"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_scalar_api-client-react_dist_index_js"],{

/***/ "(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/index.css":
/*!**************************************************************!*\
  !*** ./node_modules/@scalar/api-client-react/dist/index.css ***!
  \**************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"32f2561f9c5f\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2NhbGFyL2FwaS1jbGllbnQtcmVhY3QvZGlzdC9pbmRleC5jc3MiLCJtYXBwaW5ncyI6IjtBQUFBLCtEQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac2NhbGFyL2FwaS1jbGllbnQtcmVhY3QvZGlzdC9pbmRleC5jc3M/NzA2MyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjMyZjI1NjFmOWM1ZlwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/index.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/index-DG086FZT.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@scalar/api-client-react/dist/index-DG086FZT.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: function() { return /* binding */ Ij; },\n/* harmony export */   a: function() { return /* binding */ D; },\n/* harmony export */   b: function() { return /* binding */ Wl; },\n/* harmony export */   c: function() { return /* binding */ ne; },\n/* harmony export */   d: function() { return /* binding */ Ej; },\n/* harmony export */   o: function() { return /* binding */ Z; }\n/* harmony export */ });\n/* harmony import */ var _index_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.css */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/index.css\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n\nvar ih = { exports: {} }, la = {};\n/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar im;\nfunction C_() {\n  if (im)\n    return la;\n  im = 1;\n  var t = react__WEBPACK_IMPORTED_MODULE_1__, e = Symbol.for(\"react.element\"), n = Symbol.for(\"react.fragment\"), r = Object.prototype.hasOwnProperty, i = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, s = { key: !0, ref: !0, __self: !0, __source: !0 };\n  function o(a, l, c) {\n    var u, d = {}, f = null, h = null;\n    c !== void 0 && (f = \"\" + c), l.key !== void 0 && (f = \"\" + l.key), l.ref !== void 0 && (h = l.ref);\n    for (u in l)\n      r.call(l, u) && !s.hasOwnProperty(u) && (d[u] = l[u]);\n    if (a && a.defaultProps)\n      for (u in l = a.defaultProps, l)\n        d[u] === void 0 && (d[u] = l[u]);\n    return { $$typeof: e, type: a, key: f, ref: h, props: d, _owner: i.current };\n  }\n  return la.Fragment = n, la.jsx = o, la.jsxs = o, la;\n}\nvar ca = {};\n/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar sm;\nfunction A_() {\n  return sm || (sm = 1,  true && function() {\n    var t = react__WEBPACK_IMPORTED_MODULE_1__, e = Symbol.for(\"react.element\"), n = Symbol.for(\"react.portal\"), r = Symbol.for(\"react.fragment\"), i = Symbol.for(\"react.strict_mode\"), s = Symbol.for(\"react.profiler\"), o = Symbol.for(\"react.provider\"), a = Symbol.for(\"react.context\"), l = Symbol.for(\"react.forward_ref\"), c = Symbol.for(\"react.suspense\"), u = Symbol.for(\"react.suspense_list\"), d = Symbol.for(\"react.memo\"), f = Symbol.for(\"react.lazy\"), h = Symbol.for(\"react.offscreen\"), p = Symbol.iterator, O = \"@@iterator\";\n    function m(E) {\n      if (E === null || typeof E != \"object\")\n        return null;\n      var q = p && E[p] || E[O];\n      return typeof q == \"function\" ? q : null;\n    }\n    var y = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n    function b(E) {\n      {\n        for (var q = arguments.length, oe = new Array(q > 1 ? q - 1 : 0), xe = 1; xe < q; xe++)\n          oe[xe - 1] = arguments[xe];\n        g(\"error\", E, oe);\n      }\n    }\n    function g(E, q, oe) {\n      {\n        var xe = y.ReactDebugCurrentFrame, qe = xe.getStackAddendum();\n        qe !== \"\" && (q += \"%s\", oe = oe.concat([qe]));\n        var nt = oe.map(function(We) {\n          return String(We);\n        });\n        nt.unshift(\"Warning: \" + q), Function.prototype.apply.call(console[E], console, nt);\n      }\n    }\n    var v = !1, S = !1, w = !1, k = !1, _ = !1, T;\n    T = Symbol.for(\"react.module.reference\");\n    function C(E) {\n      return !!(typeof E == \"string\" || typeof E == \"function\" || E === r || E === s || _ || E === i || E === c || E === u || k || E === h || v || S || w || typeof E == \"object\" && E !== null && (E.$$typeof === f || E.$$typeof === d || E.$$typeof === o || E.$$typeof === a || E.$$typeof === l || // This needs to include all possible module reference object\n      // types supported by any Flight configuration anywhere since\n      // we don't know which Flight build this will end up being used\n      // with.\n      E.$$typeof === T || E.getModuleId !== void 0));\n    }\n    function A(E, q, oe) {\n      var xe = E.displayName;\n      if (xe)\n        return xe;\n      var qe = q.displayName || q.name || \"\";\n      return qe !== \"\" ? oe + \"(\" + qe + \")\" : oe;\n    }\n    function Q(E) {\n      return E.displayName || \"Context\";\n    }\n    function W(E) {\n      if (E == null)\n        return null;\n      if (typeof E.tag == \"number\" && b(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"), typeof E == \"function\")\n        return E.displayName || E.name || null;\n      if (typeof E == \"string\")\n        return E;\n      switch (E) {\n        case r:\n          return \"Fragment\";\n        case n:\n          return \"Portal\";\n        case s:\n          return \"Profiler\";\n        case i:\n          return \"StrictMode\";\n        case c:\n          return \"Suspense\";\n        case u:\n          return \"SuspenseList\";\n      }\n      if (typeof E == \"object\")\n        switch (E.$$typeof) {\n          case a:\n            var q = E;\n            return Q(q) + \".Consumer\";\n          case o:\n            var oe = E;\n            return Q(oe._context) + \".Provider\";\n          case l:\n            return A(E, E.render, \"ForwardRef\");\n          case d:\n            var xe = E.displayName || null;\n            return xe !== null ? xe : W(E.type) || \"Memo\";\n          case f: {\n            var qe = E, nt = qe._payload, We = qe._init;\n            try {\n              return W(We(nt));\n            } catch {\n              return null;\n            }\n          }\n        }\n      return null;\n    }\n    var L = Object.assign, re = 0, Y, K, B, _e, Ce, ue, ge;\n    function Be() {\n    }\n    Be.__reactDisabledLog = !0;\n    function Le() {\n      {\n        if (re === 0) {\n          Y = console.log, K = console.info, B = console.warn, _e = console.error, Ce = console.group, ue = console.groupCollapsed, ge = console.groupEnd;\n          var E = {\n            configurable: !0,\n            enumerable: !0,\n            value: Be,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            info: E,\n            log: E,\n            warn: E,\n            error: E,\n            group: E,\n            groupCollapsed: E,\n            groupEnd: E\n          });\n        }\n        re++;\n      }\n    }\n    function Zt() {\n      {\n        if (re--, re === 0) {\n          var E = {\n            configurable: !0,\n            enumerable: !0,\n            writable: !0\n          };\n          Object.defineProperties(console, {\n            log: L({}, E, {\n              value: Y\n            }),\n            info: L({}, E, {\n              value: K\n            }),\n            warn: L({}, E, {\n              value: B\n            }),\n            error: L({}, E, {\n              value: _e\n            }),\n            group: L({}, E, {\n              value: Ce\n            }),\n            groupCollapsed: L({}, E, {\n              value: ue\n            }),\n            groupEnd: L({}, E, {\n              value: ge\n            })\n          });\n        }\n        re < 0 && b(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n      }\n    }\n    var Vt = y.ReactCurrentDispatcher, It;\n    function Tn(E, q, oe) {\n      {\n        if (It === void 0)\n          try {\n            throw Error();\n          } catch (qe) {\n            var xe = qe.stack.trim().match(/\\n( *(at )?)/);\n            It = xe && xe[1] || \"\";\n          }\n        return `\n` + It + E;\n      }\n    }\n    var Sr = !1, or;\n    {\n      var En = typeof WeakMap == \"function\" ? WeakMap : Map;\n      or = new En();\n    }\n    function vi(E, q) {\n      if (!E || Sr)\n        return \"\";\n      {\n        var oe = or.get(E);\n        if (oe !== void 0)\n          return oe;\n      }\n      var xe;\n      Sr = !0;\n      var qe = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var nt;\n      nt = Vt.current, Vt.current = null, Le();\n      try {\n        if (q) {\n          var We = function() {\n            throw Error();\n          };\n          if (Object.defineProperty(We.prototype, \"props\", {\n            set: function() {\n              throw Error();\n            }\n          }), typeof Reflect == \"object\" && Reflect.construct) {\n            try {\n              Reflect.construct(We, []);\n            } catch (qr) {\n              xe = qr;\n            }\n            Reflect.construct(E, [], We);\n          } else {\n            try {\n              We.call();\n            } catch (qr) {\n              xe = qr;\n            }\n            E.call(We.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (qr) {\n            xe = qr;\n          }\n          E();\n        }\n      } catch (qr) {\n        if (qr && xe && typeof qr.stack == \"string\") {\n          for (var Ne = qr.stack.split(`\n`), dn = xe.stack.split(`\n`), St = Ne.length - 1, $t = dn.length - 1; St >= 1 && $t >= 0 && Ne[St] !== dn[$t]; )\n            $t--;\n          for (; St >= 1 && $t >= 0; St--, $t--)\n            if (Ne[St] !== dn[$t]) {\n              if (St !== 1 || $t !== 1)\n                do\n                  if (St--, $t--, $t < 0 || Ne[St] !== dn[$t]) {\n                    var qn = `\n` + Ne[St].replace(\" at new \", \" at \");\n                    return E.displayName && qn.includes(\"<anonymous>\") && (qn = qn.replace(\"<anonymous>\", E.displayName)), typeof E == \"function\" && or.set(E, qn), qn;\n                  }\n                while (St >= 1 && $t >= 0);\n              break;\n            }\n        }\n      } finally {\n        Sr = !1, Vt.current = nt, Zt(), Error.prepareStackTrace = qe;\n      }\n      var so = E ? E.displayName || E.name : \"\", rm = so ? Tn(so) : \"\";\n      return typeof E == \"function\" && or.set(E, rm), rm;\n    }\n    function Ur(E, q, oe) {\n      return vi(E, !1);\n    }\n    function x(E) {\n      var q = E.prototype;\n      return !!(q && q.isReactComponent);\n    }\n    function $(E, q, oe) {\n      if (E == null)\n        return \"\";\n      if (typeof E == \"function\")\n        return vi(E, x(E));\n      if (typeof E == \"string\")\n        return Tn(E);\n      switch (E) {\n        case c:\n          return Tn(\"Suspense\");\n        case u:\n          return Tn(\"SuspenseList\");\n      }\n      if (typeof E == \"object\")\n        switch (E.$$typeof) {\n          case l:\n            return Ur(E.render);\n          case d:\n            return $(E.type, q, oe);\n          case f: {\n            var xe = E, qe = xe._payload, nt = xe._init;\n            try {\n              return $(nt(qe), q, oe);\n            } catch {\n            }\n          }\n        }\n      return \"\";\n    }\n    var N = Object.prototype.hasOwnProperty, M = {}, X = y.ReactDebugCurrentFrame;\n    function z(E) {\n      if (E) {\n        var q = E._owner, oe = $(E.type, E._source, q ? q.type : null);\n        X.setExtraStackFrame(oe);\n      } else\n        X.setExtraStackFrame(null);\n    }\n    function ee(E, q, oe, xe, qe) {\n      {\n        var nt = Function.call.bind(N);\n        for (var We in E)\n          if (nt(E, We)) {\n            var Ne = void 0;\n            try {\n              if (typeof E[We] != \"function\") {\n                var dn = Error((xe || \"React class\") + \": \" + oe + \" type `\" + We + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof E[We] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                throw dn.name = \"Invariant Violation\", dn;\n              }\n              Ne = E[We](q, We, xe, oe, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n            } catch (St) {\n              Ne = St;\n            }\n            Ne && !(Ne instanceof Error) && (z(qe), b(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\", xe || \"React class\", oe, We, typeof Ne), z(null)), Ne instanceof Error && !(Ne.message in M) && (M[Ne.message] = !0, z(qe), b(\"Failed %s type: %s\", oe, Ne.message), z(null));\n          }\n      }\n    }\n    var H = Array.isArray;\n    function F(E) {\n      return H(E);\n    }\n    function U(E) {\n      {\n        var q = typeof Symbol == \"function\" && Symbol.toStringTag, oe = q && E[Symbol.toStringTag] || E.constructor.name || \"Object\";\n        return oe;\n      }\n    }\n    function se(E) {\n      try {\n        return me(E), !1;\n      } catch {\n        return !0;\n      }\n    }\n    function me(E) {\n      return \"\" + E;\n    }\n    function he(E) {\n      if (se(E))\n        return b(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\", U(E)), me(E);\n    }\n    var ye = y.ReactCurrentOwner, Qe = {\n      key: !0,\n      ref: !0,\n      __self: !0,\n      __source: !0\n    }, Ue, tt, bt;\n    bt = {};\n    function $n(E) {\n      if (N.call(E, \"ref\")) {\n        var q = Object.getOwnPropertyDescriptor(E, \"ref\").get;\n        if (q && q.isReactWarning)\n          return !1;\n      }\n      return E.ref !== void 0;\n    }\n    function yi(E) {\n      if (N.call(E, \"key\")) {\n        var q = Object.getOwnPropertyDescriptor(E, \"key\").get;\n        if (q && q.isReactWarning)\n          return !1;\n      }\n      return E.key !== void 0;\n    }\n    function ac(E, q) {\n      if (typeof E.ref == \"string\" && ye.current && q && ye.current.stateNode !== q) {\n        var oe = W(ye.current.type);\n        bt[oe] || (b('Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', W(ye.current.type), E.ref), bt[oe] = !0);\n      }\n    }\n    function ps(E, q) {\n      {\n        var oe = function() {\n          Ue || (Ue = !0, b(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", q));\n        };\n        oe.isReactWarning = !0, Object.defineProperty(E, \"key\", {\n          get: oe,\n          configurable: !0\n        });\n      }\n    }\n    function lc(E, q) {\n      {\n        var oe = function() {\n          tt || (tt = !0, b(\"%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", q));\n        };\n        oe.isReactWarning = !0, Object.defineProperty(E, \"ref\", {\n          get: oe,\n          configurable: !0\n        });\n      }\n    }\n    var Lt = function(E, q, oe, xe, qe, nt, We) {\n      var Ne = {\n        // This tag allows us to uniquely identify this as a React Element\n        $$typeof: e,\n        // Built-in properties that belong on the element\n        type: E,\n        key: q,\n        ref: oe,\n        props: We,\n        // Record the component responsible for creating this element.\n        _owner: nt\n      };\n      return Ne._store = {}, Object.defineProperty(Ne._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: !1\n      }), Object.defineProperty(Ne, \"_self\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: xe\n      }), Object.defineProperty(Ne, \"_source\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !1,\n        value: qe\n      }), Object.freeze && (Object.freeze(Ne.props), Object.freeze(Ne)), Ne;\n    };\n    function Un(E, q, oe, xe, qe) {\n      {\n        var nt, We = {}, Ne = null, dn = null;\n        oe !== void 0 && (he(oe), Ne = \"\" + oe), yi(q) && (he(q.key), Ne = \"\" + q.key), $n(q) && (dn = q.ref, ac(q, qe));\n        for (nt in q)\n          N.call(q, nt) && !Qe.hasOwnProperty(nt) && (We[nt] = q[nt]);\n        if (E && E.defaultProps) {\n          var St = E.defaultProps;\n          for (nt in St)\n            We[nt] === void 0 && (We[nt] = St[nt]);\n        }\n        if (Ne || dn) {\n          var $t = typeof E == \"function\" ? E.displayName || E.name || \"Unknown\" : E;\n          Ne && ps(We, $t), dn && lc(We, $t);\n        }\n        return Lt(E, Ne, dn, qe, xe, ye.current, We);\n      }\n    }\n    var ro = y.ReactCurrentOwner, Gg = y.ReactDebugCurrentFrame;\n    function io(E) {\n      if (E) {\n        var q = E._owner, oe = $(E.type, E._source, q ? q.type : null);\n        Gg.setExtraStackFrame(oe);\n      } else\n        Gg.setExtraStackFrame(null);\n    }\n    var nf;\n    nf = !1;\n    function rf(E) {\n      return typeof E == \"object\" && E !== null && E.$$typeof === e;\n    }\n    function Kg() {\n      {\n        if (ro.current) {\n          var E = W(ro.current.type);\n          if (E)\n            return `\n\nCheck the render method of \\`` + E + \"`.\";\n        }\n        return \"\";\n      }\n    }\n    function S_(E) {\n      {\n        if (E !== void 0) {\n          var q = E.fileName.replace(/^.*[\\\\\\/]/, \"\"), oe = E.lineNumber;\n          return `\n\nCheck your code at ` + q + \":\" + oe + \".\";\n        }\n        return \"\";\n      }\n    }\n    var Jg = {};\n    function w_(E) {\n      {\n        var q = Kg();\n        if (!q) {\n          var oe = typeof E == \"string\" ? E : E.displayName || E.name;\n          oe && (q = `\n\nCheck the top-level render call using <` + oe + \">.\");\n        }\n        return q;\n      }\n    }\n    function em(E, q) {\n      {\n        if (!E._store || E._store.validated || E.key != null)\n          return;\n        E._store.validated = !0;\n        var oe = w_(q);\n        if (Jg[oe])\n          return;\n        Jg[oe] = !0;\n        var xe = \"\";\n        E && E._owner && E._owner !== ro.current && (xe = \" It was passed a child from \" + W(E._owner.type) + \".\"), io(E), b('Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', oe, xe), io(null);\n      }\n    }\n    function tm(E, q) {\n      {\n        if (typeof E != \"object\")\n          return;\n        if (F(E))\n          for (var oe = 0; oe < E.length; oe++) {\n            var xe = E[oe];\n            rf(xe) && em(xe, q);\n          }\n        else if (rf(E))\n          E._store && (E._store.validated = !0);\n        else if (E) {\n          var qe = m(E);\n          if (typeof qe == \"function\" && qe !== E.entries)\n            for (var nt = qe.call(E), We; !(We = nt.next()).done; )\n              rf(We.value) && em(We.value, q);\n        }\n      }\n    }\n    function k_(E) {\n      {\n        var q = E.type;\n        if (q == null || typeof q == \"string\")\n          return;\n        var oe;\n        if (typeof q == \"function\")\n          oe = q.propTypes;\n        else if (typeof q == \"object\" && (q.$$typeof === l || // Note: Memo only checks outer props here.\n        // Inner props are checked in the reconciler.\n        q.$$typeof === d))\n          oe = q.propTypes;\n        else\n          return;\n        if (oe) {\n          var xe = W(q);\n          ee(oe, E.props, \"prop\", xe, E);\n        } else if (q.PropTypes !== void 0 && !nf) {\n          nf = !0;\n          var qe = W(q);\n          b(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", qe || \"Unknown\");\n        }\n        typeof q.getDefaultProps == \"function\" && !q.getDefaultProps.isReactClassApproved && b(\"getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.\");\n      }\n    }\n    function x_(E) {\n      {\n        for (var q = Object.keys(E.props), oe = 0; oe < q.length; oe++) {\n          var xe = q[oe];\n          if (xe !== \"children\" && xe !== \"key\") {\n            io(E), b(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", xe), io(null);\n            break;\n          }\n        }\n        E.ref !== null && (io(E), b(\"Invalid attribute `ref` supplied to `React.Fragment`.\"), io(null));\n      }\n    }\n    function nm(E, q, oe, xe, qe, nt) {\n      {\n        var We = C(E);\n        if (!We) {\n          var Ne = \"\";\n          (E === void 0 || typeof E == \"object\" && E !== null && Object.keys(E).length === 0) && (Ne += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\");\n          var dn = S_(qe);\n          dn ? Ne += dn : Ne += Kg();\n          var St;\n          E === null ? St = \"null\" : F(E) ? St = \"array\" : E !== void 0 && E.$$typeof === e ? (St = \"<\" + (W(E.type) || \"Unknown\") + \" />\", Ne = \" Did you accidentally export a JSX literal instead of a component?\") : St = typeof E, b(\"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\", St, Ne);\n        }\n        var $t = Un(E, q, oe, qe, nt);\n        if ($t == null)\n          return $t;\n        if (We) {\n          var qn = q.children;\n          if (qn !== void 0)\n            if (xe)\n              if (F(qn)) {\n                for (var so = 0; so < qn.length; so++)\n                  tm(qn[so], E);\n                Object.freeze && Object.freeze(qn);\n              } else\n                b(\"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\");\n            else\n              tm(qn, E);\n        }\n        return E === r ? x_($t) : k_($t), $t;\n      }\n    }\n    function P_(E, q, oe) {\n      return nm(E, q, oe, !0);\n    }\n    function __(E, q, oe) {\n      return nm(E, q, oe, !1);\n    }\n    var T_ = __, E_ = P_;\n    ca.Fragment = r, ca.jsx = T_, ca.jsxs = E_;\n  }()), ca;\n}\n false ? 0 : ih.exports = A_();\nvar Hr = ih.exports;\n/**\n* @vue/shared v3.4.21\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\nfunction Bt(t, e) {\n  const n = new Set(t.split(\",\"));\n  return e ? (r) => n.has(r.toLowerCase()) : (r) => n.has(r);\n}\nconst Ve =  true ? Object.freeze({}) : 0, mo =  true ? Object.freeze([]) : 0, it = () => {\n}, zc = () => !1, oi = (t) => t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && // uppercase letter\n(t.charCodeAt(2) > 122 || t.charCodeAt(2) < 97), mu = (t) => t.startsWith(\"onUpdate:\"), $e = Object.assign, Fp = (t, e) => {\n  const n = t.indexOf(e);\n  n > -1 && t.splice(n, 1);\n}, R_ = Object.prototype.hasOwnProperty, Ae = (t, e) => R_.call(t, e), ie = Array.isArray, Cs = (t) => ea(t) === \"[object Map]\", Gs = (t) => ea(t) === \"[object Set]\", om = (t) => ea(t) === \"[object Date]\", N_ = (t) => ea(t) === \"[object RegExp]\", be = (t) => typeof t == \"function\", we = (t) => typeof t == \"string\", Or = (t) => typeof t == \"symbol\", Ze = (t) => t !== null && typeof t == \"object\", dd = (t) => (Ze(t) || be(t)) && be(t.then) && be(t.catch), hy = Object.prototype.toString, ea = (t) => hy.call(t), Gp = (t) => ea(t).slice(8, -1), py = (t) => ea(t) === \"[object Object]\", Kp = (t) => we(t) && t !== \"NaN\" && t[0] !== \"-\" && \"\" + parseInt(t, 10) === t, Ui = /* @__PURE__ */ Bt(\n  // the leading comma is intentional so empty string \"\" is also included\n  \",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted\"\n), Oy = /* @__PURE__ */ Bt(\n  \"bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo\"\n), fd = (t) => {\n  const e = /* @__PURE__ */ Object.create(null);\n  return (n) => e[n] || (e[n] = t(n));\n}, D_ = /-(\\w)/g, mt = fd((t) => t.replace(D_, (e, n) => n ? n.toUpperCase() : \"\")), Z_ = /\\B([A-Z])/g, rn = fd(\n  (t) => t.replace(Z_, \"-$1\").toLowerCase()\n), Wr = fd((t) => t.charAt(0).toUpperCase() + t.slice(1)), Tr = fd((t) => t ? `on${Wr(t)}` : \"\"), gr = (t, e) => !Object.is(t, e), Ii = (t, e) => {\n  for (let n = 0; n < t.length; n++)\n    t[n](e);\n}, bu = (t, e, n) => {\n  Object.defineProperty(t, e, {\n    configurable: !0,\n    enumerable: !1,\n    value: n\n  });\n}, Ka = (t) => {\n  const e = parseFloat(t);\n  return isNaN(e) ? t : e;\n}, vu = (t) => {\n  const e = we(t) ? Number(t) : NaN;\n  return isNaN(e) ? t : e;\n};\nlet am;\nconst bo = () => am || (am = typeof globalThis < \"u\" ? globalThis : typeof self < \"u\" ? self : typeof window < \"u\" ? window : typeof global < \"u\" ? global : {}), Dr = {\n  1: \"TEXT\",\n  2: \"CLASS\",\n  4: \"STYLE\",\n  8: \"PROPS\",\n  16: \"FULL_PROPS\",\n  32: \"NEED_HYDRATION\",\n  64: \"STABLE_FRAGMENT\",\n  128: \"KEYED_FRAGMENT\",\n  256: \"UNKEYED_FRAGMENT\",\n  512: \"NEED_PATCH\",\n  1024: \"DYNAMIC_SLOTS\",\n  2048: \"DEV_ROOT_FRAGMENT\",\n  [-1]: \"HOISTED\",\n  [-2]: \"BAIL\"\n}, V_ = {\n  1: \"STABLE\",\n  2: \"DYNAMIC\",\n  3: \"FORWARDED\"\n}, I_ = \"Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error\", W_ = /* @__PURE__ */ Bt(I_), lm = 2;\nfunction M_(t, e = 0, n = t.length) {\n  let r = t.split(/(\\r?\\n)/);\n  const i = r.filter((a, l) => l % 2 === 1);\n  r = r.filter((a, l) => l % 2 === 0);\n  let s = 0;\n  const o = [];\n  for (let a = 0; a < r.length; a++)\n    if (s += r[a].length + (i[a] && i[a].length || 0), s >= e) {\n      for (let l = a - lm; l <= a + lm || n > s; l++) {\n        if (l < 0 || l >= r.length)\n          continue;\n        const c = l + 1;\n        o.push(\n          `${c}${\" \".repeat(Math.max(3 - String(c).length, 0))}|  ${r[l]}`\n        );\n        const u = r[l].length, d = i[l] && i[l].length || 0;\n        if (l === a) {\n          const f = e - (s - (u + d)), h = Math.max(\n            1,\n            n > s ? u - f : n - e\n          );\n          o.push(\"   |  \" + \" \".repeat(f) + \"^\".repeat(h));\n        } else if (l > a) {\n          if (n > s) {\n            const f = Math.max(Math.min(n - s, u), 1);\n            o.push(\"   |  \" + \"^\".repeat(f));\n          }\n          s += u + d;\n        }\n      }\n      break;\n    }\n  return o.join(`\n`);\n}\nfunction Br(t) {\n  if (ie(t)) {\n    const e = {};\n    for (let n = 0; n < t.length; n++) {\n      const r = t[n], i = we(r) ? gy(r) : Br(r);\n      if (i)\n        for (const s in i)\n          e[s] = i[s];\n    }\n    return e;\n  } else if (we(t) || Ze(t))\n    return t;\n}\nconst X_ = /;(?![^(]*\\))/g, j_ = /:([^]+)/, B_ = /\\/\\*[^]*?\\*\\//g;\nfunction gy(t) {\n  const e = {};\n  return t.replace(B_, \"\").split(X_).forEach((n) => {\n    if (n) {\n      const r = n.split(j_);\n      r.length > 1 && (e[r[0].trim()] = r[1].trim());\n    }\n  }), e;\n}\nfunction L_(t) {\n  let e = \"\";\n  if (!t || we(t))\n    return e;\n  for (const n in t) {\n    const r = t[n], i = n.startsWith(\"--\") ? n : rn(n);\n    (we(r) || typeof r == \"number\") && (e += `${i}:${r};`);\n  }\n  return e;\n}\nfunction Ke(t) {\n  let e = \"\";\n  if (we(t))\n    e = t;\n  else if (ie(t))\n    for (let n = 0; n < t.length; n++) {\n      const r = Ke(t[n]);\n      r && (e += r + \" \");\n    }\n  else if (Ze(t))\n    for (const n in t)\n      t[n] && (e += n + \" \");\n  return e.trim();\n}\nfunction my(t) {\n  if (!t)\n    return null;\n  let { class: e, style: n } = t;\n  return e && !we(e) && (t.class = Ke(e)), n && (t.style = Br(n)), t;\n}\nconst U_ = \"html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot\", q_ = \"svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view\", Y_ = \"annotation,annotation-xml,maction,maligngroup,malignmark,math,menclose,merror,mfenced,mfrac,mfraction,mglyph,mi,mlabeledtr,mlongdiv,mmultiscripts,mn,mo,mover,mpadded,mphantom,mprescripts,mroot,mrow,ms,mscarries,mscarry,msgroup,msline,mspace,msqrt,msrow,mstack,mstyle,msub,msubsup,msup,mtable,mtd,mtext,mtr,munder,munderover,none,semantics\", z_ = \"area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr\", by = /* @__PURE__ */ Bt(U_), vy = /* @__PURE__ */ Bt(q_), yy = /* @__PURE__ */ Bt(Y_), H_ = /* @__PURE__ */ Bt(z_), Sy = \"itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly\", F_ = /* @__PURE__ */ Bt(Sy), cm = /* @__PURE__ */ Bt(\n  Sy + \",async,autofocus,autoplay,controls,default,defer,disabled,hidden,inert,loop,open,required,reversed,scoped,seamless,checked,muted,multiple,selected\"\n);\nfunction Jp(t) {\n  return !!t || t === \"\";\n}\nconst G_ = /* @__PURE__ */ Bt(\n  \"accept,accept-charset,accesskey,action,align,allow,alt,async,autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,border,buffered,capture,challenge,charset,checked,cite,class,code,codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,formaction,formenctype,formmethod,formnovalidate,formtarget,headers,height,hidden,high,href,hreflang,http-equiv,icon,id,importance,inert,integrity,ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,target,title,translate,type,usemap,value,width,wrap\"\n), K_ = /* @__PURE__ */ Bt(\n  \"xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,font-style,font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,overflow,overline-position,overline-thickness,panose-1,paint-order,path,pathLength,patternContentUnits,patternTransform,patternUnits,ping,pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,specularConstant,specularExponent,speed,spreadMethod,startOffset,stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,string,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,text-decoration,text-rendering,textLength,to,transform,transform-origin,type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xmlns:xlink,xml:base,xml:lang,xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan\"\n);\nfunction J_(t) {\n  if (t == null)\n    return !1;\n  const e = typeof t;\n  return e === \"string\" || e === \"number\" || e === \"boolean\";\n}\nfunction eT(t, e) {\n  if (t.length !== e.length)\n    return !1;\n  let n = !0;\n  for (let r = 0; n && r < t.length; r++)\n    n = ts(t[r], e[r]);\n  return n;\n}\nfunction ts(t, e) {\n  if (t === e)\n    return !0;\n  let n = om(t), r = om(e);\n  if (n || r)\n    return n && r ? t.getTime() === e.getTime() : !1;\n  if (n = Or(t), r = Or(e), n || r)\n    return t === e;\n  if (n = ie(t), r = ie(e), n || r)\n    return n && r ? eT(t, e) : !1;\n  if (n = Ze(t), r = Ze(e), n || r) {\n    if (!n || !r)\n      return !1;\n    const i = Object.keys(t).length, s = Object.keys(e).length;\n    if (i !== s)\n      return !1;\n    for (const o in t) {\n      const a = t.hasOwnProperty(o), l = e.hasOwnProperty(o);\n      if (a && !l || !a && l || !ts(t[o], e[o]))\n        return !1;\n    }\n  }\n  return String(t) === String(e);\n}\nfunction hd(t, e) {\n  return t.findIndex((n) => ts(n, e));\n}\nconst De = (t) => we(t) ? t : t == null ? \"\" : ie(t) || Ze(t) && (t.toString === hy || !be(t.toString)) ? JSON.stringify(t, wy, 2) : String(t), wy = (t, e) => e && e.__v_isRef ? wy(t, e.value) : Cs(e) ? {\n  [`Map(${e.size})`]: [...e.entries()].reduce(\n    (n, [r, i], s) => (n[sf(r, s) + \" =>\"] = i, n),\n    {}\n  )\n} : Gs(e) ? {\n  [`Set(${e.size})`]: [...e.values()].map((n) => sf(n))\n} : Or(e) ? sf(e) : Ze(e) && !ie(e) && !py(e) ? String(e) : e, sf = (t, e = \"\") => {\n  var n;\n  return Or(t) ? `Symbol(${(n = t.description) != null ? n : e})` : t;\n};\n/**\n* @vue/reactivity v3.4.21\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\nfunction Mr(t, ...e) {\n  console.warn(`[Vue warn] ${t}`, ...e);\n}\nlet An;\nclass eO {\n  constructor(e = !1) {\n    this.detached = e, this._active = !0, this.effects = [], this.cleanups = [], this.parent = An, !e && An && (this.index = (An.scopes || (An.scopes = [])).push(\n      this\n    ) - 1);\n  }\n  get active() {\n    return this._active;\n  }\n  run(e) {\n    if (this._active) {\n      const n = An;\n      try {\n        return An = this, e();\n      } finally {\n        An = n;\n      }\n    } else\n       true && Mr(\"cannot run an inactive effect scope.\");\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  on() {\n    An = this;\n  }\n  /**\n   * This should only be called on non-detached scopes\n   * @internal\n   */\n  off() {\n    An = this.parent;\n  }\n  stop(e) {\n    if (this._active) {\n      let n, r;\n      for (n = 0, r = this.effects.length; n < r; n++)\n        this.effects[n].stop();\n      for (n = 0, r = this.cleanups.length; n < r; n++)\n        this.cleanups[n]();\n      if (this.scopes)\n        for (n = 0, r = this.scopes.length; n < r; n++)\n          this.scopes[n].stop(!0);\n      if (!this.detached && this.parent && !e) {\n        const i = this.parent.scopes.pop();\n        i && i !== this && (this.parent.scopes[this.index] = i, i.index = this.index);\n      }\n      this.parent = void 0, this._active = !1;\n    }\n  }\n}\nfunction tT(t) {\n  return new eO(t);\n}\nfunction ky(t, e = An) {\n  e && e.active && e.effects.push(t);\n}\nfunction Rl() {\n  return An;\n}\nfunction tO(t) {\n  An ? An.cleanups.push(t) :  true && Mr(\n    \"onScopeDispose() is called when there is no active effect scope to be associated with.\"\n  );\n}\nlet As;\nclass Ao {\n  constructor(e, n, r, i) {\n    this.fn = e, this.trigger = n, this.scheduler = r, this.active = !0, this.deps = [], this._dirtyLevel = 4, this._trackId = 0, this._runnings = 0, this._shouldSchedule = !1, this._depsLength = 0, ky(this, i);\n  }\n  get dirty() {\n    if (this._dirtyLevel === 2 || this._dirtyLevel === 3) {\n      this._dirtyLevel = 1, ds();\n      for (let e = 0; e < this._depsLength; e++) {\n        const n = this.deps[e];\n        if (n.computed && (nT(n.computed), this._dirtyLevel >= 4))\n          break;\n      }\n      this._dirtyLevel === 1 && (this._dirtyLevel = 0), fs();\n    }\n    return this._dirtyLevel >= 4;\n  }\n  set dirty(e) {\n    this._dirtyLevel = e ? 4 : 0;\n  }\n  run() {\n    if (this._dirtyLevel = 0, !this.active)\n      return this.fn();\n    let e = qi, n = As;\n    try {\n      return qi = !0, As = this, this._runnings++, um(this), this.fn();\n    } finally {\n      dm(this), this._runnings--, As = n, qi = e;\n    }\n  }\n  stop() {\n    var e;\n    this.active && (um(this), dm(this), (e = this.onStop) == null || e.call(this), this.active = !1);\n  }\n}\nfunction nT(t) {\n  return t.value;\n}\nfunction um(t) {\n  t._trackId++, t._depsLength = 0;\n}\nfunction dm(t) {\n  if (t.deps.length > t._depsLength) {\n    for (let e = t._depsLength; e < t.deps.length; e++)\n      xy(t.deps[e], t);\n    t.deps.length = t._depsLength;\n  }\n}\nfunction xy(t, e) {\n  const n = t.get(e);\n  n !== void 0 && e._trackId !== n && (t.delete(e), t.size === 0 && t.cleanup());\n}\nfunction rT(t, e) {\n  t.effect instanceof Ao && (t = t.effect.fn);\n  const n = new Ao(t, it, () => {\n    n.dirty && n.run();\n  });\n  e && ($e(n, e), e.scope && ky(n, e.scope)), (!e || !e.lazy) && n.run();\n  const r = n.run.bind(n);\n  return r.effect = n, r;\n}\nfunction iT(t) {\n  t.effect.stop();\n}\nlet qi = !0, sh = 0;\nconst Py = [];\nfunction ds() {\n  Py.push(qi), qi = !1;\n}\nfunction fs() {\n  const t = Py.pop();\n  qi = t === void 0 ? !0 : t;\n}\nfunction nO() {\n  sh++;\n}\nfunction rO() {\n  for (sh--; !sh && oh.length; )\n    oh.shift()();\n}\nfunction _y(t, e, n) {\n  var r;\n  if (e.get(t) !== t._trackId) {\n    e.set(t, t._trackId);\n    const i = t.deps[t._depsLength];\n    i !== e ? (i && xy(i, t), t.deps[t._depsLength++] = e) : t._depsLength++,  true && ((r = t.onTrack) == null || r.call(t, $e({ effect: t }, n)));\n  }\n}\nconst oh = [];\nfunction Ty(t, e, n) {\n  var r;\n  nO();\n  for (const i of t.keys()) {\n    let s;\n    i._dirtyLevel < e && (s ?? (s = t.get(i) === i._trackId)) && (i._shouldSchedule || (i._shouldSchedule = i._dirtyLevel === 0), i._dirtyLevel = e), i._shouldSchedule && (s ?? (s = t.get(i) === i._trackId)) && ( true && ((r = i.onTrigger) == null || r.call(i, $e({ effect: i }, n))), i.trigger(), (!i._runnings || i.allowRecurse) && i._dirtyLevel !== 2 && (i._shouldSchedule = !1, i.scheduler && oh.push(i.scheduler)));\n  }\n  rO();\n}\nconst Ey = (t, e) => {\n  const n = /* @__PURE__ */ new Map();\n  return n.cleanup = t, n.computed = e, n;\n}, yu = /* @__PURE__ */ new WeakMap(), Rs = Symbol( true ? \"iterate\" : 0), ah = Symbol( true ? \"Map key iterate\" : 0);\nfunction Kt(t, e, n) {\n  if (qi && As) {\n    let r = yu.get(t);\n    r || yu.set(t, r = /* @__PURE__ */ new Map());\n    let i = r.get(n);\n    i || r.set(n, i = Ey(() => r.delete(n))), _y(\n      As,\n      i,\n       true ? {\n        target: t,\n        type: e,\n        key: n\n      } : 0\n    );\n  }\n}\nfunction Zr(t, e, n, r, i, s) {\n  const o = yu.get(t);\n  if (!o)\n    return;\n  let a = [];\n  if (e === \"clear\")\n    a = [...o.values()];\n  else if (n === \"length\" && ie(t)) {\n    const l = Number(r);\n    o.forEach((c, u) => {\n      (u === \"length\" || !Or(u) && u >= l) && a.push(c);\n    });\n  } else\n    switch (n !== void 0 && a.push(o.get(n)), e) {\n      case \"add\":\n        ie(t) ? Kp(n) && a.push(o.get(\"length\")) : (a.push(o.get(Rs)), Cs(t) && a.push(o.get(ah)));\n        break;\n      case \"delete\":\n        ie(t) || (a.push(o.get(Rs)), Cs(t) && a.push(o.get(ah)));\n        break;\n      case \"set\":\n        Cs(t) && a.push(o.get(Rs));\n        break;\n    }\n  nO();\n  for (const l of a)\n    l && Ty(\n      l,\n      4,\n       true ? {\n        target: t,\n        type: e,\n        key: n,\n        newValue: r,\n        oldValue: i,\n        oldTarget: s\n      } : 0\n    );\n  rO();\n}\nfunction sT(t, e) {\n  var n;\n  return (n = yu.get(t)) == null ? void 0 : n.get(e);\n}\nconst oT = /* @__PURE__ */ Bt(\"__proto__,__v_isRef,__isVue\"), $y = new Set(\n  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((t) => t !== \"arguments\" && t !== \"caller\").map((t) => Symbol[t]).filter(Or)\n), fm = /* @__PURE__ */ aT();\nfunction aT() {\n  const t = {};\n  return [\"includes\", \"indexOf\", \"lastIndexOf\"].forEach((e) => {\n    t[e] = function(...n) {\n      const r = Oe(this);\n      for (let s = 0, o = this.length; s < o; s++)\n        Kt(r, \"get\", s + \"\");\n      const i = r[e](...n);\n      return i === -1 || i === !1 ? r[e](...n.map(Oe)) : i;\n    };\n  }), [\"push\", \"pop\", \"shift\", \"unshift\", \"splice\"].forEach((e) => {\n    t[e] = function(...n) {\n      ds(), nO();\n      const r = Oe(this)[e].apply(this, n);\n      return rO(), fs(), r;\n    };\n  }), t;\n}\nfunction lT(t) {\n  const e = Oe(this);\n  return Kt(e, \"has\", t), e.hasOwnProperty(t);\n}\nclass Qy {\n  constructor(e = !1, n = !1) {\n    this._isReadonly = e, this._isShallow = n;\n  }\n  get(e, n, r) {\n    const i = this._isReadonly, s = this._isShallow;\n    if (n === \"__v_isReactive\")\n      return !i;\n    if (n === \"__v_isReadonly\")\n      return i;\n    if (n === \"__v_isShallow\")\n      return s;\n    if (n === \"__v_raw\")\n      return r === (i ? s ? Vy : Zy : s ? Dy : Ny).get(e) || // receiver is not the reactive proxy, but has the same prototype\n      // this means the reciever is a user proxy of the reactive proxy\n      Object.getPrototypeOf(e) === Object.getPrototypeOf(r) ? e : void 0;\n    const o = ie(e);\n    if (!i) {\n      if (o && Ae(fm, n))\n        return Reflect.get(fm, n, r);\n      if (n === \"hasOwnProperty\")\n        return lT;\n    }\n    const a = Reflect.get(e, n, r);\n    return (Or(n) ? $y.has(n) : oT(n)) || (i || Kt(e, \"get\", n), s) ? a : Ct(a) ? o && Kp(n) ? a : a.value : Ze(a) ? i ? sO(a) : Xn(a) : a;\n  }\n}\nclass Cy extends Qy {\n  constructor(e = !1) {\n    super(!1, e);\n  }\n  set(e, n, r, i) {\n    let s = e[n];\n    if (!this._isShallow) {\n      const l = ai(s);\n      if (!zi(r) && !ai(r) && (s = Oe(s), r = Oe(r)), !ie(e) && Ct(s) && !Ct(r))\n        return l ? !1 : (s.value = r, !0);\n    }\n    const o = ie(e) && Kp(n) ? Number(n) < e.length : Ae(e, n), a = Reflect.set(e, n, r, i);\n    return e === Oe(i) && (o ? gr(r, s) && Zr(e, \"set\", n, r, s) : Zr(e, \"add\", n, r)), a;\n  }\n  deleteProperty(e, n) {\n    const r = Ae(e, n), i = e[n], s = Reflect.deleteProperty(e, n);\n    return s && r && Zr(e, \"delete\", n, void 0, i), s;\n  }\n  has(e, n) {\n    const r = Reflect.has(e, n);\n    return (!Or(n) || !$y.has(n)) && Kt(e, \"has\", n), r;\n  }\n  ownKeys(e) {\n    return Kt(\n      e,\n      \"iterate\",\n      ie(e) ? \"length\" : Rs\n    ), Reflect.ownKeys(e);\n  }\n}\nclass Ay extends Qy {\n  constructor(e = !1) {\n    super(!0, e);\n  }\n  set(e, n) {\n    return  true && Mr(\n      `Set operation on key \"${String(n)}\" failed: target is readonly.`,\n      e\n    ), !0;\n  }\n  deleteProperty(e, n) {\n    return  true && Mr(\n      `Delete operation on key \"${String(n)}\" failed: target is readonly.`,\n      e\n    ), !0;\n  }\n}\nconst cT = /* @__PURE__ */ new Cy(), uT = /* @__PURE__ */ new Ay(), dT = /* @__PURE__ */ new Cy(\n  !0\n), fT = /* @__PURE__ */ new Ay(!0), iO = (t) => t, pd = (t) => Reflect.getPrototypeOf(t);\nfunction cc(t, e, n = !1, r = !1) {\n  t = t.__v_raw;\n  const i = Oe(t), s = Oe(e);\n  n || (gr(e, s) && Kt(i, \"get\", e), Kt(i, \"get\", s));\n  const { has: o } = pd(i), a = r ? iO : n ? aO : el;\n  if (o.call(i, e))\n    return a(t.get(e));\n  if (o.call(i, s))\n    return a(t.get(s));\n  t !== i && t.get(e);\n}\nfunction uc(t, e = !1) {\n  const n = this.__v_raw, r = Oe(n), i = Oe(t);\n  return e || (gr(t, i) && Kt(r, \"has\", t), Kt(r, \"has\", i)), t === i ? n.has(t) : n.has(t) || n.has(i);\n}\nfunction dc(t, e = !1) {\n  return t = t.__v_raw, !e && Kt(Oe(t), \"iterate\", Rs), Reflect.get(t, \"size\", t);\n}\nfunction hm(t) {\n  t = Oe(t);\n  const e = Oe(this);\n  return pd(e).has.call(e, t) || (e.add(t), Zr(e, \"add\", t, t)), this;\n}\nfunction pm(t, e) {\n  e = Oe(e);\n  const n = Oe(this), { has: r, get: i } = pd(n);\n  let s = r.call(n, t);\n  s ?  true && Ry(n, r, t) : (t = Oe(t), s = r.call(n, t));\n  const o = i.call(n, t);\n  return n.set(t, e), s ? gr(e, o) && Zr(n, \"set\", t, e, o) : Zr(n, \"add\", t, e), this;\n}\nfunction Om(t) {\n  const e = Oe(this), { has: n, get: r } = pd(e);\n  let i = n.call(e, t);\n  i ?  true && Ry(e, n, t) : (t = Oe(t), i = n.call(e, t));\n  const s = r ? r.call(e, t) : void 0, o = e.delete(t);\n  return i && Zr(e, \"delete\", t, void 0, s), o;\n}\nfunction gm() {\n  const t = Oe(this), e = t.size !== 0, n =  true ? Cs(t) ? new Map(t) : new Set(t) : 0, r = t.clear();\n  return e && Zr(t, \"clear\", void 0, void 0, n), r;\n}\nfunction fc(t, e) {\n  return function(r, i) {\n    const s = this, o = s.__v_raw, a = Oe(o), l = e ? iO : t ? aO : el;\n    return !t && Kt(a, \"iterate\", Rs), o.forEach((c, u) => r.call(i, l(c), l(u), s));\n  };\n}\nfunction hc(t, e, n) {\n  return function(...r) {\n    const i = this.__v_raw, s = Oe(i), o = Cs(s), a = t === \"entries\" || t === Symbol.iterator && o, l = t === \"keys\" && o, c = i[t](...r), u = n ? iO : e ? aO : el;\n    return !e && Kt(\n      s,\n      \"iterate\",\n      l ? ah : Rs\n    ), {\n      // iterator protocol\n      next() {\n        const { value: d, done: f } = c.next();\n        return f ? { value: d, done: f } : {\n          value: a ? [u(d[0]), u(d[1])] : u(d),\n          done: f\n        };\n      },\n      // iterable protocol\n      [Symbol.iterator]() {\n        return this;\n      }\n    };\n  };\n}\nfunction Si(t) {\n  return function(...e) {\n    if (true) {\n      const n = e[0] ? `on key \"${e[0]}\" ` : \"\";\n      Mr(\n        `${Wr(t)} operation ${n}failed: target is readonly.`,\n        Oe(this)\n      );\n    }\n    return t === \"delete\" ? !1 : t === \"clear\" ? void 0 : this;\n  };\n}\nfunction hT() {\n  const t = {\n    get(s) {\n      return cc(this, s);\n    },\n    get size() {\n      return dc(this);\n    },\n    has: uc,\n    add: hm,\n    set: pm,\n    delete: Om,\n    clear: gm,\n    forEach: fc(!1, !1)\n  }, e = {\n    get(s) {\n      return cc(this, s, !1, !0);\n    },\n    get size() {\n      return dc(this);\n    },\n    has: uc,\n    add: hm,\n    set: pm,\n    delete: Om,\n    clear: gm,\n    forEach: fc(!1, !0)\n  }, n = {\n    get(s) {\n      return cc(this, s, !0);\n    },\n    get size() {\n      return dc(this, !0);\n    },\n    has(s) {\n      return uc.call(this, s, !0);\n    },\n    add: Si(\"add\"),\n    set: Si(\"set\"),\n    delete: Si(\"delete\"),\n    clear: Si(\"clear\"),\n    forEach: fc(!0, !1)\n  }, r = {\n    get(s) {\n      return cc(this, s, !0, !0);\n    },\n    get size() {\n      return dc(this, !0);\n    },\n    has(s) {\n      return uc.call(this, s, !0);\n    },\n    add: Si(\"add\"),\n    set: Si(\"set\"),\n    delete: Si(\"delete\"),\n    clear: Si(\"clear\"),\n    forEach: fc(!0, !0)\n  };\n  return [\"keys\", \"values\", \"entries\", Symbol.iterator].forEach((s) => {\n    t[s] = hc(\n      s,\n      !1,\n      !1\n    ), n[s] = hc(\n      s,\n      !0,\n      !1\n    ), e[s] = hc(\n      s,\n      !1,\n      !0\n    ), r[s] = hc(\n      s,\n      !0,\n      !0\n    );\n  }), [\n    t,\n    n,\n    e,\n    r\n  ];\n}\nconst [\n  pT,\n  OT,\n  gT,\n  mT\n] = /* @__PURE__ */ hT();\nfunction Od(t, e) {\n  const n = e ? t ? mT : gT : t ? OT : pT;\n  return (r, i, s) => i === \"__v_isReactive\" ? !t : i === \"__v_isReadonly\" ? t : i === \"__v_raw\" ? r : Reflect.get(\n    Ae(n, i) && i in r ? n : r,\n    i,\n    s\n  );\n}\nconst bT = {\n  get: /* @__PURE__ */ Od(!1, !1)\n}, vT = {\n  get: /* @__PURE__ */ Od(!1, !0)\n}, yT = {\n  get: /* @__PURE__ */ Od(!0, !1)\n}, ST = {\n  get: /* @__PURE__ */ Od(!0, !0)\n};\nfunction Ry(t, e, n) {\n  const r = Oe(n);\n  if (r !== n && e.call(t, r)) {\n    const i = Gp(t);\n    Mr(\n      `Reactive ${i} contains both the raw and reactive versions of the same object${i === \"Map\" ? \" as keys\" : \"\"}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`\n    );\n  }\n}\nconst Ny = /* @__PURE__ */ new WeakMap(), Dy = /* @__PURE__ */ new WeakMap(), Zy = /* @__PURE__ */ new WeakMap(), Vy = /* @__PURE__ */ new WeakMap();\nfunction wT(t) {\n  switch (t) {\n    case \"Object\":\n    case \"Array\":\n      return 1;\n    case \"Map\":\n    case \"Set\":\n    case \"WeakMap\":\n    case \"WeakSet\":\n      return 2;\n    default:\n      return 0;\n  }\n}\nfunction kT(t) {\n  return t.__v_skip || !Object.isExtensible(t) ? 0 : wT(Gp(t));\n}\nfunction Xn(t) {\n  return ai(t) ? t : gd(\n    t,\n    !1,\n    cT,\n    bT,\n    Ny\n  );\n}\nfunction Iy(t) {\n  return gd(\n    t,\n    !1,\n    dT,\n    vT,\n    Dy\n  );\n}\nfunction sO(t) {\n  return gd(\n    t,\n    !0,\n    uT,\n    yT,\n    Zy\n  );\n}\nfunction Dn(t) {\n  return gd(\n    t,\n    !0,\n    fT,\n    ST,\n    Vy\n  );\n}\nfunction gd(t, e, n, r, i) {\n  if (!Ze(t))\n    return  true && Mr(`value cannot be made reactive: ${String(t)}`), t;\n  if (t.__v_raw && !(e && t.__v_isReactive))\n    return t;\n  const s = i.get(t);\n  if (s)\n    return s;\n  const o = kT(t);\n  if (o === 0)\n    return t;\n  const a = new Proxy(\n    t,\n    o === 2 ? r : n\n  );\n  return i.set(t, a), a;\n}\nfunction Yi(t) {\n  return ai(t) ? Yi(t.__v_raw) : !!(t && t.__v_isReactive);\n}\nfunction ai(t) {\n  return !!(t && t.__v_isReadonly);\n}\nfunction zi(t) {\n  return !!(t && t.__v_isShallow);\n}\nfunction Ja(t) {\n  return Yi(t) || ai(t);\n}\nfunction Oe(t) {\n  const e = t && t.__v_raw;\n  return e ? Oe(e) : t;\n}\nfunction oO(t) {\n  return Object.isExtensible(t) && bu(t, \"__v_skip\", !0), t;\n}\nconst el = (t) => Ze(t) ? Xn(t) : t, aO = (t) => Ze(t) ? sO(t) : t, xT = \"Computed is still dirty after getter evaluation, likely because a computed is mutating its own dependency in its getter. State mutations in computed getters should be avoided.  Check the docs for more details: https://vuejs.org/guide/essentials/computed.html#getters-should-be-side-effect-free\";\nclass Wy {\n  constructor(e, n, r, i) {\n    this.getter = e, this._setter = n, this.dep = void 0, this.__v_isRef = !0, this.__v_isReadonly = !1, this.effect = new Ao(\n      () => e(this._value),\n      () => vo(\n        this,\n        this.effect._dirtyLevel === 2 ? 2 : 3\n      )\n    ), this.effect.computed = this, this.effect.active = this._cacheable = !i, this.__v_isReadonly = r;\n  }\n  get value() {\n    const e = Oe(this);\n    return (!e._cacheable || e.effect.dirty) && gr(e._value, e._value = e.effect.run()) && vo(e, 4), lO(e), e.effect._dirtyLevel >= 2 && ( true && this._warnRecursive && Mr(xT, `\n\ngetter: `, this.getter), vo(e, 2)), e._value;\n  }\n  set value(e) {\n    this._setter(e);\n  }\n  // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x\n  get _dirty() {\n    return this.effect.dirty;\n  }\n  set _dirty(e) {\n    this.effect.dirty = e;\n  }\n  // #endregion\n}\nfunction PT(t, e, n = !1) {\n  let r, i;\n  const s = be(t);\n  s ? (r = t, i =  true ? () => {\n    Mr(\"Write operation failed: computed value is readonly\");\n  } : 0) : (r = t.get, i = t.set);\n  const o = new Wy(r, i, s || !i, n);\n  return  true && e && !n && (o.effect.onTrack = e.onTrack, o.effect.onTrigger = e.onTrigger), o;\n}\nfunction lO(t) {\n  var e;\n  qi && As && (t = Oe(t), _y(\n    As,\n    (e = t.dep) != null ? e : t.dep = Ey(\n      () => t.dep = void 0,\n      t instanceof Wy ? t : void 0\n    ),\n     true ? {\n      target: t,\n      type: \"get\",\n      key: \"value\"\n    } : 0\n  ));\n}\nfunction vo(t, e = 4, n) {\n  t = Oe(t);\n  const r = t.dep;\n  r && Ty(\n    r,\n    e,\n     true ? {\n      target: t,\n      type: \"set\",\n      key: \"value\",\n      newValue: n\n    } : 0\n  );\n}\nfunction Ct(t) {\n  return !!(t && t.__v_isRef === !0);\n}\nfunction G(t) {\n  return My(t, !1);\n}\nfunction cO(t) {\n  return My(t, !0);\n}\nfunction My(t, e) {\n  return Ct(t) ? t : new _T(t, e);\n}\nclass _T {\n  constructor(e, n) {\n    this.__v_isShallow = n, this.dep = void 0, this.__v_isRef = !0, this._rawValue = n ? e : Oe(e), this._value = n ? e : el(e);\n  }\n  get value() {\n    return lO(this), this._value;\n  }\n  set value(e) {\n    const n = this.__v_isShallow || zi(e) || ai(e);\n    e = n ? e : Oe(e), gr(e, this._rawValue) && (this._rawValue = e, this._value = n ? e : el(e), vo(this, 4, e));\n  }\n}\nfunction TT(t) {\n  vo(t, 4,  true ? t.value : 0);\n}\nfunction R(t) {\n  return Ct(t) ? t.value : t;\n}\nfunction Jt(t) {\n  return be(t) ? t() : R(t);\n}\nconst ET = {\n  get: (t, e, n) => R(Reflect.get(t, e, n)),\n  set: (t, e, n, r) => {\n    const i = t[e];\n    return Ct(i) && !Ct(n) ? (i.value = n, !0) : Reflect.set(t, e, n, r);\n  }\n};\nfunction uO(t) {\n  return Yi(t) ? t : new Proxy(t, ET);\n}\nclass $T {\n  constructor(e) {\n    this.dep = void 0, this.__v_isRef = !0;\n    const { get: n, set: r } = e(\n      () => lO(this),\n      () => vo(this)\n    );\n    this._get = n, this._set = r;\n  }\n  get value() {\n    return this._get();\n  }\n  set value(e) {\n    this._set(e);\n  }\n}\nfunction Xy(t) {\n  return new $T(t);\n}\nfunction QT(t) {\n   true && !Ja(t) && Mr(\"toRefs() expects a reactive object but received a plain one.\");\n  const e = ie(t) ? new Array(t.length) : {};\n  for (const n in t)\n    e[n] = jy(t, n);\n  return e;\n}\nclass CT {\n  constructor(e, n, r) {\n    this._object = e, this._key = n, this._defaultValue = r, this.__v_isRef = !0;\n  }\n  get value() {\n    const e = this._object[this._key];\n    return e === void 0 ? this._defaultValue : e;\n  }\n  set value(e) {\n    this._object[this._key] = e;\n  }\n  get dep() {\n    return sT(Oe(this._object), this._key);\n  }\n}\nclass AT {\n  constructor(e) {\n    this._getter = e, this.__v_isRef = !0, this.__v_isReadonly = !0;\n  }\n  get value() {\n    return this._getter();\n  }\n}\nfunction Ei(t, e, n) {\n  return Ct(t) ? t : be(t) ? new AT(t) : Ze(t) && arguments.length > 1 ? jy(t, e, n) : G(t);\n}\nfunction jy(t, e, n) {\n  const r = t[e];\n  return Ct(r) ? r : new CT(t, e, n);\n}\nconst RT = {\n  GET: \"get\",\n  HAS: \"has\",\n  ITERATE: \"iterate\"\n}, NT = {\n  SET: \"set\",\n  ADD: \"add\",\n  DELETE: \"delete\",\n  CLEAR: \"clear\"\n};\n/**\n* @vue/runtime-core v3.4.21\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\nconst Ns = [];\nfunction Ia(t) {\n  Ns.push(t);\n}\nfunction Wa() {\n  Ns.pop();\n}\nfunction I(t, ...e) {\n  ds();\n  const n = Ns.length ? Ns[Ns.length - 1].component : null, r = n && n.appContext.config.warnHandler, i = DT();\n  if (r)\n    Vr(\n      r,\n      n,\n      11,\n      [\n        t + e.map((s) => {\n          var o, a;\n          return (a = (o = s.toString) == null ? void 0 : o.call(s)) != null ? a : JSON.stringify(s);\n        }).join(\"\"),\n        n && n.proxy,\n        i.map(\n          ({ vnode: s }) => `at <${Td(n, s.type)}>`\n        ).join(`\n`),\n        i\n      ]\n    );\n  else {\n    const s = [`[Vue warn]: ${t}`, ...e];\n    i.length && s.push(`\n`, ...ZT(i)), console.warn(...s);\n  }\n  fs();\n}\nfunction DT() {\n  let t = Ns[Ns.length - 1];\n  if (!t)\n    return [];\n  const e = [];\n  for (; t; ) {\n    const n = e[0];\n    n && n.vnode === t ? n.recurseCount++ : e.push({\n      vnode: t,\n      recurseCount: 0\n    });\n    const r = t.component && t.component.parent;\n    t = r && r.vnode;\n  }\n  return e;\n}\nfunction ZT(t) {\n  const e = [];\n  return t.forEach((n, r) => {\n    e.push(...r === 0 ? [] : [`\n`], ...VT(n));\n  }), e;\n}\nfunction VT({ vnode: t, recurseCount: e }) {\n  const n = e > 0 ? `... (${e} recursive calls)` : \"\", r = t.component ? t.component.parent == null : !1, i = ` at <${Td(\n    t.component,\n    t.type,\n    r\n  )}`, s = \">\" + n;\n  return t.props ? [i, ...IT(t.props), s] : [i + s];\n}\nfunction IT(t) {\n  const e = [], n = Object.keys(t);\n  return n.slice(0, 3).forEach((r) => {\n    e.push(...By(r, t[r]));\n  }), n.length > 3 && e.push(\" ...\"), e;\n}\nfunction By(t, e, n) {\n  return we(e) ? (e = JSON.stringify(e), n ? e : [`${t}=${e}`]) : typeof e == \"number\" || typeof e == \"boolean\" || e == null ? n ? e : [`${t}=${e}`] : Ct(e) ? (e = By(t, Oe(e.value), !0), n ? e : [`${t}=Ref<`, e, \">\"]) : be(e) ? [`${t}=fn${e.name ? `<${e.name}>` : \"\"}`] : (e = Oe(e), n ? e : [`${t}=`, e]);\n}\nfunction dO(t, e) {\n   true && t !== void 0 && (typeof t != \"number\" ? I(`${e} is not a valid number - got ${JSON.stringify(t)}.`) : isNaN(t) && I(`${e} is NaN - the duration expression might be incorrect.`));\n}\nconst WT = {\n  SETUP_FUNCTION: 0,\n  0: \"SETUP_FUNCTION\",\n  RENDER_FUNCTION: 1,\n  1: \"RENDER_FUNCTION\",\n  WATCH_GETTER: 2,\n  2: \"WATCH_GETTER\",\n  WATCH_CALLBACK: 3,\n  3: \"WATCH_CALLBACK\",\n  WATCH_CLEANUP: 4,\n  4: \"WATCH_CLEANUP\",\n  NATIVE_EVENT_HANDLER: 5,\n  5: \"NATIVE_EVENT_HANDLER\",\n  COMPONENT_EVENT_HANDLER: 6,\n  6: \"COMPONENT_EVENT_HANDLER\",\n  VNODE_HOOK: 7,\n  7: \"VNODE_HOOK\",\n  DIRECTIVE_HOOK: 8,\n  8: \"DIRECTIVE_HOOK\",\n  TRANSITION_HOOK: 9,\n  9: \"TRANSITION_HOOK\",\n  APP_ERROR_HANDLER: 10,\n  10: \"APP_ERROR_HANDLER\",\n  APP_WARN_HANDLER: 11,\n  11: \"APP_WARN_HANDLER\",\n  FUNCTION_REF: 12,\n  12: \"FUNCTION_REF\",\n  ASYNC_COMPONENT_LOADER: 13,\n  13: \"ASYNC_COMPONENT_LOADER\",\n  SCHEDULER: 14,\n  14: \"SCHEDULER\"\n}, md = {\n  sp: \"serverPrefetch hook\",\n  bc: \"beforeCreate hook\",\n  c: \"created hook\",\n  bm: \"beforeMount hook\",\n  m: \"mounted hook\",\n  bu: \"beforeUpdate hook\",\n  u: \"updated\",\n  bum: \"beforeUnmount hook\",\n  um: \"unmounted hook\",\n  a: \"activated hook\",\n  da: \"deactivated hook\",\n  ec: \"errorCaptured hook\",\n  rtc: \"renderTracked hook\",\n  rtg: \"renderTriggered hook\",\n  0: \"setup function\",\n  1: \"render function\",\n  2: \"watcher getter\",\n  3: \"watcher callback\",\n  4: \"watcher cleanup function\",\n  5: \"native event handler\",\n  6: \"component event handler\",\n  7: \"vnode hook\",\n  8: \"directive hook\",\n  9: \"transition hook\",\n  10: \"app errorHandler\",\n  11: \"app warnHandler\",\n  12: \"ref function\",\n  13: \"async component loader\",\n  14: \"scheduler flush. This is likely a Vue internals bug. Please open an issue at https://github.com/vuejs/core .\"\n};\nfunction Vr(t, e, n, r) {\n  try {\n    return r ? t(...r) : t();\n  } catch (i) {\n    hs(i, e, n);\n  }\n}\nfunction Wn(t, e, n, r) {\n  if (be(t)) {\n    const s = Vr(t, e, n, r);\n    return s && dd(s) && s.catch((o) => {\n      hs(o, e, n);\n    }), s;\n  }\n  const i = [];\n  for (let s = 0; s < t.length; s++)\n    i.push(Wn(t[s], e, n, r));\n  return i;\n}\nfunction hs(t, e, n, r = !0) {\n  const i = e ? e.vnode : null;\n  if (e) {\n    let s = e.parent;\n    const o = e.proxy, a =  true ? md[n] : 0;\n    for (; s; ) {\n      const c = s.ec;\n      if (c) {\n        for (let u = 0; u < c.length; u++)\n          if (c[u](t, o, a) === !1)\n            return;\n      }\n      s = s.parent;\n    }\n    const l = e.appContext.config.errorHandler;\n    if (l) {\n      Vr(\n        l,\n        null,\n        10,\n        [t, o, a]\n      );\n      return;\n    }\n  }\n  MT(t, n, i, r);\n}\nfunction MT(t, e, n, r = !0) {\n  if (true) {\n    const i = md[e];\n    if (n && Ia(n), I(`Unhandled error${i ? ` during execution of ${i}` : \"\"}`), n && Wa(), r)\n      throw t;\n    console.error(t);\n  } else\n    {}\n}\nlet tl = !1, lh = !1;\nconst sn = [];\nlet $r = 0;\nconst yo = [];\nlet ei = null, Qi = 0;\nconst Ly = /* @__PURE__ */ Promise.resolve();\nlet fO = null;\nconst XT = 100;\nfunction Pn(t) {\n  const e = fO || Ly;\n  return t ? e.then(this ? t.bind(this) : t) : e;\n}\nfunction jT(t) {\n  let e = $r + 1, n = sn.length;\n  for (; e < n; ) {\n    const r = e + n >>> 1, i = sn[r], s = rl(i);\n    s < t || s === t && i.pre ? e = r + 1 : n = r;\n  }\n  return e;\n}\nfunction Nl(t) {\n  (!sn.length || !sn.includes(\n    t,\n    tl && t.allowRecurse ? $r + 1 : $r\n  )) && (t.id == null ? sn.push(t) : sn.splice(jT(t.id), 0, t), Uy());\n}\nfunction Uy() {\n  !tl && !lh && (lh = !0, fO = Ly.then(qy));\n}\nfunction BT(t) {\n  const e = sn.indexOf(t);\n  e > $r && sn.splice(e, 1);\n}\nfunction nl(t) {\n  ie(t) ? yo.push(...t) : (!ei || !ei.includes(\n    t,\n    t.allowRecurse ? Qi + 1 : Qi\n  )) && yo.push(t), Uy();\n}\nfunction mm(t, e, n = tl ? $r + 1 : 0) {\n  for ( true && (e = e || /* @__PURE__ */ new Map()); n < sn.length; n++) {\n    const r = sn[n];\n    if (r && r.pre) {\n      if (t && r.id !== t.uid ||  true && hO(e, r))\n        continue;\n      sn.splice(n, 1), n--, r();\n    }\n  }\n}\nfunction Su(t) {\n  if (yo.length) {\n    const e = [...new Set(yo)].sort(\n      (n, r) => rl(n) - rl(r)\n    );\n    if (yo.length = 0, ei) {\n      ei.push(...e);\n      return;\n    }\n    for (ei = e,  true && (t = t || /* @__PURE__ */ new Map()), Qi = 0; Qi < ei.length; Qi++)\n       true && hO(t, ei[Qi]) || ei[Qi]();\n    ei = null, Qi = 0;\n  }\n}\nconst rl = (t) => t.id == null ? 1 / 0 : t.id, LT = (t, e) => {\n  const n = rl(t) - rl(e);\n  if (n === 0) {\n    if (t.pre && !e.pre)\n      return -1;\n    if (e.pre && !t.pre)\n      return 1;\n  }\n  return n;\n};\nfunction qy(t) {\n  lh = !1, tl = !0,  true && (t = t || /* @__PURE__ */ new Map()), sn.sort(LT);\n  const e =  true ? (n) => hO(t, n) : 0;\n  try {\n    for ($r = 0; $r < sn.length; $r++) {\n      const n = sn[$r];\n      if (n && n.active !== !1) {\n        if ( true && e(n))\n          continue;\n        Vr(n, null, 14);\n      }\n    }\n  } finally {\n    $r = 0, sn.length = 0, Su(t), tl = !1, fO = null, (sn.length || yo.length) && qy(t);\n  }\n}\nfunction hO(t, e) {\n  if (!t.has(e))\n    t.set(e, 1);\n  else {\n    const n = t.get(e);\n    if (n > XT) {\n      const r = e.ownerInstance, i = r && al(r.type);\n      return hs(\n        `Maximum recursive updates exceeded${i ? ` in component <${i}>` : \"\"}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,\n        null,\n        10\n      ), !0;\n    } else\n      t.set(e, n + 1);\n  }\n}\nlet Hi = !1;\nconst uo = /* @__PURE__ */ new Set();\n true && (bo().__VUE_HMR_RUNTIME__ = {\n  createRecord: of(Yy),\n  rerender: of(YT),\n  reload: of(zT)\n});\nconst Ms = /* @__PURE__ */ new Map();\nfunction UT(t) {\n  const e = t.type.__hmrId;\n  let n = Ms.get(e);\n  n || (Yy(e, t.type), n = Ms.get(e)), n.instances.add(t);\n}\nfunction qT(t) {\n  Ms.get(t.type.__hmrId).instances.delete(t);\n}\nfunction Yy(t, e) {\n  return Ms.has(t) ? !1 : (Ms.set(t, {\n    initialDef: Ma(e),\n    instances: /* @__PURE__ */ new Set()\n  }), !0);\n}\nfunction Ma(t) {\n  return B1(t) ? t.__vccOpts : t;\n}\nfunction YT(t, e) {\n  const n = Ms.get(t);\n  n && (n.initialDef.render = e, [...n.instances].forEach((r) => {\n    e && (r.render = e, Ma(r.type).render = e), r.renderCache = [], Hi = !0, r.effect.dirty = !0, r.update(), Hi = !1;\n  }));\n}\nfunction zT(t, e) {\n  const n = Ms.get(t);\n  if (!n)\n    return;\n  e = Ma(e), bm(n.initialDef, e);\n  const r = [...n.instances];\n  for (const i of r) {\n    const s = Ma(i.type);\n    uo.has(s) || (s !== n.initialDef && bm(s, e), uo.add(s)), i.appContext.propsCache.delete(i.type), i.appContext.emitsCache.delete(i.type), i.appContext.optionsCache.delete(i.type), i.ceReload ? (uo.add(s), i.ceReload(e.styles), uo.delete(s)) : i.parent ? (i.parent.effect.dirty = !0, Nl(i.parent.update)) : i.appContext.reload ? i.appContext.reload() : typeof window < \"u\" ? window.location.reload() : console.warn(\n      \"[HMR] Root or manually mounted instance modified. Full reload required.\"\n    );\n  }\n  nl(() => {\n    for (const i of r)\n      uo.delete(\n        Ma(i.type)\n      );\n  });\n}\nfunction bm(t, e) {\n  $e(t, e);\n  for (const n in t)\n    n !== \"__file\" && !(n in e) && delete t[n];\n}\nfunction of(t) {\n  return (e, n) => {\n    try {\n      return t(e, n);\n    } catch (r) {\n      console.error(r), console.warn(\n        \"[HMR] Something went wrong during Vue component hot-reload. Full reload required.\"\n      );\n    }\n  };\n}\nlet ar, $a = [], ch = !1;\nfunction Dl(t, ...e) {\n  ar ? ar.emit(t, ...e) : ch || $a.push({ event: t, args: e });\n}\nfunction pO(t, e) {\n  var n, r;\n  ar = t, ar ? (ar.enabled = !0, $a.forEach(({ event: i, args: s }) => ar.emit(i, ...s)), $a = []) : /* handle late devtools injection - only do this if we are in an actual */ /* browser environment to avoid the timer handle stalling test runner exit */ /* (#4815) */ typeof window < \"u\" && // some envs mock window but not fully\n  window.HTMLElement && // also exclude jsdom\n  !((r = (n = window.navigator) == null ? void 0 : n.userAgent) != null && r.includes(\"jsdom\")) ? ((e.__VUE_DEVTOOLS_HOOK_REPLAY__ = e.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((s) => {\n    pO(s, e);\n  }), setTimeout(() => {\n    ar || (e.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, ch = !0, $a = []);\n  }, 3e3)) : (ch = !0, $a = []);\n}\nfunction HT(t, e) {\n  Dl(\"app:init\", t, e, {\n    Fragment: Pe,\n    Text: ns,\n    Comment: _t,\n    Static: Fi\n  });\n}\nfunction FT(t) {\n  Dl(\"app:unmount\", t);\n}\nconst uh = /* @__PURE__ */ OO(\n  \"component:added\"\n  /* COMPONENT_ADDED */\n), zy = /* @__PURE__ */ OO(\n  \"component:updated\"\n  /* COMPONENT_UPDATED */\n), GT = /* @__PURE__ */ OO(\n  \"component:removed\"\n  /* COMPONENT_REMOVED */\n), KT = (t) => {\n  ar && typeof ar.cleanupBuffer == \"function\" && // remove the component if it wasn't buffered\n  !ar.cleanupBuffer(t) && GT(t);\n};\nfunction OO(t) {\n  return (e) => {\n    Dl(\n      t,\n      e.appContext.app,\n      e.uid,\n      e.parent ? e.parent.uid : void 0,\n      e\n    );\n  };\n}\nconst JT = /* @__PURE__ */ Hy(\n  \"perf:start\"\n  /* PERFORMANCE_START */\n), eE = /* @__PURE__ */ Hy(\n  \"perf:end\"\n  /* PERFORMANCE_END */\n);\nfunction Hy(t) {\n  return (e, n, r) => {\n    Dl(t, e.appContext.app, e.uid, e, n, r);\n  };\n}\nfunction tE(t, e, n) {\n  Dl(\n    \"component:emit\",\n    t.appContext.app,\n    t,\n    e,\n    n\n  );\n}\nfunction nE(t, e, ...n) {\n  if (t.isUnmounted)\n    return;\n  const r = t.vnode.props || Ve;\n  if (true) {\n    const {\n      emitsOptions: u,\n      propsOptions: [d]\n    } = t;\n    if (u)\n      if (!(e in u))\n        (!d || !(Tr(e) in d)) && I(\n          `Component emitted event \"${e}\" but it is neither declared in the emits option nor as an \"${Tr(e)}\" prop.`\n        );\n      else {\n        const f = u[e];\n        be(f) && (f(...n) || I(\n          `Invalid event arguments: event validation failed for event \"${e}\".`\n        ));\n      }\n  }\n  let i = n;\n  const s = e.startsWith(\"update:\"), o = s && e.slice(7);\n  if (o && o in r) {\n    const u = `${o === \"modelValue\" ? \"model\" : o}Modifiers`, { number: d, trim: f } = r[u] || Ve;\n    f && (i = n.map((h) => we(h) ? h.trim() : h)), d && (i = n.map(Ka));\n  }\n  if (( true) && tE(t, e, i), \"development\" !== \"production\") {\n    const u = e.toLowerCase();\n    u !== e && r[Tr(u)] && I(\n      `Event \"${u}\" is emitted in component ${Td(\n        t,\n        t.type\n      )} but the handler is registered for \"${e}\". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use \"${rn(\n        e\n      )}\" instead of \"${e}\".`\n    );\n  }\n  let a, l = r[a = Tr(e)] || // also try camelCase event handler (#2249)\n  r[a = Tr(mt(e))];\n  !l && s && (l = r[a = Tr(rn(e))]), l && Wn(\n    l,\n    t,\n    6,\n    i\n  );\n  const c = r[a + \"Once\"];\n  if (c) {\n    if (!t.emitted)\n      t.emitted = {};\n    else if (t.emitted[a])\n      return;\n    t.emitted[a] = !0, Wn(\n      c,\n      t,\n      6,\n      i\n    );\n  }\n}\nfunction Fy(t, e, n = !1) {\n  const r = e.emitsCache, i = r.get(t);\n  if (i !== void 0)\n    return i;\n  const s = t.emits;\n  let o = {}, a = !1;\n  if (__VUE_OPTIONS_API__ && !be(t)) {\n    const l = (c) => {\n      const u = Fy(c, e, !0);\n      u && (a = !0, $e(o, u));\n    };\n    !n && e.mixins.length && e.mixins.forEach(l), t.extends && l(t.extends), t.mixins && t.mixins.forEach(l);\n  }\n  return !s && !a ? (Ze(t) && r.set(t, null), null) : (ie(s) ? s.forEach((l) => o[l] = null) : $e(o, s), Ze(t) && r.set(t, o), o);\n}\nfunction bd(t, e) {\n  return !t || !oi(e) ? !1 : (e = e.slice(2).replace(/Once$/, \"\"), Ae(t, e[0].toLowerCase() + e.slice(1)) || Ae(t, rn(e)) || Ae(t, e));\n}\nlet Ot = null, vd = null;\nfunction il(t) {\n  const e = Ot;\n  return Ot = t, vd = t && t.type.__scopeId || null, e;\n}\nfunction Ks(t) {\n  vd = t;\n}\nfunction Js() {\n  vd = null;\n}\nconst rE = (t) => ce;\nfunction ce(t, e = Ot, n) {\n  if (!e || t._n)\n    return t;\n  const r = (...i) => {\n    r._d && vh(-1);\n    const s = il(e);\n    let o;\n    try {\n      o = t(...i);\n    } finally {\n      il(s), r._d && vh(1);\n    }\n    return ( true) && zy(e), o;\n  };\n  return r._n = !0, r._c = !0, r._d = !0, r;\n}\nlet dh = !1;\nfunction wu() {\n  dh = !0;\n}\nfunction Hc(t) {\n  const {\n    type: e,\n    vnode: n,\n    proxy: r,\n    withProxy: i,\n    props: s,\n    propsOptions: [o],\n    slots: a,\n    attrs: l,\n    emit: c,\n    render: u,\n    renderCache: d,\n    data: f,\n    setupState: h,\n    ctx: p,\n    inheritAttrs: O\n  } = t;\n  let m, y;\n  const b = il(t);\n   true && (dh = !1);\n  try {\n    if (n.shapeFlag & 4) {\n      const S = i || r, w =  true && h.__isScriptSetup ? new Proxy(S, {\n        get(k, _, T) {\n          return I(\n            `Property '${String(\n              _\n            )}' was accessed via 'this'. Avoid using 'this' in templates.`\n          ), Reflect.get(k, _, T);\n        }\n      }) : S;\n      m = Sn(\n        u.call(\n          w,\n          S,\n          d,\n          s,\n          h,\n          f,\n          p\n        )\n      ), y = l;\n    } else {\n      const S = e;\n       true && l === s && wu(), m = Sn(\n        S.length > 1 ? S(\n          s,\n           true ? {\n            get attrs() {\n              return wu(), l;\n            },\n            slots: a,\n            emit: c\n          } : 0\n        ) : S(\n          s,\n          null\n          /* we know it doesn't need it */\n        )\n      ), y = e.props ? l : iE(l);\n    }\n  } catch (S) {\n    Ba.length = 0, hs(S, t, 1), m = J(_t);\n  }\n  let g = m, v;\n  if ( true && m.patchFlag > 0 && m.patchFlag & 2048 && ([g, v] = Gy(m)), y && O !== !1) {\n    const S = Object.keys(y), { shapeFlag: w } = g;\n    if (S.length) {\n      if (w & 7)\n        o && S.some(mu) && (y = sE(\n          y,\n          o\n        )), g = jn(g, y);\n      else if ( true && !dh && g.type !== _t) {\n        const k = Object.keys(l), _ = [], T = [];\n        for (let C = 0, A = k.length; C < A; C++) {\n          const Q = k[C];\n          oi(Q) ? mu(Q) || _.push(Q[2].toLowerCase() + Q.slice(3)) : T.push(Q);\n        }\n        T.length && I(\n          `Extraneous non-props attributes (${T.join(\", \")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`\n        ), _.length && I(\n          `Extraneous non-emits event listeners (${_.join(\", \")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the \"emits\" option.`\n        );\n      }\n    }\n  }\n  return n.dirs && ( true && !vm(g) && I(\n    \"Runtime directive used on component with non-element root node. The directives will not function as intended.\"\n  ), g = jn(g), g.dirs = g.dirs ? g.dirs.concat(n.dirs) : n.dirs), n.transition && ( true && !vm(g) && I(\n    \"Component inside <Transition> renders non-element root node that cannot be animated.\"\n  ), g.transition = n.transition),  true && v ? v(g) : m = g, il(b), m;\n}\nconst Gy = (t) => {\n  const e = t.children, n = t.dynamicChildren, r = yd(e, !1);\n  if (r) {\n    if ( true && r.patchFlag > 0 && r.patchFlag & 2048)\n      return Gy(r);\n  } else\n    return [t, void 0];\n  const i = e.indexOf(r), s = n ? n.indexOf(r) : -1, o = (a) => {\n    e[i] = a, n && (s > -1 ? n[s] = a : a.patchFlag > 0 && (t.dynamicChildren = [...n, a]));\n  };\n  return [Sn(r), o];\n};\nfunction yd(t, e = !0) {\n  let n;\n  for (let r = 0; r < t.length; r++) {\n    const i = t[r];\n    if (li(i)) {\n      if (i.type !== _t || i.children === \"v-if\") {\n        if (n)\n          return;\n        if (n = i,  true && e && n.patchFlag > 0 && n.patchFlag & 2048)\n          return yd(n.children);\n      }\n    } else\n      return;\n  }\n  return n;\n}\nconst iE = (t) => {\n  let e;\n  for (const n in t)\n    (n === \"class\" || n === \"style\" || oi(n)) && ((e || (e = {}))[n] = t[n]);\n  return e;\n}, sE = (t, e) => {\n  const n = {};\n  for (const r in t)\n    (!mu(r) || !(r.slice(9) in e)) && (n[r] = t[r]);\n  return n;\n}, vm = (t) => t.shapeFlag & 7 || t.type === _t;\nfunction oE(t, e, n) {\n  const { props: r, children: i, component: s } = t, { props: o, children: a, patchFlag: l } = e, c = s.emitsOptions;\n  if ( true && (i || a) && Hi || e.dirs || e.transition)\n    return !0;\n  if (n && l >= 0) {\n    if (l & 1024)\n      return !0;\n    if (l & 16)\n      return r ? ym(r, o, c) : !!o;\n    if (l & 8) {\n      const u = e.dynamicProps;\n      for (let d = 0; d < u.length; d++) {\n        const f = u[d];\n        if (o[f] !== r[f] && !bd(c, f))\n          return !0;\n      }\n    }\n  } else\n    return (i || a) && (!a || !a.$stable) ? !0 : r === o ? !1 : r ? o ? ym(r, o, c) : !0 : !!o;\n  return !1;\n}\nfunction ym(t, e, n) {\n  const r = Object.keys(e);\n  if (r.length !== Object.keys(t).length)\n    return !0;\n  for (let i = 0; i < r.length; i++) {\n    const s = r[i];\n    if (e[s] !== t[s] && !bd(n, s))\n      return !0;\n  }\n  return !1;\n}\nfunction gO({ vnode: t, parent: e }, n) {\n  for (; e; ) {\n    const r = e.subTree;\n    if (r.suspense && r.suspense.activeBranch === t && (r.el = t.el), r === t)\n      (t = e.vnode).el = n, e = e.parent;\n    else\n      break;\n  }\n}\nconst ku = \"components\", aE = \"directives\";\nfunction lE(t, e) {\n  return bO(ku, t, !0, e) || t;\n}\nconst mO = Symbol.for(\"v-ndc\");\nfunction Zl(t) {\n  return we(t) ? bO(ku, t, !1) || t : t || mO;\n}\nfunction cE(t) {\n  return bO(aE, t);\n}\nfunction bO(t, e, n = !0, r = !1) {\n  const i = Ot || xt;\n  if (i) {\n    const s = i.type;\n    if (t === ku) {\n      const a = al(\n        s,\n        !1\n      );\n      if (a && (a === e || a === mt(e) || a === Wr(mt(e))))\n        return s;\n    }\n    const o = (\n      // local registration\n      // check instance[type] first which is resolved for options API\n      Sm(i[t] || s[t], e) || // global registration\n      Sm(i.appContext[t], e)\n    );\n    if (!o && r)\n      return s;\n    if ( true && n && !o) {\n      const a = t === ku ? `\nIf this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : \"\";\n      I(`Failed to resolve ${t.slice(0, -1)}: ${e}${a}`);\n    }\n    return o;\n  } else\n     true && I(\n      `resolve${Wr(t.slice(0, -1))} can only be used in render() or setup().`\n    );\n}\nfunction Sm(t, e) {\n  return t && (t[e] || t[mt(e)] || t[Wr(mt(e))]);\n}\nconst Ky = (t) => t.__isSuspense;\nlet fh = 0;\nconst uE = {\n  name: \"Suspense\",\n  // In order to make Suspense tree-shakable, we need to avoid importing it\n  // directly in the renderer. The renderer checks for the __isSuspense flag\n  // on a vnode's type and calls the `process` method, passing in renderer\n  // internals.\n  __isSuspense: !0,\n  process(t, e, n, r, i, s, o, a, l, c) {\n    if (t == null)\n      fE(\n        e,\n        n,\n        r,\n        i,\n        s,\n        o,\n        a,\n        l,\n        c\n      );\n    else {\n      if (s && s.deps > 0 && !t.suspense.isInFallback) {\n        e.suspense = t.suspense, e.suspense.vnode = e, e.el = t.el;\n        return;\n      }\n      hE(\n        t,\n        e,\n        n,\n        r,\n        i,\n        o,\n        a,\n        l,\n        c\n      );\n    }\n  },\n  hydrate: pE,\n  create: vO,\n  normalize: OE\n}, dE = uE;\nfunction sl(t, e) {\n  const n = t.props && t.props[e];\n  be(n) && n();\n}\nfunction fE(t, e, n, r, i, s, o, a, l) {\n  const {\n    p: c,\n    o: { createElement: u }\n  } = l, d = u(\"div\"), f = t.suspense = vO(\n    t,\n    i,\n    r,\n    e,\n    d,\n    n,\n    s,\n    o,\n    a,\n    l\n  );\n  c(\n    null,\n    f.pendingBranch = t.ssContent,\n    d,\n    null,\n    r,\n    f,\n    s,\n    o\n  ), f.deps > 0 ? (sl(t, \"onPending\"), sl(t, \"onFallback\"), c(\n    null,\n    t.ssFallback,\n    e,\n    n,\n    r,\n    null,\n    // fallback tree will not have suspense context\n    s,\n    o\n  ), So(f, t.ssFallback)) : f.resolve(!1, !0);\n}\nfunction hE(t, e, n, r, i, s, o, a, { p: l, um: c, o: { createElement: u } }) {\n  const d = e.suspense = t.suspense;\n  d.vnode = e, e.el = t.el;\n  const f = e.ssContent, h = e.ssFallback, { activeBranch: p, pendingBranch: O, isInFallback: m, isHydrating: y } = d;\n  if (O)\n    d.pendingBranch = f, lr(f, O) ? (l(\n      O,\n      f,\n      d.hiddenContainer,\n      null,\n      i,\n      d,\n      s,\n      o,\n      a\n    ), d.deps <= 0 ? d.resolve() : m && (y || (l(\n      p,\n      h,\n      n,\n      r,\n      i,\n      null,\n      // fallback tree will not have suspense context\n      s,\n      o,\n      a\n    ), So(d, h)))) : (d.pendingId = fh++, y ? (d.isHydrating = !1, d.activeBranch = O) : c(O, i, d), d.deps = 0, d.effects.length = 0, d.hiddenContainer = u(\"div\"), m ? (l(\n      null,\n      f,\n      d.hiddenContainer,\n      null,\n      i,\n      d,\n      s,\n      o,\n      a\n    ), d.deps <= 0 ? d.resolve() : (l(\n      p,\n      h,\n      n,\n      r,\n      i,\n      null,\n      // fallback tree will not have suspense context\n      s,\n      o,\n      a\n    ), So(d, h))) : p && lr(f, p) ? (l(\n      p,\n      f,\n      n,\n      r,\n      i,\n      d,\n      s,\n      o,\n      a\n    ), d.resolve(!0)) : (l(\n      null,\n      f,\n      d.hiddenContainer,\n      null,\n      i,\n      d,\n      s,\n      o,\n      a\n    ), d.deps <= 0 && d.resolve()));\n  else if (p && lr(f, p))\n    l(\n      p,\n      f,\n      n,\n      r,\n      i,\n      d,\n      s,\n      o,\n      a\n    ), So(d, f);\n  else if (sl(e, \"onPending\"), d.pendingBranch = f, f.shapeFlag & 512 ? d.pendingId = f.component.suspenseId : d.pendingId = fh++, l(\n    null,\n    f,\n    d.hiddenContainer,\n    null,\n    i,\n    d,\n    s,\n    o,\n    a\n  ), d.deps <= 0)\n    d.resolve();\n  else {\n    const { timeout: b, pendingId: g } = d;\n    b > 0 ? setTimeout(() => {\n      d.pendingId === g && d.fallback(h);\n    }, b) : b === 0 && d.fallback(h);\n  }\n}\nlet wm = !1;\nfunction vO(t, e, n, r, i, s, o, a, l, c, u = !1) {\n   true && !wm && (wm = !0, console[console.info ? \"info\" : \"log\"](\n    \"<Suspense> is an experimental feature and its API will likely change.\"\n  ));\n  const {\n    p: d,\n    m: f,\n    um: h,\n    n: p,\n    o: { parentNode: O, remove: m }\n  } = c;\n  let y;\n  const b = gE(t);\n  b && e != null && e.pendingBranch && (y = e.pendingId, e.deps++);\n  const g = t.props ? vu(t.props.timeout) : void 0;\n   true && dO(g, \"Suspense timeout\");\n  const v = s, S = {\n    vnode: t,\n    parent: e,\n    parentComponent: n,\n    namespace: o,\n    container: r,\n    hiddenContainer: i,\n    deps: 0,\n    pendingId: fh++,\n    timeout: typeof g == \"number\" ? g : -1,\n    activeBranch: null,\n    pendingBranch: null,\n    isInFallback: !u,\n    isHydrating: u,\n    isUnmounted: !1,\n    effects: [],\n    resolve(w = !1, k = !1) {\n      if (true) {\n        if (!w && !S.pendingBranch)\n          throw new Error(\n            \"suspense.resolve() is called without a pending branch.\"\n          );\n        if (S.isUnmounted)\n          throw new Error(\n            \"suspense.resolve() is called on an already unmounted suspense boundary.\"\n          );\n      }\n      const {\n        vnode: _,\n        activeBranch: T,\n        pendingBranch: C,\n        pendingId: A,\n        effects: Q,\n        parentComponent: W,\n        container: L\n      } = S;\n      let re = !1;\n      S.isHydrating ? S.isHydrating = !1 : w || (re = T && C.transition && C.transition.mode === \"out-in\", re && (T.transition.afterLeave = () => {\n        A === S.pendingId && (f(\n          C,\n          L,\n          s === v ? p(T) : s,\n          0\n        ), nl(Q));\n      }), T && (O(T.el) !== S.hiddenContainer && (s = p(T)), h(T, W, S, !0)), re || f(C, L, s, 0)), So(S, C), S.pendingBranch = null, S.isInFallback = !1;\n      let Y = S.parent, K = !1;\n      for (; Y; ) {\n        if (Y.pendingBranch) {\n          Y.effects.push(...Q), K = !0;\n          break;\n        }\n        Y = Y.parent;\n      }\n      !K && !re && nl(Q), S.effects = [], b && e && e.pendingBranch && y === e.pendingId && (e.deps--, e.deps === 0 && !k && e.resolve()), sl(_, \"onResolve\");\n    },\n    fallback(w) {\n      if (!S.pendingBranch)\n        return;\n      const { vnode: k, activeBranch: _, parentComponent: T, container: C, namespace: A } = S;\n      sl(k, \"onFallback\");\n      const Q = p(_), W = () => {\n        S.isInFallback && (d(\n          null,\n          w,\n          C,\n          Q,\n          T,\n          null,\n          // fallback tree will not have suspense context\n          A,\n          a,\n          l\n        ), So(S, w));\n      }, L = w.transition && w.transition.mode === \"out-in\";\n      L && (_.transition.afterLeave = W), S.isInFallback = !0, h(\n        _,\n        T,\n        null,\n        // no suspense so unmount hooks fire now\n        !0\n        // shouldRemove\n      ), L || W();\n    },\n    move(w, k, _) {\n      S.activeBranch && f(S.activeBranch, w, k, _), S.container = w;\n    },\n    next() {\n      return S.activeBranch && p(S.activeBranch);\n    },\n    registerDep(w, k) {\n      const _ = !!S.pendingBranch;\n      _ && S.deps++;\n      const T = w.vnode.el;\n      w.asyncDep.catch((C) => {\n        hs(C, w, 0);\n      }).then((C) => {\n        if (w.isUnmounted || S.isUnmounted || S.pendingId !== w.suspenseId)\n          return;\n        w.asyncResolved = !0;\n        const { vnode: A } = w;\n         true && Ia(A), xh(w, C, !1), T && (A.el = T);\n        const Q = !T && w.subTree.el;\n        k(\n          w,\n          A,\n          // component may have been moved before resolve.\n          // if this is not a hydration, instance.subTree will be the comment\n          // placeholder.\n          O(T || w.subTree.el),\n          // anchor will not be used if this is hydration, so only need to\n          // consider the comment placeholder case.\n          T ? null : p(w.subTree),\n          S,\n          o,\n          l\n        ), Q && m(Q), gO(w, A.el),  true && Wa(), _ && --S.deps === 0 && S.resolve();\n      });\n    },\n    unmount(w, k) {\n      S.isUnmounted = !0, S.activeBranch && h(\n        S.activeBranch,\n        n,\n        w,\n        k\n      ), S.pendingBranch && h(\n        S.pendingBranch,\n        n,\n        w,\n        k\n      );\n    }\n  };\n  return S;\n}\nfunction pE(t, e, n, r, i, s, o, a, l) {\n  const c = e.suspense = vO(\n    e,\n    r,\n    n,\n    t.parentNode,\n    // eslint-disable-next-line no-restricted-globals\n    document.createElement(\"div\"),\n    null,\n    i,\n    s,\n    o,\n    a,\n    !0\n  ), u = l(\n    t,\n    c.pendingBranch = e.ssContent,\n    n,\n    c,\n    s,\n    o\n  );\n  return c.deps === 0 && c.resolve(!1, !0), u;\n}\nfunction OE(t) {\n  const { shapeFlag: e, children: n } = t, r = e & 32;\n  t.ssContent = km(\n    r ? n.default : n\n  ), t.ssFallback = r ? km(n.fallback) : J(_t);\n}\nfunction km(t) {\n  let e;\n  if (be(t)) {\n    const n = js && t._c;\n    n && (t._d = !1, Z()), t = t(), n && (t._d = !0, e = kn, A1());\n  }\n  if (ie(t)) {\n    const n = yd(t);\n     true && !n && t.filter((r) => r !== mO).length > 0 && I(\"<Suspense> slots expect a single root node.\"), t = n;\n  }\n  return t = Sn(t), e && !t.dynamicChildren && (t.dynamicChildren = e.filter((n) => n !== t)), t;\n}\nfunction Jy(t, e) {\n  e && e.pendingBranch ? ie(t) ? e.effects.push(...t) : e.effects.push(t) : nl(t);\n}\nfunction So(t, e) {\n  t.activeBranch = e;\n  const { vnode: n, parentComponent: r } = t;\n  let i = e.el;\n  for (; !i && e.component; )\n    e = e.component.subTree, i = e.el;\n  n.el = i, r && r.subTree === n && (r.vnode.el = i, gO(r, i));\n}\nfunction gE(t) {\n  var e;\n  return ((e = t.props) == null ? void 0 : e.suspensible) != null && t.props.suspensible !== !1;\n}\nconst e1 = Symbol.for(\"v-scx\"), yO = () => {\n  {\n    const t = Pt(e1);\n    return t ||  true && I(\n      \"Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build.\"\n    ), t;\n  }\n};\nfunction Bn(t, e) {\n  return Vl(t, null, e);\n}\nfunction t1(t, e) {\n  return Vl(\n    t,\n    null,\n     true ? $e({}, e, { flush: \"post\" }) : 0\n  );\n}\nfunction n1(t, e) {\n  return Vl(\n    t,\n    null,\n     true ? $e({}, e, { flush: \"sync\" }) : 0\n  );\n}\nconst pc = {};\nfunction ht(t, e, n) {\n  return  true && !be(e) && I(\n    \"`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature.\"\n  ), Vl(t, e, n);\n}\nfunction Vl(t, e, {\n  immediate: n,\n  deep: r,\n  flush: i,\n  once: s,\n  onTrack: o,\n  onTrigger: a\n} = Ve) {\n  if (e && s) {\n    const k = e;\n    e = (..._) => {\n      k(..._), w();\n    };\n  }\n   true && r !== void 0 && typeof r == \"number\" && I(\n    'watch() \"deep\" option with number value will be used as watch depth in future versions. Please use a boolean instead to avoid potential breakage.'\n  ),  true && !e && (n !== void 0 && I(\n    'watch() \"immediate\" option is only respected when using the watch(source, callback, options?) signature.'\n  ), r !== void 0 && I(\n    'watch() \"deep\" option is only respected when using the watch(source, callback, options?) signature.'\n  ), s !== void 0 && I(\n    'watch() \"once\" option is only respected when using the watch(source, callback, options?) signature.'\n  ));\n  const l = (k) => {\n    I(\n      \"Invalid watch source: \",\n      k,\n      \"A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.\"\n    );\n  }, c = xt, u = (k) => r === !0 ? k : (\n    // for deep: false, only traverse root-level properties\n    ws(k, r === !1 ? 1 : void 0)\n  );\n  let d, f = !1, h = !1;\n  if (Ct(t) ? (d = () => t.value, f = zi(t)) : Yi(t) ? (d = () => u(t), f = !0) : ie(t) ? (h = !0, f = t.some((k) => Yi(k) || zi(k)), d = () => t.map((k) => {\n    if (Ct(k))\n      return k.value;\n    if (Yi(k))\n      return u(k);\n    if (be(k))\n      return Vr(k, c, 2);\n     true && l(k);\n  })) : be(t) ? e ? d = () => Vr(t, c, 2) : d = () => (p && p(), Wn(\n    t,\n    c,\n    3,\n    [O]\n  )) : (d = it,  true && l(t)), e && r) {\n    const k = d;\n    d = () => ws(k());\n  }\n  let p, O = (k) => {\n    p = v.onStop = () => {\n      Vr(k, c, 4), p = v.onStop = void 0;\n    };\n  }, m;\n  if (Xl)\n    if (O = it, e ? n && Wn(e, c, 3, [\n      d(),\n      h ? [] : void 0,\n      O\n    ]) : d(), i === \"sync\") {\n      const k = yO();\n      m = k.__watcherHandles || (k.__watcherHandles = []);\n    } else\n      return it;\n  let y = h ? new Array(t.length).fill(pc) : pc;\n  const b = () => {\n    if (!(!v.active || !v.dirty))\n      if (e) {\n        const k = v.run();\n        (r || f || (h ? k.some((_, T) => gr(_, y[T])) : gr(k, y))) && (p && p(), Wn(e, c, 3, [\n          k,\n          // pass undefined as the old value when it's changed for the first time\n          y === pc ? void 0 : h && y[0] === pc ? [] : y,\n          O\n        ]), y = k);\n      } else\n        v.run();\n  };\n  b.allowRecurse = !!e;\n  let g;\n  i === \"sync\" ? g = b : i === \"post\" ? g = () => Yt(b, c && c.suspense) : (b.pre = !0, c && (b.id = c.uid), g = () => Nl(b));\n  const v = new Ao(d, it, g), S = Rl(), w = () => {\n    v.stop(), S && Fp(S.effects, v);\n  };\n  return  true && (v.onTrack = o, v.onTrigger = a), e ? n ? b() : y = v.run() : i === \"post\" ? Yt(\n    v.run.bind(v),\n    c && c.suspense\n  ) : v.run(), m && m.push(w), w;\n}\nfunction mE(t, e, n) {\n  const r = this.proxy, i = we(t) ? t.includes(\".\") ? r1(r, t) : () => r[t] : t.bind(r, r);\n  let s;\n  be(e) ? s = e : (s = e.handler, n = e);\n  const o = Bs(this), a = Vl(i, s.bind(r), n);\n  return o(), a;\n}\nfunction r1(t, e) {\n  const n = e.split(\".\");\n  return () => {\n    let r = t;\n    for (let i = 0; i < n.length && r; i++)\n      r = r[n[i]];\n    return r;\n  };\n}\nfunction ws(t, e, n = 0, r) {\n  if (!Ze(t) || t.__v_skip)\n    return t;\n  if (e && e > 0) {\n    if (n >= e)\n      return t;\n    n++;\n  }\n  if (r = r || /* @__PURE__ */ new Set(), r.has(t))\n    return t;\n  if (r.add(t), Ct(t))\n    ws(t.value, e, n, r);\n  else if (ie(t))\n    for (let i = 0; i < t.length; i++)\n      ws(t[i], e, n, r);\n  else if (Gs(t) || Cs(t))\n    t.forEach((i) => {\n      ws(i, e, n, r);\n    });\n  else if (py(t))\n    for (const i in t)\n      ws(t[i], e, n, r);\n  return t;\n}\nfunction i1(t) {\n  Oy(t) && I(\"Do not use built-in directive ids as custom directive id: \" + t);\n}\nfunction Xi(t, e) {\n  if (Ot === null)\n    return  true && I(\"withDirectives can only be used inside render functions.\"), t;\n  const n = _d(Ot) || Ot.proxy, r = t.dirs || (t.dirs = []);\n  for (let i = 0; i < e.length; i++) {\n    let [s, o, a, l = Ve] = e[i];\n    s && (be(s) && (s = {\n      mounted: s,\n      updated: s\n    }), s.deep && ws(o), r.push({\n      dir: s,\n      instance: n,\n      value: o,\n      oldValue: void 0,\n      arg: a,\n      modifiers: l\n    }));\n  }\n  return t;\n}\nfunction _r(t, e, n, r) {\n  const i = t.dirs, s = e && e.dirs;\n  for (let o = 0; o < i.length; o++) {\n    const a = i[o];\n    s && (a.oldValue = s[o].value);\n    let l = a.dir[r];\n    l && (ds(), Wn(l, n, 8, [\n      t.el,\n      a,\n      t,\n      e\n    ]), fs());\n  }\n}\nconst Ci = Symbol(\"_leaveCb\"), Oc = Symbol(\"_enterCb\");\nfunction SO() {\n  const t = {\n    isMounted: !1,\n    isLeaving: !1,\n    isUnmounting: !1,\n    leavingVNodes: /* @__PURE__ */ new Map()\n  };\n  return et(() => {\n    t.isMounted = !0;\n  }), Il(() => {\n    t.isUnmounting = !0;\n  }), t;\n}\nconst Yn = [Function, Array], wO = {\n  mode: String,\n  appear: Boolean,\n  persisted: Boolean,\n  // enter\n  onBeforeEnter: Yn,\n  onEnter: Yn,\n  onAfterEnter: Yn,\n  onEnterCancelled: Yn,\n  // leave\n  onBeforeLeave: Yn,\n  onLeave: Yn,\n  onAfterLeave: Yn,\n  onLeaveCancelled: Yn,\n  // appear\n  onBeforeAppear: Yn,\n  onAppear: Yn,\n  onAfterAppear: Yn,\n  onAppearCancelled: Yn\n}, bE = {\n  name: \"BaseTransition\",\n  props: wO,\n  setup(t, { slots: e }) {\n    const n = ir(), r = SO();\n    return () => {\n      const i = e.default && Sd(e.default(), !0);\n      if (!i || !i.length)\n        return;\n      let s = i[0];\n      if (i.length > 1) {\n        let f = !1;\n        for (const h of i)\n          if (h.type !== _t) {\n            if ( true && f) {\n              I(\n                \"<transition> can only be used on a single element or component. Use <transition-group> for lists.\"\n              );\n              break;\n            }\n            if (s = h, f = !0, \"development\" === \"production\")\n              break;\n          }\n      }\n      const o = Oe(t), { mode: a } = o;\n      if ( true && a && a !== \"in-out\" && a !== \"out-in\" && a !== \"default\" && I(`invalid <transition> mode: ${a}`), r.isLeaving)\n        return af(s);\n      const l = xm(s);\n      if (!l)\n        return af(s);\n      const c = Ro(\n        l,\n        o,\n        r,\n        n\n      );\n      Xs(l, c);\n      const u = n.subTree, d = u && xm(u);\n      if (d && d.type !== _t && !lr(l, d)) {\n        const f = Ro(\n          d,\n          o,\n          r,\n          n\n        );\n        if (Xs(d, f), a === \"out-in\")\n          return r.isLeaving = !0, f.afterLeave = () => {\n            r.isLeaving = !1, n.update.active !== !1 && (n.effect.dirty = !0, n.update());\n          }, af(s);\n        a === \"in-out\" && l.type !== _t && (f.delayLeave = (h, p, O) => {\n          const m = o1(\n            r,\n            d\n          );\n          m[String(d.key)] = d, h[Ci] = () => {\n            p(), h[Ci] = void 0, delete c.delayedLeave;\n          }, c.delayedLeave = O;\n        });\n      }\n      return s;\n    };\n  }\n}, s1 = bE;\nfunction o1(t, e) {\n  const { leavingVNodes: n } = t;\n  let r = n.get(e.type);\n  return r || (r = /* @__PURE__ */ Object.create(null), n.set(e.type, r)), r;\n}\nfunction Ro(t, e, n, r) {\n  const {\n    appear: i,\n    mode: s,\n    persisted: o = !1,\n    onBeforeEnter: a,\n    onEnter: l,\n    onAfterEnter: c,\n    onEnterCancelled: u,\n    onBeforeLeave: d,\n    onLeave: f,\n    onAfterLeave: h,\n    onLeaveCancelled: p,\n    onBeforeAppear: O,\n    onAppear: m,\n    onAfterAppear: y,\n    onAppearCancelled: b\n  } = e, g = String(t.key), v = o1(n, t), S = (_, T) => {\n    _ && Wn(\n      _,\n      r,\n      9,\n      T\n    );\n  }, w = (_, T) => {\n    const C = T[1];\n    S(_, T), ie(_) ? _.every((A) => A.length <= 1) && C() : _.length <= 1 && C();\n  }, k = {\n    mode: s,\n    persisted: o,\n    beforeEnter(_) {\n      let T = a;\n      if (!n.isMounted)\n        if (i)\n          T = O || a;\n        else\n          return;\n      _[Ci] && _[Ci](\n        !0\n        /* cancelled */\n      );\n      const C = v[g];\n      C && lr(t, C) && C.el[Ci] && C.el[Ci](), S(T, [_]);\n    },\n    enter(_) {\n      let T = l, C = c, A = u;\n      if (!n.isMounted)\n        if (i)\n          T = m || l, C = y || c, A = b || u;\n        else\n          return;\n      let Q = !1;\n      const W = _[Oc] = (L) => {\n        Q || (Q = !0, L ? S(A, [_]) : S(C, [_]), k.delayedLeave && k.delayedLeave(), _[Oc] = void 0);\n      };\n      T ? w(T, [_, W]) : W();\n    },\n    leave(_, T) {\n      const C = String(t.key);\n      if (_[Oc] && _[Oc](\n        !0\n        /* cancelled */\n      ), n.isUnmounting)\n        return T();\n      S(d, [_]);\n      let A = !1;\n      const Q = _[Ci] = (W) => {\n        A || (A = !0, T(), W ? S(p, [_]) : S(h, [_]), _[Ci] = void 0, v[C] === t && delete v[C]);\n      };\n      v[C] = t, f ? w(f, [_, Q]) : Q();\n    },\n    clone(_) {\n      return Ro(_, e, n, r);\n    }\n  };\n  return k;\n}\nfunction af(t) {\n  if (ta(t))\n    return t = jn(t), t.children = null, t;\n}\nfunction xm(t) {\n  return ta(t) ? (\n    // #7121 ensure get the child component subtree in case\n    // it's been replaced during HMR\n     true && t.component ? t.component.subTree : t.children ? t.children[0] : void 0\n  ) : t;\n}\nfunction Xs(t, e) {\n  t.shapeFlag & 6 && t.component ? Xs(t.component.subTree, e) : t.shapeFlag & 128 ? (t.ssContent.transition = e.clone(t.ssContent), t.ssFallback.transition = e.clone(t.ssFallback)) : t.transition = e;\n}\nfunction Sd(t, e = !1, n) {\n  let r = [], i = 0;\n  for (let s = 0; s < t.length; s++) {\n    let o = t[s];\n    const a = n == null ? o.key : String(n) + String(o.key != null ? o.key : s);\n    o.type === Pe ? (o.patchFlag & 128 && i++, r = r.concat(\n      Sd(o.children, e, a)\n    )) : (e || o.type !== _t) && r.push(a != null ? jn(o, { key: a }) : o);\n  }\n  if (i > 1)\n    for (let s = 0; s < r.length; s++)\n      r[s].patchFlag = -2;\n  return r;\n}\n/*! #__NO_SIDE_EFFECTS__ */\n// @__NO_SIDE_EFFECTS__\nfunction le(t, e) {\n  return be(t) ? (\n    // #8326: extend call and options.name access are considered side-effects\n    // by Rollup, so we have to wrap it in a pure-annotated IIFE.\n    $e({ name: t.name }, e, { setup: t })\n  ) : t;\n}\nconst Ds = (t) => !!t.type.__asyncLoader;\n/*! #__NO_SIDE_EFFECTS__ */\n// @__NO_SIDE_EFFECTS__\nfunction a1(t) {\n  be(t) && (t = { loader: t });\n  const {\n    loader: e,\n    loadingComponent: n,\n    errorComponent: r,\n    delay: i = 200,\n    timeout: s,\n    // undefined = never times out\n    suspensible: o = !0,\n    onError: a\n  } = t;\n  let l = null, c, u = 0;\n  const d = () => (u++, l = null, f()), f = () => {\n    let h;\n    return l || (h = l = e().catch((p) => {\n      if (p = p instanceof Error ? p : new Error(String(p)), a)\n        return new Promise((O, m) => {\n          a(p, () => O(d()), () => m(p), u + 1);\n        });\n      throw p;\n    }).then((p) => {\n      if (h !== l && l)\n        return l;\n      if ( true && !p && I(\n        \"Async component loader resolved to undefined. If you are using retry(), make sure to return its return value.\"\n      ), p && (p.__esModule || p[Symbol.toStringTag] === \"Module\") && (p = p.default),  true && p && !Ze(p) && !be(p))\n        throw new Error(`Invalid async component load result: ${p}`);\n      return c = p, p;\n    }));\n  };\n  return /* @__PURE__ */ le({\n    name: \"AsyncComponentWrapper\",\n    __asyncLoader: f,\n    get __asyncResolved() {\n      return c;\n    },\n    setup() {\n      const h = xt;\n      if (c)\n        return () => lf(c, h);\n      const p = (b) => {\n        l = null, hs(\n          b,\n          h,\n          13,\n          !r\n        );\n      };\n      if (o && h.suspense || Xl)\n        return f().then((b) => () => lf(b, h)).catch((b) => (p(b), () => r ? J(r, {\n          error: b\n        }) : null));\n      const O = G(!1), m = G(), y = G(!!i);\n      return i && setTimeout(() => {\n        y.value = !1;\n      }, i), s != null && setTimeout(() => {\n        if (!O.value && !m.value) {\n          const b = new Error(\n            `Async component timed out after ${s}ms.`\n          );\n          p(b), m.value = b;\n        }\n      }, s), f().then(() => {\n        O.value = !0, h.parent && ta(h.parent.vnode) && (h.parent.effect.dirty = !0, Nl(h.parent.update));\n      }).catch((b) => {\n        p(b), m.value = b;\n      }), () => {\n        if (O.value && c)\n          return lf(c, h);\n        if (m.value && r)\n          return J(r, {\n            error: m.value\n          });\n        if (n && !y.value)\n          return J(n);\n      };\n    }\n  });\n}\nfunction lf(t, e) {\n  const { ref: n, props: r, children: i, ce: s } = e.vnode, o = J(t, r, i);\n  return o.ref = n, o.ce = s, delete e.vnode.ce, o;\n}\nconst ta = (t) => t.type.__isKeepAlive, vE = {\n  name: \"KeepAlive\",\n  // Marker for special handling inside the renderer. We are not using a ===\n  // check directly on KeepAlive in the renderer, because importing it directly\n  // would prevent it from being tree-shaken.\n  __isKeepAlive: !0,\n  props: {\n    include: [String, RegExp, Array],\n    exclude: [String, RegExp, Array],\n    max: [String, Number]\n  },\n  setup(t, { slots: e }) {\n    const n = ir(), r = n.ctx;\n    if (!r.renderer)\n      return () => {\n        const b = e.default && e.default();\n        return b && b.length === 1 ? b[0] : b;\n      };\n    const i = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Set();\n    let o = null;\n    ( true) && (n.__v_cache = i);\n    const a = n.suspense, {\n      renderer: {\n        p: l,\n        m: c,\n        um: u,\n        o: { createElement: d }\n      }\n    } = r, f = d(\"div\");\n    r.activate = (b, g, v, S, w) => {\n      const k = b.component;\n      c(b, g, v, 0, a), l(\n        k.vnode,\n        b,\n        g,\n        v,\n        k,\n        a,\n        S,\n        b.slotScopeIds,\n        w\n      ), Yt(() => {\n        k.isDeactivated = !1, k.a && Ii(k.a);\n        const _ = b.props && b.props.onVnodeMounted;\n        _ && yn(_, k.parent, b);\n      }, a), ( true) && uh(k);\n    }, r.deactivate = (b) => {\n      const g = b.component;\n      c(b, f, null, 1, a), Yt(() => {\n        g.da && Ii(g.da);\n        const v = b.props && b.props.onVnodeUnmounted;\n        v && yn(v, g.parent, b), g.isDeactivated = !0;\n      }, a), ( true) && uh(g);\n    };\n    function h(b) {\n      cf(b), u(b, n, a, !0);\n    }\n    function p(b) {\n      i.forEach((g, v) => {\n        const S = al(g.type);\n        S && (!b || !b(S)) && O(v);\n      });\n    }\n    function O(b) {\n      const g = i.get(b);\n      !o || !lr(g, o) ? h(g) : o && cf(o), i.delete(b), s.delete(b);\n    }\n    ht(\n      () => [t.include, t.exclude],\n      ([b, g]) => {\n        b && p((v) => Qa(b, v)), g && p((v) => !Qa(g, v));\n      },\n      // prune post-render after `current` has been updated\n      { flush: \"post\", deep: !0 }\n    );\n    let m = null;\n    const y = () => {\n      m != null && i.set(m, uf(n.subTree));\n    };\n    return et(y), kd(y), Il(() => {\n      i.forEach((b) => {\n        const { subTree: g, suspense: v } = n, S = uf(g);\n        if (b.type === S.type && b.key === S.key) {\n          cf(S);\n          const w = S.component.da;\n          w && Yt(w, v);\n          return;\n        }\n        h(b);\n      });\n    }), () => {\n      if (m = null, !e.default)\n        return null;\n      const b = e.default(), g = b[0];\n      if (b.length > 1)\n        return  true && I(\"KeepAlive should contain exactly one component child.\"), o = null, b;\n      if (!li(g) || !(g.shapeFlag & 4) && !(g.shapeFlag & 128))\n        return o = null, g;\n      let v = uf(g);\n      const S = v.type, w = al(\n        Ds(v) ? v.type.__asyncResolved || {} : S\n      ), { include: k, exclude: _, max: T } = t;\n      if (k && (!w || !Qa(k, w)) || _ && w && Qa(_, w))\n        return o = v, g;\n      const C = v.key == null ? S : v.key, A = i.get(C);\n      return v.el && (v = jn(v), g.shapeFlag & 128 && (g.ssContent = v)), m = C, A ? (v.el = A.el, v.component = A.component, v.transition && Xs(v, v.transition), v.shapeFlag |= 512, s.delete(C), s.add(C)) : (s.add(C), T && s.size > parseInt(T, 10) && O(s.values().next().value)), v.shapeFlag |= 256, o = v, Ky(g.type) ? g : v;\n    };\n  }\n}, yE = vE;\nfunction Qa(t, e) {\n  return ie(t) ? t.some((n) => Qa(n, e)) : we(t) ? t.split(\",\").includes(e) : N_(t) ? t.test(e) : !1;\n}\nfunction l1(t, e) {\n  u1(t, \"a\", e);\n}\nfunction c1(t, e) {\n  u1(t, \"da\", e);\n}\nfunction u1(t, e, n = xt) {\n  const r = t.__wdc || (t.__wdc = () => {\n    let i = n;\n    for (; i; ) {\n      if (i.isDeactivated)\n        return;\n      i = i.parent;\n    }\n    return t();\n  });\n  if (wd(e, r, n), n) {\n    let i = n.parent;\n    for (; i && i.parent; )\n      ta(i.parent.vnode) && SE(r, e, n, i), i = i.parent;\n  }\n}\nfunction SE(t, e, n, r) {\n  const i = wd(\n    e,\n    t,\n    r,\n    !0\n    /* prepend */\n  );\n  jt(() => {\n    Fp(r[e], i);\n  }, n);\n}\nfunction cf(t) {\n  t.shapeFlag &= -257, t.shapeFlag &= -513;\n}\nfunction uf(t) {\n  return t.shapeFlag & 128 ? t.ssContent : t;\n}\nfunction wd(t, e, n = xt, r = !1) {\n  if (n) {\n    const i = n[t] || (n[t] = []), s = e.__weh || (e.__weh = (...o) => {\n      if (n.isUnmounted)\n        return;\n      ds();\n      const a = Bs(n), l = Wn(e, n, t, o);\n      return a(), fs(), l;\n    });\n    return r ? i.unshift(s) : i.push(s), s;\n  } else if (true) {\n    const i = Tr(md[t].replace(/ hook$/, \"\"));\n    I(\n      `${i} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`\n    );\n  }\n}\nconst gi = (t) => (e, n = xt) => (\n  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)\n  (!Xl || t === \"sp\") && wd(t, (...r) => e(...r), n)\n), d1 = gi(\"bm\"), et = gi(\"m\"), f1 = gi(\"bu\"), kd = gi(\"u\"), Il = gi(\"bum\"), jt = gi(\"um\"), xd = gi(\"sp\"), h1 = gi(\n  \"rtg\"\n), p1 = gi(\n  \"rtc\"\n);\nfunction O1(t, e = xt) {\n  wd(\"ec\", t, e);\n}\nfunction Xr(t, e, n, r) {\n  let i;\n  const s = n && n[r];\n  if (ie(t) || we(t)) {\n    i = new Array(t.length);\n    for (let o = 0, a = t.length; o < a; o++)\n      i[o] = e(t[o], o, void 0, s && s[o]);\n  } else if (typeof t == \"number\") {\n     true && !Number.isInteger(t) && I(`The v-for range expect an integer value but got ${t}.`), i = new Array(t);\n    for (let o = 0; o < t; o++)\n      i[o] = e(o + 1, o, void 0, s && s[o]);\n  } else if (Ze(t))\n    if (t[Symbol.iterator])\n      i = Array.from(\n        t,\n        (o, a) => e(o, a, void 0, s && s[a])\n      );\n    else {\n      const o = Object.keys(t);\n      i = new Array(o.length);\n      for (let a = 0, l = o.length; a < l; a++) {\n        const c = o[a];\n        i[a] = e(t[c], c, a, s && s[a]);\n      }\n    }\n  else\n    i = [];\n  return n && (n[r] = i), i;\n}\nfunction wE(t, e) {\n  for (let n = 0; n < e.length; n++) {\n    const r = e[n];\n    if (ie(r))\n      for (let i = 0; i < r.length; i++)\n        t[r[i].name] = r[i].fn;\n    else\n      r && (t[r.name] = r.key ? (...i) => {\n        const s = r.fn(...i);\n        return s && (s.key = r.key), s;\n      } : r.fn);\n  }\n  return t;\n}\nfunction pt(t, e, n = {}, r, i) {\n  if (Ot.isCE || Ot.parent && Ds(Ot.parent) && Ot.parent.isCE)\n    return e !== \"default\" && (n.name = e), J(\"slot\", n, r && r());\n  let s = t[e];\n   true && s && s.length > 1 && (I(\n    \"SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template.\"\n  ), s = () => []), s && s._c && (s._d = !1), Z();\n  const o = s && g1(s(n)), a = ke(\n    Pe,\n    {\n      key: n.key || // slot content array of a dynamic conditional slot may have a branch\n      // key attached in the `createSlots` helper, respect that\n      o && o.key || `_${e}`\n    },\n    o || (r ? r() : []),\n    o && t._ === 1 ? 64 : -2\n  );\n  return !i && a.scopeId && (a.slotScopeIds = [a.scopeId + \"-s\"]), s && s._c && (s._d = !0), a;\n}\nfunction g1(t) {\n  return t.some((e) => li(e) ? !(e.type === _t || e.type === Pe && !g1(e.children)) : !0) ? t : null;\n}\nfunction kE(t, e) {\n  const n = {};\n  if ( true && !Ze(t))\n    return I(\"v-on with no argument expects an object value.\"), n;\n  for (const r in t)\n    n[e && /[A-Z]/.test(r) ? `on:${r}` : Tr(r)] = t[r];\n  return n;\n}\nconst hh = (t) => t ? I1(t) ? _d(t) || t.proxy : hh(t.parent) : null, Zs = (\n  // Move PURE marker to new line to workaround compiler discarding it\n  // due to type annotation\n  /* @__PURE__ */ $e(/* @__PURE__ */ Object.create(null), {\n    $: (t) => t,\n    $el: (t) => t.vnode.el,\n    $data: (t) => t.data,\n    $props: (t) =>  true ? Dn(t.props) : 0,\n    $attrs: (t) =>  true ? Dn(t.attrs) : 0,\n    $slots: (t) =>  true ? Dn(t.slots) : 0,\n    $refs: (t) =>  true ? Dn(t.refs) : 0,\n    $parent: (t) => hh(t.parent),\n    $root: (t) => hh(t.root),\n    $emit: (t) => t.emit,\n    $options: (t) => __VUE_OPTIONS_API__ ? PO(t) : t.type,\n    $forceUpdate: (t) => t.f || (t.f = () => {\n      t.effect.dirty = !0, Nl(t.update);\n    }),\n    $nextTick: (t) => t.n || (t.n = Pn.bind(t.proxy)),\n    $watch: (t) => __VUE_OPTIONS_API__ ? mE.bind(t) : it\n  })\n), kO = (t) => t === \"_\" || t === \"$\", df = (t, e) => t !== Ve && !t.__isScriptSetup && Ae(t, e), Xa = {\n  get({ _: t }, e) {\n    const { ctx: n, setupState: r, data: i, props: s, accessCache: o, type: a, appContext: l } = t;\n    if ( true && e === \"__isVue\")\n      return !0;\n    let c;\n    if (e[0] !== \"$\") {\n      const h = o[e];\n      if (h !== void 0)\n        switch (h) {\n          case 1:\n            return r[e];\n          case 2:\n            return i[e];\n          case 4:\n            return n[e];\n          case 3:\n            return s[e];\n        }\n      else {\n        if (df(r, e))\n          return o[e] = 1, r[e];\n        if (i !== Ve && Ae(i, e))\n          return o[e] = 2, i[e];\n        if (\n          // only cache other properties when instance has declared (thus stable)\n          // props\n          (c = t.propsOptions[0]) && Ae(c, e)\n        )\n          return o[e] = 3, s[e];\n        if (n !== Ve && Ae(n, e))\n          return o[e] = 4, n[e];\n        (!__VUE_OPTIONS_API__ || ph) && (o[e] = 0);\n      }\n    }\n    const u = Zs[e];\n    let d, f;\n    if (u)\n      return e === \"$attrs\" ? (Kt(t, \"get\", e),  true && wu()) :  true && e === \"$slots\" && Kt(t, \"get\", e), u(t);\n    if (\n      // css module (injected by vue-loader)\n      (d = a.__cssModules) && (d = d[e])\n    )\n      return d;\n    if (n !== Ve && Ae(n, e))\n      return o[e] = 4, n[e];\n    if (\n      // global properties\n      f = l.config.globalProperties, Ae(f, e)\n    )\n      return f[e];\n     true && Ot && (!we(e) || // #1091 avoid internal isRef/isVNode checks on component instance leading\n    // to infinite warning loop\n    e.indexOf(\"__v\") !== 0) && (i !== Ve && kO(e[0]) && Ae(i, e) ? I(\n      `Property ${JSON.stringify(\n        e\n      )} must be accessed via $data because it starts with a reserved character (\"$\" or \"_\") and is not proxied on the render context.`\n    ) : t === Ot && I(\n      `Property ${JSON.stringify(e)} was accessed during render but is not defined on instance.`\n    ));\n  },\n  set({ _: t }, e, n) {\n    const { data: r, setupState: i, ctx: s } = t;\n    return df(i, e) ? (i[e] = n, !0) :  true && i.__isScriptSetup && Ae(i, e) ? (I(`Cannot mutate <script setup> binding \"${e}\" from Options API.`), !1) : r !== Ve && Ae(r, e) ? (r[e] = n, !0) : Ae(t.props, e) ? ( true && I(`Attempting to mutate prop \"${e}\". Props are readonly.`), !1) : e[0] === \"$\" && e.slice(1) in t ? ( true && I(\n      `Attempting to mutate public property \"${e}\". Properties starting with $ are reserved and readonly.`\n    ), !1) : ( true && e in t.appContext.config.globalProperties ? Object.defineProperty(s, e, {\n      enumerable: !0,\n      configurable: !0,\n      value: n\n    }) : s[e] = n, !0);\n  },\n  has({\n    _: { data: t, setupState: e, accessCache: n, ctx: r, appContext: i, propsOptions: s }\n  }, o) {\n    let a;\n    return !!n[o] || t !== Ve && Ae(t, o) || df(e, o) || (a = s[0]) && Ae(a, o) || Ae(r, o) || Ae(Zs, o) || Ae(i.config.globalProperties, o);\n  },\n  defineProperty(t, e, n) {\n    return n.get != null ? t._.accessCache[e] = 0 : Ae(n, \"value\") && this.set(t, e, n.value, null), Reflect.defineProperty(t, e, n);\n  }\n};\n true && (Xa.ownKeys = (t) => (I(\n  \"Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead.\"\n), Reflect.ownKeys(t)));\nconst xE = /* @__PURE__ */ $e(\n  {},\n  Xa,\n  {\n    get(t, e) {\n      if (e !== Symbol.unscopables)\n        return Xa.get(t, e, t);\n    },\n    has(t, e) {\n      const n = e[0] !== \"_\" && !W_(e);\n      return  true && !n && Xa.has(t, e) && I(\n        `Property ${JSON.stringify(\n          e\n        )} should not start with _ which is a reserved prefix for Vue internals.`\n      ), n;\n    }\n  }\n);\nfunction PE(t) {\n  const e = {};\n  return Object.defineProperty(e, \"_\", {\n    configurable: !0,\n    enumerable: !1,\n    get: () => t\n  }), Object.keys(Zs).forEach((n) => {\n    Object.defineProperty(e, n, {\n      configurable: !0,\n      enumerable: !1,\n      get: () => Zs[n](t),\n      // intercepted by the proxy so no need for implementation,\n      // but needed to prevent set errors\n      set: it\n    });\n  }), e;\n}\nfunction _E(t) {\n  const {\n    ctx: e,\n    propsOptions: [n]\n  } = t;\n  n && Object.keys(n).forEach((r) => {\n    Object.defineProperty(e, r, {\n      enumerable: !0,\n      configurable: !0,\n      get: () => t.props[r],\n      set: it\n    });\n  });\n}\nfunction TE(t) {\n  const { ctx: e, setupState: n } = t;\n  Object.keys(Oe(n)).forEach((r) => {\n    if (!n.__isScriptSetup) {\n      if (kO(r[0])) {\n        I(\n          `setup() return property ${JSON.stringify(\n            r\n          )} should not start with \"$\" or \"_\" which are reserved prefixes for Vue internals.`\n        );\n        return;\n      }\n      Object.defineProperty(e, r, {\n        enumerable: !0,\n        configurable: !0,\n        get: () => n[r],\n        set: it\n      });\n    }\n  });\n}\nconst eo = (t) => I(\n  `${t}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`\n);\nfunction EE() {\n  return  true && eo(\"defineProps\"), null;\n}\nfunction $E() {\n  return  true && eo(\"defineEmits\"), null;\n}\nfunction QE(t) {\n   true && eo(\"defineExpose\");\n}\nfunction CE(t) {\n   true && eo(\"defineOptions\");\n}\nfunction AE() {\n  return  true && eo(\"defineSlots\"), null;\n}\nfunction RE() {\n   true && eo(\"defineModel\");\n}\nfunction NE(t, e) {\n  return  true && eo(\"withDefaults\"), null;\n}\nfunction DE() {\n  return m1().slots;\n}\nfunction xO() {\n  return m1().attrs;\n}\nfunction m1() {\n  const t = ir();\n  return  true && !t && I(\"useContext() called without active instance.\"), t.setupContext || (t.setupContext = j1(t));\n}\nfunction ol(t) {\n  return ie(t) ? t.reduce(\n    (e, n) => (e[n] = null, e),\n    {}\n  ) : t;\n}\nfunction ZE(t, e) {\n  const n = ol(t);\n  for (const r in e) {\n    if (r.startsWith(\"__skip\"))\n      continue;\n    let i = n[r];\n    i ? ie(i) || be(i) ? i = n[r] = { type: i, default: e[r] } : i.default = e[r] : i === null ? i = n[r] = { default: e[r] } :  true && I(`props default key \"${r}\" has no corresponding declaration.`), i && e[`__skip_${r}`] && (i.skipFactory = !0);\n  }\n  return n;\n}\nfunction VE(t, e) {\n  return !t || !e ? t || e : ie(t) && ie(e) ? t.concat(e) : $e({}, ol(t), ol(e));\n}\nfunction IE(t, e) {\n  const n = {};\n  for (const r in t)\n    e.includes(r) || Object.defineProperty(n, r, {\n      enumerable: !0,\n      get: () => t[r]\n    });\n  return n;\n}\nfunction WE(t) {\n  const e = ir();\n   true && !e && I(\n    \"withAsyncContext called without active current instance. This is likely a bug.\"\n  );\n  let n = t();\n  return wh(), dd(n) && (n = n.catch((r) => {\n    throw Bs(e), r;\n  })), [n, () => Bs(e)];\n}\nfunction ME() {\n  const t = /* @__PURE__ */ Object.create(null);\n  return (e, n) => {\n    t[n] ? I(`${e} property \"${n}\" is already defined in ${t[n]}.`) : t[n] = e;\n  };\n}\nlet ph = !0;\nfunction XE(t) {\n  const e = PO(t), n = t.proxy, r = t.ctx;\n  ph = !1, e.beforeCreate && Pm(e.beforeCreate, t, \"bc\");\n  const {\n    // state\n    data: i,\n    computed: s,\n    methods: o,\n    watch: a,\n    provide: l,\n    inject: c,\n    // lifecycle\n    created: u,\n    beforeMount: d,\n    mounted: f,\n    beforeUpdate: h,\n    updated: p,\n    activated: O,\n    deactivated: m,\n    beforeDestroy: y,\n    beforeUnmount: b,\n    destroyed: g,\n    unmounted: v,\n    render: S,\n    renderTracked: w,\n    renderTriggered: k,\n    errorCaptured: _,\n    serverPrefetch: T,\n    // public API\n    expose: C,\n    inheritAttrs: A,\n    // assets\n    components: Q,\n    directives: W,\n    filters: L\n  } = e, re =  true ? ME() : 0;\n  if (true) {\n    const [K] = t.propsOptions;\n    if (K)\n      for (const B in K)\n        re(\"Props\", B);\n  }\n  if (c && jE(c, r, re), o)\n    for (const K in o) {\n      const B = o[K];\n      be(B) ? ( true ? Object.defineProperty(r, K, {\n        value: B.bind(n),\n        configurable: !0,\n        enumerable: !0,\n        writable: !0\n      }) : 0,  true && re(\"Methods\", K)) :  true && I(\n        `Method \"${K}\" has type \"${typeof B}\" in the component definition. Did you reference the function correctly?`\n      );\n    }\n  if (i) {\n     true && !be(i) && I(\n      \"The data option must be a function. Plain object usage is no longer supported.\"\n    );\n    const K = i.call(n, n);\n    if ( true && dd(K) && I(\n      \"data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>.\"\n    ), !Ze(K))\n       true && I(\"data() should return an object.\");\n    else if (t.data = Xn(K), \"development\" !== \"production\")\n      for (const B in K)\n        re(\"Data\", B), kO(B[0]) || Object.defineProperty(r, B, {\n          configurable: !0,\n          enumerable: !0,\n          get: () => K[B],\n          set: it\n        });\n  }\n  if (ph = !0, s)\n    for (const K in s) {\n      const B = s[K], _e = be(B) ? B.bind(n, n) : be(B.get) ? B.get.bind(n, n) : it;\n       true && _e === it && I(`Computed property \"${K}\" has no getter.`);\n      const Ce = !be(B) && be(B.set) ? B.set.bind(n) :  true ? () => {\n        I(\n          `Write operation failed: computed property \"${K}\" is readonly.`\n        );\n      } : 0, ue = j({\n        get: _e,\n        set: Ce\n      });\n      Object.defineProperty(r, K, {\n        enumerable: !0,\n        configurable: !0,\n        get: () => ue.value,\n        set: (ge) => ue.value = ge\n      }),  true && re(\"Computed\", K);\n    }\n  if (a)\n    for (const K in a)\n      b1(a[K], r, n, K);\n  if (l) {\n    const K = be(l) ? l.call(n) : l;\n    Reflect.ownKeys(K).forEach((B) => {\n      _n(B, K[B]);\n    });\n  }\n  u && Pm(u, t, \"c\");\n  function Y(K, B) {\n    ie(B) ? B.forEach((_e) => K(_e.bind(n))) : B && K(B.bind(n));\n  }\n  if (Y(d1, d), Y(et, f), Y(f1, h), Y(kd, p), Y(l1, O), Y(c1, m), Y(O1, _), Y(p1, w), Y(h1, k), Y(Il, b), Y(jt, v), Y(xd, T), ie(C))\n    if (C.length) {\n      const K = t.exposed || (t.exposed = {});\n      C.forEach((B) => {\n        Object.defineProperty(K, B, {\n          get: () => n[B],\n          set: (_e) => n[B] = _e\n        });\n      });\n    } else\n      t.exposed || (t.exposed = {});\n  S && t.render === it && (t.render = S), A != null && (t.inheritAttrs = A), Q && (t.components = Q), W && (t.directives = W);\n}\nfunction jE(t, e, n = it) {\n  ie(t) && (t = Oh(t));\n  for (const r in t) {\n    const i = t[r];\n    let s;\n    Ze(i) ? \"default\" in i ? s = Pt(\n      i.from || r,\n      i.default,\n      !0\n    ) : s = Pt(i.from || r) : s = Pt(i), Ct(s) ? Object.defineProperty(e, r, {\n      enumerable: !0,\n      configurable: !0,\n      get: () => s.value,\n      set: (o) => s.value = o\n    }) : e[r] = s,  true && n(\"Inject\", r);\n  }\n}\nfunction Pm(t, e, n) {\n  Wn(\n    ie(t) ? t.map((r) => r.bind(e.proxy)) : t.bind(e.proxy),\n    e,\n    n\n  );\n}\nfunction b1(t, e, n, r) {\n  const i = r.includes(\".\") ? r1(n, r) : () => n[r];\n  if (we(t)) {\n    const s = e[t];\n    be(s) ? ht(i, s) :  true && I(`Invalid watch handler specified by key \"${t}\"`, s);\n  } else if (be(t))\n    ht(i, t.bind(n));\n  else if (Ze(t))\n    if (ie(t))\n      t.forEach((s) => b1(s, e, n, r));\n    else {\n      const s = be(t.handler) ? t.handler.bind(n) : e[t.handler];\n      be(s) ? ht(i, s, t) :  true && I(`Invalid watch handler specified by key \"${t.handler}\"`, s);\n    }\n  else\n     true && I(`Invalid watch option: \"${r}\"`, t);\n}\nfunction PO(t) {\n  const e = t.type, { mixins: n, extends: r } = e, {\n    mixins: i,\n    optionsCache: s,\n    config: { optionMergeStrategies: o }\n  } = t.appContext, a = s.get(e);\n  let l;\n  return a ? l = a : !i.length && !n && !r ? l = e : (l = {}, i.length && i.forEach(\n    (c) => xu(l, c, o, !0)\n  ), xu(l, e, o)), Ze(e) && s.set(e, l), l;\n}\nfunction xu(t, e, n, r = !1) {\n  const { mixins: i, extends: s } = e;\n  s && xu(t, s, n, !0), i && i.forEach(\n    (o) => xu(t, o, n, !0)\n  );\n  for (const o in e)\n    if (r && o === \"expose\")\n       true && I(\n        '\"expose\" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.'\n      );\n    else {\n      const a = BE[o] || n && n[o];\n      t[o] = a ? a(t[o], e[o]) : e[o];\n    }\n  return t;\n}\nconst BE = {\n  data: _m,\n  props: Tm,\n  emits: Tm,\n  // objects\n  methods: Ca,\n  computed: Ca,\n  // lifecycle\n  beforeCreate: fn,\n  created: fn,\n  beforeMount: fn,\n  mounted: fn,\n  beforeUpdate: fn,\n  updated: fn,\n  beforeDestroy: fn,\n  beforeUnmount: fn,\n  destroyed: fn,\n  unmounted: fn,\n  activated: fn,\n  deactivated: fn,\n  errorCaptured: fn,\n  serverPrefetch: fn,\n  // assets\n  components: Ca,\n  directives: Ca,\n  // watch\n  watch: UE,\n  // provide / inject\n  provide: _m,\n  inject: LE\n};\nfunction _m(t, e) {\n  return e ? t ? function() {\n    return $e(\n      be(t) ? t.call(this, this) : t,\n      be(e) ? e.call(this, this) : e\n    );\n  } : e : t;\n}\nfunction LE(t, e) {\n  return Ca(Oh(t), Oh(e));\n}\nfunction Oh(t) {\n  if (ie(t)) {\n    const e = {};\n    for (let n = 0; n < t.length; n++)\n      e[t[n]] = t[n];\n    return e;\n  }\n  return t;\n}\nfunction fn(t, e) {\n  return t ? [...new Set([].concat(t, e))] : e;\n}\nfunction Ca(t, e) {\n  return t ? $e(/* @__PURE__ */ Object.create(null), t, e) : e;\n}\nfunction Tm(t, e) {\n  return t ? ie(t) && ie(e) ? [.../* @__PURE__ */ new Set([...t, ...e])] : $e(\n    /* @__PURE__ */ Object.create(null),\n    ol(t),\n    ol(e ?? {})\n  ) : e;\n}\nfunction UE(t, e) {\n  if (!t)\n    return e;\n  if (!e)\n    return t;\n  const n = $e(/* @__PURE__ */ Object.create(null), t);\n  for (const r in e)\n    n[r] = fn(t[r], e[r]);\n  return n;\n}\nfunction v1() {\n  return {\n    app: null,\n    config: {\n      isNativeTag: zc,\n      performance: !1,\n      globalProperties: {},\n      optionMergeStrategies: {},\n      errorHandler: void 0,\n      warnHandler: void 0,\n      compilerOptions: {}\n    },\n    mixins: [],\n    components: {},\n    directives: {},\n    provides: /* @__PURE__ */ Object.create(null),\n    optionsCache: /* @__PURE__ */ new WeakMap(),\n    propsCache: /* @__PURE__ */ new WeakMap(),\n    emitsCache: /* @__PURE__ */ new WeakMap()\n  };\n}\nlet qE = 0;\nfunction YE(t, e) {\n  return function(r, i = null) {\n    be(r) || (r = $e({}, r)), i != null && !Ze(i) && ( true && I(\"root props passed to app.mount() must be an object.\"), i = null);\n    const s = v1(), o = /* @__PURE__ */ new WeakSet();\n    let a = !1;\n    const l = s.app = {\n      _uid: qE++,\n      _component: r,\n      _props: i,\n      _container: null,\n      _context: s,\n      _instance: null,\n      version: _h,\n      get config() {\n        return s.config;\n      },\n      set config(c) {\n         true && I(\n          \"app.config cannot be replaced. Modify individual options instead.\"\n        );\n      },\n      use(c, ...u) {\n        return o.has(c) ?  true && I(\"Plugin has already been applied to target app.\") : c && be(c.install) ? (o.add(c), c.install(l, ...u)) : be(c) ? (o.add(c), c(l, ...u)) :  true && I(\n          'A plugin must either be a function or an object with an \"install\" function.'\n        ), l;\n      },\n      mixin(c) {\n        return __VUE_OPTIONS_API__ ? s.mixins.includes(c) ?  true && I(\n          \"Mixin has already been applied to target app\" + (c.name ? `: ${c.name}` : \"\")\n        ) : s.mixins.push(c) :  true && I(\"Mixins are only available in builds supporting Options API\"), l;\n      },\n      component(c, u) {\n        return  true && kh(c, s.config), u ? ( true && s.components[c] && I(`Component \"${c}\" has already been registered in target app.`), s.components[c] = u, l) : s.components[c];\n      },\n      directive(c, u) {\n        return  true && i1(c), u ? ( true && s.directives[c] && I(`Directive \"${c}\" has already been registered in target app.`), s.directives[c] = u, l) : s.directives[c];\n      },\n      mount(c, u, d) {\n        if (a)\n           true && I(\n            \"App has already been mounted.\\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. `const createMyApp = () => createApp(App)`\"\n          );\n        else {\n           true && c.__vue_app__ && I(\n            \"There is already an app instance mounted on the host container.\\n If you want to mount another app on the same host container, you need to unmount the previous app by calling `app.unmount()` first.\"\n          );\n          const f = J(r, i);\n          return f.appContext = s, d === !0 ? d = \"svg\" : d === !1 && (d = void 0),  true && (s.reload = () => {\n            t(\n              jn(f),\n              c,\n              d\n            );\n          }), u && e ? e(f, c) : t(f, c, d), a = !0, l._container = c, c.__vue_app__ = l, ( true) && (l._instance = f.component, HT(l, _h)), _d(f.component) || f.component.proxy;\n        }\n      },\n      unmount() {\n        a ? (t(null, l._container), ( true) && (l._instance = null, FT(l)), delete l._container.__vue_app__) :  true && I(\"Cannot unmount an app that is not mounted.\");\n      },\n      provide(c, u) {\n        return  true && c in s.provides && I(\n          `App already provides property with key \"${String(c)}\". It will be overwritten with the new value.`\n        ), s.provides[c] = u, l;\n      },\n      runWithContext(c) {\n        const u = wo;\n        wo = l;\n        try {\n          return c();\n        } finally {\n          wo = u;\n        }\n      }\n    };\n    return l;\n  };\n}\nlet wo = null;\nfunction _n(t, e) {\n  if (!xt)\n     true && I(\"provide() can only be used inside setup().\");\n  else {\n    let n = xt.provides;\n    const r = xt.parent && xt.parent.provides;\n    r === n && (n = xt.provides = Object.create(r)), n[t] = e;\n  }\n}\nfunction Pt(t, e, n = !1) {\n  const r = xt || Ot;\n  if (r || wo) {\n    const i = r ? r.parent == null ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides : wo._context.provides;\n    if (i && t in i)\n      return i[t];\n    if (arguments.length > 1)\n      return n && be(e) ? e.call(r && r.proxy) : e;\n     true && I(`injection \"${String(t)}\" not found.`);\n  } else\n     true && I(\"inject() can only be used inside setup() or functional components.\");\n}\nfunction zE() {\n  return !!(xt || Ot || wo);\n}\nfunction HE(t, e, n, r = !1) {\n  const i = {}, s = {};\n  bu(s, Pd, 1), t.propsDefaults = /* @__PURE__ */ Object.create(null), y1(t, e, i, s);\n  for (const o in t.propsOptions[0])\n    o in i || (i[o] = void 0);\n   true && w1(e || {}, i, t), n ? t.props = r ? i : Iy(i) : t.type.props ? t.props = i : t.props = s, t.attrs = s;\n}\nfunction FE(t) {\n  for (; t; ) {\n    if (t.type.__hmrId)\n      return !0;\n    t = t.parent;\n  }\n}\nfunction GE(t, e, n, r) {\n  const {\n    props: i,\n    attrs: s,\n    vnode: { patchFlag: o }\n  } = t, a = Oe(i), [l] = t.propsOptions;\n  let c = !1;\n  if (\n    // always force full diff in dev\n    // - #1942 if hmr is enabled with sfc component\n    // - vite#872 non-sfc component used by sfc component\n    !( true && FE(t)) && (r || o > 0) && !(o & 16)\n  ) {\n    if (o & 8) {\n      const u = t.vnode.dynamicProps;\n      for (let d = 0; d < u.length; d++) {\n        let f = u[d];\n        if (bd(t.emitsOptions, f))\n          continue;\n        const h = e[f];\n        if (l)\n          if (Ae(s, f))\n            h !== s[f] && (s[f] = h, c = !0);\n          else {\n            const p = mt(f);\n            i[p] = gh(\n              l,\n              a,\n              p,\n              h,\n              t,\n              !1\n            );\n          }\n        else\n          h !== s[f] && (s[f] = h, c = !0);\n      }\n    }\n  } else {\n    y1(t, e, i, s) && (c = !0);\n    let u;\n    for (const d in a)\n      (!e || // for camelCase\n      !Ae(e, d) && // it's possible the original props was passed in as kebab-case\n      // and converted to camelCase (#955)\n      ((u = rn(d)) === d || !Ae(e, u))) && (l ? n && // for camelCase\n      (n[d] !== void 0 || // for kebab-case\n      n[u] !== void 0) && (i[d] = gh(\n        l,\n        a,\n        d,\n        void 0,\n        t,\n        !0\n      )) : delete i[d]);\n    if (s !== a)\n      for (const d in s)\n        (!e || !Ae(e, d)) && (delete s[d], c = !0);\n  }\n  c && Zr(t, \"set\", \"$attrs\"),  true && w1(e || {}, i, t);\n}\nfunction y1(t, e, n, r) {\n  const [i, s] = t.propsOptions;\n  let o = !1, a;\n  if (e)\n    for (let l in e) {\n      if (Ui(l))\n        continue;\n      const c = e[l];\n      let u;\n      i && Ae(i, u = mt(l)) ? !s || !s.includes(u) ? n[u] = c : (a || (a = {}))[u] = c : bd(t.emitsOptions, l) || (!(l in r) || c !== r[l]) && (r[l] = c, o = !0);\n    }\n  if (s) {\n    const l = Oe(n), c = a || Ve;\n    for (let u = 0; u < s.length; u++) {\n      const d = s[u];\n      n[d] = gh(\n        i,\n        l,\n        d,\n        c[d],\n        t,\n        !Ae(c, d)\n      );\n    }\n  }\n  return o;\n}\nfunction gh(t, e, n, r, i, s) {\n  const o = t[n];\n  if (o != null) {\n    const a = Ae(o, \"default\");\n    if (a && r === void 0) {\n      const l = o.default;\n      if (o.type !== Function && !o.skipFactory && be(l)) {\n        const { propsDefaults: c } = i;\n        if (n in c)\n          r = c[n];\n        else {\n          const u = Bs(i);\n          r = c[n] = l.call(\n            null,\n            e\n          ), u();\n        }\n      } else\n        r = l;\n    }\n    o[\n      0\n      /* shouldCast */\n    ] && (s && !a ? r = !1 : o[\n      1\n      /* shouldCastTrue */\n    ] && (r === \"\" || r === rn(n)) && (r = !0));\n  }\n  return r;\n}\nfunction S1(t, e, n = !1) {\n  const r = e.propsCache, i = r.get(t);\n  if (i)\n    return i;\n  const s = t.props, o = {}, a = [];\n  let l = !1;\n  if (__VUE_OPTIONS_API__ && !be(t)) {\n    const u = (d) => {\n      l = !0;\n      const [f, h] = S1(d, e, !0);\n      $e(o, f), h && a.push(...h);\n    };\n    !n && e.mixins.length && e.mixins.forEach(u), t.extends && u(t.extends), t.mixins && t.mixins.forEach(u);\n  }\n  if (!s && !l)\n    return Ze(t) && r.set(t, mo), mo;\n  if (ie(s))\n    for (let u = 0; u < s.length; u++) {\n       true && !we(s[u]) && I(\"props must be strings when using array syntax.\", s[u]);\n      const d = mt(s[u]);\n      Em(d) && (o[d] = Ve);\n    }\n  else if (s) {\n     true && !Ze(s) && I(\"invalid props options\", s);\n    for (const u in s) {\n      const d = mt(u);\n      if (Em(d)) {\n        const f = s[u], h = o[d] = ie(f) || be(f) ? { type: f } : $e({}, f);\n        if (h) {\n          const p = Qm(Boolean, h.type), O = Qm(String, h.type);\n          h[\n            0\n            /* shouldCast */\n          ] = p > -1, h[\n            1\n            /* shouldCastTrue */\n          ] = O < 0 || p < O, (p > -1 || Ae(h, \"default\")) && a.push(d);\n        }\n      }\n    }\n  }\n  const c = [o, a];\n  return Ze(t) && r.set(t, c), c;\n}\nfunction Em(t) {\n  return t[0] !== \"$\" && !Ui(t) ? !0 : ( true && I(`Invalid prop name: \"${t}\" is a reserved property.`), !1);\n}\nfunction mh(t) {\n  return t === null ? \"null\" : typeof t == \"function\" ? t.name || \"\" : typeof t == \"object\" && t.constructor && t.constructor.name || \"\";\n}\nfunction $m(t, e) {\n  return mh(t) === mh(e);\n}\nfunction Qm(t, e) {\n  return ie(e) ? e.findIndex((n) => $m(n, t)) : be(e) && $m(e, t) ? 0 : -1;\n}\nfunction w1(t, e, n) {\n  const r = Oe(e), i = n.propsOptions[0];\n  for (const s in i) {\n    let o = i[s];\n    o != null && KE(\n      s,\n      r[s],\n      o,\n       true ? Dn(r) : 0,\n      !Ae(t, s) && !Ae(t, rn(s))\n    );\n  }\n}\nfunction KE(t, e, n, r, i) {\n  const { type: s, required: o, validator: a, skipCheck: l } = n;\n  if (o && i) {\n    I('Missing required prop: \"' + t + '\"');\n    return;\n  }\n  if (!(e == null && !o)) {\n    if (s != null && s !== !0 && !l) {\n      let c = !1;\n      const u = ie(s) ? s : [s], d = [];\n      for (let f = 0; f < u.length && !c; f++) {\n        const { valid: h, expectedType: p } = e$(e, u[f]);\n        d.push(p || \"\"), c = h;\n      }\n      if (!c) {\n        I(t$(t, e, d));\n        return;\n      }\n    }\n    a && !a(e, r) && I('Invalid prop: custom validator check failed for prop \"' + t + '\".');\n  }\n}\nconst JE = /* @__PURE__ */ Bt(\n  \"String,Number,Boolean,Function,Symbol,BigInt\"\n);\nfunction e$(t, e) {\n  let n;\n  const r = mh(e);\n  if (JE(r)) {\n    const i = typeof t;\n    n = i === r.toLowerCase(), !n && i === \"object\" && (n = t instanceof e);\n  } else\n    r === \"Object\" ? n = Ze(t) : r === \"Array\" ? n = ie(t) : r === \"null\" ? n = t === null : n = t instanceof e;\n  return {\n    valid: n,\n    expectedType: r\n  };\n}\nfunction t$(t, e, n) {\n  if (n.length === 0)\n    return `Prop type [] for prop \"${t}\" won't match anything. Did you mean to use type Array instead?`;\n  let r = `Invalid prop: type check failed for prop \"${t}\". Expected ${n.map(Wr).join(\" | \")}`;\n  const i = n[0], s = Gp(e), o = Cm(e, i), a = Cm(e, s);\n  return n.length === 1 && Am(i) && !n$(i, s) && (r += ` with value ${o}`), r += `, got ${s} `, Am(s) && (r += `with value ${a}.`), r;\n}\nfunction Cm(t, e) {\n  return e === \"String\" ? `\"${t}\"` : e === \"Number\" ? `${Number(t)}` : `${t}`;\n}\nfunction Am(t) {\n  return [\"string\", \"number\", \"boolean\"].some((n) => t.toLowerCase() === n);\n}\nfunction n$(...t) {\n  return t.some((e) => e.toLowerCase() === \"boolean\");\n}\nconst k1 = (t) => t[0] === \"_\" || t === \"$stable\", _O = (t) => ie(t) ? t.map(Sn) : [Sn(t)], r$ = (t, e, n) => {\n  if (e._n)\n    return e;\n  const r = ce((...i) => ( true && xt && (!n || n.root === xt.root) && I(\n    `Slot \"${t}\" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`\n  ), _O(e(...i))), n);\n  return r._c = !1, r;\n}, x1 = (t, e, n) => {\n  const r = t._ctx;\n  for (const i in t) {\n    if (k1(i))\n      continue;\n    const s = t[i];\n    if (be(s))\n      e[i] = r$(i, s, r);\n    else if (s != null) {\n       true && I(\n        `Non-function value encountered for slot \"${i}\". Prefer function slots for better performance.`\n      );\n      const o = _O(s);\n      e[i] = () => o;\n    }\n  }\n}, P1 = (t, e) => {\n   true && !ta(t.vnode) && I(\n    \"Non-function value encountered for default slot. Prefer function slots for better performance.\"\n  );\n  const n = _O(e);\n  t.slots.default = () => n;\n}, i$ = (t, e) => {\n  if (t.vnode.shapeFlag & 32) {\n    const n = e._;\n    n ? (t.slots = Oe(e), bu(e, \"_\", n)) : x1(\n      e,\n      t.slots = {}\n    );\n  } else\n    t.slots = {}, e && P1(t, e);\n  bu(t.slots, Pd, 1);\n}, s$ = (t, e, n) => {\n  const { vnode: r, slots: i } = t;\n  let s = !0, o = Ve;\n  if (r.shapeFlag & 32) {\n    const a = e._;\n    a ?  true && Hi ? ($e(i, e), Zr(t, \"set\", \"$slots\")) : n && a === 1 ? s = !1 : ($e(i, e), !n && a === 1 && delete i._) : (s = !e.$stable, x1(e, i)), o = e;\n  } else\n    e && (P1(t, e), o = { default: 1 });\n  if (s)\n    for (const a in i)\n      !k1(a) && o[a] == null && delete i[a];\n};\nfunction Pu(t, e, n, r, i = !1) {\n  if (ie(t)) {\n    t.forEach(\n      (f, h) => Pu(\n        f,\n        e && (ie(e) ? e[h] : e),\n        n,\n        r,\n        i\n      )\n    );\n    return;\n  }\n  if (Ds(r) && !i)\n    return;\n  const s = r.shapeFlag & 4 ? _d(r.component) || r.component.proxy : r.el, o = i ? null : s, { i: a, r: l } = t;\n  if ( true && !a) {\n    I(\n      \"Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function.\"\n    );\n    return;\n  }\n  const c = e && e.r, u = a.refs === Ve ? a.refs = {} : a.refs, d = a.setupState;\n  if (c != null && c !== l && (we(c) ? (u[c] = null, Ae(d, c) && (d[c] = null)) : Ct(c) && (c.value = null)), be(l))\n    Vr(l, a, 12, [o, u]);\n  else {\n    const f = we(l), h = Ct(l);\n    if (f || h) {\n      const p = () => {\n        if (t.f) {\n          const O = f ? Ae(d, l) ? d[l] : u[l] : l.value;\n          i ? ie(O) && Fp(O, s) : ie(O) ? O.includes(s) || O.push(s) : f ? (u[l] = [s], Ae(d, l) && (d[l] = u[l])) : (l.value = [s], t.k && (u[t.k] = l.value));\n        } else\n          f ? (u[l] = o, Ae(d, l) && (d[l] = o)) : h ? (l.value = o, t.k && (u[t.k] = o)) :  true && I(\"Invalid template ref type:\", l, `(${typeof l})`);\n      };\n      o ? (p.id = -1, Yt(p, n)) : p();\n    } else\n       true && I(\"Invalid template ref type:\", l, `(${typeof l})`);\n  }\n}\nlet Yr = !1;\nconst o$ = (t) => t.namespaceURI.includes(\"svg\") && t.tagName !== \"foreignObject\", a$ = (t) => t.namespaceURI.includes(\"MathML\"), gc = (t) => {\n  if (o$(t))\n    return \"svg\";\n  if (a$(t))\n    return \"mathml\";\n}, ua = (t) => t.nodeType === 8;\nfunction l$(t) {\n  const {\n    mt: e,\n    p: n,\n    o: {\n      patchProp: r,\n      createText: i,\n      nextSibling: s,\n      parentNode: o,\n      remove: a,\n      insert: l,\n      createComment: c\n    }\n  } = t, u = (g, v) => {\n    if (!v.hasChildNodes()) {\n      ( true) && I(\n        \"Attempting to hydrate existing markup but container is empty. Performing full mount instead.\"\n      ), n(null, g, v), Su(), v._vnode = g;\n      return;\n    }\n    Yr = !1, d(v.firstChild, g, null, null, null), Su(), v._vnode = g, Yr && console.error(\"Hydration completed but contains mismatches.\");\n  }, d = (g, v, S, w, k, _ = !1) => {\n    const T = ua(g) && g.data === \"[\", C = () => O(\n      g,\n      v,\n      S,\n      w,\n      k,\n      T\n    ), { type: A, ref: Q, shapeFlag: W, patchFlag: L } = v;\n    let re = g.nodeType;\n    v.el = g, ( true) && (\"__vnode\" in g || Object.defineProperty(g, \"__vnode\", {\n      value: v,\n      enumerable: !1\n    }), \"__vueParentComponent\" in g || Object.defineProperty(g, \"__vueParentComponent\", {\n      value: S,\n      enumerable: !1\n    })), L === -2 && (_ = !1, v.dynamicChildren = null);\n    let Y = null;\n    switch (A) {\n      case ns:\n        re !== 3 ? v.children === \"\" ? (l(v.el = i(\"\"), o(g), g), Y = g) : Y = C() : (g.data !== v.children && (Yr = !0, ( true) && I(\n          \"Hydration text mismatch in\",\n          g.parentNode,\n          `\n  - rendered on server: ${JSON.stringify(\n            g.data\n          )}\n  - expected on client: ${JSON.stringify(v.children)}`\n        ), g.data = v.children), Y = s(g));\n        break;\n      case _t:\n        b(g) ? (Y = s(g), y(\n          v.el = g.content.firstChild,\n          g,\n          S\n        )) : re !== 8 || T ? Y = C() : Y = s(g);\n        break;\n      case Fi:\n        if (T && (g = s(g), re = g.nodeType), re === 1 || re === 3) {\n          Y = g;\n          const K = !v.children.length;\n          for (let B = 0; B < v.staticCount; B++)\n            K && (v.children += Y.nodeType === 1 ? Y.outerHTML : Y.data), B === v.staticCount - 1 && (v.anchor = Y), Y = s(Y);\n          return T ? s(Y) : Y;\n        } else\n          C();\n        break;\n      case Pe:\n        T ? Y = p(\n          g,\n          v,\n          S,\n          w,\n          k,\n          _\n        ) : Y = C();\n        break;\n      default:\n        if (W & 1)\n          (re !== 1 || v.type.toLowerCase() !== g.tagName.toLowerCase()) && !b(g) ? Y = C() : Y = f(\n            g,\n            v,\n            S,\n            w,\n            k,\n            _\n          );\n        else if (W & 6) {\n          v.slotScopeIds = k;\n          const K = o(g);\n          if (T ? Y = m(g) : ua(g) && g.data === \"teleport start\" ? Y = m(g, g.data, \"teleport end\") : Y = s(g), e(\n            v,\n            K,\n            null,\n            S,\n            w,\n            gc(K),\n            _\n          ), Ds(v)) {\n            let B;\n            T ? (B = J(Pe), B.anchor = Y ? Y.previousSibling : K.lastChild) : B = g.nodeType === 3 ? He(\"\") : J(\"div\"), B.el = g, v.component.subTree = B;\n          }\n        } else\n          W & 64 ? re !== 8 ? Y = C() : Y = v.type.hydrate(\n            g,\n            v,\n            S,\n            w,\n            k,\n            _,\n            t,\n            h\n          ) : W & 128 ? Y = v.type.hydrate(\n            g,\n            v,\n            S,\n            w,\n            gc(o(g)),\n            k,\n            _,\n            t,\n            d\n          ) : ( true) && I(\"Invalid HostVNode type:\", A, `(${typeof A})`);\n    }\n    return Q != null && Pu(Q, null, w, v), Y;\n  }, f = (g, v, S, w, k, _) => {\n    _ = _ || !!v.dynamicChildren;\n    const { type: T, props: C, patchFlag: A, shapeFlag: Q, dirs: W, transition: L } = v, re = T === \"input\" || T === \"option\";\n    if (true) {\n      W && _r(v, null, S, \"created\");\n      let Y = !1;\n      if (b(g)) {\n        Y = $1(w, L) && S && S.vnode.props && S.vnode.props.appear;\n        const B = g.content.firstChild;\n        Y && L.beforeEnter(B), y(B, g, S), v.el = g = B;\n      }\n      if (Q & 16 && // skip if element has innerHTML / textContent\n      !(C && (C.innerHTML || C.textContent))) {\n        let B = h(\n          g.firstChild,\n          v,\n          g,\n          S,\n          w,\n          k,\n          _\n        ), _e = !1;\n        for (; B; ) {\n          Yr = !0, ( true) && !_e && (I(\n            \"Hydration children mismatch on\",\n            g,\n            `\nServer rendered element contains more child nodes than client vdom.`\n          ), _e = !0);\n          const Ce = B;\n          B = B.nextSibling, a(Ce);\n        }\n      } else\n        Q & 8 && g.textContent !== v.children && (Yr = !0, ( true) && I(\n          \"Hydration text content mismatch on\",\n          g,\n          `\n  - rendered on server: ${g.textContent}\n  - expected on client: ${v.children}`\n        ), g.textContent = v.children);\n      if (C)\n        if (true)\n          for (const B in C)\n             true && c$(g, B, C[B], v, S) && (Yr = !0), (re && (B.endsWith(\"value\") || B === \"indeterminate\") || oi(B) && !Ui(B) || // force hydrate v-bind with .prop modifiers\n            B[0] === \".\") && r(\n              g,\n              B,\n              null,\n              C[B],\n              void 0,\n              void 0,\n              S\n            );\n        else\n          {}\n      let K;\n      (K = C && C.onVnodeBeforeMount) && yn(K, S, v), W && _r(v, null, S, \"beforeMount\"), ((K = C && C.onVnodeMounted) || W || Y) && Jy(() => {\n        K && yn(K, S, v), Y && L.enter(g), W && _r(v, null, S, \"mounted\");\n      }, w);\n    }\n    return g.nextSibling;\n  }, h = (g, v, S, w, k, _, T) => {\n    T = T || !!v.dynamicChildren;\n    const C = v.children, A = C.length;\n    let Q = !1;\n    for (let W = 0; W < A; W++) {\n      const L = T ? C[W] : C[W] = Sn(C[W]);\n      if (g)\n        g = d(\n          g,\n          L,\n          w,\n          k,\n          _,\n          T\n        );\n      else {\n        if (L.type === ns && !L.children)\n          continue;\n        Yr = !0, ( true) && !Q && (I(\n          \"Hydration children mismatch on\",\n          S,\n          `\nServer rendered element contains fewer child nodes than client vdom.`\n        ), Q = !0), n(\n          null,\n          L,\n          S,\n          null,\n          w,\n          k,\n          gc(S),\n          _\n        );\n      }\n    }\n    return g;\n  }, p = (g, v, S, w, k, _) => {\n    const { slotScopeIds: T } = v;\n    T && (k = k ? k.concat(T) : T);\n    const C = o(g), A = h(\n      s(g),\n      v,\n      C,\n      S,\n      w,\n      k,\n      _\n    );\n    return A && ua(A) && A.data === \"]\" ? s(v.anchor = A) : (Yr = !0, l(v.anchor = c(\"]\"), C, A), A);\n  }, O = (g, v, S, w, k, _) => {\n    if (Yr = !0, ( true) && I(\n      `Hydration node mismatch:\n- rendered on server:`,\n      g,\n      g.nodeType === 3 ? \"(text)\" : ua(g) && g.data === \"[\" ? \"(start of fragment)\" : \"\",\n      `\n- expected on client:`,\n      v.type\n    ), v.el = null, _) {\n      const A = m(g);\n      for (; ; ) {\n        const Q = s(g);\n        if (Q && Q !== A)\n          a(Q);\n        else\n          break;\n      }\n    }\n    const T = s(g), C = o(g);\n    return a(g), n(\n      null,\n      v,\n      C,\n      T,\n      S,\n      w,\n      gc(C),\n      k\n    ), T;\n  }, m = (g, v = \"[\", S = \"]\") => {\n    let w = 0;\n    for (; g; )\n      if (g = s(g), g && ua(g) && (g.data === v && w++, g.data === S)) {\n        if (w === 0)\n          return s(g);\n        w--;\n      }\n    return g;\n  }, y = (g, v, S) => {\n    const w = v.parentNode;\n    w && w.replaceChild(g, v);\n    let k = S;\n    for (; k; )\n      k.vnode.el === v && (k.vnode.el = k.subTree.el = g), k = k.parent;\n  }, b = (g) => g.nodeType === 1 && g.tagName.toLowerCase() === \"template\";\n  return [u, d];\n}\nfunction c$(t, e, n, r, i) {\n  var s;\n  let o, a, l, c;\n  if (e === \"class\")\n    l = t.getAttribute(\"class\"), c = Ke(n), u$(Rm(l || \"\"), Rm(c)) || (o = a = \"class\");\n  else if (e === \"style\") {\n    l = t.getAttribute(\"style\"), c = we(n) ? n : L_(Br(n));\n    const u = Nm(l), d = Nm(c);\n    if (r.dirs)\n      for (const { dir: h, value: p } of r.dirs)\n        h.name === \"show\" && !p && d.set(\"display\", \"none\");\n    const f = i == null ? void 0 : i.subTree;\n    if (r === f || (f == null ? void 0 : f.type) === Pe && f.children.includes(r)) {\n      const h = (s = i == null ? void 0 : i.getCssVars) == null ? void 0 : s.call(i);\n      for (const p in h)\n        d.set(`--${p}`, String(h[p]));\n    }\n    d$(u, d) || (o = a = \"style\");\n  } else\n    (t instanceof SVGElement && K_(e) || t instanceof HTMLElement && (cm(e) || G_(e))) && (cm(e) ? (l = t.hasAttribute(e), c = Jp(n)) : n == null ? (l = t.hasAttribute(e), c = !1) : (t.hasAttribute(e) ? l = t.getAttribute(e) : e === \"value\" && t.tagName === \"TEXTAREA\" ? l = t.value : l = !1, c = J_(n) ? String(n) : !1), l !== c && (o = \"attribute\", a = e));\n  if (o) {\n    const u = (h) => h === !1 ? \"(not rendered)\" : `${a}=\"${h}\"`, d = `Hydration ${o} mismatch on`, f = `\n  - rendered on server: ${u(l)}\n  - expected on client: ${u(c)}\n  Note: this mismatch is check-only. The DOM will not be rectified in production due to performance overhead.\n  You should fix the source of the mismatch.`;\n    return I(d, t, f), !0;\n  }\n  return !1;\n}\nfunction Rm(t) {\n  return new Set(t.trim().split(/\\s+/));\n}\nfunction u$(t, e) {\n  if (t.size !== e.size)\n    return !1;\n  for (const n of t)\n    if (!e.has(n))\n      return !1;\n  return !0;\n}\nfunction Nm(t) {\n  const e = /* @__PURE__ */ new Map();\n  for (const n of t.split(\";\")) {\n    let [r, i] = n.split(\":\");\n    r = r == null ? void 0 : r.trim(), i = i == null ? void 0 : i.trim(), r && i && e.set(r, i);\n  }\n  return e;\n}\nfunction d$(t, e) {\n  if (t.size !== e.size)\n    return !1;\n  for (const [n, r] of t)\n    if (r !== e.get(n))\n      return !1;\n  return !0;\n}\nlet da, Wi;\nfunction Fr(t, e) {\n  t.appContext.config.performance && _u() && Wi.mark(`vue-${e}-${t.uid}`), ( true) && JT(t, e, _u() ? Wi.now() : Date.now());\n}\nfunction Gr(t, e) {\n  if (t.appContext.config.performance && _u()) {\n    const n = `vue-${e}-${t.uid}`, r = n + \":end\";\n    Wi.mark(r), Wi.measure(\n      `<${Td(t, t.type)}> ${e}`,\n      n,\n      r\n    ), Wi.clearMarks(n), Wi.clearMarks(r);\n  }\n  ( true) && eE(t, e, _u() ? Wi.now() : Date.now());\n}\nfunction _u() {\n  return da !== void 0 || (typeof window < \"u\" && window.performance ? (da = !0, Wi = window.performance) : da = !1), da;\n}\nfunction f$() {\n  const t = [];\n  if (typeof __VUE_OPTIONS_API__ != \"boolean\" && ( true && t.push(\"__VUE_OPTIONS_API__\"), bo().__VUE_OPTIONS_API__ = !0), typeof __VUE_PROD_DEVTOOLS__ != \"boolean\" && ( true && t.push(\"__VUE_PROD_DEVTOOLS__\"), bo().__VUE_PROD_DEVTOOLS__ = !1), typeof __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ != \"boolean\" && ( true && t.push(\"__VUE_PROD_HYDRATION_MISMATCH_DETAILS__\"), bo().__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ = !1),  true && t.length) {\n    const e = t.length > 1;\n    console.warn(\n      `Feature flag${e ? \"s\" : \"\"} ${t.join(\", \")} ${e ? \"are\" : \"is\"} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.\n\nFor more details, see https://link.vuejs.org/feature-flags.`\n    );\n  }\n}\nconst Yt = Jy;\nfunction _1(t) {\n  return E1(t);\n}\nfunction T1(t) {\n  return E1(t, l$);\n}\nfunction E1(t, e) {\n  f$();\n  const n = bo();\n  n.__VUE__ = !0, ( true) && pO(n.__VUE_DEVTOOLS_GLOBAL_HOOK__, n);\n  const {\n    insert: r,\n    remove: i,\n    patchProp: s,\n    createElement: o,\n    createText: a,\n    createComment: l,\n    setText: c,\n    setElementText: u,\n    parentNode: d,\n    nextSibling: f,\n    setScopeId: h = it,\n    insertStaticContent: p\n  } = t, O = (x, $, N, M = null, X = null, z = null, ee = void 0, H = null, F =  true && Hi ? !1 : !!$.dynamicChildren) => {\n    if (x === $)\n      return;\n    x && !lr(x, $) && (M = Tn(x), Be(x, X, z, !0), x = null), $.patchFlag === -2 && (F = !1, $.dynamicChildren = null);\n    const { type: U, ref: se, shapeFlag: me } = $;\n    switch (U) {\n      case ns:\n        m(x, $, N, M);\n        break;\n      case _t:\n        y(x, $, N, M);\n        break;\n      case Fi:\n        x == null ? b($, N, M, ee) :  true && g(x, $, N, ee);\n        break;\n      case Pe:\n        W(\n          x,\n          $,\n          N,\n          M,\n          X,\n          z,\n          ee,\n          H,\n          F\n        );\n        break;\n      default:\n        me & 1 ? w(\n          x,\n          $,\n          N,\n          M,\n          X,\n          z,\n          ee,\n          H,\n          F\n        ) : me & 6 ? L(\n          x,\n          $,\n          N,\n          M,\n          X,\n          z,\n          ee,\n          H,\n          F\n        ) : me & 64 || me & 128 ? U.process(\n          x,\n          $,\n          N,\n          M,\n          X,\n          z,\n          ee,\n          H,\n          F,\n          En\n        ) :  true && I(\"Invalid VNode type:\", U, `(${typeof U})`);\n    }\n    se != null && X && Pu(se, x && x.ref, z, $ || x, !$);\n  }, m = (x, $, N, M) => {\n    if (x == null)\n      r(\n        $.el = a($.children),\n        N,\n        M\n      );\n    else {\n      const X = $.el = x.el;\n      $.children !== x.children && c(X, $.children);\n    }\n  }, y = (x, $, N, M) => {\n    x == null ? r(\n      $.el = l($.children || \"\"),\n      N,\n      M\n    ) : $.el = x.el;\n  }, b = (x, $, N, M) => {\n    [x.el, x.anchor] = p(\n      x.children,\n      $,\n      N,\n      M,\n      x.el,\n      x.anchor\n    );\n  }, g = (x, $, N, M) => {\n    if ($.children !== x.children) {\n      const X = f(x.anchor);\n      S(x), [$.el, $.anchor] = p(\n        $.children,\n        N,\n        X,\n        M\n      );\n    } else\n      $.el = x.el, $.anchor = x.anchor;\n  }, v = ({ el: x, anchor: $ }, N, M) => {\n    let X;\n    for (; x && x !== $; )\n      X = f(x), r(x, N, M), x = X;\n    r($, N, M);\n  }, S = ({ el: x, anchor: $ }) => {\n    let N;\n    for (; x && x !== $; )\n      N = f(x), i(x), x = N;\n    i($);\n  }, w = (x, $, N, M, X, z, ee, H, F) => {\n    $.type === \"svg\" ? ee = \"svg\" : $.type === \"math\" && (ee = \"mathml\"), x == null ? k(\n      $,\n      N,\n      M,\n      X,\n      z,\n      ee,\n      H,\n      F\n    ) : C(\n      x,\n      $,\n      X,\n      z,\n      ee,\n      H,\n      F\n    );\n  }, k = (x, $, N, M, X, z, ee, H) => {\n    let F, U;\n    const { props: se, shapeFlag: me, transition: he, dirs: ye } = x;\n    if (F = x.el = o(\n      x.type,\n      z,\n      se && se.is,\n      se\n    ), me & 8 ? u(F, x.children) : me & 16 && T(\n      x.children,\n      F,\n      null,\n      M,\n      X,\n      ff(x, z),\n      ee,\n      H\n    ), ye && _r(x, null, M, \"created\"), _(F, x, x.scopeId, ee, M), se) {\n      for (const Ue in se)\n        Ue !== \"value\" && !Ui(Ue) && s(\n          F,\n          Ue,\n          null,\n          se[Ue],\n          z,\n          x.children,\n          M,\n          X,\n          It\n        );\n      \"value\" in se && s(F, \"value\", null, se.value, z), (U = se.onVnodeBeforeMount) && yn(U, M, x);\n    }\n    ( true) && (Object.defineProperty(F, \"__vnode\", {\n      value: x,\n      enumerable: !1\n    }), Object.defineProperty(F, \"__vueParentComponent\", {\n      value: M,\n      enumerable: !1\n    })), ye && _r(x, null, M, \"beforeMount\");\n    const Qe = $1(X, he);\n    Qe && he.beforeEnter(F), r(F, $, N), ((U = se && se.onVnodeMounted) || Qe || ye) && Yt(() => {\n      U && yn(U, M, x), Qe && he.enter(F), ye && _r(x, null, M, \"mounted\");\n    }, X);\n  }, _ = (x, $, N, M, X) => {\n    if (N && h(x, N), M)\n      for (let z = 0; z < M.length; z++)\n        h(x, M[z]);\n    if (X) {\n      let z = X.subTree;\n      if ( true && z.patchFlag > 0 && z.patchFlag & 2048 && (z = yd(z.children) || z), $ === z) {\n        const ee = X.vnode;\n        _(\n          x,\n          ee,\n          ee.scopeId,\n          ee.slotScopeIds,\n          X.parent\n        );\n      }\n    }\n  }, T = (x, $, N, M, X, z, ee, H, F = 0) => {\n    for (let U = F; U < x.length; U++) {\n      const se = x[U] = H ? Ai(x[U]) : Sn(x[U]);\n      O(\n        null,\n        se,\n        $,\n        N,\n        M,\n        X,\n        z,\n        ee,\n        H\n      );\n    }\n  }, C = (x, $, N, M, X, z, ee) => {\n    const H = $.el = x.el;\n    let { patchFlag: F, dynamicChildren: U, dirs: se } = $;\n    F |= x.patchFlag & 16;\n    const me = x.props || Ve, he = $.props || Ve;\n    let ye;\n    if (N && Os(N, !1), (ye = he.onVnodeBeforeUpdate) && yn(ye, N, $, x), se && _r($, x, N, \"beforeUpdate\"), N && Os(N, !0),  true && Hi && (F = 0, ee = !1, U = null), U ? (A(\n      x.dynamicChildren,\n      U,\n      H,\n      N,\n      M,\n      ff($, X),\n      z\n    ),  true && ja(x, $)) : ee || _e(\n      x,\n      $,\n      H,\n      null,\n      N,\n      M,\n      ff($, X),\n      z,\n      !1\n    ), F > 0) {\n      if (F & 16)\n        Q(\n          H,\n          $,\n          me,\n          he,\n          N,\n          M,\n          X\n        );\n      else if (F & 2 && me.class !== he.class && s(H, \"class\", null, he.class, X), F & 4 && s(H, \"style\", me.style, he.style, X), F & 8) {\n        const Qe = $.dynamicProps;\n        for (let Ue = 0; Ue < Qe.length; Ue++) {\n          const tt = Qe[Ue], bt = me[tt], $n = he[tt];\n          ($n !== bt || tt === \"value\") && s(\n            H,\n            tt,\n            bt,\n            $n,\n            X,\n            x.children,\n            N,\n            M,\n            It\n          );\n        }\n      }\n      F & 1 && x.children !== $.children && u(H, $.children);\n    } else\n      !ee && U == null && Q(\n        H,\n        $,\n        me,\n        he,\n        N,\n        M,\n        X\n      );\n    ((ye = he.onVnodeUpdated) || se) && Yt(() => {\n      ye && yn(ye, N, $, x), se && _r($, x, N, \"updated\");\n    }, M);\n  }, A = (x, $, N, M, X, z, ee) => {\n    for (let H = 0; H < $.length; H++) {\n      const F = x[H], U = $[H], se = (\n        // oldVNode may be an errored async setup() component inside Suspense\n        // which will not have a mounted element\n        F.el && // - In the case of a Fragment, we need to provide the actual parent\n        // of the Fragment itself so it can move its children.\n        (F.type === Pe || // - In the case of different nodes, there is going to be a replacement\n        // which also requires the correct parent container\n        !lr(F, U) || // - In the case of a component, it could contain anything.\n        F.shapeFlag & 70) ? d(F.el) : (\n          // In other cases, the parent container is not actually used so we\n          // just pass the block element here to avoid a DOM parentNode call.\n          N\n        )\n      );\n      O(\n        F,\n        U,\n        se,\n        null,\n        M,\n        X,\n        z,\n        ee,\n        !0\n      );\n    }\n  }, Q = (x, $, N, M, X, z, ee) => {\n    if (N !== M) {\n      if (N !== Ve)\n        for (const H in N)\n          !Ui(H) && !(H in M) && s(\n            x,\n            H,\n            N[H],\n            null,\n            ee,\n            $.children,\n            X,\n            z,\n            It\n          );\n      for (const H in M) {\n        if (Ui(H))\n          continue;\n        const F = M[H], U = N[H];\n        F !== U && H !== \"value\" && s(\n          x,\n          H,\n          U,\n          F,\n          ee,\n          $.children,\n          X,\n          z,\n          It\n        );\n      }\n      \"value\" in M && s(x, \"value\", N.value, M.value, ee);\n    }\n  }, W = (x, $, N, M, X, z, ee, H, F) => {\n    const U = $.el = x ? x.el : a(\"\"), se = $.anchor = x ? x.anchor : a(\"\");\n    let { patchFlag: me, dynamicChildren: he, slotScopeIds: ye } = $;\n     true && // #5523 dev root fragment may inherit directives\n    (Hi || me & 2048) && (me = 0, F = !1, he = null), ye && (H = H ? H.concat(ye) : ye), x == null ? (r(U, N, M), r(se, N, M), T(\n      // #10007\n      // such fragment like `<></>` will be compiled into\n      // a fragment which doesn't have a children.\n      // In this case fallback to an empty array\n      $.children || [],\n      N,\n      se,\n      X,\n      z,\n      ee,\n      H,\n      F\n    )) : me > 0 && me & 64 && he && // #2715 the previous fragment could've been a BAILed one as a result\n    // of renderSlot() with no valid children\n    x.dynamicChildren ? (A(\n      x.dynamicChildren,\n      he,\n      N,\n      X,\n      z,\n      ee,\n      H\n    ),  true ? ja(x, $) : (\n      // #2080 if the stable fragment has a key, it's a <template v-for> that may\n      //  get moved around. Make sure all root level vnodes inherit el.\n      // #2134 or if it's a component root, it may also get moved around\n      // as the component is being moved.\n      0\n    )) : _e(\n      x,\n      $,\n      N,\n      se,\n      X,\n      z,\n      ee,\n      H,\n      F\n    );\n  }, L = (x, $, N, M, X, z, ee, H, F) => {\n    $.slotScopeIds = H, x == null ? $.shapeFlag & 512 ? X.ctx.activate(\n      $,\n      N,\n      M,\n      ee,\n      F\n    ) : re(\n      $,\n      N,\n      M,\n      X,\n      z,\n      ee,\n      F\n    ) : Y(x, $, F);\n  }, re = (x, $, N, M, X, z, ee) => {\n    const H = x.component = V1(\n      x,\n      M,\n      X\n    );\n    if ( true && H.type.__hmrId && UT(H),  true && (Ia(x), Fr(H, \"mount\")), ta(x) && (H.ctx.renderer = En),  true && Fr(H, \"init\"), W1(H),  true && Gr(H, \"init\"), H.asyncDep) {\n      if (X && X.registerDep(H, K), !x.el) {\n        const F = H.subTree = J(_t);\n        y(null, F, $, N);\n      }\n    } else\n      K(\n        H,\n        x,\n        $,\n        N,\n        X,\n        z,\n        ee\n      );\n     true && (Wa(), Gr(H, \"mount\"));\n  }, Y = (x, $, N) => {\n    const M = $.component = x.component;\n    if (oE(x, $, N))\n      if (M.asyncDep && !M.asyncResolved) {\n         true && Ia($), B(M, $, N),  true && Wa();\n        return;\n      } else\n        M.next = $, BT(M.update), M.effect.dirty = !0, M.update();\n    else\n      $.el = x.el, M.vnode = $;\n  }, K = (x, $, N, M, X, z, ee) => {\n    const H = () => {\n      if (x.isMounted) {\n        let { next: se, bu: me, u: he, parent: ye, vnode: Qe } = x;\n        {\n          const yi = Q1(x);\n          if (yi) {\n            se && (se.el = Qe.el, B(x, se, ee)), yi.asyncDep.then(() => {\n              x.isUnmounted || H();\n            });\n            return;\n          }\n        }\n        let Ue = se, tt;\n         true && Ia(se || x.vnode), Os(x, !1), se ? (se.el = Qe.el, B(x, se, ee)) : se = Qe, me && Ii(me), (tt = se.props && se.props.onVnodeBeforeUpdate) && yn(tt, ye, se, Qe), Os(x, !0),  true && Fr(x, \"render\");\n        const bt = Hc(x);\n         true && Gr(x, \"render\");\n        const $n = x.subTree;\n        x.subTree = bt,  true && Fr(x, \"patch\"), O(\n          $n,\n          bt,\n          // parent may have changed if it's in a teleport\n          d($n.el),\n          // anchor may have changed if it's in a fragment\n          Tn($n),\n          x,\n          X,\n          z\n        ),  true && Gr(x, \"patch\"), se.el = bt.el, Ue === null && gO(x, bt.el), he && Yt(he, X), (tt = se.props && se.props.onVnodeUpdated) && Yt(\n          () => yn(tt, ye, se, Qe),\n          X\n        ), ( true) && zy(x),  true && Wa();\n      } else {\n        let se;\n        const { el: me, props: he } = $, { bm: ye, m: Qe, parent: Ue } = x, tt = Ds($);\n        if (Os(x, !1), ye && Ii(ye), !tt && (se = he && he.onVnodeBeforeMount) && yn(se, Ue, $), Os(x, !0), me && Ur) {\n          const bt = () => {\n             true && Fr(x, \"render\"), x.subTree = Hc(x),  true && Gr(x, \"render\"),  true && Fr(x, \"hydrate\"), Ur(\n              me,\n              x.subTree,\n              x,\n              X,\n              null\n            ),  true && Gr(x, \"hydrate\");\n          };\n          tt ? $.type.__asyncLoader().then(\n            // note: we are moving the render call into an async callback,\n            // which means it won't track dependencies - but it's ok because\n            // a server-rendered async wrapper is already in resolved state\n            // and it will never need to change.\n            () => !x.isUnmounted && bt()\n          ) : bt();\n        } else {\n           true && Fr(x, \"render\");\n          const bt = x.subTree = Hc(x);\n           true && Gr(x, \"render\"),  true && Fr(x, \"patch\"), O(\n            null,\n            bt,\n            N,\n            M,\n            x,\n            X,\n            z\n          ),  true && Gr(x, \"patch\"), $.el = bt.el;\n        }\n        if (Qe && Yt(Qe, X), !tt && (se = he && he.onVnodeMounted)) {\n          const bt = $;\n          Yt(\n            () => yn(se, Ue, bt),\n            X\n          );\n        }\n        ($.shapeFlag & 256 || Ue && Ds(Ue.vnode) && Ue.vnode.shapeFlag & 256) && x.a && Yt(x.a, X), x.isMounted = !0, ( true) && uh(x), $ = N = M = null;\n      }\n    }, F = x.effect = new Ao(\n      H,\n      it,\n      () => Nl(U),\n      x.scope\n      // track it in component's effect scope\n    ), U = x.update = () => {\n      F.dirty && F.run();\n    };\n    U.id = x.uid, Os(x, !0),  true && (F.onTrack = x.rtc ? (se) => Ii(x.rtc, se) : void 0, F.onTrigger = x.rtg ? (se) => Ii(x.rtg, se) : void 0, U.ownerInstance = x), U();\n  }, B = (x, $, N) => {\n    $.component = x;\n    const M = x.vnode.props;\n    x.vnode = $, x.next = null, GE(x, $.props, M, N), s$(x, $.children, N), ds(), mm(x), fs();\n  }, _e = (x, $, N, M, X, z, ee, H, F = !1) => {\n    const U = x && x.children, se = x ? x.shapeFlag : 0, me = $.children, { patchFlag: he, shapeFlag: ye } = $;\n    if (he > 0) {\n      if (he & 128) {\n        ue(\n          U,\n          me,\n          N,\n          M,\n          X,\n          z,\n          ee,\n          H,\n          F\n        );\n        return;\n      } else if (he & 256) {\n        Ce(\n          U,\n          me,\n          N,\n          M,\n          X,\n          z,\n          ee,\n          H,\n          F\n        );\n        return;\n      }\n    }\n    ye & 8 ? (se & 16 && It(U, X, z), me !== U && u(N, me)) : se & 16 ? ye & 16 ? ue(\n      U,\n      me,\n      N,\n      M,\n      X,\n      z,\n      ee,\n      H,\n      F\n    ) : It(U, X, z, !0) : (se & 8 && u(N, \"\"), ye & 16 && T(\n      me,\n      N,\n      M,\n      X,\n      z,\n      ee,\n      H,\n      F\n    ));\n  }, Ce = (x, $, N, M, X, z, ee, H, F) => {\n    x = x || mo, $ = $ || mo;\n    const U = x.length, se = $.length, me = Math.min(U, se);\n    let he;\n    for (he = 0; he < me; he++) {\n      const ye = $[he] = F ? Ai($[he]) : Sn($[he]);\n      O(\n        x[he],\n        ye,\n        N,\n        null,\n        X,\n        z,\n        ee,\n        H,\n        F\n      );\n    }\n    U > se ? It(\n      x,\n      X,\n      z,\n      !0,\n      !1,\n      me\n    ) : T(\n      $,\n      N,\n      M,\n      X,\n      z,\n      ee,\n      H,\n      F,\n      me\n    );\n  }, ue = (x, $, N, M, X, z, ee, H, F) => {\n    let U = 0;\n    const se = $.length;\n    let me = x.length - 1, he = se - 1;\n    for (; U <= me && U <= he; ) {\n      const ye = x[U], Qe = $[U] = F ? Ai($[U]) : Sn($[U]);\n      if (lr(ye, Qe))\n        O(\n          ye,\n          Qe,\n          N,\n          null,\n          X,\n          z,\n          ee,\n          H,\n          F\n        );\n      else\n        break;\n      U++;\n    }\n    for (; U <= me && U <= he; ) {\n      const ye = x[me], Qe = $[he] = F ? Ai($[he]) : Sn($[he]);\n      if (lr(ye, Qe))\n        O(\n          ye,\n          Qe,\n          N,\n          null,\n          X,\n          z,\n          ee,\n          H,\n          F\n        );\n      else\n        break;\n      me--, he--;\n    }\n    if (U > me) {\n      if (U <= he) {\n        const ye = he + 1, Qe = ye < se ? $[ye].el : M;\n        for (; U <= he; )\n          O(\n            null,\n            $[U] = F ? Ai($[U]) : Sn($[U]),\n            N,\n            Qe,\n            X,\n            z,\n            ee,\n            H,\n            F\n          ), U++;\n      }\n    } else if (U > he)\n      for (; U <= me; )\n        Be(x[U], X, z, !0), U++;\n    else {\n      const ye = U, Qe = U, Ue = /* @__PURE__ */ new Map();\n      for (U = Qe; U <= he; U++) {\n        const Lt = $[U] = F ? Ai($[U]) : Sn($[U]);\n        Lt.key != null && ( true && Ue.has(Lt.key) && I(\n          \"Duplicate keys found during update:\",\n          JSON.stringify(Lt.key),\n          \"Make sure keys are unique.\"\n        ), Ue.set(Lt.key, U));\n      }\n      let tt, bt = 0;\n      const $n = he - Qe + 1;\n      let yi = !1, ac = 0;\n      const ps = new Array($n);\n      for (U = 0; U < $n; U++)\n        ps[U] = 0;\n      for (U = ye; U <= me; U++) {\n        const Lt = x[U];\n        if (bt >= $n) {\n          Be(Lt, X, z, !0);\n          continue;\n        }\n        let Un;\n        if (Lt.key != null)\n          Un = Ue.get(Lt.key);\n        else\n          for (tt = Qe; tt <= he; tt++)\n            if (ps[tt - Qe] === 0 && lr(Lt, $[tt])) {\n              Un = tt;\n              break;\n            }\n        Un === void 0 ? Be(Lt, X, z, !0) : (ps[Un - Qe] = U + 1, Un >= ac ? ac = Un : yi = !0, O(\n          Lt,\n          $[Un],\n          N,\n          null,\n          X,\n          z,\n          ee,\n          H,\n          F\n        ), bt++);\n      }\n      const lc = yi ? h$(ps) : mo;\n      for (tt = lc.length - 1, U = $n - 1; U >= 0; U--) {\n        const Lt = Qe + U, Un = $[Lt], ro = Lt + 1 < se ? $[Lt + 1].el : M;\n        ps[U] === 0 ? O(\n          null,\n          Un,\n          N,\n          ro,\n          X,\n          z,\n          ee,\n          H,\n          F\n        ) : yi && (tt < 0 || U !== lc[tt] ? ge(Un, N, ro, 2) : tt--);\n      }\n    }\n  }, ge = (x, $, N, M, X = null) => {\n    const { el: z, type: ee, transition: H, children: F, shapeFlag: U } = x;\n    if (U & 6) {\n      ge(x.component.subTree, $, N, M);\n      return;\n    }\n    if (U & 128) {\n      x.suspense.move($, N, M);\n      return;\n    }\n    if (U & 64) {\n      ee.move(x, $, N, En);\n      return;\n    }\n    if (ee === Pe) {\n      r(z, $, N);\n      for (let me = 0; me < F.length; me++)\n        ge(F[me], $, N, M);\n      r(x.anchor, $, N);\n      return;\n    }\n    if (ee === Fi) {\n      v(x, $, N);\n      return;\n    }\n    if (M !== 2 && U & 1 && H)\n      if (M === 0)\n        H.beforeEnter(z), r(z, $, N), Yt(() => H.enter(z), X);\n      else {\n        const { leave: me, delayLeave: he, afterLeave: ye } = H, Qe = () => r(z, $, N), Ue = () => {\n          me(z, () => {\n            Qe(), ye && ye();\n          });\n        };\n        he ? he(z, Qe, Ue) : Ue();\n      }\n    else\n      r(z, $, N);\n  }, Be = (x, $, N, M = !1, X = !1) => {\n    const {\n      type: z,\n      props: ee,\n      ref: H,\n      children: F,\n      dynamicChildren: U,\n      shapeFlag: se,\n      patchFlag: me,\n      dirs: he\n    } = x;\n    if (H != null && Pu(H, null, N, x, !0), se & 256) {\n      $.ctx.deactivate(x);\n      return;\n    }\n    const ye = se & 1 && he, Qe = !Ds(x);\n    let Ue;\n    if (Qe && (Ue = ee && ee.onVnodeBeforeUnmount) && yn(Ue, $, x), se & 6)\n      Vt(x.component, N, M);\n    else {\n      if (se & 128) {\n        x.suspense.unmount(N, M);\n        return;\n      }\n      ye && _r(x, null, $, \"beforeUnmount\"), se & 64 ? x.type.remove(\n        x,\n        $,\n        N,\n        X,\n        En,\n        M\n      ) : U && // #1153: fast path should not be taken for non-stable (v-for) fragments\n      (z !== Pe || me > 0 && me & 64) ? It(\n        U,\n        $,\n        N,\n        !1,\n        !0\n      ) : (z === Pe && me & 384 || !X && se & 16) && It(F, $, N), M && Le(x);\n    }\n    (Qe && (Ue = ee && ee.onVnodeUnmounted) || ye) && Yt(() => {\n      Ue && yn(Ue, $, x), ye && _r(x, null, $, \"unmounted\");\n    }, N);\n  }, Le = (x) => {\n    const { type: $, el: N, anchor: M, transition: X } = x;\n    if ($ === Pe) {\n       true && x.patchFlag > 0 && x.patchFlag & 2048 && X && !X.persisted ? x.children.forEach((ee) => {\n        ee.type === _t ? i(ee.el) : Le(ee);\n      }) : Zt(N, M);\n      return;\n    }\n    if ($ === Fi) {\n      S(x);\n      return;\n    }\n    const z = () => {\n      i(N), X && !X.persisted && X.afterLeave && X.afterLeave();\n    };\n    if (x.shapeFlag & 1 && X && !X.persisted) {\n      const { leave: ee, delayLeave: H } = X, F = () => ee(N, z);\n      H ? H(x.el, z, F) : F();\n    } else\n      z();\n  }, Zt = (x, $) => {\n    let N;\n    for (; x !== $; )\n      N = f(x), i(x), x = N;\n    i($);\n  }, Vt = (x, $, N) => {\n     true && x.type.__hmrId && qT(x);\n    const { bum: M, scope: X, update: z, subTree: ee, um: H } = x;\n    M && Ii(M), X.stop(), z && (z.active = !1, Be(ee, x, $, N)), H && Yt(H, $), Yt(() => {\n      x.isUnmounted = !0;\n    }, $), $ && $.pendingBranch && !$.isUnmounted && x.asyncDep && !x.asyncResolved && x.suspenseId === $.pendingId && ($.deps--, $.deps === 0 && $.resolve()), ( true) && KT(x);\n  }, It = (x, $, N, M = !1, X = !1, z = 0) => {\n    for (let ee = z; ee < x.length; ee++)\n      Be(x[ee], $, N, M, X);\n  }, Tn = (x) => x.shapeFlag & 6 ? Tn(x.component.subTree) : x.shapeFlag & 128 ? x.suspense.next() : f(x.anchor || x.el);\n  let Sr = !1;\n  const or = (x, $, N) => {\n    x == null ? $._vnode && Be($._vnode, null, null, !0) : O(\n      $._vnode || null,\n      x,\n      $,\n      null,\n      null,\n      null,\n      N\n    ), Sr || (Sr = !0, mm(), Su(), Sr = !1), $._vnode = x;\n  }, En = {\n    p: O,\n    um: Be,\n    m: ge,\n    r: Le,\n    mt: re,\n    mc: T,\n    pc: _e,\n    pbc: A,\n    n: Tn,\n    o: t\n  };\n  let vi, Ur;\n  return e && ([vi, Ur] = e(\n    En\n  )), {\n    render: or,\n    hydrate: vi,\n    createApp: YE(or, vi)\n  };\n}\nfunction ff({ type: t, props: e }, n) {\n  return n === \"svg\" && t === \"foreignObject\" || n === \"mathml\" && t === \"annotation-xml\" && e && e.encoding && e.encoding.includes(\"html\") ? void 0 : n;\n}\nfunction Os({ effect: t, update: e }, n) {\n  t.allowRecurse = e.allowRecurse = n;\n}\nfunction $1(t, e) {\n  return (!t || t && !t.pendingBranch) && e && !e.persisted;\n}\nfunction ja(t, e, n = !1) {\n  const r = t.children, i = e.children;\n  if (ie(r) && ie(i))\n    for (let s = 0; s < r.length; s++) {\n      const o = r[s];\n      let a = i[s];\n      a.shapeFlag & 1 && !a.dynamicChildren && ((a.patchFlag <= 0 || a.patchFlag === 32) && (a = i[s] = Ai(i[s]), a.el = o.el), n || ja(o, a)), a.type === ns && (a.el = o.el),  true && a.type === _t && !a.el && (a.el = o.el);\n    }\n}\nfunction h$(t) {\n  const e = t.slice(), n = [0];\n  let r, i, s, o, a;\n  const l = t.length;\n  for (r = 0; r < l; r++) {\n    const c = t[r];\n    if (c !== 0) {\n      if (i = n[n.length - 1], t[i] < c) {\n        e[r] = i, n.push(r);\n        continue;\n      }\n      for (s = 0, o = n.length - 1; s < o; )\n        a = s + o >> 1, t[n[a]] < c ? s = a + 1 : o = a;\n      c < t[n[s]] && (s > 0 && (e[r] = n[s - 1]), n[s] = r);\n    }\n  }\n  for (s = n.length, o = n[s - 1]; s-- > 0; )\n    n[s] = o, o = e[o];\n  return n;\n}\nfunction Q1(t) {\n  const e = t.subTree.component;\n  if (e)\n    return e.asyncDep && !e.asyncResolved ? e : Q1(e);\n}\nconst p$ = (t) => t.__isTeleport, ko = (t) => t && (t.disabled || t.disabled === \"\"), Dm = (t) => typeof SVGElement < \"u\" && t instanceof SVGElement, Zm = (t) => typeof MathMLElement == \"function\" && t instanceof MathMLElement, bh = (t, e) => {\n  const n = t && t.to;\n  if (we(n))\n    if (e) {\n      const r = e(n);\n      return r ||  true && I(\n        `Failed to locate Teleport target with selector \"${n}\". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`\n      ), r;\n    } else\n      return  true && I(\n        \"Current renderer does not support string target for Teleports. (missing querySelector renderer option)\"\n      ), null;\n  else\n    return  true && !n && !ko(t) && I(`Invalid Teleport target: ${n}`), n;\n}, O$ = {\n  name: \"Teleport\",\n  __isTeleport: !0,\n  process(t, e, n, r, i, s, o, a, l, c) {\n    const {\n      mc: u,\n      pc: d,\n      pbc: f,\n      o: { insert: h, querySelector: p, createText: O, createComment: m }\n    } = c, y = ko(e.props);\n    let { shapeFlag: b, children: g, dynamicChildren: v } = e;\n    if ( true && Hi && (l = !1, v = null), t == null) {\n      const S = e.el =  true ? m(\"teleport start\") : 0, w = e.anchor =  true ? m(\"teleport end\") : 0;\n      h(S, n, r), h(w, n, r);\n      const k = e.target = bh(e.props, p), _ = e.targetAnchor = O(\"\");\n      k ? (h(_, k), o === \"svg\" || Dm(k) ? o = \"svg\" : (o === \"mathml\" || Zm(k)) && (o = \"mathml\")) :  true && !y && I(\"Invalid Teleport target on mount:\", k, `(${typeof k})`);\n      const T = (C, A) => {\n        b & 16 && u(\n          g,\n          C,\n          A,\n          i,\n          s,\n          o,\n          a,\n          l\n        );\n      };\n      y ? T(n, w) : k && T(k, _);\n    } else {\n      e.el = t.el;\n      const S = e.anchor = t.anchor, w = e.target = t.target, k = e.targetAnchor = t.targetAnchor, _ = ko(t.props), T = _ ? n : w, C = _ ? S : k;\n      if (o === \"svg\" || Dm(w) ? o = \"svg\" : (o === \"mathml\" || Zm(w)) && (o = \"mathml\"), v ? (f(\n        t.dynamicChildren,\n        v,\n        T,\n        i,\n        s,\n        o,\n        a\n      ), ja(t, e, !0)) : l || d(\n        t,\n        e,\n        T,\n        C,\n        i,\n        s,\n        o,\n        a,\n        !1\n      ), y)\n        _ ? e.props && t.props && e.props.to !== t.props.to && (e.props.to = t.props.to) : mc(\n          e,\n          n,\n          S,\n          c,\n          1\n        );\n      else if ((e.props && e.props.to) !== (t.props && t.props.to)) {\n        const A = e.target = bh(\n          e.props,\n          p\n        );\n        A ? mc(\n          e,\n          A,\n          null,\n          c,\n          0\n        ) :  true && I(\n          \"Invalid Teleport target on update:\",\n          w,\n          `(${typeof w})`\n        );\n      } else\n        _ && mc(\n          e,\n          w,\n          k,\n          c,\n          1\n        );\n    }\n    C1(e);\n  },\n  remove(t, e, n, r, { um: i, o: { remove: s } }, o) {\n    const { shapeFlag: a, children: l, anchor: c, targetAnchor: u, target: d, props: f } = t;\n    if (d && s(u), o && s(c), a & 16) {\n      const h = o || !ko(f);\n      for (let p = 0; p < l.length; p++) {\n        const O = l[p];\n        i(\n          O,\n          e,\n          n,\n          h,\n          !!O.dynamicChildren\n        );\n      }\n    }\n  },\n  move: mc,\n  hydrate: g$\n};\nfunction mc(t, e, n, { o: { insert: r }, m: i }, s = 2) {\n  s === 0 && r(t.targetAnchor, e, n);\n  const { el: o, anchor: a, shapeFlag: l, children: c, props: u } = t, d = s === 2;\n  if (d && r(o, e, n), (!d || ko(u)) && l & 16)\n    for (let f = 0; f < c.length; f++)\n      i(\n        c[f],\n        e,\n        n,\n        2\n      );\n  d && r(a, e, n);\n}\nfunction g$(t, e, n, r, i, s, {\n  o: { nextSibling: o, parentNode: a, querySelector: l }\n}, c) {\n  const u = e.target = bh(\n    e.props,\n    l\n  );\n  if (u) {\n    const d = u._lpa || u.firstChild;\n    if (e.shapeFlag & 16)\n      if (ko(e.props))\n        e.anchor = c(\n          o(t),\n          e,\n          a(t),\n          n,\n          r,\n          i,\n          s\n        ), e.targetAnchor = d;\n      else {\n        e.anchor = o(t);\n        let f = d;\n        for (; f; )\n          if (f = o(f), f && f.nodeType === 8 && f.data === \"teleport anchor\") {\n            e.targetAnchor = f, u._lpa = e.targetAnchor && o(e.targetAnchor);\n            break;\n          }\n        c(\n          d,\n          e,\n          u,\n          n,\n          r,\n          i,\n          s\n        );\n      }\n    C1(e);\n  }\n  return e.anchor && o(e.anchor);\n}\nconst TO = O$;\nfunction C1(t) {\n  const e = t.ctx;\n  if (e && e.ut) {\n    let n = t.children[0].el;\n    for (; n && n !== t.targetAnchor; )\n      n.nodeType === 1 && n.setAttribute(\"data-v-owner\", e.uid), n = n.nextSibling;\n    e.ut();\n  }\n}\nconst Pe = Symbol.for(\"v-fgt\"), ns = Symbol.for(\"v-txt\"), _t = Symbol.for(\"v-cmt\"), Fi = Symbol.for(\"v-stc\"), Ba = [];\nlet kn = null;\nfunction Z(t = !1) {\n  Ba.push(kn = t ? null : []);\n}\nfunction A1() {\n  Ba.pop(), kn = Ba[Ba.length - 1] || null;\n}\nlet js = 1;\nfunction vh(t) {\n  js += t;\n}\nfunction R1(t) {\n  return t.dynamicChildren = js > 0 ? kn || mo : null, A1(), js > 0 && kn && kn.push(t), t;\n}\nfunction ne(t, e, n, r, i, s) {\n  return R1(\n    D(\n      t,\n      e,\n      n,\n      r,\n      i,\n      s,\n      !0\n    )\n  );\n}\nfunction ke(t, e, n, r, i) {\n  return R1(\n    J(\n      t,\n      e,\n      n,\n      r,\n      i,\n      !0\n    )\n  );\n}\nfunction li(t) {\n  return t ? t.__v_isVNode === !0 : !1;\n}\nfunction lr(t, e) {\n  return  true && e.shapeFlag & 6 && uo.has(e.type) ? (t.shapeFlag &= -257, e.shapeFlag &= -513, !1) : t.type === e.type && t.key === e.key;\n}\nlet yh;\nfunction m$(t) {\n  yh = t;\n}\nconst b$ = (...t) => D1(\n  ...yh ? yh(t, Ot) : t\n), Pd = \"__vInternal\", N1 = ({ key: t }) => t ?? null, Fc = ({\n  ref: t,\n  ref_key: e,\n  ref_for: n\n}) => (typeof t == \"number\" && (t = \"\" + t), t != null ? we(t) || Ct(t) || be(t) ? { i: Ot, r: t, k: e, f: !!n } : t : null);\nfunction D(t, e = null, n = null, r = 0, i = null, s = t === Pe ? 0 : 1, o = !1, a = !1) {\n  const l = {\n    __v_isVNode: !0,\n    __v_skip: !0,\n    type: t,\n    props: e,\n    key: e && N1(e),\n    ref: e && Fc(e),\n    scopeId: vd,\n    slotScopeIds: null,\n    children: n,\n    component: null,\n    suspense: null,\n    ssContent: null,\n    ssFallback: null,\n    dirs: null,\n    transition: null,\n    el: null,\n    anchor: null,\n    target: null,\n    targetAnchor: null,\n    staticCount: 0,\n    shapeFlag: s,\n    patchFlag: r,\n    dynamicProps: i,\n    dynamicChildren: null,\n    appContext: null,\n    ctx: Ot\n  };\n  return a ? ($O(l, n), s & 128 && t.normalize(l)) : n && (l.shapeFlag |= we(n) ? 8 : 16),  true && l.key !== l.key && I(\"VNode created with invalid key (NaN). VNode type:\", l.type), js > 0 && // avoid a block node from tracking itself\n  !o && // has current parent block\n  kn && // presence of a patch flag indicates this node needs patching on updates.\n  // component nodes also should always be patched, because even if the\n  // component doesn't need to update, it needs to persist the instance on to\n  // the next vnode so that it can be properly unmounted later.\n  (l.patchFlag > 0 || s & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the\n  // vnode should not be considered dynamic due to handler caching.\n  l.patchFlag !== 32 && kn.push(l), l;\n}\nconst J =  true ? b$ : 0;\nfunction D1(t, e = null, n = null, r = 0, i = null, s = !1) {\n  if ((!t || t === mO) && ( true && !t && I(`Invalid vnode type when creating vnode: ${t}.`), t = _t), li(t)) {\n    const a = jn(\n      t,\n      e,\n      !0\n      /* mergeRef: true */\n    );\n    return n && $O(a, n), js > 0 && !s && kn && (a.shapeFlag & 6 ? kn[kn.indexOf(t)] = a : kn.push(a)), a.patchFlag |= -2, a;\n  }\n  if (B1(t) && (t = t.__vccOpts), e) {\n    e = EO(e);\n    let { class: a, style: l } = e;\n    a && !we(a) && (e.class = Ke(a)), Ze(l) && (Ja(l) && !ie(l) && (l = $e({}, l)), e.style = Br(l));\n  }\n  const o = we(t) ? 1 : Ky(t) ? 128 : p$(t) ? 64 : Ze(t) ? 4 : be(t) ? 2 : 0;\n  return  true && o & 4 && Ja(t) && (t = Oe(t), I(\n    \"Vue received a Component that was made a reactive object. This can lead to unnecessary performance overhead and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.\",\n    `\nComponent that was made reactive: `,\n    t\n  )), D(\n    t,\n    e,\n    n,\n    r,\n    i,\n    o,\n    s,\n    !0\n  );\n}\nfunction EO(t) {\n  return t ? Ja(t) || Pd in t ? $e({}, t) : t : null;\n}\nfunction jn(t, e, n = !1) {\n  const { props: r, ref: i, patchFlag: s, children: o } = t, a = e ? Ml(r || {}, e) : r;\n  return {\n    __v_isVNode: !0,\n    __v_skip: !0,\n    type: t.type,\n    props: a,\n    key: a && N1(a),\n    ref: e && e.ref ? (\n      // #2078 in the case of <component :is=\"vnode\" ref=\"extra\"/>\n      // if the vnode itself already has a ref, cloneVNode will need to merge\n      // the refs so the single vnode can be set on multiple refs\n      n && i ? ie(i) ? i.concat(Fc(e)) : [i, Fc(e)] : Fc(e)\n    ) : i,\n    scopeId: t.scopeId,\n    slotScopeIds: t.slotScopeIds,\n    children:  true && s === -1 && ie(o) ? o.map(Z1) : o,\n    target: t.target,\n    targetAnchor: t.targetAnchor,\n    staticCount: t.staticCount,\n    shapeFlag: t.shapeFlag,\n    // if the vnode is cloned with extra props, we can no longer assume its\n    // existing patch flag to be reliable and need to add the FULL_PROPS flag.\n    // note: preserve flag for fragments since they use the flag for children\n    // fast paths only.\n    patchFlag: e && t.type !== Pe ? s === -1 ? 16 : s | 16 : s,\n    dynamicProps: t.dynamicProps,\n    dynamicChildren: t.dynamicChildren,\n    appContext: t.appContext,\n    dirs: t.dirs,\n    transition: t.transition,\n    // These should technically only be non-null on mounted VNodes. However,\n    // they *should* be copied for kept-alive vnodes. So we just always copy\n    // them since them being non-null during a mount doesn't affect the logic as\n    // they will simply be overwritten.\n    component: t.component,\n    suspense: t.suspense,\n    ssContent: t.ssContent && jn(t.ssContent),\n    ssFallback: t.ssFallback && jn(t.ssFallback),\n    el: t.el,\n    anchor: t.anchor,\n    ctx: t.ctx,\n    ce: t.ce\n  };\n}\nfunction Z1(t) {\n  const e = jn(t);\n  return ie(t.children) && (e.children = t.children.map(Z1)), e;\n}\nfunction He(t = \" \", e = 0) {\n  return J(ns, null, t, e);\n}\nfunction Wl(t, e) {\n  const n = J(Fi, null, t);\n  return n.staticCount = e, n;\n}\nfunction st(t = \"\", e = !1) {\n  return e ? (Z(), ke(_t, null, t)) : J(_t, null, t);\n}\nfunction Sn(t) {\n  return t == null || typeof t == \"boolean\" ? J(_t) : ie(t) ? J(\n    Pe,\n    null,\n    // #3666, avoid reference pollution when reusing vnode\n    t.slice()\n  ) : typeof t == \"object\" ? Ai(t) : J(ns, null, String(t));\n}\nfunction Ai(t) {\n  return t.el === null && t.patchFlag !== -1 || t.memo ? t : jn(t);\n}\nfunction $O(t, e) {\n  let n = 0;\n  const { shapeFlag: r } = t;\n  if (e == null)\n    e = null;\n  else if (ie(e))\n    n = 16;\n  else if (typeof e == \"object\")\n    if (r & 65) {\n      const i = e.default;\n      i && (i._c && (i._d = !1), $O(t, i()), i._c && (i._d = !0));\n      return;\n    } else {\n      n = 32;\n      const i = e._;\n      !i && !(Pd in e) ? e._ctx = Ot : i === 3 && Ot && (Ot.slots._ === 1 ? e._ = 1 : (e._ = 2, t.patchFlag |= 1024));\n    }\n  else\n    be(e) ? (e = { default: e, _ctx: Ot }, n = 32) : (e = String(e), r & 64 ? (n = 16, e = [He(e)]) : n = 8);\n  t.children = e, t.shapeFlag |= n;\n}\nfunction Ml(...t) {\n  const e = {};\n  for (let n = 0; n < t.length; n++) {\n    const r = t[n];\n    for (const i in r)\n      if (i === \"class\")\n        e.class !== r.class && (e.class = Ke([e.class, r.class]));\n      else if (i === \"style\")\n        e.style = Br([e.style, r.style]);\n      else if (oi(i)) {\n        const s = e[i], o = r[i];\n        o && s !== o && !(ie(s) && s.includes(o)) && (e[i] = s ? [].concat(s, o) : o);\n      } else\n        i !== \"\" && (e[i] = r[i]);\n  }\n  return e;\n}\nfunction yn(t, e, n, r = null) {\n  Wn(t, e, 7, [\n    n,\n    r\n  ]);\n}\nconst v$ = v1();\nlet y$ = 0;\nfunction V1(t, e, n) {\n  const r = t.type, i = (e ? e.appContext : t.appContext) || v$, s = {\n    uid: y$++,\n    vnode: t,\n    type: r,\n    parent: e,\n    appContext: i,\n    root: null,\n    // to be immediately set\n    next: null,\n    subTree: null,\n    // will be set synchronously right after creation\n    effect: null,\n    update: null,\n    // will be set synchronously right after creation\n    scope: new eO(\n      !0\n      /* detached */\n    ),\n    render: null,\n    proxy: null,\n    exposed: null,\n    exposeProxy: null,\n    withProxy: null,\n    provides: e ? e.provides : Object.create(i.provides),\n    accessCache: null,\n    renderCache: [],\n    // local resolved assets\n    components: null,\n    directives: null,\n    // resolved props and emits options\n    propsOptions: S1(r, i),\n    emitsOptions: Fy(r, i),\n    // emit\n    emit: null,\n    // to be set immediately\n    emitted: null,\n    // props default value\n    propsDefaults: Ve,\n    // inheritAttrs\n    inheritAttrs: r.inheritAttrs,\n    // state\n    ctx: Ve,\n    data: Ve,\n    props: Ve,\n    attrs: Ve,\n    slots: Ve,\n    refs: Ve,\n    setupState: Ve,\n    setupContext: null,\n    attrsProxy: null,\n    slotsProxy: null,\n    // suspense related\n    suspense: n,\n    suspenseId: n ? n.pendingId : 0,\n    asyncDep: null,\n    asyncResolved: !1,\n    // lifecycle hooks\n    // not using enums here because it results in computed properties\n    isMounted: !1,\n    isUnmounted: !1,\n    isDeactivated: !1,\n    bc: null,\n    c: null,\n    bm: null,\n    m: null,\n    bu: null,\n    u: null,\n    um: null,\n    bum: null,\n    da: null,\n    a: null,\n    rtg: null,\n    rtc: null,\n    ec: null,\n    sp: null\n  };\n  return  true ? s.ctx = PE(s) : 0, s.root = e ? e.root : s, s.emit = nE.bind(null, s), t.ce && t.ce(s), s;\n}\nlet xt = null;\nconst ir = () => xt || Ot;\nlet Tu, Sh;\n{\n  const t = bo(), e = (n, r) => {\n    let i;\n    return (i = t[n]) || (i = t[n] = []), i.push(r), (s) => {\n      i.length > 1 ? i.forEach((o) => o(s)) : i[0](s);\n    };\n  };\n  Tu = e(\n    \"__VUE_INSTANCE_SETTERS__\",\n    (n) => xt = n\n  ), Sh = e(\n    \"__VUE_SSR_SETTERS__\",\n    (n) => Xl = n\n  );\n}\nconst Bs = (t) => {\n  const e = xt;\n  return Tu(t), t.scope.on(), () => {\n    t.scope.off(), Tu(e);\n  };\n}, wh = () => {\n  xt && xt.scope.off(), Tu(null);\n}, S$ = /* @__PURE__ */ Bt(\"slot,component\");\nfunction kh(t, { isNativeTag: e }) {\n  (S$(t) || e(t)) && I(\n    \"Do not use built-in or reserved HTML elements as component id: \" + t\n  );\n}\nfunction I1(t) {\n  return t.vnode.shapeFlag & 4;\n}\nlet Xl = !1;\nfunction W1(t, e = !1) {\n  e && Sh(e);\n  const { props: n, children: r } = t.vnode, i = I1(t);\n  HE(t, n, i, e), i$(t, r);\n  const s = i ? w$(t, e) : void 0;\n  return e && Sh(!1), s;\n}\nfunction w$(t, e) {\n  var n;\n  const r = t.type;\n  if (true) {\n    if (r.name && kh(r.name, t.appContext.config), r.components) {\n      const s = Object.keys(r.components);\n      for (let o = 0; o < s.length; o++)\n        kh(s[o], t.appContext.config);\n    }\n    if (r.directives) {\n      const s = Object.keys(r.directives);\n      for (let o = 0; o < s.length; o++)\n        i1(s[o]);\n    }\n    r.compilerOptions && QO() && I(\n      '\"compilerOptions\" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.'\n    );\n  }\n  t.accessCache = /* @__PURE__ */ Object.create(null), t.proxy = oO(new Proxy(t.ctx, Xa)),  true && _E(t);\n  const { setup: i } = r;\n  if (i) {\n    const s = t.setupContext = i.length > 1 ? j1(t) : null, o = Bs(t);\n    ds();\n    const a = Vr(\n      i,\n      t,\n      0,\n      [\n         true ? Dn(t.props) : 0,\n        s\n      ]\n    );\n    if (fs(), o(), dd(a)) {\n      if (a.then(wh, wh), e)\n        return a.then((l) => {\n          xh(t, l, e);\n        }).catch((l) => {\n          hs(l, t, 0);\n        });\n      if (t.asyncDep = a,  true && !t.suspense) {\n        const l = (n = r.name) != null ? n : \"Anonymous\";\n        I(\n          `Component <${l}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`\n        );\n      }\n    } else\n      xh(t, a, e);\n  } else\n    X1(t, e);\n}\nfunction xh(t, e, n) {\n  be(e) ? t.type.__ssrInlineRender ? t.ssrRender = e : t.render = e : Ze(e) ? ( true && li(e) && I(\n    \"setup() should not return VNodes directly - return a render function instead.\"\n  ), ( true) && (t.devtoolsRawSetupState = e), t.setupState = uO(e),  true && TE(t)) :  true && e !== void 0 && I(\n    `setup() should return an object. Received: ${e === null ? \"null\" : typeof e}`\n  ), X1(t, n);\n}\nlet La, Ph;\nfunction M1(t) {\n  La = t, Ph = (e) => {\n    e.render._rc && (e.withProxy = new Proxy(e.ctx, xE));\n  };\n}\nconst QO = () => !La;\nfunction X1(t, e, n) {\n  const r = t.type;\n  if (!t.render) {\n    if (!e && La && !r.render) {\n      const i = r.template || PO(t).template;\n      if (i) {\n         true && Fr(t, \"compile\");\n        const { isCustomElement: s, compilerOptions: o } = t.appContext.config, { delimiters: a, compilerOptions: l } = r, c = $e(\n          $e(\n            {\n              isCustomElement: s,\n              delimiters: a\n            },\n            o\n          ),\n          l\n        );\n        r.render = La(i, c),  true && Gr(t, \"compile\");\n      }\n    }\n    t.render = r.render || it, Ph && Ph(t);\n  }\n  if (__VUE_OPTIONS_API__) {\n    const i = Bs(t);\n    ds();\n    try {\n      XE(t);\n    } finally {\n      fs(), i();\n    }\n  }\n   true && !r.render && t.render === it && !e && (!La && r.template ? I(\n    'Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias \"vue\" to \"vue/dist/vue.esm-bundler.js\".'\n  ) : I(\"Component is missing template or render function.\"));\n}\nfunction Vm(t) {\n  return t.attrsProxy || (t.attrsProxy = new Proxy(\n    t.attrs,\n     true ? {\n      get(e, n) {\n        return wu(), Kt(t, \"get\", \"$attrs\"), e[n];\n      },\n      set() {\n        return I(\"setupContext.attrs is readonly.\"), !1;\n      },\n      deleteProperty() {\n        return I(\"setupContext.attrs is readonly.\"), !1;\n      }\n    } : 0\n  ));\n}\nfunction k$(t) {\n  return t.slotsProxy || (t.slotsProxy = new Proxy(t.slots, {\n    get(e, n) {\n      return Kt(t, \"get\", \"$slots\"), e[n];\n    }\n  }));\n}\nfunction j1(t) {\n  const e = (n) => {\n    if ( true && (t.exposed && I(\"expose() should be called only once per setup().\"), n != null)) {\n      let r = typeof n;\n      r === \"object\" && (ie(n) ? r = \"array\" : Ct(n) && (r = \"ref\")), r !== \"object\" && I(\n        `expose() should be passed a plain object, received ${r}.`\n      );\n    }\n    t.exposed = n || {};\n  };\n  return  true ? Object.freeze({\n    get attrs() {\n      return Vm(t);\n    },\n    get slots() {\n      return k$(t);\n    },\n    get emit() {\n      return (n, ...r) => t.emit(n, ...r);\n    },\n    expose: e\n  }) : 0;\n}\nfunction _d(t) {\n  if (t.exposed)\n    return t.exposeProxy || (t.exposeProxy = new Proxy(uO(oO(t.exposed)), {\n      get(e, n) {\n        if (n in e)\n          return e[n];\n        if (n in Zs)\n          return Zs[n](t);\n      },\n      has(e, n) {\n        return n in e || n in Zs;\n      }\n    }));\n}\nconst x$ = /(?:^|[-_])(\\w)/g, P$ = (t) => t.replace(x$, (e) => e.toUpperCase()).replace(/[-_]/g, \"\");\nfunction al(t, e = !0) {\n  return be(t) ? t.displayName || t.name : t.name || e && t.__name;\n}\nfunction Td(t, e, n = !1) {\n  let r = al(e);\n  if (!r && e.__file) {\n    const i = e.__file.match(/([^/\\\\]+)\\.\\w+$/);\n    i && (r = i[1]);\n  }\n  if (!r && t && t.parent) {\n    const i = (s) => {\n      for (const o in s)\n        if (s[o] === e)\n          return o;\n    };\n    r = i(\n      t.components || t.parent.type.components\n    ) || i(t.appContext.components);\n  }\n  return r ? P$(r) : n ? \"App\" : \"Anonymous\";\n}\nfunction B1(t) {\n  return be(t) && \"__vccOpts\" in t;\n}\nconst j = (t, e) => {\n  const n = PT(t, e, Xl);\n  if (true) {\n    const r = ir();\n    r && r.appContext.config.warnRecursiveComputed && (n._warnRecursive = !0);\n  }\n  return n;\n};\nfunction _$(t, e, n = Ve) {\n  const r = ir();\n  if ( true && !r)\n    return I(\"useModel() called without active instance.\"), G();\n  if ( true && !r.propsOptions[0][e])\n    return I(`useModel() called with prop \"${e}\" which is not declared.`), G();\n  const i = mt(e), s = rn(e), o = Xy((l, c) => {\n    let u;\n    return n1(() => {\n      const d = t[e];\n      gr(u, d) && (u = d, c());\n    }), {\n      get() {\n        return l(), n.get ? n.get(u) : u;\n      },\n      set(d) {\n        const f = r.vnode.props;\n        !(f && // check if parent has passed v-model\n        (e in f || i in f || s in f) && (`onUpdate:${e}` in f || `onUpdate:${i}` in f || `onUpdate:${s}` in f)) && gr(d, u) && (u = d, c()), r.emit(`update:${e}`, n.set ? n.set(d) : d);\n      }\n    };\n  }), a = e === \"modelValue\" ? \"modelModifiers\" : `${e}Modifiers`;\n  return o[Symbol.iterator] = () => {\n    let l = 0;\n    return {\n      next() {\n        return l < 2 ? { value: l++ ? t[a] || {} : o, done: !1 } : { done: !0 };\n      }\n    };\n  }, o;\n}\nfunction kt(t, e, n) {\n  const r = arguments.length;\n  return r === 2 ? Ze(e) && !ie(e) ? li(e) ? J(t, null, [e]) : J(t, e) : J(t, null, e) : (r > 3 ? n = Array.prototype.slice.call(arguments, 2) : r === 3 && li(n) && (n = [n]), J(t, e, n));\n}\nfunction CO() {\n  if ( false || typeof window > \"u\")\n    return;\n  const t = { style: \"color:#3ba776\" }, e = { style: \"color:#1677ff\" }, n = { style: \"color:#f5222d\" }, r = { style: \"color:#eb2f96\" }, i = {\n    header(d) {\n      return Ze(d) ? d.__isVue ? [\"div\", t, \"VueInstance\"] : Ct(d) ? [\n        \"div\",\n        {},\n        [\"span\", t, u(d)],\n        \"<\",\n        a(d.value),\n        \">\"\n      ] : Yi(d) ? [\n        \"div\",\n        {},\n        [\"span\", t, zi(d) ? \"ShallowReactive\" : \"Reactive\"],\n        \"<\",\n        a(d),\n        `>${ai(d) ? \" (readonly)\" : \"\"}`\n      ] : ai(d) ? [\n        \"div\",\n        {},\n        [\"span\", t, zi(d) ? \"ShallowReadonly\" : \"Readonly\"],\n        \"<\",\n        a(d),\n        \">\"\n      ] : null : null;\n    },\n    hasBody(d) {\n      return d && d.__isVue;\n    },\n    body(d) {\n      if (d && d.__isVue)\n        return [\n          \"div\",\n          {},\n          ...s(d.$)\n        ];\n    }\n  };\n  function s(d) {\n    const f = [];\n    d.type.props && d.props && f.push(o(\"props\", Oe(d.props))), d.setupState !== Ve && f.push(o(\"setup\", d.setupState)), d.data !== Ve && f.push(o(\"data\", Oe(d.data)));\n    const h = l(d, \"computed\");\n    h && f.push(o(\"computed\", h));\n    const p = l(d, \"inject\");\n    return p && f.push(o(\"injected\", p)), f.push([\n      \"div\",\n      {},\n      [\n        \"span\",\n        {\n          style: r.style + \";opacity:0.66\"\n        },\n        \"$ (internal): \"\n      ],\n      [\"object\", { object: d }]\n    ]), f;\n  }\n  function o(d, f) {\n    return f = $e({}, f), Object.keys(f).length ? [\n      \"div\",\n      { style: \"line-height:1.25em;margin-bottom:0.6em\" },\n      [\n        \"div\",\n        {\n          style: \"color:#476582\"\n        },\n        d\n      ],\n      [\n        \"div\",\n        {\n          style: \"padding-left:1.25em\"\n        },\n        ...Object.keys(f).map((h) => [\n          \"div\",\n          {},\n          [\"span\", r, h + \": \"],\n          a(f[h], !1)\n        ])\n      ]\n    ] : [\"span\", {}];\n  }\n  function a(d, f = !0) {\n    return typeof d == \"number\" ? [\"span\", e, d] : typeof d == \"string\" ? [\"span\", n, JSON.stringify(d)] : typeof d == \"boolean\" ? [\"span\", r, d] : Ze(d) ? [\"object\", { object: f ? Oe(d) : d }] : [\"span\", n, String(d)];\n  }\n  function l(d, f) {\n    const h = d.type;\n    if (be(h))\n      return;\n    const p = {};\n    for (const O in d.ctx)\n      c(h, O, f) && (p[O] = d.ctx[O]);\n    return p;\n  }\n  function c(d, f, h) {\n    const p = d[h];\n    if (ie(p) && p.includes(f) || Ze(p) && f in p || d.extends && c(d.extends, f, h) || d.mixins && d.mixins.some((O) => c(O, f, h)))\n      return !0;\n  }\n  function u(d) {\n    return zi(d) ? \"ShallowRef\" : d.effect ? \"ComputedRef\" : \"Ref\";\n  }\n  window.devtoolsFormatters ? window.devtoolsFormatters.push(i) : window.devtoolsFormatters = [i];\n}\nfunction T$(t, e, n, r) {\n  const i = n[r];\n  if (i && L1(i, t))\n    return i;\n  const s = e();\n  return s.memo = t.slice(), n[r] = s;\n}\nfunction L1(t, e) {\n  const n = t.memo;\n  if (n.length != e.length)\n    return !1;\n  for (let r = 0; r < n.length; r++)\n    if (gr(n[r], e[r]))\n      return !1;\n  return js > 0 && kn && kn.push(t), !0;\n}\nconst _h = \"3.4.21\", Xt =  true ? I : 0, E$ = md, $$ = (\"development\", ar), Q$ = (\"development\", pO), C$ = {\n  createComponentInstance: V1,\n  setupComponent: W1,\n  renderComponentRoot: Hc,\n  setCurrentRenderingInstance: il,\n  isVNode: li,\n  normalizeVNode: Sn\n}, A$ = C$, R$ = null, N$ = null, D$ = null;\n/**\n* @vue/runtime-dom v3.4.21\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\nconst Z$ = \"http://www.w3.org/2000/svg\", V$ = \"http://www.w3.org/1998/Math/MathML\", Ri = typeof document < \"u\" ? document : null, Im = Ri && /* @__PURE__ */ Ri.createElement(\"template\"), I$ = {\n  insert: (t, e, n) => {\n    e.insertBefore(t, n || null);\n  },\n  remove: (t) => {\n    const e = t.parentNode;\n    e && e.removeChild(t);\n  },\n  createElement: (t, e, n, r) => {\n    const i = e === \"svg\" ? Ri.createElementNS(Z$, t) : e === \"mathml\" ? Ri.createElementNS(V$, t) : Ri.createElement(t, n ? { is: n } : void 0);\n    return t === \"select\" && r && r.multiple != null && i.setAttribute(\"multiple\", r.multiple), i;\n  },\n  createText: (t) => Ri.createTextNode(t),\n  createComment: (t) => Ri.createComment(t),\n  setText: (t, e) => {\n    t.nodeValue = e;\n  },\n  setElementText: (t, e) => {\n    t.textContent = e;\n  },\n  parentNode: (t) => t.parentNode,\n  nextSibling: (t) => t.nextSibling,\n  querySelector: (t) => Ri.querySelector(t),\n  setScopeId(t, e) {\n    t.setAttribute(e, \"\");\n  },\n  // __UNSAFE__\n  // Reason: innerHTML.\n  // Static content here can only come from compiled templates.\n  // As long as the user only uses trusted templates, this is safe.\n  insertStaticContent(t, e, n, r, i, s) {\n    const o = n ? n.previousSibling : e.lastChild;\n    if (i && (i === s || i.nextSibling))\n      for (; e.insertBefore(i.cloneNode(!0), n), !(i === s || !(i = i.nextSibling)); )\n        ;\n    else {\n      Im.innerHTML = r === \"svg\" ? `<svg>${t}</svg>` : r === \"mathml\" ? `<math>${t}</math>` : t;\n      const a = Im.content;\n      if (r === \"svg\" || r === \"mathml\") {\n        const l = a.firstChild;\n        for (; l.firstChild; )\n          a.appendChild(l.firstChild);\n        a.removeChild(l);\n      }\n      e.insertBefore(a, n);\n    }\n    return [\n      // first\n      o ? o.nextSibling : e.firstChild,\n      // last\n      n ? n.previousSibling : e.lastChild\n    ];\n  }\n}, wi = \"transition\", fa = \"animation\", No = Symbol(\"_vtc\"), AO = (t, { slots: e }) => kt(s1, q1(t), e);\nAO.displayName = \"Transition\";\nconst U1 = {\n  name: String,\n  type: String,\n  css: {\n    type: Boolean,\n    default: !0\n  },\n  duration: [String, Number, Object],\n  enterFromClass: String,\n  enterActiveClass: String,\n  enterToClass: String,\n  appearFromClass: String,\n  appearActiveClass: String,\n  appearToClass: String,\n  leaveFromClass: String,\n  leaveActiveClass: String,\n  leaveToClass: String\n}, W$ = AO.props = /* @__PURE__ */ $e(\n  {},\n  wO,\n  U1\n), gs = (t, e = []) => {\n  ie(t) ? t.forEach((n) => n(...e)) : t && t(...e);\n}, Wm = (t) => t ? ie(t) ? t.some((e) => e.length > 1) : t.length > 1 : !1;\nfunction q1(t) {\n  const e = {};\n  for (const Q in t)\n    Q in U1 || (e[Q] = t[Q]);\n  if (t.css === !1)\n    return e;\n  const {\n    name: n = \"v\",\n    type: r,\n    duration: i,\n    enterFromClass: s = `${n}-enter-from`,\n    enterActiveClass: o = `${n}-enter-active`,\n    enterToClass: a = `${n}-enter-to`,\n    appearFromClass: l = s,\n    appearActiveClass: c = o,\n    appearToClass: u = a,\n    leaveFromClass: d = `${n}-leave-from`,\n    leaveActiveClass: f = `${n}-leave-active`,\n    leaveToClass: h = `${n}-leave-to`\n  } = t, p = M$(i), O = p && p[0], m = p && p[1], {\n    onBeforeEnter: y,\n    onEnter: b,\n    onEnterCancelled: g,\n    onLeave: v,\n    onLeaveCancelled: S,\n    onBeforeAppear: w = y,\n    onAppear: k = b,\n    onAppearCancelled: _ = g\n  } = e, T = (Q, W, L) => {\n    $i(Q, W ? u : a), $i(Q, W ? c : o), L && L();\n  }, C = (Q, W) => {\n    Q._isLeaving = !1, $i(Q, d), $i(Q, h), $i(Q, f), W && W();\n  }, A = (Q) => (W, L) => {\n    const re = Q ? k : b, Y = () => T(W, Q, L);\n    gs(re, [W, Y]), Mm(() => {\n      $i(W, Q ? l : s), Kr(W, Q ? u : a), Wm(re) || Xm(W, r, O, Y);\n    });\n  };\n  return $e(e, {\n    onBeforeEnter(Q) {\n      gs(y, [Q]), Kr(Q, s), Kr(Q, o);\n    },\n    onBeforeAppear(Q) {\n      gs(w, [Q]), Kr(Q, l), Kr(Q, c);\n    },\n    onEnter: A(!1),\n    onAppear: A(!0),\n    onLeave(Q, W) {\n      Q._isLeaving = !0;\n      const L = () => C(Q, W);\n      Kr(Q, d), z1(), Kr(Q, f), Mm(() => {\n        Q._isLeaving && ($i(Q, d), Kr(Q, h), Wm(v) || Xm(Q, r, m, L));\n      }), gs(v, [Q, L]);\n    },\n    onEnterCancelled(Q) {\n      T(Q, !1), gs(g, [Q]);\n    },\n    onAppearCancelled(Q) {\n      T(Q, !0), gs(_, [Q]);\n    },\n    onLeaveCancelled(Q) {\n      C(Q), gs(S, [Q]);\n    }\n  });\n}\nfunction M$(t) {\n  if (t == null)\n    return null;\n  if (Ze(t))\n    return [hf(t.enter), hf(t.leave)];\n  {\n    const e = hf(t);\n    return [e, e];\n  }\n}\nfunction hf(t) {\n  const e = vu(t);\n  return  true && dO(e, \"<transition> explicit duration\"), e;\n}\nfunction Kr(t, e) {\n  e.split(/\\s+/).forEach((n) => n && t.classList.add(n)), (t[No] || (t[No] = /* @__PURE__ */ new Set())).add(e);\n}\nfunction $i(t, e) {\n  e.split(/\\s+/).forEach((r) => r && t.classList.remove(r));\n  const n = t[No];\n  n && (n.delete(e), n.size || (t[No] = void 0));\n}\nfunction Mm(t) {\n  requestAnimationFrame(() => {\n    requestAnimationFrame(t);\n  });\n}\nlet X$ = 0;\nfunction Xm(t, e, n, r) {\n  const i = t._endId = ++X$, s = () => {\n    i === t._endId && r();\n  };\n  if (n)\n    return setTimeout(s, n);\n  const { type: o, timeout: a, propCount: l } = Y1(t, e);\n  if (!o)\n    return r();\n  const c = o + \"end\";\n  let u = 0;\n  const d = () => {\n    t.removeEventListener(c, f), s();\n  }, f = (h) => {\n    h.target === t && ++u >= l && d();\n  };\n  setTimeout(() => {\n    u < l && d();\n  }, a + 1), t.addEventListener(c, f);\n}\nfunction Y1(t, e) {\n  const n = window.getComputedStyle(t), r = (p) => (n[p] || \"\").split(\", \"), i = r(`${wi}Delay`), s = r(`${wi}Duration`), o = jm(i, s), a = r(`${fa}Delay`), l = r(`${fa}Duration`), c = jm(a, l);\n  let u = null, d = 0, f = 0;\n  e === wi ? o > 0 && (u = wi, d = o, f = s.length) : e === fa ? c > 0 && (u = fa, d = c, f = l.length) : (d = Math.max(o, c), u = d > 0 ? o > c ? wi : fa : null, f = u ? u === wi ? s.length : l.length : 0);\n  const h = u === wi && /\\b(transform|all)(,|$)/.test(\n    r(`${wi}Property`).toString()\n  );\n  return {\n    type: u,\n    timeout: d,\n    propCount: f,\n    hasTransform: h\n  };\n}\nfunction jm(t, e) {\n  for (; t.length < e.length; )\n    t = t.concat(t);\n  return Math.max(...e.map((n, r) => Bm(n) + Bm(t[r])));\n}\nfunction Bm(t) {\n  return t === \"auto\" ? 0 : Number(t.slice(0, -1).replace(\",\", \".\")) * 1e3;\n}\nfunction z1() {\n  return document.body.offsetHeight;\n}\nfunction j$(t, e, n) {\n  const r = t[No];\n  r && (e = (e ? [e, ...r] : [...r]).join(\" \")), e == null ? t.removeAttribute(\"class\") : n ? t.setAttribute(\"class\", e) : t.className = e;\n}\nconst Eu = Symbol(\"_vod\"), H1 = Symbol(\"_vsh\"), jl = {\n  beforeMount(t, { value: e }, { transition: n }) {\n    t[Eu] = t.style.display === \"none\" ? \"\" : t.style.display, n && e ? n.beforeEnter(t) : ha(t, e);\n  },\n  mounted(t, { value: e }, { transition: n }) {\n    n && e && n.enter(t);\n  },\n  updated(t, { value: e, oldValue: n }, { transition: r }) {\n    !e != !n && (r ? e ? (r.beforeEnter(t), ha(t, !0), r.enter(t)) : r.leave(t, () => {\n      ha(t, !1);\n    }) : ha(t, e));\n  },\n  beforeUnmount(t, { value: e }) {\n    ha(t, e);\n  }\n};\n true && (jl.name = \"show\");\nfunction ha(t, e) {\n  t.style.display = e ? t[Eu] : \"none\", t[H1] = !e;\n}\nfunction B$() {\n  jl.getSSRProps = ({ value: t }) => {\n    if (!t)\n      return { style: { display: \"none\" } };\n  };\n}\nconst F1 = Symbol( true ? \"CSS_VAR_TEXT\" : 0);\nfunction G1(t) {\n  const e = ir();\n  if (!e) {\n     true && Xt(\"useCssVars is called without current active component instance.\");\n    return;\n  }\n  const n = e.ut = (i = t(e.proxy)) => {\n    Array.from(\n      document.querySelectorAll(`[data-v-owner=\"${e.uid}\"]`)\n    ).forEach((s) => Eh(s, i));\n  };\n   true && (e.getCssVars = () => t(e.proxy));\n  const r = () => {\n    const i = t(e.proxy);\n    Th(e.subTree, i), n(i);\n  };\n  t1(r), et(() => {\n    const i = new MutationObserver(r);\n    i.observe(e.subTree.el.parentNode, { childList: !0 }), jt(() => i.disconnect());\n  });\n}\nfunction Th(t, e) {\n  if (t.shapeFlag & 128) {\n    const n = t.suspense;\n    t = n.activeBranch, n.pendingBranch && !n.isHydrating && n.effects.push(() => {\n      Th(n.activeBranch, e);\n    });\n  }\n  for (; t.component; )\n    t = t.component.subTree;\n  if (t.shapeFlag & 1 && t.el)\n    Eh(t.el, e);\n  else if (t.type === Pe)\n    t.children.forEach((n) => Th(n, e));\n  else if (t.type === Fi) {\n    let { el: n, anchor: r } = t;\n    for (; n && (Eh(n, e), n !== r); )\n      n = n.nextSibling;\n  }\n}\nfunction Eh(t, e) {\n  if (t.nodeType === 1) {\n    const n = t.style;\n    let r = \"\";\n    for (const i in e)\n      n.setProperty(`--${i}`, e[i]), r += `--${i}: ${e[i]};`;\n    n[F1] = r;\n  }\n}\nconst L$ = /(^|;)\\s*display\\s*:/;\nfunction U$(t, e, n) {\n  const r = t.style, i = we(n);\n  let s = !1;\n  if (n && !i) {\n    if (e)\n      if (we(e))\n        for (const o of e.split(\";\")) {\n          const a = o.slice(0, o.indexOf(\":\")).trim();\n          n[a] == null && Gc(r, a, \"\");\n        }\n      else\n        for (const o in e)\n          n[o] == null && Gc(r, o, \"\");\n    for (const o in n)\n      o === \"display\" && (s = !0), Gc(r, o, n[o]);\n  } else if (i) {\n    if (e !== n) {\n      const o = r[F1];\n      o && (n += \";\" + o), r.cssText = n, s = L$.test(n);\n    }\n  } else\n    e && t.removeAttribute(\"style\");\n  Eu in t && (t[Eu] = s ? r.display : \"\", t[H1] && (r.display = \"none\"));\n}\nconst q$ = /[^\\\\];\\s*$/, Lm = /\\s*!important$/;\nfunction Gc(t, e, n) {\n  if (ie(n))\n    n.forEach((r) => Gc(t, e, r));\n  else if (n == null && (n = \"\"),  true && q$.test(n) && Xt(\n    `Unexpected semicolon at the end of '${e}' style value: '${n}'`\n  ), e.startsWith(\"--\"))\n    t.setProperty(e, n);\n  else {\n    const r = Y$(t, e);\n    Lm.test(n) ? t.setProperty(\n      rn(r),\n      n.replace(Lm, \"\"),\n      \"important\"\n    ) : t[r] = n;\n  }\n}\nconst Um = [\"Webkit\", \"Moz\", \"ms\"], pf = {};\nfunction Y$(t, e) {\n  const n = pf[e];\n  if (n)\n    return n;\n  let r = mt(e);\n  if (r !== \"filter\" && r in t)\n    return pf[e] = r;\n  r = Wr(r);\n  for (let i = 0; i < Um.length; i++) {\n    const s = Um[i] + r;\n    if (s in t)\n      return pf[e] = s;\n  }\n  return e;\n}\nconst qm = \"http://www.w3.org/1999/xlink\";\nfunction z$(t, e, n, r, i) {\n  if (r && e.startsWith(\"xlink:\"))\n    n == null ? t.removeAttributeNS(qm, e.slice(6, e.length)) : t.setAttributeNS(qm, e, n);\n  else {\n    const s = F_(e);\n    n == null || s && !Jp(n) ? t.removeAttribute(e) : t.setAttribute(e, s ? \"\" : n);\n  }\n}\nfunction H$(t, e, n, r, i, s, o) {\n  if (e === \"innerHTML\" || e === \"textContent\") {\n    r && o(r, i, s), t[e] = n ?? \"\";\n    return;\n  }\n  const a = t.tagName;\n  if (e === \"value\" && a !== \"PROGRESS\" && // custom elements may use _value internally\n  !a.includes(\"-\")) {\n    const c = a === \"OPTION\" ? t.getAttribute(\"value\") || \"\" : t.value, u = n ?? \"\";\n    (c !== u || !(\"_value\" in t)) && (t.value = u), n == null && t.removeAttribute(e), t._value = n;\n    return;\n  }\n  let l = !1;\n  if (n === \"\" || n == null) {\n    const c = typeof t[e];\n    c === \"boolean\" ? n = Jp(n) : n == null && c === \"string\" ? (n = \"\", l = !0) : c === \"number\" && (n = 0, l = !0);\n  }\n  try {\n    t[e] = n;\n  } catch (c) {\n     true && !l && Xt(\n      `Failed setting prop \"${e}\" on <${a.toLowerCase()}>: value ${n} is invalid.`,\n      c\n    );\n  }\n  l && t.removeAttribute(e);\n}\nfunction ni(t, e, n, r) {\n  t.addEventListener(e, n, r);\n}\nfunction F$(t, e, n, r) {\n  t.removeEventListener(e, n, r);\n}\nconst Ym = Symbol(\"_vei\");\nfunction G$(t, e, n, r, i = null) {\n  const s = t[Ym] || (t[Ym] = {}), o = s[e];\n  if (r && o)\n    o.value = r;\n  else {\n    const [a, l] = K$(e);\n    if (r) {\n      const c = s[e] = tQ(r, i);\n      ni(t, a, c, l);\n    } else\n      o && (F$(t, a, o, l), s[e] = void 0);\n  }\n}\nconst zm = /(?:Once|Passive|Capture)$/;\nfunction K$(t) {\n  let e;\n  if (zm.test(t)) {\n    e = {};\n    let r;\n    for (; r = t.match(zm); )\n      t = t.slice(0, t.length - r[0].length), e[r[0].toLowerCase()] = !0;\n  }\n  return [t[2] === \":\" ? t.slice(3) : rn(t.slice(2)), e];\n}\nlet Of = 0;\nconst J$ = /* @__PURE__ */ Promise.resolve(), eQ = () => Of || (J$.then(() => Of = 0), Of = Date.now());\nfunction tQ(t, e) {\n  const n = (r) => {\n    if (!r._vts)\n      r._vts = Date.now();\n    else if (r._vts <= n.attached)\n      return;\n    Wn(\n      nQ(r, n.value),\n      e,\n      5,\n      [r]\n    );\n  };\n  return n.value = t, n.attached = eQ(), n;\n}\nfunction nQ(t, e) {\n  if (ie(e)) {\n    const n = t.stopImmediatePropagation;\n    return t.stopImmediatePropagation = () => {\n      n.call(t), t._stopped = !0;\n    }, e.map((r) => (i) => !i._stopped && r && r(i));\n  } else\n    return e;\n}\nconst Hm = (t) => t.charCodeAt(0) === 111 && t.charCodeAt(1) === 110 && // lowercase letter\nt.charCodeAt(2) > 96 && t.charCodeAt(2) < 123, rQ = (t, e, n, r, i, s, o, a, l) => {\n  const c = i === \"svg\";\n  e === \"class\" ? j$(t, r, c) : e === \"style\" ? U$(t, n, r) : oi(e) ? mu(e) || G$(t, e, n, r, o) : (e[0] === \".\" ? (e = e.slice(1), !0) : e[0] === \"^\" ? (e = e.slice(1), !1) : iQ(t, e, r, c)) ? H$(\n    t,\n    e,\n    r,\n    s,\n    o,\n    a,\n    l\n  ) : (e === \"true-value\" ? t._trueValue = r : e === \"false-value\" && (t._falseValue = r), z$(t, e, r, c));\n};\nfunction iQ(t, e, n, r) {\n  if (r)\n    return !!(e === \"innerHTML\" || e === \"textContent\" || e in t && Hm(e) && be(n));\n  if (e === \"spellcheck\" || e === \"draggable\" || e === \"translate\" || e === \"form\" || e === \"list\" && t.tagName === \"INPUT\" || e === \"type\" && t.tagName === \"TEXTAREA\")\n    return !1;\n  if (e === \"width\" || e === \"height\") {\n    const i = t.tagName;\n    if (i === \"IMG\" || i === \"VIDEO\" || i === \"CANVAS\" || i === \"SOURCE\")\n      return !1;\n  }\n  return Hm(e) && we(n) ? !1 : e in t;\n}\n/*! #__NO_SIDE_EFFECTS__ */\n// @__NO_SIDE_EFFECTS__\nfunction K1(t, e) {\n  const n = /* @__PURE__ */ le(t);\n  class r extends Ed {\n    constructor(s) {\n      super(n, s, e);\n    }\n  }\n  return r.def = n, r;\n}\n/*! #__NO_SIDE_EFFECTS__ */\nconst sQ = /* @__NO_SIDE_EFFECTS__ */ (t) => /* @__PURE__ */ K1(t, fS), oQ = typeof HTMLElement < \"u\" ? HTMLElement : class {\n};\nclass Ed extends oQ {\n  constructor(e, n = {}, r) {\n    super(), this._def = e, this._props = n, this._instance = null, this._connected = !1, this._resolved = !1, this._numberProps = null, this._ob = null, this.shadowRoot && r ? r(this._createVNode(), this.shadowRoot) : ( true && this.shadowRoot && Xt(\n      \"Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use `defineSSRCustomElement`.\"\n    ), this.attachShadow({ mode: \"open\" }), this._def.__asyncLoader || this._resolveProps(this._def));\n  }\n  connectedCallback() {\n    this._connected = !0, this._instance || (this._resolved ? this._update() : this._resolveDef());\n  }\n  disconnectedCallback() {\n    this._connected = !1, this._ob && (this._ob.disconnect(), this._ob = null), Pn(() => {\n      this._connected || ($h(null, this.shadowRoot), this._instance = null);\n    });\n  }\n  /**\n   * resolve inner component definition (handle possible async component)\n   */\n  _resolveDef() {\n    this._resolved = !0;\n    for (let r = 0; r < this.attributes.length; r++)\n      this._setAttr(this.attributes[r].name);\n    this._ob = new MutationObserver((r) => {\n      for (const i of r)\n        this._setAttr(i.attributeName);\n    }), this._ob.observe(this, { attributes: !0 });\n    const e = (r, i = !1) => {\n      const { props: s, styles: o } = r;\n      let a;\n      if (s && !ie(s))\n        for (const l in s) {\n          const c = s[l];\n          (c === Number || c && c.type === Number) && (l in this._props && (this._props[l] = vu(this._props[l])), (a || (a = /* @__PURE__ */ Object.create(null)))[mt(l)] = !0);\n        }\n      this._numberProps = a, i && this._resolveProps(r), this._applyStyles(o), this._update();\n    }, n = this._def.__asyncLoader;\n    n ? n().then((r) => e(r, !0)) : e(this._def);\n  }\n  _resolveProps(e) {\n    const { props: n } = e, r = ie(n) ? n : Object.keys(n || {});\n    for (const i of Object.keys(this))\n      i[0] !== \"_\" && r.includes(i) && this._setProp(i, this[i], !0, !1);\n    for (const i of r.map(mt))\n      Object.defineProperty(this, i, {\n        get() {\n          return this._getProp(i);\n        },\n        set(s) {\n          this._setProp(i, s);\n        }\n      });\n  }\n  _setAttr(e) {\n    let n = this.getAttribute(e);\n    const r = mt(e);\n    this._numberProps && this._numberProps[r] && (n = vu(n)), this._setProp(r, n, !1);\n  }\n  /**\n   * @internal\n   */\n  _getProp(e) {\n    return this._props[e];\n  }\n  /**\n   * @internal\n   */\n  _setProp(e, n, r = !0, i = !0) {\n    n !== this._props[e] && (this._props[e] = n, i && this._instance && this._update(), r && (n === !0 ? this.setAttribute(rn(e), \"\") : typeof n == \"string\" || typeof n == \"number\" ? this.setAttribute(rn(e), n + \"\") : n || this.removeAttribute(rn(e))));\n  }\n  _update() {\n    $h(this._createVNode(), this.shadowRoot);\n  }\n  _createVNode() {\n    const e = J(this._def, $e({}, this._props));\n    return this._instance || (e.ce = (n) => {\n      this._instance = n, n.isCE = !0,  true && (n.ceReload = (s) => {\n        this._styles && (this._styles.forEach((o) => this.shadowRoot.removeChild(o)), this._styles.length = 0), this._applyStyles(s), this._instance = null, this._update();\n      });\n      const r = (s, o) => {\n        this.dispatchEvent(\n          new CustomEvent(s, {\n            detail: o\n          })\n        );\n      };\n      n.emit = (s, ...o) => {\n        r(s, o), rn(s) !== s && r(rn(s), o);\n      };\n      let i = this;\n      for (; i = i && (i.parentNode || i.host); )\n        if (i instanceof Ed) {\n          n.parent = i._instance, n.provides = i._instance.provides;\n          break;\n        }\n    }), e;\n  }\n  _applyStyles(e) {\n    e && e.forEach((n) => {\n      const r = document.createElement(\"style\");\n      r.textContent = n, this.shadowRoot.appendChild(r),  true && (this._styles || (this._styles = [])).push(r);\n    });\n  }\n}\nfunction J1(t = \"$style\") {\n  {\n    const e = ir();\n    if (!e)\n      return  true && Xt(\"useCssModule must be called inside setup()\"), Ve;\n    const n = e.type.__cssModules;\n    if (!n)\n      return  true && Xt(\"Current instance does not have CSS modules injected.\"), Ve;\n    const r = n[t];\n    return r || ( true && Xt(`Current instance does not have CSS module named \"${t}\".`), Ve);\n  }\n}\nconst eS = /* @__PURE__ */ new WeakMap(), tS = /* @__PURE__ */ new WeakMap(), $u = Symbol(\"_moveCb\"), Fm = Symbol(\"_enterCb\"), nS = {\n  name: \"TransitionGroup\",\n  props: /* @__PURE__ */ $e({}, W$, {\n    tag: String,\n    moveClass: String\n  }),\n  setup(t, { slots: e }) {\n    const n = ir(), r = SO();\n    let i, s;\n    return kd(() => {\n      if (!i.length)\n        return;\n      const o = t.moveClass || `${t.name || \"v\"}-move`;\n      if (!fQ(\n        i[0].el,\n        n.vnode.el,\n        o\n      ))\n        return;\n      i.forEach(cQ), i.forEach(uQ);\n      const a = i.filter(dQ);\n      z1(), a.forEach((l) => {\n        const c = l.el, u = c.style;\n        Kr(c, o), u.transform = u.webkitTransform = u.transitionDuration = \"\";\n        const d = c[$u] = (f) => {\n          f && f.target !== c || (!f || /transform$/.test(f.propertyName)) && (c.removeEventListener(\"transitionend\", d), c[$u] = null, $i(c, o));\n        };\n        c.addEventListener(\"transitionend\", d);\n      });\n    }), () => {\n      const o = Oe(t), a = q1(o);\n      let l = o.tag || Pe;\n      i = s, s = e.default ? Sd(e.default()) : [];\n      for (let c = 0; c < s.length; c++) {\n        const u = s[c];\n        u.key != null ? Xs(\n          u,\n          Ro(u, a, r, n)\n        ) :  true && Xt(\"<TransitionGroup> children must be keyed.\");\n      }\n      if (i)\n        for (let c = 0; c < i.length; c++) {\n          const u = i[c];\n          Xs(\n            u,\n            Ro(u, a, r, n)\n          ), eS.set(u, u.el.getBoundingClientRect());\n        }\n      return J(l, null, s);\n    };\n  }\n}, aQ = (t) => delete t.mode;\nnS.props;\nconst lQ = nS;\nfunction cQ(t) {\n  const e = t.el;\n  e[$u] && e[$u](), e[Fm] && e[Fm]();\n}\nfunction uQ(t) {\n  tS.set(t, t.el.getBoundingClientRect());\n}\nfunction dQ(t) {\n  const e = eS.get(t), n = tS.get(t), r = e.left - n.left, i = e.top - n.top;\n  if (r || i) {\n    const s = t.el.style;\n    return s.transform = s.webkitTransform = `translate(${r}px,${i}px)`, s.transitionDuration = \"0s\", t;\n  }\n}\nfunction fQ(t, e, n) {\n  const r = t.cloneNode(), i = t[No];\n  i && i.forEach((a) => {\n    a.split(/\\s+/).forEach((l) => l && r.classList.remove(l));\n  }), n.split(/\\s+/).forEach((a) => a && r.classList.add(a)), r.style.display = \"none\";\n  const s = e.nodeType === 1 ? e : e.parentNode;\n  s.appendChild(r);\n  const { hasTransform: o } = Y1(r);\n  return s.removeChild(r), o;\n}\nconst rs = (t) => {\n  const e = t.props[\"onUpdate:modelValue\"] || !1;\n  return ie(e) ? (n) => Ii(e, n) : e;\n};\nfunction hQ(t) {\n  t.target.composing = !0;\n}\nfunction Gm(t) {\n  const e = t.target;\n  e.composing && (e.composing = !1, e.dispatchEvent(new Event(\"input\")));\n}\nconst Jn = Symbol(\"_assign\"), Gi = {\n  created(t, { modifiers: { lazy: e, trim: n, number: r } }, i) {\n    t[Jn] = rs(i);\n    const s = r || i.props && i.props.type === \"number\";\n    ni(t, e ? \"change\" : \"input\", (o) => {\n      if (o.target.composing)\n        return;\n      let a = t.value;\n      n && (a = a.trim()), s && (a = Ka(a)), t[Jn](a);\n    }), n && ni(t, \"change\", () => {\n      t.value = t.value.trim();\n    }), e || (ni(t, \"compositionstart\", hQ), ni(t, \"compositionend\", Gm), ni(t, \"change\", Gm));\n  },\n  // set value on mounted so it's after min/max for type=\"range\"\n  mounted(t, { value: e }) {\n    t.value = e ?? \"\";\n  },\n  beforeUpdate(t, { value: e, modifiers: { lazy: n, trim: r, number: i } }, s) {\n    if (t[Jn] = rs(s), t.composing)\n      return;\n    const o = i || t.type === \"number\" ? Ka(t.value) : t.value, a = e ?? \"\";\n    o !== a && (document.activeElement === t && t.type !== \"range\" && (n || r && t.value.trim() === a) || (t.value = a));\n  }\n}, $d = {\n  // #4096 array checkboxes need to be deep traversed\n  deep: !0,\n  created(t, e, n) {\n    t[Jn] = rs(n), ni(t, \"change\", () => {\n      const r = t._modelValue, i = Do(t), s = t.checked, o = t[Jn];\n      if (ie(r)) {\n        const a = hd(r, i), l = a !== -1;\n        if (s && !l)\n          o(r.concat(i));\n        else if (!s && l) {\n          const c = [...r];\n          c.splice(a, 1), o(c);\n        }\n      } else if (Gs(r)) {\n        const a = new Set(r);\n        s ? a.add(i) : a.delete(i), o(a);\n      } else\n        o(iS(t, s));\n    });\n  },\n  // set initial checked on mount to wait for true-value/false-value\n  mounted: Km,\n  beforeUpdate(t, e, n) {\n    t[Jn] = rs(n), Km(t, e, n);\n  }\n};\nfunction Km(t, { value: e, oldValue: n }, r) {\n  t._modelValue = e, ie(e) ? t.checked = hd(e, r.props.value) > -1 : Gs(e) ? t.checked = e.has(r.props.value) : e !== n && (t.checked = ts(e, iS(t, !0)));\n}\nconst RO = {\n  created(t, { value: e }, n) {\n    t.checked = ts(e, n.props.value), t[Jn] = rs(n), ni(t, \"change\", () => {\n      t[Jn](Do(t));\n    });\n  },\n  beforeUpdate(t, { value: e, oldValue: n }, r) {\n    t[Jn] = rs(r), e !== n && (t.checked = ts(e, r.props.value));\n  }\n}, rS = {\n  // <select multiple> value need to be deep traversed\n  deep: !0,\n  created(t, { value: e, modifiers: { number: n } }, r) {\n    const i = Gs(e);\n    ni(t, \"change\", () => {\n      const s = Array.prototype.filter.call(t.options, (o) => o.selected).map(\n        (o) => n ? Ka(Do(o)) : Do(o)\n      );\n      t[Jn](\n        t.multiple ? i ? new Set(s) : s : s[0]\n      ), t._assigning = !0, Pn(() => {\n        t._assigning = !1;\n      });\n    }), t[Jn] = rs(r);\n  },\n  // set value in mounted & updated because <select> relies on its children\n  // <option>s.\n  mounted(t, { value: e, modifiers: { number: n } }) {\n    Jm(t, e, n);\n  },\n  beforeUpdate(t, e, n) {\n    t[Jn] = rs(n);\n  },\n  updated(t, { value: e, modifiers: { number: n } }) {\n    t._assigning || Jm(t, e, n);\n  }\n};\nfunction Jm(t, e, n) {\n  const r = t.multiple, i = ie(e);\n  if (r && !i && !Gs(e)) {\n     true && Xt(\n      `<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(e).slice(8, -1)}.`\n    );\n    return;\n  }\n  for (let s = 0, o = t.options.length; s < o; s++) {\n    const a = t.options[s], l = Do(a);\n    if (r)\n      if (i) {\n        const c = typeof l;\n        c === \"string\" || c === \"number\" ? a.selected = e.includes(\n          n ? Ka(l) : l\n        ) : a.selected = hd(e, l) > -1;\n      } else\n        a.selected = e.has(l);\n    else if (ts(Do(a), e)) {\n      t.selectedIndex !== s && (t.selectedIndex = s);\n      return;\n    }\n  }\n  !r && t.selectedIndex !== -1 && (t.selectedIndex = -1);\n}\nfunction Do(t) {\n  return \"_value\" in t ? t._value : t.value;\n}\nfunction iS(t, e) {\n  const n = e ? \"_trueValue\" : \"_falseValue\";\n  return n in t ? t[n] : e;\n}\nconst sS = {\n  created(t, e, n) {\n    bc(t, e, n, null, \"created\");\n  },\n  mounted(t, e, n) {\n    bc(t, e, n, null, \"mounted\");\n  },\n  beforeUpdate(t, e, n, r) {\n    bc(t, e, n, r, \"beforeUpdate\");\n  },\n  updated(t, e, n, r) {\n    bc(t, e, n, r, \"updated\");\n  }\n};\nfunction oS(t, e) {\n  switch (t) {\n    case \"SELECT\":\n      return rS;\n    case \"TEXTAREA\":\n      return Gi;\n    default:\n      switch (e) {\n        case \"checkbox\":\n          return $d;\n        case \"radio\":\n          return RO;\n        default:\n          return Gi;\n      }\n  }\n}\nfunction bc(t, e, n, r, i) {\n  const o = oS(\n    t.tagName,\n    n.props && n.props.type\n  )[i];\n  o && o(t, e, n, r);\n}\nfunction pQ() {\n  Gi.getSSRProps = ({ value: t }) => ({ value: t }), RO.getSSRProps = ({ value: t }, e) => {\n    if (e.props && ts(e.props.value, t))\n      return { checked: !0 };\n  }, $d.getSSRProps = ({ value: t }, e) => {\n    if (ie(t)) {\n      if (e.props && hd(t, e.props.value) > -1)\n        return { checked: !0 };\n    } else if (Gs(t)) {\n      if (e.props && t.has(e.props.value))\n        return { checked: !0 };\n    } else if (t)\n      return { checked: !0 };\n  }, sS.getSSRProps = (t, e) => {\n    if (typeof e.type != \"string\")\n      return;\n    const n = oS(\n      // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase\n      e.type.toUpperCase(),\n      e.props && e.props.type\n    );\n    if (n.getSSRProps)\n      return n.getSSRProps(t, e);\n  };\n}\nconst OQ = [\"ctrl\", \"shift\", \"alt\", \"meta\"], gQ = {\n  stop: (t) => t.stopPropagation(),\n  prevent: (t) => t.preventDefault(),\n  self: (t) => t.target !== t.currentTarget,\n  ctrl: (t) => !t.ctrlKey,\n  shift: (t) => !t.shiftKey,\n  alt: (t) => !t.altKey,\n  meta: (t) => !t.metaKey,\n  left: (t) => \"button\" in t && t.button !== 0,\n  middle: (t) => \"button\" in t && t.button !== 1,\n  right: (t) => \"button\" in t && t.button !== 2,\n  exact: (t, e) => OQ.some((n) => t[`${n}Key`] && !e.includes(n))\n}, aS = (t, e) => {\n  const n = t._withMods || (t._withMods = {}), r = e.join(\".\");\n  return n[r] || (n[r] = (i, ...s) => {\n    for (let o = 0; o < e.length; o++) {\n      const a = gQ[e[o]];\n      if (a && a(i, e))\n        return;\n    }\n    return t(i, ...s);\n  });\n}, mQ = {\n  esc: \"escape\",\n  space: \" \",\n  up: \"arrow-up\",\n  left: \"arrow-left\",\n  right: \"arrow-right\",\n  down: \"arrow-down\",\n  delete: \"backspace\"\n}, lS = (t, e) => {\n  const n = t._withKeys || (t._withKeys = {}), r = e.join(\".\");\n  return n[r] || (n[r] = (i) => {\n    if (!(\"key\" in i))\n      return;\n    const s = rn(i.key);\n    if (e.some((o) => o === s || mQ[o] === s))\n      return t(i);\n  });\n}, cS = /* @__PURE__ */ $e({ patchProp: rQ }, I$);\nlet Ua, eb = !1;\nfunction uS() {\n  return Ua || (Ua = _1(cS));\n}\nfunction dS() {\n  return Ua = eb ? Ua : T1(cS), eb = !0, Ua;\n}\nconst $h = (...t) => {\n  uS().render(...t);\n}, fS = (...t) => {\n  dS().hydrate(...t);\n}, hS = (...t) => {\n  const e = uS().createApp(...t);\n   true && (OS(e), gS(e));\n  const { mount: n } = e;\n  return e.mount = (r) => {\n    const i = mS(r);\n    if (!i)\n      return;\n    const s = e._component;\n    !be(s) && !s.render && !s.template && (s.template = i.innerHTML), i.innerHTML = \"\";\n    const o = n(i, !1, pS(i));\n    return i instanceof Element && (i.removeAttribute(\"v-cloak\"), i.setAttribute(\"data-v-app\", \"\")), o;\n  }, e;\n}, bQ = (...t) => {\n  const e = dS().createApp(...t);\n   true && (OS(e), gS(e));\n  const { mount: n } = e;\n  return e.mount = (r) => {\n    const i = mS(r);\n    if (i)\n      return n(i, !0, pS(i));\n  }, e;\n};\nfunction pS(t) {\n  if (t instanceof SVGElement)\n    return \"svg\";\n  if (typeof MathMLElement == \"function\" && t instanceof MathMLElement)\n    return \"mathml\";\n}\nfunction OS(t) {\n  Object.defineProperty(t.config, \"isNativeTag\", {\n    value: (e) => by(e) || vy(e) || yy(e),\n    writable: !1\n  });\n}\nfunction gS(t) {\n  if (QO()) {\n    const e = t.config.isCustomElement;\n    Object.defineProperty(t.config, \"isCustomElement\", {\n      get() {\n        return e;\n      },\n      set() {\n        Xt(\n          \"The `isCustomElement` config option is deprecated. Use `compilerOptions.isCustomElement` instead.\"\n        );\n      }\n    });\n    const n = t.config.compilerOptions, r = 'The `compilerOptions` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka \"full build\"). Since you are using the runtime-only build, `compilerOptions` must be passed to `@vue/compiler-dom` in the build setup instead.\\n- For vue-loader: pass it via vue-loader\\'s `compilerOptions` loader option.\\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc';\n    Object.defineProperty(t.config, \"compilerOptions\", {\n      get() {\n        return Xt(r), n;\n      },\n      set() {\n        Xt(r);\n      }\n    });\n  }\n}\nfunction mS(t) {\n  if (we(t)) {\n    const e = document.querySelector(t);\n    return  true && !e && Xt(\n      `Failed to mount app: mount target selector \"${t}\" returned null.`\n    ), e;\n  }\n  return  true && window.ShadowRoot && t instanceof window.ShadowRoot && t.mode === \"closed\" && Xt(\n    'mounting on a ShadowRoot with `{mode: \"closed\"}` may lead to unpredictable bugs'\n  ), t;\n}\nlet tb = !1;\nconst vQ = () => {\n  tb || (tb = !0, pQ(), B$());\n}, yQ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  BaseTransition: s1,\n  BaseTransitionPropsValidators: wO,\n  Comment: _t,\n  DeprecationTypes: D$,\n  EffectScope: eO,\n  ErrorCodes: WT,\n  ErrorTypeStrings: E$,\n  Fragment: Pe,\n  KeepAlive: yE,\n  ReactiveEffect: Ao,\n  Static: Fi,\n  Suspense: dE,\n  Teleport: TO,\n  Text: ns,\n  TrackOpTypes: RT,\n  Transition: AO,\n  TransitionGroup: lQ,\n  TriggerOpTypes: NT,\n  VueElement: Ed,\n  assertNumber: dO,\n  callWithAsyncErrorHandling: Wn,\n  callWithErrorHandling: Vr,\n  camelize: mt,\n  capitalize: Wr,\n  cloneVNode: jn,\n  compatUtils: N$,\n  computed: j,\n  createApp: hS,\n  createBlock: ke,\n  createCommentVNode: st,\n  createElementBlock: ne,\n  createElementVNode: D,\n  createHydrationRenderer: T1,\n  createPropsRestProxy: IE,\n  createRenderer: _1,\n  createSSRApp: bQ,\n  createSlots: wE,\n  createStaticVNode: Wl,\n  createTextVNode: He,\n  createVNode: J,\n  customRef: Xy,\n  defineAsyncComponent: a1,\n  defineComponent: le,\n  defineCustomElement: K1,\n  defineEmits: $E,\n  defineExpose: QE,\n  defineModel: RE,\n  defineOptions: CE,\n  defineProps: EE,\n  defineSSRCustomElement: sQ,\n  defineSlots: AE,\n  devtools: $$,\n  effect: rT,\n  effectScope: tT,\n  getCurrentInstance: ir,\n  getCurrentScope: Rl,\n  getTransitionRawChildren: Sd,\n  guardReactiveProps: EO,\n  h: kt,\n  handleError: hs,\n  hasInjectionContext: zE,\n  hydrate: fS,\n  initCustomFormatter: CO,\n  initDirectivesForSSR: vQ,\n  inject: Pt,\n  isMemoSame: L1,\n  isProxy: Ja,\n  isReactive: Yi,\n  isReadonly: ai,\n  isRef: Ct,\n  isRuntimeOnly: QO,\n  isShallow: zi,\n  isVNode: li,\n  markRaw: oO,\n  mergeDefaults: ZE,\n  mergeModels: VE,\n  mergeProps: Ml,\n  nextTick: Pn,\n  normalizeClass: Ke,\n  normalizeProps: my,\n  normalizeStyle: Br,\n  onActivated: l1,\n  onBeforeMount: d1,\n  onBeforeUnmount: Il,\n  onBeforeUpdate: f1,\n  onDeactivated: c1,\n  onErrorCaptured: O1,\n  onMounted: et,\n  onRenderTracked: p1,\n  onRenderTriggered: h1,\n  onScopeDispose: tO,\n  onServerPrefetch: xd,\n  onUnmounted: jt,\n  onUpdated: kd,\n  openBlock: Z,\n  popScopeId: Js,\n  provide: _n,\n  proxyRefs: uO,\n  pushScopeId: Ks,\n  queuePostFlushCb: nl,\n  reactive: Xn,\n  readonly: sO,\n  ref: G,\n  registerRuntimeCompiler: M1,\n  render: $h,\n  renderList: Xr,\n  renderSlot: pt,\n  resolveComponent: lE,\n  resolveDirective: cE,\n  resolveDynamicComponent: Zl,\n  resolveFilter: R$,\n  resolveTransitionHooks: Ro,\n  setBlockTracking: vh,\n  setDevtoolsHook: Q$,\n  setTransitionHooks: Xs,\n  shallowReactive: Iy,\n  shallowReadonly: Dn,\n  shallowRef: cO,\n  ssrContextKey: e1,\n  ssrUtils: A$,\n  stop: iT,\n  toDisplayString: De,\n  toHandlerKey: Tr,\n  toHandlers: kE,\n  toRaw: Oe,\n  toRef: Ei,\n  toRefs: QT,\n  toValue: Jt,\n  transformVNodeArgs: m$,\n  triggerRef: TT,\n  unref: R,\n  useAttrs: xO,\n  useCssModule: J1,\n  useCssVars: G1,\n  useModel: _$,\n  useSSRContext: yO,\n  useSlots: DE,\n  useTransitionState: SO,\n  vModelCheckbox: $d,\n  vModelDynamic: sS,\n  vModelRadio: RO,\n  vModelSelect: rS,\n  vModelText: Gi,\n  vShow: jl,\n  version: _h,\n  warn: Xt,\n  watch: ht,\n  watchEffect: Bn,\n  watchPostEffect: t1,\n  watchSyncEffect: n1,\n  withAsyncContext: WE,\n  withCtx: ce,\n  withDefaults: NE,\n  withDirectives: Xi,\n  withKeys: lS,\n  withMemo: T$,\n  withModifiers: aS,\n  withScopeId: rE\n}, Symbol.toStringTag, { value: \"Module\" }));\n/**\n* vue v3.4.21\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\nfunction SQ() {\n  CO();\n}\n true && SQ();\nfunction wQ(t, e, n) {\n  let r = G(n == null ? void 0 : n.value), i = j(() => t.value !== void 0);\n  return [j(() => i.value ? t.value : r.value), function(s) {\n    return i.value || (r.value = s), e == null ? void 0 : e(s);\n  }];\n}\nlet kQ = Symbol(\"headlessui.useid\"), xQ = 0;\nfunction mr() {\n  return Pt(kQ, () => `${++xQ}`)();\n}\nfunction pe(t) {\n  var e;\n  if (t == null || t.value == null)\n    return null;\n  let n = (e = t.value.$el) != null ? e : t.value;\n  return n instanceof Node ? n : null;\n}\nfunction Tt(t, e, ...n) {\n  if (t in e) {\n    let i = e[t];\n    return typeof i == \"function\" ? i(...n) : i;\n  }\n  let r = new Error(`Tried to handle \"${t}\" but there is no handler defined. Only defined handlers are: ${Object.keys(e).map((i) => `\"${i}\"`).join(\", \")}.`);\n  throw Error.captureStackTrace && Error.captureStackTrace(r, Tt), r;\n}\nvar PQ = Object.defineProperty, _Q = (t, e, n) => e in t ? PQ(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, nb = (t, e, n) => (_Q(t, typeof e != \"symbol\" ? e + \"\" : e, n), n);\nlet TQ = class {\n  constructor() {\n    nb(this, \"current\", this.detect()), nb(this, \"currentId\", 0);\n  }\n  set(e) {\n    this.current !== e && (this.currentId = 0, this.current = e);\n  }\n  reset() {\n    this.set(this.detect());\n  }\n  nextId() {\n    return ++this.currentId;\n  }\n  get isServer() {\n    return this.current === \"server\";\n  }\n  get isClient() {\n    return this.current === \"client\";\n  }\n  detect() {\n    return typeof window > \"u\" || typeof document > \"u\" ? \"server\" : \"client\";\n  }\n}, Qd = new TQ();\nfunction to(t) {\n  if (Qd.isServer)\n    return null;\n  if (t instanceof Node)\n    return t.ownerDocument;\n  if (t != null && t.hasOwnProperty(\"value\")) {\n    let e = pe(t);\n    if (e)\n      return e.ownerDocument;\n  }\n  return document;\n}\nlet Qh = [\"[contentEditable=true]\", \"[tabindex]\", \"a[href]\", \"area[href]\", \"button:not([disabled])\", \"iframe\", \"input:not([disabled])\", \"select:not([disabled])\", \"textarea:not([disabled])\"].map((t) => `${t}:not([tabindex='-1'])`).join(\",\");\nvar Wt = ((t) => (t[t.First = 1] = \"First\", t[t.Previous = 2] = \"Previous\", t[t.Next = 4] = \"Next\", t[t.Last = 8] = \"Last\", t[t.WrapAround = 16] = \"WrapAround\", t[t.NoScroll = 32] = \"NoScroll\", t))(Wt || {}), ho = ((t) => (t[t.Error = 0] = \"Error\", t[t.Overflow = 1] = \"Overflow\", t[t.Success = 2] = \"Success\", t[t.Underflow = 3] = \"Underflow\", t))(ho || {}), EQ = ((t) => (t[t.Previous = -1] = \"Previous\", t[t.Next = 1] = \"Next\", t))(EQ || {});\nfunction $Q(t = document.body) {\n  return t == null ? [] : Array.from(t.querySelectorAll(Qh)).sort((e, n) => Math.sign((e.tabIndex || Number.MAX_SAFE_INTEGER) - (n.tabIndex || Number.MAX_SAFE_INTEGER)));\n}\nvar NO = ((t) => (t[t.Strict = 0] = \"Strict\", t[t.Loose = 1] = \"Loose\", t))(NO || {});\nfunction bS(t, e = 0) {\n  var n;\n  return t === ((n = to(t)) == null ? void 0 : n.body) ? !1 : Tt(e, { 0() {\n    return t.matches(Qh);\n  }, 1() {\n    let r = t;\n    for (; r !== null; ) {\n      if (r.matches(Qh))\n        return !0;\n      r = r.parentElement;\n    }\n    return !1;\n  } });\n}\nvar QQ = ((t) => (t[t.Keyboard = 0] = \"Keyboard\", t[t.Mouse = 1] = \"Mouse\", t))(QQ || {});\ntypeof window < \"u\" && typeof document < \"u\" && (document.addEventListener(\"keydown\", (t) => {\n  t.metaKey || t.altKey || t.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = \"\");\n}, !0), document.addEventListener(\"click\", (t) => {\n  t.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : t.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = \"\");\n}, !0));\nfunction Vs(t) {\n  t == null || t.focus({ preventScroll: !0 });\n}\nlet CQ = [\"textarea\", \"input\"].join(\",\");\nfunction AQ(t) {\n  var e, n;\n  return (n = (e = t == null ? void 0 : t.matches) == null ? void 0 : e.call(t, CQ)) != null ? n : !1;\n}\nfunction vs(t, e = (n) => n) {\n  return t.slice().sort((n, r) => {\n    let i = e(n), s = e(r);\n    if (i === null || s === null)\n      return 0;\n    let o = i.compareDocumentPosition(s);\n    return o & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : o & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;\n  });\n}\nfunction Er(t, e, { sorted: n = !0, relativeTo: r = null, skipElements: i = [] } = {}) {\n  var s;\n  let o = (s = Array.isArray(t) ? t.length > 0 ? t[0].ownerDocument : document : t == null ? void 0 : t.ownerDocument) != null ? s : document, a = Array.isArray(t) ? n ? vs(t) : t : $Q(t);\n  i.length > 0 && a.length > 1 && (a = a.filter((p) => !i.includes(p))), r = r ?? o.activeElement;\n  let l = (() => {\n    if (e & 5)\n      return 1;\n    if (e & 10)\n      return -1;\n    throw new Error(\"Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last\");\n  })(), c = (() => {\n    if (e & 1)\n      return 0;\n    if (e & 2)\n      return Math.max(0, a.indexOf(r)) - 1;\n    if (e & 4)\n      return Math.max(0, a.indexOf(r)) + 1;\n    if (e & 8)\n      return a.length - 1;\n    throw new Error(\"Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last\");\n  })(), u = e & 32 ? { preventScroll: !0 } : {}, d = 0, f = a.length, h;\n  do {\n    if (d >= f || d + f <= 0)\n      return 0;\n    let p = c + d;\n    if (e & 16)\n      p = (p + f) % f;\n    else {\n      if (p < 0)\n        return 3;\n      if (p >= f)\n        return 1;\n    }\n    h = a[p], h == null || h.focus(u), d += l;\n  } while (h !== o.activeElement);\n  return e & 6 && AQ(h) && h.select(), 2;\n}\nfunction vS() {\n  return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;\n}\nfunction RQ() {\n  return /Android/gi.test(window.navigator.userAgent);\n}\nfunction NQ() {\n  return vS() || RQ();\n}\nfunction vc(t, e, n) {\n  Qd.isServer || Bn((r) => {\n    document.addEventListener(t, e, n), r(() => document.removeEventListener(t, e, n));\n  });\n}\nfunction yS(t, e, n) {\n  Qd.isServer || Bn((r) => {\n    window.addEventListener(t, e, n), r(() => window.removeEventListener(t, e, n));\n  });\n}\nfunction SS(t, e, n = j(() => !0)) {\n  function r(s, o) {\n    if (!n.value || s.defaultPrevented)\n      return;\n    let a = o(s);\n    if (a === null || !a.getRootNode().contains(a))\n      return;\n    let l = function c(u) {\n      return typeof u == \"function\" ? c(u()) : Array.isArray(u) || u instanceof Set ? u : [u];\n    }(t);\n    for (let c of l) {\n      if (c === null)\n        continue;\n      let u = c instanceof HTMLElement ? c : pe(c);\n      if (u != null && u.contains(a) || s.composed && s.composedPath().includes(u))\n        return;\n    }\n    return !bS(a, NO.Loose) && a.tabIndex !== -1 && s.preventDefault(), e(s, a);\n  }\n  let i = G(null);\n  vc(\"pointerdown\", (s) => {\n    var o, a;\n    n.value && (i.value = ((a = (o = s.composedPath) == null ? void 0 : o.call(s)) == null ? void 0 : a[0]) || s.target);\n  }, !0), vc(\"mousedown\", (s) => {\n    var o, a;\n    n.value && (i.value = ((a = (o = s.composedPath) == null ? void 0 : o.call(s)) == null ? void 0 : a[0]) || s.target);\n  }, !0), vc(\"click\", (s) => {\n    NQ() || i.value && (r(s, () => i.value), i.value = null);\n  }, !0), vc(\"touchend\", (s) => r(s, () => s.target instanceof HTMLElement ? s.target : null), !0), yS(\"blur\", (s) => r(s, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), !0);\n}\nfunction rb(t, e) {\n  if (t)\n    return t;\n  let n = e ?? \"button\";\n  if (typeof n == \"string\" && n.toLowerCase() === \"button\")\n    return \"button\";\n}\nfunction DO(t, e) {\n  let n = G(rb(t.value.type, t.value.as));\n  return et(() => {\n    n.value = rb(t.value.type, t.value.as);\n  }), Bn(() => {\n    var r;\n    n.value || pe(e) && pe(e) instanceof HTMLButtonElement && !((r = pe(e)) != null && r.hasAttribute(\"type\")) && (n.value = \"button\");\n  }), n;\n}\nfunction ib(t) {\n  return [t.screenX, t.screenY];\n}\nfunction DQ() {\n  let t = G([-1, -1]);\n  return { wasMoved(e) {\n    let n = ib(e);\n    return t.value[0] === n[0] && t.value[1] === n[1] ? !1 : (t.value = n, !0);\n  }, update(e) {\n    t.value = ib(e);\n  } };\n}\nvar ci = ((t) => (t[t.None = 0] = \"None\", t[t.RenderStrategy = 1] = \"RenderStrategy\", t[t.Static = 2] = \"Static\", t))(ci || {}), ZQ = ((t) => (t[t.Unmount = 0] = \"Unmount\", t[t.Hidden = 1] = \"Hidden\", t))(ZQ || {});\nfunction Et({ visible: t = !0, features: e = 0, ourProps: n, theirProps: r, ...i }) {\n  var s;\n  let o = kS(r, n), a = Object.assign(i, { props: o });\n  if (t || e & 2 && o.static)\n    return gf(a);\n  if (e & 1) {\n    let l = (s = o.unmount) == null || s ? 0 : 1;\n    return Tt(l, { 0() {\n      return null;\n    }, 1() {\n      return gf({ ...i, props: { ...o, hidden: !0, style: { display: \"none\" } } });\n    } });\n  }\n  return gf(a);\n}\nfunction gf({ props: t, attrs: e, slots: n, slot: r, name: i }) {\n  var s, o;\n  let { as: a, ...l } = ZO(t, [\"unmount\", \"static\"]), c = (s = n.default) == null ? void 0 : s.call(n, r), u = {};\n  if (r) {\n    let d = !1, f = [];\n    for (let [h, p] of Object.entries(r))\n      typeof p == \"boolean\" && (d = !0), p === !0 && f.push(h);\n    d && (u[\"data-headlessui-state\"] = f.join(\" \"));\n  }\n  if (a === \"template\") {\n    if (c = wS(c ?? []), Object.keys(l).length > 0 || Object.keys(e).length > 0) {\n      let [d, ...f] = c ?? [];\n      if (!IQ(d) || f.length > 0)\n        throw new Error(['Passing props on \"template\"!', \"\", `The current component <${i} /> is rendering a \"template\".`, \"However we need to passthrough the following props:\", Object.keys(l).concat(Object.keys(e)).map((O) => O.trim()).filter((O, m, y) => y.indexOf(O) === m).sort((O, m) => O.localeCompare(m)).map((O) => `  - ${O}`).join(`\n`), \"\", \"You can apply a few solutions:\", ['Add an `as=\"...\"` prop, to ensure that we render an actual element instead of a \"template\".', \"Render a single element as the child so that we can forward the props onto that element.\"].map((O) => `  - ${O}`).join(`\n`)].join(`\n`));\n      let h = kS((o = d.props) != null ? o : {}, l, u), p = jn(d, h, !0);\n      for (let O in h)\n        O.startsWith(\"on\") && (p.props || (p.props = {}), p.props[O] = h[O]);\n      return p;\n    }\n    return Array.isArray(c) && c.length === 1 ? c[0] : c;\n  }\n  return kt(a, Object.assign({}, l, u), { default: () => c });\n}\nfunction wS(t) {\n  return t.flatMap((e) => e.type === Pe ? wS(e.children) : [e]);\n}\nfunction kS(...t) {\n  if (t.length === 0)\n    return {};\n  if (t.length === 1)\n    return t[0];\n  let e = {}, n = {};\n  for (let r of t)\n    for (let i in r)\n      i.startsWith(\"on\") && typeof r[i] == \"function\" ? (n[i] != null || (n[i] = []), n[i].push(r[i])) : e[i] = r[i];\n  if (e.disabled || e[\"aria-disabled\"])\n    return Object.assign(e, Object.fromEntries(Object.keys(n).map((r) => [r, void 0])));\n  for (let r in n)\n    Object.assign(e, { [r](i, ...s) {\n      let o = n[r];\n      for (let a of o) {\n        if (i instanceof Event && i.defaultPrevented)\n          return;\n        a(i, ...s);\n      }\n    } });\n  return e;\n}\nfunction VQ(t) {\n  let e = Object.assign({}, t);\n  for (let n in e)\n    e[n] === void 0 && delete e[n];\n  return e;\n}\nfunction ZO(t, e = []) {\n  let n = Object.assign({}, t);\n  for (let r of e)\n    r in n && delete n[r];\n  return n;\n}\nfunction IQ(t) {\n  return t == null ? !1 : typeof t.type == \"string\" || typeof t.type == \"object\" || typeof t.type == \"function\";\n}\nvar Zo = ((t) => (t[t.None = 1] = \"None\", t[t.Focusable = 2] = \"Focusable\", t[t.Hidden = 4] = \"Hidden\", t))(Zo || {});\nlet Vo = /* @__PURE__ */ le({ name: \"Hidden\", props: { as: { type: [Object, String], default: \"div\" }, features: { type: Number, default: 1 } }, setup(t, { slots: e, attrs: n }) {\n  return () => {\n    var r;\n    let { features: i, ...s } = t, o = { \"aria-hidden\": (i & 2) === 2 ? !0 : (r = s[\"aria-hidden\"]) != null ? r : void 0, hidden: (i & 4) === 4 ? !0 : void 0, style: { position: \"fixed\", top: 1, left: 1, width: 1, height: 0, padding: 0, margin: -1, overflow: \"hidden\", clip: \"rect(0, 0, 0, 0)\", whiteSpace: \"nowrap\", borderWidth: \"0\", ...(i & 4) === 4 && (i & 2) !== 2 && { display: \"none\" } } };\n    return Et({ ourProps: o, theirProps: s, slot: {}, attrs: n, slots: e, name: \"Hidden\" });\n  };\n} }), xS = Symbol(\"Context\");\nvar In = ((t) => (t[t.Open = 1] = \"Open\", t[t.Closed = 2] = \"Closed\", t[t.Closing = 4] = \"Closing\", t[t.Opening = 8] = \"Opening\", t))(In || {});\nfunction VO() {\n  return Pt(xS, null);\n}\nfunction PS(t) {\n  _n(xS, t);\n}\nvar Xe = ((t) => (t.Space = \" \", t.Enter = \"Enter\", t.Escape = \"Escape\", t.Backspace = \"Backspace\", t.Delete = \"Delete\", t.ArrowLeft = \"ArrowLeft\", t.ArrowUp = \"ArrowUp\", t.ArrowRight = \"ArrowRight\", t.ArrowDown = \"ArrowDown\", t.Home = \"Home\", t.End = \"End\", t.PageUp = \"PageUp\", t.PageDown = \"PageDown\", t.Tab = \"Tab\", t))(Xe || {});\nfunction WQ(t) {\n  function e() {\n    document.readyState !== \"loading\" && (t(), document.removeEventListener(\"DOMContentLoaded\", e));\n  }\n  typeof window < \"u\" && typeof document < \"u\" && (document.addEventListener(\"DOMContentLoaded\", e), e());\n}\nlet ys = [];\nWQ(() => {\n  function t(e) {\n    e.target instanceof HTMLElement && e.target !== document.body && ys[0] !== e.target && (ys.unshift(e.target), ys = ys.filter((n) => n != null && n.isConnected), ys.splice(10));\n  }\n  window.addEventListener(\"click\", t, { capture: !0 }), window.addEventListener(\"mousedown\", t, { capture: !0 }), window.addEventListener(\"focus\", t, { capture: !0 }), document.body.addEventListener(\"click\", t, { capture: !0 }), document.body.addEventListener(\"mousedown\", t, { capture: !0 }), document.body.addEventListener(\"focus\", t, { capture: !0 });\n});\nfunction MQ(t) {\n  throw new Error(\"Unexpected object: \" + t);\n}\nvar hn = ((t) => (t[t.First = 0] = \"First\", t[t.Previous = 1] = \"Previous\", t[t.Next = 2] = \"Next\", t[t.Last = 3] = \"Last\", t[t.Specific = 4] = \"Specific\", t[t.Nothing = 5] = \"Nothing\", t))(hn || {});\nfunction XQ(t, e) {\n  let n = e.resolveItems();\n  if (n.length <= 0)\n    return null;\n  let r = e.resolveActiveIndex(), i = r ?? -1;\n  switch (t.focus) {\n    case 0: {\n      for (let s = 0; s < n.length; ++s)\n        if (!e.resolveDisabled(n[s], s, n))\n          return s;\n      return r;\n    }\n    case 1: {\n      i === -1 && (i = n.length);\n      for (let s = i - 1; s >= 0; --s)\n        if (!e.resolveDisabled(n[s], s, n))\n          return s;\n      return r;\n    }\n    case 2: {\n      for (let s = i + 1; s < n.length; ++s)\n        if (!e.resolveDisabled(n[s], s, n))\n          return s;\n      return r;\n    }\n    case 3: {\n      for (let s = n.length - 1; s >= 0; --s)\n        if (!e.resolveDisabled(n[s], s, n))\n          return s;\n      return r;\n    }\n    case 4: {\n      for (let s = 0; s < n.length; ++s)\n        if (e.resolveId(n[s], s, n) === t.id)\n          return s;\n      return r;\n    }\n    case 5:\n      return null;\n    default:\n      MQ(t);\n  }\n}\nfunction Cd(t) {\n  typeof queueMicrotask == \"function\" ? queueMicrotask(t) : Promise.resolve().then(t).catch((e) => setTimeout(() => {\n    throw e;\n  }));\n}\nfunction IO() {\n  let t = [], e = { addEventListener(n, r, i, s) {\n    return n.addEventListener(r, i, s), e.add(() => n.removeEventListener(r, i, s));\n  }, requestAnimationFrame(...n) {\n    let r = requestAnimationFrame(...n);\n    e.add(() => cancelAnimationFrame(r));\n  }, nextFrame(...n) {\n    e.requestAnimationFrame(() => {\n      e.requestAnimationFrame(...n);\n    });\n  }, setTimeout(...n) {\n    let r = setTimeout(...n);\n    e.add(() => clearTimeout(r));\n  }, microTask(...n) {\n    let r = { current: !0 };\n    return Cd(() => {\n      r.current && n[0]();\n    }), e.add(() => {\n      r.current = !1;\n    });\n  }, style(n, r, i) {\n    let s = n.style.getPropertyValue(r);\n    return Object.assign(n.style, { [r]: i }), this.add(() => {\n      Object.assign(n.style, { [r]: s });\n    });\n  }, group(n) {\n    let r = IO();\n    return n(r), this.add(() => r.dispose());\n  }, add(n) {\n    return t.push(n), () => {\n      let r = t.indexOf(n);\n      if (r >= 0)\n        for (let i of t.splice(r, 1))\n          i();\n    };\n  }, dispose() {\n    for (let n of t.splice(0))\n      n();\n  } };\n  return e;\n}\nfunction _S(t = {}, e = null, n = []) {\n  for (let [r, i] of Object.entries(t))\n    ES(n, TS(e, r), i);\n  return n;\n}\nfunction TS(t, e) {\n  return t ? t + \"[\" + e + \"]\" : e;\n}\nfunction ES(t, e, n) {\n  if (Array.isArray(n))\n    for (let [r, i] of n.entries())\n      ES(t, TS(e, r.toString()), i);\n  else\n    n instanceof Date ? t.push([e, n.toISOString()]) : typeof n == \"boolean\" ? t.push([e, n ? \"1\" : \"0\"]) : typeof n == \"string\" ? t.push([e, n]) : typeof n == \"number\" ? t.push([e, `${n}`]) : n == null ? t.push([e, \"\"]) : _S(n, e, t);\n}\nfunction $S(t, e, n, r) {\n  Qd.isServer || Bn((i) => {\n    t = t ?? window, t.addEventListener(e, n, r), i(() => t.removeEventListener(e, n, r));\n  });\n}\nvar Aa = ((t) => (t[t.Forwards = 0] = \"Forwards\", t[t.Backwards = 1] = \"Backwards\", t))(Aa || {});\nfunction jQ() {\n  let t = G(0);\n  return yS(\"keydown\", (e) => {\n    e.key === \"Tab\" && (t.value = e.shiftKey ? 1 : 0);\n  }), t;\n}\nfunction QS(t) {\n  if (!t)\n    return /* @__PURE__ */ new Set();\n  if (typeof t == \"function\")\n    return new Set(t());\n  let e = /* @__PURE__ */ new Set();\n  for (let n of t.value) {\n    let r = pe(n);\n    r instanceof HTMLElement && e.add(r);\n  }\n  return e;\n}\nvar CS = ((t) => (t[t.None = 1] = \"None\", t[t.InitialFocus = 2] = \"InitialFocus\", t[t.TabLock = 4] = \"TabLock\", t[t.FocusLock = 8] = \"FocusLock\", t[t.RestoreFocus = 16] = \"RestoreFocus\", t[t.All = 30] = \"All\", t))(CS || {});\nlet pa = Object.assign(/* @__PURE__ */ le({ name: \"FocusTrap\", props: { as: { type: [Object, String], default: \"div\" }, initialFocus: { type: Object, default: null }, features: { type: Number, default: 30 }, containers: { type: [Object, Function], default: G(/* @__PURE__ */ new Set()) } }, inheritAttrs: !1, setup(t, { attrs: e, slots: n, expose: r }) {\n  let i = G(null);\n  r({ el: i, $el: i });\n  let s = j(() => to(i)), o = G(!1);\n  et(() => o.value = !0), jt(() => o.value = !1), LQ({ ownerDocument: s }, j(() => o.value && !!(t.features & 16)));\n  let a = UQ({ ownerDocument: s, container: i, initialFocus: j(() => t.initialFocus) }, j(() => o.value && !!(t.features & 2)));\n  qQ({ ownerDocument: s, container: i, containers: t.containers, previousActiveElement: a }, j(() => o.value && !!(t.features & 8)));\n  let l = jQ();\n  function c(h) {\n    let p = pe(i);\n    p && ((O) => O())(() => {\n      Tt(l.value, { [Aa.Forwards]: () => {\n        Er(p, Wt.First, { skipElements: [h.relatedTarget] });\n      }, [Aa.Backwards]: () => {\n        Er(p, Wt.Last, { skipElements: [h.relatedTarget] });\n      } });\n    });\n  }\n  let u = G(!1);\n  function d(h) {\n    h.key === \"Tab\" && (u.value = !0, requestAnimationFrame(() => {\n      u.value = !1;\n    }));\n  }\n  function f(h) {\n    if (!o.value)\n      return;\n    let p = QS(t.containers);\n    pe(i) instanceof HTMLElement && p.add(pe(i));\n    let O = h.relatedTarget;\n    O instanceof HTMLElement && O.dataset.headlessuiFocusGuard !== \"true\" && (AS(p, O) || (u.value ? Er(pe(i), Tt(l.value, { [Aa.Forwards]: () => Wt.Next, [Aa.Backwards]: () => Wt.Previous }) | Wt.WrapAround, { relativeTo: h.target }) : h.target instanceof HTMLElement && Vs(h.target)));\n  }\n  return () => {\n    let h = {}, p = { ref: i, onKeydown: d, onFocusout: f }, { features: O, initialFocus: m, containers: y, ...b } = t;\n    return kt(Pe, [!!(O & 4) && kt(Vo, { as: \"button\", type: \"button\", \"data-headlessui-focus-guard\": !0, onFocus: c, features: Zo.Focusable }), Et({ ourProps: p, theirProps: { ...e, ...b }, slot: h, attrs: e, slots: n, name: \"FocusTrap\" }), !!(O & 4) && kt(Vo, { as: \"button\", type: \"button\", \"data-headlessui-focus-guard\": !0, onFocus: c, features: Zo.Focusable })]);\n  };\n} }), { features: CS });\nfunction BQ(t) {\n  let e = G(ys.slice());\n  return ht([t], ([n], [r]) => {\n    r === !0 && n === !1 ? Cd(() => {\n      e.value.splice(0);\n    }) : r === !1 && n === !0 && (e.value = ys.slice());\n  }, { flush: \"post\" }), () => {\n    var n;\n    return (n = e.value.find((r) => r != null && r.isConnected)) != null ? n : null;\n  };\n}\nfunction LQ({ ownerDocument: t }, e) {\n  let n = BQ(e);\n  et(() => {\n    Bn(() => {\n      var r, i;\n      e.value || ((r = t.value) == null ? void 0 : r.activeElement) === ((i = t.value) == null ? void 0 : i.body) && Vs(n());\n    }, { flush: \"post\" });\n  }), jt(() => {\n    e.value && Vs(n());\n  });\n}\nfunction UQ({ ownerDocument: t, container: e, initialFocus: n }, r) {\n  let i = G(null), s = G(!1);\n  return et(() => s.value = !0), jt(() => s.value = !1), et(() => {\n    ht([e, n, r], (o, a) => {\n      if (o.every((c, u) => (a == null ? void 0 : a[u]) === c) || !r.value)\n        return;\n      let l = pe(e);\n      l && Cd(() => {\n        var c, u;\n        if (!s.value)\n          return;\n        let d = pe(n), f = (c = t.value) == null ? void 0 : c.activeElement;\n        if (d) {\n          if (d === f) {\n            i.value = f;\n            return;\n          }\n        } else if (l.contains(f)) {\n          i.value = f;\n          return;\n        }\n        d ? Vs(d) : Er(l, Wt.First | Wt.NoScroll) === ho.Error && console.warn(\"There are no focusable elements inside the <FocusTrap />\"), i.value = (u = t.value) == null ? void 0 : u.activeElement;\n      });\n    }, { immediate: !0, flush: \"post\" });\n  }), i;\n}\nfunction qQ({ ownerDocument: t, container: e, containers: n, previousActiveElement: r }, i) {\n  var s;\n  $S((s = t.value) == null ? void 0 : s.defaultView, \"focus\", (o) => {\n    if (!i.value)\n      return;\n    let a = QS(n);\n    pe(e) instanceof HTMLElement && a.add(pe(e));\n    let l = r.value;\n    if (!l)\n      return;\n    let c = o.target;\n    c && c instanceof HTMLElement ? AS(a, c) ? (r.value = c, Vs(c)) : (o.preventDefault(), o.stopPropagation(), Vs(l)) : Vs(r.value);\n  }, !0);\n}\nfunction AS(t, e) {\n  for (let n of t)\n    if (n.contains(e))\n      return !0;\n  return !1;\n}\nfunction YQ(t) {\n  let e = cO(t.getSnapshot());\n  return jt(t.subscribe(() => {\n    e.value = t.getSnapshot();\n  })), e;\n}\nfunction zQ(t, e) {\n  let n = t(), r = /* @__PURE__ */ new Set();\n  return { getSnapshot() {\n    return n;\n  }, subscribe(i) {\n    return r.add(i), () => r.delete(i);\n  }, dispatch(i, ...s) {\n    let o = e[i].call(n, ...s);\n    o && (n = o, r.forEach((a) => a()));\n  } };\n}\nfunction HQ() {\n  let t;\n  return { before({ doc: e }) {\n    var n;\n    let r = e.documentElement;\n    t = ((n = e.defaultView) != null ? n : window).innerWidth - r.clientWidth;\n  }, after({ doc: e, d: n }) {\n    let r = e.documentElement, i = r.clientWidth - r.offsetWidth, s = t - i;\n    n.style(r, \"paddingRight\", `${s}px`);\n  } };\n}\nfunction FQ() {\n  return vS() ? { before({ doc: t, d: e, meta: n }) {\n    function r(i) {\n      return n.containers.flatMap((s) => s()).some((s) => s.contains(i));\n    }\n    e.microTask(() => {\n      var i;\n      if (window.getComputedStyle(t.documentElement).scrollBehavior !== \"auto\") {\n        let a = IO();\n        a.style(t.documentElement, \"scrollBehavior\", \"auto\"), e.add(() => e.microTask(() => a.dispose()));\n      }\n      let s = (i = window.scrollY) != null ? i : window.pageYOffset, o = null;\n      e.addEventListener(t, \"click\", (a) => {\n        if (a.target instanceof HTMLElement)\n          try {\n            let l = a.target.closest(\"a\");\n            if (!l)\n              return;\n            let { hash: c } = new URL(l.href), u = t.querySelector(c);\n            u && !r(u) && (o = u);\n          } catch {\n          }\n      }, !0), e.addEventListener(t, \"touchstart\", (a) => {\n        if (a.target instanceof HTMLElement)\n          if (r(a.target)) {\n            let l = a.target;\n            for (; l.parentElement && r(l.parentElement); )\n              l = l.parentElement;\n            e.style(l, \"overscrollBehavior\", \"contain\");\n          } else\n            e.style(a.target, \"touchAction\", \"none\");\n      }), e.addEventListener(t, \"touchmove\", (a) => {\n        if (a.target instanceof HTMLElement)\n          if (r(a.target)) {\n            let l = a.target;\n            for (; l.parentElement && l.dataset.headlessuiPortal !== \"\" && !(l.scrollHeight > l.clientHeight || l.scrollWidth > l.clientWidth); )\n              l = l.parentElement;\n            l.dataset.headlessuiPortal === \"\" && a.preventDefault();\n          } else\n            a.preventDefault();\n      }, { passive: !1 }), e.add(() => {\n        var a;\n        let l = (a = window.scrollY) != null ? a : window.pageYOffset;\n        s !== l && window.scrollTo(0, s), o && o.isConnected && (o.scrollIntoView({ block: \"nearest\" }), o = null);\n      });\n    });\n  } } : {};\n}\nfunction GQ() {\n  return { before({ doc: t, d: e }) {\n    e.style(t.documentElement, \"overflow\", \"hidden\");\n  } };\n}\nfunction KQ(t) {\n  let e = {};\n  for (let n of t)\n    Object.assign(e, n(e));\n  return e;\n}\nlet ks = zQ(() => /* @__PURE__ */ new Map(), { PUSH(t, e) {\n  var n;\n  let r = (n = this.get(t)) != null ? n : { doc: t, count: 0, d: IO(), meta: /* @__PURE__ */ new Set() };\n  return r.count++, r.meta.add(e), this.set(t, r), this;\n}, POP(t, e) {\n  let n = this.get(t);\n  return n && (n.count--, n.meta.delete(e)), this;\n}, SCROLL_PREVENT({ doc: t, d: e, meta: n }) {\n  let r = { doc: t, d: e, meta: KQ(n) }, i = [FQ(), HQ(), GQ()];\n  i.forEach(({ before: s }) => s == null ? void 0 : s(r)), i.forEach(({ after: s }) => s == null ? void 0 : s(r));\n}, SCROLL_ALLOW({ d: t }) {\n  t.dispose();\n}, TEARDOWN({ doc: t }) {\n  this.delete(t);\n} });\nks.subscribe(() => {\n  let t = ks.getSnapshot(), e = /* @__PURE__ */ new Map();\n  for (let [n] of t)\n    e.set(n, n.documentElement.style.overflow);\n  for (let n of t.values()) {\n    let r = e.get(n.doc) === \"hidden\", i = n.count !== 0;\n    (i && !r || !i && r) && ks.dispatch(n.count > 0 ? \"SCROLL_PREVENT\" : \"SCROLL_ALLOW\", n), n.count === 0 && ks.dispatch(\"TEARDOWN\", n);\n  }\n});\nfunction JQ(t, e, n) {\n  let r = YQ(ks), i = j(() => {\n    let s = t.value ? r.value.get(t.value) : void 0;\n    return s ? s.count > 0 : !1;\n  });\n  return ht([t, e], ([s, o], [a], l) => {\n    if (!s || !o)\n      return;\n    ks.dispatch(\"PUSH\", s, n);\n    let c = !1;\n    l(() => {\n      c || (ks.dispatch(\"POP\", a ?? s, n), c = !0);\n    });\n  }, { immediate: !0 }), i;\n}\nlet mf = /* @__PURE__ */ new Map(), Oa = /* @__PURE__ */ new Map();\nfunction sb(t, e = G(!0)) {\n  Bn((n) => {\n    var r;\n    if (!e.value)\n      return;\n    let i = pe(t);\n    if (!i)\n      return;\n    n(function() {\n      var o;\n      if (!i)\n        return;\n      let a = (o = Oa.get(i)) != null ? o : 1;\n      if (a === 1 ? Oa.delete(i) : Oa.set(i, a - 1), a !== 1)\n        return;\n      let l = mf.get(i);\n      l && (l[\"aria-hidden\"] === null ? i.removeAttribute(\"aria-hidden\") : i.setAttribute(\"aria-hidden\", l[\"aria-hidden\"]), i.inert = l.inert, mf.delete(i));\n    });\n    let s = (r = Oa.get(i)) != null ? r : 0;\n    Oa.set(i, s + 1), s === 0 && (mf.set(i, { \"aria-hidden\": i.getAttribute(\"aria-hidden\"), inert: i.inert }), i.setAttribute(\"aria-hidden\", \"true\"), i.inert = !0);\n  });\n}\nfunction eC({ defaultContainers: t = [], portals: e, mainTreeNodeRef: n } = {}) {\n  let r = G(null), i = to(r);\n  function s() {\n    var o, a, l;\n    let c = [];\n    for (let u of t)\n      u !== null && (u instanceof HTMLElement ? c.push(u) : \"value\" in u && u.value instanceof HTMLElement && c.push(u.value));\n    if (e != null && e.value)\n      for (let u of e.value)\n        c.push(u);\n    for (let u of (o = i == null ? void 0 : i.querySelectorAll(\"html > *, body > *\")) != null ? o : [])\n      u !== document.body && u !== document.head && u instanceof HTMLElement && u.id !== \"headlessui-portal-root\" && (u.contains(pe(r)) || u.contains((l = (a = pe(r)) == null ? void 0 : a.getRootNode()) == null ? void 0 : l.host) || c.some((d) => u.contains(d)) || c.push(u));\n    return c;\n  }\n  return { resolveContainers: s, contains(o) {\n    return s().some((a) => a.contains(o));\n  }, mainTreeNodeRef: r, MainTreeNode() {\n    return n != null ? null : kt(Vo, { features: Zo.Hidden, ref: r });\n  } };\n}\nlet RS = Symbol(\"ForcePortalRootContext\");\nfunction tC() {\n  return Pt(RS, !1);\n}\nlet ob = /* @__PURE__ */ le({ name: \"ForcePortalRoot\", props: { as: { type: [Object, String], default: \"template\" }, force: { type: Boolean, default: !1 } }, setup(t, { slots: e, attrs: n }) {\n  return _n(RS, t.force), () => {\n    let { force: r, ...i } = t;\n    return Et({ theirProps: i, ourProps: {}, slot: {}, slots: e, attrs: n, name: \"ForcePortalRoot\" });\n  };\n} }), NS = Symbol(\"StackContext\");\nvar Ch = ((t) => (t[t.Add = 0] = \"Add\", t[t.Remove = 1] = \"Remove\", t))(Ch || {});\nfunction nC() {\n  return Pt(NS, () => {\n  });\n}\nfunction rC({ type: t, enabled: e, element: n, onUpdate: r }) {\n  let i = nC();\n  function s(...o) {\n    r == null || r(...o), i(...o);\n  }\n  et(() => {\n    ht(e, (o, a) => {\n      o ? s(0, t, n) : a === !0 && s(1, t, n);\n    }, { immediate: !0, flush: \"sync\" });\n  }), jt(() => {\n    e.value && s(1, t, n);\n  }), _n(NS, s);\n}\nlet DS = Symbol(\"DescriptionContext\");\nfunction iC() {\n  let t = Pt(DS, null);\n  if (t === null)\n    throw new Error(\"Missing parent\");\n  return t;\n}\nfunction sC({ slot: t = G({}), name: e = \"Description\", props: n = {} } = {}) {\n  let r = G([]);\n  function i(s) {\n    return r.value.push(s), () => {\n      let o = r.value.indexOf(s);\n      o !== -1 && r.value.splice(o, 1);\n    };\n  }\n  return _n(DS, { register: i, slot: t, name: e, props: n }), j(() => r.value.length > 0 ? r.value.join(\" \") : void 0);\n}\nlet oC = /* @__PURE__ */ le({ name: \"Description\", props: { as: { type: [Object, String], default: \"p\" }, id: { type: String, default: null } }, setup(t, { attrs: e, slots: n }) {\n  var r;\n  let i = (r = t.id) != null ? r : `headlessui-description-${mr()}`, s = iC();\n  return et(() => jt(s.register(i))), () => {\n    let { name: o = \"Description\", slot: a = G({}), props: l = {} } = s, { ...c } = t, u = { ...Object.entries(l).reduce((d, [f, h]) => Object.assign(d, { [f]: R(h) }), {}), id: i };\n    return Et({ ourProps: u, theirProps: c, slot: a.value, attrs: e, slots: n, name: o });\n  };\n} });\nfunction aC(t) {\n  let e = to(t);\n  if (!e) {\n    if (t === null)\n      return null;\n    throw new Error(`[Headless UI]: Cannot find ownerDocument for contextElement: ${t}`);\n  }\n  let n = e.getElementById(\"headlessui-portal-root\");\n  if (n)\n    return n;\n  let r = e.createElement(\"div\");\n  return r.setAttribute(\"id\", \"headlessui-portal-root\"), e.body.appendChild(r);\n}\nlet lC = /* @__PURE__ */ le({ name: \"Portal\", props: { as: { type: [Object, String], default: \"div\" } }, setup(t, { slots: e, attrs: n }) {\n  let r = G(null), i = j(() => to(r)), s = tC(), o = Pt(ZS, null), a = G(s === !0 || o == null ? aC(r.value) : o.resolveTarget()), l = G(!1);\n  et(() => {\n    l.value = !0;\n  }), Bn(() => {\n    s || o != null && (a.value = o.resolveTarget());\n  });\n  let c = Pt(Ah, null), u = !1, d = ir();\n  return ht(r, () => {\n    if (u || !c)\n      return;\n    let f = pe(r);\n    f && (jt(c.register(f), d), u = !0);\n  }), jt(() => {\n    var f, h;\n    let p = (f = i.value) == null ? void 0 : f.getElementById(\"headlessui-portal-root\");\n    p && a.value === p && a.value.children.length <= 0 && ((h = a.value.parentElement) == null || h.removeChild(a.value));\n  }), () => {\n    if (!l.value || a.value === null)\n      return null;\n    let f = { ref: r, \"data-headlessui-portal\": \"\" };\n    return kt(TO, { to: a.value }, Et({ ourProps: f, theirProps: t, slot: {}, attrs: n, slots: e, name: \"Portal\" }));\n  };\n} }), Ah = Symbol(\"PortalParentContext\");\nfunction cC() {\n  let t = Pt(Ah, null), e = G([]);\n  function n(s) {\n    return e.value.push(s), t && t.register(s), () => r(s);\n  }\n  function r(s) {\n    let o = e.value.indexOf(s);\n    o !== -1 && e.value.splice(o, 1), t && t.unregister(s);\n  }\n  let i = { register: n, unregister: r, portals: e };\n  return [e, /* @__PURE__ */ le({ name: \"PortalWrapper\", setup(s, { slots: o }) {\n    return _n(Ah, i), () => {\n      var a;\n      return (a = o.default) == null ? void 0 : a.call(o);\n    };\n  } })];\n}\nlet ZS = Symbol(\"PortalGroupContext\"), uC = /* @__PURE__ */ le({ name: \"PortalGroup\", props: { as: { type: [Object, String], default: \"template\" }, target: { type: Object, default: null } }, setup(t, { attrs: e, slots: n }) {\n  let r = Xn({ resolveTarget() {\n    return t.target;\n  } });\n  return _n(ZS, r), () => {\n    let { target: i, ...s } = t;\n    return Et({ theirProps: s, ourProps: {}, slot: {}, attrs: e, slots: n, name: \"PortalGroup\" });\n  };\n} });\nvar dC = ((t) => (t[t.Open = 0] = \"Open\", t[t.Closed = 1] = \"Closed\", t))(dC || {});\nlet Rh = Symbol(\"DialogContext\");\nfunction WO(t) {\n  let e = Pt(Rh, null);\n  if (e === null) {\n    let n = new Error(`<${t} /> is missing a parent <Dialog /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(n, WO), n;\n  }\n  return e;\n}\nlet yc = \"DC8F892D-2EBD-447C-A4C8-A03058436FF4\", fC = /* @__PURE__ */ le({ name: \"Dialog\", inheritAttrs: !1, props: { as: { type: [Object, String], default: \"div\" }, static: { type: Boolean, default: !1 }, unmount: { type: Boolean, default: !0 }, open: { type: [Boolean, String], default: yc }, initialFocus: { type: Object, default: null }, id: { type: String, default: null }, role: { type: String, default: \"dialog\" } }, emits: { close: (t) => !0 }, setup(t, { emit: e, attrs: n, slots: r, expose: i }) {\n  var s, o;\n  let a = (s = t.id) != null ? s : `headlessui-dialog-${mr()}`, l = G(!1);\n  et(() => {\n    l.value = !0;\n  });\n  let c = !1, u = j(() => t.role === \"dialog\" || t.role === \"alertdialog\" ? t.role : (c || (c = !0, console.warn(`Invalid role [${u}] passed to <Dialog />. Only \\`dialog\\` and and \\`alertdialog\\` are supported. Using \\`dialog\\` instead.`)), \"dialog\")), d = G(0), f = VO(), h = j(() => t.open === yc && f !== null ? (f.value & In.Open) === In.Open : t.open), p = G(null), O = j(() => to(p));\n  if (i({ el: p, $el: p }), !(t.open !== yc || f !== null))\n    throw new Error(\"You forgot to provide an `open` prop to the `Dialog`.\");\n  if (typeof h.value != \"boolean\")\n    throw new Error(`You provided an \\`open\\` prop to the \\`Dialog\\`, but the value is not a boolean. Received: ${h.value === yc ? void 0 : t.open}`);\n  let m = j(() => l.value && h.value ? 0 : 1), y = j(() => m.value === 0), b = j(() => d.value > 1), g = Pt(Rh, null) !== null, [v, S] = cC(), { resolveContainers: w, mainTreeNodeRef: k, MainTreeNode: _ } = eC({ portals: v, defaultContainers: [j(() => {\n    var ue;\n    return (ue = K.panelRef.value) != null ? ue : p.value;\n  })] }), T = j(() => b.value ? \"parent\" : \"leaf\"), C = j(() => f !== null ? (f.value & In.Closing) === In.Closing : !1), A = j(() => g || C.value ? !1 : y.value), Q = j(() => {\n    var ue, ge, Be;\n    return (Be = Array.from((ge = (ue = O.value) == null ? void 0 : ue.querySelectorAll(\"body > *\")) != null ? ge : []).find((Le) => Le.id === \"headlessui-portal-root\" ? !1 : Le.contains(pe(k)) && Le instanceof HTMLElement)) != null ? Be : null;\n  });\n  sb(Q, A);\n  let W = j(() => b.value ? !0 : y.value), L = j(() => {\n    var ue, ge, Be;\n    return (Be = Array.from((ge = (ue = O.value) == null ? void 0 : ue.querySelectorAll(\"[data-headlessui-portal]\")) != null ? ge : []).find((Le) => Le.contains(pe(k)) && Le instanceof HTMLElement)) != null ? Be : null;\n  });\n  sb(L, W), rC({ type: \"Dialog\", enabled: j(() => m.value === 0), element: p, onUpdate: (ue, ge) => {\n    if (ge === \"Dialog\")\n      return Tt(ue, { [Ch.Add]: () => d.value += 1, [Ch.Remove]: () => d.value -= 1 });\n  } });\n  let re = sC({ name: \"DialogDescription\", slot: j(() => ({ open: h.value })) }), Y = G(null), K = { titleId: Y, panelRef: G(null), dialogState: m, setTitleId(ue) {\n    Y.value !== ue && (Y.value = ue);\n  }, close() {\n    e(\"close\", !1);\n  } };\n  _n(Rh, K);\n  let B = j(() => !(!y.value || b.value));\n  SS(w, (ue, ge) => {\n    ue.preventDefault(), K.close(), Pn(() => ge == null ? void 0 : ge.focus());\n  }, B);\n  let _e = j(() => !(b.value || m.value !== 0));\n  $S((o = O.value) == null ? void 0 : o.defaultView, \"keydown\", (ue) => {\n    _e.value && (ue.defaultPrevented || ue.key === Xe.Escape && (ue.preventDefault(), ue.stopPropagation(), K.close()));\n  });\n  let Ce = j(() => !(C.value || m.value !== 0 || g));\n  return JQ(O, Ce, (ue) => {\n    var ge;\n    return { containers: [...(ge = ue.containers) != null ? ge : [], w] };\n  }), Bn((ue) => {\n    if (m.value !== 0)\n      return;\n    let ge = pe(p);\n    if (!ge)\n      return;\n    let Be = new ResizeObserver((Le) => {\n      for (let Zt of Le) {\n        let Vt = Zt.target.getBoundingClientRect();\n        Vt.x === 0 && Vt.y === 0 && Vt.width === 0 && Vt.height === 0 && K.close();\n      }\n    });\n    Be.observe(ge), ue(() => Be.disconnect());\n  }), () => {\n    let { open: ue, initialFocus: ge, ...Be } = t, Le = { ...n, ref: p, id: a, role: u.value, \"aria-modal\": m.value === 0 ? !0 : void 0, \"aria-labelledby\": Y.value, \"aria-describedby\": re.value }, Zt = { open: m.value === 0 };\n    return kt(ob, { force: !0 }, () => [kt(lC, () => kt(uC, { target: p.value }, () => kt(ob, { force: !1 }, () => kt(pa, { initialFocus: ge, containers: w, features: y.value ? Tt(T.value, { parent: pa.features.RestoreFocus, leaf: pa.features.All & ~pa.features.FocusLock }) : pa.features.None }, () => kt(S, {}, () => Et({ ourProps: Le, theirProps: { ...Be, ...n }, slot: Zt, attrs: n, slots: r, visible: m.value === 0, features: ci.RenderStrategy | ci.Static, name: \"Dialog\" })))))), kt(_)]);\n  };\n} }), hC = /* @__PURE__ */ le({ name: \"DialogPanel\", props: { as: { type: [Object, String], default: \"div\" }, id: { type: String, default: null } }, setup(t, { attrs: e, slots: n, expose: r }) {\n  var i;\n  let s = (i = t.id) != null ? i : `headlessui-dialog-panel-${mr()}`, o = WO(\"DialogPanel\");\n  r({ el: o.panelRef, $el: o.panelRef });\n  function a(l) {\n    l.stopPropagation();\n  }\n  return () => {\n    let { ...l } = t, c = { id: s, ref: o.panelRef, onClick: a };\n    return Et({ ourProps: c, theirProps: l, slot: { open: o.dialogState.value === 0 }, attrs: e, slots: n, name: \"DialogPanel\" });\n  };\n} }), pC = /* @__PURE__ */ le({ name: \"DialogTitle\", props: { as: { type: [Object, String], default: \"h2\" }, id: { type: String, default: null } }, setup(t, { attrs: e, slots: n }) {\n  var r;\n  let i = (r = t.id) != null ? r : `headlessui-dialog-title-${mr()}`, s = WO(\"DialogTitle\");\n  return et(() => {\n    s.setTitleId(i), jt(() => s.setTitleId(null));\n  }), () => {\n    let { ...o } = t;\n    return Et({ ourProps: { id: i }, theirProps: o, slot: { open: s.dialogState.value === 0 }, attrs: e, slots: n, name: \"DialogTitle\" });\n  };\n} }), OC = oC;\nvar gC = ((t) => (t[t.Open = 0] = \"Open\", t[t.Closed = 1] = \"Closed\", t))(gC || {});\nlet VS = Symbol(\"DisclosureContext\");\nfunction MO(t) {\n  let e = Pt(VS, null);\n  if (e === null) {\n    let n = new Error(`<${t} /> is missing a parent <Disclosure /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(n, MO), n;\n  }\n  return e;\n}\nlet IS = Symbol(\"DisclosurePanelContext\");\nfunction mC() {\n  return Pt(IS, null);\n}\nlet bC = /* @__PURE__ */ le({ name: \"Disclosure\", props: { as: { type: [Object, String], default: \"template\" }, defaultOpen: { type: [Boolean], default: !1 } }, setup(t, { slots: e, attrs: n }) {\n  let r = G(t.defaultOpen ? 0 : 1), i = G(null), s = G(null), o = { buttonId: G(`headlessui-disclosure-button-${mr()}`), panelId: G(`headlessui-disclosure-panel-${mr()}`), disclosureState: r, panel: i, button: s, toggleDisclosure() {\n    r.value = Tt(r.value, { 0: 1, 1: 0 });\n  }, closeDisclosure() {\n    r.value !== 1 && (r.value = 1);\n  }, close(a) {\n    o.closeDisclosure();\n    let l = a ? a instanceof HTMLElement ? a : a.value instanceof HTMLElement ? pe(a) : pe(o.button) : pe(o.button);\n    l == null || l.focus();\n  } };\n  return _n(VS, o), PS(j(() => Tt(r.value, { 0: In.Open, 1: In.Closed }))), () => {\n    let { defaultOpen: a, ...l } = t, c = { open: r.value === 0, close: o.close };\n    return Et({ theirProps: l, ourProps: {}, slot: c, slots: e, attrs: n, name: \"Disclosure\" });\n  };\n} }), vC = /* @__PURE__ */ le({ name: \"DisclosureButton\", props: { as: { type: [Object, String], default: \"button\" }, disabled: { type: [Boolean], default: !1 }, id: { type: String, default: null } }, setup(t, { attrs: e, slots: n, expose: r }) {\n  let i = MO(\"DisclosureButton\"), s = mC(), o = j(() => s === null ? !1 : s.value === i.panelId.value);\n  et(() => {\n    o.value || t.id !== null && (i.buttonId.value = t.id);\n  }), jt(() => {\n    o.value || (i.buttonId.value = null);\n  });\n  let a = G(null);\n  r({ el: a, $el: a }), o.value || Bn(() => {\n    i.button.value = a.value;\n  });\n  let l = DO(j(() => ({ as: t.as, type: e.type })), a);\n  function c() {\n    var f;\n    t.disabled || (o.value ? (i.toggleDisclosure(), (f = pe(i.button)) == null || f.focus()) : i.toggleDisclosure());\n  }\n  function u(f) {\n    var h;\n    if (!t.disabled)\n      if (o.value)\n        switch (f.key) {\n          case Xe.Space:\n          case Xe.Enter:\n            f.preventDefault(), f.stopPropagation(), i.toggleDisclosure(), (h = pe(i.button)) == null || h.focus();\n            break;\n        }\n      else\n        switch (f.key) {\n          case Xe.Space:\n          case Xe.Enter:\n            f.preventDefault(), f.stopPropagation(), i.toggleDisclosure();\n            break;\n        }\n  }\n  function d(f) {\n    switch (f.key) {\n      case Xe.Space:\n        f.preventDefault();\n        break;\n    }\n  }\n  return () => {\n    var f;\n    let h = { open: i.disclosureState.value === 0 }, { id: p, ...O } = t, m = o.value ? { ref: a, type: l.value, onClick: c, onKeydown: u } : { id: (f = i.buttonId.value) != null ? f : p, ref: a, type: l.value, \"aria-expanded\": i.disclosureState.value === 0, \"aria-controls\": i.disclosureState.value === 0 || pe(i.panel) ? i.panelId.value : void 0, disabled: t.disabled ? !0 : void 0, onClick: c, onKeydown: u, onKeyup: d };\n    return Et({ ourProps: m, theirProps: O, slot: h, attrs: e, slots: n, name: \"DisclosureButton\" });\n  };\n} }), yC = /* @__PURE__ */ le({ name: \"DisclosurePanel\", props: { as: { type: [Object, String], default: \"div\" }, static: { type: Boolean, default: !1 }, unmount: { type: Boolean, default: !0 }, id: { type: String, default: null } }, setup(t, { attrs: e, slots: n, expose: r }) {\n  let i = MO(\"DisclosurePanel\");\n  et(() => {\n    t.id !== null && (i.panelId.value = t.id);\n  }), jt(() => {\n    i.panelId.value = null;\n  }), r({ el: i.panel, $el: i.panel }), _n(IS, i.panelId);\n  let s = VO(), o = j(() => s !== null ? (s.value & In.Open) === In.Open : i.disclosureState.value === 0);\n  return () => {\n    var a;\n    let l = { open: i.disclosureState.value === 0, close: i.close }, { id: c, ...u } = t, d = { id: (a = i.panelId.value) != null ? a : c, ref: i.panel };\n    return Et({ ourProps: d, theirProps: u, slot: l, attrs: e, slots: n, features: ci.RenderStrategy | ci.Static, visible: o.value, name: \"DisclosurePanel\" });\n  };\n} }), ab = /([\\u2700-\\u27BF]|[\\uE000-\\uF8FF]|\\uD83C[\\uDC00-\\uDFFF]|\\uD83D[\\uDC00-\\uDFFF]|[\\u2011-\\u26FF]|\\uD83E[\\uDD10-\\uDDFF])/g;\nfunction lb(t) {\n  var e, n;\n  let r = (e = t.innerText) != null ? e : \"\", i = t.cloneNode(!0);\n  if (!(i instanceof HTMLElement))\n    return r;\n  let s = !1;\n  for (let a of i.querySelectorAll('[hidden],[aria-hidden],[role=\"img\"]'))\n    a.remove(), s = !0;\n  let o = s ? (n = i.innerText) != null ? n : \"\" : r;\n  return ab.test(o) && (o = o.replace(ab, \"\")), o;\n}\nfunction SC(t) {\n  let e = t.getAttribute(\"aria-label\");\n  if (typeof e == \"string\")\n    return e.trim();\n  let n = t.getAttribute(\"aria-labelledby\");\n  if (n) {\n    let r = n.split(\" \").map((i) => {\n      let s = document.getElementById(i);\n      if (s) {\n        let o = s.getAttribute(\"aria-label\");\n        return typeof o == \"string\" ? o.trim() : lb(s).trim();\n      }\n      return null;\n    }).filter(Boolean);\n    if (r.length > 0)\n      return r.join(\", \");\n  }\n  return lb(t).trim();\n}\nfunction wC(t) {\n  let e = G(\"\"), n = G(\"\");\n  return () => {\n    let r = pe(t);\n    if (!r)\n      return \"\";\n    let i = r.innerText;\n    if (e.value === i)\n      return n.value;\n    let s = SC(r).trim().toLowerCase();\n    return e.value = i, n.value = s, s;\n  };\n}\nfunction kC(t, e) {\n  return t === e;\n}\nvar xC = ((t) => (t[t.Open = 0] = \"Open\", t[t.Closed = 1] = \"Closed\", t))(xC || {}), PC = ((t) => (t[t.Single = 0] = \"Single\", t[t.Multi = 1] = \"Multi\", t))(PC || {}), _C = ((t) => (t[t.Pointer = 0] = \"Pointer\", t[t.Other = 1] = \"Other\", t))(_C || {});\nfunction TC(t) {\n  requestAnimationFrame(() => requestAnimationFrame(t));\n}\nlet WS = Symbol(\"ListboxContext\");\nfunction Ad(t) {\n  let e = Pt(WS, null);\n  if (e === null) {\n    let n = new Error(`<${t} /> is missing a parent <Listbox /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(n, Ad), n;\n  }\n  return e;\n}\nlet EC = /* @__PURE__ */ le({ name: \"Listbox\", emits: { \"update:modelValue\": (t) => !0 }, props: { as: { type: [Object, String], default: \"template\" }, disabled: { type: [Boolean], default: !1 }, by: { type: [String, Function], default: () => kC }, horizontal: { type: [Boolean], default: !1 }, modelValue: { type: [Object, String, Number, Boolean], default: void 0 }, defaultValue: { type: [Object, String, Number, Boolean], default: void 0 }, form: { type: String, optional: !0 }, name: { type: String, optional: !0 }, multiple: { type: [Boolean], default: !1 } }, inheritAttrs: !1, setup(t, { slots: e, attrs: n, emit: r }) {\n  let i = G(1), s = G(null), o = G(null), a = G(null), l = G([]), c = G(\"\"), u = G(null), d = G(1);\n  function f(g = (v) => v) {\n    let v = u.value !== null ? l.value[u.value] : null, S = vs(g(l.value.slice()), (k) => pe(k.dataRef.domRef)), w = v ? S.indexOf(v) : null;\n    return w === -1 && (w = null), { options: S, activeOptionIndex: w };\n  }\n  let h = j(() => t.multiple ? 1 : 0), [p, O] = wQ(j(() => t.modelValue), (g) => r(\"update:modelValue\", g), j(() => t.defaultValue)), m = j(() => p.value === void 0 ? Tt(h.value, { 1: [], 0: void 0 }) : p.value), y = { listboxState: i, value: m, mode: h, compare(g, v) {\n    if (typeof t.by == \"string\") {\n      let S = t.by;\n      return (g == null ? void 0 : g[S]) === (v == null ? void 0 : v[S]);\n    }\n    return t.by(g, v);\n  }, orientation: j(() => t.horizontal ? \"horizontal\" : \"vertical\"), labelRef: s, buttonRef: o, optionsRef: a, disabled: j(() => t.disabled), options: l, searchQuery: c, activeOptionIndex: u, activationTrigger: d, closeListbox() {\n    t.disabled || i.value !== 1 && (i.value = 1, u.value = null);\n  }, openListbox() {\n    t.disabled || i.value !== 0 && (i.value = 0);\n  }, goToOption(g, v, S) {\n    if (t.disabled || i.value === 1)\n      return;\n    let w = f(), k = XQ(g === hn.Specific ? { focus: hn.Specific, id: v } : { focus: g }, { resolveItems: () => w.options, resolveActiveIndex: () => w.activeOptionIndex, resolveId: (_) => _.id, resolveDisabled: (_) => _.dataRef.disabled });\n    c.value = \"\", u.value = k, d.value = S ?? 1, l.value = w.options;\n  }, search(g) {\n    if (t.disabled || i.value === 1)\n      return;\n    let v = c.value !== \"\" ? 0 : 1;\n    c.value += g.toLowerCase();\n    let S = (u.value !== null ? l.value.slice(u.value + v).concat(l.value.slice(0, u.value + v)) : l.value).find((k) => k.dataRef.textValue.startsWith(c.value) && !k.dataRef.disabled), w = S ? l.value.indexOf(S) : -1;\n    w === -1 || w === u.value || (u.value = w, d.value = 1);\n  }, clearSearch() {\n    t.disabled || i.value !== 1 && c.value !== \"\" && (c.value = \"\");\n  }, registerOption(g, v) {\n    let S = f((w) => [...w, { id: g, dataRef: v }]);\n    l.value = S.options, u.value = S.activeOptionIndex;\n  }, unregisterOption(g) {\n    let v = f((S) => {\n      let w = S.findIndex((k) => k.id === g);\n      return w !== -1 && S.splice(w, 1), S;\n    });\n    l.value = v.options, u.value = v.activeOptionIndex, d.value = 1;\n  }, theirOnChange(g) {\n    t.disabled || O(g);\n  }, select(g) {\n    t.disabled || O(Tt(h.value, { 0: () => g, 1: () => {\n      let v = Oe(y.value.value).slice(), S = Oe(g), w = v.findIndex((k) => y.compare(S, Oe(k)));\n      return w === -1 ? v.push(S) : v.splice(w, 1), v;\n    } }));\n  } };\n  SS([o, a], (g, v) => {\n    var S;\n    y.closeListbox(), bS(v, NO.Loose) || (g.preventDefault(), (S = pe(o)) == null || S.focus());\n  }, j(() => i.value === 0)), _n(WS, y), PS(j(() => Tt(i.value, { 0: In.Open, 1: In.Closed })));\n  let b = j(() => {\n    var g;\n    return (g = pe(o)) == null ? void 0 : g.closest(\"form\");\n  });\n  return et(() => {\n    ht([b], () => {\n      if (!b.value || t.defaultValue === void 0)\n        return;\n      function g() {\n        y.theirOnChange(t.defaultValue);\n      }\n      return b.value.addEventListener(\"reset\", g), () => {\n        var v;\n        (v = b.value) == null || v.removeEventListener(\"reset\", g);\n      };\n    }, { immediate: !0 });\n  }), () => {\n    let { name: g, modelValue: v, disabled: S, form: w, ...k } = t, _ = { open: i.value === 0, disabled: S, value: m.value };\n    return kt(Pe, [...g != null && m.value != null ? _S({ [g]: m.value }).map(([T, C]) => kt(Vo, VQ({ features: Zo.Hidden, key: T, as: \"input\", type: \"hidden\", hidden: !0, readOnly: !0, form: w, disabled: S, name: T, value: C }))) : [], Et({ ourProps: {}, theirProps: { ...n, ...ZO(k, [\"defaultValue\", \"onUpdate:modelValue\", \"horizontal\", \"multiple\", \"by\"]) }, slot: _, slots: e, attrs: n, name: \"Listbox\" })]);\n  };\n} }), $C = /* @__PURE__ */ le({ name: \"ListboxButton\", props: { as: { type: [Object, String], default: \"button\" }, id: { type: String, default: null } }, setup(t, { attrs: e, slots: n, expose: r }) {\n  var i;\n  let s = (i = t.id) != null ? i : `headlessui-listbox-button-${mr()}`, o = Ad(\"ListboxButton\");\n  r({ el: o.buttonRef, $el: o.buttonRef });\n  function a(d) {\n    switch (d.key) {\n      case Xe.Space:\n      case Xe.Enter:\n      case Xe.ArrowDown:\n        d.preventDefault(), o.openListbox(), Pn(() => {\n          var f;\n          (f = pe(o.optionsRef)) == null || f.focus({ preventScroll: !0 }), o.value.value || o.goToOption(hn.First);\n        });\n        break;\n      case Xe.ArrowUp:\n        d.preventDefault(), o.openListbox(), Pn(() => {\n          var f;\n          (f = pe(o.optionsRef)) == null || f.focus({ preventScroll: !0 }), o.value.value || o.goToOption(hn.Last);\n        });\n        break;\n    }\n  }\n  function l(d) {\n    switch (d.key) {\n      case Xe.Space:\n        d.preventDefault();\n        break;\n    }\n  }\n  function c(d) {\n    o.disabled.value || (o.listboxState.value === 0 ? (o.closeListbox(), Pn(() => {\n      var f;\n      return (f = pe(o.buttonRef)) == null ? void 0 : f.focus({ preventScroll: !0 });\n    })) : (d.preventDefault(), o.openListbox(), TC(() => {\n      var f;\n      return (f = pe(o.optionsRef)) == null ? void 0 : f.focus({ preventScroll: !0 });\n    })));\n  }\n  let u = DO(j(() => ({ as: t.as, type: e.type })), o.buttonRef);\n  return () => {\n    var d, f;\n    let h = { open: o.listboxState.value === 0, disabled: o.disabled.value, value: o.value.value }, { ...p } = t, O = { ref: o.buttonRef, id: s, type: u.value, \"aria-haspopup\": \"listbox\", \"aria-controls\": (d = pe(o.optionsRef)) == null ? void 0 : d.id, \"aria-expanded\": o.listboxState.value === 0, \"aria-labelledby\": o.labelRef.value ? [(f = pe(o.labelRef)) == null ? void 0 : f.id, s].join(\" \") : void 0, disabled: o.disabled.value === !0 ? !0 : void 0, onKeydown: a, onKeyup: l, onClick: c };\n    return Et({ ourProps: O, theirProps: p, slot: h, attrs: e, slots: n, name: \"ListboxButton\" });\n  };\n} }), QC = /* @__PURE__ */ le({ name: \"ListboxOptions\", props: { as: { type: [Object, String], default: \"ul\" }, static: { type: Boolean, default: !1 }, unmount: { type: Boolean, default: !0 }, id: { type: String, default: null } }, setup(t, { attrs: e, slots: n, expose: r }) {\n  var i;\n  let s = (i = t.id) != null ? i : `headlessui-listbox-options-${mr()}`, o = Ad(\"ListboxOptions\"), a = G(null);\n  r({ el: o.optionsRef, $el: o.optionsRef });\n  function l(d) {\n    switch (a.value && clearTimeout(a.value), d.key) {\n      case Xe.Space:\n        if (o.searchQuery.value !== \"\")\n          return d.preventDefault(), d.stopPropagation(), o.search(d.key);\n      case Xe.Enter:\n        if (d.preventDefault(), d.stopPropagation(), o.activeOptionIndex.value !== null) {\n          let f = o.options.value[o.activeOptionIndex.value];\n          o.select(f.dataRef.value);\n        }\n        o.mode.value === 0 && (o.closeListbox(), Pn(() => {\n          var f;\n          return (f = pe(o.buttonRef)) == null ? void 0 : f.focus({ preventScroll: !0 });\n        }));\n        break;\n      case Tt(o.orientation.value, { vertical: Xe.ArrowDown, horizontal: Xe.ArrowRight }):\n        return d.preventDefault(), d.stopPropagation(), o.goToOption(hn.Next);\n      case Tt(o.orientation.value, { vertical: Xe.ArrowUp, horizontal: Xe.ArrowLeft }):\n        return d.preventDefault(), d.stopPropagation(), o.goToOption(hn.Previous);\n      case Xe.Home:\n      case Xe.PageUp:\n        return d.preventDefault(), d.stopPropagation(), o.goToOption(hn.First);\n      case Xe.End:\n      case Xe.PageDown:\n        return d.preventDefault(), d.stopPropagation(), o.goToOption(hn.Last);\n      case Xe.Escape:\n        d.preventDefault(), d.stopPropagation(), o.closeListbox(), Pn(() => {\n          var f;\n          return (f = pe(o.buttonRef)) == null ? void 0 : f.focus({ preventScroll: !0 });\n        });\n        break;\n      case Xe.Tab:\n        d.preventDefault(), d.stopPropagation();\n        break;\n      default:\n        d.key.length === 1 && (o.search(d.key), a.value = setTimeout(() => o.clearSearch(), 350));\n        break;\n    }\n  }\n  let c = VO(), u = j(() => c !== null ? (c.value & In.Open) === In.Open : o.listboxState.value === 0);\n  return () => {\n    var d, f;\n    let h = { open: o.listboxState.value === 0 }, { ...p } = t, O = { \"aria-activedescendant\": o.activeOptionIndex.value === null || (d = o.options.value[o.activeOptionIndex.value]) == null ? void 0 : d.id, \"aria-multiselectable\": o.mode.value === 1 ? !0 : void 0, \"aria-labelledby\": (f = pe(o.buttonRef)) == null ? void 0 : f.id, \"aria-orientation\": o.orientation.value, id: s, onKeydown: l, role: \"listbox\", tabIndex: 0, ref: o.optionsRef };\n    return Et({ ourProps: O, theirProps: p, slot: h, attrs: e, slots: n, features: ci.RenderStrategy | ci.Static, visible: u.value, name: \"ListboxOptions\" });\n  };\n} }), CC = /* @__PURE__ */ le({ name: \"ListboxOption\", props: { as: { type: [Object, String], default: \"li\" }, value: { type: [Object, String, Number, Boolean] }, disabled: { type: Boolean, default: !1 }, id: { type: String, default: null } }, setup(t, { slots: e, attrs: n, expose: r }) {\n  var i;\n  let s = (i = t.id) != null ? i : `headlessui-listbox-option-${mr()}`, o = Ad(\"ListboxOption\"), a = G(null);\n  r({ el: a, $el: a });\n  let l = j(() => o.activeOptionIndex.value !== null ? o.options.value[o.activeOptionIndex.value].id === s : !1), c = j(() => Tt(o.mode.value, { 0: () => o.compare(Oe(o.value.value), Oe(t.value)), 1: () => Oe(o.value.value).some((g) => o.compare(Oe(g), Oe(t.value))) })), u = j(() => Tt(o.mode.value, { 1: () => {\n    var g;\n    let v = Oe(o.value.value);\n    return ((g = o.options.value.find((S) => v.some((w) => o.compare(Oe(w), Oe(S.dataRef.value))))) == null ? void 0 : g.id) === s;\n  }, 0: () => c.value })), d = wC(a), f = j(() => ({ disabled: t.disabled, value: t.value, get textValue() {\n    return d();\n  }, domRef: a }));\n  et(() => o.registerOption(s, f)), jt(() => o.unregisterOption(s)), et(() => {\n    ht([o.listboxState, c], () => {\n      o.listboxState.value === 0 && c.value && Tt(o.mode.value, { 1: () => {\n        u.value && o.goToOption(hn.Specific, s);\n      }, 0: () => {\n        o.goToOption(hn.Specific, s);\n      } });\n    }, { immediate: !0 });\n  }), Bn(() => {\n    o.listboxState.value === 0 && l.value && o.activationTrigger.value !== 0 && Pn(() => {\n      var g, v;\n      return (v = (g = pe(a)) == null ? void 0 : g.scrollIntoView) == null ? void 0 : v.call(g, { block: \"nearest\" });\n    });\n  });\n  function h(g) {\n    if (t.disabled)\n      return g.preventDefault();\n    o.select(t.value), o.mode.value === 0 && (o.closeListbox(), Pn(() => {\n      var v;\n      return (v = pe(o.buttonRef)) == null ? void 0 : v.focus({ preventScroll: !0 });\n    }));\n  }\n  function p() {\n    if (t.disabled)\n      return o.goToOption(hn.Nothing);\n    o.goToOption(hn.Specific, s);\n  }\n  let O = DQ();\n  function m(g) {\n    O.update(g);\n  }\n  function y(g) {\n    O.wasMoved(g) && (t.disabled || l.value || o.goToOption(hn.Specific, s, 0));\n  }\n  function b(g) {\n    O.wasMoved(g) && (t.disabled || l.value && o.goToOption(hn.Nothing));\n  }\n  return () => {\n    let { disabled: g } = t, v = { active: l.value, selected: c.value, disabled: g }, { value: S, disabled: w, ...k } = t, _ = { id: s, ref: a, role: \"option\", tabIndex: g === !0 ? void 0 : -1, \"aria-disabled\": g === !0 ? !0 : void 0, \"aria-selected\": c.value, disabled: void 0, onClick: h, onFocus: p, onPointerenter: m, onMouseenter: m, onPointermove: y, onMousemove: y, onPointerleave: b, onMouseleave: b };\n    return Et({ ourProps: _, theirProps: k, slot: v, attrs: n, slots: e, name: \"ListboxOption\" });\n  };\n} }), AC = /* @__PURE__ */ le({ props: { onFocus: { type: Function, required: !0 } }, setup(t) {\n  let e = G(!0);\n  return () => e.value ? kt(Vo, { as: \"button\", type: \"button\", features: Zo.Focusable, onFocus(n) {\n    n.preventDefault();\n    let r, i = 50;\n    function s() {\n      var o;\n      if (i-- <= 0) {\n        r && cancelAnimationFrame(r);\n        return;\n      }\n      if ((o = t.onFocus) != null && o.call(t)) {\n        e.value = !1, cancelAnimationFrame(r);\n        return;\n      }\n      r = requestAnimationFrame(s);\n    }\n    r = requestAnimationFrame(s);\n  } }) : null;\n} });\nvar RC = ((t) => (t[t.Forwards = 0] = \"Forwards\", t[t.Backwards = 1] = \"Backwards\", t))(RC || {}), NC = ((t) => (t[t.Less = -1] = \"Less\", t[t.Equal = 0] = \"Equal\", t[t.Greater = 1] = \"Greater\", t))(NC || {});\nlet MS = Symbol(\"TabsContext\");\nfunction Bl(t) {\n  let e = Pt(MS, null);\n  if (e === null) {\n    let n = new Error(`<${t} /> is missing a parent <TabGroup /> component.`);\n    throw Error.captureStackTrace && Error.captureStackTrace(n, Bl), n;\n  }\n  return e;\n}\nlet XO = Symbol(\"TabsSSRContext\"), DC = /* @__PURE__ */ le({ name: \"TabGroup\", emits: { change: (t) => !0 }, props: { as: { type: [Object, String], default: \"template\" }, selectedIndex: { type: [Number], default: null }, defaultIndex: { type: [Number], default: 0 }, vertical: { type: [Boolean], default: !1 }, manual: { type: [Boolean], default: !1 } }, inheritAttrs: !1, setup(t, { slots: e, attrs: n, emit: r }) {\n  var i;\n  let s = G((i = t.selectedIndex) != null ? i : t.defaultIndex), o = G([]), a = G([]), l = j(() => t.selectedIndex !== null), c = j(() => l.value ? t.selectedIndex : s.value);\n  function u(O) {\n    var m;\n    let y = vs(d.tabs.value, pe), b = vs(d.panels.value, pe), g = y.filter((v) => {\n      var S;\n      return !((S = pe(v)) != null && S.hasAttribute(\"disabled\"));\n    });\n    if (O < 0 || O > y.length - 1) {\n      let v = Tt(s.value === null ? 0 : Math.sign(O - s.value), { [-1]: () => 1, 0: () => Tt(Math.sign(O), { [-1]: () => 0, 0: () => 0, 1: () => 1 }), 1: () => 0 }), S = Tt(v, { 0: () => y.indexOf(g[0]), 1: () => y.indexOf(g[g.length - 1]) });\n      S !== -1 && (s.value = S), d.tabs.value = y, d.panels.value = b;\n    } else {\n      let v = y.slice(0, O), S = [...y.slice(O), ...v].find((k) => g.includes(k));\n      if (!S)\n        return;\n      let w = (m = y.indexOf(S)) != null ? m : d.selectedIndex.value;\n      w === -1 && (w = d.selectedIndex.value), s.value = w, d.tabs.value = y, d.panels.value = b;\n    }\n  }\n  let d = { selectedIndex: j(() => {\n    var O, m;\n    return (m = (O = s.value) != null ? O : t.defaultIndex) != null ? m : null;\n  }), orientation: j(() => t.vertical ? \"vertical\" : \"horizontal\"), activation: j(() => t.manual ? \"manual\" : \"auto\"), tabs: o, panels: a, setSelectedIndex(O) {\n    c.value !== O && r(\"change\", O), l.value || u(O);\n  }, registerTab(O) {\n    var m;\n    if (o.value.includes(O))\n      return;\n    let y = o.value[s.value];\n    if (o.value.push(O), o.value = vs(o.value, pe), !l.value) {\n      let b = (m = o.value.indexOf(y)) != null ? m : s.value;\n      b !== -1 && (s.value = b);\n    }\n  }, unregisterTab(O) {\n    let m = o.value.indexOf(O);\n    m !== -1 && o.value.splice(m, 1);\n  }, registerPanel(O) {\n    a.value.includes(O) || (a.value.push(O), a.value = vs(a.value, pe));\n  }, unregisterPanel(O) {\n    let m = a.value.indexOf(O);\n    m !== -1 && a.value.splice(m, 1);\n  } };\n  _n(MS, d);\n  let f = G({ tabs: [], panels: [] }), h = G(!1);\n  et(() => {\n    h.value = !0;\n  }), _n(XO, j(() => h.value ? null : f.value));\n  let p = j(() => t.selectedIndex);\n  return et(() => {\n    ht([p], () => {\n      var O;\n      return u((O = t.selectedIndex) != null ? O : t.defaultIndex);\n    }, { immediate: !0 });\n  }), Bn(() => {\n    if (!l.value || c.value == null || d.tabs.value.length <= 0)\n      return;\n    let O = vs(d.tabs.value, pe);\n    O.some((m, y) => pe(d.tabs.value[y]) !== pe(m)) && d.setSelectedIndex(O.findIndex((m) => pe(m) === pe(d.tabs.value[c.value])));\n  }), () => {\n    let O = { selectedIndex: s.value };\n    return kt(Pe, [o.value.length <= 0 && kt(AC, { onFocus: () => {\n      for (let m of o.value) {\n        let y = pe(m);\n        if ((y == null ? void 0 : y.tabIndex) === 0)\n          return y.focus(), !0;\n      }\n      return !1;\n    } }), Et({ theirProps: { ...n, ...ZO(t, [\"selectedIndex\", \"defaultIndex\", \"manual\", \"vertical\", \"onChange\"]) }, ourProps: {}, slot: O, slots: e, attrs: n, name: \"TabGroup\" })]);\n  };\n} }), ZC = /* @__PURE__ */ le({ name: \"TabList\", props: { as: { type: [Object, String], default: \"div\" } }, setup(t, { attrs: e, slots: n }) {\n  let r = Bl(\"TabList\");\n  return () => {\n    let i = { selectedIndex: r.selectedIndex.value }, s = { role: \"tablist\", \"aria-orientation\": r.orientation.value };\n    return Et({ ourProps: s, theirProps: t, slot: i, attrs: e, slots: n, name: \"TabList\" });\n  };\n} }), cb = /* @__PURE__ */ le({ name: \"Tab\", props: { as: { type: [Object, String], default: \"button\" }, disabled: { type: [Boolean], default: !1 }, id: { type: String, default: null } }, setup(t, { attrs: e, slots: n, expose: r }) {\n  var i;\n  let s = (i = t.id) != null ? i : `headlessui-tabs-tab-${mr()}`, o = Bl(\"Tab\"), a = G(null);\n  r({ el: a, $el: a }), et(() => o.registerTab(a)), jt(() => o.unregisterTab(a));\n  let l = Pt(XO), c = j(() => {\n    if (l.value) {\n      let b = l.value.tabs.indexOf(s);\n      return b === -1 ? l.value.tabs.push(s) - 1 : b;\n    }\n    return -1;\n  }), u = j(() => {\n    let b = o.tabs.value.indexOf(a);\n    return b === -1 ? c.value : b;\n  }), d = j(() => u.value === o.selectedIndex.value);\n  function f(b) {\n    var g;\n    let v = b();\n    if (v === ho.Success && o.activation.value === \"auto\") {\n      let S = (g = to(a)) == null ? void 0 : g.activeElement, w = o.tabs.value.findIndex((k) => pe(k) === S);\n      w !== -1 && o.setSelectedIndex(w);\n    }\n    return v;\n  }\n  function h(b) {\n    let g = o.tabs.value.map((v) => pe(v)).filter(Boolean);\n    if (b.key === Xe.Space || b.key === Xe.Enter) {\n      b.preventDefault(), b.stopPropagation(), o.setSelectedIndex(u.value);\n      return;\n    }\n    switch (b.key) {\n      case Xe.Home:\n      case Xe.PageUp:\n        return b.preventDefault(), b.stopPropagation(), f(() => Er(g, Wt.First));\n      case Xe.End:\n      case Xe.PageDown:\n        return b.preventDefault(), b.stopPropagation(), f(() => Er(g, Wt.Last));\n    }\n    if (f(() => Tt(o.orientation.value, { vertical() {\n      return b.key === Xe.ArrowUp ? Er(g, Wt.Previous | Wt.WrapAround) : b.key === Xe.ArrowDown ? Er(g, Wt.Next | Wt.WrapAround) : ho.Error;\n    }, horizontal() {\n      return b.key === Xe.ArrowLeft ? Er(g, Wt.Previous | Wt.WrapAround) : b.key === Xe.ArrowRight ? Er(g, Wt.Next | Wt.WrapAround) : ho.Error;\n    } })) === ho.Success)\n      return b.preventDefault();\n  }\n  let p = G(!1);\n  function O() {\n    var b;\n    p.value || (p.value = !0, !t.disabled && ((b = pe(a)) == null || b.focus({ preventScroll: !0 }), o.setSelectedIndex(u.value), Cd(() => {\n      p.value = !1;\n    })));\n  }\n  function m(b) {\n    b.preventDefault();\n  }\n  let y = DO(j(() => ({ as: t.as, type: e.type })), a);\n  return () => {\n    var b, g;\n    let v = { selected: d.value, disabled: (b = t.disabled) != null ? b : !1 }, { ...S } = t, w = { ref: a, onKeydown: h, onMousedown: m, onClick: O, id: s, role: \"tab\", type: y.value, \"aria-controls\": (g = pe(o.panels.value[u.value])) == null ? void 0 : g.id, \"aria-selected\": d.value, tabIndex: d.value ? 0 : -1, disabled: t.disabled ? !0 : void 0 };\n    return Et({ ourProps: w, theirProps: S, slot: v, attrs: e, slots: n, name: \"Tab\" });\n  };\n} }), VC = /* @__PURE__ */ le({ name: \"TabPanels\", props: { as: { type: [Object, String], default: \"div\" } }, setup(t, { slots: e, attrs: n }) {\n  let r = Bl(\"TabPanels\");\n  return () => {\n    let i = { selectedIndex: r.selectedIndex.value };\n    return Et({ theirProps: t, ourProps: {}, slot: i, attrs: n, slots: e, name: \"TabPanels\" });\n  };\n} }), ub = /* @__PURE__ */ le({ name: \"TabPanel\", props: { as: { type: [Object, String], default: \"div\" }, static: { type: Boolean, default: !1 }, unmount: { type: Boolean, default: !0 }, id: { type: String, default: null }, tabIndex: { type: Number, default: 0 } }, setup(t, { attrs: e, slots: n, expose: r }) {\n  var i;\n  let s = (i = t.id) != null ? i : `headlessui-tabs-panel-${mr()}`, o = Bl(\"TabPanel\"), a = G(null);\n  r({ el: a, $el: a }), et(() => o.registerPanel(a)), jt(() => o.unregisterPanel(a));\n  let l = Pt(XO), c = j(() => {\n    if (l.value) {\n      let f = l.value.panels.indexOf(s);\n      return f === -1 ? l.value.panels.push(s) - 1 : f;\n    }\n    return -1;\n  }), u = j(() => {\n    let f = o.panels.value.indexOf(a);\n    return f === -1 ? c.value : f;\n  }), d = j(() => u.value === o.selectedIndex.value);\n  return () => {\n    var f;\n    let h = { selected: d.value }, { tabIndex: p, ...O } = t, m = { ref: a, id: s, role: \"tabpanel\", \"aria-labelledby\": (f = pe(o.tabs.value[u.value])) == null ? void 0 : f.id, tabIndex: d.value ? p : -1 };\n    return !d.value && t.unmount && !t.static ? kt(Vo, { as: \"span\", \"aria-hidden\": !0, ...m }) : Et({ ourProps: m, theirProps: O, slot: h, attrs: e, slots: n, features: ci.Static | ci.RenderStrategy, visible: d.value, name: \"TabPanel\" });\n  };\n} });\nfunction XS(t) {\n  return Rl() ? (tO(t), !0) : !1;\n}\nfunction ll(t) {\n  return typeof t == \"function\" ? t() : R(t);\n}\nconst IC = typeof window < \"u\" && typeof document < \"u\";\ntypeof WorkerGlobalScope < \"u\" && globalThis instanceof WorkerGlobalScope;\nconst WC = Object.prototype.toString, MC = (t) => WC.call(t) === \"[object Object]\", jS = () => {\n};\nfunction Nh(t, e, n) {\n  const r = ht(\n    t,\n    (i, s, o) => {\n      i && (n != null && n.once && Pn(() => r()), e(i, s, o));\n    },\n    {\n      ...n,\n      once: !1\n    }\n  );\n  return r;\n}\nfunction XC(t) {\n  var e;\n  const n = ll(t);\n  return (e = n == null ? void 0 : n.$el) != null ? e : n;\n}\nconst jO = IC ? window : void 0;\nfunction Sc(...t) {\n  let e, n, r, i;\n  if (typeof t[0] == \"string\" || Array.isArray(t[0]) ? ([n, r, i] = t, e = jO) : [e, n, r, i] = t, !e)\n    return jS;\n  Array.isArray(n) || (n = [n]), Array.isArray(r) || (r = [r]);\n  const s = [], o = () => {\n    s.forEach((u) => u()), s.length = 0;\n  }, a = (u, d, f, h) => (u.addEventListener(d, f, h), () => u.removeEventListener(d, f, h)), l = ht(\n    () => [XC(e), ll(i)],\n    ([u, d]) => {\n      if (o(), !u)\n        return;\n      const f = MC(d) ? { ...d } : d;\n      s.push(\n        ...n.flatMap((h) => r.map((p) => a(u, h, p, f)))\n      );\n    },\n    { immediate: !0, flush: \"post\" }\n  ), c = () => {\n    l(), o();\n  };\n  return XS(c), c;\n}\nfunction jC() {\n  const t = G(!1), e = ir();\n  return e && et(() => {\n    t.value = !0;\n  }, e), t;\n}\nfunction BC(t) {\n  const e = jC();\n  return j(() => (e.value, !!t()));\n}\nfunction LC(t, e = {}) {\n  const { window: n = jO } = e, r = BC(() => n && \"matchMedia\" in n && typeof n.matchMedia == \"function\");\n  let i;\n  const s = G(!1), o = (c) => {\n    s.value = c.matches;\n  }, a = () => {\n    i && (\"removeEventListener\" in i ? i.removeEventListener(\"change\", o) : i.removeListener(o));\n  }, l = Bn(() => {\n    r.value && (a(), i = n.matchMedia(ll(t)), \"addEventListener\" in i ? i.addEventListener(\"change\", o) : i.addListener(o), s.value = i.matches);\n  });\n  return XS(() => {\n    l(), a(), i = void 0;\n  }), s;\n}\nconst ga = /* @__PURE__ */ new Map();\nfunction UC(t) {\n  const e = Rl();\n  function n(a) {\n    var l;\n    const c = ga.get(t) || /* @__PURE__ */ new Set();\n    c.add(a), ga.set(t, c);\n    const u = () => i(a);\n    return (l = e == null ? void 0 : e.cleanups) == null || l.push(u), u;\n  }\n  function r(a) {\n    function l(...c) {\n      i(l), a(...c);\n    }\n    return n(l);\n  }\n  function i(a) {\n    const l = ga.get(t);\n    l && (l.delete(a), l.size || s());\n  }\n  function s() {\n    ga.delete(t);\n  }\n  function o(a, l) {\n    var c;\n    (c = ga.get(t)) == null || c.forEach((u) => u(a, l));\n  }\n  return { on: n, once: r, off: i, emit: o, reset: s };\n}\nconst qC = {\n  ctrl: \"control\",\n  command: \"meta\",\n  cmd: \"meta\",\n  option: \"alt\",\n  up: \"arrowup\",\n  down: \"arrowdown\",\n  left: \"arrowleft\",\n  right: \"arrowright\"\n};\nfunction BS(t = {}) {\n  const {\n    reactive: e = !1,\n    target: n = jO,\n    aliasMap: r = qC,\n    passive: i = !0,\n    onEventFired: s = jS\n  } = t, o = Xn(/* @__PURE__ */ new Set()), a = {\n    toJSON() {\n      return {};\n    },\n    current: o\n  }, l = e ? Xn(a) : a, c = /* @__PURE__ */ new Set(), u = /* @__PURE__ */ new Set();\n  function d(O, m) {\n    O in l && (e ? l[O] = m : l[O].value = m);\n  }\n  function f() {\n    o.clear();\n    for (const O of u)\n      d(O, !1);\n  }\n  function h(O, m) {\n    var y, b;\n    const g = (y = O.key) == null ? void 0 : y.toLowerCase(), S = [(b = O.code) == null ? void 0 : b.toLowerCase(), g].filter(Boolean);\n    g && (m ? o.add(g) : o.delete(g));\n    for (const w of S)\n      u.add(w), d(w, m);\n    g === \"meta\" && !m ? (c.forEach((w) => {\n      o.delete(w), d(w, !1);\n    }), c.clear()) : typeof O.getModifierState == \"function\" && O.getModifierState(\"Meta\") && m && [...o, ...S].forEach((w) => c.add(w));\n  }\n  Sc(n, \"keydown\", (O) => (h(O, !0), s(O)), { passive: i }), Sc(n, \"keyup\", (O) => (h(O, !1), s(O)), { passive: i }), Sc(\"blur\", f, { passive: !0 }), Sc(\"focus\", f, { passive: !0 });\n  const p = new Proxy(\n    l,\n    {\n      get(O, m, y) {\n        if (typeof m != \"string\")\n          return Reflect.get(O, m, y);\n        if (m = m.toLowerCase(), m in r && (m = r[m]), !(m in l))\n          if (/[+_-]/.test(m)) {\n            const g = m.split(/[+_-]/g).map((v) => v.trim());\n            l[m] = j(() => g.every((v) => ll(p[v])));\n          } else\n            l[m] = G(!1);\n        const b = Reflect.get(O, m, y);\n        return e ? ll(b) : b;\n      }\n    }\n  );\n  return p;\n}\nfunction LS(t, e) {\n  return function() {\n    return t.apply(e, arguments);\n  };\n}\nconst { toString: YC } = Object.prototype, { getPrototypeOf: BO } = Object, Rd = /* @__PURE__ */ ((t) => (e) => {\n  const n = YC.call(e);\n  return t[n] || (t[n] = n.slice(8, -1).toLowerCase());\n})(/* @__PURE__ */ Object.create(null)), Lr = (t) => (t = t.toLowerCase(), (e) => Rd(e) === t), Nd = (t) => (e) => typeof e === t, { isArray: na } = Array, cl = Nd(\"undefined\");\nfunction zC(t) {\n  return t !== null && !cl(t) && t.constructor !== null && !cl(t.constructor) && er(t.constructor.isBuffer) && t.constructor.isBuffer(t);\n}\nconst US = Lr(\"ArrayBuffer\");\nfunction HC(t) {\n  let e;\n  return typeof ArrayBuffer < \"u\" && ArrayBuffer.isView ? e = ArrayBuffer.isView(t) : e = t && t.buffer && US(t.buffer), e;\n}\nconst FC = Nd(\"string\"), er = Nd(\"function\"), qS = Nd(\"number\"), Dd = (t) => t !== null && typeof t == \"object\", GC = (t) => t === !0 || t === !1, Kc = (t) => {\n  if (Rd(t) !== \"object\")\n    return !1;\n  const e = BO(t);\n  return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t);\n}, KC = Lr(\"Date\"), JC = Lr(\"File\"), eA = Lr(\"Blob\"), tA = Lr(\"FileList\"), nA = (t) => Dd(t) && er(t.pipe), rA = (t) => {\n  let e;\n  return t && (typeof FormData == \"function\" && t instanceof FormData || er(t.append) && ((e = Rd(t)) === \"formdata\" || // detect form-data instance\n  e === \"object\" && er(t.toString) && t.toString() === \"[object FormData]\"));\n}, iA = Lr(\"URLSearchParams\"), sA = (t) => t.trim ? t.trim() : t.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, \"\");\nfunction Ll(t, e, { allOwnKeys: n = !1 } = {}) {\n  if (t === null || typeof t > \"u\")\n    return;\n  let r, i;\n  if (typeof t != \"object\" && (t = [t]), na(t))\n    for (r = 0, i = t.length; r < i; r++)\n      e.call(null, t[r], r, t);\n  else {\n    const s = n ? Object.getOwnPropertyNames(t) : Object.keys(t), o = s.length;\n    let a;\n    for (r = 0; r < o; r++)\n      a = s[r], e.call(null, t[a], a, t);\n  }\n}\nfunction YS(t, e) {\n  e = e.toLowerCase();\n  const n = Object.keys(t);\n  let r = n.length, i;\n  for (; r-- > 0; )\n    if (i = n[r], e === i.toLowerCase())\n      return i;\n  return null;\n}\nconst zS = typeof globalThis < \"u\" ? globalThis : typeof self < \"u\" ? self : typeof window < \"u\" ? window : global, HS = (t) => !cl(t) && t !== zS;\nfunction Dh() {\n  const { caseless: t } = HS(this) && this || {}, e = {}, n = (r, i) => {\n    const s = t && YS(e, i) || i;\n    Kc(e[s]) && Kc(r) ? e[s] = Dh(e[s], r) : Kc(r) ? e[s] = Dh({}, r) : na(r) ? e[s] = r.slice() : e[s] = r;\n  };\n  for (let r = 0, i = arguments.length; r < i; r++)\n    arguments[r] && Ll(arguments[r], n);\n  return e;\n}\nconst oA = (t, e, n, { allOwnKeys: r } = {}) => (Ll(e, (i, s) => {\n  n && er(i) ? t[s] = LS(i, n) : t[s] = i;\n}, { allOwnKeys: r }), t), aA = (t) => (t.charCodeAt(0) === 65279 && (t = t.slice(1)), t), lA = (t, e, n, r) => {\n  t.prototype = Object.create(e.prototype, r), t.prototype.constructor = t, Object.defineProperty(t, \"super\", {\n    value: e.prototype\n  }), n && Object.assign(t.prototype, n);\n}, cA = (t, e, n, r) => {\n  let i, s, o;\n  const a = {};\n  if (e = e || {}, t == null)\n    return e;\n  do {\n    for (i = Object.getOwnPropertyNames(t), s = i.length; s-- > 0; )\n      o = i[s], (!r || r(o, t, e)) && !a[o] && (e[o] = t[o], a[o] = !0);\n    t = n !== !1 && BO(t);\n  } while (t && (!n || n(t, e)) && t !== Object.prototype);\n  return e;\n}, uA = (t, e, n) => {\n  t = String(t), (n === void 0 || n > t.length) && (n = t.length), n -= e.length;\n  const r = t.indexOf(e, n);\n  return r !== -1 && r === n;\n}, dA = (t) => {\n  if (!t)\n    return null;\n  if (na(t))\n    return t;\n  let e = t.length;\n  if (!qS(e))\n    return null;\n  const n = new Array(e);\n  for (; e-- > 0; )\n    n[e] = t[e];\n  return n;\n}, fA = /* @__PURE__ */ ((t) => (e) => t && e instanceof t)(typeof Uint8Array < \"u\" && BO(Uint8Array)), hA = (t, e) => {\n  const r = (t && t[Symbol.iterator]).call(t);\n  let i;\n  for (; (i = r.next()) && !i.done; ) {\n    const s = i.value;\n    e.call(t, s[0], s[1]);\n  }\n}, pA = (t, e) => {\n  let n;\n  const r = [];\n  for (; (n = t.exec(e)) !== null; )\n    r.push(n);\n  return r;\n}, OA = Lr(\"HTMLFormElement\"), gA = (t) => t.toLowerCase().replace(\n  /[-_\\s]([a-z\\d])(\\w*)/g,\n  function(n, r, i) {\n    return r.toUpperCase() + i;\n  }\n), db = (({ hasOwnProperty: t }) => (e, n) => t.call(e, n))(Object.prototype), mA = Lr(\"RegExp\"), FS = (t, e) => {\n  const n = Object.getOwnPropertyDescriptors(t), r = {};\n  Ll(n, (i, s) => {\n    let o;\n    (o = e(i, s, t)) !== !1 && (r[s] = o || i);\n  }), Object.defineProperties(t, r);\n}, bA = (t) => {\n  FS(t, (e, n) => {\n    if (er(t) && [\"arguments\", \"caller\", \"callee\"].indexOf(n) !== -1)\n      return !1;\n    const r = t[n];\n    if (er(r)) {\n      if (e.enumerable = !1, \"writable\" in e) {\n        e.writable = !1;\n        return;\n      }\n      e.set || (e.set = () => {\n        throw Error(\"Can not rewrite read-only method '\" + n + \"'\");\n      });\n    }\n  });\n}, vA = (t, e) => {\n  const n = {}, r = (i) => {\n    i.forEach((s) => {\n      n[s] = !0;\n    });\n  };\n  return na(t) ? r(t) : r(String(t).split(e)), n;\n}, yA = () => {\n}, SA = (t, e) => (t = +t, Number.isFinite(t) ? t : e), bf = \"abcdefghijklmnopqrstuvwxyz\", fb = \"0123456789\", GS = {\n  DIGIT: fb,\n  ALPHA: bf,\n  ALPHA_DIGIT: bf + bf.toUpperCase() + fb\n}, wA = (t = 16, e = GS.ALPHA_DIGIT) => {\n  let n = \"\";\n  const { length: r } = e;\n  for (; t--; )\n    n += e[Math.random() * r | 0];\n  return n;\n};\nfunction kA(t) {\n  return !!(t && er(t.append) && t[Symbol.toStringTag] === \"FormData\" && t[Symbol.iterator]);\n}\nconst xA = (t) => {\n  const e = new Array(10), n = (r, i) => {\n    if (Dd(r)) {\n      if (e.indexOf(r) >= 0)\n        return;\n      if (!(\"toJSON\" in r)) {\n        e[i] = r;\n        const s = na(r) ? [] : {};\n        return Ll(r, (o, a) => {\n          const l = n(o, i + 1);\n          !cl(l) && (s[a] = l);\n        }), e[i] = void 0, s;\n      }\n    }\n    return r;\n  };\n  return n(t, 0);\n}, PA = Lr(\"AsyncFunction\"), _A = (t) => t && (Dd(t) || er(t)) && er(t.then) && er(t.catch), V = {\n  isArray: na,\n  isArrayBuffer: US,\n  isBuffer: zC,\n  isFormData: rA,\n  isArrayBufferView: HC,\n  isString: FC,\n  isNumber: qS,\n  isBoolean: GC,\n  isObject: Dd,\n  isPlainObject: Kc,\n  isUndefined: cl,\n  isDate: KC,\n  isFile: JC,\n  isBlob: eA,\n  isRegExp: mA,\n  isFunction: er,\n  isStream: nA,\n  isURLSearchParams: iA,\n  isTypedArray: fA,\n  isFileList: tA,\n  forEach: Ll,\n  merge: Dh,\n  extend: oA,\n  trim: sA,\n  stripBOM: aA,\n  inherits: lA,\n  toFlatObject: cA,\n  kindOf: Rd,\n  kindOfTest: Lr,\n  endsWith: uA,\n  toArray: dA,\n  forEachEntry: hA,\n  matchAll: pA,\n  isHTMLForm: OA,\n  hasOwnProperty: db,\n  hasOwnProp: db,\n  // an alias to avoid ESLint no-prototype-builtins detection\n  reduceDescriptors: FS,\n  freezeMethods: bA,\n  toObjectSet: vA,\n  toCamelCase: gA,\n  noop: yA,\n  toFiniteNumber: SA,\n  findKey: YS,\n  global: zS,\n  isContextDefined: HS,\n  ALPHABET: GS,\n  generateString: wA,\n  isSpecCompliantForm: kA,\n  toJSONObject: xA,\n  isAsyncFn: PA,\n  isThenable: _A\n};\nfunction je(t, e, n, r, i) {\n  Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = t, this.name = \"AxiosError\", e && (this.code = e), n && (this.config = n), r && (this.request = r), i && (this.response = i);\n}\nV.inherits(je, Error, {\n  toJSON: function() {\n    return {\n      // Standard\n      message: this.message,\n      name: this.name,\n      // Microsoft\n      description: this.description,\n      number: this.number,\n      // Mozilla\n      fileName: this.fileName,\n      lineNumber: this.lineNumber,\n      columnNumber: this.columnNumber,\n      stack: this.stack,\n      // Axios\n      config: V.toJSONObject(this.config),\n      code: this.code,\n      status: this.response && this.response.status ? this.response.status : null\n    };\n  }\n});\nconst KS = je.prototype, JS = {};\n[\n  \"ERR_BAD_OPTION_VALUE\",\n  \"ERR_BAD_OPTION\",\n  \"ECONNABORTED\",\n  \"ETIMEDOUT\",\n  \"ERR_NETWORK\",\n  \"ERR_FR_TOO_MANY_REDIRECTS\",\n  \"ERR_DEPRECATED\",\n  \"ERR_BAD_RESPONSE\",\n  \"ERR_BAD_REQUEST\",\n  \"ERR_CANCELED\",\n  \"ERR_NOT_SUPPORT\",\n  \"ERR_INVALID_URL\"\n  // eslint-disable-next-line func-names\n].forEach((t) => {\n  JS[t] = { value: t };\n});\nObject.defineProperties(je, JS);\nObject.defineProperty(KS, \"isAxiosError\", { value: !0 });\nje.from = (t, e, n, r, i, s) => {\n  const o = Object.create(KS);\n  return V.toFlatObject(t, o, function(l) {\n    return l !== Error.prototype;\n  }, (a) => a !== \"isAxiosError\"), je.call(o, t.message, e, n, r, i), o.cause = t, o.name = t.name, s && Object.assign(o, s), o;\n};\nconst TA = null;\nfunction Zh(t) {\n  return V.isPlainObject(t) || V.isArray(t);\n}\nfunction ew(t) {\n  return V.endsWith(t, \"[]\") ? t.slice(0, -2) : t;\n}\nfunction hb(t, e, n) {\n  return t ? t.concat(e).map(function(i, s) {\n    return i = ew(i), !n && s ? \"[\" + i + \"]\" : i;\n  }).join(n ? \".\" : \"\") : e;\n}\nfunction EA(t) {\n  return V.isArray(t) && !t.some(Zh);\n}\nconst $A = V.toFlatObject(V, {}, null, function(e) {\n  return /^is[A-Z]/.test(e);\n});\nfunction Zd(t, e, n) {\n  if (!V.isObject(t))\n    throw new TypeError(\"target must be an object\");\n  e = e || new FormData(), n = V.toFlatObject(n, {\n    metaTokens: !0,\n    dots: !1,\n    indexes: !1\n  }, !1, function(O, m) {\n    return !V.isUndefined(m[O]);\n  });\n  const r = n.metaTokens, i = n.visitor || u, s = n.dots, o = n.indexes, l = (n.Blob || typeof Blob < \"u\" && Blob) && V.isSpecCompliantForm(e);\n  if (!V.isFunction(i))\n    throw new TypeError(\"visitor must be a function\");\n  function c(p) {\n    if (p === null)\n      return \"\";\n    if (V.isDate(p))\n      return p.toISOString();\n    if (!l && V.isBlob(p))\n      throw new je(\"Blob is not supported. Use a Buffer instead.\");\n    return V.isArrayBuffer(p) || V.isTypedArray(p) ? l && typeof Blob == \"function\" ? new Blob([p]) : Buffer.from(p) : p;\n  }\n  function u(p, O, m) {\n    let y = p;\n    if (p && !m && typeof p == \"object\") {\n      if (V.endsWith(O, \"{}\"))\n        O = r ? O : O.slice(0, -2), p = JSON.stringify(p);\n      else if (V.isArray(p) && EA(p) || (V.isFileList(p) || V.endsWith(O, \"[]\")) && (y = V.toArray(p)))\n        return O = ew(O), y.forEach(function(g, v) {\n          !(V.isUndefined(g) || g === null) && e.append(\n            // eslint-disable-next-line no-nested-ternary\n            o === !0 ? hb([O], v, s) : o === null ? O : O + \"[]\",\n            c(g)\n          );\n        }), !1;\n    }\n    return Zh(p) ? !0 : (e.append(hb(m, O, s), c(p)), !1);\n  }\n  const d = [], f = Object.assign($A, {\n    defaultVisitor: u,\n    convertValue: c,\n    isVisitable: Zh\n  });\n  function h(p, O) {\n    if (!V.isUndefined(p)) {\n      if (d.indexOf(p) !== -1)\n        throw Error(\"Circular reference detected in \" + O.join(\".\"));\n      d.push(p), V.forEach(p, function(y, b) {\n        (!(V.isUndefined(y) || y === null) && i.call(\n          e,\n          y,\n          V.isString(b) ? b.trim() : b,\n          O,\n          f\n        )) === !0 && h(y, O ? O.concat(b) : [b]);\n      }), d.pop();\n    }\n  }\n  if (!V.isObject(t))\n    throw new TypeError(\"data must be an object\");\n  return h(t), e;\n}\nfunction pb(t) {\n  const e = {\n    \"!\": \"%21\",\n    \"'\": \"%27\",\n    \"(\": \"%28\",\n    \")\": \"%29\",\n    \"~\": \"%7E\",\n    \"%20\": \"+\",\n    \"%00\": \"\\0\"\n  };\n  return encodeURIComponent(t).replace(/[!'()~]|%20|%00/g, function(r) {\n    return e[r];\n  });\n}\nfunction LO(t, e) {\n  this._pairs = [], t && Zd(t, this, e);\n}\nconst tw = LO.prototype;\ntw.append = function(e, n) {\n  this._pairs.push([e, n]);\n};\ntw.toString = function(e) {\n  const n = e ? function(r) {\n    return e.call(this, r, pb);\n  } : pb;\n  return this._pairs.map(function(i) {\n    return n(i[0]) + \"=\" + n(i[1]);\n  }, \"\").join(\"&\");\n};\nfunction QA(t) {\n  return encodeURIComponent(t).replace(/%3A/gi, \":\").replace(/%24/g, \"$\").replace(/%2C/gi, \",\").replace(/%20/g, \"+\").replace(/%5B/gi, \"[\").replace(/%5D/gi, \"]\");\n}\nfunction nw(t, e, n) {\n  if (!e)\n    return t;\n  const r = n && n.encode || QA, i = n && n.serialize;\n  let s;\n  if (i ? s = i(e, n) : s = V.isURLSearchParams(e) ? e.toString() : new LO(e, n).toString(r), s) {\n    const o = t.indexOf(\"#\");\n    o !== -1 && (t = t.slice(0, o)), t += (t.indexOf(\"?\") === -1 ? \"?\" : \"&\") + s;\n  }\n  return t;\n}\nclass Ob {\n  constructor() {\n    this.handlers = [];\n  }\n  /**\n   * Add a new interceptor to the stack\n   *\n   * @param {Function} fulfilled The function to handle `then` for a `Promise`\n   * @param {Function} rejected The function to handle `reject` for a `Promise`\n   *\n   * @return {Number} An ID used to remove interceptor later\n   */\n  use(e, n, r) {\n    return this.handlers.push({\n      fulfilled: e,\n      rejected: n,\n      synchronous: r ? r.synchronous : !1,\n      runWhen: r ? r.runWhen : null\n    }), this.handlers.length - 1;\n  }\n  /**\n   * Remove an interceptor from the stack\n   *\n   * @param {Number} id The ID that was returned by `use`\n   *\n   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise\n   */\n  eject(e) {\n    this.handlers[e] && (this.handlers[e] = null);\n  }\n  /**\n   * Clear all interceptors from the stack\n   *\n   * @returns {void}\n   */\n  clear() {\n    this.handlers && (this.handlers = []);\n  }\n  /**\n   * Iterate over all the registered interceptors\n   *\n   * This method is particularly useful for skipping over any\n   * interceptors that may have become `null` calling `eject`.\n   *\n   * @param {Function} fn The function to call for each interceptor\n   *\n   * @returns {void}\n   */\n  forEach(e) {\n    V.forEach(this.handlers, function(r) {\n      r !== null && e(r);\n    });\n  }\n}\nconst rw = {\n  silentJSONParsing: !0,\n  forcedJSONParsing: !0,\n  clarifyTimeoutError: !1\n}, CA = typeof URLSearchParams < \"u\" ? URLSearchParams : LO, AA = typeof FormData < \"u\" ? FormData : null, RA = typeof Blob < \"u\" ? Blob : null, NA = {\n  isBrowser: !0,\n  classes: {\n    URLSearchParams: CA,\n    FormData: AA,\n    Blob: RA\n  },\n  protocols: [\"http\", \"https\", \"file\", \"blob\", \"url\", \"data\"]\n}, iw = typeof window < \"u\" && typeof document < \"u\", DA = ((t) => iw && [\"ReactNative\", \"NativeScript\", \"NS\"].indexOf(t) < 0)(typeof navigator < \"u\" && navigator.product), ZA = typeof WorkerGlobalScope < \"u\" && // eslint-disable-next-line no-undef\nself instanceof WorkerGlobalScope && typeof self.importScripts == \"function\", VA = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  hasBrowserEnv: iw,\n  hasStandardBrowserEnv: DA,\n  hasStandardBrowserWebWorkerEnv: ZA\n}, Symbol.toStringTag, { value: \"Module\" })), Ar = {\n  ...VA,\n  ...NA\n};\nfunction IA(t, e) {\n  return Zd(t, new Ar.classes.URLSearchParams(), Object.assign({\n    visitor: function(n, r, i, s) {\n      return Ar.isNode && V.isBuffer(n) ? (this.append(r, n.toString(\"base64\")), !1) : s.defaultVisitor.apply(this, arguments);\n    }\n  }, e));\n}\nfunction WA(t) {\n  return V.matchAll(/\\w+|\\[(\\w*)]/g, t).map((e) => e[0] === \"[]\" ? \"\" : e[1] || e[0]);\n}\nfunction MA(t) {\n  const e = {}, n = Object.keys(t);\n  let r;\n  const i = n.length;\n  let s;\n  for (r = 0; r < i; r++)\n    s = n[r], e[s] = t[s];\n  return e;\n}\nfunction sw(t) {\n  function e(n, r, i, s) {\n    let o = n[s++];\n    if (o === \"__proto__\")\n      return !0;\n    const a = Number.isFinite(+o), l = s >= n.length;\n    return o = !o && V.isArray(i) ? i.length : o, l ? (V.hasOwnProp(i, o) ? i[o] = [i[o], r] : i[o] = r, !a) : ((!i[o] || !V.isObject(i[o])) && (i[o] = []), e(n, r, i[o], s) && V.isArray(i[o]) && (i[o] = MA(i[o])), !a);\n  }\n  if (V.isFormData(t) && V.isFunction(t.entries)) {\n    const n = {};\n    return V.forEachEntry(t, (r, i) => {\n      e(WA(r), i, n, 0);\n    }), n;\n  }\n  return null;\n}\nfunction XA(t, e, n) {\n  if (V.isString(t))\n    try {\n      return (e || JSON.parse)(t), V.trim(t);\n    } catch (r) {\n      if (r.name !== \"SyntaxError\")\n        throw r;\n    }\n  return (n || JSON.stringify)(t);\n}\nconst UO = {\n  transitional: rw,\n  adapter: [\"xhr\", \"http\"],\n  transformRequest: [function(e, n) {\n    const r = n.getContentType() || \"\", i = r.indexOf(\"application/json\") > -1, s = V.isObject(e);\n    if (s && V.isHTMLForm(e) && (e = new FormData(e)), V.isFormData(e))\n      return i ? JSON.stringify(sw(e)) : e;\n    if (V.isArrayBuffer(e) || V.isBuffer(e) || V.isStream(e) || V.isFile(e) || V.isBlob(e))\n      return e;\n    if (V.isArrayBufferView(e))\n      return e.buffer;\n    if (V.isURLSearchParams(e))\n      return n.setContentType(\"application/x-www-form-urlencoded;charset=utf-8\", !1), e.toString();\n    let a;\n    if (s) {\n      if (r.indexOf(\"application/x-www-form-urlencoded\") > -1)\n        return IA(e, this.formSerializer).toString();\n      if ((a = V.isFileList(e)) || r.indexOf(\"multipart/form-data\") > -1) {\n        const l = this.env && this.env.FormData;\n        return Zd(\n          a ? { \"files[]\": e } : e,\n          l && new l(),\n          this.formSerializer\n        );\n      }\n    }\n    return s || i ? (n.setContentType(\"application/json\", !1), XA(e)) : e;\n  }],\n  transformResponse: [function(e) {\n    const n = this.transitional || UO.transitional, r = n && n.forcedJSONParsing, i = this.responseType === \"json\";\n    if (e && V.isString(e) && (r && !this.responseType || i)) {\n      const o = !(n && n.silentJSONParsing) && i;\n      try {\n        return JSON.parse(e);\n      } catch (a) {\n        if (o)\n          throw a.name === \"SyntaxError\" ? je.from(a, je.ERR_BAD_RESPONSE, this, null, this.response) : a;\n      }\n    }\n    return e;\n  }],\n  /**\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\n   * timeout is not created.\n   */\n  timeout: 0,\n  xsrfCookieName: \"XSRF-TOKEN\",\n  xsrfHeaderName: \"X-XSRF-TOKEN\",\n  maxContentLength: -1,\n  maxBodyLength: -1,\n  env: {\n    FormData: Ar.classes.FormData,\n    Blob: Ar.classes.Blob\n  },\n  validateStatus: function(e) {\n    return e >= 200 && e < 300;\n  },\n  headers: {\n    common: {\n      Accept: \"application/json, text/plain, */*\",\n      \"Content-Type\": void 0\n    }\n  }\n};\nV.forEach([\"delete\", \"get\", \"head\", \"post\", \"put\", \"patch\"], (t) => {\n  UO.headers[t] = {};\n});\nconst qO = UO, jA = V.toObjectSet([\n  \"age\",\n  \"authorization\",\n  \"content-length\",\n  \"content-type\",\n  \"etag\",\n  \"expires\",\n  \"from\",\n  \"host\",\n  \"if-modified-since\",\n  \"if-unmodified-since\",\n  \"last-modified\",\n  \"location\",\n  \"max-forwards\",\n  \"proxy-authorization\",\n  \"referer\",\n  \"retry-after\",\n  \"user-agent\"\n]), BA = (t) => {\n  const e = {};\n  let n, r, i;\n  return t && t.split(`\n`).forEach(function(o) {\n    i = o.indexOf(\":\"), n = o.substring(0, i).trim().toLowerCase(), r = o.substring(i + 1).trim(), !(!n || e[n] && jA[n]) && (n === \"set-cookie\" ? e[n] ? e[n].push(r) : e[n] = [r] : e[n] = e[n] ? e[n] + \", \" + r : r);\n  }), e;\n}, gb = Symbol(\"internals\");\nfunction ma(t) {\n  return t && String(t).trim().toLowerCase();\n}\nfunction Jc(t) {\n  return t === !1 || t == null ? t : V.isArray(t) ? t.map(Jc) : String(t);\n}\nfunction LA(t) {\n  const e = /* @__PURE__ */ Object.create(null), n = /([^\\s,;=]+)\\s*(?:=\\s*([^,;]+))?/g;\n  let r;\n  for (; r = n.exec(t); )\n    e[r[1]] = r[2];\n  return e;\n}\nconst UA = (t) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(t.trim());\nfunction vf(t, e, n, r, i) {\n  if (V.isFunction(r))\n    return r.call(this, e, n);\n  if (i && (e = n), !!V.isString(e)) {\n    if (V.isString(r))\n      return e.indexOf(r) !== -1;\n    if (V.isRegExp(r))\n      return r.test(e);\n  }\n}\nfunction qA(t) {\n  return t.trim().toLowerCase().replace(/([a-z\\d])(\\w*)/g, (e, n, r) => n.toUpperCase() + r);\n}\nfunction YA(t, e) {\n  const n = V.toCamelCase(\" \" + e);\n  [\"get\", \"set\", \"has\"].forEach((r) => {\n    Object.defineProperty(t, r + n, {\n      value: function(i, s, o) {\n        return this[r].call(this, e, i, s, o);\n      },\n      configurable: !0\n    });\n  });\n}\nclass Vd {\n  constructor(e) {\n    e && this.set(e);\n  }\n  set(e, n, r) {\n    const i = this;\n    function s(a, l, c) {\n      const u = ma(l);\n      if (!u)\n        throw new Error(\"header name must be a non-empty string\");\n      const d = V.findKey(i, u);\n      (!d || i[d] === void 0 || c === !0 || c === void 0 && i[d] !== !1) && (i[d || l] = Jc(a));\n    }\n    const o = (a, l) => V.forEach(a, (c, u) => s(c, u, l));\n    return V.isPlainObject(e) || e instanceof this.constructor ? o(e, n) : V.isString(e) && (e = e.trim()) && !UA(e) ? o(BA(e), n) : e != null && s(n, e, r), this;\n  }\n  get(e, n) {\n    if (e = ma(e), e) {\n      const r = V.findKey(this, e);\n      if (r) {\n        const i = this[r];\n        if (!n)\n          return i;\n        if (n === !0)\n          return LA(i);\n        if (V.isFunction(n))\n          return n.call(this, i, r);\n        if (V.isRegExp(n))\n          return n.exec(i);\n        throw new TypeError(\"parser must be boolean|regexp|function\");\n      }\n    }\n  }\n  has(e, n) {\n    if (e = ma(e), e) {\n      const r = V.findKey(this, e);\n      return !!(r && this[r] !== void 0 && (!n || vf(this, this[r], r, n)));\n    }\n    return !1;\n  }\n  delete(e, n) {\n    const r = this;\n    let i = !1;\n    function s(o) {\n      if (o = ma(o), o) {\n        const a = V.findKey(r, o);\n        a && (!n || vf(r, r[a], a, n)) && (delete r[a], i = !0);\n      }\n    }\n    return V.isArray(e) ? e.forEach(s) : s(e), i;\n  }\n  clear(e) {\n    const n = Object.keys(this);\n    let r = n.length, i = !1;\n    for (; r--; ) {\n      const s = n[r];\n      (!e || vf(this, this[s], s, e, !0)) && (delete this[s], i = !0);\n    }\n    return i;\n  }\n  normalize(e) {\n    const n = this, r = {};\n    return V.forEach(this, (i, s) => {\n      const o = V.findKey(r, s);\n      if (o) {\n        n[o] = Jc(i), delete n[s];\n        return;\n      }\n      const a = e ? qA(s) : String(s).trim();\n      a !== s && delete n[s], n[a] = Jc(i), r[a] = !0;\n    }), this;\n  }\n  concat(...e) {\n    return this.constructor.concat(this, ...e);\n  }\n  toJSON(e) {\n    const n = /* @__PURE__ */ Object.create(null);\n    return V.forEach(this, (r, i) => {\n      r != null && r !== !1 && (n[i] = e && V.isArray(r) ? r.join(\", \") : r);\n    }), n;\n  }\n  [Symbol.iterator]() {\n    return Object.entries(this.toJSON())[Symbol.iterator]();\n  }\n  toString() {\n    return Object.entries(this.toJSON()).map(([e, n]) => e + \": \" + n).join(`\n`);\n  }\n  get [Symbol.toStringTag]() {\n    return \"AxiosHeaders\";\n  }\n  static from(e) {\n    return e instanceof this ? e : new this(e);\n  }\n  static concat(e, ...n) {\n    const r = new this(e);\n    return n.forEach((i) => r.set(i)), r;\n  }\n  static accessor(e) {\n    const r = (this[gb] = this[gb] = {\n      accessors: {}\n    }).accessors, i = this.prototype;\n    function s(o) {\n      const a = ma(o);\n      r[a] || (YA(i, o), r[a] = !0);\n    }\n    return V.isArray(e) ? e.forEach(s) : s(e), this;\n  }\n}\nVd.accessor([\"Content-Type\", \"Content-Length\", \"Accept\", \"Accept-Encoding\", \"User-Agent\", \"Authorization\"]);\nV.reduceDescriptors(Vd.prototype, ({ value: t }, e) => {\n  let n = e[0].toUpperCase() + e.slice(1);\n  return {\n    get: () => t,\n    set(r) {\n      this[n] = r;\n    }\n  };\n});\nV.freezeMethods(Vd);\nconst ri = Vd;\nfunction yf(t, e) {\n  const n = this || qO, r = e || n, i = ri.from(r.headers);\n  let s = r.data;\n  return V.forEach(t, function(a) {\n    s = a.call(n, s, i.normalize(), e ? e.status : void 0);\n  }), i.normalize(), s;\n}\nfunction ow(t) {\n  return !!(t && t.__CANCEL__);\n}\nfunction Ul(t, e, n) {\n  je.call(this, t ?? \"canceled\", je.ERR_CANCELED, e, n), this.name = \"CanceledError\";\n}\nV.inherits(Ul, je, {\n  __CANCEL__: !0\n});\nfunction zA(t, e, n) {\n  const r = n.config.validateStatus;\n  !n.status || !r || r(n.status) ? t(n) : e(new je(\n    \"Request failed with status code \" + n.status,\n    [je.ERR_BAD_REQUEST, je.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4],\n    n.config,\n    n.request,\n    n\n  ));\n}\nconst HA = Ar.hasStandardBrowserEnv ? (\n  // Standard browser envs support document.cookie\n  {\n    write(t, e, n, r, i, s) {\n      const o = [t + \"=\" + encodeURIComponent(e)];\n      V.isNumber(n) && o.push(\"expires=\" + new Date(n).toGMTString()), V.isString(r) && o.push(\"path=\" + r), V.isString(i) && o.push(\"domain=\" + i), s === !0 && o.push(\"secure\"), document.cookie = o.join(\"; \");\n    },\n    read(t) {\n      const e = document.cookie.match(new RegExp(\"(^|;\\\\s*)(\" + t + \")=([^;]*)\"));\n      return e ? decodeURIComponent(e[3]) : null;\n    },\n    remove(t) {\n      this.write(t, \"\", Date.now() - 864e5);\n    }\n  }\n) : (\n  // Non-standard browser env (web workers, react-native) lack needed support.\n  {\n    write() {\n    },\n    read() {\n      return null;\n    },\n    remove() {\n    }\n  }\n);\nfunction FA(t) {\n  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(t);\n}\nfunction GA(t, e) {\n  return e ? t.replace(/\\/?\\/$/, \"\") + \"/\" + e.replace(/^\\/+/, \"\") : t;\n}\nfunction aw(t, e) {\n  return t && !FA(e) ? GA(t, e) : e;\n}\nconst KA = Ar.hasStandardBrowserEnv ? (\n  // Standard browser envs have full support of the APIs needed to test\n  // whether the request URL is of the same origin as current location.\n  function() {\n    const e = /(msie|trident)/i.test(navigator.userAgent), n = document.createElement(\"a\");\n    let r;\n    function i(s) {\n      let o = s;\n      return e && (n.setAttribute(\"href\", o), o = n.href), n.setAttribute(\"href\", o), {\n        href: n.href,\n        protocol: n.protocol ? n.protocol.replace(/:$/, \"\") : \"\",\n        host: n.host,\n        search: n.search ? n.search.replace(/^\\?/, \"\") : \"\",\n        hash: n.hash ? n.hash.replace(/^#/, \"\") : \"\",\n        hostname: n.hostname,\n        port: n.port,\n        pathname: n.pathname.charAt(0) === \"/\" ? n.pathname : \"/\" + n.pathname\n      };\n    }\n    return r = i(window.location.href), function(o) {\n      const a = V.isString(o) ? i(o) : o;\n      return a.protocol === r.protocol && a.host === r.host;\n    };\n  }()\n) : (\n  // Non standard browser envs (web workers, react-native) lack needed support.\n  /* @__PURE__ */ function() {\n    return function() {\n      return !0;\n    };\n  }()\n);\nfunction JA(t) {\n  const e = /^([-+\\w]{1,25})(:?\\/\\/|:)/.exec(t);\n  return e && e[1] || \"\";\n}\nfunction e2(t, e) {\n  t = t || 10;\n  const n = new Array(t), r = new Array(t);\n  let i = 0, s = 0, o;\n  return e = e !== void 0 ? e : 1e3, function(l) {\n    const c = Date.now(), u = r[s];\n    o || (o = c), n[i] = l, r[i] = c;\n    let d = s, f = 0;\n    for (; d !== i; )\n      f += n[d++], d = d % t;\n    if (i = (i + 1) % t, i === s && (s = (s + 1) % t), c - o < e)\n      return;\n    const h = u && c - u;\n    return h ? Math.round(f * 1e3 / h) : void 0;\n  };\n}\nfunction mb(t, e) {\n  let n = 0;\n  const r = e2(50, 250);\n  return (i) => {\n    const s = i.loaded, o = i.lengthComputable ? i.total : void 0, a = s - n, l = r(a), c = s <= o;\n    n = s;\n    const u = {\n      loaded: s,\n      total: o,\n      progress: o ? s / o : void 0,\n      bytes: a,\n      rate: l || void 0,\n      estimated: l && o && c ? (o - s) / l : void 0,\n      event: i\n    };\n    u[e ? \"download\" : \"upload\"] = !0, t(u);\n  };\n}\nconst t2 = typeof XMLHttpRequest < \"u\", n2 = t2 && function(t) {\n  return new Promise(function(n, r) {\n    let i = t.data;\n    const s = ri.from(t.headers).normalize();\n    let { responseType: o, withXSRFToken: a } = t, l;\n    function c() {\n      t.cancelToken && t.cancelToken.unsubscribe(l), t.signal && t.signal.removeEventListener(\"abort\", l);\n    }\n    let u;\n    if (V.isFormData(i)) {\n      if (Ar.hasStandardBrowserEnv || Ar.hasStandardBrowserWebWorkerEnv)\n        s.setContentType(!1);\n      else if ((u = s.getContentType()) !== !1) {\n        const [O, ...m] = u ? u.split(\";\").map((y) => y.trim()).filter(Boolean) : [];\n        s.setContentType([O || \"multipart/form-data\", ...m].join(\"; \"));\n      }\n    }\n    let d = new XMLHttpRequest();\n    if (t.auth) {\n      const O = t.auth.username || \"\", m = t.auth.password ? unescape(encodeURIComponent(t.auth.password)) : \"\";\n      s.set(\"Authorization\", \"Basic \" + btoa(O + \":\" + m));\n    }\n    const f = aw(t.baseURL, t.url);\n    d.open(t.method.toUpperCase(), nw(f, t.params, t.paramsSerializer), !0), d.timeout = t.timeout;\n    function h() {\n      if (!d)\n        return;\n      const O = ri.from(\n        \"getAllResponseHeaders\" in d && d.getAllResponseHeaders()\n      ), y = {\n        data: !o || o === \"text\" || o === \"json\" ? d.responseText : d.response,\n        status: d.status,\n        statusText: d.statusText,\n        headers: O,\n        config: t,\n        request: d\n      };\n      zA(function(g) {\n        n(g), c();\n      }, function(g) {\n        r(g), c();\n      }, y), d = null;\n    }\n    if (\"onloadend\" in d ? d.onloadend = h : d.onreadystatechange = function() {\n      !d || d.readyState !== 4 || d.status === 0 && !(d.responseURL && d.responseURL.indexOf(\"file:\") === 0) || setTimeout(h);\n    }, d.onabort = function() {\n      d && (r(new je(\"Request aborted\", je.ECONNABORTED, t, d)), d = null);\n    }, d.onerror = function() {\n      r(new je(\"Network Error\", je.ERR_NETWORK, t, d)), d = null;\n    }, d.ontimeout = function() {\n      let m = t.timeout ? \"timeout of \" + t.timeout + \"ms exceeded\" : \"timeout exceeded\";\n      const y = t.transitional || rw;\n      t.timeoutErrorMessage && (m = t.timeoutErrorMessage), r(new je(\n        m,\n        y.clarifyTimeoutError ? je.ETIMEDOUT : je.ECONNABORTED,\n        t,\n        d\n      )), d = null;\n    }, Ar.hasStandardBrowserEnv && (a && V.isFunction(a) && (a = a(t)), a || a !== !1 && KA(f))) {\n      const O = t.xsrfHeaderName && t.xsrfCookieName && HA.read(t.xsrfCookieName);\n      O && s.set(t.xsrfHeaderName, O);\n    }\n    i === void 0 && s.setContentType(null), \"setRequestHeader\" in d && V.forEach(s.toJSON(), function(m, y) {\n      d.setRequestHeader(y, m);\n    }), V.isUndefined(t.withCredentials) || (d.withCredentials = !!t.withCredentials), o && o !== \"json\" && (d.responseType = t.responseType), typeof t.onDownloadProgress == \"function\" && d.addEventListener(\"progress\", mb(t.onDownloadProgress, !0)), typeof t.onUploadProgress == \"function\" && d.upload && d.upload.addEventListener(\"progress\", mb(t.onUploadProgress)), (t.cancelToken || t.signal) && (l = (O) => {\n      d && (r(!O || O.type ? new Ul(null, t, d) : O), d.abort(), d = null);\n    }, t.cancelToken && t.cancelToken.subscribe(l), t.signal && (t.signal.aborted ? l() : t.signal.addEventListener(\"abort\", l)));\n    const p = JA(f);\n    if (p && Ar.protocols.indexOf(p) === -1) {\n      r(new je(\"Unsupported protocol \" + p + \":\", je.ERR_BAD_REQUEST, t));\n      return;\n    }\n    d.send(i || null);\n  });\n}, Vh = {\n  http: TA,\n  xhr: n2\n};\nV.forEach(Vh, (t, e) => {\n  if (t) {\n    try {\n      Object.defineProperty(t, \"name\", { value: e });\n    } catch {\n    }\n    Object.defineProperty(t, \"adapterName\", { value: e });\n  }\n});\nconst bb = (t) => `- ${t}`, r2 = (t) => V.isFunction(t) || t === null || t === !1, lw = {\n  getAdapter: (t) => {\n    t = V.isArray(t) ? t : [t];\n    const { length: e } = t;\n    let n, r;\n    const i = {};\n    for (let s = 0; s < e; s++) {\n      n = t[s];\n      let o;\n      if (r = n, !r2(n) && (r = Vh[(o = String(n)).toLowerCase()], r === void 0))\n        throw new je(`Unknown adapter '${o}'`);\n      if (r)\n        break;\n      i[o || \"#\" + s] = r;\n    }\n    if (!r) {\n      const s = Object.entries(i).map(\n        ([a, l]) => `adapter ${a} ` + (l === !1 ? \"is not supported by the environment\" : \"is not available in the build\")\n      );\n      let o = e ? s.length > 1 ? `since :\n` + s.map(bb).join(`\n`) : \" \" + bb(s[0]) : \"as no adapter specified\";\n      throw new je(\n        \"There is no suitable adapter to dispatch the request \" + o,\n        \"ERR_NOT_SUPPORT\"\n      );\n    }\n    return r;\n  },\n  adapters: Vh\n};\nfunction Sf(t) {\n  if (t.cancelToken && t.cancelToken.throwIfRequested(), t.signal && t.signal.aborted)\n    throw new Ul(null, t);\n}\nfunction vb(t) {\n  return Sf(t), t.headers = ri.from(t.headers), t.data = yf.call(\n    t,\n    t.transformRequest\n  ), [\"post\", \"put\", \"patch\"].indexOf(t.method) !== -1 && t.headers.setContentType(\"application/x-www-form-urlencoded\", !1), lw.getAdapter(t.adapter || qO.adapter)(t).then(function(r) {\n    return Sf(t), r.data = yf.call(\n      t,\n      t.transformResponse,\n      r\n    ), r.headers = ri.from(r.headers), r;\n  }, function(r) {\n    return ow(r) || (Sf(t), r && r.response && (r.response.data = yf.call(\n      t,\n      t.transformResponse,\n      r.response\n    ), r.response.headers = ri.from(r.response.headers))), Promise.reject(r);\n  });\n}\nconst yb = (t) => t instanceof ri ? { ...t } : t;\nfunction Io(t, e) {\n  e = e || {};\n  const n = {};\n  function r(c, u, d) {\n    return V.isPlainObject(c) && V.isPlainObject(u) ? V.merge.call({ caseless: d }, c, u) : V.isPlainObject(u) ? V.merge({}, u) : V.isArray(u) ? u.slice() : u;\n  }\n  function i(c, u, d) {\n    if (V.isUndefined(u)) {\n      if (!V.isUndefined(c))\n        return r(void 0, c, d);\n    } else\n      return r(c, u, d);\n  }\n  function s(c, u) {\n    if (!V.isUndefined(u))\n      return r(void 0, u);\n  }\n  function o(c, u) {\n    if (V.isUndefined(u)) {\n      if (!V.isUndefined(c))\n        return r(void 0, c);\n    } else\n      return r(void 0, u);\n  }\n  function a(c, u, d) {\n    if (d in e)\n      return r(c, u);\n    if (d in t)\n      return r(void 0, c);\n  }\n  const l = {\n    url: s,\n    method: s,\n    data: s,\n    baseURL: o,\n    transformRequest: o,\n    transformResponse: o,\n    paramsSerializer: o,\n    timeout: o,\n    timeoutMessage: o,\n    withCredentials: o,\n    withXSRFToken: o,\n    adapter: o,\n    responseType: o,\n    xsrfCookieName: o,\n    xsrfHeaderName: o,\n    onUploadProgress: o,\n    onDownloadProgress: o,\n    decompress: o,\n    maxContentLength: o,\n    maxBodyLength: o,\n    beforeRedirect: o,\n    transport: o,\n    httpAgent: o,\n    httpsAgent: o,\n    cancelToken: o,\n    socketPath: o,\n    responseEncoding: o,\n    validateStatus: a,\n    headers: (c, u) => i(yb(c), yb(u), !0)\n  };\n  return V.forEach(Object.keys(Object.assign({}, t, e)), function(u) {\n    const d = l[u] || i, f = d(t[u], e[u], u);\n    V.isUndefined(f) && d !== a || (n[u] = f);\n  }), n;\n}\nconst cw = \"1.6.8\", YO = {};\n[\"object\", \"boolean\", \"number\", \"function\", \"string\", \"symbol\"].forEach((t, e) => {\n  YO[t] = function(r) {\n    return typeof r === t || \"a\" + (e < 1 ? \"n \" : \" \") + t;\n  };\n});\nconst Sb = {};\nYO.transitional = function(e, n, r) {\n  function i(s, o) {\n    return \"[Axios v\" + cw + \"] Transitional option '\" + s + \"'\" + o + (r ? \". \" + r : \"\");\n  }\n  return (s, o, a) => {\n    if (e === !1)\n      throw new je(\n        i(o, \" has been removed\" + (n ? \" in \" + n : \"\")),\n        je.ERR_DEPRECATED\n      );\n    return n && !Sb[o] && (Sb[o] = !0, console.warn(\n      i(\n        o,\n        \" has been deprecated since v\" + n + \" and will be removed in the near future\"\n      )\n    )), e ? e(s, o, a) : !0;\n  };\n};\nfunction i2(t, e, n) {\n  if (typeof t != \"object\")\n    throw new je(\"options must be an object\", je.ERR_BAD_OPTION_VALUE);\n  const r = Object.keys(t);\n  let i = r.length;\n  for (; i-- > 0; ) {\n    const s = r[i], o = e[s];\n    if (o) {\n      const a = t[s], l = a === void 0 || o(a, s, t);\n      if (l !== !0)\n        throw new je(\"option \" + s + \" must be \" + l, je.ERR_BAD_OPTION_VALUE);\n      continue;\n    }\n    if (n !== !0)\n      throw new je(\"Unknown option \" + s, je.ERR_BAD_OPTION);\n  }\n}\nconst Ih = {\n  assertOptions: i2,\n  validators: YO\n}, ki = Ih.validators;\nclass Qu {\n  constructor(e) {\n    this.defaults = e, this.interceptors = {\n      request: new Ob(),\n      response: new Ob()\n    };\n  }\n  /**\n   * Dispatch a request\n   *\n   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)\n   * @param {?Object} config\n   *\n   * @returns {Promise} The Promise to be fulfilled\n   */\n  async request(e, n) {\n    try {\n      return await this._request(e, n);\n    } catch (r) {\n      if (r instanceof Error) {\n        let i;\n        Error.captureStackTrace ? Error.captureStackTrace(i = {}) : i = new Error();\n        const s = i.stack ? i.stack.replace(/^.+\\n/, \"\") : \"\";\n        r.stack ? s && !String(r.stack).endsWith(s.replace(/^.+\\n.+\\n/, \"\")) && (r.stack += `\n` + s) : r.stack = s;\n      }\n      throw r;\n    }\n  }\n  _request(e, n) {\n    typeof e == \"string\" ? (n = n || {}, n.url = e) : n = e || {}, n = Io(this.defaults, n);\n    const { transitional: r, paramsSerializer: i, headers: s } = n;\n    r !== void 0 && Ih.assertOptions(r, {\n      silentJSONParsing: ki.transitional(ki.boolean),\n      forcedJSONParsing: ki.transitional(ki.boolean),\n      clarifyTimeoutError: ki.transitional(ki.boolean)\n    }, !1), i != null && (V.isFunction(i) ? n.paramsSerializer = {\n      serialize: i\n    } : Ih.assertOptions(i, {\n      encode: ki.function,\n      serialize: ki.function\n    }, !0)), n.method = (n.method || this.defaults.method || \"get\").toLowerCase();\n    let o = s && V.merge(\n      s.common,\n      s[n.method]\n    );\n    s && V.forEach(\n      [\"delete\", \"get\", \"head\", \"post\", \"put\", \"patch\", \"common\"],\n      (p) => {\n        delete s[p];\n      }\n    ), n.headers = ri.concat(o, s);\n    const a = [];\n    let l = !0;\n    this.interceptors.request.forEach(function(O) {\n      typeof O.runWhen == \"function\" && O.runWhen(n) === !1 || (l = l && O.synchronous, a.unshift(O.fulfilled, O.rejected));\n    });\n    const c = [];\n    this.interceptors.response.forEach(function(O) {\n      c.push(O.fulfilled, O.rejected);\n    });\n    let u, d = 0, f;\n    if (!l) {\n      const p = [vb.bind(this), void 0];\n      for (p.unshift.apply(p, a), p.push.apply(p, c), f = p.length, u = Promise.resolve(n); d < f; )\n        u = u.then(p[d++], p[d++]);\n      return u;\n    }\n    f = a.length;\n    let h = n;\n    for (d = 0; d < f; ) {\n      const p = a[d++], O = a[d++];\n      try {\n        h = p(h);\n      } catch (m) {\n        O.call(this, m);\n        break;\n      }\n    }\n    try {\n      u = vb.call(this, h);\n    } catch (p) {\n      return Promise.reject(p);\n    }\n    for (d = 0, f = c.length; d < f; )\n      u = u.then(c[d++], c[d++]);\n    return u;\n  }\n  getUri(e) {\n    e = Io(this.defaults, e);\n    const n = aw(e.baseURL, e.url);\n    return nw(n, e.params, e.paramsSerializer);\n  }\n}\nV.forEach([\"delete\", \"get\", \"head\", \"options\"], function(e) {\n  Qu.prototype[e] = function(n, r) {\n    return this.request(Io(r || {}, {\n      method: e,\n      url: n,\n      data: (r || {}).data\n    }));\n  };\n});\nV.forEach([\"post\", \"put\", \"patch\"], function(e) {\n  function n(r) {\n    return function(s, o, a) {\n      return this.request(Io(a || {}, {\n        method: e,\n        headers: r ? {\n          \"Content-Type\": \"multipart/form-data\"\n        } : {},\n        url: s,\n        data: o\n      }));\n    };\n  }\n  Qu.prototype[e] = n(), Qu.prototype[e + \"Form\"] = n(!0);\n});\nconst eu = Qu;\nclass zO {\n  constructor(e) {\n    if (typeof e != \"function\")\n      throw new TypeError(\"executor must be a function.\");\n    let n;\n    this.promise = new Promise(function(s) {\n      n = s;\n    });\n    const r = this;\n    this.promise.then((i) => {\n      if (!r._listeners)\n        return;\n      let s = r._listeners.length;\n      for (; s-- > 0; )\n        r._listeners[s](i);\n      r._listeners = null;\n    }), this.promise.then = (i) => {\n      let s;\n      const o = new Promise((a) => {\n        r.subscribe(a), s = a;\n      }).then(i);\n      return o.cancel = function() {\n        r.unsubscribe(s);\n      }, o;\n    }, e(function(s, o, a) {\n      r.reason || (r.reason = new Ul(s, o, a), n(r.reason));\n    });\n  }\n  /**\n   * Throws a `CanceledError` if cancellation has been requested.\n   */\n  throwIfRequested() {\n    if (this.reason)\n      throw this.reason;\n  }\n  /**\n   * Subscribe to the cancel signal\n   */\n  subscribe(e) {\n    if (this.reason) {\n      e(this.reason);\n      return;\n    }\n    this._listeners ? this._listeners.push(e) : this._listeners = [e];\n  }\n  /**\n   * Unsubscribe from the cancel signal\n   */\n  unsubscribe(e) {\n    if (!this._listeners)\n      return;\n    const n = this._listeners.indexOf(e);\n    n !== -1 && this._listeners.splice(n, 1);\n  }\n  /**\n   * Returns an object that contains a new `CancelToken` and a function that, when called,\n   * cancels the `CancelToken`.\n   */\n  static source() {\n    let e;\n    return {\n      token: new zO(function(i) {\n        e = i;\n      }),\n      cancel: e\n    };\n  }\n}\nconst s2 = zO;\nfunction o2(t) {\n  return function(n) {\n    return t.apply(null, n);\n  };\n}\nfunction a2(t) {\n  return V.isObject(t) && t.isAxiosError === !0;\n}\nconst Wh = {\n  Continue: 100,\n  SwitchingProtocols: 101,\n  Processing: 102,\n  EarlyHints: 103,\n  Ok: 200,\n  Created: 201,\n  Accepted: 202,\n  NonAuthoritativeInformation: 203,\n  NoContent: 204,\n  ResetContent: 205,\n  PartialContent: 206,\n  MultiStatus: 207,\n  AlreadyReported: 208,\n  ImUsed: 226,\n  MultipleChoices: 300,\n  MovedPermanently: 301,\n  Found: 302,\n  SeeOther: 303,\n  NotModified: 304,\n  UseProxy: 305,\n  Unused: 306,\n  TemporaryRedirect: 307,\n  PermanentRedirect: 308,\n  BadRequest: 400,\n  Unauthorized: 401,\n  PaymentRequired: 402,\n  Forbidden: 403,\n  NotFound: 404,\n  MethodNotAllowed: 405,\n  NotAcceptable: 406,\n  ProxyAuthenticationRequired: 407,\n  RequestTimeout: 408,\n  Conflict: 409,\n  Gone: 410,\n  LengthRequired: 411,\n  PreconditionFailed: 412,\n  PayloadTooLarge: 413,\n  UriTooLong: 414,\n  UnsupportedMediaType: 415,\n  RangeNotSatisfiable: 416,\n  ExpectationFailed: 417,\n  ImATeapot: 418,\n  MisdirectedRequest: 421,\n  UnprocessableEntity: 422,\n  Locked: 423,\n  FailedDependency: 424,\n  TooEarly: 425,\n  UpgradeRequired: 426,\n  PreconditionRequired: 428,\n  TooManyRequests: 429,\n  RequestHeaderFieldsTooLarge: 431,\n  UnavailableForLegalReasons: 451,\n  InternalServerError: 500,\n  NotImplemented: 501,\n  BadGateway: 502,\n  ServiceUnavailable: 503,\n  GatewayTimeout: 504,\n  HttpVersionNotSupported: 505,\n  VariantAlsoNegotiates: 506,\n  InsufficientStorage: 507,\n  LoopDetected: 508,\n  NotExtended: 510,\n  NetworkAuthenticationRequired: 511\n};\nObject.entries(Wh).forEach(([t, e]) => {\n  Wh[e] = t;\n});\nconst l2 = Wh;\nfunction uw(t) {\n  const e = new eu(t), n = LS(eu.prototype.request, e);\n  return V.extend(n, eu.prototype, e, { allOwnKeys: !0 }), V.extend(n, e, null, { allOwnKeys: !0 }), n.create = function(i) {\n    return uw(Io(t, i));\n  }, n;\n}\nconst At = uw(qO);\nAt.Axios = eu;\nAt.CanceledError = Ul;\nAt.CancelToken = s2;\nAt.isCancel = ow;\nAt.VERSION = cw;\nAt.toFormData = Zd;\nAt.AxiosError = je;\nAt.Cancel = At.CanceledError;\nAt.all = function(e) {\n  return Promise.all(e);\n};\nAt.spread = o2;\nAt.isAxiosError = a2;\nAt.mergeConfig = Io;\nAt.AxiosHeaders = ri;\nAt.formToJSON = (t) => sw(V.isHTMLForm(t) ? new FormData(t) : t);\nAt.getAdapter = lw.getAdapter;\nAt.HttpStatusCode = l2;\nAt.default = At;\nconst c2 = \"useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict\";\nlet u2 = (t = 21) => {\n  let e = \"\", n = crypto.getRandomValues(new Uint8Array(t));\n  for (; t--; )\n    e += c2[n[t] & 63];\n  return e;\n};\nconst d2 = [\n  \"B\",\n  \"kB\",\n  \"MB\",\n  \"GB\",\n  \"TB\",\n  \"PB\",\n  \"EB\",\n  \"ZB\",\n  \"YB\"\n], f2 = [\n  \"B\",\n  \"KiB\",\n  \"MiB\",\n  \"GiB\",\n  \"TiB\",\n  \"PiB\",\n  \"EiB\",\n  \"ZiB\",\n  \"YiB\"\n], h2 = [\n  \"b\",\n  \"kbit\",\n  \"Mbit\",\n  \"Gbit\",\n  \"Tbit\",\n  \"Pbit\",\n  \"Ebit\",\n  \"Zbit\",\n  \"Ybit\"\n], p2 = [\n  \"b\",\n  \"kibit\",\n  \"Mibit\",\n  \"Gibit\",\n  \"Tibit\",\n  \"Pibit\",\n  \"Eibit\",\n  \"Zibit\",\n  \"Yibit\"\n], wb = (t, e, n) => {\n  let r = t;\n  return typeof e == \"string\" || Array.isArray(e) ? r = t.toLocaleString(e, n) : (e === !0 || n !== void 0) && (r = t.toLocaleString(void 0, n)), r;\n};\nfunction Cu(t, e) {\n  if (!Number.isFinite(t))\n    throw new TypeError(`Expected a finite number, got ${typeof t}: ${t}`);\n  e = {\n    bits: !1,\n    binary: !1,\n    space: !0,\n    ...e\n  };\n  const n = e.bits ? e.binary ? p2 : h2 : e.binary ? f2 : d2, r = e.space ? \" \" : \"\";\n  if (e.signed && t === 0)\n    return ` 0${r}${n[0]}`;\n  const i = t < 0, s = i ? \"-\" : e.signed ? \"+\" : \"\";\n  i && (t = -t);\n  let o;\n  if (e.minimumFractionDigits !== void 0 && (o = { minimumFractionDigits: e.minimumFractionDigits }), e.maximumFractionDigits !== void 0 && (o = { maximumFractionDigits: e.maximumFractionDigits, ...o }), t < 1) {\n    const u = wb(t, e.locale, o);\n    return s + u + r + n[0];\n  }\n  const a = Math.min(Math.floor(e.binary ? Math.log(t) / Math.log(1024) : Math.log10(t) / 3), n.length - 1);\n  t /= (e.binary ? 1024 : 1e3) ** a, o || (t = t.toPrecision(3));\n  const l = wb(Number(t), e.locale, o), c = n[a];\n  return s + l + r + c;\n}\nfunction O2(t) {\n  if (typeof t != \"number\")\n    throw new TypeError(\"Expected a number\");\n  const e = t > 0 ? Math.floor : Math.ceil;\n  return {\n    days: e(t / 864e5),\n    hours: e(t / 36e5) % 24,\n    minutes: e(t / 6e4) % 60,\n    seconds: e(t / 1e3) % 60,\n    milliseconds: e(t) % 1e3,\n    microseconds: e(t * 1e3) % 1e3,\n    nanoseconds: e(t * 1e6) % 1e3\n  };\n}\nconst g2 = (t, e) => e === 1 ? t : `${t}s`, m2 = 1e-7;\nfunction dw(t, e = {}) {\n  if (!Number.isFinite(t))\n    throw new TypeError(\"Expected a finite number\");\n  e.colonNotation && (e.compact = !1, e.formatSubMilliseconds = !1, e.separateMilliseconds = !1, e.verbose = !1), e.compact && (e.secondsDecimalDigits = 0, e.millisecondsDecimalDigits = 0);\n  const n = [], r = (o, a) => {\n    const l = Math.floor(o * 10 ** a + m2);\n    return (Math.round(l) / 10 ** a).toFixed(a);\n  }, i = (o, a, l, c) => {\n    if ((n.length === 0 || !e.colonNotation) && o === 0 && !(e.colonNotation && l === \"m\"))\n      return;\n    c = (c || o || \"0\").toString();\n    let u, d;\n    if (e.colonNotation) {\n      u = n.length > 0 ? \":\" : \"\", d = \"\";\n      const f = c.includes(\".\") ? c.split(\".\")[0].length : c.length, h = n.length > 0 ? 2 : 1;\n      c = \"0\".repeat(Math.max(0, h - f)) + c;\n    } else\n      u = \"\", d = e.verbose ? \" \" + g2(a, o) : l;\n    n.push(u + c + d);\n  }, s = O2(t);\n  if (i(Math.trunc(s.days / 365), \"year\", \"y\"), i(s.days % 365, \"day\", \"d\"), i(s.hours, \"hour\", \"h\"), i(s.minutes, \"minute\", \"m\"), e.separateMilliseconds || e.formatSubMilliseconds || !e.colonNotation && t < 1e3)\n    if (i(s.seconds, \"second\", \"s\"), e.formatSubMilliseconds)\n      i(s.milliseconds, \"millisecond\", \"ms\"), i(s.microseconds, \"microsecond\", \"s\"), i(s.nanoseconds, \"nanosecond\", \"ns\");\n    else {\n      const o = s.milliseconds + s.microseconds / 1e3 + s.nanoseconds / 1e6, a = typeof e.millisecondsDecimalDigits == \"number\" ? e.millisecondsDecimalDigits : 0, l = o >= 1 ? Math.round(o) : Math.ceil(o), c = a ? o.toFixed(a) : l;\n      i(\n        Number.parseFloat(c),\n        \"millisecond\",\n        \"ms\",\n        c\n      );\n    }\n  else {\n    const o = t / 1e3 % 60, a = typeof e.secondsDecimalDigits == \"number\" ? e.secondsDecimalDigits : 1, l = r(o, a), c = e.keepDecimalsOnWholeSeconds ? l : l.replace(/\\.0+$/, \"\");\n    i(Number.parseFloat(c), \"second\", \"s\", c);\n  }\n  if (n.length === 0)\n    return \"0\" + (e.verbose ? \" milliseconds\" : \"ms\");\n  if (e.compact)\n    return n[0];\n  if (typeof e.unitCount == \"number\") {\n    const o = e.colonNotation ? \"\" : \" \";\n    return n.slice(0, Math.max(e.unitCount, 1)).join(o);\n  }\n  return e.colonNotation ? n.join(\"\") : n.join(\" \");\n}\nconst Au = Math.min, Is = Math.max, Ru = Math.round, wc = Math.floor, is = (t) => ({\n  x: t,\n  y: t\n}), b2 = {\n  left: \"right\",\n  right: \"left\",\n  bottom: \"top\",\n  top: \"bottom\"\n}, v2 = {\n  start: \"end\",\n  end: \"start\"\n};\nfunction kb(t, e, n) {\n  return Is(t, Au(e, n));\n}\nfunction Id(t, e) {\n  return typeof t == \"function\" ? t(e) : t;\n}\nfunction Ls(t) {\n  return t.split(\"-\")[0];\n}\nfunction Wd(t) {\n  return t.split(\"-\")[1];\n}\nfunction fw(t) {\n  return t === \"x\" ? \"y\" : \"x\";\n}\nfunction hw(t) {\n  return t === \"y\" ? \"height\" : \"width\";\n}\nfunction Md(t) {\n  return [\"top\", \"bottom\"].includes(Ls(t)) ? \"y\" : \"x\";\n}\nfunction pw(t) {\n  return fw(Md(t));\n}\nfunction y2(t, e, n) {\n  n === void 0 && (n = !1);\n  const r = Wd(t), i = pw(t), s = hw(i);\n  let o = i === \"x\" ? r === (n ? \"end\" : \"start\") ? \"right\" : \"left\" : r === \"start\" ? \"bottom\" : \"top\";\n  return e.reference[s] > e.floating[s] && (o = Nu(o)), [o, Nu(o)];\n}\nfunction S2(t) {\n  const e = Nu(t);\n  return [Mh(t), e, Mh(e)];\n}\nfunction Mh(t) {\n  return t.replace(/start|end/g, (e) => v2[e]);\n}\nfunction w2(t, e, n) {\n  const r = [\"left\", \"right\"], i = [\"right\", \"left\"], s = [\"top\", \"bottom\"], o = [\"bottom\", \"top\"];\n  switch (t) {\n    case \"top\":\n    case \"bottom\":\n      return n ? e ? i : r : e ? r : i;\n    case \"left\":\n    case \"right\":\n      return e ? s : o;\n    default:\n      return [];\n  }\n}\nfunction k2(t, e, n, r) {\n  const i = Wd(t);\n  let s = w2(Ls(t), n === \"start\", r);\n  return i && (s = s.map((o) => o + \"-\" + i), e && (s = s.concat(s.map(Mh)))), s;\n}\nfunction Nu(t) {\n  return t.replace(/left|right|bottom|top/g, (e) => b2[e]);\n}\nfunction x2(t) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...t\n  };\n}\nfunction P2(t) {\n  return typeof t != \"number\" ? x2(t) : {\n    top: t,\n    right: t,\n    bottom: t,\n    left: t\n  };\n}\nfunction Du(t) {\n  const {\n    x: e,\n    y: n,\n    width: r,\n    height: i\n  } = t;\n  return {\n    width: r,\n    height: i,\n    top: n,\n    left: e,\n    right: e + r,\n    bottom: n + i,\n    x: e,\n    y: n\n  };\n}\nfunction xb(t, e, n) {\n  let {\n    reference: r,\n    floating: i\n  } = t;\n  const s = Md(e), o = pw(e), a = hw(o), l = Ls(e), c = s === \"y\", u = r.x + r.width / 2 - i.width / 2, d = r.y + r.height / 2 - i.height / 2, f = r[a] / 2 - i[a] / 2;\n  let h;\n  switch (l) {\n    case \"top\":\n      h = {\n        x: u,\n        y: r.y - i.height\n      };\n      break;\n    case \"bottom\":\n      h = {\n        x: u,\n        y: r.y + r.height\n      };\n      break;\n    case \"right\":\n      h = {\n        x: r.x + r.width,\n        y: d\n      };\n      break;\n    case \"left\":\n      h = {\n        x: r.x - i.width,\n        y: d\n      };\n      break;\n    default:\n      h = {\n        x: r.x,\n        y: r.y\n      };\n  }\n  switch (Wd(e)) {\n    case \"start\":\n      h[o] -= f * (n && c ? -1 : 1);\n      break;\n    case \"end\":\n      h[o] += f * (n && c ? -1 : 1);\n      break;\n  }\n  return h;\n}\nconst _2 = async (t, e, n) => {\n  const {\n    placement: r = \"bottom\",\n    strategy: i = \"absolute\",\n    middleware: s = [],\n    platform: o\n  } = n, a = s.filter(Boolean), l = await (o.isRTL == null ? void 0 : o.isRTL(e));\n  let c = await o.getElementRects({\n    reference: t,\n    floating: e,\n    strategy: i\n  }), {\n    x: u,\n    y: d\n  } = xb(c, r, l), f = r, h = {}, p = 0;\n  for (let O = 0; O < a.length; O++) {\n    const {\n      name: m,\n      fn: y\n    } = a[O], {\n      x: b,\n      y: g,\n      data: v,\n      reset: S\n    } = await y({\n      x: u,\n      y: d,\n      initialPlacement: r,\n      placement: f,\n      strategy: i,\n      middlewareData: h,\n      rects: c,\n      platform: o,\n      elements: {\n        reference: t,\n        floating: e\n      }\n    });\n    u = b ?? u, d = g ?? d, h = {\n      ...h,\n      [m]: {\n        ...h[m],\n        ...v\n      }\n    }, S && p <= 50 && (p++, typeof S == \"object\" && (S.placement && (f = S.placement), S.rects && (c = S.rects === !0 ? await o.getElementRects({\n      reference: t,\n      floating: e,\n      strategy: i\n    }) : S.rects), {\n      x: u,\n      y: d\n    } = xb(c, f, l)), O = -1);\n  }\n  return {\n    x: u,\n    y: d,\n    placement: f,\n    strategy: i,\n    middlewareData: h\n  };\n};\nasync function Ow(t, e) {\n  var n;\n  e === void 0 && (e = {});\n  const {\n    x: r,\n    y: i,\n    platform: s,\n    rects: o,\n    elements: a,\n    strategy: l\n  } = t, {\n    boundary: c = \"clippingAncestors\",\n    rootBoundary: u = \"viewport\",\n    elementContext: d = \"floating\",\n    altBoundary: f = !1,\n    padding: h = 0\n  } = Id(e, t), p = P2(h), m = a[f ? d === \"floating\" ? \"reference\" : \"floating\" : d], y = Du(await s.getClippingRect({\n    element: (n = await (s.isElement == null ? void 0 : s.isElement(m))) == null || n ? m : m.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(a.floating)),\n    boundary: c,\n    rootBoundary: u,\n    strategy: l\n  })), b = d === \"floating\" ? {\n    ...o.floating,\n    x: r,\n    y: i\n  } : o.reference, g = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(a.floating)), v = await (s.isElement == null ? void 0 : s.isElement(g)) ? await (s.getScale == null ? void 0 : s.getScale(g)) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  }, S = Du(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements: a,\n    rect: b,\n    offsetParent: g,\n    strategy: l\n  }) : b);\n  return {\n    top: (y.top - S.top + p.top) / v.y,\n    bottom: (S.bottom - y.bottom + p.bottom) / v.y,\n    left: (y.left - S.left + p.left) / v.x,\n    right: (S.right - y.right + p.right) / v.x\n  };\n}\nconst T2 = function(t) {\n  return t === void 0 && (t = {}), {\n    name: \"flip\",\n    options: t,\n    async fn(e) {\n      var n, r;\n      const {\n        placement: i,\n        middlewareData: s,\n        rects: o,\n        initialPlacement: a,\n        platform: l,\n        elements: c\n      } = e, {\n        mainAxis: u = !0,\n        crossAxis: d = !0,\n        fallbackPlacements: f,\n        fallbackStrategy: h = \"bestFit\",\n        fallbackAxisSideDirection: p = \"none\",\n        flipAlignment: O = !0,\n        ...m\n      } = Id(t, e);\n      if ((n = s.arrow) != null && n.alignmentOffset)\n        return {};\n      const y = Ls(i), b = Ls(a) === a, g = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)), v = f || (b || !O ? [Nu(a)] : S2(a));\n      !f && p !== \"none\" && v.push(...k2(a, O, p, g));\n      const S = [a, ...v], w = await Ow(e, m), k = [];\n      let _ = ((r = s.flip) == null ? void 0 : r.overflows) || [];\n      if (u && k.push(w[y]), d) {\n        const Q = y2(i, o, g);\n        k.push(w[Q[0]], w[Q[1]]);\n      }\n      if (_ = [..._, {\n        placement: i,\n        overflows: k\n      }], !k.every((Q) => Q <= 0)) {\n        var T, C;\n        const Q = (((T = s.flip) == null ? void 0 : T.index) || 0) + 1, W = S[Q];\n        if (W)\n          return {\n            data: {\n              index: Q,\n              overflows: _\n            },\n            reset: {\n              placement: W\n            }\n          };\n        let L = (C = _.filter((re) => re.overflows[0] <= 0).sort((re, Y) => re.overflows[1] - Y.overflows[1])[0]) == null ? void 0 : C.placement;\n        if (!L)\n          switch (h) {\n            case \"bestFit\": {\n              var A;\n              const re = (A = _.map((Y) => [Y.placement, Y.overflows.filter((K) => K > 0).reduce((K, B) => K + B, 0)]).sort((Y, K) => Y[1] - K[1])[0]) == null ? void 0 : A[0];\n              re && (L = re);\n              break;\n            }\n            case \"initialPlacement\":\n              L = a;\n              break;\n          }\n        if (i !== L)\n          return {\n            reset: {\n              placement: L\n            }\n          };\n      }\n      return {};\n    }\n  };\n};\nasync function E2(t, e) {\n  const {\n    placement: n,\n    platform: r,\n    elements: i\n  } = t, s = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)), o = Ls(n), a = Wd(n), l = Md(n) === \"y\", c = [\"left\", \"top\"].includes(o) ? -1 : 1, u = s && l ? -1 : 1, d = Id(e, t);\n  let {\n    mainAxis: f,\n    crossAxis: h,\n    alignmentAxis: p\n  } = typeof d == \"number\" ? {\n    mainAxis: d,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...d\n  };\n  return a && typeof p == \"number\" && (h = a === \"end\" ? p * -1 : p), l ? {\n    x: h * u,\n    y: f * c\n  } : {\n    x: f * c,\n    y: h * u\n  };\n}\nconst $2 = function(t) {\n  return t === void 0 && (t = 0), {\n    name: \"offset\",\n    options: t,\n    async fn(e) {\n      var n, r;\n      const {\n        x: i,\n        y: s,\n        placement: o,\n        middlewareData: a\n      } = e, l = await E2(e, t);\n      return o === ((n = a.offset) == null ? void 0 : n.placement) && (r = a.arrow) != null && r.alignmentOffset ? {} : {\n        x: i + l.x,\n        y: s + l.y,\n        data: {\n          ...l,\n          placement: o\n        }\n      };\n    }\n  };\n}, Q2 = function(t) {\n  return t === void 0 && (t = {}), {\n    name: \"shift\",\n    options: t,\n    async fn(e) {\n      const {\n        x: n,\n        y: r,\n        placement: i\n      } = e, {\n        mainAxis: s = !0,\n        crossAxis: o = !1,\n        limiter: a = {\n          fn: (m) => {\n            let {\n              x: y,\n              y: b\n            } = m;\n            return {\n              x: y,\n              y: b\n            };\n          }\n        },\n        ...l\n      } = Id(t, e), c = {\n        x: n,\n        y: r\n      }, u = await Ow(e, l), d = Md(Ls(i)), f = fw(d);\n      let h = c[f], p = c[d];\n      if (s) {\n        const m = f === \"y\" ? \"top\" : \"left\", y = f === \"y\" ? \"bottom\" : \"right\", b = h + u[m], g = h - u[y];\n        h = kb(b, h, g);\n      }\n      if (o) {\n        const m = d === \"y\" ? \"top\" : \"left\", y = d === \"y\" ? \"bottom\" : \"right\", b = p + u[m], g = p - u[y];\n        p = kb(b, p, g);\n      }\n      const O = a.fn({\n        ...e,\n        [f]: h,\n        [d]: p\n      });\n      return {\n        ...O,\n        data: {\n          x: O.x - n,\n          y: O.y - r\n        }\n      };\n    }\n  };\n};\nfunction ui(t) {\n  return HO(t) ? (t.nodeName || \"\").toLowerCase() : \"#document\";\n}\nfunction Mn(t) {\n  var e;\n  return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window;\n}\nfunction mi(t) {\n  var e;\n  return (e = (HO(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement;\n}\nfunction HO(t) {\n  return t instanceof Node || t instanceof Mn(t).Node;\n}\nfunction di(t) {\n  return t instanceof Element || t instanceof Mn(t).Element;\n}\nfunction jr(t) {\n  return t instanceof HTMLElement || t instanceof Mn(t).HTMLElement;\n}\nfunction Pb(t) {\n  return typeof ShadowRoot > \"u\" ? !1 : t instanceof ShadowRoot || t instanceof Mn(t).ShadowRoot;\n}\nfunction ql(t) {\n  const {\n    overflow: e,\n    overflowX: n,\n    overflowY: r,\n    display: i\n  } = nr(t);\n  return /auto|scroll|overlay|hidden|clip/.test(e + r + n) && ![\"inline\", \"contents\"].includes(i);\n}\nfunction C2(t) {\n  return [\"table\", \"td\", \"th\"].includes(ui(t));\n}\nfunction FO(t) {\n  const e = GO(), n = nr(t);\n  return n.transform !== \"none\" || n.perspective !== \"none\" || (n.containerType ? n.containerType !== \"normal\" : !1) || !e && (n.backdropFilter ? n.backdropFilter !== \"none\" : !1) || !e && (n.filter ? n.filter !== \"none\" : !1) || [\"transform\", \"perspective\", \"filter\"].some((r) => (n.willChange || \"\").includes(r)) || [\"paint\", \"layout\", \"strict\", \"content\"].some((r) => (n.contain || \"\").includes(r));\n}\nfunction A2(t) {\n  let e = Wo(t);\n  for (; jr(e) && !Xd(e); ) {\n    if (FO(e))\n      return e;\n    e = Wo(e);\n  }\n  return null;\n}\nfunction GO() {\n  return typeof CSS > \"u\" || !CSS.supports ? !1 : CSS.supports(\"-webkit-backdrop-filter\", \"none\");\n}\nfunction Xd(t) {\n  return [\"html\", \"body\", \"#document\"].includes(ui(t));\n}\nfunction nr(t) {\n  return Mn(t).getComputedStyle(t);\n}\nfunction jd(t) {\n  return di(t) ? {\n    scrollLeft: t.scrollLeft,\n    scrollTop: t.scrollTop\n  } : {\n    scrollLeft: t.pageXOffset,\n    scrollTop: t.pageYOffset\n  };\n}\nfunction Wo(t) {\n  if (ui(t) === \"html\")\n    return t;\n  const e = (\n    // Step into the shadow DOM of the parent of a slotted node.\n    t.assignedSlot || // DOM Element detected.\n    t.parentNode || // ShadowRoot detected.\n    Pb(t) && t.host || // Fallback.\n    mi(t)\n  );\n  return Pb(e) ? e.host : e;\n}\nfunction gw(t) {\n  const e = Wo(t);\n  return Xd(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : jr(e) && ql(e) ? e : gw(e);\n}\nfunction ul(t, e, n) {\n  var r;\n  e === void 0 && (e = []), n === void 0 && (n = !0);\n  const i = gw(t), s = i === ((r = t.ownerDocument) == null ? void 0 : r.body), o = Mn(i);\n  return s ? e.concat(o, o.visualViewport || [], ql(i) ? i : [], o.frameElement && n ? ul(o.frameElement) : []) : e.concat(i, ul(i, [], n));\n}\nfunction mw(t) {\n  const e = nr(t);\n  let n = parseFloat(e.width) || 0, r = parseFloat(e.height) || 0;\n  const i = jr(t), s = i ? t.offsetWidth : n, o = i ? t.offsetHeight : r, a = Ru(n) !== s || Ru(r) !== o;\n  return a && (n = s, r = o), {\n    width: n,\n    height: r,\n    $: a\n  };\n}\nfunction KO(t) {\n  return di(t) ? t : t.contextElement;\n}\nfunction xo(t) {\n  const e = KO(t);\n  if (!jr(e))\n    return is(1);\n  const n = e.getBoundingClientRect(), {\n    width: r,\n    height: i,\n    $: s\n  } = mw(e);\n  let o = (s ? Ru(n.width) : n.width) / r, a = (s ? Ru(n.height) : n.height) / i;\n  return (!o || !Number.isFinite(o)) && (o = 1), (!a || !Number.isFinite(a)) && (a = 1), {\n    x: o,\n    y: a\n  };\n}\nconst R2 = /* @__PURE__ */ is(0);\nfunction bw(t) {\n  const e = Mn(t);\n  return !GO() || !e.visualViewport ? R2 : {\n    x: e.visualViewport.offsetLeft,\n    y: e.visualViewport.offsetTop\n  };\n}\nfunction N2(t, e, n) {\n  return e === void 0 && (e = !1), !n || e && n !== Mn(t) ? !1 : e;\n}\nfunction Us(t, e, n, r) {\n  e === void 0 && (e = !1), n === void 0 && (n = !1);\n  const i = t.getBoundingClientRect(), s = KO(t);\n  let o = is(1);\n  e && (r ? di(r) && (o = xo(r)) : o = xo(t));\n  const a = N2(s, n, r) ? bw(s) : is(0);\n  let l = (i.left + a.x) / o.x, c = (i.top + a.y) / o.y, u = i.width / o.x, d = i.height / o.y;\n  if (s) {\n    const f = Mn(s), h = r && di(r) ? Mn(r) : r;\n    let p = f, O = p.frameElement;\n    for (; O && r && h !== p; ) {\n      const m = xo(O), y = O.getBoundingClientRect(), b = nr(O), g = y.left + (O.clientLeft + parseFloat(b.paddingLeft)) * m.x, v = y.top + (O.clientTop + parseFloat(b.paddingTop)) * m.y;\n      l *= m.x, c *= m.y, u *= m.x, d *= m.y, l += g, c += v, p = Mn(O), O = p.frameElement;\n    }\n  }\n  return Du({\n    width: u,\n    height: d,\n    x: l,\n    y: c\n  });\n}\nconst D2 = [\":popover-open\", \":modal\"];\nfunction vw(t) {\n  return D2.some((e) => {\n    try {\n      return t.matches(e);\n    } catch {\n      return !1;\n    }\n  });\n}\nfunction Z2(t) {\n  let {\n    elements: e,\n    rect: n,\n    offsetParent: r,\n    strategy: i\n  } = t;\n  const s = i === \"fixed\", o = mi(r), a = e ? vw(e.floating) : !1;\n  if (r === o || a && s)\n    return n;\n  let l = {\n    scrollLeft: 0,\n    scrollTop: 0\n  }, c = is(1);\n  const u = is(0), d = jr(r);\n  if ((d || !d && !s) && ((ui(r) !== \"body\" || ql(o)) && (l = jd(r)), jr(r))) {\n    const f = Us(r);\n    c = xo(r), u.x = f.x + r.clientLeft, u.y = f.y + r.clientTop;\n  }\n  return {\n    width: n.width * c.x,\n    height: n.height * c.y,\n    x: n.x * c.x - l.scrollLeft * c.x + u.x,\n    y: n.y * c.y - l.scrollTop * c.y + u.y\n  };\n}\nfunction V2(t) {\n  return Array.from(t.getClientRects());\n}\nfunction yw(t) {\n  return Us(mi(t)).left + jd(t).scrollLeft;\n}\nfunction I2(t) {\n  const e = mi(t), n = jd(t), r = t.ownerDocument.body, i = Is(e.scrollWidth, e.clientWidth, r.scrollWidth, r.clientWidth), s = Is(e.scrollHeight, e.clientHeight, r.scrollHeight, r.clientHeight);\n  let o = -n.scrollLeft + yw(t);\n  const a = -n.scrollTop;\n  return nr(r).direction === \"rtl\" && (o += Is(e.clientWidth, r.clientWidth) - i), {\n    width: i,\n    height: s,\n    x: o,\n    y: a\n  };\n}\nfunction W2(t, e) {\n  const n = Mn(t), r = mi(t), i = n.visualViewport;\n  let s = r.clientWidth, o = r.clientHeight, a = 0, l = 0;\n  if (i) {\n    s = i.width, o = i.height;\n    const c = GO();\n    (!c || c && e === \"fixed\") && (a = i.offsetLeft, l = i.offsetTop);\n  }\n  return {\n    width: s,\n    height: o,\n    x: a,\n    y: l\n  };\n}\nfunction M2(t, e) {\n  const n = Us(t, !0, e === \"fixed\"), r = n.top + t.clientTop, i = n.left + t.clientLeft, s = jr(t) ? xo(t) : is(1), o = t.clientWidth * s.x, a = t.clientHeight * s.y, l = i * s.x, c = r * s.y;\n  return {\n    width: o,\n    height: a,\n    x: l,\n    y: c\n  };\n}\nfunction _b(t, e, n) {\n  let r;\n  if (e === \"viewport\")\n    r = W2(t, n);\n  else if (e === \"document\")\n    r = I2(mi(t));\n  else if (di(e))\n    r = M2(e, n);\n  else {\n    const i = bw(t);\n    r = {\n      ...e,\n      x: e.x - i.x,\n      y: e.y - i.y\n    };\n  }\n  return Du(r);\n}\nfunction Sw(t, e) {\n  const n = Wo(t);\n  return n === e || !di(n) || Xd(n) ? !1 : nr(n).position === \"fixed\" || Sw(n, e);\n}\nfunction X2(t, e) {\n  const n = e.get(t);\n  if (n)\n    return n;\n  let r = ul(t, [], !1).filter((a) => di(a) && ui(a) !== \"body\"), i = null;\n  const s = nr(t).position === \"fixed\";\n  let o = s ? Wo(t) : t;\n  for (; di(o) && !Xd(o); ) {\n    const a = nr(o), l = FO(o);\n    !l && a.position === \"fixed\" && (i = null), (s ? !l && !i : !l && a.position === \"static\" && !!i && [\"absolute\", \"fixed\"].includes(i.position) || ql(o) && !l && Sw(t, o)) ? r = r.filter((u) => u !== o) : i = a, o = Wo(o);\n  }\n  return e.set(t, r), r;\n}\nfunction j2(t) {\n  let {\n    element: e,\n    boundary: n,\n    rootBoundary: r,\n    strategy: i\n  } = t;\n  const o = [...n === \"clippingAncestors\" ? X2(e, this._c) : [].concat(n), r], a = o[0], l = o.reduce((c, u) => {\n    const d = _b(e, u, i);\n    return c.top = Is(d.top, c.top), c.right = Au(d.right, c.right), c.bottom = Au(d.bottom, c.bottom), c.left = Is(d.left, c.left), c;\n  }, _b(e, a, i));\n  return {\n    width: l.right - l.left,\n    height: l.bottom - l.top,\n    x: l.left,\n    y: l.top\n  };\n}\nfunction B2(t) {\n  const {\n    width: e,\n    height: n\n  } = mw(t);\n  return {\n    width: e,\n    height: n\n  };\n}\nfunction L2(t, e, n) {\n  const r = jr(e), i = mi(e), s = n === \"fixed\", o = Us(t, !0, s, e);\n  let a = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const l = is(0);\n  if (r || !r && !s)\n    if ((ui(e) !== \"body\" || ql(i)) && (a = jd(e)), r) {\n      const d = Us(e, !0, s, e);\n      l.x = d.x + e.clientLeft, l.y = d.y + e.clientTop;\n    } else\n      i && (l.x = yw(i));\n  const c = o.left + a.scrollLeft - l.x, u = o.top + a.scrollTop - l.y;\n  return {\n    x: c,\n    y: u,\n    width: o.width,\n    height: o.height\n  };\n}\nfunction Tb(t, e) {\n  return !jr(t) || nr(t).position === \"fixed\" ? null : e ? e(t) : t.offsetParent;\n}\nfunction ww(t, e) {\n  const n = Mn(t);\n  if (!jr(t) || vw(t))\n    return n;\n  let r = Tb(t, e);\n  for (; r && C2(r) && nr(r).position === \"static\"; )\n    r = Tb(r, e);\n  return r && (ui(r) === \"html\" || ui(r) === \"body\" && nr(r).position === \"static\" && !FO(r)) ? n : r || A2(t) || n;\n}\nconst U2 = async function(t) {\n  const e = this.getOffsetParent || ww, n = this.getDimensions;\n  return {\n    reference: L2(t.reference, await e(t.floating), t.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      ...await n(t.floating)\n    }\n  };\n};\nfunction q2(t) {\n  return nr(t).direction === \"rtl\";\n}\nconst Y2 = {\n  convertOffsetParentRelativeRectToViewportRelativeRect: Z2,\n  getDocumentElement: mi,\n  getClippingRect: j2,\n  getOffsetParent: ww,\n  getElementRects: U2,\n  getClientRects: V2,\n  getDimensions: B2,\n  getScale: xo,\n  isElement: di,\n  isRTL: q2\n};\nfunction z2(t, e) {\n  let n = null, r;\n  const i = mi(t);\n  function s() {\n    var a;\n    clearTimeout(r), (a = n) == null || a.disconnect(), n = null;\n  }\n  function o(a, l) {\n    a === void 0 && (a = !1), l === void 0 && (l = 1), s();\n    const {\n      left: c,\n      top: u,\n      width: d,\n      height: f\n    } = t.getBoundingClientRect();\n    if (a || e(), !d || !f)\n      return;\n    const h = wc(u), p = wc(i.clientWidth - (c + d)), O = wc(i.clientHeight - (u + f)), m = wc(c), b = {\n      rootMargin: -h + \"px \" + -p + \"px \" + -O + \"px \" + -m + \"px\",\n      threshold: Is(0, Au(1, l)) || 1\n    };\n    let g = !0;\n    function v(S) {\n      const w = S[0].intersectionRatio;\n      if (w !== l) {\n        if (!g)\n          return o();\n        w ? o(!1, w) : r = setTimeout(() => {\n          o(!1, 1e-7);\n        }, 100);\n      }\n      g = !1;\n    }\n    try {\n      n = new IntersectionObserver(v, {\n        ...b,\n        // Handle <iframe>s\n        root: i.ownerDocument\n      });\n    } catch {\n      n = new IntersectionObserver(v, b);\n    }\n    n.observe(t);\n  }\n  return o(!0), s;\n}\nfunction H2(t, e, n, r) {\n  r === void 0 && (r = {});\n  const {\n    ancestorScroll: i = !0,\n    ancestorResize: s = !0,\n    elementResize: o = typeof ResizeObserver == \"function\",\n    layoutShift: a = typeof IntersectionObserver == \"function\",\n    animationFrame: l = !1\n  } = r, c = KO(t), u = i || s ? [...c ? ul(c) : [], ...ul(e)] : [];\n  u.forEach((y) => {\n    i && y.addEventListener(\"scroll\", n, {\n      passive: !0\n    }), s && y.addEventListener(\"resize\", n);\n  });\n  const d = c && a ? z2(c, n) : null;\n  let f = -1, h = null;\n  o && (h = new ResizeObserver((y) => {\n    let [b] = y;\n    b && b.target === c && h && (h.unobserve(e), cancelAnimationFrame(f), f = requestAnimationFrame(() => {\n      var g;\n      (g = h) == null || g.observe(e);\n    })), n();\n  }), c && !l && h.observe(c), h.observe(e));\n  let p, O = l ? Us(t) : null;\n  l && m();\n  function m() {\n    const y = Us(t);\n    O && (y.x !== O.x || y.y !== O.y || y.width !== O.width || y.height !== O.height) && n(), O = y, p = requestAnimationFrame(m);\n  }\n  return n(), () => {\n    var y;\n    u.forEach((b) => {\n      i && b.removeEventListener(\"scroll\", n), s && b.removeEventListener(\"resize\", n);\n    }), d == null || d(), (y = h) == null || y.disconnect(), h = null, l && cancelAnimationFrame(p);\n  };\n}\nconst F2 = Q2, G2 = T2, K2 = (t, e, n) => {\n  const r = /* @__PURE__ */ new Map(), i = {\n    platform: Y2,\n    ...n\n  }, s = {\n    ...i.platform,\n    _c: r\n  };\n  return _2(t, e, {\n    ...i,\n    platform: s\n  });\n};\nfunction J2(t) {\n  return t != null && typeof t == \"object\" && \"$el\" in t;\n}\nfunction Eb(t) {\n  if (J2(t)) {\n    const e = t.$el;\n    return HO(e) && ui(e) === \"#comment\" ? null : e;\n  }\n  return t;\n}\nfunction kw(t) {\n  return typeof window > \"u\" ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1;\n}\nfunction $b(t, e) {\n  const n = kw(t);\n  return Math.round(e * n) / n;\n}\nfunction eR(t, e, n) {\n  n === void 0 && (n = {});\n  const r = n.whileElementsMounted, i = j(() => {\n    var k;\n    return (k = R(n.open)) != null ? k : !0;\n  }), s = j(() => R(n.middleware)), o = j(() => {\n    var k;\n    return (k = R(n.placement)) != null ? k : \"bottom\";\n  }), a = j(() => {\n    var k;\n    return (k = R(n.strategy)) != null ? k : \"absolute\";\n  }), l = j(() => {\n    var k;\n    return (k = R(n.transform)) != null ? k : !0;\n  }), c = j(() => Eb(t.value)), u = j(() => Eb(e.value)), d = G(0), f = G(0), h = G(a.value), p = G(o.value), O = cO({}), m = G(!1), y = j(() => {\n    const k = {\n      position: h.value,\n      left: \"0\",\n      top: \"0\"\n    };\n    if (!u.value)\n      return k;\n    const _ = $b(u.value, d.value), T = $b(u.value, f.value);\n    return l.value ? {\n      ...k,\n      transform: \"translate(\" + _ + \"px, \" + T + \"px)\",\n      ...kw(u.value) >= 1.5 && {\n        willChange: \"transform\"\n      }\n    } : {\n      position: h.value,\n      left: _ + \"px\",\n      top: T + \"px\"\n    };\n  });\n  let b;\n  function g() {\n    c.value == null || u.value == null || K2(c.value, u.value, {\n      middleware: s.value,\n      placement: o.value,\n      strategy: a.value\n    }).then((k) => {\n      d.value = k.x, f.value = k.y, h.value = k.strategy, p.value = k.placement, O.value = k.middlewareData, m.value = !0;\n    });\n  }\n  function v() {\n    typeof b == \"function\" && (b(), b = void 0);\n  }\n  function S() {\n    if (v(), r === void 0) {\n      g();\n      return;\n    }\n    if (c.value != null && u.value != null) {\n      b = r(c.value, u.value, g);\n      return;\n    }\n  }\n  function w() {\n    i.value || (m.value = !1);\n  }\n  return ht([s, o, a], g, {\n    flush: \"sync\"\n  }), ht([c, u], S, {\n    flush: \"sync\"\n  }), ht(i, w, {\n    flush: \"sync\"\n  }), Rl() && tO(v), {\n    x: Dn(d),\n    y: Dn(f),\n    strategy: Dn(h),\n    placement: Dn(p),\n    middlewareData: Dn(O),\n    isPositioned: Dn(m),\n    floatingStyles: y,\n    update: g\n  };\n}\nvar JO = {};\n/*!\n * content-type\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\nvar Qb = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *(\"(?:[\\u000b\\u0020\\u0021\\u0023-\\u005b\\u005d-\\u007e\\u0080-\\u00ff]|\\\\[\\u000b\\u0020-\\u00ff])*\"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g, tR = /^[\\u000b\\u0020-\\u007e\\u0080-\\u00ff]+$/, xw = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/, nR = /\\\\([\\u000b\\u0020-\\u00ff])/g, rR = /([\\\\\"])/g, Pw = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;\nJO.format = iR;\nJO.parse = sR;\nfunction iR(t) {\n  if (!t || typeof t != \"object\")\n    throw new TypeError(\"argument obj is required\");\n  var e = t.parameters, n = t.type;\n  if (!n || !Pw.test(n))\n    throw new TypeError(\"invalid type\");\n  var r = n;\n  if (e && typeof e == \"object\")\n    for (var i, s = Object.keys(e).sort(), o = 0; o < s.length; o++) {\n      if (i = s[o], !xw.test(i))\n        throw new TypeError(\"invalid parameter name\");\n      r += \"; \" + i + \"=\" + aR(e[i]);\n    }\n  return r;\n}\nfunction sR(t) {\n  if (!t)\n    throw new TypeError(\"argument string is required\");\n  var e = typeof t == \"object\" ? oR(t) : t;\n  if (typeof e != \"string\")\n    throw new TypeError(\"argument string is required to be a string\");\n  var n = e.indexOf(\";\"), r = n !== -1 ? e.slice(0, n).trim() : e.trim();\n  if (!Pw.test(r))\n    throw new TypeError(\"invalid media type\");\n  var i = new lR(r.toLowerCase());\n  if (n !== -1) {\n    var s, o, a;\n    for (Qb.lastIndex = n; o = Qb.exec(e); ) {\n      if (o.index !== n)\n        throw new TypeError(\"invalid parameter format\");\n      n += o[0].length, s = o[1].toLowerCase(), a = o[2], a.charCodeAt(0) === 34 && (a = a.slice(1, -1), a.indexOf(\"\\\\\") !== -1 && (a = a.replace(nR, \"$1\"))), i.parameters[s] = a;\n    }\n    if (n !== e.length)\n      throw new TypeError(\"invalid parameter format\");\n  }\n  return i;\n}\nfunction oR(t) {\n  var e;\n  if (typeof t.getHeader == \"function\" ? e = t.getHeader(\"content-type\") : typeof t.headers == \"object\" && (e = t.headers && t.headers[\"content-type\"]), typeof e != \"string\")\n    throw new TypeError(\"content-type header is missing from object\");\n  return e;\n}\nfunction aR(t) {\n  var e = String(t);\n  if (xw.test(e))\n    return e;\n  if (e.length > 0 && !tR.test(e))\n    throw new TypeError(\"invalid parameter value\");\n  return '\"' + e.replace(rR, \"\\\\$1\") + '\"';\n}\nfunction lR(t) {\n  this.parameters = /* @__PURE__ */ Object.create(null), this.type = t;\n}\nvar cR = Object.defineProperty, uR = (t, e, n) => e in t ? cR(t, e, { enumerable: !0, configurable: !0, writable: !0, value: n }) : t[e] = n, _w = (t, e, n) => (uR(t, typeof e != \"symbol\" ? e + \"\" : e, n), n);\nconst dR = `/* basic theme */\n:root {\n  --scalar-text-decoration: underline;\n  --scalar-text-decoration-hover: underline;\n}\n.light-mode,\n.light-mode .dark-mode {\n  --scalar-background-1: #f9f9f9;\n  --scalar-background-2: #f1f1f1;\n  --scalar-background-3: #e7e7e7;\n  --scalar-background-card: #fff;\n\n  --scalar-color-1: #2a2f45;\n  --scalar-color-2: #757575;\n  --scalar-color-3: #8e8e8e;\n\n  --scalar-color-accent: var(--scalar-color-1);\n  --scalar-background-accent: var(--scalar-background-3);\n\n  --scalar-border-color: rgba(0, 0, 0, 0.1);\n  --scalar-code-languages-background-supersede: var(--scalar-background-1);\n  --scalar-code-language-color-supersede: var(--scalar-color-1);\n}\n.dark-mode {\n  --scalar-background-1: #131313;\n  --scalar-background-2: #1d1d1d;\n  --scalar-background-3: #272727;\n  --scalar-background-card: #1d1d1d;\n\n  --scalar-color-1: rgba(255, 255, 255, 0.9);\n  --scalar-color-2: rgba(255, 255, 255, 0.62);\n  --scalar-color-3: rgba(255, 255, 255, 0.44);\n\n  --scalar-color-accent: var(--scalar-color-1);\n  --scalar-background-accent: var(--scalar-background-3);\n\n  --scalar-border-color: rgba(255, 255, 255, 0.1);\n  --scalar-code-languages-background-supersede: var(--scalar-background-3);\n  --scalar-code-language-color-supersede: var(--scalar-color-3);\n}\n/* Document Sidebar */\n.light-mode .t-doc__sidebar,\n.dark-mode .t-doc__sidebar {\n  --scalar-sidebar-background-1: var(--scalar-background-1);\n  --scalar-sidebar-color-1: var(--scalar-color-1);\n  --scalar-sidebar-color-2: var(--scalar-color-2);\n  --scalar-sidebar-border-color: var(--scalar-border-color);\n\n  --scalar-sidebar-item-hover-background: var(--scalar-background-2);\n  --scalar-sidebar-item-hover-color: currentColor;\n\n  --scalar-sidebar-item-active-background: var(--scalar-background-accent);\n  --scalar-sidebar-color-active: var(--scalar-color-accent);\n\n  --scalar-sidebar-search-background: transparent;\n  --scalar-sidebar-search-color: var(--scalar-color-3);\n  --scalar-sidebar-search-border-color: var(--scalar-border-color);\n\n  --scalar-sidebar-indent-border: var(--scalar-sidebar-border-color);\n  --scalar-sidebar-indent-border-hover: var(--scalar-sidebar-border-color);\n  --scalar-sidebar-indent-border-active: var(--scalar-sidebar-border-color);\n}\n/* advanced */\n.light-mode .dark-mode,\n.light-mode {\n  --scalar-color-green: #069061;\n  --scalar-color-red: #ef0006;\n  --scalar-color-yellow: #edbe20;\n  --scalar-color-blue: #0082d0;\n  --scalar-color-orange: #fb892c;\n  --scalar-color-purple: #5203d1;\n\n  --scalar-button-1: rgba(0, 0, 0, 1);\n  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);\n  --scalar-button-1-color: rgba(255, 255, 255, 0.9);\n}\n.dark-mode {\n  --scalar-color-green: #00b648;\n  --scalar-color-red: #dd2f2c;\n  --scalar-color-yellow: #ffc90d;\n  --scalar-color-blue: #4eb3ec;\n  --scalar-color-orange: #ff8d4d;\n  --scalar-color-purple: #b191f9;\n\n  --scalar-button-1: rgba(255, 255, 255, 1);\n  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);\n  --scalar-button-1-color: black;\n}\n\n.code-languages-background:before {\n  box-shadow: inset 0 0 0 1px var(--scalar-border-color) !important;\n}\n.scalar-api-client__item,\n.scalar-card,\n.dark-mode .dark-mode.scalar-card {\n  --scalar-background-1: var(--scalar-background-card);\n  --scalar-background-2: var(--scalar-background-1);\n  --scalar-background-3: var(--scalar-background-1);\n}\n.dark-mode .dark-mode.scalar-card {\n  --scalar-background-3: var(--scalar-background-3);\n}\n.t-doc__sidebar {\n  --scalar-color-green: var(--scalar-color-1);\n  --scalar-color-red: var(--scalar-color-1);\n  --scalar-color-yellow: var(--scalar-color-1);\n  --scalar-color-blue: var(--scalar-color-1);\n  --scalar-color-orange: var(--scalar-color-1);\n  --scalar-color-purple: var(--scalar-color-1);\n}\n`, fR = `/* basic theme */\n:root {\n  --scalar-text-decoration: underline;\n  --scalar-text-decoration-hover: underline;\n}\n.light-mode {\n  --scalar-background-1: #f0f2f5;\n  --scalar-background-2: #eaecf0;\n  --scalar-background-3: #e0e2e6;\n  --scalar-border-color: rgb(228, 228, 231);\n\n  --scalar-color-1: rgb(9, 9, 11);\n  --scalar-color-2: rgb(113, 113, 122);\n  --scalar-color-3: rgba(25, 25, 28, 0.5);\n\n  --scalar-color-accent: var(--scalar-color-1);\n  --scalar-background-accent: #8ab4f81f;\n\n  --scalar-code-language-color-supersede: var(--scalar-color-1);\n}\n.light-mode .scalar-card.dark-mode,\n.dark-mode {\n  --scalar-background-1: #000e23;\n  --scalar-background-2: #01132e;\n  --scalar-background-3: #03193b;\n  --scalar-border-color: rgba(255, 255, 255, 0.12);\n\n  --scalar-color-1: #fafafa;\n  --scalar-color-2: rgb(161, 161, 170);\n  --scalar-color-3: rgba(255, 255, 255, 0.533);\n\n  --scalar-color-accent: var(--scalar-color-1);\n  --scalar-background-accent: #8ab4f81f;\n\n  --scalar-code-language-color-supersede: var(--scalar-color-1);\n}\n/* Document Sidebar */\n.light-mode .t-doc__sidebar,\n.dark-mode .t-doc__sidebar {\n  --scalar-sidebar-background-1: var(--scalar-background-1);\n  --scalar-sidebar-color-1: var(--scalar-color-1);\n  --scalar-sidebar-color-2: var(--scalar-color-2);\n  --scalar-sidebar-border-color: var(--scalar-border-color);\n\n  --scalar-sidebar-item-hover-background: var(--scalar-background-2);\n  --scalar-sidebar-item-hover-color: currentColor;\n\n  --scalar-sidebar-item-active-background: var(--scalar-background-3);\n  --scalar-sidebar-color-active: var(--scalar-color-accent);\n\n  --scalar-sidebar-search-background: rgba(255, 255, 255, 0.1);\n  --scalar-sidebar-search-border-color: var(--scalar-border-color);\n  --scalar-sidebar-search-color: var(--scalar-color-3);\n  z-index: 1;\n}\n.light-mode .t-doc__sidebar {\n  --scalar-sidebar-search-background: white;\n}\n/* advanced */\n.light-mode {\n  --scalar-color-green: #069061;\n  --scalar-color-red: #ef0006;\n  --scalar-color-yellow: #edbe20;\n  --scalar-color-blue: #0082d0;\n  --scalar-color-orange: #fb892c;\n  --scalar-color-purple: #5203d1;\n\n  --scalar-button-1: rgba(0, 0, 0, 1);\n  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);\n  --scalar-button-1-color: rgba(255, 255, 255, 0.9);\n}\n.dark-mode {\n  --scalar-color-green: rgba(69, 255, 165, 0.823);\n  --scalar-color-red: #ff8589;\n  --scalar-color-yellow: #ffcc4d;\n  --scalar-color-blue: #6bc1fe;\n  --scalar-color-orange: #f98943;\n  --scalar-color-purple: #b191f9;\n\n  --scalar-button-1: rgba(255, 255, 255, 1);\n  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);\n  --scalar-button-1-color: black;\n}\n/* Custom theme */\n/* Document header */\n@keyframes headerbackground {\n  from {\n    background: transparent;\n    backdrop-filter: none;\n  }\n  to {\n    background: var(--header-background-1);\n    backdrop-filter: blur(12px);\n  }\n}\n.dark-mode h2.t-editor__heading,\n.dark-mode .t-editor__page-title h1,\n.dark-mode h1.section-header,\n.dark-mode .markdown h1,\n.dark-mode .markdown h2,\n.dark-mode .markdown h3,\n.dark-mode .markdown h4,\n.dark-mode .markdown h5,\n.dark-mode .markdown h6 {\n  -webkit-text-fill-color: transparent;\n  background-image: linear-gradient(\n    to right bottom,\n    rgb(255, 255, 255) 30%,\n    rgba(255, 255, 255, 0.38)\n  );\n  -webkit-background-clip: text;\n  background-clip: text;\n}\n.code-languages-background {\n  background: var(--scalar-background-1) !important;\n}\n.code-languages-background:before {\n  box-shadow: inset 0 0 0 2px var(--scalar-border-color);\n  background: linear-gradient(\n    to right top,\n    rgb(211 225 249 / 12%),\n    rgb(209 223 247 / 11%),\n    rgb(223 233 251 / 29%)\n  ) !important;\n}\n.light-mode .code-languages-background:before {\n  background: linear-gradient(\n    to right top,\n    rgb(0 0 0 / 8%),\n    rgb(0 0 0 / 7%),\n    rgb(0 0 0 / 19%)\n  ) !important;\n}\n.code-languages__active .code-languages-background:before {\n  background: var(--scalar-background-1) !important;\n}\n.code-languages span {\n  margin-top: 5px !important;\n}\n/* Hero Section Flare */\n.section-flare-item:nth-of-type(1) {\n  --c1: #ffffff;\n  --c2: #babfd8;\n  --c3: #2e8bb2;\n  --c4: #1a8593;\n  --c5: #0a143e;\n  --c6: #0a0f52;\n  --c7: #2341b8;\n\n  --solid: var(--c1), var(--c2), var(--c3), var(--c4), var(--c5), var(--c6),\n    var(--c7);\n  --solid-wrap: var(--solid), var(--c1);\n  --trans: var(--c1), transparent, var(--c2), transparent, var(--c3),\n    transparent, var(--c4), transparent, var(--c5), transparent, var(--c6),\n    transparent, var(--c7);\n  --trans-wrap: var(--trans), transparent, var(--c1);\n\n  background: radial-gradient(circle, var(--trans)),\n    conic-gradient(from 180deg, var(--trans-wrap)),\n    radial-gradient(circle, var(--trans)), conic-gradient(var(--solid-wrap));\n  width: 70vw;\n  height: 700px;\n  border-radius: 50%;\n  filter: blur(100px);\n  z-index: 0;\n  right: 0;\n  position: absolute;\n  transform: rotate(-45deg);\n  top: -300px;\n  opacity: 0.3;\n}\n.section-flare-item:nth-of-type(3) {\n  --star-color: #6b9acc;\n  --star-color2: #446b8d;\n  --star-color3: #3e5879;\n  background-image: radial-gradient(\n      2px 2px at 20px 30px,\n      var(--star-color2),\n      rgba(0, 0, 0, 0)\n    ),\n    radial-gradient(2px 2px at 40px 70px, var(--star-color), rgba(0, 0, 0, 0)),\n    radial-gradient(2px 2px at 50px 160px, var(--star-color3), rgba(0, 0, 0, 0)),\n    radial-gradient(2px 2px at 90px 40px, var(--star-color), rgba(0, 0, 0, 0)),\n    radial-gradient(2px 2px at 130px 80px, var(--star-color), rgba(0, 0, 0, 0)),\n    radial-gradient(\n      2px 2px at 160px 120px,\n      var(--star-color3),\n      rgba(0, 0, 0, 0)\n    );\n  background-repeat: repeat;\n  background-size: 200px 200px;\n  width: 100%;\n  height: 100%;\n  mask-image: radial-gradient(ellipse at 100% 0%, black 40%, transparent 70%);\n}\n.section-flare {\n  top: -150px !important;\n  height: 100vh;\n  background: linear-gradient(#000, var(--scalar-background-1));\n  width: 100vw;\n}\n.light-mode .section-flare {\n  display: none;\n}\n.light-mode .scalar-card {\n  --scalar-background-1: #fff;\n  --scalar-background-2: #fff;\n  --scalar-background-3: #fff;\n}\n`, hR = `/* basic theme */\n:root {\n  --scalar-text-decoration: underline;\n  --scalar-text-decoration-hover: underline;\n}\n.light-mode {\n  --scalar-color-1: rgb(9, 9, 11);\n  --scalar-color-2: rgb(113, 113, 122);\n  --scalar-color-3: rgba(25, 25, 28, 0.5);\n  --scalar-color-accent: var(--scalar-color-1);\n\n  --scalar-background-1: #fff;\n  --scalar-background-2: #f4f4f5;\n  --scalar-background-3: #e3e3e6;\n  --scalar-background-accent: #8ab4f81f;\n\n  --scalar-border-color: rgb(228, 228, 231);\n  --scalar-code-language-color-supersede: var(--scalar-color-1);\n}\n.dark-mode {\n  --scalar-color-1: #fafafa;\n  --scalar-color-2: rgb(161, 161, 170);\n  --scalar-color-3: rgba(255, 255, 255, 0.533);\n  --scalar-color-accent: var(--scalar-color-1);\n\n  --scalar-background-1: #09090b;\n  --scalar-background-2: #18181b;\n  --scalar-background-3: #2c2c30;\n  --scalar-background-accent: #8ab4f81f;\n\n  --scalar-border-color: rgba(255, 255, 255, 0.12);\n  --scalar-code-language-color-supersede: var(--scalar-color-1);\n}\n\n/* Document Sidebar */\n.light-mode .t-doc__sidebar,\n.dark-mode .t-doc__sidebar {\n  --scalar-sidebar-background-1: var(--scalar-background-1);\n  --scalar-sidebar-color-1: var(--scalar-color-1);\n  --scalar-sidebar-color-2: var(--scalar-color-2);\n  --scalar-sidebar-border-color: var(--scalar-border-color);\n\n  --scalar-sidebar-item-hover-color: currentColor;\n  --scalar-sidebar-item-hover-background: var(--scalar-background-2);\n\n  --scalar-sidebar-item-active-background: var(--scalar-background-3);\n  --scalar-sidebar-color-active: var(--scalar-color-accent);\n\n  --scalar-sidebar-search-background: transparent;\n  --scalar-sidebar-search-border-color: var(--scalar-border-color);\n  --scalar-sidebar-search-color: var(--scalar-color-3);\n}\n.light-mode .t-doc__sidebar {\n  --scalar-sidebar-item-active-background: #09090b;\n  --scalar-sidebar-color-active: var(--scalar-sidebar-background-1);\n}\n/* advanced */\n.light-mode {\n  --scalar-color-green: #069061;\n  --scalar-color-red: #ef0006;\n  --scalar-color-yellow: #edbe20;\n  --scalar-color-blue: #0082d0;\n  --scalar-color-orange: #fb892c;\n  --scalar-color-purple: #5203d1;\n\n  --scalar-button-1: rgba(0, 0, 0, 1);\n  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);\n  --scalar-button-1-color: rgba(255, 255, 255, 0.9);\n}\n.dark-mode {\n  --scalar-color-green: rgba(69, 255, 165, 0.823);\n  --scalar-color-red: #ff8589;\n  --scalar-color-yellow: #ffcc4d;\n  --scalar-color-blue: #6bc1fe;\n  --scalar-color-orange: #f98943;\n  --scalar-color-purple: #b191f9;\n\n  --scalar-button-1: rgba(255, 255, 255, 1);\n  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);\n  --scalar-button-1-color: black;\n}\n/* Custom theme */\n.dark-mode h2.t-editor__heading,\n.dark-mode .t-editor__page-title h1,\n.dark-mode h1.section-header,\n.dark-mode .markdown h1,\n.dark-mode .markdown h2,\n.dark-mode .markdown h3,\n.dark-mode .markdown h4,\n.dark-mode .markdown h5,\n.dark-mode .markdown h6 {\n  -webkit-text-fill-color: transparent;\n  background-image: linear-gradient(\n    to right bottom,\n    rgb(255, 255, 255) 30%,\n    rgba(255, 255, 255, 0.38)\n  );\n  -webkit-background-clip: text;\n  background-clip: text;\n}\n.examples .scalar-card-footer {\n  --scalar-background-3: transparent;\n  padding-top: 0;\n}\n.code-languages-background {\n  background: var(--scalar-background-1) !important;\n}\n.code-languages-background:before {\n  box-shadow: inset 0 0 0 2px var(--scalar-border-color);\n  background: linear-gradient(\n    to right top,\n    rgb(211 225 249 / 12%),\n    rgb(209 223 247 / 11%),\n    rgb(223 233 251 / 29%)\n  ) !important;\n}\n.light-mode .code-languages-background:before {\n  background: linear-gradient(\n    to right top,\n    rgb(0 0 0 / 8%),\n    rgb(0 0 0 / 7%),\n    rgb(0 0 0 / 19%)\n  ) !important;\n}\n.code-languages__active .code-languages-background:before {\n  background: var(--scalar-background-1) !important;\n}\n.code-languages span {\n  margin-top: 5px !important;\n}\n/* Hero section flare */\n.section-flare {\n  width: 100vw;\n  height: 550px;\n  position: relative;\n}\n.section-flare-item:nth-of-type(1) {\n  position: absolute;\n  width: 100vw;\n  height: 550px;\n  --stripesDark: repeating-linear-gradient(\n    100deg,\n    #000 0%,\n    #000 7%,\n    transparent 10%,\n    transparent 12%,\n    #000 16%\n  );\n  --rainbow: repeating-linear-gradient(\n    100deg,\n    #fff 10%,\n    #fff 16%,\n    #fff 22%,\n    #fff 30%\n  );\n  background-image: var(--stripesDark), var(--rainbow);\n  background-size: 300%, 200%;\n  background-position:\n    50% 50%,\n    50% 50%;\n  filter: invert(100%);\n  -webkit-mask-image: radial-gradient(\n    ellipse at 100% 0%,\n    black 40%,\n    transparent 70%\n  );\n  mask-image: radial-gradient(ellipse at 100% 0%, black 40%, transparent 70%);\n  pointer-events: none;\n  opacity: 0.07;\n}\n.dark-mode .section-flare-item:nth-of-type(1) {\n  background-image: var(--stripesDark), var(--rainbow);\n  filter: opacity(50%) saturate(200%);\n  opacity: 0.25;\n  height: 350px;\n}\n.section-flare-item:nth-of-type(1):after {\n  content: '';\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n  background-image: var(--stripesDark), var(--rainbow);\n  background-size: 200%, 100%;\n  background-attachment: fixed;\n  mix-blend-mode: difference;\n}\n.dark-mode .section-flare:after {\n  background-image: var(--stripesDark), var(--rainbow);\n}\n.section-flare-item:nth-of-type(2) {\n  --star-color: #fff;\n  --star-color2: #fff;\n  --star-color3: #fff;\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  background-image: radial-gradient(\n      2px 2px at 20px 30px,\n      var(--star-color2),\n      rgba(0, 0, 0, 0)\n    ),\n    radial-gradient(2px 2px at 40px 70px, var(--star-color), rgba(0, 0, 0, 0)),\n    radial-gradient(2px 2px at 50px 160px, var(--star-color3), rgba(0, 0, 0, 0)),\n    radial-gradient(2px 2px at 90px 40px, var(--star-color), rgba(0, 0, 0, 0)),\n    radial-gradient(2px 2px at 130px 80px, var(--star-color), rgba(0, 0, 0, 0)),\n    radial-gradient(\n      2px 2px at 160px 120px,\n      var(--star-color3),\n      rgba(0, 0, 0, 0)\n    );\n  background-repeat: repeat;\n  background-size: 200px 200px;\n  mask-image: radial-gradient(ellipse at 100% 0%, black 40%, transparent 70%);\n  opacity: 0.2;\n}\n`, Tw = `/* basic theme */\n.light-mode {\n  --scalar-background-1: #fff;\n  --scalar-background-2: #f6f6f6;\n  --scalar-background-3: #e7e7e7;\n  --scalar-background-accent: #8ab4f81f;\n\n  --scalar-color-1: #2a2f45;\n  --scalar-color-2: #757575;\n  --scalar-color-3: #8e8e8e;\n\n  --scalar-color-accent: #0099ff;\n  --scalar-border-color: rgba(0, 0, 0, 0.1);\n}\n.dark-mode {\n  --scalar-background-1: #0f0f0f;\n  --scalar-background-2: #1a1a1a;\n  --scalar-background-3: #272727;\n\n  --scalar-color-1: rgba(255, 255, 255, 0.9);\n  --scalar-color-2: rgba(255, 255, 255, 0.62);\n  --scalar-color-3: rgba(255, 255, 255, 0.44);\n\n  --scalar-color-accent: #3ea6ff;\n  --scalar-background-accent: #3ea6ff1f;\n\n  --scalar-border-color: rgba(255, 255, 255, 0.1);\n}\n/* Document Sidebar */\n.light-mode .t-doc__sidebar,\n.dark-mode .t-doc__sidebar {\n  --scalar-sidebar-background-1: var(--scalar-background-1);\n  --scalar-sidebar-color-1: var(--scalar-color-1);\n  --scalar-sidebar-color-2: var(--scalar-color-2);\n  --scalar-sidebar-border-color: var(--scalar-border-color);\n\n  --scalar-sidebar-item-hover-background: var(--scalar-background-2);\n  --scalar-sidebar-item-hover-color: currentColor;\n\n  --scalar-sidebar-item-active-background: var(--scalar-background-2);\n  --scalar-sidebar-color-active: var(--scalar-color-1);\n\n  --scalar-sidebar-search-background: transparent;\n  --scalar-sidebar-search-color: var(--scalar-color-3);\n  --scalar-sidebar-search-border-color: var(--scalar-border-color);\n}\n\n/* advanced */\n.light-mode {\n  --scalar-color-green: #069061;\n  --scalar-color-red: #ef0006;\n  --scalar-color-yellow: #edbe20;\n  --scalar-color-blue: #0082d0;\n  --scalar-color-orange: #fb892c;\n  --scalar-color-purple: #5203d1;\n\n  --scalar-button-1: rgba(0, 0, 0, 1);\n  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);\n  --scalar-button-1-color: rgba(255, 255, 255, 0.9);\n}\n.dark-mode {\n  --scalar-color-green: #00b648;\n  --scalar-color-red: #dc1b19;\n  --scalar-color-yellow: #ffc90d;\n  --scalar-color-blue: #4eb3ec;\n  --scalar-color-orange: #ff8d4d;\n  --scalar-color-purple: #b191f9;\n\n  --scalar-button-1: rgba(255, 255, 255, 1);\n  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);\n  --scalar-button-1-color: black;\n}\n`, pR = `/* basic theme */\n.light-mode {\n  --scalar-color-1: #2a2f45;\n  --scalar-color-2: #757575;\n  --scalar-color-3: #8e8e8e;\n  --scalar-color-accent: #7070ff;\n\n  --scalar-background-1: #fff;\n  --scalar-background-2: #f6f6f6;\n  --scalar-background-3: #e7e7e7;\n  --scalar-background-accent: #7070ff1f;\n\n  --scalar-border-color: rgba(0, 0, 0, 0.1);\n\n  --scalar-code-language-color-supersede: var(--scalar-color-3);\n}\n.dark-mode {\n  --scalar-color-1: #f7f8f8;\n  --scalar-color-2: rgb(180, 188, 208);\n  --scalar-color-3: #b4bcd099;\n  --scalar-color-accent: #828fff;\n\n  --scalar-background-1: #000212;\n  --scalar-background-2: rgba(255, 255, 255, 0.05);\n  --scalar-background-3: rgba(255, 255, 255, 0.09);\n  --scalar-background-accent: #8ab4f81f;\n\n  --scalar-border-color: #242537;\n  --scalar-code-language-color-supersede: var(--scalar-color-3);\n}\n/* Document Sidebar */\n.light-mode .t-doc__sidebar {\n  --scalar-sidebar-background-1: var(--scalar-background-1);\n  --scalar-sidebar-item-hover-color: currentColor;\n  --scalar-sidebar-item-hover-background: var(--scalar-background-2);\n  --scalar-sidebar-item-active-background: var(--scalar-background-accent);\n  --scalar-sidebar-border-color: var(--scalar-border-color);\n  --scalar-sidebar-color-1: var(--scalar-color-1);\n  --scalar-sidebar-color-2: var(--scalar-color-2);\n  --scalar-sidebar-color-active: var(--scalar-color-accent);\n  --scalar-sidebar-search-background: rgba(0, 0, 0, 0.05);\n  --scalar-sidebar-search-border-color: 1px solid rgba(0, 0, 0, 0.05);\n  --scalar-sidebar-search-color: var(--scalar-color-3);\n  --scalar-background-2: rgba(0, 0, 0, 0.03);\n}\n.dark-mode .t-doc__sidebar {\n  --scalar-sidebar-background-1: var(--scalar-background-1);\n  --scalar-sidebar-item-hover-color: currentColor;\n  --scalar-sidebar-item-hover-background: var(--scalar-background-2);\n  --scalar-sidebar-item-active-background: rgba(255, 255, 255, 0.1);\n  --scalar-sidebar-border-color: var(--scalar-border-color);\n  --scalar-sidebar-color-1: var(--scalar-color-1);\n  --scalar-sidebar-color-2: var(--scalar-color-2);\n  --scalar-sidebar-color-active: var(--scalar-color-accent);\n  --scalar-sidebar-search-background: rgba(255, 255, 255, 0.1);\n  --scalar-sidebar-search-border-color: 1px solid rgba(255, 255, 255, 0.05);\n  --scalar-sidebar-search-color: var(--scalar-color-3);\n}\n/* advanced */\n.light-mode {\n  --scalar-color-green: #069061;\n  --scalar-color-red: #ef0006;\n  --scalar-color-yellow: #edbe20;\n  --scalar-color-blue: #0082d0;\n  --scalar-color-orange: #fb892c;\n  --scalar-color-purple: #5203d1;\n\n  --scalar-button-1: rgba(0, 0, 0, 1);\n  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);\n  --scalar-button-1-color: rgba(255, 255, 255, 0.9);\n}\n.dark-mode {\n  --scalar-color-green: #00b648;\n  --scalar-color-red: #dc1b19;\n  --scalar-color-yellow: #ffc90d;\n  --scalar-color-blue: #4eb3ec;\n  --scalar-color-orange: #ff8d4d;\n  --scalar-color-purple: #b191f9;\n\n  --scalar-button-1: rgba(255, 255, 255, 1);\n  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);\n  --scalar-button-1-color: black;\n}\n/* Custom Theme */\n.dark-mode h2.t-editor__heading,\n.dark-mode .t-editor__page-title h1,\n.dark-mode h1.section-header,\n.dark-mode .markdown h1,\n.dark-mode .markdown h2,\n.dark-mode .markdown h3,\n.dark-mode .markdown h4,\n.dark-mode .markdown h5,\n.dark-mode .markdown h6 {\n  -webkit-text-fill-color: transparent;\n  background-image: linear-gradient(\n    to right bottom,\n    rgb(255, 255, 255) 30%,\n    rgba(255, 255, 255, 0.38)\n  );\n  -webkit-background-clip: text;\n  background-clip: text;\n}\n.sidebar-search {\n  backdrop-filter: blur(12px);\n}\n@keyframes headerbackground {\n  from {\n    background: transparent;\n    backdrop-filter: none;\n  }\n  to {\n    background: var(--header-background-1);\n    backdrop-filter: blur(12px);\n  }\n}\n.dark-mode .scalar-card {\n  background: rgba(255, 255, 255, 0.05) !important;\n}\n.dark-mode .scalar-card * {\n  --scalar-background-2: transparent !important;\n  --scalar-background-1: transparent !important;\n}\n.light-mode .dark-mode.scalar-card *,\n.light-mode .dark-mode.scalar-card {\n  --scalar-background-1: #0d0f1e !important;\n  --scalar-background-2: #0d0f1e !important;\n  --scalar-background-3: #191b29 !important;\n}\n.light-mode .dark-mode.scalar-card {\n  background: #191b29 !important;\n}\n.badge {\n  box-shadow: 0 0 0 1px var(--scalar-border-color);\n  margin-right: 6px;\n}\n\n.table-row.required-parameter .table-row-item:nth-of-type(2):after {\n  background: transparent;\n  box-shadow: none;\n}\n.code-languages__active {\n  --scalar-code-language-color-supersede: var(--scalar-color-1);\n}\n.code-languages-background {\n  background: linear-gradient(\n    rgba(255, 255, 255, 0) 0%,\n    rgba(255, 255, 255, 0.05) 100%\n  ) !important;\n  box-shadow: inset 0 0 0 1px var(--scalar-border-color) !important;\n}\n/* Hero Section Flare */\n.section-flare {\n  width: 100vw;\n  background: radial-gradient(\n    ellipse 80% 50% at 50% -20%,\n    rgba(120, 119, 198, 0.3),\n    transparent\n  );\n  height: 100vh;\n}\n`, OR = `/* basic theme */\n:root {\n  --scalar-text-decoration: underline;\n  --scalar-text-decoration-hover: underline;\n}\n.light-mode {\n  --scalar-background-1: #f9f6f0;\n  --scalar-background-2: #f2efe8;\n  --scalar-background-3: #e9e7e2;\n  --scalar-border-color: rgba(203, 165, 156, 0.6);\n\n  --scalar-color-1: #c75549;\n  --scalar-color-2: #c75549;\n  --scalar-color-3: #c75549;\n\n  --scalar-color-accent: #c75549;\n  --scalar-background-accent: #dcbfa81f;\n\n  --scalar-code-language-color-supersede: var(--scalar-color-1);\n}\n.dark-mode {\n  --scalar-background-1: #140507;\n  --scalar-background-2: #20090c;\n  --scalar-background-3: #321116;\n  --scalar-border-color: rgba(255, 255, 255, 0.1);\n\n  --scalar-color-1: rgba(255, 255, 255, 0.9);\n  --scalar-color-2: rgba(255, 255, 255, 0.62);\n  --scalar-color-3: rgba(255, 255, 255, 0.44);\n\n  --scalar-color-accent: rgba(255, 255, 255, 0.9);\n  --scalar-background-accent: #441313;\n\n  --scalar-code-language-color-supersede: var(--scalar-color-1);\n}\n\n/* Document Sidebar */\n.light-mode .t-doc__sidebar,\n.dark-mode .t-doc__sidebar {\n  --scalar-sidebar-background-1: var(--scalar-background-1);\n  --scalar-sidebar-color-1: var(--scalar-color-1);\n  --scalar-sidebar-color-2: var(--scalar-color-2);\n  --scalar-sidebar-border-color: var(--scalar-border-color);\n\n  --scalar-sidebar-item-hover-color: currentColor;\n  --scalar-sidebar-item-hover-background: var(--scalar-background-2);\n\n  --scalar-sidebar-item-active-background: var(--scalar-background-3);\n  --scalar-sidebar-color-active: var(--scalar-color-accent);\n\n  --scalar-sidebar-search-background: rgba(255, 255, 255, 0.1);\n  --scalar-sidebar-search-color: var(--scalar-color-3);\n  --scalar-sidebar-search-border-color: var(--scalar-border-color);\n  z-index: 1;\n}\n/* advanced */\n.light-mode {\n  --scalar-color-green: #09533a;\n  --scalar-color-red: #aa181d;\n  --scalar-color-yellow: #ab8d2b;\n  --scalar-color-blue: #19689a;\n  --scalar-color-orange: #b26c34;\n  --scalar-color-purple: #4c2191;\n\n  --scalar-button-1: rgba(0, 0, 0, 1);\n  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);\n  --scalar-button-1-color: rgba(255, 255, 255, 0.9);\n}\n.dark-mode {\n  --scalar-color-green: rgba(69, 255, 165, 0.823);\n  --scalar-color-red: #ff8589;\n  --scalar-color-yellow: #ffcc4d;\n  --scalar-color-blue: #6bc1fe;\n  --scalar-color-orange: #f98943;\n  --scalar-color-purple: #b191f9;\n\n  --scalar-button-1: rgba(255, 255, 255, 1);\n  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);\n  --scalar-button-1-color: black;\n}\n/* Custom Theme */\n.dark-mode h2.t-editor__heading,\n.dark-mode .t-editor__page-title h1,\n.dark-mode h1.section-header,\n.dark-mode .markdown h1,\n.dark-mode .markdown h2,\n.dark-mode .markdown h3,\n.dark-mode .markdown h4,\n.dark-mode .markdown h5,\n.dark-mode .markdown h6 {\n  -webkit-text-fill-color: transparent;\n  background-image: linear-gradient(\n    to right bottom,\n    rgb(255, 255, 255) 30%,\n    rgba(255, 255, 255, 0.38)\n  );\n  -webkit-background-clip: text;\n  background-clip: text;\n}\n.light-mode .t-doc__sidebar {\n  --scalar-sidebar-search-background: white;\n}\n.examples .scalar-card-footer {\n  --scalar-background-3: transparent;\n  padding-top: 0;\n}\n.code-languages-background {\n  background: var(--scalar-background-1) !important;\n}\n.code-languages-background:before {\n  box-shadow: inset 0 0 0 2px var(--scalar-border-color);\n  background: linear-gradient(\n    to right top,\n    rgb(211 225 249 / 12%),\n    rgb(209 223 247 / 11%),\n    rgb(223 233 251 / 29%)\n  ) !important;\n}\n.light-mode .code-languages-background:before {\n  background: linear-gradient(\n    to right top,\n    rgb(0 0 0 / 8%),\n    rgb(0 0 0 / 7%),\n    rgb(0 0 0 / 19%)\n  ) !important;\n}\n.code-languages__active .code-languages-background:before {\n  background: var(--scalar-background-1) !important;\n}\n\n.code-languages span {\n  margin-top: 5px !important;\n}\n/* Hero section flare */\n.section-flare-item:nth-of-type(1) {\n  background: #d25019;\n  width: 80vw;\n  height: 500px;\n  margin-top: -150px;\n  border-radius: 50%;\n  filter: blur(100px);\n  z-index: 0;\n}\n.light-mode .section-flare {\n  display: none;\n}\n.section-flare {\n  top: -150px !important;\n  height: 100vh;\n  right: -400px !important;\n  left: initial;\n}\n`, gR = `.light-mode {\n  color-scheme: light;\n  --scalar-color-1: #000000;\n  --scalar-color-2: #000000;\n  --scalar-color-3: #000000;\n  --scalar-color-accent: #645b0f;\n  --scalar-background-1: #ccc9b3;\n  --scalar-background-2: #c2bfaa;\n  --scalar-background-3: #b8b5a1;\n  --scalar-background-accent: #000000;\n\n  --scalar-border-color: rgba(0, 0, 0, 0.2);\n  --scalar-scrollbar-color: rgba(0, 0, 0, 0.18);\n  --scalar-scrollbar-color-active: rgba(0, 0, 0, 0.36);\n  --scalar-lifted-brightness: 1;\n  --scalar-backdrop-brightness: 1;\n\n  --scalar-shadow-1: 0 1px 3px 0 rgba(0, 0, 0, 0.11);\n  --scalar-shadow-2: rgba(0, 0, 0, 0.08) 0px 13px 20px 0px,\n    rgba(0, 0, 0, 0.08) 0px 3px 8px 0px, var(--scalar-border-color) 0px 0 0 1px;\n\n  --scalar-button-1: rgb(49 53 56);\n  --scalar-button-1-color: #fff;\n  --scalar-button-1-hover: rgb(28 31 33);\n\n  --scalar-color-red: #b91c1c;\n  --scalar-color-orange: #a16207;\n  --scalar-color-green: #047857;\n  --scalar-color-blue: #1d4ed8;\n  --scalar-color-orange: #c2410c;\n  --scalar-color-purple: #6d28d9;\n\n  --scalar-code-languages-background-supersede: var(--scalar-background-3);\n  --scalar-code-language-color-supersede: var(--scalar-color-1);\n}\n\n.dark-mode {\n  color-scheme: dark;\n  --scalar-color-1: #fffef3;\n  --scalar-color-2: #fffef3;\n  --scalar-color-3: #fffef3;\n  --scalar-color-accent: #c3b531;\n  --scalar-background-1: #313332;\n  --scalar-background-2: #393b3a;\n  --scalar-background-3: #414342;\n  --scalar-background-accent: #fffef3;\n\n  --scalar-border-color: rgba(255, 255, 255, 0.1);\n  --scalar-scrollbar-color: rgba(255, 255, 255, 0.24);\n  --scalar-scrollbar-color-active: rgba(255, 255, 255, 0.48);\n  --scalar-lifted-brightness: 1.45;\n  --scalar-backdrop-brightness: 0.5;\n\n  --scalar-shadow-1: 0 1px 3px 0 rgba(0, 0, 0, 0.11);\n  --scalar-shadow-2: rgba(15, 15, 15, 0.2) 0px 3px 6px,\n    rgba(15, 15, 15, 0.4) 0px 9px 24px, 0 0 0 1px rgba(255, 255, 255, 0.1);\n\n  --scalar-button-1: #f6f6f6;\n  --scalar-button-1-color: #000;\n  --scalar-button-1-hover: #e7e7e7;\n\n  --scalar-color-green: #00b648;\n  --scalar-color-red: #dc1b19;\n  --scalar-color-yellow: #ffc90d;\n  --scalar-color-blue: #4eb3ec;\n  --scalar-color-orange: #ff8d4d;\n  --scalar-color-purple: #b191f9;\n\n  --scalar-code-languages-background-supersede: var(--scalar-background-3);\n  --scalar-code-language-color-supersede: var(--scalar-color-1);\n}\n\n/* Sidebar */\n.light-mode .t-doc__sidebar {\n  --scalar-sidebar-background-1: var(--scalar-background-1);\n  --scalar-sidebar-item-hover-color: currentColor;\n  --scalar-sidebar-item-hover-background: var(--scalar-background-2);\n  --scalar-sidebar-item-active-background: var(--scalar-background-accent);\n  --scalar-sidebar-border-color: var(--scalar-border-color);\n  --scalar-sidebar-color-1: var(--scalar-color-1);\n  --scalar-sidebar-color-2: var(--scalar-color-2);\n  --scalar-sidebar-color-active: var(--scalar-sidebar-background-1);\n  --scalar-sidebar-search-background: var(--scalar-background-3);\n  --scalar-sidebar-search-border-color: var(--scalar-sidebar-search-background);\n  --scalar-sidebar-search--color: var(--scalar-color-3);\n}\n\n.dark-mode .sidebar {\n  --scalar-sidebar-background-1: var(--scalar-background-1);\n  --scalar-sidebar-item-hover-color: currentColor;\n  --scalar-sidebar-item-hover-background: var(--scalar-background-2);\n  --scalar-sidebar-item-active-background: var(--scalar-background-accent);\n  --scalar-sidebar-border-color: var(--scalar-border-color);\n  --scalar-sidebar-color-1: var(--scalar-color-1);\n  --scalar-sidebar-color-2: var(--scalar-color-2);\n  --scalar-sidebar-color-active: var(--scalar-sidebar-background-1);\n  --scalar-sidebar-search-background: var(--scalar-background-3);\n  --scalar-sidebar-search-border-color: var(--scalar-sidebar-search-background);\n  --scalar-sidebar-search--color: var(--scalar-color-3);\n}\n`, mR = `/* basic theme */\n.light-mode {\n  --scalar-background-1: #fff;\n  --scalar-background-2: #f5f6f8;\n  --scalar-background-3: #eceef1;\n\n  --scalar-color-1: #2a2f45;\n  --scalar-color-2: #757575;\n  --scalar-color-3: #8e8e8e;\n\n  --scalar-color-accent: #5469d4;\n  --scalar-background-accent: #5469d41f;\n\n  --scalar-border-color: rgba(215, 215, 206, 0.5);\n}\n.dark-mode {\n  --scalar-background-1: #15171c;\n  --scalar-background-2: #1c1e24;\n  --scalar-background-3: #22252b;\n\n  --scalar-color-1: #fafafa;\n  --scalar-color-2: #c9ced8;\n  --scalar-color-3: #8c99ad;\n\n  --scalar-color-accent: #5469d4;\n  --scalar-background-accent: #5469d41f;\n\n  --scalar-border-color: rgba(255, 255, 255, 0.12);\n}\n/* Document Sidebar */\n.light-mode .t-doc__sidebar,\n.dark-mode .t-doc__sidebar {\n  --scalar-sidebar-background-1: var(--scalar-background-1);\n  --scalar-sidebar-color-1: var(--scalar-color-1);\n  --scalar-sidebar-color-2: var(--scalar-color-2);\n  --scalar-sidebar-border-color: var(--scalar-border-color);\n\n  --scalar-sidebar-item-hover-color: currentColor;\n  --scalar-sidebar-item-hover-background: var(--scalar-background-3);\n\n  --scalar-sidebar-item-active-background: var(--scalar-background-accent);\n  --scalar-sidebar-color-active: var(--scalar-color-accent);\n\n  --scalar-sidebar-search-background: var(--scalar-background-1);\n  --scalar-sidebar-search-color: var(--scalar-color-3);\n  --scalar-sidebar-search-border-color: var(--scalar-border-color);\n}\n\n/* advanced */\n.light-mode {\n  --scalar-color-green: #17803d;\n  --scalar-color-red: #e10909;\n  --scalar-color-yellow: #edbe20;\n  --scalar-color-blue: #1763a6;\n  --scalar-color-orange: #e25b09;\n  --scalar-color-purple: #5c3993;\n\n  --scalar-button-1: rgba(0, 0, 0, 1);\n  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);\n  --scalar-button-1-color: rgba(255, 255, 255, 0.9);\n}\n.dark-mode {\n  --scalar-color-green: #30a159;\n  --scalar-color-red: #dc1b19;\n  --scalar-color-yellow: #eec644;\n  --scalar-color-blue: #2b7abf;\n  --scalar-color-orange: #f07528;\n  --scalar-color-purple: #7a59b1;\n\n  --scalar-button-1: rgba(255, 255, 255, 1);\n  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);\n  --scalar-button-1-color: black;\n}\n`, bR = `/* basic theme */\n.light-mode {\n  --scalar-background-1: #f3f3ee;\n  --scalar-background-2: #e8e8e3;\n  --scalar-background-3: #e4e4df;\n  --scalar-border-color: rgba(215, 215, 206, 0.5);\n\n  --scalar-color-1: #2a2f45;\n  --scalar-color-2: #757575;\n  --scalar-color-3: #8e8e8e;\n\n  --scalar-color-accent: #1763a6;\n  --scalar-background-accent: #1f648e1f;\n\n  --scalar-code-language-color-supersede: var(--scalar-color-1);\n  --scalar-code-languages-background-supersede: var(--scalar-background-2);\n}\n.dark-mode {\n  --scalar-background-1: #09090b;\n  --scalar-background-2: #18181b;\n  --scalar-background-3: #2c2c30;\n  --scalar-border-color: rgba(255, 255, 255, 0.12);\n\n  --scalar-color-1: #fafafa;\n  --scalar-color-2: rgb(161, 161, 170);\n  --scalar-color-3: rgba(255, 255, 255, 0.533);\n\n  --scalar-color-accent: #4eb3ec;\n  --scalar-background-accent: #8ab4f81f;\n\n  --scalar-code-language-color-supersede: var(--scalar-color-1);\n  --scalar-code-languages-background-supersede: var(--scalar-background-2);\n}\n/* Document Sidebar */\n.light-mode .t-doc__sidebar,\n.dark-mode .t-doc__sidebar {\n  --scalar-sidebar-background-1: var(--scalar-background-1);\n  --scalar-sidebar-color-1: var(--scalar-color-1);\n  --scalar-sidebar-color-2: var(--scalar-color-2);\n  --scalar-sidebar-border-color: var(--scalar-border-color);\n\n  --scalar-sidebar-item-hover-background: var(--scalar-background-2);\n  --scalar-sidebar-item-hover-color: currentColor;\n\n  --scalar-sidebar-item-active-background: var(--scalar-background-3);\n  --scalar-sidebar-color-active: var(--scalar-color-1);\n\n  --scalar-sidebar-search-background: var(--scalar-background-1);\n  --scalar-sidebar-search-border-color: var(--scalar-border-color);\n  --scalar-sidebar-search-color: var(--scalar-color-3);\n}\n\n/* advanced */\n.light-mode {\n  --scalar-color-green: #17803d;\n  --scalar-color-red: #e10909;\n  --scalar-color-yellow: #edbe20;\n  --scalar-color-blue: #1763a6;\n  --scalar-color-orange: #e25b09;\n  --scalar-color-purple: #5c3993;\n\n  --scalar-button-1: rgba(0, 0, 0, 1);\n  --scalar-button-1-hover: rgba(0, 0, 0, 0.8);\n  --scalar-button-1-color: rgba(255, 255, 255, 0.9);\n}\n.dark-mode {\n  --scalar-color-green: #30a159;\n  --scalar-color-red: #dc1b19;\n  --scalar-color-yellow: #eec644;\n  --scalar-color-blue: #2b7abf;\n  --scalar-color-orange: #f07528;\n  --scalar-color-purple: #7a59b1;\n\n  --scalar-button-1: rgba(255, 255, 255, 1);\n  --scalar-button-1-hover: rgba(255, 255, 255, 0.9);\n  --scalar-button-1-color: black;\n}\n.dark-mode h2.t-editor__heading,\n.dark-mode .t-editor__page-title h1,\n.dark-mode h1.section-header,\n.dark-mode .markdown h1,\n.dark-mode .markdown h2,\n.dark-mode .markdown h3,\n.dark-mode .markdown h4,\n.dark-mode .markdown h5,\n.dark-mode .markdown h6 {\n  -webkit-text-fill-color: transparent;\n  background-image: linear-gradient(\n    to right bottom,\n    rgb(255, 255, 255) 30%,\n    rgba(255, 255, 255, 0.38)\n  );\n  -webkit-background-clip: text;\n  background-clip: text;\n}\n`, vR = `.light-mode {\n  color-scheme: light;\n  --scalar-color-1: #584c27;\n  --scalar-color-2: #616161;\n  --scalar-color-3: #a89f84;\n  --scalar-color-accent: #b58900;\n  --scalar-background-1: #fdf6e3;\n  --scalar-background-2: #eee8d5;\n  --scalar-background-3: #ddd6c1;\n  --scalar-background-accent: #b589001f;\n\n  --scalar-border-color: #ded8c8;\n  --scalar-scrollbar-color: rgba(0, 0, 0, 0.18);\n  --scalar-scrollbar-color-active: rgba(0, 0, 0, 0.36);\n  --scalar-lifted-brightness: 1;\n  --scalar-backdrop-brightness: 1;\n\n  --scalar-shadow-1: 0 1px 3px 0 rgba(0, 0, 0, 0.11);\n  --scalar-shadow-2: rgba(0, 0, 0, 0.08) 0px 13px 20px 0px,\n    rgba(0, 0, 0, 0.08) 0px 3px 8px 0px, #eeeeed 0px 0 0 1px;\n\n  --scalar-button-1: rgb(49 53 56);\n  --scalar-button-1-color: #fff;\n  --scalar-button-1-hover: rgb(28 31 33);\n\n  --scalar-color-red: #b91c1c;\n  --scalar-color-orange: #a16207;\n  --scalar-color-green: #047857;\n  --scalar-color-blue: #1d4ed8;\n  --scalar-color-orange: #c2410c;\n  --scalar-color-purple: #6d28d9;\n}\n\n.dark-mode {\n  color-scheme: dark;\n  --scalar-color-1: #fff;\n  --scalar-color-2: #cccccc;\n  --scalar-color-3: #6d8890;\n  --scalar-color-accent: #007acc;\n  --scalar-background-1: #00212b;\n  --scalar-background-2: #012b36;\n  --scalar-background-3: #004052;\n  --scalar-background-accent: #015a6f;\n\n  --scalar-border-color: rgba(255, 255, 255, 0.1);\n  --scalar-scrollbar-color: rgba(255, 255, 255, 0.24);\n  --scalar-scrollbar-color-active: rgba(255, 255, 255, 0.48);\n  --scalar-lifted-brightness: 1.45;\n  --scalar-backdrop-brightness: 0.5;\n\n  --scalar-shadow-1: 0 1px 3px 0 rgb(0, 0, 0, 0.1);\n  --scalar-shadow-2: rgba(15, 15, 15, 0.2) 0px 3px 6px,\n    rgba(15, 15, 15, 0.4) 0px 9px 24px, 0 0 0 1px rgba(255, 255, 255, 0.1);\n\n  --scalar-button-1: #f6f6f6;\n  --scalar-button-1-color: #000;\n  --scalar-button-1-hover: #e7e7e7;\n\n  --scalar-color-green: #00b648;\n  --scalar-color-red: #dc1b19;\n  --scalar-color-yellow: #ffc90d;\n  --scalar-color-blue: #4eb3ec;\n  --scalar-color-orange: #ff8d4d;\n  --scalar-color-purple: #b191f9;\n}\n\n/* Sidebar */\n.light-mode .t-doc__sidebar {\n  --scalar-sidebar-background-1: var(--scalar-background-1);\n  --scalar-sidebar-item-hover-color: currentColor;\n  --scalar-sidebar-item-hover-background: var(--scalar-background-2);\n  --scalar-sidebar-item-active-background: var(--scalar-background-accent);\n  --scalar-sidebar-border-color: var(--scalar-border-color);\n  --scalar-sidebar-color-1: var(--scalar-color-1);\n  --scalar-sidebar-color-2: var(--scalar-color-2);\n  --scalar-sidebar-color-active: var(--scalar-color-accent);\n  --scalar-sidebar-search-background: var(--scalar-background-2);\n  --scalar-sidebar-search-border-color: var(--scalar-sidebar-search-background);\n  --scalar-sidebar-search--color: var(--scalar-color-3);\n}\n\n.dark-mode .sidebar {\n  --scalar-sidebar-background-1: var(--scalar-background-1);\n  --scalar-sidebar-item-hover-color: currentColor;\n  --scalar-sidebar-item-hover-background: var(--scalar-background-2);\n  --scalar-sidebar-item-active-background: var(--scalar-background-accent);\n  --scalar-sidebar-border-color: var(--scalar-border-color);\n  --scalar-sidebar-color-1: var(--scalar-color-1);\n  --scalar-sidebar-color-2: var(--scalar-color-2);\n  --scalar-sidebar-color-active: var(--scalar-sidebar-color-1);\n  --scalar-sidebar-search-background: var(--scalar-background-2);\n  --scalar-sidebar-search-border-color: var(--scalar-sidebar-search-background);\n  --scalar-sidebar-search--color: var(--scalar-color-3);\n}\n`, yR = `\n@import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900');\n@import url('https://fonts.googleapis.com/css?family=JetBrains%20Mono');\n/* Inter (--scalar-font) */\n/* JetBrains Mono (--scalar-font-code) */\n`, SR = /* @__PURE__ */ le({\n  __name: \"DefaultFonts\",\n  setup(t) {\n    return (e, n) => (Z(), ke(Zl(\"style\"), { innerHTML: R(yR) }, null, 8, [\"innerHTML\"]));\n  }\n}), wR = /* @__PURE__ */ le({\n  __name: \"ThemeStyles\",\n  props: {\n    id: {},\n    withDefaultFonts: { type: Boolean, default: !0 }\n  },\n  setup(t) {\n    return (e, n) => (Z(), ne(Pe, null, [\n      e.withDefaultFonts ? (Z(), ke(SR, { key: 0 })) : st(\"\", !0),\n      e.id !== \"none\" ? (Z(), ke(Zl(\"style\"), { key: 1 }, {\n        default: ce(() => [\n          He(De(R(QR)(e.id, { layer: \"scalar-theme\" })), 1)\n        ]),\n        _: 1\n      })) : st(\"\", !0)\n    ], 64));\n  }\n});\nfunction kR(t, e) {\n  et(() => {\n    if (!document.body)\n      return;\n    const n = document.querySelector(t);\n    n == null || n.classList.add(e);\n  });\n}\nconst xR = /* @__PURE__ */ le({\n  __name: \"ResetStyles\",\n  setup(t) {\n    const { reset: e } = J1();\n    return kR(\"#headlessui-portal-root\", e), (n, r) => pt(n.$slots, \"default\", { styles: R(e) });\n  }\n}), PR = \"_reset_12vhc_3\", _R = {\n  reset: PR\n}, ct = (t, e) => {\n  const n = t.__vccOpts || t;\n  for (const [r, i] of e)\n    n[r] = i;\n  return n;\n}, TR = {\n  $style: _R\n}, ER = /* @__PURE__ */ ct(xR, [[\"__cssModules\", TR]]), $R = {\n  alternate: dR,\n  default: Tw,\n  moon: gR,\n  purple: mR,\n  solarized: vR,\n  bluePlanet: fR,\n  deepSpace: hR,\n  saturn: bR,\n  kepler: pR,\n  mars: OR\n}, QR = (t, e) => {\n  if (t === \"none\")\n    return \"\";\n  const n = $R[t || \"default\"] ?? Tw;\n  return e != null && e.layer ? `@layer ${e.layer} {\n${n}}` : n;\n};\nfunction CR() {\n  return {\n    showApiClient: !1,\n    activeApiClientEndpointId: \"\",\n    activeItem: {},\n    snippetType: \"javascript\"\n  };\n}\nXn(CR());\nconst AR = (t) => {\n  let e = 0, n = 0, r = 0;\n  if (!(t != null && t.length))\n    return n;\n  for (r = 0; r < t.length; r++)\n    e = t.charCodeAt(r), n = (n << 5) - n + e, n |= 0;\n  return n;\n};\nlet Cb;\ntry {\n  Cb = new RegExp(`(^|(?<!\n))\n+(?!\n|$)`, \"g\");\n} catch {\n  Cb = /\\n+(?!\\n|$)/g;\n}\nconst Ew = {\n  /** Parse and throw if the return value is not an object */\n  parse: (t) => {\n    const e = JSON.parse(t);\n    if (typeof e != \"object\")\n      throw Error(\"Invalid JSON object\");\n    return e;\n  },\n  /** Parse and return a fallback on failure */\n  parseSafe(t, e) {\n    try {\n      return Ew.parse(t);\n    } catch (n) {\n      return typeof e == \"function\" ? e(n) : e;\n    }\n  },\n  stringify: (t) => JSON.stringify(t)\n}, Xh = (t) => typeof t != \"string\" ? !1 : !!Ew.parseSafe(t, !1), RR = {\n  100: {\n    name: \"Continue\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/100\"\n  },\n  101: {\n    name: \"Switching Protocols\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/101\"\n  },\n  102: {\n    name: \"Processing\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/102\"\n  },\n  103: {\n    name: \"Early Hints\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/103\"\n  },\n  200: {\n    name: \"OK\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/200\"\n  },\n  201: {\n    name: \"Created\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/201\"\n  },\n  202: {\n    name: \"Accepted\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/202\"\n  },\n  203: {\n    name: \"Non-Authoritative Information\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/203\"\n  },\n  204: {\n    name: \"No Content\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/204\"\n  },\n  205: {\n    name: \"Reset Content\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/205\"\n  },\n  206: {\n    name: \"Partial Content\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/206\"\n  },\n  207: {\n    name: \"Multi-Status\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/207\"\n  },\n  208: {\n    name: \"Already Reported\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/208\"\n  },\n  226: {\n    name: \"IM Used\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/226\"\n  },\n  300: {\n    name: \"Multiple Choices\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/300\"\n  },\n  301: {\n    name: \"Moved Permanently\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/301\"\n  },\n  302: {\n    name: \"Found\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/302\"\n  },\n  303: {\n    name: \"See Other\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/303\"\n  },\n  304: {\n    name: \"Not Modified\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/304\"\n  },\n  305: {\n    name: \"Use Proxy\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/305\"\n  },\n  306: {\n    name: \"(Unused)\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/306\"\n  },\n  307: {\n    name: \"Temporary Redirect\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/307\"\n  },\n  308: {\n    name: \"Permanent Redirect\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/308\"\n  },\n  400: {\n    name: \"Bad Request\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/400\"\n  },\n  401: {\n    name: \"Unauthorized\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/401\"\n  },\n  402: {\n    name: \"Payment Required\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/402\"\n  },\n  403: {\n    name: \"Forbidden\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/403\"\n  },\n  404: {\n    name: \"Not Found\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/404\"\n  },\n  405: {\n    name: \"Method Not Allowed\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405\"\n  },\n  406: {\n    name: \"Not Acceptable\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/406\"\n  },\n  407: {\n    name: \"Proxy Authentication Required\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/407\"\n  },\n  408: {\n    name: \"Request Timeout\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/408\"\n  },\n  409: {\n    name: \"Conflict\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/409\"\n  },\n  410: {\n    name: \"Gone\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/410\"\n  },\n  411: {\n    name: \"Length Required\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/411\"\n  },\n  412: {\n    name: \"Precondition Failed\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/412\"\n  },\n  413: {\n    name: \"Content Too Large\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/413\"\n  },\n  414: {\n    name: \"URI Too Long\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/414\"\n  },\n  415: {\n    name: \"Unsupported Media Type\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/415\"\n  },\n  416: {\n    name: \"Range Not Satisfiable\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/416\"\n  },\n  417: {\n    name: \"Expectation Failed\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/417\"\n  },\n  421: {\n    name: \"Misdirected Request\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/421\"\n  },\n  422: {\n    name: \"Unprocessable Content\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/422\"\n  },\n  423: {\n    name: \"Locked\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/423\"\n  },\n  424: {\n    name: \"Failed Dependency\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/424\"\n  },\n  425: {\n    name: \"Too Early\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/425\"\n  },\n  426: {\n    name: \"Upgrade Required\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/426\"\n  },\n  428: {\n    name: \"Precondition Required\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/428\"\n  },\n  429: {\n    name: \"Too Many Requests\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/429\"\n  },\n  431: {\n    name: \"Request Header Fields Too Large\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/431\"\n  },\n  451: {\n    name: \"Unavailable For Legal Reasons\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/451\"\n  },\n  500: {\n    name: \"Internal Server Error\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/500\"\n  },\n  501: {\n    name: \"Not Implemented\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/501\"\n  },\n  502: {\n    name: \"Bad Gateway\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/502\"\n  },\n  503: {\n    name: \"Service Unavailable\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/503\"\n  },\n  504: {\n    name: \"Gateway Timeout\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/504\"\n  },\n  505: {\n    name: \"HTTP Version Not Supported\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/505\"\n  },\n  506: {\n    name: \"Variant Also Negotiates\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/506\"\n  },\n  507: {\n    name: \"Insufficient Storage\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/507\"\n  },\n  508: {\n    name: \"Loop Detected\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/508\"\n  },\n  510: {\n    name: \"Not Extended\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/510\"\n  },\n  511: {\n    name: \"Network Authentication Required\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/511\"\n  }\n}, Ab = () => ({}), $w = typeof window < \"u\" ? window.__SCALAR__ ?? Ab() : Ab(), NR = () => ({\n  preferredSecurityScheme: null,\n  // In case the spec has no security and the user would like to add some\n  customSecurity: !1,\n  http: {\n    basic: {\n      username: \"\",\n      password: \"\"\n    },\n    bearer: {\n      token: \"\"\n    }\n  },\n  apiKey: {\n    token: \"\"\n  },\n  oAuth2: {\n    clientId: \"\",\n    scopes: [],\n    accessToken: \"\",\n    state: \"\"\n  }\n}), Qw = Xn(\n  $w[\"useGlobalStore-authentication\"] ?? NR()\n), DR = (t) => Object.assign(Qw, t), Yl = () => ({\n  authentication: Qw,\n  setAuthentication: DR\n}), ZR = () => ({\n  // @ts-ignore\n  operation: {},\n  globalSecurity: []\n}), dl = Xn(ZR()), VR = (t) => {\n  Object.assign(dl, {\n    ...dl,\n    operation: t\n  });\n}, IR = (t) => {\n  Object.assign(dl, {\n    ...dl,\n    globalSecurity: t\n  });\n}, Cw = () => ({\n  openApi: dl,\n  setOperation: VR,\n  setGlobalSecurity: IR\n}), WR = () => ({\n  name: \"\",\n  url: \"\",\n  type: \"GET\",\n  path: \"\",\n  variables: [],\n  headers: [],\n  query: [],\n  body: \"\",\n  formData: []\n}), Bd = Xn({}), Aw = G([]), Mo = G(\"\"), eg = Xn(WR()), MR = (t) => {\n  Bd[t.responseId] = t, Mo.value = t.responseId, Aw.value.unshift(t.responseId);\n}, XR = (t) => {\n  Mo.value = t;\n  const { request: e } = Bd[t], n = JSON.parse(JSON.stringify(e));\n  n.body = JSON.stringify(e.body, null, 2), Object.assign(eg, n);\n}, jR = j(\n  () => Mo.value ? Bd[Mo.value].response : null\n), BR = (t) => {\n  Object.assign(eg, t);\n}, LR = () => {\n  Mo.value = \"\";\n}, UR = G(!0), sr = () => ({\n  readOnly: UR,\n  activeRequest: eg,\n  activeResponse: jR,\n  requestHistory: Bd,\n  requestHistoryOrder: Aw,\n  activeRequestId: Mo,\n  setActiveResponse: XR,\n  resetActiveResponse: LR,\n  addRequestToHistory: MR,\n  setActiveRequest: BR\n}), qR = [\n  {\n    name: \"Accept\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept\"\n  },\n  {\n    name: \"Accept-CH\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-CH\"\n  },\n  {\n    name: \"Accept-CH-Lifetime\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-CH-Lifetime\"\n  },\n  {\n    name: \"Accept-Charset\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Charset\"\n  },\n  {\n    name: \"Accept-Encoding\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding\"\n  },\n  {\n    name: \"Accept-Language\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Language\"\n  },\n  {\n    name: \"Accept-Patch\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Patch\"\n  },\n  {\n    name: \"Accept-Post\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Post\"\n  },\n  {\n    name: \"Accept-Ranges\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Ranges\"\n  },\n  {\n    name: \"Access-Control-Allow-Credentials\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials\"\n  },\n  {\n    name: \"Access-Control-Allow-Headers\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Headers\"\n  },\n  {\n    name: \"Access-Control-Allow-Methods\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Methods\"\n  },\n  {\n    name: \"Access-Control-Allow-Origin\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin\"\n  },\n  {\n    name: \"Access-Control-Expose-Headers\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Expose-Headers\"\n  },\n  {\n    name: \"Access-Control-Max-Age\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Max-Age\"\n  },\n  {\n    name: \"Access-Control-Request-Headers\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Request-Headers\"\n  },\n  {\n    name: \"Access-Control-Request-Method\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Request-Method\"\n  },\n  {\n    name: \"Age\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Age\"\n  },\n  {\n    name: \"Allow\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Allow\"\n  },\n  {\n    name: \"Alt-Svc\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Alt-Svc\"\n  },\n  {\n    name: \"Alt-Used\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Alt-Used\"\n  },\n  {\n    name: \"Authorization\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization\"\n  },\n  {\n    name: \"Cache-Control\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control\"\n  },\n  {\n    name: \"Clear-Site-Data\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Clear-Site-Data\"\n  },\n  {\n    name: \"Connection\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Connection\"\n  },\n  {\n    name: \"Content-Disposition\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition\"\n  },\n  {\n    name: \"Content-DPR\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-DPR\"\n  },\n  {\n    name: \"Content-Encoding\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding\"\n  },\n  {\n    name: \"Content-Language\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Language\"\n  },\n  {\n    name: \"Content-Length\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Length\"\n  },\n  {\n    name: \"Content-Location\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Location\"\n  },\n  {\n    name: \"Content-Range\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Range\"\n  },\n  {\n    name: \"Content-Security-Policy\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy\"\n  },\n  {\n    name: \"Content-Security-Policy-Report-Only\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy-Report-Only\"\n  },\n  {\n    name: \"Content-Type\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type\"\n  },\n  {\n    name: \"Cookie\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cookie\"\n  },\n  {\n    name: \"Critical-CH\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Critical-CH\"\n  },\n  {\n    name: \"Cross-Origin-Embedder-Policy\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Embedder-Policy\"\n  },\n  {\n    name: \"Cross-Origin-Opener-Policy\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Opener-Policy\"\n  },\n  {\n    name: \"Cross-Origin-Resource-Policy\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Resource-Policy\"\n  },\n  {\n    name: \"Date\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Date\"\n  },\n  {\n    name: \"Device-Memory\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Device-Memory\"\n  },\n  {\n    name: \"Digest\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Digest\"\n  },\n  {\n    name: \"DNT\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/DNT\"\n  },\n  {\n    name: \"Downlink\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Downlink\"\n  },\n  {\n    name: \"DPR\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/DPR\"\n  },\n  {\n    name: \"Early-Data\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Early-Data\"\n  },\n  {\n    name: \"ECT\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ECT\"\n  },\n  {\n    name: \"ETag\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag\"\n  },\n  {\n    name: \"Expect\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expect\"\n  },\n  {\n    name: \"Expect-CT\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expect-CT\"\n  },\n  {\n    name: \"Expires\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expires\"\n  },\n  {\n    name: \"Forwarded\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Forwarded\"\n  },\n  {\n    name: \"From\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/From\"\n  },\n  {\n    name: \"Host\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Host\"\n  },\n  {\n    name: \"If-Match\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Match\"\n  },\n  {\n    name: \"If-Modified-Since\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Modified-Since\"\n  },\n  {\n    name: \"If-None-Match\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-None-Match\"\n  },\n  {\n    name: \"If-Range\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Range\"\n  },\n  {\n    name: \"If-Unmodified-Since\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Unmodified-Since\"\n  },\n  {\n    name: \"Keep-Alive\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Keep-Alive\"\n  },\n  {\n    name: \"Large-Allocation\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Large-Allocation\"\n  },\n  {\n    name: \"Last-Modified\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Last-Modified\"\n  },\n  {\n    name: \"Link\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Link\"\n  },\n  {\n    name: \"Location\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Location\"\n  },\n  {\n    name: \"Max-Forwards\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Max-Forwards\"\n  },\n  {\n    name: \"NEL\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/NEL\"\n  },\n  {\n    name: \"Origin\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin\"\n  },\n  {\n    name: \"Permissions-Policy\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Permissions-Policy\"\n  },\n  {\n    name: \"Pragma\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Pragma\"\n  },\n  {\n    name: \"Proxy-Authenticate\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Proxy-Authenticate\"\n  },\n  {\n    name: \"Proxy-Authorization\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Proxy-Authorization\"\n  },\n  {\n    name: \"Range\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Range\"\n  },\n  {\n    name: \"Referer\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referer\"\n  },\n  {\n    name: \"Referrer-Policy\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy\"\n  },\n  {\n    name: \"Retry-After\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After\"\n  },\n  {\n    name: \"RTT\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/RTT\"\n  },\n  {\n    name: \"Save-Data\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Save-Data\"\n  },\n  {\n    name: \"Sec-CH-Prefers-Reduced-Motion\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-CH-Prefers-Reduced-Motion\"\n  },\n  {\n    name: \"Sec-CH-Prefers-Reduced-Transparency\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-CH-Prefers-Reduced-Transparency\"\n  },\n  {\n    name: \"Sec-CH-UA\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-CH-UA\"\n  },\n  {\n    name: \"Sec-CH-UA-Arch\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-CH-UA-Arch\"\n  },\n  {\n    name: \"Sec-CH-UA-Bitness\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-CH-UA-Bitness\"\n  },\n  {\n    name: \"Sec-CH-UA-Full-Version\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-CH-UA-Full-Version\"\n  },\n  {\n    name: \"Sec-CH-UA-Full-Version-List\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-CH-UA-Full-Version-List\"\n  },\n  {\n    name: \"Sec-CH-UA-Mobile\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-CH-UA-Mobile\"\n  },\n  {\n    name: \"Sec-CH-UA-Model\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-CH-UA-Model\"\n  },\n  {\n    name: \"Sec-CH-UA-Platform\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-CH-UA-Platform\"\n  },\n  {\n    name: \"Sec-CH-UA-Platform-Version\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-CH-UA-Platform-Version\"\n  },\n  {\n    name: \"Sec-Fetch-Dest\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-Fetch-Dest\"\n  },\n  {\n    name: \"Sec-Fetch-Mode\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-Fetch-Mode\"\n  },\n  {\n    name: \"Sec-Fetch-Site\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-Fetch-Site\"\n  },\n  {\n    name: \"Sec-Fetch-User\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-Fetch-User\"\n  },\n  {\n    name: \"Sec-GPC\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-GPC\"\n  },\n  {\n    name: \"Sec-Purpose\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-Purpose\"\n  },\n  {\n    name: \"Sec-WebSocket-Accept\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-WebSocket-Accept\"\n  },\n  {\n    name: \"Server\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Server\"\n  },\n  {\n    name: \"Server-Timing\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Server-Timing\"\n  },\n  {\n    name: \"Service-Worker-Navigation-Preload\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Service-Worker-Navigation-Preload\"\n  },\n  {\n    name: \"Set-Cookie\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie\"\n  },\n  {\n    name: \"SourceMap\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/SourceMap\"\n  },\n  {\n    name: \"Strict-Transport-Security\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security\"\n  },\n  {\n    name: \"TE\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/TE\"\n  },\n  {\n    name: \"Timing-Allow-Origin\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Timing-Allow-Origin\"\n  },\n  {\n    name: \"Tk\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Tk\"\n  },\n  {\n    name: \"Trailer\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Trailer\"\n  },\n  {\n    name: \"Transfer-Encoding\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Transfer-Encoding\"\n  },\n  {\n    name: \"Upgrade\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade\"\n  },\n  {\n    name: \"Upgrade-Insecure-Requests\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade-Insecure-Requests\"\n  },\n  {\n    name: \"User-Agent\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/User-Agent\"\n  },\n  {\n    name: \"Vary\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Vary\"\n  },\n  {\n    name: \"Via\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Via\"\n  },\n  {\n    name: \"Viewport-Width\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Viewport-Width\"\n  },\n  {\n    name: \"Want-Digest\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Want-Digest\"\n  },\n  {\n    name: \"Warning\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Warning\"\n  },\n  {\n    name: \"Width\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Width\"\n  },\n  {\n    name: \"WWW-Authenticate\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/WWW-Authenticate\"\n  },\n  {\n    name: \"X-Content-Type-Options\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options\"\n  },\n  {\n    name: \"X-DNS-Prefetch-Control\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-DNS-Prefetch-Control\"\n  },\n  {\n    name: \"Non-standard\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Non-standard\"\n  },\n  {\n    name: \"X-Forwarded-For\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For\"\n  },\n  {\n    name: \"Non-standard\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Non-standard\"\n  },\n  {\n    name: \"X-Forwarded-Host\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Host\"\n  },\n  {\n    name: \"Non-standard\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Non-standard\"\n  },\n  {\n    name: \"X-Forwarded-Proto\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Proto\"\n  },\n  {\n    name: \"Non-standard\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Non-standard\"\n  },\n  {\n    name: \"X-Frame-Options\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options\"\n  },\n  {\n    name: \"X-XSS-Protection\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection\"\n  },\n  {\n    name: \"Cf-Cache-Status\",\n    url: \"https://developers.cloudflare.com/cache/concepts/default-cache-behavior/#cloudflare-cache-responses\"\n  },\n  {\n    name: \"Cf-Ray\",\n    url: \"https://developers.cloudflare.com/fundamentals/get-started/reference/http-request-headers/#cf-ray\"\n  },\n  {\n    name: \"Report-To\",\n    url: \"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/report-to\"\n  }\n], YR = [\n  \"GET\",\n  \"POST\",\n  \"PUT\",\n  \"HEAD\",\n  \"DELETE\",\n  \"PATCH\",\n  \"OPTIONS\",\n  \"CONNECT\",\n  \"TRACE\"\n];\nfunction jh(t) {\n  return YR.includes(t);\n}\nconst zR = {\n  POST: \"var(--scalar-color-green)\",\n  DELETE: \"var(--scalar-color-red)\",\n  PATCH: \"var(--scalar-color-yellow)\",\n  GET: \"var(--scalar-color-blue)\",\n  PUT: \"var(--scalar-color-orange)\",\n  OPTIONS: \"var(--scalar-color-purple)\",\n  HEAD: \"var(--scalar-color-2)\",\n  CONNECT: \"var(--scalar-color-2)\",\n  TRACE: \"var(--scalar-color-2)\"\n}, HR = {\n  POST: \"POST\",\n  DELETE: \"DEL\",\n  PATCH: \"PATCH\",\n  GET: \"GET\",\n  PUT: \"PUT\",\n  OPTIONS: \"OPTS\",\n  HEAD: \"HEAD\",\n  CONNECT: \"CONN\",\n  TRACE: \"TRACE\"\n}, FR = /* @__PURE__ */ le({\n  __name: \"HttpMethod\",\n  props: {\n    as: {},\n    property: {},\n    short: { type: Boolean },\n    method: {}\n  },\n  setup(t) {\n    const e = t, n = j(() => e.method.trim().toUpperCase()), r = j(() => jh(n.value) ? HR[n.value] : n.value.slice(0, 4)), i = j(() => jh(n.value) ? zR[n.value] : \"var(--scalar-color-ghost)\");\n    return (s, o) => (Z(), ke(Zl(s.as ?? \"span\"), {\n      style: Br({ [s.property || \"color\"]: i.value })\n    }, {\n      default: ce(() => [\n        pt(s.$slots, \"default\", my(EO({ normalized: n.value, abbreviated: r.value, color: i.value })), () => [\n          He(De(s.short ? r.value : n.value), 1)\n        ])\n      ]),\n      _: 3\n    }, 8, [\"style\"]));\n  }\n});\nclass Fe {\n  /**\n  Get the line description around the given position.\n  */\n  lineAt(e) {\n    if (e < 0 || e > this.length)\n      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);\n    return this.lineInner(e, !1, 1, 0);\n  }\n  /**\n  Get the description for the given (1-based) line number.\n  */\n  line(e) {\n    if (e < 1 || e > this.lines)\n      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);\n    return this.lineInner(e, !0, 1, 0);\n  }\n  /**\n  Replace a range of the text with the given content.\n  */\n  replace(e, n, r) {\n    [e, n] = Xo(this, e, n);\n    let i = [];\n    return this.decompose(\n      0,\n      e,\n      i,\n      2\n      /* Open.To */\n    ), r.length && r.decompose(\n      0,\n      r.length,\n      i,\n      3\n      /* Open.To */\n    ), this.decompose(\n      n,\n      this.length,\n      i,\n      1\n      /* Open.From */\n    ), Qr.from(i, this.length - (n - e) + r.length);\n  }\n  /**\n  Append another document to this one.\n  */\n  append(e) {\n    return this.replace(this.length, this.length, e);\n  }\n  /**\n  Retrieve the text between the given points.\n  */\n  slice(e, n = this.length) {\n    [e, n] = Xo(this, e, n);\n    let r = [];\n    return this.decompose(e, n, r, 0), Qr.from(r, n - e);\n  }\n  /**\n  Test whether this text is equal to another instance.\n  */\n  eq(e) {\n    if (e == this)\n      return !0;\n    if (e.length != this.length || e.lines != this.lines)\n      return !1;\n    let n = this.scanIdentical(e, 1), r = this.length - this.scanIdentical(e, -1), i = new qa(this), s = new qa(e);\n    for (let o = n, a = n; ; ) {\n      if (i.next(o), s.next(o), o = 0, i.lineBreak != s.lineBreak || i.done != s.done || i.value != s.value)\n        return !1;\n      if (a += i.value.length, i.done || a >= r)\n        return !0;\n    }\n  }\n  /**\n  Iterate over the text. When `dir` is `-1`, iteration happens\n  from end to start. This will return lines and the breaks between\n  them as separate strings.\n  */\n  iter(e = 1) {\n    return new qa(this, e);\n  }\n  /**\n  Iterate over a range of the text. When `from` > `to`, the\n  iterator will run in reverse.\n  */\n  iterRange(e, n = this.length) {\n    return new Rw(this, e, n);\n  }\n  /**\n  Return a cursor that iterates over the given range of lines,\n  _without_ returning the line breaks between, and yielding empty\n  strings for empty lines.\n  \n  When `from` and `to` are given, they should be 1-based line numbers.\n  */\n  iterLines(e, n) {\n    let r;\n    if (e == null)\n      r = this.iter();\n    else {\n      n == null && (n = this.lines + 1);\n      let i = this.line(e).from;\n      r = this.iterRange(i, Math.max(i, n == this.lines + 1 ? this.length : n <= 1 ? 0 : this.line(n - 1).to));\n    }\n    return new Nw(r);\n  }\n  /**\n  Return the document as a string, using newline characters to\n  separate lines.\n  */\n  toString() {\n    return this.sliceString(0);\n  }\n  /**\n  Convert the document to an array of lines (which can be\n  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).\n  */\n  toJSON() {\n    let e = [];\n    return this.flatten(e), e;\n  }\n  /**\n  @internal\n  */\n  constructor() {\n  }\n  /**\n  Create a `Text` instance for the given array of lines.\n  */\n  static of(e) {\n    if (e.length == 0)\n      throw new RangeError(\"A document must have at least one line\");\n    return e.length == 1 && !e[0] ? Fe.empty : e.length <= 32 ? new wt(e) : Qr.from(wt.split(e, []));\n  }\n}\nclass wt extends Fe {\n  constructor(e, n = GR(e)) {\n    super(), this.text = e, this.length = n;\n  }\n  get lines() {\n    return this.text.length;\n  }\n  get children() {\n    return null;\n  }\n  lineInner(e, n, r, i) {\n    for (let s = 0; ; s++) {\n      let o = this.text[s], a = i + o.length;\n      if ((n ? r : a) >= e)\n        return new KR(i, a, r, o);\n      i = a + 1, r++;\n    }\n  }\n  decompose(e, n, r, i) {\n    let s = e <= 0 && n >= this.length ? this : new wt(Rb(this.text, e, n), Math.min(n, this.length) - Math.max(0, e));\n    if (i & 1) {\n      let o = r.pop(), a = tu(s.text, o.text.slice(), 0, s.length);\n      if (a.length <= 32)\n        r.push(new wt(a, o.length + s.length));\n      else {\n        let l = a.length >> 1;\n        r.push(new wt(a.slice(0, l)), new wt(a.slice(l)));\n      }\n    } else\n      r.push(s);\n  }\n  replace(e, n, r) {\n    if (!(r instanceof wt))\n      return super.replace(e, n, r);\n    [e, n] = Xo(this, e, n);\n    let i = tu(this.text, tu(r.text, Rb(this.text, 0, e)), n), s = this.length + r.length - (n - e);\n    return i.length <= 32 ? new wt(i, s) : Qr.from(wt.split(i, []), s);\n  }\n  sliceString(e, n = this.length, r = `\n`) {\n    [e, n] = Xo(this, e, n);\n    let i = \"\";\n    for (let s = 0, o = 0; s <= n && o < this.text.length; o++) {\n      let a = this.text[o], l = s + a.length;\n      s > e && o && (i += r), e < l && n > s && (i += a.slice(Math.max(0, e - s), n - s)), s = l + 1;\n    }\n    return i;\n  }\n  flatten(e) {\n    for (let n of this.text)\n      e.push(n);\n  }\n  scanIdentical() {\n    return 0;\n  }\n  static split(e, n) {\n    let r = [], i = -1;\n    for (let s of e)\n      r.push(s), i += s.length + 1, r.length == 32 && (n.push(new wt(r, i)), r = [], i = -1);\n    return i > -1 && n.push(new wt(r, i)), n;\n  }\n}\nclass Qr extends Fe {\n  constructor(e, n) {\n    super(), this.children = e, this.length = n, this.lines = 0;\n    for (let r of e)\n      this.lines += r.lines;\n  }\n  lineInner(e, n, r, i) {\n    for (let s = 0; ; s++) {\n      let o = this.children[s], a = i + o.length, l = r + o.lines - 1;\n      if ((n ? l : a) >= e)\n        return o.lineInner(e, n, r, i);\n      i = a + 1, r = l + 1;\n    }\n  }\n  decompose(e, n, r, i) {\n    for (let s = 0, o = 0; o <= n && s < this.children.length; s++) {\n      let a = this.children[s], l = o + a.length;\n      if (e <= l && n >= o) {\n        let c = i & ((o <= e ? 1 : 0) | (l >= n ? 2 : 0));\n        o >= e && l <= n && !c ? r.push(a) : a.decompose(e - o, n - o, r, c);\n      }\n      o = l + 1;\n    }\n  }\n  replace(e, n, r) {\n    if ([e, n] = Xo(this, e, n), r.lines < this.lines)\n      for (let i = 0, s = 0; i < this.children.length; i++) {\n        let o = this.children[i], a = s + o.length;\n        if (e >= s && n <= a) {\n          let l = o.replace(e - s, n - s, r), c = this.lines - o.lines + l.lines;\n          if (l.lines < c >> 4 && l.lines > c >> 6) {\n            let u = this.children.slice();\n            return u[i] = l, new Qr(u, this.length - (n - e) + r.length);\n          }\n          return super.replace(s, a, l);\n        }\n        s = a + 1;\n      }\n    return super.replace(e, n, r);\n  }\n  sliceString(e, n = this.length, r = `\n`) {\n    [e, n] = Xo(this, e, n);\n    let i = \"\";\n    for (let s = 0, o = 0; s < this.children.length && o <= n; s++) {\n      let a = this.children[s], l = o + a.length;\n      o > e && s && (i += r), e < l && n > o && (i += a.sliceString(e - o, n - o, r)), o = l + 1;\n    }\n    return i;\n  }\n  flatten(e) {\n    for (let n of this.children)\n      n.flatten(e);\n  }\n  scanIdentical(e, n) {\n    if (!(e instanceof Qr))\n      return 0;\n    let r = 0, [i, s, o, a] = n > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];\n    for (; ; i += n, s += n) {\n      if (i == o || s == a)\n        return r;\n      let l = this.children[i], c = e.children[s];\n      if (l != c)\n        return r + l.scanIdentical(c, n);\n      r += l.length + 1;\n    }\n  }\n  static from(e, n = e.reduce((r, i) => r + i.length + 1, -1)) {\n    let r = 0;\n    for (let h of e)\n      r += h.lines;\n    if (r < 32) {\n      let h = [];\n      for (let p of e)\n        p.flatten(h);\n      return new wt(h, n);\n    }\n    let i = Math.max(\n      32,\n      r >> 5\n      /* Tree.BranchShift */\n    ), s = i << 1, o = i >> 1, a = [], l = 0, c = -1, u = [];\n    function d(h) {\n      let p;\n      if (h.lines > s && h instanceof Qr)\n        for (let O of h.children)\n          d(O);\n      else\n        h.lines > o && (l > o || !l) ? (f(), a.push(h)) : h instanceof wt && l && (p = u[u.length - 1]) instanceof wt && h.lines + p.lines <= 32 ? (l += h.lines, c += h.length + 1, u[u.length - 1] = new wt(p.text.concat(h.text), p.length + 1 + h.length)) : (l + h.lines > i && f(), l += h.lines, c += h.length + 1, u.push(h));\n    }\n    function f() {\n      l != 0 && (a.push(u.length == 1 ? u[0] : Qr.from(u, c)), c = -1, l = u.length = 0);\n    }\n    for (let h of e)\n      d(h);\n    return f(), a.length == 1 ? a[0] : new Qr(a, n);\n  }\n}\nFe.empty = /* @__PURE__ */ new wt([\"\"], 0);\nfunction GR(t) {\n  let e = -1;\n  for (let n of t)\n    e += n.length + 1;\n  return e;\n}\nfunction tu(t, e, n = 0, r = 1e9) {\n  for (let i = 0, s = 0, o = !0; s < t.length && i <= r; s++) {\n    let a = t[s], l = i + a.length;\n    l >= n && (l > r && (a = a.slice(0, r - i)), i < n && (a = a.slice(n - i)), o ? (e[e.length - 1] += a, o = !1) : e.push(a)), i = l + 1;\n  }\n  return e;\n}\nfunction Rb(t, e, n) {\n  return tu(t, [\"\"], e, n);\n}\nclass qa {\n  constructor(e, n = 1) {\n    this.dir = n, this.done = !1, this.lineBreak = !1, this.value = \"\", this.nodes = [e], this.offsets = [n > 0 ? 1 : (e instanceof wt ? e.text.length : e.children.length) << 1];\n  }\n  nextInner(e, n) {\n    for (this.done = this.lineBreak = !1; ; ) {\n      let r = this.nodes.length - 1, i = this.nodes[r], s = this.offsets[r], o = s >> 1, a = i instanceof wt ? i.text.length : i.children.length;\n      if (o == (n > 0 ? a : 0)) {\n        if (r == 0)\n          return this.done = !0, this.value = \"\", this;\n        n > 0 && this.offsets[r - 1]++, this.nodes.pop(), this.offsets.pop();\n      } else if ((s & 1) == (n > 0 ? 0 : 1)) {\n        if (this.offsets[r] += n, e == 0)\n          return this.lineBreak = !0, this.value = `\n`, this;\n        e--;\n      } else if (i instanceof wt) {\n        let l = i.text[o + (n < 0 ? -1 : 0)];\n        if (this.offsets[r] += n, l.length > Math.max(0, e))\n          return this.value = e == 0 ? l : n > 0 ? l.slice(e) : l.slice(0, l.length - e), this;\n        e -= l.length;\n      } else {\n        let l = i.children[o + (n < 0 ? -1 : 0)];\n        e > l.length ? (e -= l.length, this.offsets[r] += n) : (n < 0 && this.offsets[r]--, this.nodes.push(l), this.offsets.push(n > 0 ? 1 : (l instanceof wt ? l.text.length : l.children.length) << 1));\n      }\n    }\n  }\n  next(e = 0) {\n    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);\n  }\n}\nclass Rw {\n  constructor(e, n, r) {\n    this.value = \"\", this.done = !1, this.cursor = new qa(e, n > r ? -1 : 1), this.pos = n > r ? e.length : 0, this.from = Math.min(n, r), this.to = Math.max(n, r);\n  }\n  nextInner(e, n) {\n    if (n < 0 ? this.pos <= this.from : this.pos >= this.to)\n      return this.value = \"\", this.done = !0, this;\n    e += Math.max(0, n < 0 ? this.pos - this.to : this.from - this.pos);\n    let r = n < 0 ? this.pos - this.from : this.to - this.pos;\n    e > r && (e = r), r -= e;\n    let { value: i } = this.cursor.next(e);\n    return this.pos += (i.length + e) * n, this.value = i.length <= r ? i : n < 0 ? i.slice(i.length - r) : i.slice(0, r), this.done = !this.value, this;\n  }\n  next(e = 0) {\n    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);\n  }\n  get lineBreak() {\n    return this.cursor.lineBreak && this.value != \"\";\n  }\n}\nclass Nw {\n  constructor(e) {\n    this.inner = e, this.afterBreak = !0, this.value = \"\", this.done = !1;\n  }\n  next(e = 0) {\n    let { done: n, lineBreak: r, value: i } = this.inner.next(e);\n    return n && this.afterBreak ? (this.value = \"\", this.afterBreak = !1) : n ? (this.done = !0, this.value = \"\") : r ? this.afterBreak ? this.value = \"\" : (this.afterBreak = !0, this.next()) : (this.value = i, this.afterBreak = !1), this;\n  }\n  get lineBreak() {\n    return !1;\n  }\n}\ntypeof Symbol < \"u\" && (Fe.prototype[Symbol.iterator] = function() {\n  return this.iter();\n}, qa.prototype[Symbol.iterator] = Rw.prototype[Symbol.iterator] = Nw.prototype[Symbol.iterator] = function() {\n  return this;\n});\nclass KR {\n  /**\n  @internal\n  */\n  constructor(e, n, r, i) {\n    this.from = e, this.to = n, this.number = r, this.text = i;\n  }\n  /**\n  The length of the line (not including any line break after it).\n  */\n  get length() {\n    return this.to - this.from;\n  }\n}\nfunction Xo(t, e, n) {\n  return e = Math.max(0, Math.min(t.length, e)), [e, Math.max(e, Math.min(t.length, n))];\n}\nlet Po = /* @__PURE__ */ \"lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o\".split(\",\").map((t) => t ? parseInt(t, 36) : 1);\nfor (let t = 1; t < Po.length; t++)\n  Po[t] += Po[t - 1];\nfunction JR(t) {\n  for (let e = 1; e < Po.length; e += 2)\n    if (Po[e] > t)\n      return Po[e - 1] <= t;\n  return !1;\n}\nfunction Nb(t) {\n  return t >= 127462 && t <= 127487;\n}\nconst Db = 8205;\nfunction Rr(t, e, n = !0, r = !0) {\n  return (n ? Dw : eN)(t, e, r);\n}\nfunction Dw(t, e, n) {\n  if (e == t.length)\n    return e;\n  e && Zw(t.charCodeAt(e)) && Vw(t.charCodeAt(e - 1)) && e--;\n  let r = nn(t, e);\n  for (e += cr(r); e < t.length; ) {\n    let i = nn(t, e);\n    if (r == Db || i == Db || n && JR(i))\n      e += cr(i), r = i;\n    else if (Nb(i)) {\n      let s = 0, o = e - 2;\n      for (; o >= 0 && Nb(nn(t, o)); )\n        s++, o -= 2;\n      if (s % 2 == 0)\n        break;\n      e += 2;\n    } else\n      break;\n  }\n  return e;\n}\nfunction eN(t, e, n) {\n  for (; e > 0; ) {\n    let r = Dw(t, e - 2, n);\n    if (r < e)\n      return r;\n    e--;\n  }\n  return 0;\n}\nfunction Zw(t) {\n  return t >= 56320 && t < 57344;\n}\nfunction Vw(t) {\n  return t >= 55296 && t < 56320;\n}\nfunction nn(t, e) {\n  let n = t.charCodeAt(e);\n  if (!Vw(n) || e + 1 == t.length)\n    return n;\n  let r = t.charCodeAt(e + 1);\n  return Zw(r) ? (n - 55296 << 10) + (r - 56320) + 65536 : n;\n}\nfunction Iw(t) {\n  return t <= 65535 ? String.fromCharCode(t) : (t -= 65536, String.fromCharCode((t >> 10) + 55296, (t & 1023) + 56320));\n}\nfunction cr(t) {\n  return t < 65536 ? 1 : 2;\n}\nconst Bh = /\\r\\n?|\\n/;\nvar on = /* @__PURE__ */ function(t) {\n  return t[t.Simple = 0] = \"Simple\", t[t.TrackDel = 1] = \"TrackDel\", t[t.TrackBefore = 2] = \"TrackBefore\", t[t.TrackAfter = 3] = \"TrackAfter\", t;\n}(on || (on = {}));\nclass ii {\n  // Sections are encoded as pairs of integers. The first is the\n  // length in the current document, and the second is -1 for\n  // unaffected sections, and the length of the replacement content\n  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,\n  // 0), and a replacement two positive numbers.\n  /**\n  @internal\n  */\n  constructor(e) {\n    this.sections = e;\n  }\n  /**\n  The length of the document before the change.\n  */\n  get length() {\n    let e = 0;\n    for (let n = 0; n < this.sections.length; n += 2)\n      e += this.sections[n];\n    return e;\n  }\n  /**\n  The length of the document after the change.\n  */\n  get newLength() {\n    let e = 0;\n    for (let n = 0; n < this.sections.length; n += 2) {\n      let r = this.sections[n + 1];\n      e += r < 0 ? this.sections[n] : r;\n    }\n    return e;\n  }\n  /**\n  False when there are actual changes in this set.\n  */\n  get empty() {\n    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;\n  }\n  /**\n  Iterate over the unchanged parts left by these changes. `posA`\n  provides the position of the range in the old document, `posB`\n  the new position in the changed document.\n  */\n  iterGaps(e) {\n    for (let n = 0, r = 0, i = 0; n < this.sections.length; ) {\n      let s = this.sections[n++], o = this.sections[n++];\n      o < 0 ? (e(r, i, s), i += s) : i += o, r += s;\n    }\n  }\n  /**\n  Iterate over the ranges changed by these changes. (See\n  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a\n  variant that also provides you with the inserted text.)\n  `fromA`/`toA` provides the extent of the change in the starting\n  document, `fromB`/`toB` the extent of the replacement in the\n  changed document.\n  \n  When `individual` is true, adjacent changes (which are kept\n  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are\n  reported separately.\n  */\n  iterChangedRanges(e, n = !1) {\n    Lh(this, e, n);\n  }\n  /**\n  Get a description of the inverted form of these changes.\n  */\n  get invertedDesc() {\n    let e = [];\n    for (let n = 0; n < this.sections.length; ) {\n      let r = this.sections[n++], i = this.sections[n++];\n      i < 0 ? e.push(r, i) : e.push(i, r);\n    }\n    return new ii(e);\n  }\n  /**\n  Compute the combined effect of applying another set of changes\n  after this one. The length of the document after this set should\n  match the length before `other`.\n  */\n  composeDesc(e) {\n    return this.empty ? e : e.empty ? this : Ww(this, e);\n  }\n  /**\n  Map this description, which should start with the same document\n  as `other`, over another set of changes, so that it can be\n  applied after it. When `before` is true, map as if the changes\n  in `other` happened before the ones in `this`.\n  */\n  mapDesc(e, n = !1) {\n    return e.empty ? this : Uh(this, e, n);\n  }\n  mapPos(e, n = -1, r = on.Simple) {\n    let i = 0, s = 0;\n    for (let o = 0; o < this.sections.length; ) {\n      let a = this.sections[o++], l = this.sections[o++], c = i + a;\n      if (l < 0) {\n        if (c > e)\n          return s + (e - i);\n        s += a;\n      } else {\n        if (r != on.Simple && c >= e && (r == on.TrackDel && i < e && c > e || r == on.TrackBefore && i < e || r == on.TrackAfter && c > e))\n          return null;\n        if (c > e || c == e && n < 0 && !a)\n          return e == i || n < 0 ? s : s + l;\n        s += l;\n      }\n      i = c;\n    }\n    if (e > i)\n      throw new RangeError(`Position ${e} is out of range for changeset of length ${i}`);\n    return s;\n  }\n  /**\n  Check whether these changes touch a given range. When one of the\n  changes entirely covers the range, the string `\"cover\"` is\n  returned.\n  */\n  touchesRange(e, n = e) {\n    for (let r = 0, i = 0; r < this.sections.length && i <= n; ) {\n      let s = this.sections[r++], o = this.sections[r++], a = i + s;\n      if (o >= 0 && i <= n && a >= e)\n        return i < e && a > n ? \"cover\" : !0;\n      i = a;\n    }\n    return !1;\n  }\n  /**\n  @internal\n  */\n  toString() {\n    let e = \"\";\n    for (let n = 0; n < this.sections.length; ) {\n      let r = this.sections[n++], i = this.sections[n++];\n      e += (e ? \" \" : \"\") + r + (i >= 0 ? \":\" + i : \"\");\n    }\n    return e;\n  }\n  /**\n  Serialize this change desc to a JSON-representable value.\n  */\n  toJSON() {\n    return this.sections;\n  }\n  /**\n  Create a change desc from its JSON representation (as produced\n  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).\n  */\n  static fromJSON(e) {\n    if (!Array.isArray(e) || e.length % 2 || e.some((n) => typeof n != \"number\"))\n      throw new RangeError(\"Invalid JSON representation of ChangeDesc\");\n    return new ii(e);\n  }\n  /**\n  @internal\n  */\n  static create(e) {\n    return new ii(e);\n  }\n}\nclass Mt extends ii {\n  constructor(e, n) {\n    super(e), this.inserted = n;\n  }\n  /**\n  Apply the changes to a document, returning the modified\n  document.\n  */\n  apply(e) {\n    if (this.length != e.length)\n      throw new RangeError(\"Applying change set to a document with the wrong length\");\n    return Lh(this, (n, r, i, s, o) => e = e.replace(i, i + (r - n), o), !1), e;\n  }\n  mapDesc(e, n = !1) {\n    return Uh(this, e, n, !0);\n  }\n  /**\n  Given the document as it existed _before_ the changes, return a\n  change set that represents the inverse of this set, which could\n  be used to go from the document created by the changes back to\n  the document as it existed before the changes.\n  */\n  invert(e) {\n    let n = this.sections.slice(), r = [];\n    for (let i = 0, s = 0; i < n.length; i += 2) {\n      let o = n[i], a = n[i + 1];\n      if (a >= 0) {\n        n[i] = a, n[i + 1] = o;\n        let l = i >> 1;\n        for (; r.length < l; )\n          r.push(Fe.empty);\n        r.push(o ? e.slice(s, s + o) : Fe.empty);\n      }\n      s += o;\n    }\n    return new Mt(n, r);\n  }\n  /**\n  Combine two subsequent change sets into a single set. `other`\n  must start in the document produced by `this`. If `this` goes\n  `docA`  `docB` and `other` represents `docB`  `docC`, the\n  returned value will represent the change `docA`  `docC`.\n  */\n  compose(e) {\n    return this.empty ? e : e.empty ? this : Ww(this, e, !0);\n  }\n  /**\n  Given another change set starting in the same document, maps this\n  change set over the other, producing a new change set that can be\n  applied to the document produced by applying `other`. When\n  `before` is `true`, order changes as if `this` comes before\n  `other`, otherwise (the default) treat `other` as coming first.\n  \n  Given two changes `A` and `B`, `A.compose(B.map(A))` and\n  `B.compose(A.map(B, true))` will produce the same document. This\n  provides a basic form of [operational\n  transformation](https://en.wikipedia.org/wiki/Operational_transformation),\n  and can be used for collaborative editing.\n  */\n  map(e, n = !1) {\n    return e.empty ? this : Uh(this, e, n, !0);\n  }\n  /**\n  Iterate over the changed ranges in the document, calling `f` for\n  each, with the range in the original document (`fromA`-`toA`)\n  and the range that replaces it in the new document\n  (`fromB`-`toB`).\n  \n  When `individual` is true, adjacent changes are reported\n  separately.\n  */\n  iterChanges(e, n = !1) {\n    Lh(this, e, n);\n  }\n  /**\n  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change\n  set.\n  */\n  get desc() {\n    return ii.create(this.sections);\n  }\n  /**\n  @internal\n  */\n  filter(e) {\n    let n = [], r = [], i = [], s = new fl(this);\n    e:\n      for (let o = 0, a = 0; ; ) {\n        let l = o == e.length ? 1e9 : e[o++];\n        for (; a < l || a == l && s.len == 0; ) {\n          if (s.done)\n            break e;\n          let u = Math.min(s.len, l - a);\n          tn(i, u, -1);\n          let d = s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0;\n          tn(n, u, d), d > 0 && ji(r, n, s.text), s.forward(u), a += u;\n        }\n        let c = e[o++];\n        for (; a < c; ) {\n          if (s.done)\n            break e;\n          let u = Math.min(s.len, c - a);\n          tn(n, u, -1), tn(i, u, s.ins == -1 ? -1 : s.off == 0 ? s.ins : 0), s.forward(u), a += u;\n        }\n      }\n    return {\n      changes: new Mt(n, r),\n      filtered: ii.create(i)\n    };\n  }\n  /**\n  Serialize this change set to a JSON-representable value.\n  */\n  toJSON() {\n    let e = [];\n    for (let n = 0; n < this.sections.length; n += 2) {\n      let r = this.sections[n], i = this.sections[n + 1];\n      i < 0 ? e.push(r) : i == 0 ? e.push([r]) : e.push([r].concat(this.inserted[n >> 1].toJSON()));\n    }\n    return e;\n  }\n  /**\n  Create a change set for the given changes, for a document of the\n  given length, using `lineSep` as line separator.\n  */\n  static of(e, n, r) {\n    let i = [], s = [], o = 0, a = null;\n    function l(u = !1) {\n      if (!u && !i.length)\n        return;\n      o < n && tn(i, n - o, -1);\n      let d = new Mt(i, s);\n      a = a ? a.compose(d.map(a)) : d, i = [], s = [], o = 0;\n    }\n    function c(u) {\n      if (Array.isArray(u))\n        for (let d of u)\n          c(d);\n      else if (u instanceof Mt) {\n        if (u.length != n)\n          throw new RangeError(`Mismatched change set length (got ${u.length}, expected ${n})`);\n        l(), a = a ? a.compose(u.map(a)) : u;\n      } else {\n        let { from: d, to: f = d, insert: h } = u;\n        if (d > f || d < 0 || f > n)\n          throw new RangeError(`Invalid change range ${d} to ${f} (in doc of length ${n})`);\n        let p = h ? typeof h == \"string\" ? Fe.of(h.split(r || Bh)) : h : Fe.empty, O = p.length;\n        if (d == f && O == 0)\n          return;\n        d < o && l(), d > o && tn(i, d - o, -1), tn(i, f - d, O), ji(s, i, p), o = f;\n      }\n    }\n    return c(e), l(!a), a;\n  }\n  /**\n  Create an empty changeset of the given length.\n  */\n  static empty(e) {\n    return new Mt(e ? [e, -1] : [], []);\n  }\n  /**\n  Create a changeset from its JSON representation (as produced by\n  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).\n  */\n  static fromJSON(e) {\n    if (!Array.isArray(e))\n      throw new RangeError(\"Invalid JSON representation of ChangeSet\");\n    let n = [], r = [];\n    for (let i = 0; i < e.length; i++) {\n      let s = e[i];\n      if (typeof s == \"number\")\n        n.push(s, -1);\n      else {\n        if (!Array.isArray(s) || typeof s[0] != \"number\" || s.some((o, a) => a && typeof o != \"string\"))\n          throw new RangeError(\"Invalid JSON representation of ChangeSet\");\n        if (s.length == 1)\n          n.push(s[0], 0);\n        else {\n          for (; r.length < i; )\n            r.push(Fe.empty);\n          r[i] = Fe.of(s.slice(1)), n.push(s[0], r[i].length);\n        }\n      }\n    }\n    return new Mt(n, r);\n  }\n  /**\n  @internal\n  */\n  static createSet(e, n) {\n    return new Mt(e, n);\n  }\n}\nfunction tn(t, e, n, r = !1) {\n  if (e == 0 && n <= 0)\n    return;\n  let i = t.length - 2;\n  i >= 0 && n <= 0 && n == t[i + 1] ? t[i] += e : e == 0 && t[i] == 0 ? t[i + 1] += n : r ? (t[i] += e, t[i + 1] += n) : t.push(e, n);\n}\nfunction ji(t, e, n) {\n  if (n.length == 0)\n    return;\n  let r = e.length - 2 >> 1;\n  if (r < t.length)\n    t[t.length - 1] = t[t.length - 1].append(n);\n  else {\n    for (; t.length < r; )\n      t.push(Fe.empty);\n    t.push(n);\n  }\n}\nfunction Lh(t, e, n) {\n  let r = t.inserted;\n  for (let i = 0, s = 0, o = 0; o < t.sections.length; ) {\n    let a = t.sections[o++], l = t.sections[o++];\n    if (l < 0)\n      i += a, s += a;\n    else {\n      let c = i, u = s, d = Fe.empty;\n      for (; c += a, u += l, l && r && (d = d.append(r[o - 2 >> 1])), !(n || o == t.sections.length || t.sections[o + 1] < 0); )\n        a = t.sections[o++], l = t.sections[o++];\n      e(i, c, s, u, d), i = c, s = u;\n    }\n  }\n}\nfunction Uh(t, e, n, r = !1) {\n  let i = [], s = r ? [] : null, o = new fl(t), a = new fl(e);\n  for (let l = -1; ; )\n    if (o.ins == -1 && a.ins == -1) {\n      let c = Math.min(o.len, a.len);\n      tn(i, c, -1), o.forward(c), a.forward(c);\n    } else if (a.ins >= 0 && (o.ins < 0 || l == o.i || o.off == 0 && (a.len < o.len || a.len == o.len && !n))) {\n      let c = a.len;\n      for (tn(i, a.ins, -1); c; ) {\n        let u = Math.min(o.len, c);\n        o.ins >= 0 && l < o.i && o.len <= u && (tn(i, 0, o.ins), s && ji(s, i, o.text), l = o.i), o.forward(u), c -= u;\n      }\n      a.next();\n    } else if (o.ins >= 0) {\n      let c = 0, u = o.len;\n      for (; u; )\n        if (a.ins == -1) {\n          let d = Math.min(u, a.len);\n          c += d, u -= d, a.forward(d);\n        } else if (a.ins == 0 && a.len < u)\n          u -= a.len, a.next();\n        else\n          break;\n      tn(i, c, l < o.i ? o.ins : 0), s && l < o.i && ji(s, i, o.text), l = o.i, o.forward(o.len - u);\n    } else {\n      if (o.done && a.done)\n        return s ? Mt.createSet(i, s) : ii.create(i);\n      throw new Error(\"Mismatched change set lengths\");\n    }\n}\nfunction Ww(t, e, n = !1) {\n  let r = [], i = n ? [] : null, s = new fl(t), o = new fl(e);\n  for (let a = !1; ; ) {\n    if (s.done && o.done)\n      return i ? Mt.createSet(r, i) : ii.create(r);\n    if (s.ins == 0)\n      tn(r, s.len, 0, a), s.next();\n    else if (o.len == 0 && !o.done)\n      tn(r, 0, o.ins, a), i && ji(i, r, o.text), o.next();\n    else {\n      if (s.done || o.done)\n        throw new Error(\"Mismatched change set lengths\");\n      {\n        let l = Math.min(s.len2, o.len), c = r.length;\n        if (s.ins == -1) {\n          let u = o.ins == -1 ? -1 : o.off ? 0 : o.ins;\n          tn(r, l, u, a), i && u && ji(i, r, o.text);\n        } else\n          o.ins == -1 ? (tn(r, s.off ? 0 : s.len, l, a), i && ji(i, r, s.textBit(l))) : (tn(r, s.off ? 0 : s.len, o.off ? 0 : o.ins, a), i && !o.off && ji(i, r, o.text));\n        a = (s.ins > l || o.ins >= 0 && o.len > l) && (a || r.length > c), s.forward2(l), o.forward(l);\n      }\n    }\n  }\n}\nclass fl {\n  constructor(e) {\n    this.set = e, this.i = 0, this.next();\n  }\n  next() {\n    let { sections: e } = this.set;\n    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;\n  }\n  get done() {\n    return this.ins == -2;\n  }\n  get len2() {\n    return this.ins < 0 ? this.len : this.ins;\n  }\n  get text() {\n    let { inserted: e } = this.set, n = this.i - 2 >> 1;\n    return n >= e.length ? Fe.empty : e[n];\n  }\n  textBit(e) {\n    let { inserted: n } = this.set, r = this.i - 2 >> 1;\n    return r >= n.length && !e ? Fe.empty : n[r].slice(this.off, e == null ? void 0 : this.off + e);\n  }\n  forward(e) {\n    e == this.len ? this.next() : (this.len -= e, this.off += e);\n  }\n  forward2(e) {\n    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);\n  }\n}\nclass xs {\n  constructor(e, n, r) {\n    this.from = e, this.to = n, this.flags = r;\n  }\n  /**\n  The anchor of the rangethe side that doesn't move when you\n  extend it.\n  */\n  get anchor() {\n    return this.flags & 32 ? this.to : this.from;\n  }\n  /**\n  The head of the range, which is moved when the range is\n  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).\n  */\n  get head() {\n    return this.flags & 32 ? this.from : this.to;\n  }\n  /**\n  True when `anchor` and `head` are at the same position.\n  */\n  get empty() {\n    return this.from == this.to;\n  }\n  /**\n  If this is a cursor that is explicitly associated with the\n  character on one of its sides, this returns the side. -1 means\n  the character before its position, 1 the character after, and 0\n  means no association.\n  */\n  get assoc() {\n    return this.flags & 8 ? -1 : this.flags & 16 ? 1 : 0;\n  }\n  /**\n  The bidirectional text level associated with this cursor, if\n  any.\n  */\n  get bidiLevel() {\n    let e = this.flags & 7;\n    return e == 7 ? null : e;\n  }\n  /**\n  The goal column (stored vertical offset) associated with a\n  cursor. This is used to preserve the vertical position when\n  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across\n  lines of different length.\n  */\n  get goalColumn() {\n    let e = this.flags >> 6;\n    return e == 16777215 ? void 0 : e;\n  }\n  /**\n  Map this range through a change, producing a valid range in the\n  updated document.\n  */\n  map(e, n = -1) {\n    let r, i;\n    return this.empty ? r = i = e.mapPos(this.from, n) : (r = e.mapPos(this.from, 1), i = e.mapPos(this.to, -1)), r == this.from && i == this.to ? this : new xs(r, i, this.flags);\n  }\n  /**\n  Extend this range to cover at least `from` to `to`.\n  */\n  extend(e, n = e) {\n    if (e <= this.anchor && n >= this.anchor)\n      return ae.range(e, n);\n    let r = Math.abs(e - this.anchor) > Math.abs(n - this.anchor) ? e : n;\n    return ae.range(this.anchor, r);\n  }\n  /**\n  Compare this range to another range.\n  */\n  eq(e, n = !1) {\n    return this.anchor == e.anchor && this.head == e.head && (!n || !this.empty || this.assoc == e.assoc);\n  }\n  /**\n  Return a JSON-serializable object representing the range.\n  */\n  toJSON() {\n    return { anchor: this.anchor, head: this.head };\n  }\n  /**\n  Convert a JSON representation of a range to a `SelectionRange`\n  instance.\n  */\n  static fromJSON(e) {\n    if (!e || typeof e.anchor != \"number\" || typeof e.head != \"number\")\n      throw new RangeError(\"Invalid JSON representation for SelectionRange\");\n    return ae.range(e.anchor, e.head);\n  }\n  /**\n  @internal\n  */\n  static create(e, n, r) {\n    return new xs(e, n, r);\n  }\n}\nclass ae {\n  constructor(e, n) {\n    this.ranges = e, this.mainIndex = n;\n  }\n  /**\n  Map a selection through a change. Used to adjust the selection\n  position for changes.\n  */\n  map(e, n = -1) {\n    return e.empty ? this : ae.create(this.ranges.map((r) => r.map(e, n)), this.mainIndex);\n  }\n  /**\n  Compare this selection to another selection. By default, ranges\n  are compared only by position. When `includeAssoc` is true,\n  cursor ranges must also have the same\n  [`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.\n  */\n  eq(e, n = !1) {\n    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)\n      return !1;\n    for (let r = 0; r < this.ranges.length; r++)\n      if (!this.ranges[r].eq(e.ranges[r], n))\n        return !1;\n    return !0;\n  }\n  /**\n  Get the primary selection range. Usually, you should make sure\n  your code applies to _all_ ranges, by using methods like\n  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).\n  */\n  get main() {\n    return this.ranges[this.mainIndex];\n  }\n  /**\n  Make sure the selection only has one range. Returns a selection\n  holding only the main range from this selection.\n  */\n  asSingle() {\n    return this.ranges.length == 1 ? this : new ae([this.main], 0);\n  }\n  /**\n  Extend this selection with an extra range.\n  */\n  addRange(e, n = !0) {\n    return ae.create([e].concat(this.ranges), n ? 0 : this.mainIndex + 1);\n  }\n  /**\n  Replace a given range with another range, and then normalize the\n  selection to merge and sort ranges if necessary.\n  */\n  replaceRange(e, n = this.mainIndex) {\n    let r = this.ranges.slice();\n    return r[n] = e, ae.create(r, this.mainIndex);\n  }\n  /**\n  Convert this selection to an object that can be serialized to\n  JSON.\n  */\n  toJSON() {\n    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };\n  }\n  /**\n  Create a selection from a JSON representation.\n  */\n  static fromJSON(e) {\n    if (!e || !Array.isArray(e.ranges) || typeof e.main != \"number\" || e.main >= e.ranges.length)\n      throw new RangeError(\"Invalid JSON representation for EditorSelection\");\n    return new ae(e.ranges.map((n) => xs.fromJSON(n)), e.main);\n  }\n  /**\n  Create a selection holding a single range.\n  */\n  static single(e, n = e) {\n    return new ae([ae.range(e, n)], 0);\n  }\n  /**\n  Sort and merge the given set of ranges, creating a valid\n  selection.\n  */\n  static create(e, n = 0) {\n    if (e.length == 0)\n      throw new RangeError(\"A selection needs at least one range\");\n    for (let r = 0, i = 0; i < e.length; i++) {\n      let s = e[i];\n      if (s.empty ? s.from <= r : s.from < r)\n        return ae.normalized(e.slice(), n);\n      r = s.to;\n    }\n    return new ae(e, n);\n  }\n  /**\n  Create a cursor selection range at the given position. You can\n  safely ignore the optional arguments in most situations.\n  */\n  static cursor(e, n = 0, r, i) {\n    return xs.create(e, e, (n == 0 ? 0 : n < 0 ? 8 : 16) | (r == null ? 7 : Math.min(6, r)) | (i ?? 16777215) << 6);\n  }\n  /**\n  Create a selection range.\n  */\n  static range(e, n, r, i) {\n    let s = (r ?? 16777215) << 6 | (i == null ? 7 : Math.min(6, i));\n    return n < e ? xs.create(n, e, 48 | s) : xs.create(e, n, (n > e ? 8 : 0) | s);\n  }\n  /**\n  @internal\n  */\n  static normalized(e, n = 0) {\n    let r = e[n];\n    e.sort((i, s) => i.from - s.from), n = e.indexOf(r);\n    for (let i = 1; i < e.length; i++) {\n      let s = e[i], o = e[i - 1];\n      if (s.empty ? s.from <= o.to : s.from < o.to) {\n        let a = o.from, l = Math.max(s.to, o.to);\n        i <= n && n--, e.splice(--i, 2, s.anchor > s.head ? ae.range(l, a) : ae.range(a, l));\n      }\n    }\n    return new ae(e, n);\n  }\n}\nfunction Mw(t, e) {\n  for (let n of t.ranges)\n    if (n.to > e)\n      throw new RangeError(\"Selection points outside of document\");\n}\nlet tg = 0;\nclass ve {\n  constructor(e, n, r, i, s) {\n    this.combine = e, this.compareInput = n, this.compare = r, this.isStatic = i, this.id = tg++, this.default = e([]), this.extensions = typeof s == \"function\" ? s(this) : s;\n  }\n  /**\n  Returns a facet reader for this facet, which can be used to\n  [read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.\n  */\n  get reader() {\n    return this;\n  }\n  /**\n  Define a new facet.\n  */\n  static define(e = {}) {\n    return new ve(e.combine || ((n) => n), e.compareInput || ((n, r) => n === r), e.compare || (e.combine ? (n, r) => n === r : ng), !!e.static, e.enables);\n  }\n  /**\n  Returns an extension that adds the given value to this facet.\n  */\n  of(e) {\n    return new nu([], this, 0, e);\n  }\n  /**\n  Create an extension that computes a value for the facet from a\n  state. You must take care to declare the parts of the state that\n  this value depends on, since your function is only called again\n  for a new state when one of those parts changed.\n  \n  In cases where your value depends only on a single field, you'll\n  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.\n  */\n  compute(e, n) {\n    if (this.isStatic)\n      throw new Error(\"Can't compute a static facet\");\n    return new nu(e, this, 1, n);\n  }\n  /**\n  Create an extension that computes zero or more values for this\n  facet from a state.\n  */\n  computeN(e, n) {\n    if (this.isStatic)\n      throw new Error(\"Can't compute a static facet\");\n    return new nu(e, this, 2, n);\n  }\n  from(e, n) {\n    return n || (n = (r) => r), this.compute([e], (r) => n(r.field(e)));\n  }\n}\nfunction ng(t, e) {\n  return t == e || t.length == e.length && t.every((n, r) => n === e[r]);\n}\nclass nu {\n  constructor(e, n, r, i) {\n    this.dependencies = e, this.facet = n, this.type = r, this.value = i, this.id = tg++;\n  }\n  dynamicSlot(e) {\n    var n;\n    let r = this.value, i = this.facet.compareInput, s = this.id, o = e[s] >> 1, a = this.type == 2, l = !1, c = !1, u = [];\n    for (let d of this.dependencies)\n      d == \"doc\" ? l = !0 : d == \"selection\" ? c = !0 : ((n = e[d.id]) !== null && n !== void 0 ? n : 1) & 1 || u.push(e[d.id]);\n    return {\n      create(d) {\n        return d.values[o] = r(d), 1;\n      },\n      update(d, f) {\n        if (l && f.docChanged || c && (f.docChanged || f.selection) || qh(d, u)) {\n          let h = r(d);\n          if (a ? !Zb(h, d.values[o], i) : !i(h, d.values[o]))\n            return d.values[o] = h, 1;\n        }\n        return 0;\n      },\n      reconfigure: (d, f) => {\n        let h, p = f.config.address[s];\n        if (p != null) {\n          let O = Vu(f, p);\n          if (this.dependencies.every((m) => m instanceof ve ? f.facet(m) === d.facet(m) : m instanceof yr ? f.field(m, !1) == d.field(m, !1) : !0) || (a ? Zb(h = r(d), O, i) : i(h = r(d), O)))\n            return d.values[o] = O, 0;\n        } else\n          h = r(d);\n        return d.values[o] = h, 1;\n      }\n    };\n  }\n}\nfunction Zb(t, e, n) {\n  if (t.length != e.length)\n    return !1;\n  for (let r = 0; r < t.length; r++)\n    if (!n(t[r], e[r]))\n      return !1;\n  return !0;\n}\nfunction qh(t, e) {\n  let n = !1;\n  for (let r of e)\n    Ya(t, r) & 1 && (n = !0);\n  return n;\n}\nfunction tN(t, e, n) {\n  let r = n.map((l) => t[l.id]), i = n.map((l) => l.type), s = r.filter((l) => !(l & 1)), o = t[e.id] >> 1;\n  function a(l) {\n    let c = [];\n    for (let u = 0; u < r.length; u++) {\n      let d = Vu(l, r[u]);\n      if (i[u] == 2)\n        for (let f of d)\n          c.push(f);\n      else\n        c.push(d);\n    }\n    return e.combine(c);\n  }\n  return {\n    create(l) {\n      for (let c of r)\n        Ya(l, c);\n      return l.values[o] = a(l), 1;\n    },\n    update(l, c) {\n      if (!qh(l, s))\n        return 0;\n      let u = a(l);\n      return e.compare(u, l.values[o]) ? 0 : (l.values[o] = u, 1);\n    },\n    reconfigure(l, c) {\n      let u = qh(l, r), d = c.config.facets[e.id], f = c.facet(e);\n      if (d && !u && ng(n, d))\n        return l.values[o] = f, 0;\n      let h = a(l);\n      return e.compare(h, f) ? (l.values[o] = f, 0) : (l.values[o] = h, 1);\n    }\n  };\n}\nconst Vb = /* @__PURE__ */ ve.define({ static: !0 });\nclass yr {\n  constructor(e, n, r, i, s) {\n    this.id = e, this.createF = n, this.updateF = r, this.compareF = i, this.spec = s, this.provides = void 0;\n  }\n  /**\n  Define a state field.\n  */\n  static define(e) {\n    let n = new yr(tg++, e.create, e.update, e.compare || ((r, i) => r === i), e);\n    return e.provide && (n.provides = e.provide(n)), n;\n  }\n  create(e) {\n    let n = e.facet(Vb).find((r) => r.field == this);\n    return ((n == null ? void 0 : n.create) || this.createF)(e);\n  }\n  /**\n  @internal\n  */\n  slot(e) {\n    let n = e[this.id] >> 1;\n    return {\n      create: (r) => (r.values[n] = this.create(r), 1),\n      update: (r, i) => {\n        let s = r.values[n], o = this.updateF(s, i);\n        return this.compareF(s, o) ? 0 : (r.values[n] = o, 1);\n      },\n      reconfigure: (r, i) => i.config.address[this.id] != null ? (r.values[n] = i.field(this), 0) : (r.values[n] = this.create(r), 1)\n    };\n  }\n  /**\n  Returns an extension that enables this field and overrides the\n  way it is initialized. Can be useful when you need to provide a\n  non-default starting value for the field.\n  */\n  init(e) {\n    return [this, Vb.of({ field: this, create: e })];\n  }\n  /**\n  State field instances can be used as\n  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a\n  given state.\n  */\n  get extension() {\n    return this;\n  }\n}\nconst Ss = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };\nfunction ba(t) {\n  return (e) => new Xw(e, t);\n}\nconst zl = {\n  /**\n  The highest precedence level, for extensions that should end up\n  near the start of the precedence ordering.\n  */\n  highest: /* @__PURE__ */ ba(Ss.highest),\n  /**\n  A higher-than-default precedence, for extensions that should\n  come before those with default precedence.\n  */\n  high: /* @__PURE__ */ ba(Ss.high),\n  /**\n  The default precedence, which is also used for extensions\n  without an explicit precedence.\n  */\n  default: /* @__PURE__ */ ba(Ss.default),\n  /**\n  A lower-than-default precedence.\n  */\n  low: /* @__PURE__ */ ba(Ss.low),\n  /**\n  The lowest precedence level. Meant for things that should end up\n  near the end of the extension order.\n  */\n  lowest: /* @__PURE__ */ ba(Ss.lowest)\n};\nclass Xw {\n  constructor(e, n) {\n    this.inner = e, this.prec = n;\n  }\n}\nclass Ld {\n  /**\n  Create an instance of this compartment to add to your [state\n  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).\n  */\n  of(e) {\n    return new Yh(this, e);\n  }\n  /**\n  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that\n  reconfigures this compartment.\n  */\n  reconfigure(e) {\n    return Ld.reconfigure.of({ compartment: this, extension: e });\n  }\n  /**\n  Get the current content of the compartment in the state, or\n  `undefined` if it isn't present.\n  */\n  get(e) {\n    return e.config.compartments.get(this);\n  }\n}\nclass Yh {\n  constructor(e, n) {\n    this.compartment = e, this.inner = n;\n  }\n}\nclass Zu {\n  constructor(e, n, r, i, s, o) {\n    for (this.base = e, this.compartments = n, this.dynamicSlots = r, this.address = i, this.staticValues = s, this.facets = o, this.statusTemplate = []; this.statusTemplate.length < r.length; )\n      this.statusTemplate.push(\n        0\n        /* SlotStatus.Unresolved */\n      );\n  }\n  staticFacet(e) {\n    let n = this.address[e.id];\n    return n == null ? e.default : this.staticValues[n >> 1];\n  }\n  static resolve(e, n, r) {\n    let i = [], s = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ new Map();\n    for (let f of nN(e, n, o))\n      f instanceof yr ? i.push(f) : (s[f.facet.id] || (s[f.facet.id] = [])).push(f);\n    let a = /* @__PURE__ */ Object.create(null), l = [], c = [];\n    for (let f of i)\n      a[f.id] = c.length << 1, c.push((h) => f.slot(h));\n    let u = r == null ? void 0 : r.config.facets;\n    for (let f in s) {\n      let h = s[f], p = h[0].facet, O = u && u[f] || [];\n      if (h.every(\n        (m) => m.type == 0\n        /* Provider.Static */\n      ))\n        if (a[p.id] = l.length << 1 | 1, ng(O, h))\n          l.push(r.facet(p));\n        else {\n          let m = p.combine(h.map((y) => y.value));\n          l.push(r && p.compare(m, r.facet(p)) ? r.facet(p) : m);\n        }\n      else {\n        for (let m of h)\n          m.type == 0 ? (a[m.id] = l.length << 1 | 1, l.push(m.value)) : (a[m.id] = c.length << 1, c.push((y) => m.dynamicSlot(y)));\n        a[p.id] = c.length << 1, c.push((m) => tN(m, p, h));\n      }\n    }\n    let d = c.map((f) => f(a));\n    return new Zu(e, o, d, a, l, s);\n  }\n}\nfunction nN(t, e, n) {\n  let r = [[], [], [], [], []], i = /* @__PURE__ */ new Map();\n  function s(o, a) {\n    let l = i.get(o);\n    if (l != null) {\n      if (l <= a)\n        return;\n      let c = r[l].indexOf(o);\n      c > -1 && r[l].splice(c, 1), o instanceof Yh && n.delete(o.compartment);\n    }\n    if (i.set(o, a), Array.isArray(o))\n      for (let c of o)\n        s(c, a);\n    else if (o instanceof Yh) {\n      if (n.has(o.compartment))\n        throw new RangeError(\"Duplicate use of compartment in extensions\");\n      let c = e.get(o.compartment) || o.inner;\n      n.set(o.compartment, c), s(c, a);\n    } else if (o instanceof Xw)\n      s(o.inner, o.prec);\n    else if (o instanceof yr)\n      r[a].push(o), o.provides && s(o.provides, a);\n    else if (o instanceof nu)\n      r[a].push(o), o.facet.extensions && s(o.facet.extensions, Ss.default);\n    else {\n      let c = o.extension;\n      if (!c)\n        throw new Error(`Unrecognized extension value in extension set (${o}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);\n      s(c, a);\n    }\n  }\n  return s(t, Ss.default), r.reduce((o, a) => o.concat(a));\n}\nfunction Ya(t, e) {\n  if (e & 1)\n    return 2;\n  let n = e >> 1, r = t.status[n];\n  if (r == 4)\n    throw new Error(\"Cyclic dependency between fields and/or facets\");\n  if (r & 2)\n    return r;\n  t.status[n] = 4;\n  let i = t.computeSlot(t, t.config.dynamicSlots[n]);\n  return t.status[n] = 2 | i;\n}\nfunction Vu(t, e) {\n  return e & 1 ? t.config.staticValues[e >> 1] : t.values[e >> 1];\n}\nconst jw = /* @__PURE__ */ ve.define(), zh = /* @__PURE__ */ ve.define({\n  combine: (t) => t.some((e) => e),\n  static: !0\n}), Bw = /* @__PURE__ */ ve.define({\n  combine: (t) => t.length ? t[0] : void 0,\n  static: !0\n}), Lw = /* @__PURE__ */ ve.define(), Uw = /* @__PURE__ */ ve.define(), qw = /* @__PURE__ */ ve.define(), Yw = /* @__PURE__ */ ve.define({\n  combine: (t) => t.length ? t[0] : !1\n});\nclass no {\n  /**\n  @internal\n  */\n  constructor(e, n) {\n    this.type = e, this.value = n;\n  }\n  /**\n  Define a new type of annotation.\n  */\n  static define() {\n    return new rN();\n  }\n}\nclass rN {\n  /**\n  Create an instance of this annotation.\n  */\n  of(e) {\n    return new no(this, e);\n  }\n}\nclass iN {\n  /**\n  @internal\n  */\n  constructor(e) {\n    this.map = e;\n  }\n  /**\n  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this\n  type.\n  */\n  of(e) {\n    return new ot(this, e);\n  }\n}\nclass ot {\n  /**\n  @internal\n  */\n  constructor(e, n) {\n    this.type = e, this.value = n;\n  }\n  /**\n  Map this effect through a position mapping. Will return\n  `undefined` when that ends up deleting the effect.\n  */\n  map(e) {\n    let n = this.type.map(this.value, e);\n    return n === void 0 ? void 0 : n == this.value ? this : new ot(this.type, n);\n  }\n  /**\n  Tells you whether this effect object is of a given\n  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).\n  */\n  is(e) {\n    return this.type == e;\n  }\n  /**\n  Define a new effect type. The type parameter indicates the type\n  of values that his effect holds. It should be a type that\n  doesn't include `undefined`, since that is used in\n  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is\n  removed.\n  */\n  static define(e = {}) {\n    return new iN(e.map || ((n) => n));\n  }\n  /**\n  Map an array of effects through a change set.\n  */\n  static mapEffects(e, n) {\n    if (!e.length)\n      return e;\n    let r = [];\n    for (let i of e) {\n      let s = i.map(n);\n      s && r.push(s);\n    }\n    return r;\n  }\n}\not.reconfigure = /* @__PURE__ */ ot.define();\not.appendConfig = /* @__PURE__ */ ot.define();\nclass Gt {\n  constructor(e, n, r, i, s, o) {\n    this.startState = e, this.changes = n, this.selection = r, this.effects = i, this.annotations = s, this.scrollIntoView = o, this._doc = null, this._state = null, r && Mw(r, n.newLength), s.some((a) => a.type == Gt.time) || (this.annotations = s.concat(Gt.time.of(Date.now())));\n  }\n  /**\n  @internal\n  */\n  static create(e, n, r, i, s, o) {\n    return new Gt(e, n, r, i, s, o);\n  }\n  /**\n  The new document produced by the transaction. Contrary to\n  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't\n  force the entire new state to be computed right away, so it is\n  recommended that [transaction\n  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter\n  when they need to look at the new document.\n  */\n  get newDoc() {\n    return this._doc || (this._doc = this.changes.apply(this.startState.doc));\n  }\n  /**\n  The new selection produced by the transaction. If\n  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,\n  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's\n  current selection through the changes made by the transaction.\n  */\n  get newSelection() {\n    return this.selection || this.startState.selection.map(this.changes);\n  }\n  /**\n  The new state created by the transaction. Computed on demand\n  (but retained for subsequent access), so it is recommended not to\n  access it in [transaction\n  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.\n  */\n  get state() {\n    return this._state || this.startState.applyTransaction(this), this._state;\n  }\n  /**\n  Get the value of the given annotation type, if any.\n  */\n  annotation(e) {\n    for (let n of this.annotations)\n      if (n.type == e)\n        return n.value;\n  }\n  /**\n  Indicates whether the transaction changed the document.\n  */\n  get docChanged() {\n    return !this.changes.empty;\n  }\n  /**\n  Indicates whether this transaction reconfigures the state\n  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or\n  with a top-level configuration\n  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).\n  */\n  get reconfigured() {\n    return this.startState.config != this.state.config;\n  }\n  /**\n  Returns true if the transaction has a [user\n  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to\n  or more specific than `event`. For example, if the transaction\n  has `\"select.pointer\"` as user event, `\"select\"` and\n  `\"select.pointer\"` will match it.\n  */\n  isUserEvent(e) {\n    let n = this.annotation(Gt.userEvent);\n    return !!(n && (n == e || n.length > e.length && n.slice(0, e.length) == e && n[e.length] == \".\"));\n  }\n}\nGt.time = /* @__PURE__ */ no.define();\nGt.userEvent = /* @__PURE__ */ no.define();\nGt.addToHistory = /* @__PURE__ */ no.define();\nGt.remote = /* @__PURE__ */ no.define();\nfunction sN(t, e) {\n  let n = [];\n  for (let r = 0, i = 0; ; ) {\n    let s, o;\n    if (r < t.length && (i == e.length || e[i] >= t[r]))\n      s = t[r++], o = t[r++];\n    else if (i < e.length)\n      s = e[i++], o = e[i++];\n    else\n      return n;\n    !n.length || n[n.length - 1] < s ? n.push(s, o) : n[n.length - 1] < o && (n[n.length - 1] = o);\n  }\n}\nfunction zw(t, e, n) {\n  var r;\n  let i, s, o;\n  return n ? (i = e.changes, s = Mt.empty(e.changes.length), o = t.changes.compose(e.changes)) : (i = e.changes.map(t.changes), s = t.changes.mapDesc(e.changes, !0), o = t.changes.compose(i)), {\n    changes: o,\n    selection: e.selection ? e.selection.map(s) : (r = t.selection) === null || r === void 0 ? void 0 : r.map(i),\n    effects: ot.mapEffects(t.effects, i).concat(ot.mapEffects(e.effects, s)),\n    annotations: t.annotations.length ? t.annotations.concat(e.annotations) : e.annotations,\n    scrollIntoView: t.scrollIntoView || e.scrollIntoView\n  };\n}\nfunction Hh(t, e, n) {\n  let r = e.selection, i = _o(e.annotations);\n  return e.userEvent && (i = i.concat(Gt.userEvent.of(e.userEvent))), {\n    changes: e.changes instanceof Mt ? e.changes : Mt.of(e.changes || [], n, t.facet(Bw)),\n    selection: r && (r instanceof ae ? r : ae.single(r.anchor, r.head)),\n    effects: _o(e.effects),\n    annotations: i,\n    scrollIntoView: !!e.scrollIntoView\n  };\n}\nfunction Hw(t, e, n) {\n  let r = Hh(t, e.length ? e[0] : {}, t.doc.length);\n  e.length && e[0].filter === !1 && (n = !1);\n  for (let s = 1; s < e.length; s++) {\n    e[s].filter === !1 && (n = !1);\n    let o = !!e[s].sequential;\n    r = zw(r, Hh(t, e[s], o ? r.changes.newLength : t.doc.length), o);\n  }\n  let i = Gt.create(t, r.changes, r.selection, r.effects, r.annotations, r.scrollIntoView);\n  return aN(n ? oN(i) : i);\n}\nfunction oN(t) {\n  let e = t.startState, n = !0;\n  for (let i of e.facet(Lw)) {\n    let s = i(t);\n    if (s === !1) {\n      n = !1;\n      break;\n    }\n    Array.isArray(s) && (n = n === !0 ? s : sN(n, s));\n  }\n  if (n !== !0) {\n    let i, s;\n    if (n === !1)\n      s = t.changes.invertedDesc, i = Mt.empty(e.doc.length);\n    else {\n      let o = t.changes.filter(n);\n      i = o.changes, s = o.filtered.mapDesc(o.changes).invertedDesc;\n    }\n    t = Gt.create(e, i, t.selection && t.selection.map(s), ot.mapEffects(t.effects, s), t.annotations, t.scrollIntoView);\n  }\n  let r = e.facet(Uw);\n  for (let i = r.length - 1; i >= 0; i--) {\n    let s = r[i](t);\n    s instanceof Gt ? t = s : Array.isArray(s) && s.length == 1 && s[0] instanceof Gt ? t = s[0] : t = Hw(e, _o(s), !1);\n  }\n  return t;\n}\nfunction aN(t) {\n  let e = t.startState, n = e.facet(qw), r = t;\n  for (let i = n.length - 1; i >= 0; i--) {\n    let s = n[i](t);\n    s && Object.keys(s).length && (r = zw(r, Hh(e, s, t.changes.newLength), !0));\n  }\n  return r == t ? t : Gt.create(e, t.changes, t.selection, r.effects, r.annotations, r.scrollIntoView);\n}\nconst lN = [];\nfunction _o(t) {\n  return t == null ? lN : Array.isArray(t) ? t : [t];\n}\nvar Hn = /* @__PURE__ */ function(t) {\n  return t[t.Word = 0] = \"Word\", t[t.Space = 1] = \"Space\", t[t.Other = 2] = \"Other\", t;\n}(Hn || (Hn = {}));\nconst cN = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\nlet Fh;\ntry {\n  Fh = /* @__PURE__ */ new RegExp(\"[\\\\p{Alphabetic}\\\\p{Number}_]\", \"u\");\n} catch {\n}\nfunction uN(t) {\n  if (Fh)\n    return Fh.test(t);\n  for (let e = 0; e < t.length; e++) {\n    let n = t[e];\n    if (/\\w/.test(n) || n > \"\" && (n.toUpperCase() != n.toLowerCase() || cN.test(n)))\n      return !0;\n  }\n  return !1;\n}\nfunction dN(t) {\n  return (e) => {\n    if (!/\\S/.test(e))\n      return Hn.Space;\n    if (uN(e))\n      return Hn.Word;\n    for (let n = 0; n < t.length; n++)\n      if (e.indexOf(t[n]) > -1)\n        return Hn.Word;\n    return Hn.Other;\n  };\n}\nclass Ye {\n  constructor(e, n, r, i, s, o) {\n    this.config = e, this.doc = n, this.selection = r, this.values = i, this.status = e.statusTemplate.slice(), this.computeSlot = s, o && (o._state = this);\n    for (let a = 0; a < this.config.dynamicSlots.length; a++)\n      Ya(this, a << 1);\n    this.computeSlot = null;\n  }\n  field(e, n = !0) {\n    let r = this.config.address[e.id];\n    if (r == null) {\n      if (n)\n        throw new RangeError(\"Field is not present in this state\");\n      return;\n    }\n    return Ya(this, r), Vu(this, r);\n  }\n  /**\n  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this\n  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)\n  can be passed. Unless\n  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the\n  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec\n  are assumed to start in the _current_ document (not the document\n  produced by previous specs), and its\n  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and\n  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer\n  to the document created by its _own_ changes. The resulting\n  transaction contains the combined effect of all the different\n  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later\n  specs take precedence over earlier ones.\n  */\n  update(...e) {\n    return Hw(this, e, !0);\n  }\n  /**\n  @internal\n  */\n  applyTransaction(e) {\n    let n = this.config, { base: r, compartments: i } = n;\n    for (let a of e.effects)\n      a.is(Ld.reconfigure) ? (n && (i = /* @__PURE__ */ new Map(), n.compartments.forEach((l, c) => i.set(c, l)), n = null), i.set(a.value.compartment, a.value.extension)) : a.is(ot.reconfigure) ? (n = null, r = a.value) : a.is(ot.appendConfig) && (n = null, r = _o(r).concat(a.value));\n    let s;\n    n ? s = e.startState.values.slice() : (n = Zu.resolve(r, i, this), s = new Ye(n, this.doc, this.selection, n.dynamicSlots.map(() => null), (l, c) => c.reconfigure(l, this), null).values);\n    let o = e.startState.facet(zh) ? e.newSelection : e.newSelection.asSingle();\n    new Ye(n, e.newDoc, o, s, (a, l) => l.update(a, e), e);\n  }\n  /**\n  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that\n  replaces every selection range with the given content.\n  */\n  replaceSelection(e) {\n    return typeof e == \"string\" && (e = this.toText(e)), this.changeByRange((n) => ({\n      changes: { from: n.from, to: n.to, insert: e },\n      range: ae.cursor(n.from + e.length)\n    }));\n  }\n  /**\n  Create a set of changes and a new selection by running the given\n  function for each range in the active selection. The function\n  can return an optional set of changes (in the coordinate space\n  of the start document), plus an updated range (in the coordinate\n  space of the document produced by the call's own changes). This\n  method will merge all the changes and ranges into a single\n  changeset and selection, and return it as a [transaction\n  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to\n  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).\n  */\n  changeByRange(e) {\n    let n = this.selection, r = e(n.ranges[0]), i = this.changes(r.changes), s = [r.range], o = _o(r.effects);\n    for (let a = 1; a < n.ranges.length; a++) {\n      let l = e(n.ranges[a]), c = this.changes(l.changes), u = c.map(i);\n      for (let f = 0; f < a; f++)\n        s[f] = s[f].map(u);\n      let d = i.mapDesc(c, !0);\n      s.push(l.range.map(d)), i = i.compose(u), o = ot.mapEffects(o, u).concat(ot.mapEffects(_o(l.effects), d));\n    }\n    return {\n      changes: i,\n      selection: ae.create(s, n.mainIndex),\n      effects: o\n    };\n  }\n  /**\n  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change\n  description, taking the state's document length and line\n  separator into account.\n  */\n  changes(e = []) {\n    return e instanceof Mt ? e : Mt.of(e, this.doc.length, this.facet(Ye.lineSeparator));\n  }\n  /**\n  Using the state's [line\n  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a\n  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.\n  */\n  toText(e) {\n    return Fe.of(e.split(this.facet(Ye.lineSeparator) || Bh));\n  }\n  /**\n  Return the given range of the document as a string.\n  */\n  sliceDoc(e = 0, n = this.doc.length) {\n    return this.doc.sliceString(e, n, this.lineBreak);\n  }\n  /**\n  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).\n  */\n  facet(e) {\n    let n = this.config.address[e.id];\n    return n == null ? e.default : (Ya(this, n), Vu(this, n));\n  }\n  /**\n  Convert this state to a JSON-serializable object. When custom\n  fields should be serialized, you can pass them in as an object\n  mapping property names (in the resulting object, which should\n  not use `doc` or `selection`) to fields.\n  */\n  toJSON(e) {\n    let n = {\n      doc: this.sliceDoc(),\n      selection: this.selection.toJSON()\n    };\n    if (e)\n      for (let r in e) {\n        let i = e[r];\n        i instanceof yr && this.config.address[i.id] != null && (n[r] = i.spec.toJSON(this.field(e[r]), this));\n      }\n    return n;\n  }\n  /**\n  Deserialize a state from its JSON representation. When custom\n  fields should be deserialized, pass the same object you passed\n  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as\n  third argument.\n  */\n  static fromJSON(e, n = {}, r) {\n    if (!e || typeof e.doc != \"string\")\n      throw new RangeError(\"Invalid JSON representation for EditorState\");\n    let i = [];\n    if (r) {\n      for (let s in r)\n        if (Object.prototype.hasOwnProperty.call(e, s)) {\n          let o = r[s], a = e[s];\n          i.push(o.init((l) => o.spec.fromJSON(a, l)));\n        }\n    }\n    return Ye.create({\n      doc: e.doc,\n      selection: ae.fromJSON(e.selection),\n      extensions: n.extensions ? i.concat([n.extensions]) : i\n    });\n  }\n  /**\n  Create a new state. You'll usually only need this when\n  initializing an editorupdated states are created by applying\n  transactions.\n  */\n  static create(e = {}) {\n    let n = Zu.resolve(e.extensions || [], /* @__PURE__ */ new Map()), r = e.doc instanceof Fe ? e.doc : Fe.of((e.doc || \"\").split(n.staticFacet(Ye.lineSeparator) || Bh)), i = e.selection ? e.selection instanceof ae ? e.selection : ae.single(e.selection.anchor, e.selection.head) : ae.single(0);\n    return Mw(i, r.length), n.staticFacet(zh) || (i = i.asSingle()), new Ye(n, r, i, n.dynamicSlots.map(() => null), (s, o) => o.create(s), null);\n  }\n  /**\n  The size (in columns) of a tab in the document, determined by\n  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.\n  */\n  get tabSize() {\n    return this.facet(Ye.tabSize);\n  }\n  /**\n  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)\n  string for this state.\n  */\n  get lineBreak() {\n    return this.facet(Ye.lineSeparator) || `\n`;\n  }\n  /**\n  Returns true when the editor is\n  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.\n  */\n  get readOnly() {\n    return this.facet(Yw);\n  }\n  /**\n  Look up a translation for the given phrase (via the\n  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the\n  original string if no translation is found.\n  \n  If additional arguments are passed, they will be inserted in\n  place of markers like `$1` (for the first value) and `$2`, etc.\n  A single `$` is equivalent to `$1`, and `$$` will produce a\n  literal dollar sign.\n  */\n  phrase(e, ...n) {\n    for (let r of this.facet(Ye.phrases))\n      if (Object.prototype.hasOwnProperty.call(r, e)) {\n        e = r[e];\n        break;\n      }\n    return n.length && (e = e.replace(/\\$(\\$|\\d*)/g, (r, i) => {\n      if (i == \"$\")\n        return \"$\";\n      let s = +(i || 1);\n      return !s || s > n.length ? r : n[s - 1];\n    })), e;\n  }\n  /**\n  Find the values for a given language data field, provided by the\n  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.\n  \n  Examples of language data fields are...\n  \n  - [`\"commentTokens\"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying\n    comment syntax.\n  - [`\"autocomplete\"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)\n    for providing language-specific completion sources.\n  - [`\"wordChars\"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding\n    characters that should be considered part of words in this\n    language.\n  - [`\"closeBrackets\"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls\n    bracket closing behavior.\n  */\n  languageDataAt(e, n, r = -1) {\n    let i = [];\n    for (let s of this.facet(jw))\n      for (let o of s(this, n, r))\n        Object.prototype.hasOwnProperty.call(o, e) && i.push(o[e]);\n    return i;\n  }\n  /**\n  Return a function that can categorize strings (expected to\n  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))\n  into one of:\n  \n   - Word (contains an alphanumeric character or a character\n     explicitly listed in the local language's `\"wordChars\"`\n     language data, which should be a string)\n   - Space (contains only whitespace)\n   - Other (anything else)\n  */\n  charCategorizer(e) {\n    return dN(this.languageDataAt(\"wordChars\", e).join(\"\"));\n  }\n  /**\n  Find the word at the given position, meaning the range\n  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters\n  around it. If no word characters are adjacent to the position,\n  this returns null.\n  */\n  wordAt(e) {\n    let { text: n, from: r, length: i } = this.doc.lineAt(e), s = this.charCategorizer(e), o = e - r, a = e - r;\n    for (; o > 0; ) {\n      let l = Rr(n, o, !1);\n      if (s(n.slice(l, o)) != Hn.Word)\n        break;\n      o = l;\n    }\n    for (; a < i; ) {\n      let l = Rr(n, a);\n      if (s(n.slice(a, l)) != Hn.Word)\n        break;\n      a = l;\n    }\n    return o == a ? null : ae.range(o + r, a + r);\n  }\n}\nYe.allowMultipleSelections = zh;\nYe.tabSize = /* @__PURE__ */ ve.define({\n  combine: (t) => t.length ? t[0] : 4\n});\nYe.lineSeparator = Bw;\nYe.readOnly = Yw;\nYe.phrases = /* @__PURE__ */ ve.define({\n  compare(t, e) {\n    let n = Object.keys(t), r = Object.keys(e);\n    return n.length == r.length && n.every((i) => t[i] == e[i]);\n  }\n});\nYe.languageData = jw;\nYe.changeFilter = Lw;\nYe.transactionFilter = Uw;\nYe.transactionExtender = qw;\nLd.reconfigure = /* @__PURE__ */ ot.define();\nfunction Ud(t, e, n = {}) {\n  let r = {};\n  for (let i of t)\n    for (let s of Object.keys(i)) {\n      let o = i[s], a = r[s];\n      if (a === void 0)\n        r[s] = o;\n      else if (!(a === o || o === void 0))\n        if (Object.hasOwnProperty.call(n, s))\n          r[s] = n[s](a, o);\n        else\n          throw new Error(\"Config merge conflict for field \" + s);\n    }\n  for (let i in e)\n    r[i] === void 0 && (r[i] = e[i]);\n  return r;\n}\nclass qs {\n  /**\n  Compare this value with another value. Used when comparing\n  rangesets. The default implementation compares by identity.\n  Unless you are only creating a fixed number of unique instances\n  of your value type, it is a good idea to implement this\n  properly.\n  */\n  eq(e) {\n    return this == e;\n  }\n  /**\n  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.\n  */\n  range(e, n = e) {\n    return Gh.create(e, n, this);\n  }\n}\nqs.prototype.startSide = qs.prototype.endSide = 0;\nqs.prototype.point = !1;\nqs.prototype.mapMode = on.TrackDel;\nlet Gh = class Fw {\n  constructor(e, n, r) {\n    this.from = e, this.to = n, this.value = r;\n  }\n  /**\n  @internal\n  */\n  static create(e, n, r) {\n    return new Fw(e, n, r);\n  }\n};\nfunction Kh(t, e) {\n  return t.from - e.from || t.value.startSide - e.value.startSide;\n}\nclass rg {\n  constructor(e, n, r, i) {\n    this.from = e, this.to = n, this.value = r, this.maxPoint = i;\n  }\n  get length() {\n    return this.to[this.to.length - 1];\n  }\n  // Find the index of the given position and side. Use the ranges'\n  // `from` pos when `end == false`, `to` when `end == true`.\n  findIndex(e, n, r, i = 0) {\n    let s = r ? this.to : this.from;\n    for (let o = i, a = s.length; ; ) {\n      if (o == a)\n        return o;\n      let l = o + a >> 1, c = s[l] - e || (r ? this.value[l].endSide : this.value[l].startSide) - n;\n      if (l == o)\n        return c >= 0 ? o : a;\n      c >= 0 ? a = l : o = l + 1;\n    }\n  }\n  between(e, n, r, i) {\n    for (let s = this.findIndex(n, -1e9, !0), o = this.findIndex(r, 1e9, !1, s); s < o; s++)\n      if (i(this.from[s] + e, this.to[s] + e, this.value[s]) === !1)\n        return !1;\n  }\n  map(e, n) {\n    let r = [], i = [], s = [], o = -1, a = -1;\n    for (let l = 0; l < this.value.length; l++) {\n      let c = this.value[l], u = this.from[l] + e, d = this.to[l] + e, f, h;\n      if (u == d) {\n        let p = n.mapPos(u, c.startSide, c.mapMode);\n        if (p == null || (f = h = p, c.startSide != c.endSide && (h = n.mapPos(u, c.endSide), h < f)))\n          continue;\n      } else if (f = n.mapPos(u, c.startSide), h = n.mapPos(d, c.endSide), f > h || f == h && c.startSide > 0 && c.endSide <= 0)\n        continue;\n      (h - f || c.endSide - c.startSide) < 0 || (o < 0 && (o = f), c.point && (a = Math.max(a, h - f)), r.push(c), i.push(f - o), s.push(h - o));\n    }\n    return { mapped: r.length ? new rg(i, s, r, a) : null, pos: o };\n  }\n}\nclass ze {\n  constructor(e, n, r, i) {\n    this.chunkPos = e, this.chunk = n, this.nextLayer = r, this.maxPoint = i;\n  }\n  /**\n  @internal\n  */\n  static create(e, n, r, i) {\n    return new ze(e, n, r, i);\n  }\n  /**\n  @internal\n  */\n  get length() {\n    let e = this.chunk.length - 1;\n    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);\n  }\n  /**\n  The number of ranges in the set.\n  */\n  get size() {\n    if (this.isEmpty)\n      return 0;\n    let e = this.nextLayer.size;\n    for (let n of this.chunk)\n      e += n.value.length;\n    return e;\n  }\n  /**\n  @internal\n  */\n  chunkEnd(e) {\n    return this.chunkPos[e] + this.chunk[e].length;\n  }\n  /**\n  Update the range set, optionally adding new ranges or filtering\n  out existing ones.\n  \n  (Note: The type parameter is just there as a kludge to work\n  around TypeScript variance issues that prevented `RangeSet<X>`\n  from being a subtype of `RangeSet<Y>` when `X` is a subtype of\n  `Y`.)\n  */\n  update(e) {\n    let { add: n = [], sort: r = !1, filterFrom: i = 0, filterTo: s = this.length } = e, o = e.filter;\n    if (n.length == 0 && !o)\n      return this;\n    if (r && (n = n.slice().sort(Kh)), this.isEmpty)\n      return n.length ? ze.of(n) : this;\n    let a = new Gw(this, null, -1).goto(0), l = 0, c = [], u = new jo();\n    for (; a.value || l < n.length; )\n      if (l < n.length && (a.from - n[l].from || a.startSide - n[l].value.startSide) >= 0) {\n        let d = n[l++];\n        u.addInner(d.from, d.to, d.value) || c.push(d);\n      } else\n        a.rangeIndex == 1 && a.chunkIndex < this.chunk.length && (l == n.length || this.chunkEnd(a.chunkIndex) < n[l].from) && (!o || i > this.chunkEnd(a.chunkIndex) || s < this.chunkPos[a.chunkIndex]) && u.addChunk(this.chunkPos[a.chunkIndex], this.chunk[a.chunkIndex]) ? a.nextChunk() : ((!o || i > a.to || s < a.from || o(a.from, a.to, a.value)) && (u.addInner(a.from, a.to, a.value) || c.push(Gh.create(a.from, a.to, a.value))), a.next());\n    return u.finishInner(this.nextLayer.isEmpty && !c.length ? ze.empty : this.nextLayer.update({ add: c, filter: o, filterFrom: i, filterTo: s }));\n  }\n  /**\n  Map this range set through a set of changes, return the new set.\n  */\n  map(e) {\n    if (e.empty || this.isEmpty)\n      return this;\n    let n = [], r = [], i = -1;\n    for (let o = 0; o < this.chunk.length; o++) {\n      let a = this.chunkPos[o], l = this.chunk[o], c = e.touchesRange(a, a + l.length);\n      if (c === !1)\n        i = Math.max(i, l.maxPoint), n.push(l), r.push(e.mapPos(a));\n      else if (c === !0) {\n        let { mapped: u, pos: d } = l.map(a, e);\n        u && (i = Math.max(i, u.maxPoint), n.push(u), r.push(d));\n      }\n    }\n    let s = this.nextLayer.map(e);\n    return n.length == 0 ? s : new ze(r, n, s || ze.empty, i);\n  }\n  /**\n  Iterate over the ranges that touch the region `from` to `to`,\n  calling `f` for each. There is no guarantee that the ranges will\n  be reported in any specific order. When the callback returns\n  `false`, iteration stops.\n  */\n  between(e, n, r) {\n    if (!this.isEmpty) {\n      for (let i = 0; i < this.chunk.length; i++) {\n        let s = this.chunkPos[i], o = this.chunk[i];\n        if (n >= s && e <= s + o.length && o.between(s, e - s, n - s, r) === !1)\n          return;\n      }\n      this.nextLayer.between(e, n, r);\n    }\n  }\n  /**\n  Iterate over the ranges in this set, in order, including all\n  ranges that end at or after `from`.\n  */\n  iter(e = 0) {\n    return hl.from([this]).goto(e);\n  }\n  /**\n  @internal\n  */\n  get isEmpty() {\n    return this.nextLayer == this;\n  }\n  /**\n  Iterate over the ranges in a collection of sets, in order,\n  starting from `from`.\n  */\n  static iter(e, n = 0) {\n    return hl.from(e).goto(n);\n  }\n  /**\n  Iterate over two groups of sets, calling methods on `comparator`\n  to notify it of possible differences.\n  */\n  static compare(e, n, r, i, s = -1) {\n    let o = e.filter((d) => d.maxPoint > 0 || !d.isEmpty && d.maxPoint >= s), a = n.filter((d) => d.maxPoint > 0 || !d.isEmpty && d.maxPoint >= s), l = Ib(o, a, r), c = new va(o, l, s), u = new va(a, l, s);\n    r.iterGaps((d, f, h) => Wb(c, d, u, f, h, i)), r.empty && r.length == 0 && Wb(c, 0, u, 0, 0, i);\n  }\n  /**\n  Compare the contents of two groups of range sets, returning true\n  if they are equivalent in the given range.\n  */\n  static eq(e, n, r = 0, i) {\n    i == null && (i = 999999999);\n    let s = e.filter((u) => !u.isEmpty && n.indexOf(u) < 0), o = n.filter((u) => !u.isEmpty && e.indexOf(u) < 0);\n    if (s.length != o.length)\n      return !1;\n    if (!s.length)\n      return !0;\n    let a = Ib(s, o), l = new va(s, a, 0).goto(r), c = new va(o, a, 0).goto(r);\n    for (; ; ) {\n      if (l.to != c.to || !Jh(l.active, c.active) || l.point && (!c.point || !l.point.eq(c.point)))\n        return !1;\n      if (l.to > i)\n        return !0;\n      l.next(), c.next();\n    }\n  }\n  /**\n  Iterate over a group of range sets at the same time, notifying\n  the iterator about the ranges covering every given piece of\n  content. Returns the open count (see\n  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end\n  of the iteration.\n  */\n  static spans(e, n, r, i, s = -1) {\n    let o = new va(e, null, s).goto(n), a = n, l = o.openStart;\n    for (; ; ) {\n      let c = Math.min(o.to, r);\n      if (o.point) {\n        let u = o.activeForPoint(o.to), d = o.pointFrom < n ? u.length + 1 : o.point.startSide < 0 ? u.length : Math.min(u.length, l);\n        i.point(a, c, o.point, u, d, o.pointRank), l = Math.min(o.openEnd(c), u.length);\n      } else\n        c > a && (i.span(a, c, o.active, l), l = o.openEnd(c));\n      if (o.to > r)\n        return l + (o.point && o.to > r ? 1 : 0);\n      a = o.to, o.next();\n    }\n  }\n  /**\n  Create a range set for the given range or array of ranges. By\n  default, this expects the ranges to be _sorted_ (by start\n  position and, if two start at the same position,\n  `value.startSide`). You can pass `true` as second argument to\n  cause the method to sort them.\n  */\n  static of(e, n = !1) {\n    let r = new jo();\n    for (let i of e instanceof Gh ? [e] : n ? fN(e) : e)\n      r.add(i.from, i.to, i.value);\n    return r.finish();\n  }\n  /**\n  Join an array of range sets into a single set.\n  */\n  static join(e) {\n    if (!e.length)\n      return ze.empty;\n    let n = e[e.length - 1];\n    for (let r = e.length - 2; r >= 0; r--)\n      for (let i = e[r]; i != ze.empty; i = i.nextLayer)\n        n = new ze(i.chunkPos, i.chunk, n, Math.max(i.maxPoint, n.maxPoint));\n    return n;\n  }\n}\nze.empty = /* @__PURE__ */ new ze([], [], null, -1);\nfunction fN(t) {\n  if (t.length > 1)\n    for (let e = t[0], n = 1; n < t.length; n++) {\n      let r = t[n];\n      if (Kh(e, r) > 0)\n        return t.slice().sort(Kh);\n      e = r;\n    }\n  return t;\n}\nze.empty.nextLayer = ze.empty;\nclass jo {\n  finishChunk(e) {\n    this.chunks.push(new rg(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);\n  }\n  /**\n  Create an empty builder.\n  */\n  constructor() {\n    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;\n  }\n  /**\n  Add a range. Ranges should be added in sorted (by `from` and\n  `value.startSide`) order.\n  */\n  add(e, n, r) {\n    this.addInner(e, n, r) || (this.nextLayer || (this.nextLayer = new jo())).add(e, n, r);\n  }\n  /**\n  @internal\n  */\n  addInner(e, n, r) {\n    let i = e - this.lastTo || r.startSide - this.last.endSide;\n    if (i <= 0 && (e - this.lastFrom || r.startSide - this.last.startSide) < 0)\n      throw new Error(\"Ranges must be added sorted by `from` position and `startSide`\");\n    return i < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(n - this.chunkStart), this.last = r, this.lastFrom = e, this.lastTo = n, this.value.push(r), r.point && (this.maxPoint = Math.max(this.maxPoint, n - e)), !0);\n  }\n  /**\n  @internal\n  */\n  addChunk(e, n) {\n    if ((e - this.lastTo || n.value[0].startSide - this.last.endSide) < 0)\n      return !1;\n    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, n.maxPoint), this.chunks.push(n), this.chunkPos.push(e);\n    let r = n.value.length - 1;\n    return this.last = n.value[r], this.lastFrom = n.from[r] + e, this.lastTo = n.to[r] + e, !0;\n  }\n  /**\n  Finish the range set. Returns the new set. The builder can't be\n  used anymore after this has been called.\n  */\n  finish() {\n    return this.finishInner(ze.empty);\n  }\n  /**\n  @internal\n  */\n  finishInner(e) {\n    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)\n      return e;\n    let n = ze.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);\n    return this.from = null, n;\n  }\n}\nfunction Ib(t, e, n) {\n  let r = /* @__PURE__ */ new Map();\n  for (let s of t)\n    for (let o = 0; o < s.chunk.length; o++)\n      s.chunk[o].maxPoint <= 0 && r.set(s.chunk[o], s.chunkPos[o]);\n  let i = /* @__PURE__ */ new Set();\n  for (let s of e)\n    for (let o = 0; o < s.chunk.length; o++) {\n      let a = r.get(s.chunk[o]);\n      a != null && (n ? n.mapPos(a) : a) == s.chunkPos[o] && !(n != null && n.touchesRange(a, a + s.chunk[o].length)) && i.add(s.chunk[o]);\n    }\n  return i;\n}\nclass Gw {\n  constructor(e, n, r, i = 0) {\n    this.layer = e, this.skip = n, this.minPoint = r, this.rank = i;\n  }\n  get startSide() {\n    return this.value ? this.value.startSide : 0;\n  }\n  get endSide() {\n    return this.value ? this.value.endSide : 0;\n  }\n  goto(e, n = -1e9) {\n    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, n, !1), this;\n  }\n  gotoInner(e, n, r) {\n    for (; this.chunkIndex < this.layer.chunk.length; ) {\n      let i = this.layer.chunk[this.chunkIndex];\n      if (!(this.skip && this.skip.has(i) || this.layer.chunkEnd(this.chunkIndex) < e || i.maxPoint < this.minPoint))\n        break;\n      this.chunkIndex++, r = !1;\n    }\n    if (this.chunkIndex < this.layer.chunk.length) {\n      let i = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], n, !0);\n      (!r || this.rangeIndex < i) && this.setRangeIndex(i);\n    }\n    this.next();\n  }\n  forward(e, n) {\n    (this.to - e || this.endSide - n) < 0 && this.gotoInner(e, n, !0);\n  }\n  next() {\n    for (; ; )\n      if (this.chunkIndex == this.layer.chunk.length) {\n        this.from = this.to = 1e9, this.value = null;\n        break;\n      } else {\n        let e = this.layer.chunkPos[this.chunkIndex], n = this.layer.chunk[this.chunkIndex], r = e + n.from[this.rangeIndex];\n        if (this.from = r, this.to = e + n.to[this.rangeIndex], this.value = n.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)\n          break;\n      }\n  }\n  setRangeIndex(e) {\n    if (e == this.layer.chunk[this.chunkIndex].value.length) {\n      if (this.chunkIndex++, this.skip)\n        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )\n          this.chunkIndex++;\n      this.rangeIndex = 0;\n    } else\n      this.rangeIndex = e;\n  }\n  nextChunk() {\n    this.chunkIndex++, this.rangeIndex = 0, this.next();\n  }\n  compare(e) {\n    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;\n  }\n}\nclass hl {\n  constructor(e) {\n    this.heap = e;\n  }\n  static from(e, n = null, r = -1) {\n    let i = [];\n    for (let s = 0; s < e.length; s++)\n      for (let o = e[s]; !o.isEmpty; o = o.nextLayer)\n        o.maxPoint >= r && i.push(new Gw(o, n, r, s));\n    return i.length == 1 ? i[0] : new hl(i);\n  }\n  get startSide() {\n    return this.value ? this.value.startSide : 0;\n  }\n  goto(e, n = -1e9) {\n    for (let r of this.heap)\n      r.goto(e, n);\n    for (let r = this.heap.length >> 1; r >= 0; r--)\n      wf(this.heap, r);\n    return this.next(), this;\n  }\n  forward(e, n) {\n    for (let r of this.heap)\n      r.forward(e, n);\n    for (let r = this.heap.length >> 1; r >= 0; r--)\n      wf(this.heap, r);\n    (this.to - e || this.value.endSide - n) < 0 && this.next();\n  }\n  next() {\n    if (this.heap.length == 0)\n      this.from = this.to = 1e9, this.value = null, this.rank = -1;\n    else {\n      let e = this.heap[0];\n      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), wf(this.heap, 0);\n    }\n  }\n}\nfunction wf(t, e) {\n  for (let n = t[e]; ; ) {\n    let r = (e << 1) + 1;\n    if (r >= t.length)\n      break;\n    let i = t[r];\n    if (r + 1 < t.length && i.compare(t[r + 1]) >= 0 && (i = t[r + 1], r++), n.compare(i) < 0)\n      break;\n    t[r] = n, t[e] = i, e = r;\n  }\n}\nclass va {\n  constructor(e, n, r) {\n    this.minPoint = r, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = hl.from(e, n, r);\n  }\n  goto(e, n = -1e9) {\n    return this.cursor.goto(e, n), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = n, this.openStart = -1, this.next(), this;\n  }\n  forward(e, n) {\n    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - n) < 0; )\n      this.removeActive(this.minActive);\n    this.cursor.forward(e, n);\n  }\n  removeActive(e) {\n    kc(this.active, e), kc(this.activeTo, e), kc(this.activeRank, e), this.minActive = Mb(this.active, this.activeTo);\n  }\n  addActive(e) {\n    let n = 0, { value: r, to: i, rank: s } = this.cursor;\n    for (; n < this.activeRank.length && (s - this.activeRank[n] || i - this.activeTo[n]) > 0; )\n      n++;\n    xc(this.active, n, r), xc(this.activeTo, n, i), xc(this.activeRank, n, s), e && xc(e, n, this.cursor.from), this.minActive = Mb(this.active, this.activeTo);\n  }\n  // After calling this, if `this.point` != null, the next range is a\n  // point. Otherwise, it's a regular range, covered by `this.active`.\n  next() {\n    let e = this.to, n = this.point;\n    this.point = null;\n    let r = this.openStart < 0 ? [] : null;\n    for (; ; ) {\n      let i = this.minActive;\n      if (i > -1 && (this.activeTo[i] - this.cursor.from || this.active[i].endSide - this.cursor.startSide) < 0) {\n        if (this.activeTo[i] > e) {\n          this.to = this.activeTo[i], this.endSide = this.active[i].endSide;\n          break;\n        }\n        this.removeActive(i), r && kc(r, i);\n      } else if (this.cursor.value)\n        if (this.cursor.from > e) {\n          this.to = this.cursor.from, this.endSide = this.cursor.startSide;\n          break;\n        } else {\n          let s = this.cursor.value;\n          if (!s.point)\n            this.addActive(r), this.cursor.next();\n          else if (n && this.cursor.to == this.to && this.cursor.from < this.cursor.to)\n            this.cursor.next();\n          else {\n            this.point = s, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = s.endSide, this.cursor.next(), this.forward(this.to, this.endSide);\n            break;\n          }\n        }\n      else {\n        this.to = this.endSide = 1e9;\n        break;\n      }\n    }\n    if (r) {\n      this.openStart = 0;\n      for (let i = r.length - 1; i >= 0 && r[i] < e; i--)\n        this.openStart++;\n    }\n  }\n  activeForPoint(e) {\n    if (!this.active.length)\n      return this.active;\n    let n = [];\n    for (let r = this.active.length - 1; r >= 0 && !(this.activeRank[r] < this.pointRank); r--)\n      (this.activeTo[r] > e || this.activeTo[r] == e && this.active[r].endSide >= this.point.endSide) && n.push(this.active[r]);\n    return n.reverse();\n  }\n  openEnd(e) {\n    let n = 0;\n    for (let r = this.activeTo.length - 1; r >= 0 && this.activeTo[r] > e; r--)\n      n++;\n    return n;\n  }\n}\nfunction Wb(t, e, n, r, i, s) {\n  t.goto(e), n.goto(r);\n  let o = r + i, a = r, l = r - e;\n  for (; ; ) {\n    let c = t.to + l - n.to || t.endSide - n.endSide, u = c < 0 ? t.to + l : n.to, d = Math.min(u, o);\n    if (t.point || n.point ? t.point && n.point && (t.point == n.point || t.point.eq(n.point)) && Jh(t.activeForPoint(t.to), n.activeForPoint(n.to)) || s.comparePoint(a, d, t.point, n.point) : d > a && !Jh(t.active, n.active) && s.compareRange(a, d, t.active, n.active), u > o)\n      break;\n    a = u, c <= 0 && t.next(), c >= 0 && n.next();\n  }\n}\nfunction Jh(t, e) {\n  if (t.length != e.length)\n    return !1;\n  for (let n = 0; n < t.length; n++)\n    if (t[n] != e[n] && !t[n].eq(e[n]))\n      return !1;\n  return !0;\n}\nfunction kc(t, e) {\n  for (let n = e, r = t.length - 1; n < r; n++)\n    t[n] = t[n + 1];\n  t.pop();\n}\nfunction xc(t, e, n) {\n  for (let r = t.length - 1; r >= e; r--)\n    t[r + 1] = t[r];\n  t[e] = n;\n}\nfunction Mb(t, e) {\n  let n = -1, r = 1e9;\n  for (let i = 0; i < e.length; i++)\n    (e[i] - r || t[i].endSide - t[n].endSide) < 0 && (n = i, r = e[i]);\n  return n;\n}\nfunction ig(t, e, n = t.length) {\n  let r = 0;\n  for (let i = 0; i < n; )\n    t.charCodeAt(i) == 9 ? (r += e - r % e, i++) : (r++, i = Rr(t, i));\n  return r;\n}\nfunction hN(t, e, n, r) {\n  for (let i = 0, s = 0; ; ) {\n    if (s >= e)\n      return i;\n    if (i == t.length)\n      break;\n    s += t.charCodeAt(i) == 9 ? n - s % n : 1, i = Rr(t, i);\n  }\n  return r === !0 ? -1 : t.length;\n}\nconst ep = \"\", Xb = typeof Symbol > \"u\" ? \"__\" + ep : Symbol.for(ep), tp = typeof Symbol > \"u\" ? \"__styleSet\" + Math.floor(Math.random() * 1e8) : Symbol(\"styleSet\"), jb = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : {};\nclass ss {\n  // :: (Object<Style>, ?{finish: ?(string)  string})\n  // Create a style module from the given spec.\n  //\n  // When `finish` is given, it is called on regular (non-`@`)\n  // selectors (after `&` expansion) to compute the final selector.\n  constructor(e, n) {\n    this.rules = [];\n    let { finish: r } = n || {};\n    function i(o) {\n      return /^@/.test(o) ? [o] : o.split(/,\\s*/);\n    }\n    function s(o, a, l, c) {\n      let u = [], d = /^@(\\w+)\\b/.exec(o[0]), f = d && d[1] == \"keyframes\";\n      if (d && a == null)\n        return l.push(o[0] + \";\");\n      for (let h in a) {\n        let p = a[h];\n        if (/&/.test(h))\n          s(\n            h.split(/,\\s*/).map((O) => o.map((m) => O.replace(/&/, m))).reduce((O, m) => O.concat(m)),\n            p,\n            l\n          );\n        else if (p && typeof p == \"object\") {\n          if (!d)\n            throw new RangeError(\"The value of a property (\" + h + \") should be a primitive value.\");\n          s(i(h), p, u, f);\n        } else\n          p != null && u.push(h.replace(/_.*/, \"\").replace(/[A-Z]/g, (O) => \"-\" + O.toLowerCase()) + \": \" + p + \";\");\n      }\n      (u.length || f) && l.push((r && !d && !c ? o.map(r) : o).join(\", \") + \" {\" + u.join(\" \") + \"}\");\n    }\n    for (let o in e)\n      s(i(o), e[o], this.rules);\n  }\n  // :: ()  string\n  // Returns a string containing the module's CSS rules.\n  getRules() {\n    return this.rules.join(`\n`);\n  }\n  // :: ()  string\n  // Generate a new unique CSS class name.\n  static newName() {\n    let e = jb[Xb] || 1;\n    return jb[Xb] = e + 1, ep + e.toString(36);\n  }\n  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>, ?{nonce: ?string})\n  //\n  // Mount the given set of modules in the given DOM root, which ensures\n  // that the CSS rules defined by the module are available in that\n  // context.\n  //\n  // Rules are only added to the document once per root.\n  //\n  // Rule order will follow the order of the modules, so that rules from\n  // modules later in the array take precedence of those from earlier\n  // modules. If you call this function multiple times for the same root\n  // in a way that changes the order of already mounted modules, the old\n  // order will be changed.\n  //\n  // If a Content Security Policy nonce is provided, it is added to\n  // the `<style>` tag generated by the library.\n  static mount(e, n, r) {\n    let i = e[tp], s = r && r.nonce;\n    i ? s && i.setNonce(s) : i = new pN(e, s), i.mount(Array.isArray(n) ? n : [n]);\n  }\n}\nlet Bb = /* @__PURE__ */ new Map();\nclass pN {\n  constructor(e, n) {\n    this.root = e;\n    let r = e.ownerDocument || e, i = r.defaultView;\n    if (!e.head && e.adoptedStyleSheets && i.CSSStyleSheet) {\n      let s = Bb.get(r);\n      if (s)\n        return e[tp] = s;\n      this.sheet = new i.CSSStyleSheet(), Bb.set(r, this);\n    } else\n      this.styleTag = r.createElement(\"style\"), n && this.styleTag.setAttribute(\"nonce\", n);\n    this.modules = [], e[tp] = this;\n  }\n  mount(e) {\n    let n = this.sheet, r = 0, i = 0;\n    for (let s = 0; s < e.length; s++) {\n      let o = e[s], a = this.modules.indexOf(o);\n      if (a < i && a > -1 && (this.modules.splice(a, 1), i--, a = -1), a == -1) {\n        if (this.modules.splice(i++, 0, o), n)\n          for (let l = 0; l < o.rules.length; l++)\n            n.insertRule(o.rules[l], r++);\n      } else {\n        for (; i < a; )\n          r += this.modules[i++].rules.length;\n        r += o.rules.length, i++;\n      }\n    }\n    if (n)\n      this.root.adoptedStyleSheets.indexOf(this.sheet) < 0 && (this.root.adoptedStyleSheets = [this.sheet, ...this.root.adoptedStyleSheets]);\n    else {\n      let s = \"\";\n      for (let a = 0; a < this.modules.length; a++)\n        s += this.modules[a].getRules() + `\n`;\n      this.styleTag.textContent = s;\n      let o = this.root.head || this.root;\n      this.styleTag.parentNode != o && o.insertBefore(this.styleTag, o.firstChild);\n    }\n  }\n  setNonce(e) {\n    this.styleTag && this.styleTag.getAttribute(\"nonce\") != e && this.styleTag.setAttribute(\"nonce\", e);\n  }\n}\nvar os = {\n  8: \"Backspace\",\n  9: \"Tab\",\n  10: \"Enter\",\n  12: \"NumLock\",\n  13: \"Enter\",\n  16: \"Shift\",\n  17: \"Control\",\n  18: \"Alt\",\n  20: \"CapsLock\",\n  27: \"Escape\",\n  32: \" \",\n  33: \"PageUp\",\n  34: \"PageDown\",\n  35: \"End\",\n  36: \"Home\",\n  37: \"ArrowLeft\",\n  38: \"ArrowUp\",\n  39: \"ArrowRight\",\n  40: \"ArrowDown\",\n  44: \"PrintScreen\",\n  45: \"Insert\",\n  46: \"Delete\",\n  59: \";\",\n  61: \"=\",\n  91: \"Meta\",\n  92: \"Meta\",\n  106: \"*\",\n  107: \"+\",\n  108: \",\",\n  109: \"-\",\n  110: \".\",\n  111: \"/\",\n  144: \"NumLock\",\n  145: \"ScrollLock\",\n  160: \"Shift\",\n  161: \"Shift\",\n  162: \"Control\",\n  163: \"Control\",\n  164: \"Alt\",\n  165: \"Alt\",\n  173: \"-\",\n  186: \";\",\n  187: \"=\",\n  188: \",\",\n  189: \"-\",\n  190: \".\",\n  191: \"/\",\n  192: \"`\",\n  219: \"[\",\n  220: \"\\\\\",\n  221: \"]\",\n  222: \"'\"\n}, pl = {\n  48: \")\",\n  49: \"!\",\n  50: \"@\",\n  51: \"#\",\n  52: \"$\",\n  53: \"%\",\n  54: \"^\",\n  55: \"&\",\n  56: \"*\",\n  57: \"(\",\n  59: \":\",\n  61: \"+\",\n  173: \"_\",\n  186: \":\",\n  187: \"+\",\n  188: \"<\",\n  189: \"_\",\n  190: \">\",\n  191: \"?\",\n  192: \"~\",\n  219: \"{\",\n  220: \"|\",\n  221: \"}\",\n  222: '\"'\n}, ON = typeof navigator < \"u\" && /Mac/.test(navigator.platform), gN = typeof navigator < \"u\" && /MSIE \\d|Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent);\nfor (var Ht = 0; Ht < 10; Ht++)\n  os[48 + Ht] = os[96 + Ht] = String(Ht);\nfor (var Ht = 1; Ht <= 24; Ht++)\n  os[Ht + 111] = \"F\" + Ht;\nfor (var Ht = 65; Ht <= 90; Ht++)\n  os[Ht] = String.fromCharCode(Ht + 32), pl[Ht] = String.fromCharCode(Ht);\nfor (var kf in os)\n  pl.hasOwnProperty(kf) || (pl[kf] = os[kf]);\nfunction mN(t) {\n  var e = ON && t.metaKey && t.shiftKey && !t.ctrlKey && !t.altKey || gN && t.shiftKey && t.key && t.key.length == 1 || t.key == \"Unidentified\", n = !e && t.key || (t.shiftKey ? pl : os)[t.keyCode] || t.key || \"Unidentified\";\n  return n == \"Esc\" && (n = \"Escape\"), n == \"Del\" && (n = \"Delete\"), n == \"Left\" && (n = \"ArrowLeft\"), n == \"Up\" && (n = \"ArrowUp\"), n == \"Right\" && (n = \"ArrowRight\"), n == \"Down\" && (n = \"ArrowDown\"), n;\n}\nfunction Iu(t) {\n  let e;\n  return t.nodeType == 11 ? e = t.getSelection ? t : t.ownerDocument : e = t, e.getSelection();\n}\nfunction np(t, e) {\n  return e ? t == e || t.contains(e.nodeType != 1 ? e.parentNode : e) : !1;\n}\nfunction bN(t) {\n  let e = t.activeElement;\n  for (; e && e.shadowRoot; )\n    e = e.shadowRoot.activeElement;\n  return e;\n}\nfunction ru(t, e) {\n  if (!e.anchorNode)\n    return !1;\n  try {\n    return np(t, e.anchorNode);\n  } catch {\n    return !1;\n  }\n}\nfunction Ol(t) {\n  return t.nodeType == 3 ? Ys(t, 0, t.nodeValue.length).getClientRects() : t.nodeType == 1 ? t.getClientRects() : [];\n}\nfunction za(t, e, n, r) {\n  return n ? Lb(t, e, n, r, -1) || Lb(t, e, n, r, 1) : !1;\n}\nfunction gl(t) {\n  for (var e = 0; ; e++)\n    if (t = t.previousSibling, !t)\n      return e;\n}\nfunction Lb(t, e, n, r, i) {\n  for (; ; ) {\n    if (t == n && e == r)\n      return !0;\n    if (e == (i < 0 ? 0 : fi(t))) {\n      if (t.nodeName == \"DIV\")\n        return !1;\n      let s = t.parentNode;\n      if (!s || s.nodeType != 1)\n        return !1;\n      e = gl(t) + (i < 0 ? 0 : 1), t = s;\n    } else if (t.nodeType == 1) {\n      if (t = t.childNodes[e + (i < 0 ? -1 : 0)], t.nodeType == 1 && t.contentEditable == \"false\")\n        return !1;\n      e = i < 0 ? fi(t) : 0;\n    } else\n      return !1;\n  }\n}\nfunction fi(t) {\n  return t.nodeType == 3 ? t.nodeValue.length : t.childNodes.length;\n}\nfunction sg(t, e) {\n  let n = e ? t.left : t.right;\n  return { left: n, right: n, top: t.top, bottom: t.bottom };\n}\nfunction vN(t) {\n  return {\n    left: 0,\n    right: t.innerWidth,\n    top: 0,\n    bottom: t.innerHeight\n  };\n}\nfunction Kw(t, e) {\n  let n = e.width / t.offsetWidth, r = e.height / t.offsetHeight;\n  return (n > 0.995 && n < 1.005 || !isFinite(n) || Math.abs(e.width - t.offsetWidth) < 1) && (n = 1), (r > 0.995 && r < 1.005 || !isFinite(r) || Math.abs(e.height - t.offsetHeight) < 1) && (r = 1), { scaleX: n, scaleY: r };\n}\nfunction yN(t, e, n, r, i, s, o, a) {\n  let l = t.ownerDocument, c = l.defaultView || window;\n  for (let u = t, d = !1; u && !d; )\n    if (u.nodeType == 1) {\n      let f, h = u == l.body, p = 1, O = 1;\n      if (h)\n        f = vN(c);\n      else {\n        if (/^(fixed|sticky)$/.test(getComputedStyle(u).position) && (d = !0), u.scrollHeight <= u.clientHeight && u.scrollWidth <= u.clientWidth) {\n          u = u.assignedSlot || u.parentNode;\n          continue;\n        }\n        let b = u.getBoundingClientRect();\n        ({ scaleX: p, scaleY: O } = Kw(u, b)), f = {\n          left: b.left,\n          right: b.left + u.clientWidth * p,\n          top: b.top,\n          bottom: b.top + u.clientHeight * O\n        };\n      }\n      let m = 0, y = 0;\n      if (i == \"nearest\")\n        e.top < f.top ? (y = -(f.top - e.top + o), n > 0 && e.bottom > f.bottom + y && (y = e.bottom - f.bottom + y + o)) : e.bottom > f.bottom && (y = e.bottom - f.bottom + o, n < 0 && e.top - y < f.top && (y = -(f.top + y - e.top + o)));\n      else {\n        let b = e.bottom - e.top, g = f.bottom - f.top;\n        y = (i == \"center\" && b <= g ? e.top + b / 2 - g / 2 : i == \"start\" || i == \"center\" && n < 0 ? e.top - o : e.bottom - g + o) - f.top;\n      }\n      if (r == \"nearest\" ? e.left < f.left ? (m = -(f.left - e.left + s), n > 0 && e.right > f.right + m && (m = e.right - f.right + m + s)) : e.right > f.right && (m = e.right - f.right + s, n < 0 && e.left < f.left + m && (m = -(f.left + m - e.left + s))) : m = (r == \"center\" ? e.left + (e.right - e.left) / 2 - (f.right - f.left) / 2 : r == \"start\" == a ? e.left - s : e.right - (f.right - f.left) + s) - f.left, m || y)\n        if (h)\n          c.scrollBy(m, y);\n        else {\n          let b = 0, g = 0;\n          if (y) {\n            let v = u.scrollTop;\n            u.scrollTop += y / O, g = (u.scrollTop - v) * O;\n          }\n          if (m) {\n            let v = u.scrollLeft;\n            u.scrollLeft += m / p, b = (u.scrollLeft - v) * p;\n          }\n          e = {\n            left: e.left - b,\n            top: e.top - g,\n            right: e.right - b,\n            bottom: e.bottom - g\n          }, b && Math.abs(b - m) < 1 && (r = \"nearest\"), g && Math.abs(g - y) < 1 && (i = \"nearest\");\n        }\n      if (h)\n        break;\n      u = u.assignedSlot || u.parentNode;\n    } else if (u.nodeType == 11)\n      u = u.host;\n    else\n      break;\n}\nfunction SN(t) {\n  let e = t.ownerDocument;\n  for (let n = t.parentNode; n && n != e.body; )\n    if (n.nodeType == 1) {\n      if (n.scrollHeight > n.clientHeight || n.scrollWidth > n.clientWidth)\n        return n;\n      n = n.assignedSlot || n.parentNode;\n    } else if (n.nodeType == 11)\n      n = n.host;\n    else\n      break;\n  return null;\n}\nclass wN {\n  constructor() {\n    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;\n  }\n  eq(e) {\n    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;\n  }\n  setRange(e) {\n    let { anchorNode: n, focusNode: r } = e;\n    this.set(n, Math.min(e.anchorOffset, n ? fi(n) : 0), r, Math.min(e.focusOffset, r ? fi(r) : 0));\n  }\n  set(e, n, r, i) {\n    this.anchorNode = e, this.anchorOffset = n, this.focusNode = r, this.focusOffset = i;\n  }\n}\nlet oo = null;\nfunction Jw(t) {\n  if (t.setActive)\n    return t.setActive();\n  if (oo)\n    return t.focus(oo);\n  let e = [];\n  for (let n = t; n && (e.push(n, n.scrollTop, n.scrollLeft), n != n.ownerDocument); n = n.parentNode)\n    ;\n  if (t.focus(oo == null ? {\n    get preventScroll() {\n      return oo = { preventScroll: !0 }, !0;\n    }\n  } : void 0), !oo) {\n    oo = !1;\n    for (let n = 0; n < e.length; ) {\n      let r = e[n++], i = e[n++], s = e[n++];\n      r.scrollTop != i && (r.scrollTop = i), r.scrollLeft != s && (r.scrollLeft = s);\n    }\n  }\n}\nlet Ub;\nfunction Ys(t, e, n = e) {\n  let r = Ub || (Ub = document.createRange());\n  return r.setEnd(t, n), r.setStart(t, e), r;\n}\nfunction To(t, e, n) {\n  let r = { key: e, code: e, keyCode: n, which: n, cancelable: !0 }, i = new KeyboardEvent(\"keydown\", r);\n  i.synthetic = !0, t.dispatchEvent(i);\n  let s = new KeyboardEvent(\"keyup\", r);\n  return s.synthetic = !0, t.dispatchEvent(s), i.defaultPrevented || s.defaultPrevented;\n}\nfunction kN(t) {\n  for (; t; ) {\n    if (t && (t.nodeType == 9 || t.nodeType == 11 && t.host))\n      return t;\n    t = t.assignedSlot || t.parentNode;\n  }\n  return null;\n}\nfunction ek(t) {\n  for (; t.attributes.length; )\n    t.removeAttributeNode(t.attributes[0]);\n}\nfunction xN(t, e) {\n  let n = e.focusNode, r = e.focusOffset;\n  if (!n || e.anchorNode != n || e.anchorOffset != r)\n    return !1;\n  for (r = Math.min(r, fi(n)); ; )\n    if (r) {\n      if (n.nodeType != 1)\n        return !1;\n      let i = n.childNodes[r - 1];\n      i.contentEditable == \"false\" ? r-- : (n = i, r = fi(n));\n    } else {\n      if (n == t)\n        return !0;\n      r = gl(n), n = n.parentNode;\n    }\n}\nfunction tk(t) {\n  return t.scrollTop > Math.max(1, t.scrollHeight - t.clientHeight - 4);\n}\nclass an {\n  constructor(e, n, r = !0) {\n    this.node = e, this.offset = n, this.precise = r;\n  }\n  static before(e, n) {\n    return new an(e.parentNode, gl(e), n);\n  }\n  static after(e, n) {\n    return new an(e.parentNode, gl(e) + 1, n);\n  }\n}\nconst og = [];\nclass ft {\n  constructor() {\n    this.parent = null, this.dom = null, this.flags = 2;\n  }\n  get overrideDOMText() {\n    return null;\n  }\n  get posAtStart() {\n    return this.parent ? this.parent.posBefore(this) : 0;\n  }\n  get posAtEnd() {\n    return this.posAtStart + this.length;\n  }\n  posBefore(e) {\n    let n = this.posAtStart;\n    for (let r of this.children) {\n      if (r == e)\n        return n;\n      n += r.length + r.breakAfter;\n    }\n    throw new RangeError(\"Invalid child in posBefore\");\n  }\n  posAfter(e) {\n    return this.posBefore(e) + e.length;\n  }\n  sync(e, n) {\n    if (this.flags & 2) {\n      let r = this.dom, i = null, s;\n      for (let o of this.children) {\n        if (o.flags & 7) {\n          if (!o.dom && (s = i ? i.nextSibling : r.firstChild)) {\n            let a = ft.get(s);\n            (!a || !a.parent && a.canReuseDOM(o)) && o.reuseDOM(s);\n          }\n          o.sync(e, n), o.flags &= -8;\n        }\n        if (s = i ? i.nextSibling : r.firstChild, n && !n.written && n.node == r && s != o.dom && (n.written = !0), o.dom.parentNode == r)\n          for (; s && s != o.dom; )\n            s = qb(s);\n        else\n          r.insertBefore(o.dom, s);\n        i = o.dom;\n      }\n      for (s = i ? i.nextSibling : r.firstChild, s && n && n.node == r && (n.written = !0); s; )\n        s = qb(s);\n    } else if (this.flags & 1)\n      for (let r of this.children)\n        r.flags & 7 && (r.sync(e, n), r.flags &= -8);\n  }\n  reuseDOM(e) {\n  }\n  localPosFromDOM(e, n) {\n    let r;\n    if (e == this.dom)\n      r = this.dom.childNodes[n];\n    else {\n      let i = fi(e) == 0 ? 0 : n == 0 ? -1 : 1;\n      for (; ; ) {\n        let s = e.parentNode;\n        if (s == this.dom)\n          break;\n        i == 0 && s.firstChild != s.lastChild && (e == s.firstChild ? i = -1 : i = 1), e = s;\n      }\n      i < 0 ? r = e : r = e.nextSibling;\n    }\n    if (r == this.dom.firstChild)\n      return 0;\n    for (; r && !ft.get(r); )\n      r = r.nextSibling;\n    if (!r)\n      return this.length;\n    for (let i = 0, s = 0; ; i++) {\n      let o = this.children[i];\n      if (o.dom == r)\n        return s;\n      s += o.length + o.breakAfter;\n    }\n  }\n  domBoundsAround(e, n, r = 0) {\n    let i = -1, s = -1, o = -1, a = -1;\n    for (let l = 0, c = r, u = r; l < this.children.length; l++) {\n      let d = this.children[l], f = c + d.length;\n      if (c < e && f > n)\n        return d.domBoundsAround(e, n, c);\n      if (f >= e && i == -1 && (i = l, s = c), c > n && d.dom.parentNode == this.dom) {\n        o = l, a = u;\n        break;\n      }\n      u = f, c = f + d.breakAfter;\n    }\n    return {\n      from: s,\n      to: a < 0 ? r + this.length : a,\n      startDOM: (i ? this.children[i - 1].dom.nextSibling : null) || this.dom.firstChild,\n      endDOM: o < this.children.length && o >= 0 ? this.children[o].dom : null\n    };\n  }\n  markDirty(e = !1) {\n    this.flags |= 2, this.markParentsDirty(e);\n  }\n  markParentsDirty(e) {\n    for (let n = this.parent; n; n = n.parent) {\n      if (e && (n.flags |= 2), n.flags & 1)\n        return;\n      n.flags |= 1, e = !1;\n    }\n  }\n  setParent(e) {\n    this.parent != e && (this.parent = e, this.flags & 7 && this.markParentsDirty(!0));\n  }\n  setDOM(e) {\n    this.dom != e && (this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this);\n  }\n  get rootView() {\n    for (let e = this; ; ) {\n      let n = e.parent;\n      if (!n)\n        return e;\n      e = n;\n    }\n  }\n  replaceChildren(e, n, r = og) {\n    this.markDirty();\n    for (let i = e; i < n; i++) {\n      let s = this.children[i];\n      s.parent == this && r.indexOf(s) < 0 && s.destroy();\n    }\n    this.children.splice(e, n - e, ...r);\n    for (let i = 0; i < r.length; i++)\n      r[i].setParent(this);\n  }\n  ignoreMutation(e) {\n    return !1;\n  }\n  ignoreEvent(e) {\n    return !1;\n  }\n  childCursor(e = this.length) {\n    return new nk(this.children, e, this.children.length);\n  }\n  childPos(e, n = 1) {\n    return this.childCursor().findPos(e, n);\n  }\n  toString() {\n    let e = this.constructor.name.replace(\"View\", \"\");\n    return e + (this.children.length ? \"(\" + this.children.join() + \")\" : this.length ? \"[\" + (e == \"Text\" ? this.text : this.length) + \"]\" : \"\") + (this.breakAfter ? \"#\" : \"\");\n  }\n  static get(e) {\n    return e.cmView;\n  }\n  get isEditable() {\n    return !0;\n  }\n  get isWidget() {\n    return !1;\n  }\n  get isHidden() {\n    return !1;\n  }\n  merge(e, n, r, i, s, o) {\n    return !1;\n  }\n  become(e) {\n    return !1;\n  }\n  canReuseDOM(e) {\n    return e.constructor == this.constructor && !((this.flags | e.flags) & 8);\n  }\n  // When this is a zero-length view with a side, this should return a\n  // number <= 0 to indicate it is before its position, or a\n  // number > 0 when after its position.\n  getSide() {\n    return 0;\n  }\n  destroy() {\n    for (let e of this.children)\n      e.parent == this && e.destroy();\n    this.parent = null;\n  }\n}\nft.prototype.breakAfter = 0;\nfunction qb(t) {\n  let e = t.nextSibling;\n  return t.parentNode.removeChild(t), e;\n}\nclass nk {\n  constructor(e, n, r) {\n    this.children = e, this.pos = n, this.i = r, this.off = 0;\n  }\n  findPos(e, n = 1) {\n    for (; ; ) {\n      if (e > this.pos || e == this.pos && (n > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))\n        return this.off = e - this.pos, this;\n      let r = this.children[--this.i];\n      this.pos -= r.length + r.breakAfter;\n    }\n  }\n}\nfunction rk(t, e, n, r, i, s, o, a, l) {\n  let { children: c } = t, u = c.length ? c[e] : null, d = s.length ? s[s.length - 1] : null, f = d ? d.breakAfter : o;\n  if (!(e == r && u && !o && !f && s.length < 2 && u.merge(n, i, s.length ? d : null, n == 0, a, l))) {\n    if (r < c.length) {\n      let h = c[r];\n      h && (i < h.length || h.breakAfter && (d != null && d.breakAfter)) ? (e == r && (h = h.split(i), i = 0), !f && d && h.merge(0, i, d, !0, 0, l) ? s[s.length - 1] = h : ((i || h.children.length && !h.children[0].length) && h.merge(0, i, null, !1, 0, l), s.push(h))) : h != null && h.breakAfter && (d ? d.breakAfter = 1 : o = 1), r++;\n    }\n    for (u && (u.breakAfter = o, n > 0 && (!o && s.length && u.merge(n, u.length, s[0], !1, a, 0) ? u.breakAfter = s.shift().breakAfter : (n < u.length || u.children.length && u.children[u.children.length - 1].length == 0) && u.merge(n, u.length, null, !1, a, 0), e++)); e < r && s.length; )\n      if (c[r - 1].become(s[s.length - 1]))\n        r--, s.pop(), l = s.length ? 0 : a;\n      else if (c[e].become(s[0]))\n        e++, s.shift(), a = s.length ? 0 : l;\n      else\n        break;\n    !s.length && e && r < c.length && !c[e - 1].breakAfter && c[r].merge(0, 0, c[e - 1], !1, a, l) && e--, (e < r || s.length) && t.replaceChildren(e, r, s);\n  }\n}\nfunction ik(t, e, n, r, i, s) {\n  let o = t.childCursor(), { i: a, off: l } = o.findPos(n, 1), { i: c, off: u } = o.findPos(e, -1), d = e - n;\n  for (let f of r)\n    d += f.length;\n  t.length += d, rk(t, c, u, a, l, r, 0, i, s);\n}\nlet Vn = typeof navigator < \"u\" ? navigator : { userAgent: \"\", vendor: \"\", platform: \"\" }, rp = typeof document < \"u\" ? document : { documentElement: { style: {} } };\nconst ip = /* @__PURE__ */ /Edge\\/(\\d+)/.exec(Vn.userAgent), sk = /* @__PURE__ */ /MSIE \\d/.test(Vn.userAgent), sp = /* @__PURE__ */ /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(Vn.userAgent), qd = !!(sk || sp || ip), Yb = !qd && /* @__PURE__ */ /gecko\\/(\\d+)/i.test(Vn.userAgent), xf = !qd && /* @__PURE__ */ /Chrome\\/(\\d+)/.exec(Vn.userAgent), zb = \"webkitFontSmoothing\" in rp.documentElement.style, ok = !qd && /* @__PURE__ */ /Apple Computer/.test(Vn.vendor), Hb = ok && (/* @__PURE__ */ /Mobile\\/\\w+/.test(Vn.userAgent) || Vn.maxTouchPoints > 2);\nvar de = {\n  mac: Hb || /* @__PURE__ */ /Mac/.test(Vn.platform),\n  windows: /* @__PURE__ */ /Win/.test(Vn.platform),\n  linux: /* @__PURE__ */ /Linux|X11/.test(Vn.platform),\n  ie: qd,\n  ie_version: sk ? rp.documentMode || 6 : sp ? +sp[1] : ip ? +ip[1] : 0,\n  gecko: Yb,\n  gecko_version: Yb ? +(/* @__PURE__ */ /Firefox\\/(\\d+)/.exec(Vn.userAgent) || [0, 0])[1] : 0,\n  chrome: !!xf,\n  chrome_version: xf ? +xf[1] : 0,\n  ios: Hb,\n  android: /* @__PURE__ */ /Android\\b/.test(Vn.userAgent),\n  webkit: zb,\n  safari: ok,\n  webkit_version: zb ? +(/* @__PURE__ */ /\\bAppleWebKit\\/(\\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,\n  tabSize: rp.documentElement.style.tabSize != null ? \"tab-size\" : \"-moz-tab-size\"\n};\nconst PN = 256;\nclass hi extends ft {\n  constructor(e) {\n    super(), this.text = e;\n  }\n  get length() {\n    return this.text.length;\n  }\n  createDOM(e) {\n    this.setDOM(e || document.createTextNode(this.text));\n  }\n  sync(e, n) {\n    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (n && n.node == this.dom && (n.written = !0), this.dom.nodeValue = this.text);\n  }\n  reuseDOM(e) {\n    e.nodeType == 3 && this.createDOM(e);\n  }\n  merge(e, n, r) {\n    return this.flags & 8 || r && (!(r instanceof hi) || this.length - (n - e) + r.length > PN || r.flags & 8) ? !1 : (this.text = this.text.slice(0, e) + (r ? r.text : \"\") + this.text.slice(n), this.markDirty(), !0);\n  }\n  split(e) {\n    let n = new hi(this.text.slice(e));\n    return this.text = this.text.slice(0, e), this.markDirty(), n.flags |= this.flags & 8, n;\n  }\n  localPosFromDOM(e, n) {\n    return e == this.dom ? n : n ? this.text.length : 0;\n  }\n  domAtPos(e) {\n    return new an(this.dom, e);\n  }\n  domBoundsAround(e, n, r) {\n    return { from: r, to: r + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };\n  }\n  coordsAt(e, n) {\n    return _N(this.dom, e, n);\n  }\n}\nclass pi extends ft {\n  constructor(e, n = [], r = 0) {\n    super(), this.mark = e, this.children = n, this.length = r;\n    for (let i of n)\n      i.setParent(this);\n  }\n  setAttrs(e) {\n    if (ek(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)\n      for (let n in this.mark.attrs)\n        e.setAttribute(n, this.mark.attrs[n]);\n    return e;\n  }\n  canReuseDOM(e) {\n    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);\n  }\n  reuseDOM(e) {\n    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.flags |= 6);\n  }\n  sync(e, n) {\n    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, n);\n  }\n  merge(e, n, r, i, s, o) {\n    return r && (!(r instanceof pi && r.mark.eq(this.mark)) || e && s <= 0 || n < this.length && o <= 0) ? !1 : (ik(this, e, n, r ? r.children.slice() : [], s - 1, o - 1), this.markDirty(), !0);\n  }\n  split(e) {\n    let n = [], r = 0, i = -1, s = 0;\n    for (let a of this.children) {\n      let l = r + a.length;\n      l > e && n.push(r < e ? a.split(e - r) : a), i < 0 && r >= e && (i = s), r = l, s++;\n    }\n    let o = this.length - e;\n    return this.length = e, i > -1 && (this.children.length = i, this.markDirty()), new pi(this.mark, n, o);\n  }\n  domAtPos(e) {\n    return ak(this, e);\n  }\n  coordsAt(e, n) {\n    return ck(this, e, n);\n  }\n}\nfunction _N(t, e, n) {\n  let r = t.nodeValue.length;\n  e > r && (e = r);\n  let i = e, s = e, o = 0;\n  e == 0 && n < 0 || e == r && n >= 0 ? de.chrome || de.gecko || (e ? (i--, o = 1) : s < r && (s++, o = -1)) : n < 0 ? i-- : s < r && s++;\n  let a = Ys(t, i, s).getClientRects();\n  if (!a.length)\n    return null;\n  let l = a[(o ? o < 0 : n >= 0) ? 0 : a.length - 1];\n  return de.safari && !o && l.width == 0 && (l = Array.prototype.find.call(a, (c) => c.width) || l), o ? sg(l, o < 0) : l || null;\n}\nclass Ps extends ft {\n  static create(e, n, r) {\n    return new Ps(e, n, r);\n  }\n  constructor(e, n, r) {\n    super(), this.widget = e, this.length = n, this.side = r, this.prevWidget = null;\n  }\n  split(e) {\n    let n = Ps.create(this.widget, this.length - e, this.side);\n    return this.length -= e, n;\n  }\n  sync(e) {\n    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = \"false\"));\n  }\n  getSide() {\n    return this.side;\n  }\n  merge(e, n, r, i, s, o) {\n    return r && (!(r instanceof Ps) || !this.widget.compare(r.widget) || e > 0 && s <= 0 || n < this.length && o <= 0) ? !1 : (this.length = e + (r ? r.length : 0) + (this.length - n), !0);\n  }\n  become(e) {\n    return e instanceof Ps && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, !0) : !1;\n  }\n  ignoreMutation() {\n    return !0;\n  }\n  ignoreEvent(e) {\n    return this.widget.ignoreEvent(e);\n  }\n  get overrideDOMText() {\n    if (this.length == 0)\n      return Fe.empty;\n    let e = this;\n    for (; e.parent; )\n      e = e.parent;\n    let { view: n } = e, r = n && n.state.doc, i = this.posAtStart;\n    return r ? r.slice(i, i + this.length) : Fe.empty;\n  }\n  domAtPos(e) {\n    return (this.length ? e == 0 : this.side > 0) ? an.before(this.dom) : an.after(this.dom, e == this.length);\n  }\n  domBoundsAround() {\n    return null;\n  }\n  coordsAt(e, n) {\n    let r = this.widget.coordsAt(this.dom, e, n);\n    if (r)\n      return r;\n    let i = this.dom.getClientRects(), s = null;\n    if (!i.length)\n      return null;\n    let o = this.side ? this.side < 0 : e > 0;\n    for (let a = o ? i.length - 1 : 0; s = i[a], !(e > 0 ? a == 0 : a == i.length - 1 || s.top < s.bottom); a += o ? -1 : 1)\n      ;\n    return sg(s, !o);\n  }\n  get isEditable() {\n    return !1;\n  }\n  get isWidget() {\n    return !0;\n  }\n  get isHidden() {\n    return this.widget.isHidden;\n  }\n  destroy() {\n    super.destroy(), this.dom && this.widget.destroy(this.dom);\n  }\n}\nclass Bo extends ft {\n  constructor(e) {\n    super(), this.side = e;\n  }\n  get length() {\n    return 0;\n  }\n  merge() {\n    return !1;\n  }\n  become(e) {\n    return e instanceof Bo && e.side == this.side;\n  }\n  split() {\n    return new Bo(this.side);\n  }\n  sync() {\n    if (!this.dom) {\n      let e = document.createElement(\"img\");\n      e.className = \"cm-widgetBuffer\", e.setAttribute(\"aria-hidden\", \"true\"), this.setDOM(e);\n    }\n  }\n  getSide() {\n    return this.side;\n  }\n  domAtPos(e) {\n    return this.side > 0 ? an.before(this.dom) : an.after(this.dom);\n  }\n  localPosFromDOM() {\n    return 0;\n  }\n  domBoundsAround() {\n    return null;\n  }\n  coordsAt(e) {\n    return this.dom.getBoundingClientRect();\n  }\n  get overrideDOMText() {\n    return Fe.empty;\n  }\n  get isHidden() {\n    return !0;\n  }\n}\nhi.prototype.children = Ps.prototype.children = Bo.prototype.children = og;\nfunction ak(t, e) {\n  let n = t.dom, { children: r } = t, i = 0;\n  for (let s = 0; i < r.length; i++) {\n    let o = r[i], a = s + o.length;\n    if (!(a == s && o.getSide() <= 0)) {\n      if (e > s && e < a && o.dom.parentNode == n)\n        return o.domAtPos(e - s);\n      if (e <= s)\n        break;\n      s = a;\n    }\n  }\n  for (let s = i; s > 0; s--) {\n    let o = r[s - 1];\n    if (o.dom.parentNode == n)\n      return o.domAtPos(o.length);\n  }\n  for (let s = i; s < r.length; s++) {\n    let o = r[s];\n    if (o.dom.parentNode == n)\n      return o.domAtPos(0);\n  }\n  return new an(n, 0);\n}\nfunction lk(t, e, n) {\n  let r, { children: i } = t;\n  n > 0 && e instanceof pi && i.length && (r = i[i.length - 1]) instanceof pi && r.mark.eq(e.mark) ? lk(r, e.children[0], n - 1) : (i.push(e), e.setParent(t)), t.length += e.length;\n}\nfunction ck(t, e, n) {\n  let r = null, i = -1, s = null, o = -1;\n  function a(c, u) {\n    for (let d = 0, f = 0; d < c.children.length && f <= u; d++) {\n      let h = c.children[d], p = f + h.length;\n      p >= u && (h.children.length ? a(h, u - f) : (!s || s.isHidden && n > 0) && (p > u || f == p && h.getSide() > 0) ? (s = h, o = u - f) : (f < u || f == p && h.getSide() < 0 && !h.isHidden) && (r = h, i = u - f)), f = p;\n    }\n  }\n  a(t, e);\n  let l = (n < 0 ? r : s) || r || s;\n  return l ? l.coordsAt(Math.max(0, l == r ? i : o), n) : TN(t);\n}\nfunction TN(t) {\n  let e = t.dom.lastChild;\n  if (!e)\n    return t.dom.getBoundingClientRect();\n  let n = Ol(e);\n  return n[n.length - 1] || null;\n}\nfunction op(t, e) {\n  for (let n in t)\n    n == \"class\" && e.class ? e.class += \" \" + t.class : n == \"style\" && e.style ? e.style += \";\" + t.style : e[n] = t[n];\n  return e;\n}\nconst Fb = /* @__PURE__ */ Object.create(null);\nfunction ag(t, e, n) {\n  if (t == e)\n    return !0;\n  t || (t = Fb), e || (e = Fb);\n  let r = Object.keys(t), i = Object.keys(e);\n  if (r.length - (n && r.indexOf(n) > -1 ? 1 : 0) != i.length - (n && i.indexOf(n) > -1 ? 1 : 0))\n    return !1;\n  for (let s of r)\n    if (s != n && (i.indexOf(s) == -1 || t[s] !== e[s]))\n      return !1;\n  return !0;\n}\nfunction ap(t, e, n) {\n  let r = !1;\n  if (e)\n    for (let i in e)\n      n && i in n || (r = !0, i == \"style\" ? t.style.cssText = \"\" : t.removeAttribute(i));\n  if (n)\n    for (let i in n)\n      e && e[i] == n[i] || (r = !0, i == \"style\" ? t.style.cssText = n[i] : t.setAttribute(i, n[i]));\n  return r;\n}\nfunction EN(t) {\n  let e = /* @__PURE__ */ Object.create(null);\n  for (let n = 0; n < t.attributes.length; n++) {\n    let r = t.attributes[n];\n    e[r.name] = r.value;\n  }\n  return e;\n}\nclass Nt extends ft {\n  constructor() {\n    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;\n  }\n  // Consumes source\n  merge(e, n, r, i, s, o) {\n    if (r) {\n      if (!(r instanceof Nt))\n        return !1;\n      this.dom || r.transferDOM(this);\n    }\n    return i && this.setDeco(r ? r.attrs : null), ik(this, e, n, r ? r.children.slice() : [], s, o), !0;\n  }\n  split(e) {\n    let n = new Nt();\n    if (n.breakAfter = this.breakAfter, this.length == 0)\n      return n;\n    let { i: r, off: i } = this.childPos(e);\n    i && (n.append(this.children[r].split(i), 0), this.children[r].merge(i, this.children[r].length, null, !1, 0, 0), r++);\n    for (let s = r; s < this.children.length; s++)\n      n.append(this.children[s], 0);\n    for (; r > 0 && this.children[r - 1].length == 0; )\n      this.children[--r].destroy();\n    return this.children.length = r, this.markDirty(), this.length = e, n;\n  }\n  transferDOM(e) {\n    this.dom && (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);\n  }\n  setDeco(e) {\n    ag(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);\n  }\n  append(e, n) {\n    lk(this, e, n);\n  }\n  // Only called when building a line view in ContentBuilder\n  addLineDeco(e) {\n    let n = e.spec.attributes, r = e.spec.class;\n    n && (this.attrs = op(n, this.attrs || {})), r && (this.attrs = op({ class: r }, this.attrs || {}));\n  }\n  domAtPos(e) {\n    return ak(this, e);\n  }\n  reuseDOM(e) {\n    e.nodeName == \"DIV\" && (this.setDOM(e), this.flags |= 6);\n  }\n  sync(e, n) {\n    var r;\n    this.dom ? this.flags & 4 && (ek(this.dom), this.dom.className = \"cm-line\", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement(\"div\")), this.dom.className = \"cm-line\", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (ap(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add(\"cm-line\"), this.prevAttrs = void 0), super.sync(e, n);\n    let i = this.dom.lastChild;\n    for (; i && ft.get(i) instanceof pi; )\n      i = i.lastChild;\n    if (!i || !this.length || i.nodeName != \"BR\" && ((r = ft.get(i)) === null || r === void 0 ? void 0 : r.isEditable) == !1 && (!de.ios || !this.children.some((s) => s instanceof hi))) {\n      let s = document.createElement(\"BR\");\n      s.cmIgnore = !0, this.dom.appendChild(s);\n    }\n  }\n  measureTextSize() {\n    if (this.children.length == 0 || this.length > 20)\n      return null;\n    let e = 0, n;\n    for (let r of this.children) {\n      if (!(r instanceof hi) || /[^ -~]/.test(r.text))\n        return null;\n      let i = Ol(r.dom);\n      if (i.length != 1)\n        return null;\n      e += i[0].width, n = i[0].height;\n    }\n    return e ? {\n      lineHeight: this.dom.getBoundingClientRect().height,\n      charWidth: e / this.length,\n      textHeight: n\n    } : null;\n  }\n  coordsAt(e, n) {\n    let r = ck(this, e, n);\n    if (!this.children.length && r && this.parent) {\n      let { heightOracle: i } = this.parent.view.viewState, s = r.bottom - r.top;\n      if (Math.abs(s - i.lineHeight) < 2 && i.textHeight < s) {\n        let o = (s - i.textHeight) / 2;\n        return { top: r.top + o, bottom: r.bottom - o, left: r.left, right: r.left };\n      }\n    }\n    return r;\n  }\n  become(e) {\n    return !1;\n  }\n  covers() {\n    return !0;\n  }\n  static find(e, n) {\n    for (let r = 0, i = 0; r < e.children.length; r++) {\n      let s = e.children[r], o = i + s.length;\n      if (o >= n) {\n        if (s instanceof Nt)\n          return s;\n        if (o > n)\n          break;\n      }\n      i = o + s.breakAfter;\n    }\n    return null;\n  }\n}\nclass Ki extends ft {\n  constructor(e, n, r) {\n    super(), this.widget = e, this.length = n, this.deco = r, this.breakAfter = 0, this.prevWidget = null;\n  }\n  merge(e, n, r, i, s, o) {\n    return r && (!(r instanceof Ki) || !this.widget.compare(r.widget) || e > 0 && s <= 0 || n < this.length && o <= 0) ? !1 : (this.length = e + (r ? r.length : 0) + (this.length - n), !0);\n  }\n  domAtPos(e) {\n    return e == 0 ? an.before(this.dom) : an.after(this.dom, e == this.length);\n  }\n  split(e) {\n    let n = this.length - e;\n    this.length = e;\n    let r = new Ki(this.widget, n, this.deco);\n    return r.breakAfter = this.breakAfter, r;\n  }\n  get children() {\n    return og;\n  }\n  sync(e) {\n    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.widget.editable || (this.dom.contentEditable = \"false\"));\n  }\n  get overrideDOMText() {\n    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Fe.empty;\n  }\n  domBoundsAround() {\n    return null;\n  }\n  become(e) {\n    return e instanceof Ki && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.deco = e.deco, this.breakAfter = e.breakAfter, !0) : !1;\n  }\n  ignoreMutation() {\n    return !0;\n  }\n  ignoreEvent(e) {\n    return this.widget.ignoreEvent(e);\n  }\n  get isEditable() {\n    return !1;\n  }\n  get isWidget() {\n    return !0;\n  }\n  coordsAt(e, n) {\n    return this.widget.coordsAt(this.dom, e, n);\n  }\n  destroy() {\n    super.destroy(), this.dom && this.widget.destroy(this.dom);\n  }\n  covers(e) {\n    let { startSide: n, endSide: r } = this.deco;\n    return n == r ? !1 : e < 0 ? n < 0 : r > 0;\n  }\n}\nclass ra {\n  /**\n  Compare this instance to another instance of the same type.\n  (TypeScript can't express this, but only instances of the same\n  specific class will be passed to this method.) This is used to\n  avoid redrawing widgets when they are replaced by a new\n  decoration of the same type. The default implementation just\n  returns `false`, which will cause new instances of the widget to\n  always be redrawn.\n  */\n  eq(e) {\n    return !1;\n  }\n  /**\n  Update a DOM element created by a widget of the same type (but\n  different, non-`eq` content) to reflect this widget. May return\n  true to indicate that it could update, false to indicate it\n  couldn't (in which case the widget will be redrawn). The default\n  implementation just returns false.\n  */\n  updateDOM(e, n) {\n    return !1;\n  }\n  /**\n  @internal\n  */\n  compare(e) {\n    return this == e || this.constructor == e.constructor && this.eq(e);\n  }\n  /**\n  The estimated height this widget will have, to be used when\n  estimating the height of content that hasn't been drawn. May\n  return -1 to indicate you don't know. The default implementation\n  returns -1.\n  */\n  get estimatedHeight() {\n    return -1;\n  }\n  /**\n  For inline widgets that are displayed inline (as opposed to\n  `inline-block`) and introduce line breaks (through `<br>` tags\n  or textual newlines), this must indicate the amount of line\n  breaks they introduce. Defaults to 0.\n  */\n  get lineBreaks() {\n    return 0;\n  }\n  /**\n  Can be used to configure which kinds of events inside the widget\n  should be ignored by the editor. The default is to ignore all\n  events.\n  */\n  ignoreEvent(e) {\n    return !0;\n  }\n  /**\n  Override the way screen coordinates for positions at/in the\n  widget are found. `pos` will be the offset into the widget, and\n  `side` the side of the position that is being queriedless than\n  zero for before, greater than zero for after, and zero for\n  directly at that position.\n  */\n  coordsAt(e, n, r) {\n    return null;\n  }\n  /**\n  @internal\n  */\n  get isHidden() {\n    return !1;\n  }\n  /**\n  @internal\n  */\n  get editable() {\n    return !1;\n  }\n  /**\n  This is called when the an instance of the widget is removed\n  from the editor view.\n  */\n  destroy(e) {\n  }\n}\nvar fr = /* @__PURE__ */ function(t) {\n  return t[t.Text = 0] = \"Text\", t[t.WidgetBefore = 1] = \"WidgetBefore\", t[t.WidgetAfter = 2] = \"WidgetAfter\", t[t.WidgetRange = 3] = \"WidgetRange\", t;\n}(fr || (fr = {}));\nclass Je extends qs {\n  constructor(e, n, r, i) {\n    super(), this.startSide = e, this.endSide = n, this.widget = r, this.spec = i;\n  }\n  /**\n  @internal\n  */\n  get heightRelevant() {\n    return !1;\n  }\n  /**\n  Create a mark decoration, which influences the styling of the\n  content in its range. Nested mark decorations will cause nested\n  DOM elements to be created. Nesting order is determined by\n  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with\n  the higher-precedence decorations creating the inner DOM nodes.\n  Such elements are split on line boundaries and on the boundaries\n  of lower-precedence decorations.\n  */\n  static mark(e) {\n    return new Hl(e);\n  }\n  /**\n  Create a widget decoration, which displays a DOM element at the\n  given position.\n  */\n  static widget(e) {\n    let n = Math.max(-1e4, Math.min(1e4, e.side || 0)), r = !!e.block;\n    return n += r && !e.inlineOrder ? n > 0 ? 3e8 : -4e8 : n > 0 ? 1e8 : -1e8, new as(e, n, n, r, e.widget || null, !1);\n  }\n  /**\n  Create a replace decoration which replaces the given range with\n  a widget, or simply hides it.\n  */\n  static replace(e) {\n    let n = !!e.block, r, i;\n    if (e.isBlockGap)\n      r = -5e8, i = 4e8;\n    else {\n      let { start: s, end: o } = uk(e, n);\n      r = (s ? n ? -3e8 : -1 : 5e8) - 1, i = (o ? n ? 2e8 : 1 : -6e8) + 1;\n    }\n    return new as(e, r, i, n, e.widget || null, !0);\n  }\n  /**\n  Create a line decoration, which can add DOM attributes to the\n  line starting at the given position.\n  */\n  static line(e) {\n    return new Fl(e);\n  }\n  /**\n  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given\n  decorated range or ranges. If the ranges aren't already sorted,\n  pass `true` for `sort` to make the library sort them for you.\n  */\n  static set(e, n = !1) {\n    return ze.of(e, n);\n  }\n  /**\n  @internal\n  */\n  hasHeight() {\n    return this.widget ? this.widget.estimatedHeight > -1 : !1;\n  }\n}\nJe.none = ze.empty;\nclass Hl extends Je {\n  constructor(e) {\n    let { start: n, end: r } = uk(e);\n    super(n ? -1 : 5e8, r ? 1 : -6e8, null, e), this.tagName = e.tagName || \"span\", this.class = e.class || \"\", this.attrs = e.attributes || null;\n  }\n  eq(e) {\n    var n, r;\n    return this == e || e instanceof Hl && this.tagName == e.tagName && (this.class || ((n = this.attrs) === null || n === void 0 ? void 0 : n.class)) == (e.class || ((r = e.attrs) === null || r === void 0 ? void 0 : r.class)) && ag(this.attrs, e.attrs, \"class\");\n  }\n  range(e, n = e) {\n    if (e >= n)\n      throw new RangeError(\"Mark decorations may not be empty\");\n    return super.range(e, n);\n  }\n}\nHl.prototype.point = !1;\nclass Fl extends Je {\n  constructor(e) {\n    super(-2e8, -2e8, null, e);\n  }\n  eq(e) {\n    return e instanceof Fl && this.spec.class == e.spec.class && ag(this.spec.attributes, e.spec.attributes);\n  }\n  range(e, n = e) {\n    if (n != e)\n      throw new RangeError(\"Line decoration ranges must be zero-length\");\n    return super.range(e, n);\n  }\n}\nFl.prototype.mapMode = on.TrackBefore;\nFl.prototype.point = !0;\nclass as extends Je {\n  constructor(e, n, r, i, s, o) {\n    super(n, r, s, e), this.block = i, this.isReplace = o, this.mapMode = i ? n <= 0 ? on.TrackBefore : on.TrackAfter : on.TrackDel;\n  }\n  // Only relevant when this.block == true\n  get type() {\n    return this.startSide != this.endSide ? fr.WidgetRange : this.startSide <= 0 ? fr.WidgetBefore : fr.WidgetAfter;\n  }\n  get heightRelevant() {\n    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);\n  }\n  eq(e) {\n    return e instanceof as && $N(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;\n  }\n  range(e, n = e) {\n    if (this.isReplace && (e > n || e == n && this.startSide > 0 && this.endSide <= 0))\n      throw new RangeError(\"Invalid range for replacement decoration\");\n    if (!this.isReplace && n != e)\n      throw new RangeError(\"Widget decorations can only have zero-length ranges\");\n    return super.range(e, n);\n  }\n}\nas.prototype.point = !0;\nfunction uk(t, e = !1) {\n  let { inclusiveStart: n, inclusiveEnd: r } = t;\n  return n == null && (n = t.inclusive), r == null && (r = t.inclusive), { start: n ?? e, end: r ?? e };\n}\nfunction $N(t, e) {\n  return t == e || !!(t && e && t.compare(e));\n}\nfunction lp(t, e, n, r = 0) {\n  let i = n.length - 1;\n  i >= 0 && n[i] + r >= t ? n[i] = Math.max(n[i], e) : n.push(t, e);\n}\nclass Ha {\n  constructor(e, n, r, i) {\n    this.doc = e, this.pos = n, this.end = r, this.disallowBlockEffectsFor = i, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = \"\", this.textOff = 0, this.cursor = e.iter(), this.skip = n;\n  }\n  posCovered() {\n    if (this.content.length == 0)\n      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;\n    let e = this.content[this.content.length - 1];\n    return !(e.breakAfter || e instanceof Ki && e.deco.endSide < 0);\n  }\n  getLine() {\n    return this.curLine || (this.content.push(this.curLine = new Nt()), this.atCursorPos = !0), this.curLine;\n  }\n  flushBuffer(e = this.bufferMarks) {\n    this.pendingBuffer && (this.curLine.append(Pc(new Bo(-1), e), e.length), this.pendingBuffer = 0);\n  }\n  addBlockWidget(e) {\n    this.flushBuffer(), this.curLine = null, this.content.push(e);\n  }\n  finish(e) {\n    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, !this.posCovered() && !(e && this.content.length && this.content[this.content.length - 1] instanceof Ki) && this.getLine();\n  }\n  buildText(e, n, r) {\n    for (; e > 0; ) {\n      if (this.textOff == this.text.length) {\n        let { value: s, lineBreak: o, done: a } = this.cursor.next(this.skip);\n        if (this.skip = 0, a)\n          throw new Error(\"Ran out of text content when drawing inline views\");\n        if (o) {\n          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, e--;\n          continue;\n        } else\n          this.text = s, this.textOff = 0;\n      }\n      let i = Math.min(\n        this.text.length - this.textOff,\n        e,\n        512\n        /* T.Chunk */\n      );\n      this.flushBuffer(n.slice(n.length - r)), this.getLine().append(Pc(new hi(this.text.slice(this.textOff, this.textOff + i)), n), r), this.atCursorPos = !0, this.textOff += i, e -= i, r = 0;\n    }\n  }\n  span(e, n, r, i) {\n    this.buildText(n - e, r, i), this.pos = n, this.openStart < 0 && (this.openStart = i);\n  }\n  point(e, n, r, i, s, o) {\n    if (this.disallowBlockEffectsFor[o] && r instanceof as) {\n      if (r.block)\n        throw new RangeError(\"Block decorations may not be specified via plugins\");\n      if (n > this.doc.lineAt(this.pos).to)\n        throw new RangeError(\"Decorations that replace line breaks may not be specified via plugins\");\n    }\n    let a = n - e;\n    if (r instanceof as)\n      if (r.block)\n        r.startSide > 0 && !this.posCovered() && this.getLine(), this.addBlockWidget(new Ki(r.widget || new Gb(\"div\"), a, r));\n      else {\n        let l = Ps.create(r.widget || new Gb(\"span\"), a, a ? 0 : r.startSide), c = this.atCursorPos && !l.isEditable && s <= i.length && (e < n || r.startSide > 0), u = !l.isEditable && (e < n || s > i.length || r.startSide <= 0), d = this.getLine();\n        this.pendingBuffer == 2 && !c && !l.isEditable && (this.pendingBuffer = 0), this.flushBuffer(i), c && (d.append(Pc(new Bo(1), i), s), s = i.length + Math.max(0, s - i.length)), d.append(Pc(l, i), s), this.atCursorPos = u, this.pendingBuffer = u ? e < n || s > i.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = i.slice());\n      }\n    else\n      this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(r);\n    a && (this.textOff + a <= this.text.length ? this.textOff += a : (this.skip += a - (this.text.length - this.textOff), this.text = \"\", this.textOff = 0), this.pos = n), this.openStart < 0 && (this.openStart = s);\n  }\n  static build(e, n, r, i, s) {\n    let o = new Ha(e, n, r, s);\n    return o.openEnd = ze.spans(i, n, r, o), o.openStart < 0 && (o.openStart = o.openEnd), o.finish(o.openEnd), o;\n  }\n}\nfunction Pc(t, e) {\n  for (let n of e)\n    t = new pi(n, [t], t.length);\n  return t;\n}\nclass Gb extends ra {\n  constructor(e) {\n    super(), this.tag = e;\n  }\n  eq(e) {\n    return e.tag == this.tag;\n  }\n  toDOM() {\n    return document.createElement(this.tag);\n  }\n  updateDOM(e) {\n    return e.nodeName.toLowerCase() == this.tag;\n  }\n  get isHidden() {\n    return !0;\n  }\n}\nvar Qt = /* @__PURE__ */ function(t) {\n  return t[t.LTR = 0] = \"LTR\", t[t.RTL = 1] = \"RTL\", t;\n}(Qt || (Qt = {}));\nconst zs = Qt.LTR, lg = Qt.RTL;\nfunction dk(t) {\n  let e = [];\n  for (let n = 0; n < t.length; n++)\n    e.push(1 << +t[n]);\n  return e;\n}\nconst QN = /* @__PURE__ */ dk(\"88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008\"), CN = /* @__PURE__ */ dk(\"4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333\"), cp = /* @__PURE__ */ Object.create(null), wr = [];\nfor (let t of [\"()\", \"[]\", \"{}\"]) {\n  let e = /* @__PURE__ */ t.charCodeAt(0), n = /* @__PURE__ */ t.charCodeAt(1);\n  cp[e] = n, cp[n] = -e;\n}\nfunction fk(t) {\n  return t <= 247 ? QN[t] : 1424 <= t && t <= 1524 ? 2 : 1536 <= t && t <= 1785 ? CN[t - 1536] : 1774 <= t && t <= 2220 ? 4 : 8192 <= t && t <= 8204 ? 256 : 64336 <= t && t <= 65023 ? 4 : 1;\n}\nconst AN = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac\\ufb50-\\ufdff]/;\nclass Bi {\n  /**\n  The direction of this span.\n  */\n  get dir() {\n    return this.level % 2 ? lg : zs;\n  }\n  /**\n  @internal\n  */\n  constructor(e, n, r) {\n    this.from = e, this.to = n, this.level = r;\n  }\n  /**\n  @internal\n  */\n  side(e, n) {\n    return this.dir == n == e ? this.to : this.from;\n  }\n  /**\n  @internal\n  */\n  forward(e, n) {\n    return e == (this.dir == n);\n  }\n  /**\n  @internal\n  */\n  static find(e, n, r, i) {\n    let s = -1;\n    for (let o = 0; o < e.length; o++) {\n      let a = e[o];\n      if (a.from <= n && a.to >= n) {\n        if (a.level == r)\n          return o;\n        (s < 0 || (i != 0 ? i < 0 ? a.from < n : a.to > n : e[s].level > a.level)) && (s = o);\n      }\n    }\n    if (s < 0)\n      throw new RangeError(\"Index out of range\");\n    return s;\n  }\n}\nfunction hk(t, e) {\n  if (t.length != e.length)\n    return !1;\n  for (let n = 0; n < t.length; n++) {\n    let r = t[n], i = e[n];\n    if (r.from != i.from || r.to != i.to || r.direction != i.direction || !hk(r.inner, i.inner))\n      return !1;\n  }\n  return !0;\n}\nconst rt = [];\nfunction RN(t, e, n, r, i) {\n  for (let s = 0; s <= r.length; s++) {\n    let o = s ? r[s - 1].to : e, a = s < r.length ? r[s].from : n, l = s ? 256 : i;\n    for (let c = o, u = l, d = l; c < a; c++) {\n      let f = fk(t.charCodeAt(c));\n      f == 512 ? f = u : f == 8 && d == 4 && (f = 16), rt[c] = f == 4 ? 2 : f, f & 7 && (d = f), u = f;\n    }\n    for (let c = o, u = l, d = l; c < a; c++) {\n      let f = rt[c];\n      if (f == 128)\n        c < a - 1 && u == rt[c + 1] && u & 24 ? f = rt[c] = u : rt[c] = 256;\n      else if (f == 64) {\n        let h = c + 1;\n        for (; h < a && rt[h] == 64; )\n          h++;\n        let p = c && u == 8 || h < n && rt[h] == 8 ? d == 1 ? 1 : 8 : 256;\n        for (let O = c; O < h; O++)\n          rt[O] = p;\n        c = h - 1;\n      } else\n        f == 8 && d == 1 && (rt[c] = 1);\n      u = f, f & 7 && (d = f);\n    }\n  }\n}\nfunction NN(t, e, n, r, i) {\n  let s = i == 1 ? 2 : 1;\n  for (let o = 0, a = 0, l = 0; o <= r.length; o++) {\n    let c = o ? r[o - 1].to : e, u = o < r.length ? r[o].from : n;\n    for (let d = c, f, h, p; d < u; d++)\n      if (h = cp[f = t.charCodeAt(d)])\n        if (h < 0) {\n          for (let O = a - 3; O >= 0; O -= 3)\n            if (wr[O + 1] == -h) {\n              let m = wr[O + 2], y = m & 2 ? i : m & 4 ? m & 1 ? s : i : 0;\n              y && (rt[d] = rt[wr[O]] = y), a = O;\n              break;\n            }\n        } else {\n          if (wr.length == 189)\n            break;\n          wr[a++] = d, wr[a++] = f, wr[a++] = l;\n        }\n      else if ((p = rt[d]) == 2 || p == 1) {\n        let O = p == i;\n        l = O ? 0 : 1;\n        for (let m = a - 3; m >= 0; m -= 3) {\n          let y = wr[m + 2];\n          if (y & 2)\n            break;\n          if (O)\n            wr[m + 2] |= 2;\n          else {\n            if (y & 4)\n              break;\n            wr[m + 2] |= 4;\n          }\n        }\n      }\n  }\n}\nfunction DN(t, e, n, r) {\n  for (let i = 0, s = r; i <= n.length; i++) {\n    let o = i ? n[i - 1].to : t, a = i < n.length ? n[i].from : e;\n    for (let l = o; l < a; ) {\n      let c = rt[l];\n      if (c == 256) {\n        let u = l + 1;\n        for (; ; )\n          if (u == a) {\n            if (i == n.length)\n              break;\n            u = n[i++].to, a = i < n.length ? n[i].from : e;\n          } else if (rt[u] == 256)\n            u++;\n          else\n            break;\n        let d = s == 1, f = (u < e ? rt[u] : r) == 1, h = d == f ? d ? 1 : 2 : r;\n        for (let p = u, O = i, m = O ? n[O - 1].to : t; p > l; )\n          p == m && (p = n[--O].from, m = O ? n[O - 1].to : t), rt[--p] = h;\n        l = u;\n      } else\n        s = c, l++;\n    }\n  }\n}\nfunction up(t, e, n, r, i, s, o) {\n  let a = r % 2 ? 2 : 1;\n  if (r % 2 == i % 2)\n    for (let l = e, c = 0; l < n; ) {\n      let u = !0, d = !1;\n      if (c == s.length || l < s[c].from) {\n        let O = rt[l];\n        O != a && (u = !1, d = O == 16);\n      }\n      let f = !u && a == 1 ? [] : null, h = u ? r : r + 1, p = l;\n      e:\n        for (; ; )\n          if (c < s.length && p == s[c].from) {\n            if (d)\n              break e;\n            let O = s[c];\n            if (!u)\n              for (let m = O.to, y = c + 1; ; ) {\n                if (m == n)\n                  break e;\n                if (y < s.length && s[y].from == m)\n                  m = s[y++].to;\n                else {\n                  if (rt[m] == a)\n                    break e;\n                  break;\n                }\n              }\n            if (c++, f)\n              f.push(O);\n            else {\n              O.from > l && o.push(new Bi(l, O.from, h));\n              let m = O.direction == zs != !(h % 2);\n              dp(t, m ? r + 1 : r, i, O.inner, O.from, O.to, o), l = O.to;\n            }\n            p = O.to;\n          } else {\n            if (p == n || (u ? rt[p] != a : rt[p] == a))\n              break;\n            p++;\n          }\n      f ? up(t, l, p, r + 1, i, f, o) : l < p && o.push(new Bi(l, p, h)), l = p;\n    }\n  else\n    for (let l = n, c = s.length; l > e; ) {\n      let u = !0, d = !1;\n      if (!c || l > s[c - 1].to) {\n        let O = rt[l - 1];\n        O != a && (u = !1, d = O == 16);\n      }\n      let f = !u && a == 1 ? [] : null, h = u ? r : r + 1, p = l;\n      e:\n        for (; ; )\n          if (c && p == s[c - 1].to) {\n            if (d)\n              break e;\n            let O = s[--c];\n            if (!u)\n              for (let m = O.from, y = c; ; ) {\n                if (m == e)\n                  break e;\n                if (y && s[y - 1].to == m)\n                  m = s[--y].from;\n                else {\n                  if (rt[m - 1] == a)\n                    break e;\n                  break;\n                }\n              }\n            if (f)\n              f.push(O);\n            else {\n              O.to < l && o.push(new Bi(O.to, l, h));\n              let m = O.direction == zs != !(h % 2);\n              dp(t, m ? r + 1 : r, i, O.inner, O.from, O.to, o), l = O.from;\n            }\n            p = O.from;\n          } else {\n            if (p == e || (u ? rt[p - 1] != a : rt[p - 1] == a))\n              break;\n            p--;\n          }\n      f ? up(t, p, l, r + 1, i, f, o) : p < l && o.push(new Bi(p, l, h)), l = p;\n    }\n}\nfunction dp(t, e, n, r, i, s, o) {\n  let a = e % 2 ? 2 : 1;\n  RN(t, i, s, r, a), NN(t, i, s, r, a), DN(i, s, r, a), up(t, i, s, e, n, r, o);\n}\nfunction ZN(t, e, n) {\n  if (!t)\n    return [new Bi(0, 0, e == lg ? 1 : 0)];\n  if (e == zs && !n.length && !AN.test(t))\n    return pk(t.length);\n  if (n.length)\n    for (; t.length > rt.length; )\n      rt[rt.length] = 256;\n  let r = [], i = e == zs ? 0 : 1;\n  return dp(t, i, i, n, 0, t.length, r), r;\n}\nfunction pk(t) {\n  return [new Bi(0, t, 0)];\n}\nlet Ok = \"\";\nfunction VN(t, e, n, r, i) {\n  var s;\n  let o = r.head - t.from, a = Bi.find(e, o, (s = r.bidiLevel) !== null && s !== void 0 ? s : -1, r.assoc), l = e[a], c = l.side(i, n);\n  if (o == c) {\n    let f = a += i ? 1 : -1;\n    if (f < 0 || f >= e.length)\n      return null;\n    l = e[a = f], o = l.side(!i, n), c = l.side(i, n);\n  }\n  let u = Rr(t.text, o, l.forward(i, n));\n  (u < l.from || u > l.to) && (u = c), Ok = t.text.slice(Math.min(o, u), Math.max(o, u));\n  let d = a == (i ? e.length - 1 : 0) ? null : e[a + (i ? 1 : -1)];\n  return d && u == c && d.level + (i ? 0 : 1) < l.level ? ae.cursor(d.side(!i, n) + t.from, d.forward(i, n) ? 1 : -1, d.level) : ae.cursor(u + t.from, l.forward(i, n) ? -1 : 1, l.level);\n}\nfunction IN(t, e, n) {\n  for (let r = e; r < n; r++) {\n    let i = fk(t.charCodeAt(r));\n    if (i == 1)\n      return zs;\n    if (i == 2 || i == 4)\n      return lg;\n  }\n  return zs;\n}\nconst gk = /* @__PURE__ */ ve.define(), mk = /* @__PURE__ */ ve.define(), bk = /* @__PURE__ */ ve.define(), vk = /* @__PURE__ */ ve.define(), fp = /* @__PURE__ */ ve.define(), yk = /* @__PURE__ */ ve.define(), Sk = /* @__PURE__ */ ve.define(), wk = /* @__PURE__ */ ve.define({\n  combine: (t) => t.some((e) => e)\n}), WN = /* @__PURE__ */ ve.define({\n  combine: (t) => t.some((e) => e)\n});\nclass Eo {\n  constructor(e, n = \"nearest\", r = \"nearest\", i = 5, s = 5, o = !1) {\n    this.range = e, this.y = n, this.x = r, this.yMargin = i, this.xMargin = s, this.isSnapshot = o;\n  }\n  map(e) {\n    return e.empty ? this : new Eo(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);\n  }\n  clip(e) {\n    return this.range.to <= e.doc.length ? this : new Eo(ae.cursor(e.doc.length), this.y, this.x, this.yMargin, this.xMargin, this.isSnapshot);\n  }\n}\nconst _c = /* @__PURE__ */ ot.define({ map: (t, e) => t.map(e) });\nfunction hr(t, e, n) {\n  let r = t.facet(vk);\n  r.length ? r[0](e) : window.onerror ? window.onerror(String(e), n, void 0, void 0, e) : n ? console.error(n + \":\", e) : console.error(e);\n}\nconst Yd = /* @__PURE__ */ ve.define({ combine: (t) => t.length ? t[0] : !0 });\nlet MN = 0;\nconst Ra = /* @__PURE__ */ ve.define();\nclass rr {\n  constructor(e, n, r, i, s) {\n    this.id = e, this.create = n, this.domEventHandlers = r, this.domEventObservers = i, this.extension = s(this);\n  }\n  /**\n  Define a plugin from a constructor function that creates the\n  plugin's value, given an editor view.\n  */\n  static define(e, n) {\n    const { eventHandlers: r, eventObservers: i, provide: s, decorations: o } = n || {};\n    return new rr(MN++, e, r, i, (a) => {\n      let l = [Ra.of(a)];\n      return o && l.push(ml.of((c) => {\n        let u = c.plugin(a);\n        return u ? o(u) : Je.none;\n      })), s && l.push(s(a)), l;\n    });\n  }\n  /**\n  Create a plugin for a class whose constructor takes a single\n  editor view as argument.\n  */\n  static fromClass(e, n) {\n    return rr.define((r) => new e(r), n);\n  }\n}\nclass Pf {\n  constructor(e) {\n    this.spec = e, this.mustUpdate = null, this.value = null;\n  }\n  update(e) {\n    if (this.value) {\n      if (this.mustUpdate) {\n        let n = this.mustUpdate;\n        if (this.mustUpdate = null, this.value.update)\n          try {\n            this.value.update(n);\n          } catch (r) {\n            if (hr(n.state, r, \"CodeMirror plugin crashed\"), this.value.destroy)\n              try {\n                this.value.destroy();\n              } catch {\n              }\n            this.deactivate();\n          }\n      }\n    } else if (this.spec)\n      try {\n        this.value = this.spec.create(e);\n      } catch (n) {\n        hr(e.state, n, \"CodeMirror plugin crashed\"), this.deactivate();\n      }\n    return this;\n  }\n  destroy(e) {\n    var n;\n    if (!((n = this.value) === null || n === void 0) && n.destroy)\n      try {\n        this.value.destroy();\n      } catch (r) {\n        hr(e.state, r, \"CodeMirror plugin crashed\");\n      }\n  }\n  deactivate() {\n    this.spec = this.value = null;\n  }\n}\nconst kk = /* @__PURE__ */ ve.define(), cg = /* @__PURE__ */ ve.define(), ml = /* @__PURE__ */ ve.define(), xk = /* @__PURE__ */ ve.define(), ug = /* @__PURE__ */ ve.define(), Pk = /* @__PURE__ */ ve.define();\nfunction Kb(t, e) {\n  let n = t.state.facet(Pk);\n  if (!n.length)\n    return n;\n  let r = n.map((s) => s instanceof Function ? s(t) : s), i = [];\n  return ze.spans(r, e.from, e.to, {\n    point() {\n    },\n    span(s, o, a, l) {\n      let c = s - e.from, u = o - e.from, d = i;\n      for (let f = a.length - 1; f >= 0; f--, l--) {\n        let h = a[f].spec.bidiIsolate, p;\n        if (h == null && (h = IN(e.text, c, u)), l > 0 && d.length && (p = d[d.length - 1]).to == c && p.direction == h)\n          p.to = u, d = p.inner;\n        else {\n          let O = { from: c, to: u, direction: h, inner: [] };\n          d.push(O), d = O.inner;\n        }\n      }\n    }\n  }), i;\n}\nconst _k = /* @__PURE__ */ ve.define();\nfunction Tk(t) {\n  let e = 0, n = 0, r = 0, i = 0;\n  for (let s of t.state.facet(_k)) {\n    let o = s(t);\n    o && (o.left != null && (e = Math.max(e, o.left)), o.right != null && (n = Math.max(n, o.right)), o.top != null && (r = Math.max(r, o.top)), o.bottom != null && (i = Math.max(i, o.bottom)));\n  }\n  return { left: e, right: n, top: r, bottom: i };\n}\nconst Na = /* @__PURE__ */ ve.define();\nclass tr {\n  constructor(e, n, r, i) {\n    this.fromA = e, this.toA = n, this.fromB = r, this.toB = i;\n  }\n  join(e) {\n    return new tr(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));\n  }\n  addToSet(e) {\n    let n = e.length, r = this;\n    for (; n > 0; n--) {\n      let i = e[n - 1];\n      if (!(i.fromA > r.toA)) {\n        if (i.toA < r.fromA)\n          break;\n        r = r.join(i), e.splice(n - 1, 1);\n      }\n    }\n    return e.splice(n, 0, r), e;\n  }\n  static extendWithRanges(e, n) {\n    if (n.length == 0)\n      return e;\n    let r = [];\n    for (let i = 0, s = 0, o = 0, a = 0; ; i++) {\n      let l = i == e.length ? null : e[i], c = o - a, u = l ? l.fromB : 1e9;\n      for (; s < n.length && n[s] < u; ) {\n        let d = n[s], f = n[s + 1], h = Math.max(a, d), p = Math.min(u, f);\n        if (h <= p && new tr(h + c, p + c, h, p).addToSet(r), f > u)\n          break;\n        s += 2;\n      }\n      if (!l)\n        return r;\n      new tr(l.fromA, l.toA, l.fromB, l.toB).addToSet(r), o = l.toA, a = l.toB;\n    }\n  }\n}\nclass Wu {\n  constructor(e, n, r) {\n    this.view = e, this.state = n, this.transactions = r, this.flags = 0, this.startState = e.state, this.changes = Mt.empty(this.startState.doc.length);\n    for (let s of r)\n      this.changes = this.changes.compose(s.changes);\n    let i = [];\n    this.changes.iterChangedRanges((s, o, a, l) => i.push(new tr(s, o, a, l))), this.changedRanges = i;\n  }\n  /**\n  @internal\n  */\n  static create(e, n, r) {\n    return new Wu(e, n, r);\n  }\n  /**\n  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or\n  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this\n  update.\n  */\n  get viewportChanged() {\n    return (this.flags & 4) > 0;\n  }\n  /**\n  Indicates whether the height of a block element in the editor\n  changed in this update.\n  */\n  get heightChanged() {\n    return (this.flags & 2) > 0;\n  }\n  /**\n  Returns true when the document was modified or the size of the\n  editor, or elements within the editor, changed.\n  */\n  get geometryChanged() {\n    return this.docChanged || (this.flags & 10) > 0;\n  }\n  /**\n  True when this update indicates a focus change.\n  */\n  get focusChanged() {\n    return (this.flags & 1) > 0;\n  }\n  /**\n  Whether the document changed in this update.\n  */\n  get docChanged() {\n    return !this.changes.empty;\n  }\n  /**\n  Whether the selection was explicitly set in this update.\n  */\n  get selectionSet() {\n    return this.transactions.some((e) => e.selection);\n  }\n  /**\n  @internal\n  */\n  get empty() {\n    return this.flags == 0 && this.transactions.length == 0;\n  }\n}\nclass Jb extends ft {\n  get length() {\n    return this.view.state.doc.length;\n  }\n  constructor(e) {\n    super(), this.view = e, this.decorations = [], this.dynamicDecorationMap = [], this.domChanged = null, this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new Nt()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new tr(0, 0, 0, e.state.doc.length)], 0, null);\n  }\n  // Update the document view to a given state.\n  update(e) {\n    var n;\n    let r = e.changedRanges;\n    this.minWidth > 0 && r.length && (r.every(({ fromA: c, toA: u }) => u < this.minWidthFrom || c > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0);\n    let i = -1;\n    this.view.inputState.composing >= 0 && (!((n = this.domChanged) === null || n === void 0) && n.newSel ? i = this.domChanged.newSel.head : !YN(e.changes, this.hasComposition) && !e.selectionSet && (i = e.state.selection.main.head));\n    let s = i > -1 ? jN(this.view, e.changes, i) : null;\n    if (this.domChanged = null, this.hasComposition) {\n      this.markedForComposition.clear();\n      let { from: c, to: u } = this.hasComposition;\n      r = new tr(c, u, e.changes.mapPos(c, -1), e.changes.mapPos(u, 1)).addToSet(r.slice());\n    }\n    this.hasComposition = s ? { from: s.range.fromB, to: s.range.toB } : null, (de.ie || de.chrome) && !s && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);\n    let o = this.decorations, a = this.updateDeco(), l = UN(o, a, e.changes);\n    return r = tr.extendWithRanges(r, l), !(this.flags & 7) && r.length == 0 ? !1 : (this.updateInner(r, e.startState.doc.length, s), e.transactions.length && (this.lastUpdate = Date.now()), !0);\n  }\n  // Used by update and the constructor do perform the actual DOM\n  // update\n  updateInner(e, n, r) {\n    this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, n, r);\n    let { observer: i } = this.view;\n    i.ignore(() => {\n      this.dom.style.height = this.view.viewState.contentHeight / this.view.scaleY + \"px\", this.dom.style.flexBasis = this.minWidth ? this.minWidth + \"px\" : \"\";\n      let o = de.chrome || de.ios ? { node: i.selectionRange.focusNode, written: !1 } : void 0;\n      this.sync(this.view, o), this.flags &= -8, o && (o.written || i.selectionRange.focusNode != o.node) && (this.forceSelection = !0), this.dom.style.height = \"\";\n    }), this.markedForComposition.forEach(\n      (o) => o.flags &= -9\n      /* ViewFlag.Composition */\n    );\n    let s = [];\n    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)\n      for (let o of this.children)\n        o instanceof Ki && o.widget instanceof ev && s.push(o.dom);\n    i.updateGaps(s);\n  }\n  updateChildren(e, n, r) {\n    let i = r ? r.range.addToSet(e.slice()) : e, s = this.childCursor(n);\n    for (let o = i.length - 1; ; o--) {\n      let a = o >= 0 ? i[o] : null;\n      if (!a)\n        break;\n      let { fromA: l, toA: c, fromB: u, toB: d } = a, f, h, p, O;\n      if (r && r.range.fromB < d && r.range.toB > u) {\n        let v = Ha.build(this.view.state.doc, u, r.range.fromB, this.decorations, this.dynamicDecorationMap), S = Ha.build(this.view.state.doc, r.range.toB, d, this.decorations, this.dynamicDecorationMap);\n        h = v.breakAtStart, p = v.openStart, O = S.openEnd;\n        let w = this.compositionView(r);\n        S.breakAtStart ? w.breakAfter = 1 : S.content.length && w.merge(w.length, w.length, S.content[0], !1, S.openStart, 0) && (w.breakAfter = S.content[0].breakAfter, S.content.shift()), v.content.length && w.merge(0, 0, v.content[v.content.length - 1], !0, 0, v.openEnd) && v.content.pop(), f = v.content.concat(w).concat(S.content);\n      } else\n        ({ content: f, breakAtStart: h, openStart: p, openEnd: O } = Ha.build(this.view.state.doc, u, d, this.decorations, this.dynamicDecorationMap));\n      let { i: m, off: y } = s.findPos(c, 1), { i: b, off: g } = s.findPos(l, -1);\n      rk(this, b, g, m, y, f, h, p, O);\n    }\n    r && this.fixCompositionDOM(r);\n  }\n  compositionView(e) {\n    let n = new hi(e.text.nodeValue);\n    n.flags |= 8;\n    for (let { deco: i } of e.marks)\n      n = new pi(i, [n], n.length);\n    let r = new Nt();\n    return r.append(n, 0), r;\n  }\n  fixCompositionDOM(e) {\n    let n = (s, o) => {\n      o.flags |= 8 | (o.children.some(\n        (l) => l.flags & 7\n        /* ViewFlag.Dirty */\n      ) ? 1 : 0), this.markedForComposition.add(o);\n      let a = ft.get(s);\n      a && a != o && (a.dom = null), o.setDOM(s);\n    }, r = this.childPos(e.range.fromB, 1), i = this.children[r.i];\n    n(e.line, i);\n    for (let s = e.marks.length - 1; s >= -1; s--)\n      r = i.childPos(r.off, 1), i = i.children[r.i], n(s >= 0 ? e.marks[s].node : e.text, i);\n  }\n  // Sync the DOM selection to this.state.selection\n  updateSelection(e = !1, n = !1) {\n    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();\n    let r = this.view.root.activeElement, i = r == this.dom, s = !i && ru(this.dom, this.view.observer.selectionRange) && !(r && this.dom.contains(r));\n    if (!(i || n || s))\n      return;\n    let o = this.forceSelection;\n    this.forceSelection = !1;\n    let a = this.view.state.selection.main, l = this.moveToLine(this.domAtPos(a.anchor)), c = a.empty ? l : this.moveToLine(this.domAtPos(a.head));\n    if (de.gecko && a.empty && !this.hasComposition && XN(l)) {\n      let d = document.createTextNode(\"\");\n      this.view.observer.ignore(() => l.node.insertBefore(d, l.node.childNodes[l.offset] || null)), l = c = new an(d, 0), o = !0;\n    }\n    let u = this.view.observer.selectionRange;\n    (o || !u.focusNode || (!za(l.node, l.offset, u.anchorNode, u.anchorOffset) || !za(c.node, c.offset, u.focusNode, u.focusOffset)) && !this.suppressWidgetCursorChange(u, a)) && (this.view.observer.ignore(() => {\n      de.android && de.chrome && this.dom.contains(u.focusNode) && qN(u.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));\n      let d = Iu(this.view.root);\n      if (d)\n        if (a.empty) {\n          if (de.gecko) {\n            let f = BN(l.node, l.offset);\n            if (f && f != 3) {\n              let h = $k(l.node, l.offset, f == 1 ? 1 : -1);\n              h && (l = new an(h.node, h.offset));\n            }\n          }\n          d.collapse(l.node, l.offset), a.bidiLevel != null && d.caretBidiLevel !== void 0 && (d.caretBidiLevel = a.bidiLevel);\n        } else if (d.extend) {\n          d.collapse(l.node, l.offset);\n          try {\n            d.extend(c.node, c.offset);\n          } catch {\n          }\n        } else {\n          let f = document.createRange();\n          a.anchor > a.head && ([l, c] = [c, l]), f.setEnd(c.node, c.offset), f.setStart(l.node, l.offset), d.removeAllRanges(), d.addRange(f);\n        }\n      s && this.view.root.activeElement == this.dom && (this.dom.blur(), r && r.focus());\n    }), this.view.observer.setSelectionRange(l, c)), this.impreciseAnchor = l.precise ? null : new an(u.anchorNode, u.anchorOffset), this.impreciseHead = c.precise ? null : new an(u.focusNode, u.focusOffset);\n  }\n  // If a zero-length widget is inserted next to the cursor during\n  // composition, avoid moving it across it and disrupting the\n  // composition.\n  suppressWidgetCursorChange(e, n) {\n    return this.hasComposition && n.empty && za(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) && this.posFromDOM(e.focusNode, e.focusOffset) == n.head;\n  }\n  enforceCursorAssoc() {\n    if (this.hasComposition)\n      return;\n    let { view: e } = this, n = e.state.selection.main, r = Iu(e.root), { anchorNode: i, anchorOffset: s } = e.observer.selectionRange;\n    if (!r || !n.empty || !n.assoc || !r.modify)\n      return;\n    let o = Nt.find(this, n.head);\n    if (!o)\n      return;\n    let a = o.posAtStart;\n    if (n.head == a || n.head == a + o.length)\n      return;\n    let l = this.coordsAt(n.head, -1), c = this.coordsAt(n.head, 1);\n    if (!l || !c || l.bottom > c.top)\n      return;\n    let u = this.domAtPos(n.head + n.assoc);\n    r.collapse(u.node, u.offset), r.modify(\"move\", n.assoc < 0 ? \"forward\" : \"backward\", \"lineboundary\"), e.observer.readSelectionRange();\n    let d = e.observer.selectionRange;\n    e.docView.posFromDOM(d.anchorNode, d.anchorOffset) != n.from && r.collapse(i, s);\n  }\n  // If a position is in/near a block widget, move it to a nearby text\n  // line, since we don't want the cursor inside a block widget.\n  moveToLine(e) {\n    let n = this.dom, r;\n    if (e.node != n)\n      return e;\n    for (let i = e.offset; !r && i < n.childNodes.length; i++) {\n      let s = ft.get(n.childNodes[i]);\n      s instanceof Nt && (r = s.domAtPos(0));\n    }\n    for (let i = e.offset - 1; !r && i >= 0; i--) {\n      let s = ft.get(n.childNodes[i]);\n      s instanceof Nt && (r = s.domAtPos(s.length));\n    }\n    return r ? new an(r.node, r.offset, !0) : e;\n  }\n  nearest(e) {\n    for (let n = e; n; ) {\n      let r = ft.get(n);\n      if (r && r.rootView == this)\n        return r;\n      n = n.parentNode;\n    }\n    return null;\n  }\n  posFromDOM(e, n) {\n    let r = this.nearest(e);\n    if (!r)\n      throw new RangeError(\"Trying to find position for a DOM position outside of the document\");\n    return r.localPosFromDOM(e, n) + r.posAtStart;\n  }\n  domAtPos(e) {\n    let { i: n, off: r } = this.childCursor().findPos(e, -1);\n    for (; n < this.children.length - 1; ) {\n      let i = this.children[n];\n      if (r < i.length || i instanceof Nt)\n        break;\n      n++, r = 0;\n    }\n    return this.children[n].domAtPos(r);\n  }\n  coordsAt(e, n) {\n    let r = null, i = 0;\n    for (let s = this.length, o = this.children.length - 1; o >= 0; o--) {\n      let a = this.children[o], l = s - a.breakAfter, c = l - a.length;\n      if (l < e)\n        break;\n      c <= e && (c < e || a.covers(-1)) && (l > e || a.covers(1)) && (!r || a instanceof Nt && !(r instanceof Nt && n >= 0)) && (r = a, i = c), s = c;\n    }\n    return r ? r.coordsAt(e - i, n) : null;\n  }\n  coordsForChar(e) {\n    let { i: n, off: r } = this.childPos(e, 1), i = this.children[n];\n    if (!(i instanceof Nt))\n      return null;\n    for (; i.children.length; ) {\n      let { i: a, off: l } = i.childPos(r, 1);\n      for (; ; a++) {\n        if (a == i.children.length)\n          return null;\n        if ((i = i.children[a]).length)\n          break;\n      }\n      r = l;\n    }\n    if (!(i instanceof hi))\n      return null;\n    let s = Rr(i.text, r);\n    if (s == r)\n      return null;\n    let o = Ys(i.dom, r, s).getClientRects();\n    for (let a = 0; a < o.length; a++) {\n      let l = o[a];\n      if (a == o.length - 1 || l.top < l.bottom && l.left < l.right)\n        return l;\n    }\n    return null;\n  }\n  measureVisibleLineHeights(e) {\n    let n = [], { from: r, to: i } = e, s = this.view.contentDOM.clientWidth, o = s > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, a = -1, l = this.view.textDirection == Qt.LTR;\n    for (let c = 0, u = 0; u < this.children.length; u++) {\n      let d = this.children[u], f = c + d.length;\n      if (f > i)\n        break;\n      if (c >= r) {\n        let h = d.dom.getBoundingClientRect();\n        if (n.push(h.height), o) {\n          let p = d.dom.lastChild, O = p ? Ol(p) : [];\n          if (O.length) {\n            let m = O[O.length - 1], y = l ? m.right - h.left : h.right - m.left;\n            y > a && (a = y, this.minWidth = s, this.minWidthFrom = c, this.minWidthTo = f);\n          }\n        }\n      }\n      c = f + d.breakAfter;\n    }\n    return n;\n  }\n  textDirectionAt(e) {\n    let { i: n } = this.childPos(e, 1);\n    return getComputedStyle(this.children[n].dom).direction == \"rtl\" ? Qt.RTL : Qt.LTR;\n  }\n  measureTextSize() {\n    for (let s of this.children)\n      if (s instanceof Nt) {\n        let o = s.measureTextSize();\n        if (o)\n          return o;\n      }\n    let e = document.createElement(\"div\"), n, r, i;\n    return e.className = \"cm-line\", e.style.width = \"99999px\", e.style.position = \"absolute\", e.textContent = \"abc def ghi jkl mno pqr stu\", this.view.observer.ignore(() => {\n      this.dom.appendChild(e);\n      let s = Ol(e.firstChild)[0];\n      n = e.getBoundingClientRect().height, r = s ? s.width / 27 : 7, i = s ? s.height : n, e.remove();\n    }), { lineHeight: n, charWidth: r, textHeight: i };\n  }\n  childCursor(e = this.length) {\n    let n = this.children.length;\n    return n && (e -= this.children[--n].length), new nk(this.children, e, n);\n  }\n  computeBlockGapDeco() {\n    let e = [], n = this.view.viewState;\n    for (let r = 0, i = 0; ; i++) {\n      let s = i == n.viewports.length ? null : n.viewports[i], o = s ? s.from - 1 : this.length;\n      if (o > r) {\n        let a = (n.lineBlockAt(o).bottom - n.lineBlockAt(r).top) / this.view.scaleY;\n        e.push(Je.replace({\n          widget: new ev(a),\n          block: !0,\n          inclusive: !0,\n          isBlockGap: !0\n        }).range(r, o));\n      }\n      if (!s)\n        break;\n      r = s.to + 1;\n    }\n    return Je.set(e);\n  }\n  updateDeco() {\n    let e = this.view.state.facet(ml).map((i, s) => (this.dynamicDecorationMap[s] = typeof i == \"function\") ? i(this.view) : i), n = !1, r = this.view.state.facet(xk).map((i, s) => {\n      let o = typeof i == \"function\";\n      return o && (n = !0), o ? i(this.view) : i;\n    });\n    r.length && (this.dynamicDecorationMap[e.length] = n, e.push(ze.join(r)));\n    for (let i = e.length; i < e.length + 3; i++)\n      this.dynamicDecorationMap[i] = !1;\n    return this.decorations = [\n      ...e,\n      this.computeBlockGapDeco(),\n      this.view.viewState.lineGapDeco\n    ];\n  }\n  scrollIntoView(e) {\n    if (e.isSnapshot) {\n      let c = this.view.viewState.lineBlockAt(e.range.head);\n      this.view.scrollDOM.scrollTop = c.top - e.yMargin, this.view.scrollDOM.scrollLeft = e.xMargin;\n      return;\n    }\n    let { range: n } = e, r = this.coordsAt(n.head, n.empty ? n.assoc : n.head > n.anchor ? -1 : 1), i;\n    if (!r)\n      return;\n    !n.empty && (i = this.coordsAt(n.anchor, n.anchor > n.head ? -1 : 1)) && (r = {\n      left: Math.min(r.left, i.left),\n      top: Math.min(r.top, i.top),\n      right: Math.max(r.right, i.right),\n      bottom: Math.max(r.bottom, i.bottom)\n    });\n    let s = Tk(this.view), o = {\n      left: r.left - s.left,\n      top: r.top - s.top,\n      right: r.right + s.right,\n      bottom: r.bottom + s.bottom\n    }, { offsetWidth: a, offsetHeight: l } = this.view.scrollDOM;\n    yN(this.view.scrollDOM, o, n.head < n.anchor ? -1 : 1, e.x, e.y, Math.max(Math.min(e.xMargin, a), -a), Math.max(Math.min(e.yMargin, l), -l), this.view.textDirection == Qt.LTR);\n  }\n}\nfunction XN(t) {\n  return t.node.nodeType == 1 && t.node.firstChild && (t.offset == 0 || t.node.childNodes[t.offset - 1].contentEditable == \"false\") && (t.offset == t.node.childNodes.length || t.node.childNodes[t.offset].contentEditable == \"false\");\n}\nclass ev extends ra {\n  constructor(e) {\n    super(), this.height = e;\n  }\n  toDOM() {\n    let e = document.createElement(\"div\");\n    return e.className = \"cm-gap\", this.updateDOM(e), e;\n  }\n  eq(e) {\n    return e.height == this.height;\n  }\n  updateDOM(e) {\n    return e.style.height = this.height + \"px\", !0;\n  }\n  get editable() {\n    return !0;\n  }\n  get estimatedHeight() {\n    return this.height;\n  }\n  ignoreEvent() {\n    return !1;\n  }\n}\nfunction Ek(t, e) {\n  let n = t.observer.selectionRange, r = n.focusNode && $k(n.focusNode, n.focusOffset, 0);\n  if (!r)\n    return null;\n  let i = e - r.offset;\n  return { from: i, to: i + r.node.nodeValue.length, node: r.node };\n}\nfunction jN(t, e, n) {\n  let r = Ek(t, n);\n  if (!r)\n    return null;\n  let { node: i, from: s, to: o } = r, a = i.nodeValue;\n  if (/[\\n\\r]/.test(a) || t.state.doc.sliceString(r.from, r.to) != a)\n    return null;\n  let l = e.invertedDesc, c = new tr(l.mapPos(s), l.mapPos(o), s, o), u = [];\n  for (let d = i.parentNode; ; d = d.parentNode) {\n    let f = ft.get(d);\n    if (f instanceof pi)\n      u.push({ node: d, deco: f.mark });\n    else {\n      if (f instanceof Nt || d.nodeName == \"DIV\" && d.parentNode == t.contentDOM)\n        return { range: c, text: i, marks: u, line: d };\n      if (d != t.contentDOM)\n        u.push({ node: d, deco: new Hl({\n          inclusive: !0,\n          attributes: EN(d),\n          tagName: d.tagName.toLowerCase()\n        }) });\n      else\n        return null;\n    }\n  }\n}\nfunction $k(t, e, n) {\n  if (n <= 0)\n    for (let r = t, i = e; ; ) {\n      if (r.nodeType == 3)\n        return { node: r, offset: i };\n      if (r.nodeType == 1 && i > 0)\n        r = r.childNodes[i - 1], i = fi(r);\n      else\n        break;\n    }\n  if (n >= 0)\n    for (let r = t, i = e; ; ) {\n      if (r.nodeType == 3)\n        return { node: r, offset: i };\n      if (r.nodeType == 1 && i < r.childNodes.length && n >= 0)\n        r = r.childNodes[i], i = 0;\n      else\n        break;\n    }\n  return null;\n}\nfunction BN(t, e) {\n  return t.nodeType != 1 ? 0 : (e && t.childNodes[e - 1].contentEditable == \"false\" ? 1 : 0) | (e < t.childNodes.length && t.childNodes[e].contentEditable == \"false\" ? 2 : 0);\n}\nlet LN = class {\n  constructor() {\n    this.changes = [];\n  }\n  compareRange(e, n) {\n    lp(e, n, this.changes);\n  }\n  comparePoint(e, n) {\n    lp(e, n, this.changes);\n  }\n};\nfunction UN(t, e, n) {\n  let r = new LN();\n  return ze.compare(t, e, n, r), r.changes;\n}\nfunction qN(t, e) {\n  for (let n = t; n && n != e; n = n.assignedSlot || n.parentNode)\n    if (n.nodeType == 1 && n.contentEditable == \"false\")\n      return !0;\n  return !1;\n}\nfunction YN(t, e) {\n  let n = !1;\n  return e && t.iterChangedRanges((r, i) => {\n    r < e.to && i > e.from && (n = !0);\n  }), n;\n}\nfunction zN(t, e, n = 1) {\n  let r = t.charCategorizer(e), i = t.doc.lineAt(e), s = e - i.from;\n  if (i.length == 0)\n    return ae.cursor(e);\n  s == 0 ? n = 1 : s == i.length && (n = -1);\n  let o = s, a = s;\n  n < 0 ? o = Rr(i.text, s, !1) : a = Rr(i.text, s);\n  let l = r(i.text.slice(o, a));\n  for (; o > 0; ) {\n    let c = Rr(i.text, o, !1);\n    if (r(i.text.slice(c, o)) != l)\n      break;\n    o = c;\n  }\n  for (; a < i.length; ) {\n    let c = Rr(i.text, a);\n    if (r(i.text.slice(a, c)) != l)\n      break;\n    a = c;\n  }\n  return ae.range(o + i.from, a + i.from);\n}\nfunction HN(t, e) {\n  return e.left > t ? e.left - t : Math.max(0, t - e.right);\n}\nfunction FN(t, e) {\n  return e.top > t ? e.top - t : Math.max(0, t - e.bottom);\n}\nfunction _f(t, e) {\n  return t.top < e.bottom - 1 && t.bottom > e.top + 1;\n}\nfunction tv(t, e) {\n  return e < t.top ? { top: e, left: t.left, right: t.right, bottom: t.bottom } : t;\n}\nfunction nv(t, e) {\n  return e > t.bottom ? { top: t.top, left: t.left, right: t.right, bottom: e } : t;\n}\nfunction hp(t, e, n) {\n  let r, i, s, o, a = !1, l, c, u, d;\n  for (let p = t.firstChild; p; p = p.nextSibling) {\n    let O = Ol(p);\n    for (let m = 0; m < O.length; m++) {\n      let y = O[m];\n      i && _f(i, y) && (y = tv(nv(y, i.bottom), i.top));\n      let b = HN(e, y), g = FN(n, y);\n      if (b == 0 && g == 0)\n        return p.nodeType == 3 ? rv(p, e, n) : hp(p, e, n);\n      if (!r || o > g || o == g && s > b) {\n        r = p, i = y, s = b, o = g;\n        let v = g ? n < y.top ? -1 : 1 : b ? e < y.left ? -1 : 1 : 0;\n        a = !v || (v > 0 ? m < O.length - 1 : m > 0);\n      }\n      b == 0 ? n > y.bottom && (!u || u.bottom < y.bottom) ? (l = p, u = y) : n < y.top && (!d || d.top > y.top) && (c = p, d = y) : u && _f(u, y) ? u = nv(u, y.bottom) : d && _f(d, y) && (d = tv(d, y.top));\n    }\n  }\n  if (u && u.bottom >= n ? (r = l, i = u) : d && d.top <= n && (r = c, i = d), !r)\n    return { node: t, offset: 0 };\n  let f = Math.max(i.left, Math.min(i.right, e));\n  if (r.nodeType == 3)\n    return rv(r, f, n);\n  if (a && r.contentEditable != \"false\")\n    return hp(r, f, n);\n  let h = Array.prototype.indexOf.call(t.childNodes, r) + (e >= (i.left + i.right) / 2 ? 1 : 0);\n  return { node: t, offset: h };\n}\nfunction rv(t, e, n) {\n  let r = t.nodeValue.length, i = -1, s = 1e9, o = 0;\n  for (let a = 0; a < r; a++) {\n    let l = Ys(t, a, a + 1).getClientRects();\n    for (let c = 0; c < l.length; c++) {\n      let u = l[c];\n      if (u.top == u.bottom)\n        continue;\n      o || (o = e - u.left);\n      let d = (u.top > n ? u.top - n : n - u.bottom) - 1;\n      if (u.left - 1 <= e && u.right + 1 >= e && d < s) {\n        let f = e >= (u.left + u.right) / 2, h = f;\n        if ((de.chrome || de.gecko) && Ys(t, a).getBoundingClientRect().left == u.right && (h = !f), d <= 0)\n          return { node: t, offset: a + (h ? 1 : 0) };\n        i = a + (h ? 1 : 0), s = d;\n      }\n    }\n  }\n  return { node: t, offset: i > -1 ? i : o > 0 ? t.nodeValue.length : 0 };\n}\nfunction Qk(t, e, n, r = -1) {\n  var i, s;\n  let o = t.contentDOM.getBoundingClientRect(), a = o.top + t.viewState.paddingTop, l, { docHeight: c } = t.viewState, { x: u, y: d } = e, f = d - a;\n  if (f < 0)\n    return 0;\n  if (f > c)\n    return t.state.doc.length;\n  for (let v = t.viewState.heightOracle.textHeight / 2, S = !1; l = t.elementAtHeight(f), l.type != fr.Text; )\n    for (; f = r > 0 ? l.bottom + v : l.top - v, !(f >= 0 && f <= c); ) {\n      if (S)\n        return n ? null : 0;\n      S = !0, r = -r;\n    }\n  d = a + f;\n  let h = l.from;\n  if (h < t.viewport.from)\n    return t.viewport.from == 0 ? 0 : n ? null : iv(t, o, l, u, d);\n  if (h > t.viewport.to)\n    return t.viewport.to == t.state.doc.length ? t.state.doc.length : n ? null : iv(t, o, l, u, d);\n  let p = t.dom.ownerDocument, O = t.root.elementFromPoint ? t.root : p, m = O.elementFromPoint(u, d);\n  m && !t.contentDOM.contains(m) && (m = null), m || (u = Math.max(o.left + 1, Math.min(o.right - 1, u)), m = O.elementFromPoint(u, d), m && !t.contentDOM.contains(m) && (m = null));\n  let y, b = -1;\n  if (m && ((i = t.docView.nearest(m)) === null || i === void 0 ? void 0 : i.isEditable) != !1) {\n    if (p.caretPositionFromPoint) {\n      let v = p.caretPositionFromPoint(u, d);\n      v && ({ offsetNode: y, offset: b } = v);\n    } else if (p.caretRangeFromPoint) {\n      let v = p.caretRangeFromPoint(u, d);\n      v && ({ startContainer: y, startOffset: b } = v, (!t.contentDOM.contains(y) || de.safari && GN(y, b, u) || de.chrome && KN(y, b, u)) && (y = void 0));\n    }\n  }\n  if (!y || !t.docView.dom.contains(y)) {\n    let v = Nt.find(t.docView, h);\n    if (!v)\n      return f > l.top + l.height / 2 ? l.to : l.from;\n    ({ node: y, offset: b } = hp(v.dom, u, d));\n  }\n  let g = t.docView.nearest(y);\n  if (!g)\n    return null;\n  if (g.isWidget && ((s = g.dom) === null || s === void 0 ? void 0 : s.nodeType) == 1) {\n    let v = g.dom.getBoundingClientRect();\n    return e.y < v.top || e.y <= v.bottom && e.x <= (v.left + v.right) / 2 ? g.posAtStart : g.posAtEnd;\n  } else\n    return g.localPosFromDOM(y, b) + g.posAtStart;\n}\nfunction iv(t, e, n, r, i) {\n  let s = Math.round((r - e.left) * t.defaultCharacterWidth);\n  if (t.lineWrapping && n.height > t.defaultLineHeight * 1.5) {\n    let a = t.viewState.heightOracle.textHeight, l = Math.floor((i - n.top - (t.defaultLineHeight - a) * 0.5) / a);\n    s += l * t.viewState.heightOracle.lineLength;\n  }\n  let o = t.state.sliceDoc(n.from, n.to);\n  return n.from + hN(o, s, t.state.tabSize);\n}\nfunction GN(t, e, n) {\n  let r;\n  if (t.nodeType != 3 || e != (r = t.nodeValue.length))\n    return !1;\n  for (let i = t.nextSibling; i; i = i.nextSibling)\n    if (i.nodeType != 1 || i.nodeName != \"BR\")\n      return !1;\n  return Ys(t, r - 1, r).getBoundingClientRect().left > n;\n}\nfunction KN(t, e, n) {\n  if (e != 0)\n    return !1;\n  for (let i = t; ; ) {\n    let s = i.parentNode;\n    if (!s || s.nodeType != 1 || s.firstChild != i)\n      return !1;\n    if (s.classList.contains(\"cm-line\"))\n      break;\n    i = s;\n  }\n  let r = t.nodeType == 1 ? t.getBoundingClientRect() : Ys(t, 0, Math.max(t.nodeValue.length, 1)).getBoundingClientRect();\n  return n - r.left > 5;\n}\nfunction JN(t, e) {\n  let n = t.lineBlockAt(e);\n  if (Array.isArray(n.type)) {\n    for (let r of n.type)\n      if (r.to > e || r.to == e && (r.to == n.to || r.type == fr.Text))\n        return r;\n  }\n  return n;\n}\nfunction e5(t, e, n, r) {\n  let i = JN(t, e.head), s = !r || i.type != fr.Text || !(t.lineWrapping || i.widgetLineBreaks) ? null : t.coordsAtPos(e.assoc < 0 && e.head > i.from ? e.head - 1 : e.head);\n  if (s) {\n    let o = t.dom.getBoundingClientRect(), a = t.textDirectionAt(i.from), l = t.posAtCoords({\n      x: n == (a == Qt.LTR) ? o.right - 1 : o.left + 1,\n      y: (s.top + s.bottom) / 2\n    });\n    if (l != null)\n      return ae.cursor(l, n ? -1 : 1);\n  }\n  return ae.cursor(n ? i.to : i.from, n ? -1 : 1);\n}\nfunction sv(t, e, n, r) {\n  let i = t.state.doc.lineAt(e.head), s = t.bidiSpans(i), o = t.textDirectionAt(i.from);\n  for (let a = e, l = null; ; ) {\n    let c = VN(i, s, o, a, n), u = Ok;\n    if (!c) {\n      if (i.number == (n ? t.state.doc.lines : 1))\n        return a;\n      u = `\n`, i = t.state.doc.line(i.number + (n ? 1 : -1)), s = t.bidiSpans(i), c = t.visualLineSide(i, !n);\n    }\n    if (l) {\n      if (!l(u))\n        return a;\n    } else {\n      if (!r)\n        return c;\n      l = r(u);\n    }\n    a = c;\n  }\n}\nfunction t5(t, e, n) {\n  let r = t.state.charCategorizer(e), i = r(n);\n  return (s) => {\n    let o = r(s);\n    return i == Hn.Space && (i = o), i == o;\n  };\n}\nfunction n5(t, e, n, r) {\n  let i = e.head, s = n ? 1 : -1;\n  if (i == (n ? t.state.doc.length : 0))\n    return ae.cursor(i, e.assoc);\n  let o = e.goalColumn, a, l = t.contentDOM.getBoundingClientRect(), c = t.coordsAtPos(i, e.assoc || -1), u = t.documentTop;\n  if (c)\n    o == null && (o = c.left - l.left), a = s < 0 ? c.top : c.bottom;\n  else {\n    let h = t.viewState.lineBlockAt(i);\n    o == null && (o = Math.min(l.right - l.left, t.defaultCharacterWidth * (i - h.from))), a = (s < 0 ? h.top : h.bottom) + u;\n  }\n  let d = l.left + o, f = r ?? t.viewState.heightOracle.textHeight >> 1;\n  for (let h = 0; ; h += 10) {\n    let p = a + (f + h) * s, O = Qk(t, { x: d, y: p }, !1, s);\n    if (p < l.top || p > l.bottom || (s < 0 ? O < i : O > i)) {\n      let m = t.docView.coordsForChar(O), y = !m || p < m.top ? -1 : 1;\n      return ae.cursor(O, y, void 0, o);\n    }\n  }\n}\nfunction iu(t, e, n) {\n  for (; ; ) {\n    let r = 0;\n    for (let i of t)\n      i.between(e - 1, e + 1, (s, o, a) => {\n        if (e > s && e < o) {\n          let l = r || n || (e - s < o - e ? -1 : 1);\n          e = l < 0 ? s : o, r = l;\n        }\n      });\n    if (!r)\n      return e;\n  }\n}\nfunction Tf(t, e, n) {\n  let r = iu(t.state.facet(ug).map((i) => i(t)), n.from, e.head > n.from ? -1 : 1);\n  return r == n.from ? n : ae.cursor(r, r < n.from ? 1 : -1);\n}\nclass r5 {\n  setSelectionOrigin(e) {\n    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();\n  }\n  constructor(e) {\n    this.view = e, this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.pendingIOSKey = void 0, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastEscPress = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.handlers = /* @__PURE__ */ Object.create(null), this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null, this.draggedContent = null, this.handleEvent = this.handleEvent.bind(this), this.notifiedFocused = e.hasFocus, de.safari && e.contentDOM.addEventListener(\"input\", () => null), de.gecko && v5(e.contentDOM.ownerDocument);\n  }\n  handleEvent(e) {\n    !d5(this.view, e) || this.ignoreDuringComposition(e) || e.type == \"keydown\" && this.keydown(e) || this.runHandlers(e.type, e);\n  }\n  runHandlers(e, n) {\n    let r = this.handlers[e];\n    if (r) {\n      for (let i of r.observers)\n        i(this.view, n);\n      for (let i of r.handlers) {\n        if (n.defaultPrevented)\n          break;\n        if (i(this.view, n)) {\n          n.preventDefault();\n          break;\n        }\n      }\n    }\n  }\n  ensureHandlers(e) {\n    let n = i5(e), r = this.handlers, i = this.view.contentDOM;\n    for (let s in n)\n      if (s != \"scroll\") {\n        let o = !n[s].handlers.length, a = r[s];\n        a && o != !a.handlers.length && (i.removeEventListener(s, this.handleEvent), a = null), a || i.addEventListener(s, this.handleEvent, { passive: o });\n      }\n    for (let s in r)\n      s != \"scroll\" && !n[s] && i.removeEventListener(s, this.handleEvent);\n    this.handlers = n;\n  }\n  keydown(e) {\n    if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), e.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)\n      return !0;\n    if (e.keyCode != 27 && Ak.indexOf(e.keyCode) < 0 && (this.view.inputState.lastEscPress = 0), de.android && de.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))\n      return this.view.observer.delayAndroidKey(e.key, e.keyCode), !0;\n    let n;\n    return de.ios && !e.synthetic && !e.altKey && !e.metaKey && ((n = Ck.find((r) => r.keyCode == e.keyCode)) && !e.ctrlKey || s5.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (this.pendingIOSKey = n || e, setTimeout(() => this.flushIOSKey(), 250), !0) : (e.keyCode != 229 && this.view.observer.forceFlush(), !1);\n  }\n  flushIOSKey() {\n    let e = this.pendingIOSKey;\n    return e ? (this.pendingIOSKey = void 0, To(this.view.contentDOM, e.key, e.keyCode)) : !1;\n  }\n  ignoreDuringComposition(e) {\n    return /^key/.test(e.type) ? this.composing > 0 ? !0 : de.safari && !de.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1;\n  }\n  startMouseSelection(e) {\n    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;\n  }\n  update(e) {\n    this.mouseSelection && this.mouseSelection.update(e), this.draggedContent && e.docChanged && (this.draggedContent = this.draggedContent.map(e.changes)), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);\n  }\n  destroy() {\n    this.mouseSelection && this.mouseSelection.destroy();\n  }\n}\nfunction ov(t, e) {\n  return (n, r) => {\n    try {\n      return e.call(t, r, n);\n    } catch (i) {\n      hr(n.state, i);\n    }\n  };\n}\nfunction i5(t) {\n  let e = /* @__PURE__ */ Object.create(null);\n  function n(r) {\n    return e[r] || (e[r] = { observers: [], handlers: [] });\n  }\n  for (let r of t) {\n    let i = r.spec;\n    if (i && i.domEventHandlers)\n      for (let s in i.domEventHandlers) {\n        let o = i.domEventHandlers[s];\n        o && n(s).handlers.push(ov(r.value, o));\n      }\n    if (i && i.domEventObservers)\n      for (let s in i.domEventObservers) {\n        let o = i.domEventObservers[s];\n        o && n(s).observers.push(ov(r.value, o));\n      }\n  }\n  for (let r in br)\n    n(r).handlers.push(br[r]);\n  for (let r in vr)\n    n(r).observers.push(vr[r]);\n  return e;\n}\nconst Ck = [\n  { key: \"Backspace\", keyCode: 8, inputType: \"deleteContentBackward\" },\n  { key: \"Enter\", keyCode: 13, inputType: \"insertParagraph\" },\n  { key: \"Enter\", keyCode: 13, inputType: \"insertLineBreak\" },\n  { key: \"Delete\", keyCode: 46, inputType: \"deleteContentForward\" }\n], s5 = \"dthko\", Ak = [16, 17, 18, 20, 91, 92, 224, 225], Tc = 6;\nfunction Ec(t) {\n  return Math.max(0, t) * 0.7 + 8;\n}\nfunction o5(t, e) {\n  return Math.max(Math.abs(t.clientX - e.clientX), Math.abs(t.clientY - e.clientY));\n}\nclass a5 {\n  constructor(e, n, r, i) {\n    this.view = e, this.startEvent = n, this.style = r, this.mustSelect = i, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = n, this.scrollParent = SN(e.contentDOM), this.atoms = e.state.facet(ug).map((o) => o(e));\n    let s = e.contentDOM.ownerDocument;\n    s.addEventListener(\"mousemove\", this.move = this.move.bind(this)), s.addEventListener(\"mouseup\", this.up = this.up.bind(this)), this.extend = n.shiftKey, this.multiple = e.state.facet(Ye.allowMultipleSelections) && l5(e, n), this.dragging = u5(e, n) && Zk(n) == 1 ? null : !1;\n  }\n  start(e) {\n    this.dragging === !1 && this.select(e);\n  }\n  move(e) {\n    var n;\n    if (e.buttons == 0)\n      return this.destroy();\n    if (this.dragging || this.dragging == null && o5(this.startEvent, e) < 10)\n      return;\n    this.select(this.lastEvent = e);\n    let r = 0, i = 0, s = ((n = this.scrollParent) === null || n === void 0 ? void 0 : n.getBoundingClientRect()) || { left: 0, top: 0, right: this.view.win.innerWidth, bottom: this.view.win.innerHeight }, o = Tk(this.view);\n    e.clientX - o.left <= s.left + Tc ? r = -Ec(s.left - e.clientX) : e.clientX + o.right >= s.right - Tc && (r = Ec(e.clientX - s.right)), e.clientY - o.top <= s.top + Tc ? i = -Ec(s.top - e.clientY) : e.clientY + o.bottom >= s.bottom - Tc && (i = Ec(e.clientY - s.bottom)), this.setScrollSpeed(r, i);\n  }\n  up(e) {\n    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();\n  }\n  destroy() {\n    this.setScrollSpeed(0, 0);\n    let e = this.view.contentDOM.ownerDocument;\n    e.removeEventListener(\"mousemove\", this.move), e.removeEventListener(\"mouseup\", this.up), this.view.inputState.mouseSelection = this.view.inputState.draggedContent = null;\n  }\n  setScrollSpeed(e, n) {\n    this.scrollSpeed = { x: e, y: n }, e || n ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);\n  }\n  scroll() {\n    this.scrollParent ? (this.scrollParent.scrollLeft += this.scrollSpeed.x, this.scrollParent.scrollTop += this.scrollSpeed.y) : this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y), this.dragging === !1 && this.select(this.lastEvent);\n  }\n  skipAtoms(e) {\n    let n = null;\n    for (let r = 0; r < e.ranges.length; r++) {\n      let i = e.ranges[r], s = null;\n      if (i.empty) {\n        let o = iu(this.atoms, i.from, 0);\n        o != i.from && (s = ae.cursor(o, -1));\n      } else {\n        let o = iu(this.atoms, i.from, -1), a = iu(this.atoms, i.to, 1);\n        (o != i.from || a != i.to) && (s = ae.range(i.from == i.anchor ? o : a, i.from == i.head ? o : a));\n      }\n      s && (n || (n = e.ranges.slice()), n[r] = s);\n    }\n    return n ? ae.create(n, e.mainIndex) : e;\n  }\n  select(e) {\n    let { view: n } = this, r = this.skipAtoms(this.style.get(e, this.extend, this.multiple));\n    (this.mustSelect || !r.eq(n.state.selection, this.dragging === !1)) && this.view.dispatch({\n      selection: r,\n      userEvent: \"select.pointer\"\n    }), this.mustSelect = !1;\n  }\n  update(e) {\n    this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);\n  }\n}\nfunction l5(t, e) {\n  let n = t.state.facet(gk);\n  return n.length ? n[0](e) : de.mac ? e.metaKey : e.ctrlKey;\n}\nfunction c5(t, e) {\n  let n = t.state.facet(mk);\n  return n.length ? n[0](e) : de.mac ? !e.altKey : !e.ctrlKey;\n}\nfunction u5(t, e) {\n  let { main: n } = t.state.selection;\n  if (n.empty)\n    return !1;\n  let r = Iu(t.root);\n  if (!r || r.rangeCount == 0)\n    return !0;\n  let i = r.getRangeAt(0).getClientRects();\n  for (let s = 0; s < i.length; s++) {\n    let o = i[s];\n    if (o.left <= e.clientX && o.right >= e.clientX && o.top <= e.clientY && o.bottom >= e.clientY)\n      return !0;\n  }\n  return !1;\n}\nfunction d5(t, e) {\n  if (!e.bubbles)\n    return !0;\n  if (e.defaultPrevented)\n    return !1;\n  for (let n = e.target, r; n != t.contentDOM; n = n.parentNode)\n    if (!n || n.nodeType == 11 || (r = ft.get(n)) && r.ignoreEvent(e))\n      return !1;\n  return !0;\n}\nconst br = /* @__PURE__ */ Object.create(null), vr = /* @__PURE__ */ Object.create(null), Rk = de.ie && de.ie_version < 15 || de.ios && de.webkit_version < 604;\nfunction f5(t) {\n  let e = t.dom.parentNode;\n  if (!e)\n    return;\n  let n = e.appendChild(document.createElement(\"textarea\"));\n  n.style.cssText = \"position: fixed; left: -10000px; top: 10px\", n.focus(), setTimeout(() => {\n    t.focus(), n.remove(), Nk(t, n.value);\n  }, 50);\n}\nfunction Nk(t, e) {\n  let { state: n } = t, r, i = 1, s = n.toText(e), o = s.lines == n.selection.ranges.length;\n  if (pp != null && n.selection.ranges.every((l) => l.empty) && pp == s.toString()) {\n    let l = -1;\n    r = n.changeByRange((c) => {\n      let u = n.doc.lineAt(c.from);\n      if (u.from == l)\n        return { range: c };\n      l = u.from;\n      let d = n.toText((o ? s.line(i++).text : e) + n.lineBreak);\n      return {\n        changes: { from: u.from, insert: d },\n        range: ae.cursor(c.from + d.length)\n      };\n    });\n  } else\n    o ? r = n.changeByRange((l) => {\n      let c = s.line(i++);\n      return {\n        changes: { from: l.from, to: l.to, insert: c.text },\n        range: ae.cursor(l.from + c.length)\n      };\n    }) : r = n.replaceSelection(s);\n  t.dispatch(r, {\n    userEvent: \"input.paste\",\n    scrollIntoView: !0\n  });\n}\nvr.scroll = (t) => {\n  t.inputState.lastScrollTop = t.scrollDOM.scrollTop, t.inputState.lastScrollLeft = t.scrollDOM.scrollLeft;\n};\nbr.keydown = (t, e) => (t.inputState.setSelectionOrigin(\"select\"), e.keyCode == 27 && (t.inputState.lastEscPress = Date.now()), !1);\nvr.touchstart = (t, e) => {\n  t.inputState.lastTouchTime = Date.now(), t.inputState.setSelectionOrigin(\"select.pointer\");\n};\nvr.touchmove = (t) => {\n  t.inputState.setSelectionOrigin(\"select.pointer\");\n};\nbr.mousedown = (t, e) => {\n  if (t.observer.flush(), t.inputState.lastTouchTime > Date.now() - 2e3)\n    return !1;\n  let n = null;\n  for (let r of t.state.facet(bk))\n    if (n = r(t, e), n)\n      break;\n  if (!n && e.button == 0 && (n = O5(t, e)), n) {\n    let r = !t.hasFocus;\n    t.inputState.startMouseSelection(new a5(t, e, n, r)), r && t.observer.ignore(() => Jw(t.contentDOM));\n    let i = t.inputState.mouseSelection;\n    if (i)\n      return i.start(e), i.dragging === !1;\n  }\n  return !1;\n};\nfunction av(t, e, n, r) {\n  if (r == 1)\n    return ae.cursor(e, n);\n  if (r == 2)\n    return zN(t.state, e, n);\n  {\n    let i = Nt.find(t.docView, e), s = t.state.doc.lineAt(i ? i.posAtEnd : e), o = i ? i.posAtStart : s.from, a = i ? i.posAtEnd : s.to;\n    return a < t.state.doc.length && a == s.to && a++, ae.range(o, a);\n  }\n}\nlet Dk = (t, e) => t >= e.top && t <= e.bottom, lv = (t, e, n) => Dk(e, n) && t >= n.left && t <= n.right;\nfunction h5(t, e, n, r) {\n  let i = Nt.find(t.docView, e);\n  if (!i)\n    return 1;\n  let s = e - i.posAtStart;\n  if (s == 0)\n    return 1;\n  if (s == i.length)\n    return -1;\n  let o = i.coordsAt(s, -1);\n  if (o && lv(n, r, o))\n    return -1;\n  let a = i.coordsAt(s, 1);\n  return a && lv(n, r, a) ? 1 : o && Dk(r, o) ? -1 : 1;\n}\nfunction cv(t, e) {\n  let n = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1);\n  return { pos: n, bias: h5(t, n, e.clientX, e.clientY) };\n}\nconst p5 = de.ie && de.ie_version <= 11;\nlet uv = null, dv = 0, fv = 0;\nfunction Zk(t) {\n  if (!p5)\n    return t.detail;\n  let e = uv, n = fv;\n  return uv = t, fv = Date.now(), dv = !e || n > Date.now() - 400 && Math.abs(e.clientX - t.clientX) < 2 && Math.abs(e.clientY - t.clientY) < 2 ? (dv + 1) % 3 : 1;\n}\nfunction O5(t, e) {\n  let n = cv(t, e), r = Zk(e), i = t.state.selection;\n  return {\n    update(s) {\n      s.docChanged && (n.pos = s.changes.mapPos(n.pos), i = i.map(s.changes));\n    },\n    get(s, o, a) {\n      let l = cv(t, s), c, u = av(t, l.pos, l.bias, r);\n      if (n.pos != l.pos && !o) {\n        let d = av(t, n.pos, n.bias, r), f = Math.min(d.from, u.from), h = Math.max(d.to, u.to);\n        u = f < u.from ? ae.range(f, h) : ae.range(h, f);\n      }\n      return o ? i.replaceRange(i.main.extend(u.from, u.to)) : a && r == 1 && i.ranges.length > 1 && (c = g5(i, l.pos)) ? c : a ? i.addRange(u) : ae.create([u]);\n    }\n  };\n}\nfunction g5(t, e) {\n  for (let n = 0; n < t.ranges.length; n++) {\n    let { from: r, to: i } = t.ranges[n];\n    if (r <= e && i >= e)\n      return ae.create(t.ranges.slice(0, n).concat(t.ranges.slice(n + 1)), t.mainIndex == n ? 0 : t.mainIndex - (t.mainIndex > n ? 1 : 0));\n  }\n  return null;\n}\nbr.dragstart = (t, e) => {\n  let { selection: { main: n } } = t.state;\n  if (e.target.draggable) {\n    let i = t.docView.nearest(e.target);\n    if (i && i.isWidget) {\n      let s = i.posAtStart, o = s + i.length;\n      (s >= n.to || o <= n.from) && (n = ae.range(s, o));\n    }\n  }\n  let { inputState: r } = t;\n  return r.mouseSelection && (r.mouseSelection.dragging = !0), r.draggedContent = n, e.dataTransfer && (e.dataTransfer.setData(\"Text\", t.state.sliceDoc(n.from, n.to)), e.dataTransfer.effectAllowed = \"copyMove\"), !1;\n};\nbr.dragend = (t) => (t.inputState.draggedContent = null, !1);\nfunction hv(t, e, n, r) {\n  if (!n)\n    return;\n  let i = t.posAtCoords({ x: e.clientX, y: e.clientY }, !1), { draggedContent: s } = t.inputState, o = r && s && c5(t, e) ? { from: s.from, to: s.to } : null, a = { from: i, insert: n }, l = t.state.changes(o ? [o, a] : a);\n  t.focus(), t.dispatch({\n    changes: l,\n    selection: { anchor: l.mapPos(i, -1), head: l.mapPos(i, 1) },\n    userEvent: o ? \"move.drop\" : \"input.drop\"\n  }), t.inputState.draggedContent = null;\n}\nbr.drop = (t, e) => {\n  if (!e.dataTransfer)\n    return !1;\n  if (t.state.readOnly)\n    return !0;\n  let n = e.dataTransfer.files;\n  if (n && n.length) {\n    let r = Array(n.length), i = 0, s = () => {\n      ++i == n.length && hv(t, e, r.filter((o) => o != null).join(t.state.lineBreak), !1);\n    };\n    for (let o = 0; o < n.length; o++) {\n      let a = new FileReader();\n      a.onerror = s, a.onload = () => {\n        /[\\x00-\\x08\\x0e-\\x1f]{2}/.test(a.result) || (r[o] = a.result), s();\n      }, a.readAsText(n[o]);\n    }\n    return !0;\n  } else {\n    let r = e.dataTransfer.getData(\"Text\");\n    if (r)\n      return hv(t, e, r, !0), !0;\n  }\n  return !1;\n};\nbr.paste = (t, e) => {\n  if (t.state.readOnly)\n    return !0;\n  t.observer.flush();\n  let n = Rk ? null : e.clipboardData;\n  return n ? (Nk(t, n.getData(\"text/plain\") || n.getData(\"text/uri-text\")), !0) : (f5(t), !1);\n};\nfunction m5(t, e) {\n  let n = t.dom.parentNode;\n  if (!n)\n    return;\n  let r = n.appendChild(document.createElement(\"textarea\"));\n  r.style.cssText = \"position: fixed; left: -10000px; top: 10px\", r.value = e, r.focus(), r.selectionEnd = e.length, r.selectionStart = 0, setTimeout(() => {\n    r.remove(), t.focus();\n  }, 50);\n}\nfunction b5(t) {\n  let e = [], n = [], r = !1;\n  for (let i of t.selection.ranges)\n    i.empty || (e.push(t.sliceDoc(i.from, i.to)), n.push(i));\n  if (!e.length) {\n    let i = -1;\n    for (let { from: s } of t.selection.ranges) {\n      let o = t.doc.lineAt(s);\n      o.number > i && (e.push(o.text), n.push({ from: o.from, to: Math.min(t.doc.length, o.to + 1) })), i = o.number;\n    }\n    r = !0;\n  }\n  return { text: e.join(t.lineBreak), ranges: n, linewise: r };\n}\nlet pp = null;\nbr.copy = br.cut = (t, e) => {\n  let { text: n, ranges: r, linewise: i } = b5(t.state);\n  if (!n && !i)\n    return !1;\n  pp = i ? n : null, e.type == \"cut\" && !t.state.readOnly && t.dispatch({\n    changes: r,\n    scrollIntoView: !0,\n    userEvent: \"delete.cut\"\n  });\n  let s = Rk ? null : e.clipboardData;\n  return s ? (s.clearData(), s.setData(\"text/plain\", n), !0) : (m5(t, n), !1);\n};\nconst Vk = /* @__PURE__ */ no.define();\nfunction Ik(t, e) {\n  let n = [];\n  for (let r of t.facet(Sk)) {\n    let i = r(t, e);\n    i && n.push(i);\n  }\n  return n ? t.update({ effects: n, annotations: Vk.of(!0) }) : null;\n}\nfunction Wk(t) {\n  setTimeout(() => {\n    let e = t.hasFocus;\n    if (e != t.inputState.notifiedFocused) {\n      let n = Ik(t.state, e);\n      n ? t.dispatch(n) : t.update([]);\n    }\n  }, 10);\n}\nvr.focus = (t) => {\n  t.inputState.lastFocusTime = Date.now(), !t.scrollDOM.scrollTop && (t.inputState.lastScrollTop || t.inputState.lastScrollLeft) && (t.scrollDOM.scrollTop = t.inputState.lastScrollTop, t.scrollDOM.scrollLeft = t.inputState.lastScrollLeft), Wk(t);\n};\nvr.blur = (t) => {\n  t.observer.clearSelectionRange(), Wk(t);\n};\nvr.compositionstart = vr.compositionupdate = (t) => {\n  t.inputState.compositionFirstChange == null && (t.inputState.compositionFirstChange = !0), t.inputState.composing < 0 && (t.inputState.composing = 0);\n};\nvr.compositionend = (t) => {\n  t.inputState.composing = -1, t.inputState.compositionEndedAt = Date.now(), t.inputState.compositionPendingKey = !0, t.inputState.compositionPendingChange = t.observer.pendingRecords().length > 0, t.inputState.compositionFirstChange = null, de.chrome && de.android ? t.observer.flushSoon() : t.inputState.compositionPendingChange ? Promise.resolve().then(() => t.observer.flush()) : setTimeout(() => {\n    t.inputState.composing < 0 && t.docView.hasComposition && t.update([]);\n  }, 50);\n};\nvr.contextmenu = (t) => {\n  t.inputState.lastContextMenu = Date.now();\n};\nbr.beforeinput = (t, e) => {\n  var n;\n  let r;\n  if (de.chrome && de.android && (r = Ck.find((i) => i.inputType == e.inputType)) && (t.observer.delayAndroidKey(r.key, r.keyCode), r.key == \"Backspace\" || r.key == \"Delete\")) {\n    let i = ((n = window.visualViewport) === null || n === void 0 ? void 0 : n.height) || 0;\n    setTimeout(() => {\n      var s;\n      (((s = window.visualViewport) === null || s === void 0 ? void 0 : s.height) || 0) > i + 10 && t.hasFocus && (t.contentDOM.blur(), t.focus());\n    }, 100);\n  }\n  return !1;\n};\nconst pv = /* @__PURE__ */ new Set();\nfunction v5(t) {\n  pv.has(t) || (pv.add(t), t.addEventListener(\"copy\", () => {\n  }), t.addEventListener(\"cut\", () => {\n  }));\n}\nconst Ov = [\"pre-wrap\", \"normal\", \"pre-line\", \"break-spaces\"];\nclass y5 {\n  constructor(e) {\n    this.lineWrapping = e, this.doc = Fe.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30, this.heightChanged = !1;\n  }\n  heightForGap(e, n) {\n    let r = this.doc.lineAt(n).number - this.doc.lineAt(e).number + 1;\n    return this.lineWrapping && (r += Math.max(0, Math.ceil((n - e - r * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * r;\n  }\n  heightForLine(e) {\n    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;\n  }\n  setDoc(e) {\n    return this.doc = e, this;\n  }\n  mustRefreshForWrapping(e) {\n    return Ov.indexOf(e) > -1 != this.lineWrapping;\n  }\n  mustRefreshForHeights(e) {\n    let n = !1;\n    for (let r = 0; r < e.length; r++) {\n      let i = e[r];\n      i < 0 ? r++ : this.heightSamples[Math.floor(i * 10)] || (n = !0, this.heightSamples[Math.floor(i * 10)] = !0);\n    }\n    return n;\n  }\n  refresh(e, n, r, i, s, o) {\n    let a = Ov.indexOf(e) > -1, l = Math.round(n) != Math.round(this.lineHeight) || this.lineWrapping != a;\n    if (this.lineWrapping = a, this.lineHeight = n, this.charWidth = r, this.textHeight = i, this.lineLength = s, l) {\n      this.heightSamples = {};\n      for (let c = 0; c < o.length; c++) {\n        let u = o[c];\n        u < 0 ? c++ : this.heightSamples[Math.floor(u * 10)] = !0;\n      }\n    }\n    return l;\n  }\n}\nclass S5 {\n  constructor(e, n) {\n    this.from = e, this.heights = n, this.index = 0;\n  }\n  get more() {\n    return this.index < this.heights.length;\n  }\n}\nclass Cr {\n  /**\n  @internal\n  */\n  constructor(e, n, r, i, s) {\n    this.from = e, this.length = n, this.top = r, this.height = i, this._content = s;\n  }\n  /**\n  The type of element this is. When querying lines, this may be\n  an array of all the blocks that make up the line.\n  */\n  get type() {\n    return typeof this._content == \"number\" ? fr.Text : Array.isArray(this._content) ? this._content : this._content.type;\n  }\n  /**\n  The end of the element as a document position.\n  */\n  get to() {\n    return this.from + this.length;\n  }\n  /**\n  The bottom position of the element.\n  */\n  get bottom() {\n    return this.top + this.height;\n  }\n  /**\n  If this is a widget block, this will return the widget\n  associated with it.\n  */\n  get widget() {\n    return this._content instanceof as ? this._content.widget : null;\n  }\n  /**\n  If this is a textblock, this holds the number of line breaks\n  that appear in widgets inside the block.\n  */\n  get widgetLineBreaks() {\n    return typeof this._content == \"number\" ? this._content : 0;\n  }\n  /**\n  @internal\n  */\n  join(e) {\n    let n = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);\n    return new Cr(this.from, this.length + e.length, this.top, this.height + e.height, n);\n  }\n}\nvar dt = /* @__PURE__ */ function(t) {\n  return t[t.ByPos = 0] = \"ByPos\", t[t.ByHeight = 1] = \"ByHeight\", t[t.ByPosNoHeight = 2] = \"ByPosNoHeight\", t;\n}(dt || (dt = {}));\nconst su = 1e-3;\nclass pn {\n  constructor(e, n, r = 2) {\n    this.length = e, this.height = n, this.flags = r;\n  }\n  get outdated() {\n    return (this.flags & 2) > 0;\n  }\n  set outdated(e) {\n    this.flags = (e ? 2 : 0) | this.flags & -3;\n  }\n  setHeight(e, n) {\n    this.height != n && (Math.abs(this.height - n) > su && (e.heightChanged = !0), this.height = n);\n  }\n  // Base case is to replace a leaf node, which simply builds a tree\n  // from the new nodes and returns that (HeightMapBranch and\n  // HeightMapGap override this to actually use from/to)\n  replace(e, n, r) {\n    return pn.of(r);\n  }\n  // Again, these are base cases, and are overridden for branch and gap nodes.\n  decomposeLeft(e, n) {\n    n.push(this);\n  }\n  decomposeRight(e, n) {\n    n.push(this);\n  }\n  applyChanges(e, n, r, i) {\n    let s = this, o = r.doc;\n    for (let a = i.length - 1; a >= 0; a--) {\n      let { fromA: l, toA: c, fromB: u, toB: d } = i[a], f = s.lineAt(l, dt.ByPosNoHeight, r.setDoc(n), 0, 0), h = f.to >= c ? f : s.lineAt(c, dt.ByPosNoHeight, r, 0, 0);\n      for (d += h.to - c, c = h.to; a > 0 && f.from <= i[a - 1].toA; )\n        l = i[a - 1].fromA, u = i[a - 1].fromB, a--, l < f.from && (f = s.lineAt(l, dt.ByPosNoHeight, r, 0, 0));\n      u += f.from - l, l = f.from;\n      let p = dg.build(r.setDoc(o), e, u, d);\n      s = s.replace(l, c, p);\n    }\n    return s.updateHeight(r, 0);\n  }\n  static empty() {\n    return new Rn(0, 0);\n  }\n  // nodes uses null values to indicate the position of line breaks.\n  // There are never line breaks at the start or end of the array, or\n  // two line breaks next to each other, and the array isn't allowed\n  // to be empty (same restrictions as return value from the builder).\n  static of(e) {\n    if (e.length == 1)\n      return e[0];\n    let n = 0, r = e.length, i = 0, s = 0;\n    for (; ; )\n      if (n == r)\n        if (i > s * 2) {\n          let a = e[n - 1];\n          a.break ? e.splice(--n, 1, a.left, null, a.right) : e.splice(--n, 1, a.left, a.right), r += 1 + a.break, i -= a.size;\n        } else if (s > i * 2) {\n          let a = e[r];\n          a.break ? e.splice(r, 1, a.left, null, a.right) : e.splice(r, 1, a.left, a.right), r += 2 + a.break, s -= a.size;\n        } else\n          break;\n      else if (i < s) {\n        let a = e[n++];\n        a && (i += a.size);\n      } else {\n        let a = e[--r];\n        a && (s += a.size);\n      }\n    let o = 0;\n    return e[n - 1] == null ? (o = 1, n--) : e[n] == null && (o = 1, r++), new w5(pn.of(e.slice(0, n)), o, pn.of(e.slice(r)));\n  }\n}\npn.prototype.size = 1;\nclass Mk extends pn {\n  constructor(e, n, r) {\n    super(e, n), this.deco = r;\n  }\n  blockAt(e, n, r, i) {\n    return new Cr(i, this.length, r, this.height, this.deco || 0);\n  }\n  lineAt(e, n, r, i, s) {\n    return this.blockAt(0, r, i, s);\n  }\n  forEachLine(e, n, r, i, s, o) {\n    e <= s + this.length && n >= s && o(this.blockAt(0, r, i, s));\n  }\n  updateHeight(e, n = 0, r = !1, i) {\n    return i && i.from <= n && i.more && this.setHeight(e, i.heights[i.index++]), this.outdated = !1, this;\n  }\n  toString() {\n    return `block(${this.length})`;\n  }\n}\nclass Rn extends Mk {\n  constructor(e, n) {\n    super(e, n, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;\n  }\n  blockAt(e, n, r, i) {\n    return new Cr(i, this.length, r, this.height, this.breaks);\n  }\n  replace(e, n, r) {\n    let i = r[0];\n    return r.length == 1 && (i instanceof Rn || i instanceof zt && i.flags & 4) && Math.abs(this.length - i.length) < 10 ? (i instanceof zt ? i = new Rn(i.length, this.height) : i.height = this.height, this.outdated || (i.outdated = !1), i) : pn.of(r);\n  }\n  updateHeight(e, n = 0, r = !1, i) {\n    return i && i.from <= n && i.more ? this.setHeight(e, i.heights[i.index++]) : (r || this.outdated) && this.setHeight(e, Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = !1, this;\n  }\n  toString() {\n    return `line(${this.length}${this.collapsed ? -this.collapsed : \"\"}${this.widgetHeight ? \":\" + this.widgetHeight : \"\"})`;\n  }\n}\nclass zt extends pn {\n  constructor(e) {\n    super(e, 0);\n  }\n  heightMetrics(e, n) {\n    let r = e.doc.lineAt(n).number, i = e.doc.lineAt(n + this.length).number, s = i - r + 1, o, a = 0;\n    if (e.lineWrapping) {\n      let l = Math.min(this.height, e.lineHeight * s);\n      o = l / s, this.length > s + 1 && (a = (this.height - l) / (this.length - s - 1));\n    } else\n      o = this.height / s;\n    return { firstLine: r, lastLine: i, perLine: o, perChar: a };\n  }\n  blockAt(e, n, r, i) {\n    let { firstLine: s, lastLine: o, perLine: a, perChar: l } = this.heightMetrics(n, i);\n    if (n.lineWrapping) {\n      let c = i + Math.round(Math.max(0, Math.min(1, (e - r) / this.height)) * this.length), u = n.doc.lineAt(c), d = a + u.length * l, f = Math.max(r, e - d / 2);\n      return new Cr(u.from, u.length, f, d, 0);\n    } else {\n      let c = Math.max(0, Math.min(o - s, Math.floor((e - r) / a))), { from: u, length: d } = n.doc.line(s + c);\n      return new Cr(u, d, r + a * c, a, 0);\n    }\n  }\n  lineAt(e, n, r, i, s) {\n    if (n == dt.ByHeight)\n      return this.blockAt(e, r, i, s);\n    if (n == dt.ByPosNoHeight) {\n      let { from: h, to: p } = r.doc.lineAt(e);\n      return new Cr(h, p - h, 0, 0, 0);\n    }\n    let { firstLine: o, perLine: a, perChar: l } = this.heightMetrics(r, s), c = r.doc.lineAt(e), u = a + c.length * l, d = c.number - o, f = i + a * d + l * (c.from - s - d);\n    return new Cr(c.from, c.length, Math.max(i, Math.min(f, i + this.height - u)), u, 0);\n  }\n  forEachLine(e, n, r, i, s, o) {\n    e = Math.max(e, s), n = Math.min(n, s + this.length);\n    let { firstLine: a, perLine: l, perChar: c } = this.heightMetrics(r, s);\n    for (let u = e, d = i; u <= n; ) {\n      let f = r.doc.lineAt(u);\n      if (u == e) {\n        let p = f.number - a;\n        d += l * p + c * (e - s - p);\n      }\n      let h = l + c * f.length;\n      o(new Cr(f.from, f.length, d, h, 0)), d += h, u = f.to + 1;\n    }\n  }\n  replace(e, n, r) {\n    let i = this.length - n;\n    if (i > 0) {\n      let s = r[r.length - 1];\n      s instanceof zt ? r[r.length - 1] = new zt(s.length + i) : r.push(null, new zt(i - 1));\n    }\n    if (e > 0) {\n      let s = r[0];\n      s instanceof zt ? r[0] = new zt(e + s.length) : r.unshift(new zt(e - 1), null);\n    }\n    return pn.of(r);\n  }\n  decomposeLeft(e, n) {\n    n.push(new zt(e - 1), null);\n  }\n  decomposeRight(e, n) {\n    n.push(null, new zt(this.length - e - 1));\n  }\n  updateHeight(e, n = 0, r = !1, i) {\n    let s = n + this.length;\n    if (i && i.from <= n + this.length && i.more) {\n      let o = [], a = Math.max(n, i.from), l = -1;\n      for (i.from > n && o.push(new zt(i.from - n - 1).updateHeight(e, n)); a <= s && i.more; ) {\n        let u = e.doc.lineAt(a).length;\n        o.length && o.push(null);\n        let d = i.heights[i.index++];\n        l == -1 ? l = d : Math.abs(d - l) >= su && (l = -2);\n        let f = new Rn(u, d);\n        f.outdated = !1, o.push(f), a += u + 1;\n      }\n      a <= s && o.push(null, new zt(s - a).updateHeight(e, a));\n      let c = pn.of(o);\n      return (l < 0 || Math.abs(c.height - this.height) >= su || Math.abs(l - this.heightMetrics(e, n).perLine) >= su) && (e.heightChanged = !0), c;\n    } else\n      (r || this.outdated) && (this.setHeight(e, e.heightForGap(n, n + this.length)), this.outdated = !1);\n    return this;\n  }\n  toString() {\n    return `gap(${this.length})`;\n  }\n}\nclass w5 extends pn {\n  constructor(e, n, r) {\n    super(e.length + n + r.length, e.height + r.height, n | (e.outdated || r.outdated ? 2 : 0)), this.left = e, this.right = r, this.size = e.size + r.size;\n  }\n  get break() {\n    return this.flags & 1;\n  }\n  blockAt(e, n, r, i) {\n    let s = r + this.left.height;\n    return e < s ? this.left.blockAt(e, n, r, i) : this.right.blockAt(e, n, s, i + this.left.length + this.break);\n  }\n  lineAt(e, n, r, i, s) {\n    let o = i + this.left.height, a = s + this.left.length + this.break, l = n == dt.ByHeight ? e < o : e < a, c = l ? this.left.lineAt(e, n, r, i, s) : this.right.lineAt(e, n, r, o, a);\n    if (this.break || (l ? c.to < a : c.from > a))\n      return c;\n    let u = n == dt.ByPosNoHeight ? dt.ByPosNoHeight : dt.ByPos;\n    return l ? c.join(this.right.lineAt(a, u, r, o, a)) : this.left.lineAt(a, u, r, i, s).join(c);\n  }\n  forEachLine(e, n, r, i, s, o) {\n    let a = i + this.left.height, l = s + this.left.length + this.break;\n    if (this.break)\n      e < l && this.left.forEachLine(e, n, r, i, s, o), n >= l && this.right.forEachLine(e, n, r, a, l, o);\n    else {\n      let c = this.lineAt(l, dt.ByPos, r, i, s);\n      e < c.from && this.left.forEachLine(e, c.from - 1, r, i, s, o), c.to >= e && c.from <= n && o(c), n > c.to && this.right.forEachLine(c.to + 1, n, r, a, l, o);\n    }\n  }\n  replace(e, n, r) {\n    let i = this.left.length + this.break;\n    if (n < i)\n      return this.balanced(this.left.replace(e, n, r), this.right);\n    if (e > this.left.length)\n      return this.balanced(this.left, this.right.replace(e - i, n - i, r));\n    let s = [];\n    e > 0 && this.decomposeLeft(e, s);\n    let o = s.length;\n    for (let a of r)\n      s.push(a);\n    if (e > 0 && gv(s, o - 1), n < this.length) {\n      let a = s.length;\n      this.decomposeRight(n, s), gv(s, a);\n    }\n    return pn.of(s);\n  }\n  decomposeLeft(e, n) {\n    let r = this.left.length;\n    if (e <= r)\n      return this.left.decomposeLeft(e, n);\n    n.push(this.left), this.break && (r++, e >= r && n.push(null)), e > r && this.right.decomposeLeft(e - r, n);\n  }\n  decomposeRight(e, n) {\n    let r = this.left.length, i = r + this.break;\n    if (e >= i)\n      return this.right.decomposeRight(e - i, n);\n    e < r && this.left.decomposeRight(e, n), this.break && e < i && n.push(null), n.push(this.right);\n  }\n  balanced(e, n) {\n    return e.size > 2 * n.size || n.size > 2 * e.size ? pn.of(this.break ? [e, null, n] : [e, n]) : (this.left = e, this.right = n, this.height = e.height + n.height, this.outdated = e.outdated || n.outdated, this.size = e.size + n.size, this.length = e.length + this.break + n.length, this);\n  }\n  updateHeight(e, n = 0, r = !1, i) {\n    let { left: s, right: o } = this, a = n + s.length + this.break, l = null;\n    return i && i.from <= n + s.length && i.more ? l = s = s.updateHeight(e, n, r, i) : s.updateHeight(e, n, r), i && i.from <= a + o.length && i.more ? l = o = o.updateHeight(e, a, r, i) : o.updateHeight(e, a, r), l ? this.balanced(s, o) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);\n  }\n  toString() {\n    return this.left + (this.break ? \" \" : \"-\") + this.right;\n  }\n}\nfunction gv(t, e) {\n  let n, r;\n  t[e] == null && (n = t[e - 1]) instanceof zt && (r = t[e + 1]) instanceof zt && t.splice(e - 1, 3, new zt(n.length + 1 + r.length));\n}\nconst k5 = 5;\nclass dg {\n  constructor(e, n) {\n    this.pos = e, this.oracle = n, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;\n  }\n  get isCovered() {\n    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;\n  }\n  span(e, n) {\n    if (this.lineStart > -1) {\n      let r = Math.min(n, this.lineEnd), i = this.nodes[this.nodes.length - 1];\n      i instanceof Rn ? i.length += r - this.pos : (r > this.pos || !this.isCovered) && this.nodes.push(new Rn(r - this.pos, -1)), this.writtenTo = r, n > r && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);\n    }\n    this.pos = n;\n  }\n  point(e, n, r) {\n    if (e < n || r.heightRelevant) {\n      let i = r.widget ? r.widget.estimatedHeight : 0, s = r.widget ? r.widget.lineBreaks : 0;\n      i < 0 && (i = this.oracle.lineHeight);\n      let o = n - e;\n      r.block ? this.addBlock(new Mk(o, i, r)) : (o || s || i >= k5) && this.addLineDeco(i, s, o);\n    } else\n      n > e && this.span(e, n);\n    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);\n  }\n  enterLine() {\n    if (this.lineStart > -1)\n      return;\n    let { from: e, to: n } = this.oracle.doc.lineAt(this.pos);\n    this.lineStart = e, this.lineEnd = n, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new Rn(this.pos - e, -1)), this.writtenTo = this.pos;\n  }\n  blankContent(e, n) {\n    let r = new zt(n - e);\n    return this.oracle.doc.lineAt(e).to == n && (r.flags |= 4), r;\n  }\n  ensureLine() {\n    this.enterLine();\n    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;\n    if (e instanceof Rn)\n      return e;\n    let n = new Rn(0, -1);\n    return this.nodes.push(n), n;\n  }\n  addBlock(e) {\n    this.enterLine();\n    let n = e.deco;\n    n && n.startSide > 0 && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, n && n.endSide > 0 && (this.covering = e);\n  }\n  addLineDeco(e, n, r) {\n    let i = this.ensureLine();\n    i.length += r, i.collapsed += r, i.widgetHeight = Math.max(i.widgetHeight, e), i.breaks += n, this.writtenTo = this.pos = this.pos + r;\n  }\n  finish(e) {\n    let n = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];\n    this.lineStart > -1 && !(n instanceof Rn) && !this.isCovered ? this.nodes.push(new Rn(0, -1)) : (this.writtenTo < this.pos || n == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));\n    let r = e;\n    for (let i of this.nodes)\n      i instanceof Rn && i.updateHeight(this.oracle, r), r += i ? i.length : 1;\n    return this.nodes;\n  }\n  // Always called with a region that on both sides either stretches\n  // to a line break or the end of the document.\n  // The returned array uses null to indicate line breaks, but never\n  // starts or ends in a line break, or has multiple line breaks next\n  // to each other.\n  static build(e, n, r, i) {\n    let s = new dg(r, e);\n    return ze.spans(n, r, i, s, 0), s.finish(r);\n  }\n}\nfunction x5(t, e, n) {\n  let r = new P5();\n  return ze.compare(t, e, n, r, 0), r.changes;\n}\nclass P5 {\n  constructor() {\n    this.changes = [];\n  }\n  compareRange() {\n  }\n  comparePoint(e, n, r, i) {\n    (e < n || r && r.heightRelevant || i && i.heightRelevant) && lp(e, n, this.changes, 5);\n  }\n}\nfunction _5(t, e) {\n  let n = t.getBoundingClientRect(), r = t.ownerDocument, i = r.defaultView || window, s = Math.max(0, n.left), o = Math.min(i.innerWidth, n.right), a = Math.max(0, n.top), l = Math.min(i.innerHeight, n.bottom);\n  for (let c = t.parentNode; c && c != r.body; )\n    if (c.nodeType == 1) {\n      let u = c, d = window.getComputedStyle(u);\n      if ((u.scrollHeight > u.clientHeight || u.scrollWidth > u.clientWidth) && d.overflow != \"visible\") {\n        let f = u.getBoundingClientRect();\n        s = Math.max(s, f.left), o = Math.min(o, f.right), a = Math.max(a, f.top), l = c == t.parentNode ? f.bottom : Math.min(l, f.bottom);\n      }\n      c = d.position == \"absolute\" || d.position == \"fixed\" ? u.offsetParent : u.parentNode;\n    } else if (c.nodeType == 11)\n      c = c.host;\n    else\n      break;\n  return {\n    left: s - n.left,\n    right: Math.max(s, o) - n.left,\n    top: a - (n.top + e),\n    bottom: Math.max(a, l) - (n.top + e)\n  };\n}\nfunction T5(t, e) {\n  let n = t.getBoundingClientRect();\n  return {\n    left: 0,\n    right: n.right - n.left,\n    top: e,\n    bottom: n.bottom - (n.top + e)\n  };\n}\nclass Ef {\n  constructor(e, n, r) {\n    this.from = e, this.to = n, this.size = r;\n  }\n  static same(e, n) {\n    if (e.length != n.length)\n      return !1;\n    for (let r = 0; r < e.length; r++) {\n      let i = e[r], s = n[r];\n      if (i.from != s.from || i.to != s.to || i.size != s.size)\n        return !1;\n    }\n    return !0;\n  }\n  draw(e, n) {\n    return Je.replace({\n      widget: new E5(this.size * (n ? e.scaleY : e.scaleX), n)\n    }).range(this.from, this.to);\n  }\n}\nclass E5 extends ra {\n  constructor(e, n) {\n    super(), this.size = e, this.vertical = n;\n  }\n  eq(e) {\n    return e.size == this.size && e.vertical == this.vertical;\n  }\n  toDOM() {\n    let e = document.createElement(\"div\");\n    return this.vertical ? e.style.height = this.size + \"px\" : (e.style.width = this.size + \"px\", e.style.height = \"2px\", e.style.display = \"inline-block\"), e;\n  }\n  get estimatedHeight() {\n    return this.vertical ? this.size : -1;\n  }\n}\nclass mv {\n  constructor(e) {\n    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !0, this.scaleX = 1, this.scaleY = 1, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = bv, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = Qt.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;\n    let n = e.facet(cg).some((r) => typeof r != \"function\" && r.class == \"cm-lineWrapping\");\n    this.heightOracle = new y5(n), this.stateDeco = e.facet(ml).filter((r) => typeof r != \"function\"), this.heightMap = pn.empty().applyChanges(this.stateDeco, Fe.empty, this.heightOracle.setDoc(e.doc), [new tr(0, 0, 0, e.doc.length)]), this.viewport = this.getViewport(0, null), this.updateViewportLines(), this.updateForViewport(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = Je.set(this.lineGaps.map((r) => r.draw(this, !1))), this.computeVisibleRanges();\n  }\n  updateForViewport() {\n    let e = [this.viewport], { main: n } = this.state.selection;\n    for (let r = 0; r <= 1; r++) {\n      let i = r ? n.head : n.anchor;\n      if (!e.some(({ from: s, to: o }) => i >= s && i <= o)) {\n        let { from: s, to: o } = this.lineBlockAt(i);\n        e.push(new $c(s, o));\n      }\n    }\n    this.viewports = e.sort((r, i) => r.from - i.from), this.scaler = this.heightMap.height <= 7e6 ? bv : new C5(this.heightOracle, this.heightMap, this.viewports);\n  }\n  updateViewportLines() {\n    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {\n      this.viewportLines.push(this.scaler.scale == 1 ? e : Da(e, this.scaler));\n    });\n  }\n  update(e, n = null) {\n    this.state = e.state;\n    let r = this.stateDeco;\n    this.stateDeco = this.state.facet(ml).filter((u) => typeof u != \"function\");\n    let i = e.changedRanges, s = tr.extendWithRanges(i, x5(r, this.stateDeco, e ? e.changes : Mt.empty(this.state.doc.length))), o = this.heightMap.height, a = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);\n    this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), s), this.heightMap.height != o && (e.flags |= 2), a ? (this.scrollAnchorPos = e.changes.mapPos(a.from, -1), this.scrollAnchorHeight = a.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = this.heightMap.height);\n    let l = s.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;\n    (n && (n.range.head < l.from || n.range.head > l.to) || !this.viewportIsAppropriate(l)) && (l = this.getViewport(0, n));\n    let c = !e.changes.empty || e.flags & 2 || l.from != this.viewport.from || l.to != this.viewport.to;\n    this.viewport = l, this.updateForViewport(), c && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(), n && (this.scrollTarget = n), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(WN) && (this.mustEnforceCursorAssoc = !0);\n  }\n  measure(e) {\n    let n = e.contentDOM, r = window.getComputedStyle(n), i = this.heightOracle, s = r.whiteSpace;\n    this.defaultTextDirection = r.direction == \"rtl\" ? Qt.RTL : Qt.LTR;\n    let o = this.heightOracle.mustRefreshForWrapping(s), a = n.getBoundingClientRect(), l = o || this.mustMeasureContent || this.contentDOMHeight != a.height;\n    this.contentDOMHeight = a.height, this.mustMeasureContent = !1;\n    let c = 0, u = 0;\n    if (a.width && a.height) {\n      let { scaleX: v, scaleY: S } = Kw(n, a);\n      (this.scaleX != v || this.scaleY != S) && (this.scaleX = v, this.scaleY = S, c |= 8, o = l = !0);\n    }\n    let d = (parseInt(r.paddingTop) || 0) * this.scaleY, f = (parseInt(r.paddingBottom) || 0) * this.scaleY;\n    (this.paddingTop != d || this.paddingBottom != f) && (this.paddingTop = d, this.paddingBottom = f, c |= 10), this.editorWidth != e.scrollDOM.clientWidth && (i.lineWrapping && (l = !0), this.editorWidth = e.scrollDOM.clientWidth, c |= 8);\n    let h = e.scrollDOM.scrollTop * this.scaleY;\n    this.scrollTop != h && (this.scrollAnchorHeight = -1, this.scrollTop = h), this.scrolledToBottom = tk(e.scrollDOM);\n    let p = (this.printing ? T5 : _5)(n, this.paddingTop), O = p.top - this.pixelViewport.top, m = p.bottom - this.pixelViewport.bottom;\n    this.pixelViewport = p;\n    let y = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;\n    if (y != this.inView && (this.inView = y, y && (l = !0)), !this.inView && !this.scrollTarget)\n      return 0;\n    let b = a.width;\n    if ((this.contentDOMWidth != b || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = a.width, this.editorHeight = e.scrollDOM.clientHeight, c |= 8), l) {\n      let v = e.docView.measureVisibleLineHeights(this.viewport);\n      if (i.mustRefreshForHeights(v) && (o = !0), o || i.lineWrapping && Math.abs(b - this.contentDOMWidth) > i.charWidth) {\n        let { lineHeight: S, charWidth: w, textHeight: k } = e.docView.measureTextSize();\n        o = S > 0 && i.refresh(s, S, w, k, b / w, v), o && (e.docView.minWidth = 0, c |= 8);\n      }\n      O > 0 && m > 0 ? u = Math.max(O, m) : O < 0 && m < 0 && (u = Math.min(O, m)), i.heightChanged = !1;\n      for (let S of this.viewports) {\n        let w = S.from == this.viewport.from ? v : e.docView.measureVisibleLineHeights(S);\n        this.heightMap = (o ? pn.empty().applyChanges(this.stateDeco, Fe.empty, this.heightOracle, [new tr(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(i, 0, o, new S5(S.from, w));\n      }\n      i.heightChanged && (c |= 2);\n    }\n    let g = !this.viewportIsAppropriate(this.viewport, u) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);\n    return g && (this.viewport = this.getViewport(u, this.scrollTarget)), this.updateForViewport(), (c & 2 || g) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(o ? [] : this.lineGaps, e)), c |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), c;\n  }\n  get visibleTop() {\n    return this.scaler.fromDOM(this.pixelViewport.top);\n  }\n  get visibleBottom() {\n    return this.scaler.fromDOM(this.pixelViewport.bottom);\n  }\n  getViewport(e, n) {\n    let r = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), i = this.heightMap, s = this.heightOracle, { visibleTop: o, visibleBottom: a } = this, l = new $c(i.lineAt(o - r * 1e3, dt.ByHeight, s, 0, 0).from, i.lineAt(a + (1 - r) * 1e3, dt.ByHeight, s, 0, 0).to);\n    if (n) {\n      let { head: c } = n.range;\n      if (c < l.from || c > l.to) {\n        let u = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), d = i.lineAt(c, dt.ByPos, s, 0, 0), f;\n        n.y == \"center\" ? f = (d.top + d.bottom) / 2 - u / 2 : n.y == \"start\" || n.y == \"nearest\" && c < l.from ? f = d.top : f = d.bottom - u, l = new $c(i.lineAt(f - 1e3 / 2, dt.ByHeight, s, 0, 0).from, i.lineAt(f + u + 1e3 / 2, dt.ByHeight, s, 0, 0).to);\n      }\n    }\n    return l;\n  }\n  mapViewport(e, n) {\n    let r = n.mapPos(e.from, -1), i = n.mapPos(e.to, 1);\n    return new $c(this.heightMap.lineAt(r, dt.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(i, dt.ByPos, this.heightOracle, 0, 0).to);\n  }\n  // Checks if a given viewport covers the visible part of the\n  // document and not too much beyond that.\n  viewportIsAppropriate({ from: e, to: n }, r = 0) {\n    if (!this.inView)\n      return !0;\n    let { top: i } = this.heightMap.lineAt(e, dt.ByPos, this.heightOracle, 0, 0), { bottom: s } = this.heightMap.lineAt(n, dt.ByPos, this.heightOracle, 0, 0), { visibleTop: o, visibleBottom: a } = this;\n    return (e == 0 || i <= o - Math.max(10, Math.min(\n      -r,\n      250\n      /* VP.MaxCoverMargin */\n    ))) && (n == this.state.doc.length || s >= a + Math.max(10, Math.min(\n      r,\n      250\n      /* VP.MaxCoverMargin */\n    ))) && i > o - 2 * 1e3 && s < a + 2 * 1e3;\n  }\n  mapLineGaps(e, n) {\n    if (!e.length || n.empty)\n      return e;\n    let r = [];\n    for (let i of e)\n      n.touchesRange(i.from, i.to) || r.push(new Ef(n.mapPos(i.from), n.mapPos(i.to), i.size));\n    return r;\n  }\n  // Computes positions in the viewport where the start or end of a\n  // line should be hidden, trying to reuse existing line gaps when\n  // appropriate to avoid unneccesary redraws.\n  // Uses crude character-counting for the positioning and sizing,\n  // since actual DOM coordinates aren't always available and\n  // predictable. Relies on generous margins (see LG.Margin) to hide\n  // the artifacts this might produce from the user.\n  ensureLineGaps(e, n) {\n    let r = this.heightOracle.lineWrapping, i = r ? 1e4 : 2e3, s = i >> 1, o = i << 1;\n    if (this.defaultTextDirection != Qt.LTR && !r)\n      return [];\n    let a = [], l = (c, u, d, f) => {\n      if (u - c < s)\n        return;\n      let h = this.state.selection.main, p = [h.from];\n      h.empty || p.push(h.to);\n      for (let m of p)\n        if (m > c && m < u) {\n          l(c, m - 10, d, f), l(m + 10, u, d, f);\n          return;\n        }\n      let O = Q5(e, (m) => m.from >= d.from && m.to <= d.to && Math.abs(m.from - c) < s && Math.abs(m.to - u) < s && !p.some((y) => m.from < y && m.to > y));\n      if (!O) {\n        if (u < d.to && n && r && n.visibleRanges.some((m) => m.from <= u && m.to >= u)) {\n          let m = n.moveToLineBoundary(ae.cursor(u), !1, !0).head;\n          m > c && (u = m);\n        }\n        O = new Ef(c, u, this.gapSize(d, c, u, f));\n      }\n      a.push(O);\n    };\n    for (let c of this.viewportLines) {\n      if (c.length < o)\n        continue;\n      let u = $5(c.from, c.to, this.stateDeco);\n      if (u.total < o)\n        continue;\n      let d = this.scrollTarget ? this.scrollTarget.range.head : null, f, h;\n      if (r) {\n        let p = i / this.heightOracle.lineLength * this.heightOracle.lineHeight, O, m;\n        if (d != null) {\n          let y = Cc(u, d), b = ((this.visibleBottom - this.visibleTop) / 2 + p) / c.height;\n          O = y - b, m = y + b;\n        } else\n          O = (this.visibleTop - c.top - p) / c.height, m = (this.visibleBottom - c.top + p) / c.height;\n        f = Qc(u, O), h = Qc(u, m);\n      } else {\n        let p = u.total * this.heightOracle.charWidth, O = i * this.heightOracle.charWidth, m, y;\n        if (d != null) {\n          let b = Cc(u, d), g = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + O) / p;\n          m = b - g, y = b + g;\n        } else\n          m = (this.pixelViewport.left - O) / p, y = (this.pixelViewport.right + O) / p;\n        f = Qc(u, m), h = Qc(u, y);\n      }\n      f > c.from && l(c.from, f, c, u), h < c.to && l(h, c.to, c, u);\n    }\n    return a;\n  }\n  gapSize(e, n, r, i) {\n    let s = Cc(i, r) - Cc(i, n);\n    return this.heightOracle.lineWrapping ? e.height * s : i.total * this.heightOracle.charWidth * s;\n  }\n  updateLineGaps(e) {\n    Ef.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = Je.set(e.map((n) => n.draw(this, this.heightOracle.lineWrapping))));\n  }\n  computeVisibleRanges() {\n    let e = this.stateDeco;\n    this.lineGaps.length && (e = e.concat(this.lineGapDeco));\n    let n = [];\n    ze.spans(e, this.viewport.from, this.viewport.to, {\n      span(i, s) {\n        n.push({ from: i, to: s });\n      },\n      point() {\n      }\n    }, 20);\n    let r = n.length != this.visibleRanges.length || this.visibleRanges.some((i, s) => i.from != n[s].from || i.to != n[s].to);\n    return this.visibleRanges = n, r ? 4 : 0;\n  }\n  lineBlockAt(e) {\n    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((n) => n.from <= e && n.to >= e) || Da(this.heightMap.lineAt(e, dt.ByPos, this.heightOracle, 0, 0), this.scaler);\n  }\n  lineBlockAtHeight(e) {\n    return Da(this.heightMap.lineAt(this.scaler.fromDOM(e), dt.ByHeight, this.heightOracle, 0, 0), this.scaler);\n  }\n  scrollAnchorAt(e) {\n    let n = this.lineBlockAtHeight(e + 8);\n    return n.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? n : this.viewportLines[0];\n  }\n  elementAtHeight(e) {\n    return Da(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);\n  }\n  get docHeight() {\n    return this.scaler.toDOM(this.heightMap.height);\n  }\n  get contentHeight() {\n    return this.docHeight + this.paddingTop + this.paddingBottom;\n  }\n}\nclass $c {\n  constructor(e, n) {\n    this.from = e, this.to = n;\n  }\n}\nfunction $5(t, e, n) {\n  let r = [], i = t, s = 0;\n  return ze.spans(n, t, e, {\n    span() {\n    },\n    point(o, a) {\n      o > i && (r.push({ from: i, to: o }), s += o - i), i = a;\n    }\n  }, 20), i < e && (r.push({ from: i, to: e }), s += e - i), { total: s, ranges: r };\n}\nfunction Qc({ total: t, ranges: e }, n) {\n  if (n <= 0)\n    return e[0].from;\n  if (n >= 1)\n    return e[e.length - 1].to;\n  let r = Math.floor(t * n);\n  for (let i = 0; ; i++) {\n    let { from: s, to: o } = e[i], a = o - s;\n    if (r <= a)\n      return s + r;\n    r -= a;\n  }\n}\nfunction Cc(t, e) {\n  let n = 0;\n  for (let { from: r, to: i } of t.ranges) {\n    if (e <= i) {\n      n += e - r;\n      break;\n    }\n    n += i - r;\n  }\n  return n / t.total;\n}\nfunction Q5(t, e) {\n  for (let n of t)\n    if (e(n))\n      return n;\n}\nconst bv = {\n  toDOM(t) {\n    return t;\n  },\n  fromDOM(t) {\n    return t;\n  },\n  scale: 1\n};\nclass C5 {\n  constructor(e, n, r) {\n    let i = 0, s = 0, o = 0;\n    this.viewports = r.map(({ from: a, to: l }) => {\n      let c = n.lineAt(a, dt.ByPos, e, 0, 0).top, u = n.lineAt(l, dt.ByPos, e, 0, 0).bottom;\n      return i += u - c, { from: a, to: l, top: c, bottom: u, domTop: 0, domBottom: 0 };\n    }), this.scale = (7e6 - i) / (n.height - i);\n    for (let a of this.viewports)\n      a.domTop = o + (a.top - s) * this.scale, o = a.domBottom = a.domTop + (a.bottom - a.top), s = a.bottom;\n  }\n  toDOM(e) {\n    for (let n = 0, r = 0, i = 0; ; n++) {\n      let s = n < this.viewports.length ? this.viewports[n] : null;\n      if (!s || e < s.top)\n        return i + (e - r) * this.scale;\n      if (e <= s.bottom)\n        return s.domTop + (e - s.top);\n      r = s.bottom, i = s.domBottom;\n    }\n  }\n  fromDOM(e) {\n    for (let n = 0, r = 0, i = 0; ; n++) {\n      let s = n < this.viewports.length ? this.viewports[n] : null;\n      if (!s || e < s.domTop)\n        return r + (e - i) / this.scale;\n      if (e <= s.domBottom)\n        return s.top + (e - s.domTop);\n      r = s.bottom, i = s.domBottom;\n    }\n  }\n}\nfunction Da(t, e) {\n  if (e.scale == 1)\n    return t;\n  let n = e.toDOM(t.top), r = e.toDOM(t.bottom);\n  return new Cr(t.from, t.length, n, r - n, Array.isArray(t._content) ? t._content.map((i) => Da(i, e)) : t._content);\n}\nconst Ac = /* @__PURE__ */ ve.define({ combine: (t) => t.join(\" \") }), Op = /* @__PURE__ */ ve.define({ combine: (t) => t.indexOf(!0) > -1 }), gp = /* @__PURE__ */ ss.newName(), Xk = /* @__PURE__ */ ss.newName(), jk = /* @__PURE__ */ ss.newName(), Bk = { \"&light\": \".\" + Xk, \"&dark\": \".\" + jk };\nfunction mp(t, e, n) {\n  return new ss(e, {\n    finish(r) {\n      return /&/.test(r) ? r.replace(/&\\w*/, (i) => {\n        if (i == \"&\")\n          return t;\n        if (!n || !n[i])\n          throw new RangeError(`Unsupported selector: ${i}`);\n        return n[i];\n      }) : t + \" \" + r;\n    }\n  });\n}\nconst A5 = /* @__PURE__ */ mp(\".\" + gp, {\n  \"&\": {\n    position: \"relative !important\",\n    boxSizing: \"border-box\",\n    \"&.cm-focused\": {\n      // Provide a simple default outline to make sure a focused\n      // editor is visually distinct. Can't leave the default behavior\n      // because that will apply to the content element, which is\n      // inside the scrollable container and doesn't include the\n      // gutters. We also can't use an 'auto' outline, since those\n      // are, for some reason, drawn behind the element content, which\n      // will cause things like the active line background to cover\n      // the outline (#297).\n      outline: \"1px dotted #212121\"\n    },\n    display: \"flex !important\",\n    flexDirection: \"column\"\n  },\n  \".cm-scroller\": {\n    display: \"flex !important\",\n    alignItems: \"flex-start !important\",\n    fontFamily: \"monospace\",\n    lineHeight: 1.4,\n    height: \"100%\",\n    overflowX: \"auto\",\n    position: \"relative\",\n    zIndex: 0\n  },\n  \".cm-content\": {\n    margin: 0,\n    flexGrow: 2,\n    flexShrink: 0,\n    display: \"block\",\n    whiteSpace: \"pre\",\n    wordWrap: \"normal\",\n    // https://github.com/codemirror/dev/issues/456\n    boxSizing: \"border-box\",\n    minHeight: \"100%\",\n    padding: \"4px 0\",\n    outline: \"none\",\n    \"&[contenteditable=true]\": {\n      WebkitUserModify: \"read-write-plaintext-only\"\n    }\n  },\n  \".cm-lineWrapping\": {\n    whiteSpace_fallback: \"pre-wrap\",\n    // For IE\n    whiteSpace: \"break-spaces\",\n    wordBreak: \"break-word\",\n    // For Safari, which doesn't support overflow-wrap: anywhere\n    overflowWrap: \"anywhere\",\n    flexShrink: 1\n  },\n  \"&light .cm-content\": { caretColor: \"black\" },\n  \"&dark .cm-content\": { caretColor: \"white\" },\n  \".cm-line\": {\n    display: \"block\",\n    padding: \"0 2px 0 6px\"\n  },\n  \".cm-layer\": {\n    position: \"absolute\",\n    left: 0,\n    top: 0,\n    contain: \"size style\",\n    \"& > *\": {\n      position: \"absolute\"\n    }\n  },\n  \"&light .cm-selectionBackground\": {\n    background: \"#d9d9d9\"\n  },\n  \"&dark .cm-selectionBackground\": {\n    background: \"#222\"\n  },\n  \"&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground\": {\n    background: \"#d7d4f0\"\n  },\n  \"&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground\": {\n    background: \"#233\"\n  },\n  \".cm-cursorLayer\": {\n    pointerEvents: \"none\"\n  },\n  \"&.cm-focused > .cm-scroller > .cm-cursorLayer\": {\n    animation: \"steps(1) cm-blink 1.2s infinite\"\n  },\n  // Two animations defined so that we can switch between them to\n  // restart the animation without forcing another style\n  // recomputation.\n  \"@keyframes cm-blink\": { \"0%\": {}, \"50%\": { opacity: 0 }, \"100%\": {} },\n  \"@keyframes cm-blink2\": { \"0%\": {}, \"50%\": { opacity: 0 }, \"100%\": {} },\n  \".cm-cursor, .cm-dropCursor\": {\n    borderLeft: \"1.2px solid black\",\n    marginLeft: \"-0.6px\",\n    pointerEvents: \"none\"\n  },\n  \".cm-cursor\": {\n    display: \"none\"\n  },\n  \"&dark .cm-cursor\": {\n    borderLeftColor: \"#444\"\n  },\n  \".cm-dropCursor\": {\n    position: \"absolute\"\n  },\n  \"&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor\": {\n    display: \"block\"\n  },\n  \".cm-iso\": {\n    unicodeBidi: \"isolate\"\n  },\n  \".cm-announced\": {\n    position: \"fixed\",\n    top: \"-10000px\"\n  },\n  \"@media print\": {\n    \".cm-announced\": { display: \"none\" }\n  },\n  \"&light .cm-activeLine\": { backgroundColor: \"#cceeff44\" },\n  \"&dark .cm-activeLine\": { backgroundColor: \"#99eeff33\" },\n  \"&light .cm-specialChar\": { color: \"red\" },\n  \"&dark .cm-specialChar\": { color: \"#f78\" },\n  \".cm-gutters\": {\n    flexShrink: 0,\n    display: \"flex\",\n    height: \"100%\",\n    boxSizing: \"border-box\",\n    insetInlineStart: 0,\n    zIndex: 200\n  },\n  \"&light .cm-gutters\": {\n    backgroundColor: \"#f5f5f5\",\n    color: \"#6c6c6c\",\n    borderRight: \"1px solid #ddd\"\n  },\n  \"&dark .cm-gutters\": {\n    backgroundColor: \"#333338\",\n    color: \"#ccc\"\n  },\n  \".cm-gutter\": {\n    display: \"flex !important\",\n    // Necessary -- prevents margin collapsing\n    flexDirection: \"column\",\n    flexShrink: 0,\n    boxSizing: \"border-box\",\n    minHeight: \"100%\",\n    overflow: \"hidden\"\n  },\n  \".cm-gutterElement\": {\n    boxSizing: \"border-box\"\n  },\n  \".cm-lineNumbers .cm-gutterElement\": {\n    padding: \"0 3px 0 5px\",\n    minWidth: \"20px\",\n    textAlign: \"right\",\n    whiteSpace: \"nowrap\"\n  },\n  \"&light .cm-activeLineGutter\": {\n    backgroundColor: \"#e2f2ff\"\n  },\n  \"&dark .cm-activeLineGutter\": {\n    backgroundColor: \"#222227\"\n  },\n  \".cm-panels\": {\n    boxSizing: \"border-box\",\n    position: \"sticky\",\n    left: 0,\n    right: 0\n  },\n  \"&light .cm-panels\": {\n    backgroundColor: \"#f5f5f5\",\n    color: \"black\"\n  },\n  \"&light .cm-panels-top\": {\n    borderBottom: \"1px solid #ddd\"\n  },\n  \"&light .cm-panels-bottom\": {\n    borderTop: \"1px solid #ddd\"\n  },\n  \"&dark .cm-panels\": {\n    backgroundColor: \"#333338\",\n    color: \"white\"\n  },\n  \".cm-tab\": {\n    display: \"inline-block\",\n    overflow: \"hidden\",\n    verticalAlign: \"bottom\"\n  },\n  \".cm-widgetBuffer\": {\n    verticalAlign: \"text-top\",\n    height: \"1em\",\n    width: 0,\n    display: \"inline\"\n  },\n  \".cm-placeholder\": {\n    color: \"#888\",\n    display: \"inline-block\",\n    verticalAlign: \"top\"\n  },\n  \".cm-highlightSpace:before\": {\n    content: \"attr(data-display)\",\n    position: \"absolute\",\n    pointerEvents: \"none\",\n    color: \"#888\"\n  },\n  \".cm-highlightTab\": {\n    backgroundImage: `url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"200\" height=\"20\"><path stroke=\"%23888\" stroke-width=\"1\" fill=\"none\" d=\"M1 10H196L190 5M190 15L196 10M197 4L197 16\"/></svg>')`,\n    backgroundSize: \"auto 100%\",\n    backgroundPosition: \"right 90%\",\n    backgroundRepeat: \"no-repeat\"\n  },\n  \".cm-trailingSpace\": {\n    backgroundColor: \"#ff332255\"\n  },\n  \".cm-button\": {\n    verticalAlign: \"middle\",\n    color: \"inherit\",\n    fontSize: \"70%\",\n    padding: \".2em 1em\",\n    borderRadius: \"1px\"\n  },\n  \"&light .cm-button\": {\n    backgroundImage: \"linear-gradient(#eff1f5, #d9d9df)\",\n    border: \"1px solid #888\",\n    \"&:active\": {\n      backgroundImage: \"linear-gradient(#b4b4b4, #d0d3d6)\"\n    }\n  },\n  \"&dark .cm-button\": {\n    backgroundImage: \"linear-gradient(#393939, #111)\",\n    border: \"1px solid #888\",\n    \"&:active\": {\n      backgroundImage: \"linear-gradient(#111, #333)\"\n    }\n  },\n  \".cm-textfield\": {\n    verticalAlign: \"middle\",\n    color: \"inherit\",\n    fontSize: \"70%\",\n    border: \"1px solid silver\",\n    padding: \".2em .5em\"\n  },\n  \"&light .cm-textfield\": {\n    backgroundColor: \"white\"\n  },\n  \"&dark .cm-textfield\": {\n    border: \"1px solid #555\",\n    backgroundColor: \"inherit\"\n  }\n}, Bk), Za = \"\";\nclass R5 {\n  constructor(e, n) {\n    this.points = e, this.text = \"\", this.lineSeparator = n.facet(Ye.lineSeparator);\n  }\n  append(e) {\n    this.text += e;\n  }\n  lineBreak() {\n    this.text += Za;\n  }\n  readRange(e, n) {\n    if (!e)\n      return this;\n    let r = e.parentNode;\n    for (let i = e; ; ) {\n      this.findPointBefore(r, i);\n      let s = this.text.length;\n      this.readNode(i);\n      let o = i.nextSibling;\n      if (o == n)\n        break;\n      let a = ft.get(i), l = ft.get(o);\n      (a && l ? a.breakAfter : (a ? a.breakAfter : vv(i)) || vv(o) && (i.nodeName != \"BR\" || i.cmIgnore) && this.text.length > s) && this.lineBreak(), i = o;\n    }\n    return this.findPointBefore(r, n), this;\n  }\n  readTextNode(e) {\n    let n = e.nodeValue;\n    for (let r of this.points)\n      r.node == e && (r.pos = this.text.length + Math.min(r.offset, n.length));\n    for (let r = 0, i = this.lineSeparator ? null : /\\r\\n?|\\n/g; ; ) {\n      let s = -1, o = 1, a;\n      if (this.lineSeparator ? (s = n.indexOf(this.lineSeparator, r), o = this.lineSeparator.length) : (a = i.exec(n)) && (s = a.index, o = a[0].length), this.append(n.slice(r, s < 0 ? n.length : s)), s < 0)\n        break;\n      if (this.lineBreak(), o > 1)\n        for (let l of this.points)\n          l.node == e && l.pos > this.text.length && (l.pos -= o - 1);\n      r = s + o;\n    }\n  }\n  readNode(e) {\n    if (e.cmIgnore)\n      return;\n    let n = ft.get(e), r = n && n.overrideDOMText;\n    if (r != null) {\n      this.findPointInside(e, r.length);\n      for (let i = r.iter(); !i.next().done; )\n        i.lineBreak ? this.lineBreak() : this.append(i.value);\n    } else\n      e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == \"BR\" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);\n  }\n  findPointBefore(e, n) {\n    for (let r of this.points)\n      r.node == e && e.childNodes[r.offset] == n && (r.pos = this.text.length);\n  }\n  findPointInside(e, n) {\n    for (let r of this.points)\n      (e.nodeType == 3 ? r.node == e : e.contains(r.node)) && (r.pos = this.text.length + (N5(e, r.node, r.offset) ? n : 0));\n  }\n}\nfunction N5(t, e, n) {\n  for (; ; ) {\n    if (!e || n < fi(e))\n      return !1;\n    if (e == t)\n      return !0;\n    n = gl(e) + 1, e = e.parentNode;\n  }\n}\nfunction vv(t) {\n  return t.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\\d|SECTION|PRE)$/.test(t.nodeName);\n}\nclass yv {\n  constructor(e, n) {\n    this.node = e, this.offset = n, this.pos = -1;\n  }\n}\nclass D5 {\n  constructor(e, n, r, i) {\n    this.typeOver = i, this.bounds = null, this.text = \"\";\n    let { impreciseHead: s, impreciseAnchor: o } = e.docView;\n    if (e.state.readOnly && n > -1)\n      this.newSel = null;\n    else if (n > -1 && (this.bounds = e.docView.domBoundsAround(n, r, 0))) {\n      let a = s || o ? [] : I5(e), l = new R5(a, e.state);\n      l.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = l.text, this.newSel = W5(a, this.bounds.from);\n    } else {\n      let a = e.observer.selectionRange, l = s && s.node == a.focusNode && s.offset == a.focusOffset || !np(e.contentDOM, a.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(a.focusNode, a.focusOffset), c = o && o.node == a.anchorNode && o.offset == a.anchorOffset || !np(e.contentDOM, a.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(a.anchorNode, a.anchorOffset), u = e.viewport;\n      if ((de.ios || de.chrome) && e.state.selection.main.empty && l != c && (u.from > 0 || u.to < e.state.doc.length)) {\n        let d = Math.min(l, c), f = Math.max(l, c), h = u.from - d, p = u.to - f;\n        (h == 0 || h == 1 || d == 0) && (p == 0 || p == -1 || f == e.state.doc.length) && (l = 0, c = e.state.doc.length);\n      }\n      this.newSel = ae.single(c, l);\n    }\n  }\n}\nfunction Lk(t, e) {\n  let n, { newSel: r } = e, i = t.state.selection.main, s = t.inputState.lastKeyTime > Date.now() - 100 ? t.inputState.lastKeyCode : -1;\n  if (e.bounds) {\n    let { from: o, to: a } = e.bounds, l = i.from, c = null;\n    (s === 8 || de.android && e.text.length < a - o) && (l = i.to, c = \"end\");\n    let u = V5(t.state.doc.sliceString(o, a, Za), e.text, l - o, c);\n    u && (de.chrome && s == 13 && u.toB == u.from + 2 && e.text.slice(u.from, u.toB) == Za + Za && u.toB--, n = {\n      from: o + u.from,\n      to: o + u.toA,\n      insert: Fe.of(e.text.slice(u.from, u.toB).split(Za))\n    });\n  } else\n    r && (!t.hasFocus && t.state.facet(Yd) || r.main.eq(i)) && (r = null);\n  if (!n && !r)\n    return !1;\n  if (!n && e.typeOver && !i.empty && r && r.main.empty ? n = { from: i.from, to: i.to, insert: t.state.doc.slice(i.from, i.to) } : n && n.from >= i.from && n.to <= i.to && (n.from != i.from || n.to != i.to) && i.to - i.from - (n.to - n.from) <= 4 ? n = {\n    from: i.from,\n    to: i.to,\n    insert: t.state.doc.slice(i.from, n.from).append(n.insert).append(t.state.doc.slice(n.to, i.to))\n  } : (de.mac || de.android) && n && n.from == n.to && n.from == i.head - 1 && /^\\. ?$/.test(n.insert.toString()) && t.contentDOM.getAttribute(\"autocorrect\") == \"off\" ? (r && n.insert.length == 2 && (r = ae.single(r.main.anchor - 1, r.main.head - 1)), n = { from: i.from, to: i.to, insert: Fe.of([\" \"]) }) : de.chrome && n && n.from == n.to && n.from == i.head && n.insert.toString() == `\n ` && t.lineWrapping && (r && (r = ae.single(r.main.anchor - 1, r.main.head - 1)), n = { from: i.from, to: i.to, insert: Fe.of([\" \"]) }), n) {\n    if (de.ios && t.inputState.flushIOSKey() || de.android && (n.from == i.from && n.to == i.to && n.insert.length == 1 && n.insert.lines == 2 && To(t.contentDOM, \"Enter\", 13) || (n.from == i.from - 1 && n.to == i.to && n.insert.length == 0 || s == 8 && n.insert.length < n.to - n.from && n.to > i.head) && To(t.contentDOM, \"Backspace\", 8) || n.from == i.from && n.to == i.to + 1 && n.insert.length == 0 && To(t.contentDOM, \"Delete\", 46)))\n      return !0;\n    let o = n.insert.toString();\n    t.inputState.composing >= 0 && t.inputState.composing++;\n    let a, l = () => a || (a = Z5(t, n, r));\n    return t.state.facet(yk).some((c) => c(t, n.from, n.to, o, l)) || t.dispatch(l()), !0;\n  } else if (r && !r.main.eq(i)) {\n    let o = !1, a = \"select\";\n    return t.inputState.lastSelectionTime > Date.now() - 50 && (t.inputState.lastSelectionOrigin == \"select\" && (o = !0), a = t.inputState.lastSelectionOrigin), t.dispatch({ selection: r, scrollIntoView: o, userEvent: a }), !0;\n  } else\n    return !1;\n}\nfunction Z5(t, e, n) {\n  let r, i = t.state, s = i.selection.main;\n  if (e.from >= s.from && e.to <= s.to && e.to - e.from >= (s.to - s.from) / 3 && (!n || n.main.empty && n.main.from == e.from + e.insert.length) && t.inputState.composing < 0) {\n    let a = s.from < e.from ? i.sliceDoc(s.from, e.from) : \"\", l = s.to > e.to ? i.sliceDoc(e.to, s.to) : \"\";\n    r = i.replaceSelection(t.state.toText(a + e.insert.sliceString(0, void 0, t.state.lineBreak) + l));\n  } else {\n    let a = i.changes(e), l = n && n.main.to <= a.newLength ? n.main : void 0;\n    if (i.selection.ranges.length > 1 && t.inputState.composing >= 0 && e.to <= s.to && e.to >= s.to - 10) {\n      let c = t.state.sliceDoc(e.from, e.to), u, d = n && Ek(t, n.main.head);\n      if (d) {\n        let p = e.insert.length - (e.to - e.from);\n        u = { from: d.from, to: d.to - p };\n      } else\n        u = t.state.doc.lineAt(s.head);\n      let f = s.to - e.to, h = s.to - s.from;\n      r = i.changeByRange((p) => {\n        if (p.from == s.from && p.to == s.to)\n          return { changes: a, range: l || p.map(a) };\n        let O = p.to - f, m = O - c.length;\n        if (p.to - p.from != h || t.state.sliceDoc(m, O) != c || // Unfortunately, there's no way to make multiple\n        // changes in the same node work without aborting\n        // composition, so cursors in the composition range are\n        // ignored.\n        p.to >= u.from && p.from <= u.to)\n          return { range: p };\n        let y = i.changes({ from: m, to: O, insert: e.insert }), b = p.to - s.to;\n        return {\n          changes: y,\n          range: l ? ae.range(Math.max(0, l.anchor + b), Math.max(0, l.head + b)) : p.map(y)\n        };\n      });\n    } else\n      r = {\n        changes: a,\n        selection: l && i.selection.replaceRange(l)\n      };\n  }\n  let o = \"input.type\";\n  return (t.composing || t.inputState.compositionPendingChange && t.inputState.compositionEndedAt > Date.now() - 50) && (t.inputState.compositionPendingChange = !1, o += \".compose\", t.inputState.compositionFirstChange && (o += \".start\", t.inputState.compositionFirstChange = !1)), i.update(r, { userEvent: o, scrollIntoView: !0 });\n}\nfunction V5(t, e, n, r) {\n  let i = Math.min(t.length, e.length), s = 0;\n  for (; s < i && t.charCodeAt(s) == e.charCodeAt(s); )\n    s++;\n  if (s == i && t.length == e.length)\n    return null;\n  let o = t.length, a = e.length;\n  for (; o > 0 && a > 0 && t.charCodeAt(o - 1) == e.charCodeAt(a - 1); )\n    o--, a--;\n  if (r == \"end\") {\n    let l = Math.max(0, s - Math.min(o, a));\n    n -= o + l - s;\n  }\n  if (o < s && t.length < e.length) {\n    let l = n <= s && n >= o ? s - n : 0;\n    s -= l, a = s + (a - o), o = s;\n  } else if (a < s) {\n    let l = n <= s && n >= a ? s - n : 0;\n    s -= l, o = s + (o - a), a = s;\n  }\n  return { from: s, toA: o, toB: a };\n}\nfunction I5(t) {\n  let e = [];\n  if (t.root.activeElement != t.contentDOM)\n    return e;\n  let { anchorNode: n, anchorOffset: r, focusNode: i, focusOffset: s } = t.observer.selectionRange;\n  return n && (e.push(new yv(n, r)), (i != n || s != r) && e.push(new yv(i, s))), e;\n}\nfunction W5(t, e) {\n  if (t.length == 0)\n    return null;\n  let n = t[0].pos, r = t.length == 2 ? t[1].pos : n;\n  return n > -1 && r > -1 ? ae.single(n + e, r + e) : null;\n}\nconst M5 = {\n  childList: !0,\n  characterData: !0,\n  subtree: !0,\n  attributes: !0,\n  characterDataOldValue: !0\n}, $f = de.ie && de.ie_version <= 11;\nclass X5 {\n  constructor(e) {\n    this.view = e, this.active = !1, this.selectionRange = new wN(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((n) => {\n      for (let r of n)\n        this.queue.push(r);\n      (de.ie && de.ie_version <= 11 || de.ios && e.composing) && n.some((r) => r.type == \"childList\" && r.removedNodes.length || r.type == \"characterData\" && r.oldValue.length > r.target.nodeValue.length) ? this.flushSoon() : this.flush();\n    }), $f && (this.onCharData = (n) => {\n      this.queue.push({\n        target: n.target,\n        type: \"characterData\",\n        oldValue: n.prevValue\n      }), this.flushSoon();\n    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), typeof ResizeObserver == \"function\" && (this.resizeScroll = new ResizeObserver(() => {\n      var n;\n      ((n = this.view.docView) === null || n === void 0 ? void 0 : n.lastUpdate) < Date.now() - 75 && this.onResize();\n    }), this.resizeScroll.observe(e.scrollDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == \"function\" && (this.intersection = new IntersectionObserver((n) => {\n      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), n.length > 0 && n[n.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent(\"Event\")));\n    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((n) => {\n      n.length > 0 && n[n.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent(\"Event\"));\n    }, {})), this.listenForScroll(), this.readSelectionRange();\n  }\n  onScrollChanged(e) {\n    this.view.inputState.runHandlers(\"scroll\", e), this.intersecting && this.view.measure();\n  }\n  onScroll(e) {\n    this.intersecting && this.flush(!1), this.onScrollChanged(e);\n  }\n  onResize() {\n    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {\n      this.resizeTimeout = -1, this.view.requestMeasure();\n    }, 50));\n  }\n  onPrint() {\n    this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {\n      this.view.viewState.printing = !1, this.view.requestMeasure();\n    }, 500);\n  }\n  updateGaps(e) {\n    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((n, r) => n != e[r]))) {\n      this.gapIntersection.disconnect();\n      for (let n of e)\n        this.gapIntersection.observe(n);\n      this.gaps = e;\n    }\n  }\n  onSelectionChange(e) {\n    let n = this.selectionChanged;\n    if (!this.readSelectionRange() || this.delayedAndroidKey)\n      return;\n    let { view: r } = this, i = this.selectionRange;\n    if (r.state.facet(Yd) ? r.root.activeElement != this.dom : !ru(r.dom, i))\n      return;\n    let s = i.anchorNode && r.docView.nearest(i.anchorNode);\n    if (s && s.ignoreEvent(e)) {\n      n || (this.selectionChanged = !1);\n      return;\n    }\n    (de.ie && de.ie_version <= 11 || de.android && de.chrome) && !r.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)\n    i.focusNode && za(i.focusNode, i.focusOffset, i.anchorNode, i.anchorOffset) ? this.flushSoon() : this.flush(!1);\n  }\n  readSelectionRange() {\n    let { view: e } = this, n = de.safari && e.root.nodeType == 11 && bN(this.dom.ownerDocument) == this.dom && j5(this.view) || Iu(e.root);\n    if (!n || this.selectionRange.eq(n))\n      return !1;\n    let r = ru(this.dom, n);\n    return r && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && xN(this.dom, n) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), !1) : (this.selectionRange.setRange(n), r && (this.selectionChanged = !0), !0);\n  }\n  setSelectionRange(e, n) {\n    this.selectionRange.set(e.node, e.offset, n.node, n.offset), this.selectionChanged = !1;\n  }\n  clearSelectionRange() {\n    this.selectionRange.set(null, 0, null, 0);\n  }\n  listenForScroll() {\n    this.parentCheck = -1;\n    let e = 0, n = null;\n    for (let r = this.dom; r; )\n      if (r.nodeType == 1)\n        !n && e < this.scrollTargets.length && this.scrollTargets[e] == r ? e++ : n || (n = this.scrollTargets.slice(0, e)), n && n.push(r), r = r.assignedSlot || r.parentNode;\n      else if (r.nodeType == 11)\n        r = r.host;\n      else\n        break;\n    if (e < this.scrollTargets.length && !n && (n = this.scrollTargets.slice(0, e)), n) {\n      for (let r of this.scrollTargets)\n        r.removeEventListener(\"scroll\", this.onScroll);\n      for (let r of this.scrollTargets = n)\n        r.addEventListener(\"scroll\", this.onScroll);\n    }\n  }\n  ignore(e) {\n    if (!this.active)\n      return e();\n    try {\n      return this.stop(), e();\n    } finally {\n      this.start(), this.clear();\n    }\n  }\n  start() {\n    this.active || (this.observer.observe(this.dom, M5), $f && this.dom.addEventListener(\"DOMCharacterDataModified\", this.onCharData), this.active = !0);\n  }\n  stop() {\n    this.active && (this.active = !1, this.observer.disconnect(), $f && this.dom.removeEventListener(\"DOMCharacterDataModified\", this.onCharData));\n  }\n  // Throw away any pending changes\n  clear() {\n    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;\n  }\n  // Chrome Android, especially in combination with GBoard, not only\n  // doesn't reliably fire regular key events, but also often\n  // surrounds the effect of enter or backspace with a bunch of\n  // composition events that, when interrupted, cause text duplication\n  // or other kinds of corruption. This hack makes the editor back off\n  // from handling DOM changes for a moment when such a key is\n  // detected (via beforeinput or keydown), and then tries to flush\n  // them or, if that has no effect, dispatches the given key.\n  delayAndroidKey(e, n) {\n    var r;\n    if (!this.delayedAndroidKey) {\n      let i = () => {\n        let s = this.delayedAndroidKey;\n        s && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = s.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && s.force && To(this.dom, s.key, s.keyCode));\n      };\n      this.flushingAndroidKey = this.view.win.requestAnimationFrame(i);\n    }\n    (!this.delayedAndroidKey || e == \"Enter\") && (this.delayedAndroidKey = {\n      key: e,\n      keyCode: n,\n      // Only run the key handler when no changes are detected if\n      // this isn't coming right after another change, in which case\n      // it is probably part of a weird chain of updates, and should\n      // be ignored if it returns the DOM to its previous state.\n      force: this.lastChange < Date.now() - 50 || !!(!((r = this.delayedAndroidKey) === null || r === void 0) && r.force)\n    });\n  }\n  clearDelayedAndroidKey() {\n    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;\n  }\n  flushSoon() {\n    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {\n      this.delayedFlush = -1, this.flush();\n    }));\n  }\n  forceFlush() {\n    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();\n  }\n  pendingRecords() {\n    for (let e of this.observer.takeRecords())\n      this.queue.push(e);\n    return this.queue;\n  }\n  processRecords() {\n    let e = this.pendingRecords();\n    e.length && (this.queue = []);\n    let n = -1, r = -1, i = !1;\n    for (let s of e) {\n      let o = this.readMutation(s);\n      o && (o.typeOver && (i = !0), n == -1 ? { from: n, to: r } = o : (n = Math.min(o.from, n), r = Math.max(o.to, r)));\n    }\n    return { from: n, to: r, typeOver: i };\n  }\n  readChange() {\n    let { from: e, to: n, typeOver: r } = this.processRecords(), i = this.selectionChanged && ru(this.dom, this.selectionRange);\n    if (e < 0 && !i)\n      return null;\n    e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;\n    let s = new D5(this.view, e, n, r);\n    return this.view.docView.domChanged = { newSel: s.newSel ? s.newSel.main : null }, s;\n  }\n  // Apply pending changes, if any\n  flush(e = !0) {\n    if (this.delayedFlush >= 0 || this.delayedAndroidKey)\n      return !1;\n    e && this.readSelectionRange();\n    let n = this.readChange();\n    if (!n)\n      return this.view.requestMeasure(), !1;\n    let r = this.view.state, i = Lk(this.view, n);\n    return this.view.state == r && this.view.update([]), i;\n  }\n  readMutation(e) {\n    let n = this.view.docView.nearest(e.target);\n    if (!n || n.ignoreMutation(e))\n      return null;\n    if (n.markDirty(e.type == \"attributes\"), e.type == \"attributes\" && (n.flags |= 4), e.type == \"childList\") {\n      let r = Sv(n, e.previousSibling || e.target.previousSibling, -1), i = Sv(n, e.nextSibling || e.target.nextSibling, 1);\n      return {\n        from: r ? n.posAfter(r) : n.posAtStart,\n        to: i ? n.posBefore(i) : n.posAtEnd,\n        typeOver: !1\n      };\n    } else\n      return e.type == \"characterData\" ? { from: n.posAtStart, to: n.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;\n  }\n  setWindow(e) {\n    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));\n  }\n  addWindowListeners(e) {\n    e.addEventListener(\"resize\", this.onResize), e.addEventListener(\"beforeprint\", this.onPrint), e.addEventListener(\"scroll\", this.onScroll), e.document.addEventListener(\"selectionchange\", this.onSelectionChange);\n  }\n  removeWindowListeners(e) {\n    e.removeEventListener(\"scroll\", this.onScroll), e.removeEventListener(\"resize\", this.onResize), e.removeEventListener(\"beforeprint\", this.onPrint), e.document.removeEventListener(\"selectionchange\", this.onSelectionChange);\n  }\n  destroy() {\n    var e, n, r;\n    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (n = this.gapIntersection) === null || n === void 0 || n.disconnect(), (r = this.resizeScroll) === null || r === void 0 || r.disconnect();\n    for (let i of this.scrollTargets)\n      i.removeEventListener(\"scroll\", this.onScroll);\n    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey);\n  }\n}\nfunction Sv(t, e, n) {\n  for (; e; ) {\n    let r = ft.get(e);\n    if (r && r.parent == t)\n      return r;\n    let i = e.parentNode;\n    e = i != t.dom ? i : n > 0 ? e.nextSibling : e.previousSibling;\n  }\n  return null;\n}\nfunction j5(t) {\n  let e = null;\n  function n(l) {\n    l.preventDefault(), l.stopImmediatePropagation(), e = l.getTargetRanges()[0];\n  }\n  if (t.contentDOM.addEventListener(\"beforeinput\", n, !0), t.dom.ownerDocument.execCommand(\"indent\"), t.contentDOM.removeEventListener(\"beforeinput\", n, !0), !e)\n    return null;\n  let r = e.startContainer, i = e.startOffset, s = e.endContainer, o = e.endOffset, a = t.docView.domAtPos(t.state.selection.main.anchor);\n  return za(a.node, a.offset, s, o) && ([r, i, s, o] = [s, o, r, i]), { anchorNode: r, anchorOffset: i, focusNode: s, focusOffset: o };\n}\nclass Se {\n  /**\n  The current editor state.\n  */\n  get state() {\n    return this.viewState.state;\n  }\n  /**\n  To be able to display large documents without consuming too much\n  memory or overloading the browser, CodeMirror only draws the\n  code that is visible (plus a margin around it) to the DOM. This\n  property tells you the extent of the current drawn viewport, in\n  document positions.\n  */\n  get viewport() {\n    return this.viewState.viewport;\n  }\n  /**\n  When there are, for example, large collapsed ranges in the\n  viewport, its size can be a lot bigger than the actual visible\n  content. Thus, if you are doing something like styling the\n  content in the viewport, it is preferable to only do so for\n  these ranges, which are the subset of the viewport that is\n  actually drawn.\n  */\n  get visibleRanges() {\n    return this.viewState.visibleRanges;\n  }\n  /**\n  Returns false when the editor is entirely scrolled out of view\n  or otherwise hidden.\n  */\n  get inView() {\n    return this.viewState.inView;\n  }\n  /**\n  Indicates whether the user is currently composing text via\n  [IME](https://en.wikipedia.org/wiki/Input_method), and at least\n  one change has been made in the current composition.\n  */\n  get composing() {\n    return this.inputState.composing > 0;\n  }\n  /**\n  Indicates whether the user is currently in composing state. Note\n  that on some platforms, like Android, this will be the case a\n  lot, since just putting the cursor on a word starts a\n  composition there.\n  */\n  get compositionStarted() {\n    return this.inputState.composing >= 0;\n  }\n  /**\n  The document or shadow root that the view lives in.\n  */\n  get root() {\n    return this._root;\n  }\n  /**\n  @internal\n  */\n  get win() {\n    return this.dom.ownerDocument.defaultView || window;\n  }\n  /**\n  Construct a new view. You'll want to either provide a `parent`\n  option, or put `view.dom` into your document after creating a\n  view, so that the user can see the editor.\n  */\n  constructor(e = {}) {\n    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement(\"div\"), this.scrollDOM = document.createElement(\"div\"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = \"cm-scroller\", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement(\"div\"), this.announceDOM.className = \"cm-announced\", this.announceDOM.setAttribute(\"aria-live\", \"polite\"), this.dom = document.createElement(\"div\"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), e.parent && e.parent.appendChild(this.dom);\n    let { dispatch: n } = e;\n    this.dispatchTransactions = e.dispatchTransactions || n && ((r) => r.forEach((i) => n(i, this))) || ((r) => this.update(r)), this.dispatch = this.dispatch.bind(this), this._root = e.root || kN(e.parent) || document, this.viewState = new mv(e.state || Ye.create(e)), e.scrollTo && e.scrollTo.is(_c) && (this.viewState.scrollTarget = e.scrollTo.value.clip(this.viewState.state)), this.plugins = this.state.facet(Ra).map((r) => new Pf(r));\n    for (let r of this.plugins)\n      r.update(this);\n    this.observer = new X5(this), this.inputState = new r5(this), this.inputState.ensureHandlers(this.plugins), this.docView = new Jb(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure();\n  }\n  dispatch(...e) {\n    let n = e.length == 1 && e[0] instanceof Gt ? e : e.length == 1 && Array.isArray(e[0]) ? e[0] : [this.state.update(...e)];\n    this.dispatchTransactions(n, this);\n  }\n  /**\n  Update the view for the given array of transactions. This will\n  update the visible document and selection to match the state\n  produced by the transactions, and notify view plugins of the\n  change. You should usually call\n  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this\n  as a primitive.\n  */\n  update(e) {\n    if (this.updateState != 0)\n      throw new Error(\"Calls to EditorView.update are not allowed while an update is in progress\");\n    let n = !1, r = !1, i, s = this.state;\n    for (let f of e) {\n      if (f.startState != s)\n        throw new RangeError(\"Trying to update state with a transaction that doesn't start from the previous state.\");\n      s = f.state;\n    }\n    if (this.destroyed) {\n      this.viewState.state = s;\n      return;\n    }\n    let o = this.hasFocus, a = 0, l = null;\n    e.some((f) => f.annotation(Vk)) ? (this.inputState.notifiedFocused = o, a = 1) : o != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = o, l = Ik(s, o), l || (a = 1));\n    let c = this.observer.delayedAndroidKey, u = null;\n    if (c ? (this.observer.clearDelayedAndroidKey(), u = this.observer.readChange(), (u && !this.state.doc.eq(s.doc) || !this.state.selection.eq(s.selection)) && (u = null)) : this.observer.clear(), s.facet(Ye.phrases) != this.state.facet(Ye.phrases))\n      return this.setState(s);\n    i = Wu.create(this, s, e), i.flags |= a;\n    let d = this.viewState.scrollTarget;\n    try {\n      this.updateState = 2;\n      for (let f of e) {\n        if (d && (d = d.map(f.changes)), f.scrollIntoView) {\n          let { main: h } = f.state.selection;\n          d = new Eo(h.empty ? h : ae.cursor(h.head, h.head > h.anchor ? -1 : 1));\n        }\n        for (let h of f.effects)\n          h.is(_c) && (d = h.value.clip(this.state));\n      }\n      this.viewState.update(i, d), this.bidiCache = Mu.update(this.bidiCache, i.changes), i.empty || (this.updatePlugins(i), this.inputState.update(i)), n = this.docView.update(i), this.state.facet(Na) != this.styleModules && this.mountStyles(), r = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(n, e.some((f) => f.isUserEvent(\"select.pointer\")));\n    } finally {\n      this.updateState = 0;\n    }\n    if (i.startState.facet(Ac) != i.state.facet(Ac) && (this.viewState.mustMeasureContent = !0), (n || r || d || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), !i.empty)\n      for (let f of this.state.facet(fp))\n        try {\n          f(i);\n        } catch (h) {\n          hr(this.state, h, \"update listener\");\n        }\n    (l || u) && Promise.resolve().then(() => {\n      l && this.state == l.startState && this.dispatch(l), u && !Lk(this, u) && c.force && To(this.contentDOM, c.key, c.keyCode);\n    });\n  }\n  /**\n  Reset the view to the given state. (This will cause the entire\n  document to be redrawn and all view plugins to be reinitialized,\n  so you should probably only use it when the new state isn't\n  derived from the old state. Otherwise, use\n  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)\n  */\n  setState(e) {\n    if (this.updateState != 0)\n      throw new Error(\"Calls to EditorView.setState are not allowed while an update is in progress\");\n    if (this.destroyed) {\n      this.viewState.state = e;\n      return;\n    }\n    this.updateState = 2;\n    let n = this.hasFocus;\n    try {\n      for (let r of this.plugins)\n        r.destroy(this);\n      this.viewState = new mv(e), this.plugins = e.facet(Ra).map((r) => new Pf(r)), this.pluginMap.clear();\n      for (let r of this.plugins)\n        r.update(this);\n      this.docView.destroy(), this.docView = new Jb(this), this.inputState.ensureHandlers(this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];\n    } finally {\n      this.updateState = 0;\n    }\n    n && this.focus(), this.requestMeasure();\n  }\n  updatePlugins(e) {\n    let n = e.startState.facet(Ra), r = e.state.facet(Ra);\n    if (n != r) {\n      let i = [];\n      for (let s of r) {\n        let o = n.indexOf(s);\n        if (o < 0)\n          i.push(new Pf(s));\n        else {\n          let a = this.plugins[o];\n          a.mustUpdate = e, i.push(a);\n        }\n      }\n      for (let s of this.plugins)\n        s.mustUpdate != e && s.destroy(this);\n      this.plugins = i, this.pluginMap.clear();\n    } else\n      for (let i of this.plugins)\n        i.mustUpdate = e;\n    for (let i = 0; i < this.plugins.length; i++)\n      this.plugins[i].update(this);\n    n != r && this.inputState.ensureHandlers(this.plugins);\n  }\n  /**\n  @internal\n  */\n  measure(e = !0) {\n    if (this.destroyed)\n      return;\n    if (this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.observer.delayedAndroidKey) {\n      this.measureScheduled = -1, this.requestMeasure();\n      return;\n    }\n    this.measureScheduled = 0, e && this.observer.forceFlush();\n    let n = null, r = this.scrollDOM, i = r.scrollTop * this.scaleY, { scrollAnchorPos: s, scrollAnchorHeight: o } = this.viewState;\n    Math.abs(i - this.viewState.scrollTop) > 1 && (o = -1), this.viewState.scrollAnchorHeight = -1;\n    try {\n      for (let a = 0; ; a++) {\n        if (o < 0)\n          if (tk(r))\n            s = -1, o = this.viewState.heightMap.height;\n          else {\n            let h = this.viewState.scrollAnchorAt(i);\n            s = h.from, o = h.top;\n          }\n        this.updateState = 1;\n        let l = this.viewState.measure(this);\n        if (!l && !this.measureRequests.length && this.viewState.scrollTarget == null)\n          break;\n        if (a > 5) {\n          console.warn(this.measureRequests.length ? \"Measure loop restarted more than 5 times\" : \"Viewport failed to stabilize\");\n          break;\n        }\n        let c = [];\n        l & 4 || ([this.measureRequests, c] = [c, this.measureRequests]);\n        let u = c.map((h) => {\n          try {\n            return h.read(this);\n          } catch (p) {\n            return hr(this.state, p), wv;\n          }\n        }), d = Wu.create(this, this.state, []), f = !1;\n        d.flags |= l, n ? n.flags |= l : n = d, this.updateState = 2, d.empty || (this.updatePlugins(d), this.inputState.update(d), this.updateAttrs(), f = this.docView.update(d));\n        for (let h = 0; h < c.length; h++)\n          if (u[h] != wv)\n            try {\n              let p = c[h];\n              p.write && p.write(u[h], this);\n            } catch (p) {\n              hr(this.state, p);\n            }\n        if (f && this.docView.updateSelection(!0), !d.viewportChanged && this.measureRequests.length == 0) {\n          if (this.viewState.editorHeight)\n            if (this.viewState.scrollTarget) {\n              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, o = -1;\n              continue;\n            } else {\n              let p = (s < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(s).top) - o;\n              if (p > 1 || p < -1) {\n                i = i + p, r.scrollTop = i / this.scaleY, o = -1;\n                continue;\n              }\n            }\n          break;\n        }\n      }\n    } finally {\n      this.updateState = 0, this.measureScheduled = -1;\n    }\n    if (n && !n.empty)\n      for (let a of this.state.facet(fp))\n        a(n);\n  }\n  /**\n  Get the CSS classes for the currently active editor themes.\n  */\n  get themeClasses() {\n    return gp + \" \" + (this.state.facet(Op) ? jk : Xk) + \" \" + this.state.facet(Ac);\n  }\n  updateAttrs() {\n    let e = kv(this, kk, {\n      class: \"cm-editor\" + (this.hasFocus ? \" cm-focused \" : \" \") + this.themeClasses\n    }), n = {\n      spellcheck: \"false\",\n      autocorrect: \"off\",\n      autocapitalize: \"off\",\n      translate: \"no\",\n      contenteditable: this.state.facet(Yd) ? \"true\" : \"false\",\n      class: \"cm-content\",\n      style: `${de.tabSize}: ${this.state.tabSize}`,\n      role: \"textbox\",\n      \"aria-multiline\": \"true\"\n    };\n    this.state.readOnly && (n[\"aria-readonly\"] = \"true\"), kv(this, cg, n);\n    let r = this.observer.ignore(() => {\n      let i = ap(this.contentDOM, this.contentAttrs, n), s = ap(this.dom, this.editorAttrs, e);\n      return i || s;\n    });\n    return this.editorAttrs = e, this.contentAttrs = n, r;\n  }\n  showAnnouncements(e) {\n    let n = !0;\n    for (let r of e)\n      for (let i of r.effects)\n        if (i.is(Se.announce)) {\n          n && (this.announceDOM.textContent = \"\"), n = !1;\n          let s = this.announceDOM.appendChild(document.createElement(\"div\"));\n          s.textContent = i.value;\n        }\n  }\n  mountStyles() {\n    this.styleModules = this.state.facet(Na);\n    let e = this.state.facet(Se.cspNonce);\n    ss.mount(this.root, this.styleModules.concat(A5).reverse(), e ? { nonce: e } : void 0);\n  }\n  readMeasured() {\n    if (this.updateState == 2)\n      throw new Error(\"Reading the editor layout isn't allowed during an update\");\n    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);\n  }\n  /**\n  Schedule a layout measurement, optionally providing callbacks to\n  do custom DOM measuring followed by a DOM write phase. Using\n  this is preferable reading DOM layout directly from, for\n  example, an event handler, because it'll make sure measuring and\n  drawing done by other components is synchronized, avoiding\n  unnecessary DOM layout computations.\n  */\n  requestMeasure(e) {\n    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {\n      if (this.measureRequests.indexOf(e) > -1)\n        return;\n      if (e.key != null) {\n        for (let n = 0; n < this.measureRequests.length; n++)\n          if (this.measureRequests[n].key === e.key) {\n            this.measureRequests[n] = e;\n            return;\n          }\n      }\n      this.measureRequests.push(e);\n    }\n  }\n  /**\n  Get the value of a specific plugin, if present. Note that\n  plugins that crash can be dropped from a view, so even when you\n  know you registered a given plugin, it is recommended to check\n  the return value of this method.\n  */\n  plugin(e) {\n    let n = this.pluginMap.get(e);\n    return (n === void 0 || n && n.spec != e) && this.pluginMap.set(e, n = this.plugins.find((r) => r.spec == e) || null), n && n.update(this).value;\n  }\n  /**\n  The top position of the document, in screen coordinates. This\n  may be negative when the editor is scrolled down. Points\n  directly to the top of the first line, not above the padding.\n  */\n  get documentTop() {\n    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;\n  }\n  /**\n  Reports the padding above and below the document.\n  */\n  get documentPadding() {\n    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };\n  }\n  /**\n  If the editor is transformed with CSS, this provides the scale\n  along the X axis. Otherwise, it will just be 1. Note that\n  transforms other than translation and scaling are not supported.\n  */\n  get scaleX() {\n    return this.viewState.scaleX;\n  }\n  /**\n  Provide the CSS transformed scale along the Y axis.\n  */\n  get scaleY() {\n    return this.viewState.scaleY;\n  }\n  /**\n  Find the text line or block widget at the given vertical\n  position (which is interpreted as relative to the [top of the\n  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).\n  */\n  elementAtHeight(e) {\n    return this.readMeasured(), this.viewState.elementAtHeight(e);\n  }\n  /**\n  Find the line block (see\n  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given\n  height, again interpreted relative to the [top of the\n  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).\n  */\n  lineBlockAtHeight(e) {\n    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);\n  }\n  /**\n  Get the extent and vertical position of all [line\n  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions\n  are relative to the [top of the\n  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);\n  */\n  get viewportLineBlocks() {\n    return this.viewState.viewportLines;\n  }\n  /**\n  Find the line block around the given document position. A line\n  block is a range delimited on both sides by either a\n  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line breaks, or the\n  start/end of the document. It will usually just hold a line of\n  text, but may be broken into multiple textblocks by block\n  widgets.\n  */\n  lineBlockAt(e) {\n    return this.viewState.lineBlockAt(e);\n  }\n  /**\n  The editor's total content height.\n  */\n  get contentHeight() {\n    return this.viewState.contentHeight;\n  }\n  /**\n  Move a cursor position by [grapheme\n  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether\n  the motion is away from the line start, or towards it. In\n  bidirectional text, the line is traversed in visual order, using\n  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).\n  When the start position was the last one on the line, the\n  returned position will be across the line break. If there is no\n  further line, the original position is returned.\n  \n  By default, this method moves over a single cluster. The\n  optional `by` argument can be used to move across more. It will\n  be called with the first cluster as argument, and should return\n  a predicate that determines, for each subsequent cluster,\n  whether it should also be moved over.\n  */\n  moveByChar(e, n, r) {\n    return Tf(this, e, sv(this, e, n, r));\n  }\n  /**\n  Move a cursor position across the next group of either\n  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter\n  non-whitespace characters.\n  */\n  moveByGroup(e, n) {\n    return Tf(this, e, sv(this, e, n, (r) => t5(this, e.head, r)));\n  }\n  /**\n  Get the cursor position visually at the start or end of a line.\n  Note that this may differ from the _logical_ position at its\n  start or end (which is simply at `line.from`/`line.to`) if text\n  at the start or end goes against the line's base text direction.\n  */\n  visualLineSide(e, n) {\n    let r = this.bidiSpans(e), i = this.textDirectionAt(e.from), s = r[n ? r.length - 1 : 0];\n    return ae.cursor(s.side(n, i) + e.from, s.forward(!n, i) ? 1 : -1);\n  }\n  /**\n  Move to the next line boundary in the given direction. If\n  `includeWrap` is true, line wrapping is on, and there is a\n  further wrap point on the current line, the wrap point will be\n  returned. Otherwise this function will return the start or end\n  of the line.\n  */\n  moveToLineBoundary(e, n, r = !0) {\n    return e5(this, e, n, r);\n  }\n  /**\n  Move a cursor position vertically. When `distance` isn't given,\n  it defaults to moving to the next line (including wrapped\n  lines). Otherwise, `distance` should provide a positive distance\n  in pixels.\n  \n  When `start` has a\n  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical\n  motion will use that as a target horizontal position. Otherwise,\n  the cursor's own horizontal position is used. The returned\n  cursor will have its goal column set to whichever column was\n  used.\n  */\n  moveVertically(e, n, r) {\n    return Tf(this, e, n5(this, e, n, r));\n  }\n  /**\n  Find the DOM parent node and offset (child offset if `node` is\n  an element, character offset when it is a text node) at the\n  given document position.\n  \n  Note that for positions that aren't currently in\n  `visibleRanges`, the resulting DOM position isn't necessarily\n  meaningful (it may just point before or after a placeholder\n  element).\n  */\n  domAtPos(e) {\n    return this.docView.domAtPos(e);\n  }\n  /**\n  Find the document position at the given DOM node. Can be useful\n  for associating positions with DOM events. Will raise an error\n  when `node` isn't part of the editor content.\n  */\n  posAtDOM(e, n = 0) {\n    return this.docView.posFromDOM(e, n);\n  }\n  posAtCoords(e, n = !0) {\n    return this.readMeasured(), Qk(this, e, n);\n  }\n  /**\n  Get the screen coordinates at the given document position.\n  `side` determines whether the coordinates are based on the\n  element before (-1) or after (1) the position (if no element is\n  available on the given side, the method will transparently use\n  another strategy to get reasonable coordinates).\n  */\n  coordsAtPos(e, n = 1) {\n    this.readMeasured();\n    let r = this.docView.coordsAt(e, n);\n    if (!r || r.left == r.right)\n      return r;\n    let i = this.state.doc.lineAt(e), s = this.bidiSpans(i), o = s[Bi.find(s, e - i.from, -1, n)];\n    return sg(r, o.dir == Qt.LTR == n > 0);\n  }\n  /**\n  Return the rectangle around a given character. If `pos` does not\n  point in front of a character that is in the viewport and\n  rendered (i.e. not replaced, not a line break), this will return\n  null. For space characters that are a line wrap point, this will\n  return the position before the line break.\n  */\n  coordsForChar(e) {\n    return this.readMeasured(), this.docView.coordsForChar(e);\n  }\n  /**\n  The default width of a character in the editor. May not\n  accurately reflect the width of all characters (given variable\n  width fonts or styling of invididual ranges).\n  */\n  get defaultCharacterWidth() {\n    return this.viewState.heightOracle.charWidth;\n  }\n  /**\n  The default height of a line in the editor. May not be accurate\n  for all lines.\n  */\n  get defaultLineHeight() {\n    return this.viewState.heightOracle.lineHeight;\n  }\n  /**\n  The text direction\n  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)\n  CSS property) of the editor's content element.\n  */\n  get textDirection() {\n    return this.viewState.defaultTextDirection;\n  }\n  /**\n  Find the text direction of the block at the given position, as\n  assigned by CSS. If\n  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)\n  isn't enabled, or the given position is outside of the viewport,\n  this will always return the same as\n  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that\n  this may trigger a DOM layout.\n  */\n  textDirectionAt(e) {\n    return !this.state.facet(wk) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));\n  }\n  /**\n  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)\n  (as determined by the\n  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)\n  CSS property of its content element).\n  */\n  get lineWrapping() {\n    return this.viewState.heightOracle.lineWrapping;\n  }\n  /**\n  Returns the bidirectional text structure of the given line\n  (which should be in the current document) as an array of span\n  objects. The order of these spans matches the [text\n  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)if that is\n  left-to-right, the leftmost spans come first, otherwise the\n  rightmost spans come first.\n  */\n  bidiSpans(e) {\n    if (e.length > B5)\n      return pk(e.length);\n    let n = this.textDirectionAt(e.from), r;\n    for (let s of this.bidiCache)\n      if (s.from == e.from && s.dir == n && (s.fresh || hk(s.isolates, r = Kb(this, e))))\n        return s.order;\n    r || (r = Kb(this, e));\n    let i = ZN(e.text, n, r);\n    return this.bidiCache.push(new Mu(e.from, e.to, n, r, !0, i)), i;\n  }\n  /**\n  Check whether the editor has focus.\n  */\n  get hasFocus() {\n    var e;\n    return (this.dom.ownerDocument.hasFocus() || de.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;\n  }\n  /**\n  Put focus on the editor.\n  */\n  focus() {\n    this.observer.ignore(() => {\n      Jw(this.contentDOM), this.docView.updateSelection();\n    });\n  }\n  /**\n  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only\n  necessary when moving the editor's existing DOM to a new window or shadow root.\n  */\n  setRoot(e) {\n    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());\n  }\n  /**\n  Clean up this editor view, removing its element from the\n  document, unregistering event handlers, and notifying\n  plugins. The view instance can no longer be used after\n  calling this.\n  */\n  destroy() {\n    for (let e of this.plugins)\n      e.destroy(this);\n    this.plugins = [], this.inputState.destroy(), this.docView.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;\n  }\n  /**\n  Returns an effect that can be\n  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to\n  cause it to scroll the given position or range into view.\n  */\n  static scrollIntoView(e, n = {}) {\n    return _c.of(new Eo(typeof e == \"number\" ? ae.cursor(e) : e, n.y, n.x, n.yMargin, n.xMargin));\n  }\n  /**\n  Return an effect that resets the editor to its current (at the\n  time this method was called) scroll position. Note that this\n  only affects the editor's own scrollable element, not parents.\n  See also\n  [`EditorViewConfig.scrollTo`](https://codemirror.net/6/docs/ref/#view.EditorViewConfig.scrollTo).\n  \n  The effect should be used with a document identical to the one\n  it was created for. Failing to do so is not an error, but may\n  not scroll to the expected position. You can\n  [map](https://codemirror.net/6/docs/ref/#state.StateEffect.map) the effect to account for changes.\n  */\n  scrollSnapshot() {\n    let { scrollTop: e, scrollLeft: n } = this.scrollDOM, r = this.viewState.scrollAnchorAt(e);\n    return _c.of(new Eo(ae.cursor(r.from), \"start\", \"start\", r.top - e, n, !0));\n  }\n  /**\n  Returns an extension that can be used to add DOM event handlers.\n  The value should be an object mapping event names to handler\n  functions. For any given event, such functions are ordered by\n  extension precedence, and the first handler to return true will\n  be assumed to have handled that event, and no other handlers or\n  built-in behavior will be activated for it. These are registered\n  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except\n  for `scroll` handlers, which will be called any time the\n  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of\n  its parent nodes is scrolled.\n  */\n  static domEventHandlers(e) {\n    return rr.define(() => ({}), { eventHandlers: e });\n  }\n  /**\n  Create an extension that registers DOM event observers. Contrary\n  to event [handlers](https://codemirror.net/6/docs/ref/#view.EditorView^domEventHandlers),\n  observers can't be prevented from running by a higher-precedence\n  handler returning true. They also don't prevent other handlers\n  and observers from running when they return true, and should not\n  call `preventDefault`.\n  */\n  static domEventObservers(e) {\n    return rr.define(() => ({}), { eventObservers: e });\n  }\n  /**\n  Create a theme extension. The first argument can be a\n  [`style-mod`](https://github.com/marijnh/style-mod#documentation)\n  style spec providing the styles for the theme. These will be\n  prefixed with a generated class for the style.\n  \n  Because the selectors will be prefixed with a scope class, rule\n  that directly match the editor's [wrapper\n  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)to which the scope class will be\n  addedneed to be explicitly differentiated by adding an `&` to\n  the selector for that elementfor example\n  `&.cm-focused`.\n  \n  When `dark` is set to true, the theme will be marked as dark,\n  which will cause the `&dark` rules from [base\n  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to\n  `&light` when a light theme is active).\n  */\n  static theme(e, n) {\n    let r = ss.newName(), i = [Ac.of(r), Na.of(mp(`.${r}`, e))];\n    return n && n.dark && i.push(Op.of(!0)), i;\n  }\n  /**\n  Create an extension that adds styles to the base theme. Like\n  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the\n  place of the editor wrapper element when directly targeting\n  that. You can also use `&dark` or `&light` instead to only\n  target editors with a dark or light theme.\n  */\n  static baseTheme(e) {\n    return zl.lowest(Na.of(mp(\".\" + gp, e, Bk)));\n  }\n  /**\n  Retrieve an editor view instance from the view's DOM\n  representation.\n  */\n  static findFromDOM(e) {\n    var n;\n    let r = e.querySelector(\".cm-content\"), i = r && ft.get(r) || ft.get(e);\n    return ((n = i == null ? void 0 : i.rootView) === null || n === void 0 ? void 0 : n.view) || null;\n  }\n}\nSe.styleModule = Na;\nSe.inputHandler = yk;\nSe.focusChangeEffect = Sk;\nSe.perLineTextDirection = wk;\nSe.exceptionSink = vk;\nSe.updateListener = fp;\nSe.editable = Yd;\nSe.mouseSelectionStyle = bk;\nSe.dragMovesSelection = mk;\nSe.clickAddsSelectionRange = gk;\nSe.decorations = ml;\nSe.outerDecorations = xk;\nSe.atomicRanges = ug;\nSe.bidiIsolatedRanges = Pk;\nSe.scrollMargins = _k;\nSe.darkTheme = Op;\nSe.cspNonce = /* @__PURE__ */ ve.define({ combine: (t) => t.length ? t[0] : \"\" });\nSe.contentAttributes = cg;\nSe.editorAttributes = kk;\nSe.lineWrapping = /* @__PURE__ */ Se.contentAttributes.of({ class: \"cm-lineWrapping\" });\nSe.announce = /* @__PURE__ */ ot.define();\nconst B5 = 4096, wv = {};\nclass Mu {\n  constructor(e, n, r, i, s, o) {\n    this.from = e, this.to = n, this.dir = r, this.isolates = i, this.fresh = s, this.order = o;\n  }\n  static update(e, n) {\n    if (n.empty && !e.some((s) => s.fresh))\n      return e;\n    let r = [], i = e.length ? e[e.length - 1].dir : Qt.LTR;\n    for (let s = Math.max(0, e.length - 10); s < e.length; s++) {\n      let o = e[s];\n      o.dir == i && !n.touchesRange(o.from, o.to) && r.push(new Mu(n.mapPos(o.from, 1), n.mapPos(o.to, -1), o.dir, o.isolates, !1, o.order));\n    }\n    return r;\n  }\n}\nfunction kv(t, e, n) {\n  for (let r = t.state.facet(e), i = r.length - 1; i >= 0; i--) {\n    let s = r[i], o = typeof s == \"function\" ? s(t) : s;\n    o && op(o, n);\n  }\n  return n;\n}\nconst L5 = de.mac ? \"mac\" : de.windows ? \"win\" : de.linux ? \"linux\" : \"key\";\nfunction U5(t, e) {\n  const n = t.split(/-(?!$)/);\n  let r = n[n.length - 1];\n  r == \"Space\" && (r = \" \");\n  let i, s, o, a;\n  for (let l = 0; l < n.length - 1; ++l) {\n    const c = n[l];\n    if (/^(cmd|meta|m)$/i.test(c))\n      a = !0;\n    else if (/^a(lt)?$/i.test(c))\n      i = !0;\n    else if (/^(c|ctrl|control)$/i.test(c))\n      s = !0;\n    else if (/^s(hift)?$/i.test(c))\n      o = !0;\n    else if (/^mod$/i.test(c))\n      e == \"mac\" ? a = !0 : s = !0;\n    else\n      throw new Error(\"Unrecognized modifier name: \" + c);\n  }\n  return i && (r = \"Alt-\" + r), s && (r = \"Ctrl-\" + r), a && (r = \"Meta-\" + r), o && (r = \"Shift-\" + r), r;\n}\nfunction Rc(t, e, n) {\n  return e.altKey && (t = \"Alt-\" + t), e.ctrlKey && (t = \"Ctrl-\" + t), e.metaKey && (t = \"Meta-\" + t), n !== !1 && e.shiftKey && (t = \"Shift-\" + t), t;\n}\nconst q5 = /* @__PURE__ */ zl.default(/* @__PURE__ */ Se.domEventHandlers({\n  keydown(t, e) {\n    return F5(Y5(e.state), t, e, \"editor\");\n  }\n})), bl = /* @__PURE__ */ ve.define({ enables: q5 }), xv = /* @__PURE__ */ new WeakMap();\nfunction Y5(t) {\n  let e = t.facet(bl), n = xv.get(e);\n  return n || xv.set(e, n = H5(e.reduce((r, i) => r.concat(i), []))), n;\n}\nlet Mi = null;\nconst z5 = 4e3;\nfunction H5(t, e = L5) {\n  let n = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ Object.create(null), i = (o, a) => {\n    let l = r[o];\n    if (l == null)\n      r[o] = a;\n    else if (l != a)\n      throw new Error(\"Key binding \" + o + \" is used both as a regular binding and as a multi-stroke prefix\");\n  }, s = (o, a, l, c, u) => {\n    var d, f;\n    let h = n[o] || (n[o] = /* @__PURE__ */ Object.create(null)), p = a.split(/ (?!$)/).map((y) => U5(y, e));\n    for (let y = 1; y < p.length; y++) {\n      let b = p.slice(0, y).join(\" \");\n      i(b, !0), h[b] || (h[b] = {\n        preventDefault: !0,\n        stopPropagation: !1,\n        run: [(g) => {\n          let v = Mi = { view: g, prefix: b, scope: o };\n          return setTimeout(() => {\n            Mi == v && (Mi = null);\n          }, z5), !0;\n        }]\n      });\n    }\n    let O = p.join(\" \");\n    i(O, !1);\n    let m = h[O] || (h[O] = {\n      preventDefault: !1,\n      stopPropagation: !1,\n      run: ((f = (d = h._any) === null || d === void 0 ? void 0 : d.run) === null || f === void 0 ? void 0 : f.slice()) || []\n    });\n    l && m.run.push(l), c && (m.preventDefault = !0), u && (m.stopPropagation = !0);\n  };\n  for (let o of t) {\n    let a = o.scope ? o.scope.split(\" \") : [\"editor\"];\n    if (o.any)\n      for (let c of a) {\n        let u = n[c] || (n[c] = /* @__PURE__ */ Object.create(null));\n        u._any || (u._any = { preventDefault: !1, stopPropagation: !1, run: [] });\n        for (let d in u)\n          u[d].run.push(o.any);\n      }\n    let l = o[e] || o.key;\n    if (l)\n      for (let c of a)\n        s(c, l, o.run, o.preventDefault, o.stopPropagation), o.shift && s(c, \"Shift-\" + l, o.shift, o.preventDefault, o.stopPropagation);\n  }\n  return n;\n}\nfunction F5(t, e, n, r) {\n  let i = mN(e), s = nn(i, 0), o = cr(s) == i.length && i != \" \", a = \"\", l = !1, c = !1, u = !1;\n  Mi && Mi.view == n && Mi.scope == r && (a = Mi.prefix + \" \", Ak.indexOf(e.keyCode) < 0 && (c = !0, Mi = null));\n  let d = /* @__PURE__ */ new Set(), f = (m) => {\n    if (m) {\n      for (let y of m.run)\n        if (!d.has(y) && (d.add(y), y(n, e)))\n          return m.stopPropagation && (u = !0), !0;\n      m.preventDefault && (m.stopPropagation && (u = !0), c = !0);\n    }\n    return !1;\n  }, h = t[r], p, O;\n  return h && (f(h[a + Rc(i, e, !o)]) ? l = !0 : o && (e.altKey || e.metaKey || e.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows\n  !(de.windows && e.ctrlKey && e.altKey) && (p = os[e.keyCode]) && p != i ? (f(h[a + Rc(p, e, !0)]) || e.shiftKey && (O = pl[e.keyCode]) != i && O != p && f(h[a + Rc(O, e, !1)])) && (l = !0) : o && e.shiftKey && f(h[a + Rc(i, e, !0)]) && (l = !0), !l && f(h._any) && (l = !0)), c && (l = !0), l && u && e.stopPropagation(), l;\n}\nfunction Pv(t, e, n, r, i) {\n  e.lastIndex = 0;\n  for (let s = t.iterRange(n, r), o = n, a; !s.next().done; o += s.value.length)\n    if (!s.lineBreak)\n      for (; a = e.exec(s.value); )\n        i(o + a.index, a);\n}\nfunction G5(t, e) {\n  let n = t.visibleRanges;\n  if (n.length == 1 && n[0].from == t.viewport.from && n[0].to == t.viewport.to)\n    return n;\n  let r = [];\n  for (let { from: i, to: s } of n)\n    i = Math.max(t.state.doc.lineAt(i).from, i - e), s = Math.min(t.state.doc.lineAt(s).to, s + e), r.length && r[r.length - 1].to >= i ? r[r.length - 1].to = s : r.push({ from: i, to: s });\n  return r;\n}\nclass Uk {\n  /**\n  Create a decorator.\n  */\n  constructor(e) {\n    const { regexp: n, decoration: r, decorate: i, boundary: s, maxLength: o = 1e3 } = e;\n    if (!n.global)\n      throw new RangeError(\"The regular expression given to MatchDecorator should have its 'g' flag set\");\n    if (this.regexp = n, i)\n      this.addMatch = (a, l, c, u) => i(u, c, c + a[0].length, a, l);\n    else if (typeof r == \"function\")\n      this.addMatch = (a, l, c, u) => {\n        let d = r(a, l, c);\n        d && u(c, c + a[0].length, d);\n      };\n    else if (r)\n      this.addMatch = (a, l, c, u) => u(c, c + a[0].length, r);\n    else\n      throw new RangeError(\"Either 'decorate' or 'decoration' should be provided to MatchDecorator\");\n    this.boundary = s, this.maxLength = o;\n  }\n  /**\n  Compute the full set of decorations for matches in the given\n  view's viewport. You'll want to call this when initializing your\n  plugin.\n  */\n  createDeco(e) {\n    let n = new jo(), r = n.add.bind(n);\n    for (let { from: i, to: s } of G5(e, this.maxLength))\n      Pv(e.state.doc, this.regexp, i, s, (o, a) => this.addMatch(a, e, o, r));\n    return n.finish();\n  }\n  /**\n  Update a set of decorations for a view update. `deco` _must_ be\n  the set of decorations produced by _this_ `MatchDecorator` for\n  the view state before the update.\n  */\n  updateDeco(e, n) {\n    let r = 1e9, i = -1;\n    return e.docChanged && e.changes.iterChanges((s, o, a, l) => {\n      l > e.view.viewport.from && a < e.view.viewport.to && (r = Math.min(a, r), i = Math.max(l, i));\n    }), e.viewportChanged || i - r > 1e3 ? this.createDeco(e.view) : i > -1 ? this.updateRange(e.view, n.map(e.changes), r, i) : n;\n  }\n  updateRange(e, n, r, i) {\n    for (let s of e.visibleRanges) {\n      let o = Math.max(s.from, r), a = Math.min(s.to, i);\n      if (a > o) {\n        let l = e.state.doc.lineAt(o), c = l.to < a ? e.state.doc.lineAt(a) : l, u = Math.max(s.from, l.from), d = Math.min(s.to, c.to);\n        if (this.boundary) {\n          for (; o > l.from; o--)\n            if (this.boundary.test(l.text[o - 1 - l.from])) {\n              u = o;\n              break;\n            }\n          for (; a < c.to; a++)\n            if (this.boundary.test(c.text[a - c.from])) {\n              d = a;\n              break;\n            }\n        }\n        let f = [], h, p = (O, m, y) => f.push(y.range(O, m));\n        if (l == c)\n          for (this.regexp.lastIndex = u - l.from; (h = this.regexp.exec(l.text)) && h.index < d - l.from; )\n            this.addMatch(h, e, h.index + l.from, p);\n        else\n          Pv(e.state.doc, this.regexp, u, d, (O, m) => this.addMatch(m, e, O, p));\n        n = n.update({ filterFrom: u, filterTo: d, filter: (O, m) => O < u || m > d, add: f });\n      }\n    }\n    return n;\n  }\n}\nconst bp = /x/.unicode != null ? \"gu\" : \"g\", K5 = /* @__PURE__ */ new RegExp(`[\\0-\\b\n-\u001f-\\u2028\\u2029\\uFEFF-]`, bp), J5 = {\n  0: \"null\",\n  7: \"bell\",\n  8: \"backspace\",\n  10: \"newline\",\n  11: \"vertical tab\",\n  13: \"carriage return\",\n  27: \"escape\",\n  8203: \"zero width space\",\n  8204: \"zero width non-joiner\",\n  8205: \"zero width joiner\",\n  8206: \"left-to-right mark\",\n  8207: \"right-to-left mark\",\n  8232: \"line separator\",\n  8237: \"left-to-right override\",\n  8238: \"right-to-left override\",\n  8294: \"left-to-right isolate\",\n  8295: \"right-to-left isolate\",\n  8297: \"pop directional isolate\",\n  8233: \"paragraph separator\",\n  65279: \"zero width no-break space\",\n  65532: \"object replacement\"\n};\nlet Qf = null;\nfunction eD() {\n  var t;\n  if (Qf == null && typeof document < \"u\" && document.body) {\n    let e = document.body.style;\n    Qf = ((t = e.tabSize) !== null && t !== void 0 ? t : e.MozTabSize) != null;\n  }\n  return Qf || !1;\n}\nconst ou = /* @__PURE__ */ ve.define({\n  combine(t) {\n    let e = Ud(t, {\n      render: null,\n      specialChars: K5,\n      addSpecialChars: null\n    });\n    return (e.replaceTabs = !eD()) && (e.specialChars = new RegExp(\"\t|\" + e.specialChars.source, bp)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + \"|\" + e.addSpecialChars.source, bp)), e;\n  }\n});\nfunction tD(t = {}) {\n  return [ou.of(t), nD()];\n}\nlet _v = null;\nfunction nD() {\n  return _v || (_v = rr.fromClass(class {\n    constructor(t) {\n      this.view = t, this.decorations = Je.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(t.state.facet(ou)), this.decorations = this.decorator.createDeco(t);\n    }\n    makeDecorator(t) {\n      return new Uk({\n        regexp: t.specialChars,\n        decoration: (e, n, r) => {\n          let { doc: i } = n.state, s = nn(e[0], 0);\n          if (s == 9) {\n            let o = i.lineAt(r), a = n.state.tabSize, l = ig(o.text, a, r - o.from);\n            return Je.replace({\n              widget: new oD((a - l % a) * this.view.defaultCharacterWidth / this.view.scaleX)\n            });\n          }\n          return this.decorationCache[s] || (this.decorationCache[s] = Je.replace({ widget: new sD(t, s) }));\n        },\n        boundary: t.replaceTabs ? void 0 : /[^]/\n      });\n    }\n    update(t) {\n      let e = t.state.facet(ou);\n      t.startState.facet(ou) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(t.view)) : this.decorations = this.decorator.updateDeco(t, this.decorations);\n    }\n  }, {\n    decorations: (t) => t.decorations\n  }));\n}\nconst rD = \"\";\nfunction iD(t) {\n  return t >= 32 ? rD : t == 10 ? \"\" : String.fromCharCode(9216 + t);\n}\nclass sD extends ra {\n  constructor(e, n) {\n    super(), this.options = e, this.code = n;\n  }\n  eq(e) {\n    return e.code == this.code;\n  }\n  toDOM(e) {\n    let n = iD(this.code), r = e.state.phrase(\"Control character\") + \" \" + (J5[this.code] || \"0x\" + this.code.toString(16)), i = this.options.render && this.options.render(this.code, r, n);\n    if (i)\n      return i;\n    let s = document.createElement(\"span\");\n    return s.textContent = n, s.title = r, s.setAttribute(\"aria-label\", r), s.className = \"cm-specialChar\", s;\n  }\n  ignoreEvent() {\n    return !1;\n  }\n}\nclass oD extends ra {\n  constructor(e) {\n    super(), this.width = e;\n  }\n  eq(e) {\n    return e.width == this.width;\n  }\n  toDOM() {\n    let e = document.createElement(\"span\");\n    return e.textContent = \"\t\", e.className = \"cm-tab\", e.style.width = this.width + \"px\", e;\n  }\n  ignoreEvent() {\n    return !1;\n  }\n}\nconst ya = \"-10000px\";\nclass aD {\n  constructor(e, n, r, i) {\n    this.facet = n, this.createTooltipView = r, this.removeTooltipView = i, this.input = e.state.facet(n), this.tooltips = this.input.filter((o) => o);\n    let s = null;\n    this.tooltipViews = this.tooltips.map((o) => s = r(o, s));\n  }\n  update(e, n) {\n    var r;\n    let i = e.state.facet(this.facet), s = i.filter((l) => l);\n    if (i === this.input) {\n      for (let l of this.tooltipViews)\n        l.update && l.update(e);\n      return !1;\n    }\n    let o = [], a = n ? [] : null;\n    for (let l = 0; l < s.length; l++) {\n      let c = s[l], u = -1;\n      if (c) {\n        for (let d = 0; d < this.tooltips.length; d++) {\n          let f = this.tooltips[d];\n          f && f.create == c.create && (u = d);\n        }\n        if (u < 0)\n          o[l] = this.createTooltipView(c, l ? o[l - 1] : null), a && (a[l] = !!c.above);\n        else {\n          let d = o[l] = this.tooltipViews[u];\n          a && (a[l] = n[u]), d.update && d.update(e);\n        }\n      }\n    }\n    for (let l of this.tooltipViews)\n      o.indexOf(l) < 0 && (this.removeTooltipView(l), (r = l.destroy) === null || r === void 0 || r.call(l));\n    return n && (a.forEach((l, c) => n[c] = l), n.length = a.length), this.input = i, this.tooltips = s, this.tooltipViews = o, !0;\n  }\n}\nfunction lD(t) {\n  let { win: e } = t;\n  return { top: 0, left: 0, bottom: e.innerHeight, right: e.innerWidth };\n}\nconst Cf = /* @__PURE__ */ ve.define({\n  combine: (t) => {\n    var e, n, r;\n    return {\n      position: de.ios ? \"absolute\" : ((e = t.find((i) => i.position)) === null || e === void 0 ? void 0 : e.position) || \"fixed\",\n      parent: ((n = t.find((i) => i.parent)) === null || n === void 0 ? void 0 : n.parent) || null,\n      tooltipSpace: ((r = t.find((i) => i.tooltipSpace)) === null || r === void 0 ? void 0 : r.tooltipSpace) || lD\n    };\n  }\n}), Tv = /* @__PURE__ */ new WeakMap(), qk = /* @__PURE__ */ rr.fromClass(class {\n  constructor(t) {\n    this.view = t, this.above = [], this.inView = !0, this.madeAbsolute = !1, this.lastTransaction = 0, this.measureTimeout = -1;\n    let e = t.state.facet(Cf);\n    this.position = e.position, this.parent = e.parent, this.classes = t.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.resizeObserver = typeof ResizeObserver == \"function\" ? new ResizeObserver(() => this.measureSoon()) : null, this.manager = new aD(t, Yk, (n, r) => this.createTooltip(n, r), (n) => {\n      this.resizeObserver && this.resizeObserver.unobserve(n.dom), n.dom.remove();\n    }), this.above = this.manager.tooltips.map((n) => !!n.above), this.intersectionObserver = typeof IntersectionObserver == \"function\" ? new IntersectionObserver((n) => {\n      Date.now() > this.lastTransaction - 50 && n.length > 0 && n[n.length - 1].intersectionRatio < 1 && this.measureSoon();\n    }, { threshold: [1] }) : null, this.observeIntersection(), t.win.addEventListener(\"resize\", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();\n  }\n  createContainer() {\n    this.parent ? (this.container = document.createElement(\"div\"), this.container.style.position = \"relative\", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;\n  }\n  observeIntersection() {\n    if (this.intersectionObserver) {\n      this.intersectionObserver.disconnect();\n      for (let t of this.manager.tooltipViews)\n        this.intersectionObserver.observe(t.dom);\n    }\n  }\n  measureSoon() {\n    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {\n      this.measureTimeout = -1, this.maybeMeasure();\n    }, 50));\n  }\n  update(t) {\n    t.transactions.length && (this.lastTransaction = Date.now());\n    let e = this.manager.update(t, this.above);\n    e && this.observeIntersection();\n    let n = e || t.geometryChanged, r = t.state.facet(Cf);\n    if (r.position != this.position && !this.madeAbsolute) {\n      this.position = r.position;\n      for (let i of this.manager.tooltipViews)\n        i.dom.style.position = this.position;\n      n = !0;\n    }\n    if (r.parent != this.parent) {\n      this.parent && this.container.remove(), this.parent = r.parent, this.createContainer();\n      for (let i of this.manager.tooltipViews)\n        this.container.appendChild(i.dom);\n      n = !0;\n    } else\n      this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);\n    n && this.maybeMeasure();\n  }\n  createTooltip(t, e) {\n    let n = t.create(this.view), r = e ? e.dom : null;\n    if (n.dom.classList.add(\"cm-tooltip\"), t.arrow && !n.dom.querySelector(\".cm-tooltip > .cm-tooltip-arrow\")) {\n      let i = document.createElement(\"div\");\n      i.className = \"cm-tooltip-arrow\", n.dom.insertBefore(i, r);\n    }\n    return n.dom.style.position = this.position, n.dom.style.top = ya, n.dom.style.left = \"0px\", this.container.insertBefore(n.dom, r), n.mount && n.mount(this.view), this.resizeObserver && this.resizeObserver.observe(n.dom), n;\n  }\n  destroy() {\n    var t, e, n;\n    this.view.win.removeEventListener(\"resize\", this.measureSoon);\n    for (let r of this.manager.tooltipViews)\n      r.dom.remove(), (t = r.destroy) === null || t === void 0 || t.call(r);\n    this.parent && this.container.remove(), (e = this.resizeObserver) === null || e === void 0 || e.disconnect(), (n = this.intersectionObserver) === null || n === void 0 || n.disconnect(), clearTimeout(this.measureTimeout);\n  }\n  readMeasure() {\n    let t = this.view.dom.getBoundingClientRect(), e = 1, n = 1, r = !1;\n    if (this.position == \"fixed\" && this.manager.tooltipViews.length) {\n      let { dom: i } = this.manager.tooltipViews[0];\n      if (de.gecko)\n        r = i.offsetParent != this.container.ownerDocument.body;\n      else if (i.style.top == ya && i.style.left == \"0px\") {\n        let s = i.getBoundingClientRect();\n        r = Math.abs(s.top + 1e4) > 1 || Math.abs(s.left) > 1;\n      }\n    }\n    if (r || this.position == \"absolute\")\n      if (this.parent) {\n        let i = this.parent.getBoundingClientRect();\n        i.width && i.height && (e = i.width / this.parent.offsetWidth, n = i.height / this.parent.offsetHeight);\n      } else\n        ({ scaleX: e, scaleY: n } = this.view.viewState);\n    return {\n      editor: t,\n      parent: this.parent ? this.container.getBoundingClientRect() : t,\n      pos: this.manager.tooltips.map((i, s) => {\n        let o = this.manager.tooltipViews[s];\n        return o.getCoords ? o.getCoords(i.pos) : this.view.coordsAtPos(i.pos);\n      }),\n      size: this.manager.tooltipViews.map(({ dom: i }) => i.getBoundingClientRect()),\n      space: this.view.state.facet(Cf).tooltipSpace(this.view),\n      scaleX: e,\n      scaleY: n,\n      makeAbsolute: r\n    };\n  }\n  writeMeasure(t) {\n    var e;\n    if (t.makeAbsolute) {\n      this.madeAbsolute = !0, this.position = \"absolute\";\n      for (let a of this.manager.tooltipViews)\n        a.dom.style.position = \"absolute\";\n    }\n    let { editor: n, space: r, scaleX: i, scaleY: s } = t, o = [];\n    for (let a = 0; a < this.manager.tooltips.length; a++) {\n      let l = this.manager.tooltips[a], c = this.manager.tooltipViews[a], { dom: u } = c, d = t.pos[a], f = t.size[a];\n      if (!d || d.bottom <= Math.max(n.top, r.top) || d.top >= Math.min(n.bottom, r.bottom) || d.right < Math.max(n.left, r.left) - 0.1 || d.left > Math.min(n.right, r.right) + 0.1) {\n        u.style.top = ya;\n        continue;\n      }\n      let h = l.arrow ? c.dom.querySelector(\".cm-tooltip-arrow\") : null, p = h ? 7 : 0, O = f.right - f.left, m = (e = Tv.get(c)) !== null && e !== void 0 ? e : f.bottom - f.top, y = c.offset || uD, b = this.view.textDirection == Qt.LTR, g = f.width > r.right - r.left ? b ? r.left : r.right - f.width : b ? Math.min(d.left - (h ? 14 : 0) + y.x, r.right - O) : Math.max(r.left, d.left - O + (h ? 14 : 0) - y.x), v = this.above[a];\n      !l.strictSide && (v ? d.top - (f.bottom - f.top) - y.y < r.top : d.bottom + (f.bottom - f.top) + y.y > r.bottom) && v == r.bottom - d.bottom > d.top - r.top && (v = this.above[a] = !v);\n      let S = (v ? d.top - r.top : r.bottom - d.bottom) - p;\n      if (S < m && c.resize !== !1) {\n        if (S < this.view.defaultLineHeight) {\n          u.style.top = ya;\n          continue;\n        }\n        Tv.set(c, m), u.style.height = (m = S) / s + \"px\";\n      } else\n        u.style.height && (u.style.height = \"\");\n      let w = v ? d.top - m - p - y.y : d.bottom + p + y.y, k = g + O;\n      if (c.overlap !== !0)\n        for (let _ of o)\n          _.left < k && _.right > g && _.top < w + m && _.bottom > w && (w = v ? _.top - m - 2 - p : _.bottom + p + 2);\n      if (this.position == \"absolute\" ? (u.style.top = (w - t.parent.top) / s + \"px\", u.style.left = (g - t.parent.left) / i + \"px\") : (u.style.top = w / s + \"px\", u.style.left = g / i + \"px\"), h) {\n        let _ = d.left + (b ? y.x : -y.x) - (g + 14 - 7);\n        h.style.left = _ / i + \"px\";\n      }\n      c.overlap !== !0 && o.push({ left: g, top: w, right: k, bottom: w + m }), u.classList.toggle(\"cm-tooltip-above\", v), u.classList.toggle(\"cm-tooltip-below\", !v), c.positioned && c.positioned(t.space);\n    }\n  }\n  maybeMeasure() {\n    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))\n      for (let t of this.manager.tooltipViews)\n        t.dom.style.top = ya;\n  }\n}, {\n  eventObservers: {\n    scroll() {\n      this.maybeMeasure();\n    }\n  }\n}), cD = /* @__PURE__ */ Se.baseTheme({\n  \".cm-tooltip\": {\n    zIndex: 100,\n    boxSizing: \"border-box\"\n  },\n  \"&light .cm-tooltip\": {\n    border: \"1px solid #bbb\",\n    backgroundColor: \"#f5f5f5\"\n  },\n  \"&light .cm-tooltip-section:not(:first-child)\": {\n    borderTop: \"1px solid #bbb\"\n  },\n  \"&dark .cm-tooltip\": {\n    backgroundColor: \"#333338\",\n    color: \"white\"\n  },\n  \".cm-tooltip-arrow\": {\n    height: \"7px\",\n    width: `${7 * 2}px`,\n    position: \"absolute\",\n    zIndex: -1,\n    overflow: \"hidden\",\n    \"&:before, &:after\": {\n      content: \"''\",\n      position: \"absolute\",\n      width: 0,\n      height: 0,\n      borderLeft: \"7px solid transparent\",\n      borderRight: \"7px solid transparent\"\n    },\n    \".cm-tooltip-above &\": {\n      bottom: \"-7px\",\n      \"&:before\": {\n        borderTop: \"7px solid #bbb\"\n      },\n      \"&:after\": {\n        borderTop: \"7px solid #f5f5f5\",\n        bottom: \"1px\"\n      }\n    },\n    \".cm-tooltip-below &\": {\n      top: \"-7px\",\n      \"&:before\": {\n        borderBottom: \"7px solid #bbb\"\n      },\n      \"&:after\": {\n        borderBottom: \"7px solid #f5f5f5\",\n        top: \"1px\"\n      }\n    }\n  },\n  \"&dark .cm-tooltip .cm-tooltip-arrow\": {\n    \"&:before\": {\n      borderTopColor: \"#333338\",\n      borderBottomColor: \"#333338\"\n    },\n    \"&:after\": {\n      borderTopColor: \"transparent\",\n      borderBottomColor: \"transparent\"\n    }\n  }\n}), uD = { x: 0, y: 0 }, Yk = /* @__PURE__ */ ve.define({\n  enables: [qk, cD]\n});\nfunction zk(t, e) {\n  let n = t.plugin(qk);\n  if (!n)\n    return null;\n  let r = n.manager.tooltips.indexOf(e);\n  return r < 0 ? null : n.manager.tooltipViews[r];\n}\nclass Hs extends qs {\n  /**\n  @internal\n  */\n  compare(e) {\n    return this == e || this.constructor == e.constructor && this.eq(e);\n  }\n  /**\n  Compare this marker to another marker of the same type.\n  */\n  eq(e) {\n    return !1;\n  }\n  /**\n  Called if the marker has a `toDOM` method and its representation\n  was removed from a gutter.\n  */\n  destroy(e) {\n  }\n}\nHs.prototype.elementClass = \"\";\nHs.prototype.toDOM = void 0;\nHs.prototype.mapMode = on.TrackBefore;\nHs.prototype.startSide = Hs.prototype.endSide = -1;\nHs.prototype.point = !0;\nconst Af = /* @__PURE__ */ ve.define(), au = /* @__PURE__ */ ve.define(), vp = /* @__PURE__ */ ve.define({\n  combine: (t) => t.some((e) => e)\n});\nfunction dD(t) {\n  let e = [\n    fD\n  ];\n  return t && t.fixed === !1 && e.push(vp.of(!0)), e;\n}\nconst fD = /* @__PURE__ */ rr.fromClass(class {\n  constructor(t) {\n    this.view = t, this.prevViewport = t.viewport, this.dom = document.createElement(\"div\"), this.dom.className = \"cm-gutters\", this.dom.setAttribute(\"aria-hidden\", \"true\"), this.dom.style.minHeight = this.view.contentHeight / this.view.scaleY + \"px\", this.gutters = t.state.facet(au).map((e) => new $v(t, e));\n    for (let e of this.gutters)\n      this.dom.appendChild(e.dom);\n    this.fixed = !t.state.facet(vp), this.fixed && (this.dom.style.position = \"sticky\"), this.syncGutters(!1), t.scrollDOM.insertBefore(this.dom, t.contentDOM);\n  }\n  update(t) {\n    if (this.updateGutters(t)) {\n      let e = this.prevViewport, n = t.view.viewport, r = Math.min(e.to, n.to) - Math.max(e.from, n.from);\n      this.syncGutters(r < (n.to - n.from) * 0.8);\n    }\n    t.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight + \"px\"), this.view.state.facet(vp) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? \"sticky\" : \"\"), this.prevViewport = t.view.viewport;\n  }\n  syncGutters(t) {\n    let e = this.dom.nextSibling;\n    t && this.dom.remove();\n    let n = ze.iter(this.view.state.facet(Af), this.view.viewport.from), r = [], i = this.gutters.map((s) => new hD(s, this.view.viewport, -this.view.documentPadding.top));\n    for (let s of this.view.viewportLineBlocks)\n      if (r.length && (r = []), Array.isArray(s.type)) {\n        let o = !0;\n        for (let a of s.type)\n          if (a.type == fr.Text && o) {\n            yp(n, r, a.from);\n            for (let l of i)\n              l.line(this.view, a, r);\n            o = !1;\n          } else if (a.widget)\n            for (let l of i)\n              l.widget(this.view, a);\n      } else if (s.type == fr.Text) {\n        yp(n, r, s.from);\n        for (let o of i)\n          o.line(this.view, s, r);\n      } else if (s.widget)\n        for (let o of i)\n          o.widget(this.view, s);\n    for (let s of i)\n      s.finish();\n    t && this.view.scrollDOM.insertBefore(this.dom, e);\n  }\n  updateGutters(t) {\n    let e = t.startState.facet(au), n = t.state.facet(au), r = t.docChanged || t.heightChanged || t.viewportChanged || !ze.eq(t.startState.facet(Af), t.state.facet(Af), t.view.viewport.from, t.view.viewport.to);\n    if (e == n)\n      for (let i of this.gutters)\n        i.update(t) && (r = !0);\n    else {\n      r = !0;\n      let i = [];\n      for (let s of n) {\n        let o = e.indexOf(s);\n        o < 0 ? i.push(new $v(this.view, s)) : (this.gutters[o].update(t), i.push(this.gutters[o]));\n      }\n      for (let s of this.gutters)\n        s.dom.remove(), i.indexOf(s) < 0 && s.destroy();\n      for (let s of i)\n        this.dom.appendChild(s.dom);\n      this.gutters = i;\n    }\n    return r;\n  }\n  destroy() {\n    for (let t of this.gutters)\n      t.destroy();\n    this.dom.remove();\n  }\n}, {\n  provide: (t) => Se.scrollMargins.of((e) => {\n    let n = e.plugin(t);\n    return !n || n.gutters.length == 0 || !n.fixed ? null : e.textDirection == Qt.LTR ? { left: n.dom.offsetWidth * e.scaleX } : { right: n.dom.offsetWidth * e.scaleX };\n  })\n});\nfunction Ev(t) {\n  return Array.isArray(t) ? t : [t];\n}\nfunction yp(t, e, n) {\n  for (; t.value && t.from <= n; )\n    t.from == n && e.push(t.value), t.next();\n}\nclass hD {\n  constructor(e, n, r) {\n    this.gutter = e, this.height = r, this.i = 0, this.cursor = ze.iter(e.markers, n.from);\n  }\n  addElement(e, n, r) {\n    let { gutter: i } = this, s = (n.top - this.height) / e.scaleY, o = n.height / e.scaleY;\n    if (this.i == i.elements.length) {\n      let a = new Hk(e, o, s, r);\n      i.elements.push(a), i.dom.appendChild(a.dom);\n    } else\n      i.elements[this.i].update(e, o, s, r);\n    this.height = n.bottom, this.i++;\n  }\n  line(e, n, r) {\n    let i = [];\n    yp(this.cursor, i, n.from), r.length && (i = i.concat(r));\n    let s = this.gutter.config.lineMarker(e, n, i);\n    s && i.unshift(s);\n    let o = this.gutter;\n    i.length == 0 && !o.config.renderEmptyElements || this.addElement(e, n, i);\n  }\n  widget(e, n) {\n    let r = this.gutter.config.widgetMarker(e, n.widget, n);\n    r && this.addElement(e, n, [r]);\n  }\n  finish() {\n    let e = this.gutter;\n    for (; e.elements.length > this.i; ) {\n      let n = e.elements.pop();\n      e.dom.removeChild(n.dom), n.destroy();\n    }\n  }\n}\nclass $v {\n  constructor(e, n) {\n    this.view = e, this.config = n, this.elements = [], this.spacer = null, this.dom = document.createElement(\"div\"), this.dom.className = \"cm-gutter\" + (this.config.class ? \" \" + this.config.class : \"\");\n    for (let r in n.domEventHandlers)\n      this.dom.addEventListener(r, (i) => {\n        let s = i.target, o;\n        if (s != this.dom && this.dom.contains(s)) {\n          for (; s.parentNode != this.dom; )\n            s = s.parentNode;\n          let l = s.getBoundingClientRect();\n          o = (l.top + l.bottom) / 2;\n        } else\n          o = i.clientY;\n        let a = e.lineBlockAtHeight(o - e.documentTop);\n        n.domEventHandlers[r](e, a, i) && i.preventDefault();\n      });\n    this.markers = Ev(n.markers(e)), n.initialSpacer && (this.spacer = new Hk(e, 0, 0, [n.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += \"visibility: hidden; pointer-events: none\");\n  }\n  update(e) {\n    let n = this.markers;\n    if (this.markers = Ev(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {\n      let i = this.config.updateSpacer(this.spacer.markers[0], e);\n      i != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [i]);\n    }\n    let r = e.view.viewport;\n    return !ze.eq(this.markers, n, r.from, r.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);\n  }\n  destroy() {\n    for (let e of this.elements)\n      e.destroy();\n  }\n}\nclass Hk {\n  constructor(e, n, r, i) {\n    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement(\"div\"), this.dom.className = \"cm-gutterElement\", this.update(e, n, r, i);\n  }\n  update(e, n, r, i) {\n    this.height != n && (this.height = n, this.dom.style.height = n + \"px\"), this.above != r && (this.dom.style.marginTop = (this.above = r) ? r + \"px\" : \"\"), pD(this.markers, i) || this.setMarkers(e, i);\n  }\n  setMarkers(e, n) {\n    let r = \"cm-gutterElement\", i = this.dom.firstChild;\n    for (let s = 0, o = 0; ; ) {\n      let a = o, l = s < n.length ? n[s++] : null, c = !1;\n      if (l) {\n        let u = l.elementClass;\n        u && (r += \" \" + u);\n        for (let d = o; d < this.markers.length; d++)\n          if (this.markers[d].compare(l)) {\n            a = d, c = !0;\n            break;\n          }\n      } else\n        a = this.markers.length;\n      for (; o < a; ) {\n        let u = this.markers[o++];\n        if (u.toDOM) {\n          u.destroy(i);\n          let d = i.nextSibling;\n          i.remove(), i = d;\n        }\n      }\n      if (!l)\n        break;\n      l.toDOM && (c ? i = i.nextSibling : this.dom.insertBefore(l.toDOM(e), i)), c && o++;\n    }\n    this.dom.className = r, this.markers = n;\n  }\n  destroy() {\n    this.setMarkers(null, []);\n  }\n}\nfunction pD(t, e) {\n  if (t.length != e.length)\n    return !1;\n  for (let n = 0; n < t.length; n++)\n    if (!t[n].compare(e[n]))\n      return !1;\n  return !0;\n}\nconst OD = /* @__PURE__ */ ve.define(), po = /* @__PURE__ */ ve.define({\n  combine(t) {\n    return Ud(t, { formatNumber: String, domEventHandlers: {} }, {\n      domEventHandlers(e, n) {\n        let r = Object.assign({}, e);\n        for (let i in n) {\n          let s = r[i], o = n[i];\n          r[i] = s ? (a, l, c) => s(a, l, c) || o(a, l, c) : o;\n        }\n        return r;\n      }\n    });\n  }\n});\nclass Rf extends Hs {\n  constructor(e) {\n    super(), this.number = e;\n  }\n  eq(e) {\n    return this.number == e.number;\n  }\n  toDOM() {\n    return document.createTextNode(this.number);\n  }\n}\nfunction Nf(t, e) {\n  return t.state.facet(po).formatNumber(e, t.state);\n}\nconst gD = /* @__PURE__ */ au.compute([po], (t) => ({\n  class: \"cm-lineNumbers\",\n  renderEmptyElements: !1,\n  markers(e) {\n    return e.state.facet(OD);\n  },\n  lineMarker(e, n, r) {\n    return r.some((i) => i.toDOM) ? null : new Rf(Nf(e, e.state.doc.lineAt(n.from).number));\n  },\n  widgetMarker: () => null,\n  lineMarkerChange: (e) => e.startState.facet(po) != e.state.facet(po),\n  initialSpacer(e) {\n    return new Rf(Nf(e, Qv(e.state.doc.lines)));\n  },\n  updateSpacer(e, n) {\n    let r = Nf(n.view, Qv(n.view.state.doc.lines));\n    return r == e.number ? e : new Rf(r);\n  },\n  domEventHandlers: t.facet(po).domEventHandlers\n}));\nfunction mD(t = {}) {\n  return [\n    po.of(t),\n    dD(),\n    gD\n  ];\n}\nfunction Qv(t) {\n  let e = 9;\n  for (; e < t; )\n    e = e * 10 + 9;\n  return e;\n}\nconst Fk = 1024;\nlet bD = 0;\nclass Fn {\n  constructor(e, n) {\n    this.from = e, this.to = n;\n  }\n}\nclass Re {\n  /**\n  Create a new node prop type.\n  */\n  constructor(e = {}) {\n    this.id = bD++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {\n      throw new Error(\"This node type doesn't define a deserialize function\");\n    });\n  }\n  /**\n  This is meant to be used with\n  [`NodeSet.extend`](#common.NodeSet.extend) or\n  [`LRParser.configure`](#lr.ParserConfig.props) to compute\n  prop values for each node type in the set. Takes a [match\n  object](#common.NodeType^match) or function that returns undefined\n  if the node type doesn't get this prop, and the prop's value if\n  it does.\n  */\n  add(e) {\n    if (this.perNode)\n      throw new RangeError(\"Can't add per-node props to node types\");\n    return typeof e != \"function\" && (e = On.match(e)), (n) => {\n      let r = e(n);\n      return r === void 0 ? null : [this, r];\n    };\n  }\n}\nRe.closedBy = new Re({ deserialize: (t) => t.split(\" \") });\nRe.openedBy = new Re({ deserialize: (t) => t.split(\" \") });\nRe.group = new Re({ deserialize: (t) => t.split(\" \") });\nRe.isolate = new Re({ deserialize: (t) => {\n  if (t && t != \"rtl\" && t != \"ltr\" && t != \"auto\")\n    throw new RangeError(\"Invalid value for isolate: \" + t);\n  return t || \"auto\";\n} });\nRe.contextHash = new Re({ perNode: !0 });\nRe.lookAhead = new Re({ perNode: !0 });\nRe.mounted = new Re({ perNode: !0 });\nclass vl {\n  constructor(e, n, r) {\n    this.tree = e, this.overlay = n, this.parser = r;\n  }\n  /**\n  @internal\n  */\n  static get(e) {\n    return e && e.props && e.props[Re.mounted.id];\n  }\n}\nconst vD = /* @__PURE__ */ Object.create(null);\nclass On {\n  /**\n  @internal\n  */\n  constructor(e, n, r, i = 0) {\n    this.name = e, this.props = n, this.id = r, this.flags = i;\n  }\n  /**\n  Define a node type.\n  */\n  static define(e) {\n    let n = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : vD, r = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), i = new On(e.name || \"\", n, e.id, r);\n    if (e.props) {\n      for (let s of e.props)\n        if (Array.isArray(s) || (s = s(i)), s) {\n          if (s[0].perNode)\n            throw new RangeError(\"Can't store a per-node prop on a node type\");\n          n[s[0].id] = s[1];\n        }\n    }\n    return i;\n  }\n  /**\n  Retrieves a node prop for this type. Will return `undefined` if\n  the prop isn't present on this node.\n  */\n  prop(e) {\n    return this.props[e.id];\n  }\n  /**\n  True when this is the top node of a grammar.\n  */\n  get isTop() {\n    return (this.flags & 1) > 0;\n  }\n  /**\n  True when this node is produced by a skip rule.\n  */\n  get isSkipped() {\n    return (this.flags & 2) > 0;\n  }\n  /**\n  Indicates whether this is an error node.\n  */\n  get isError() {\n    return (this.flags & 4) > 0;\n  }\n  /**\n  When true, this node type doesn't correspond to a user-declared\n  named node, for example because it is used to cache repetition.\n  */\n  get isAnonymous() {\n    return (this.flags & 8) > 0;\n  }\n  /**\n  Returns true when this node's name or one of its\n  [groups](#common.NodeProp^group) matches the given string.\n  */\n  is(e) {\n    if (typeof e == \"string\") {\n      if (this.name == e)\n        return !0;\n      let n = this.prop(Re.group);\n      return n ? n.indexOf(e) > -1 : !1;\n    }\n    return this.id == e;\n  }\n  /**\n  Create a function from node types to arbitrary values by\n  specifying an object whose property names are node or\n  [group](#common.NodeProp^group) names. Often useful with\n  [`NodeProp.add`](#common.NodeProp.add). You can put multiple\n  names, separated by spaces, in a single property name to map\n  multiple node names to a single value.\n  */\n  static match(e) {\n    let n = /* @__PURE__ */ Object.create(null);\n    for (let r in e)\n      for (let i of r.split(\" \"))\n        n[i] = e[r];\n    return (r) => {\n      for (let i = r.prop(Re.group), s = -1; s < (i ? i.length : 0); s++) {\n        let o = n[s < 0 ? r.name : i[s]];\n        if (o)\n          return o;\n      }\n    };\n  }\n}\nOn.none = new On(\n  \"\",\n  /* @__PURE__ */ Object.create(null),\n  0,\n  8\n  /* NodeFlag.Anonymous */\n);\nclass fg {\n  /**\n  Create a set with the given types. The `id` property of each\n  type should correspond to its position within the array.\n  */\n  constructor(e) {\n    this.types = e;\n    for (let n = 0; n < e.length; n++)\n      if (e[n].id != n)\n        throw new RangeError(\"Node type ids should correspond to array positions when creating a node set\");\n  }\n  /**\n  Create a copy of this set with some node properties added. The\n  arguments to this method can be created with\n  [`NodeProp.add`](#common.NodeProp.add).\n  */\n  extend(...e) {\n    let n = [];\n    for (let r of this.types) {\n      let i = null;\n      for (let s of e) {\n        let o = s(r);\n        o && (i || (i = Object.assign({}, r.props)), i[o[0].id] = o[1]);\n      }\n      n.push(i ? new On(r.name, i, r.id, r.flags) : r);\n    }\n    return new fg(n);\n  }\n}\nconst Nc = /* @__PURE__ */ new WeakMap(), Cv = /* @__PURE__ */ new WeakMap();\nvar lt;\n(function(t) {\n  t[t.ExcludeBuffers = 1] = \"ExcludeBuffers\", t[t.IncludeAnonymous = 2] = \"IncludeAnonymous\", t[t.IgnoreMounts = 4] = \"IgnoreMounts\", t[t.IgnoreOverlays = 8] = \"IgnoreOverlays\";\n})(lt || (lt = {}));\nclass gt {\n  /**\n  Construct a new tree. See also [`Tree.build`](#common.Tree^build).\n  */\n  constructor(e, n, r, i, s) {\n    if (this.type = e, this.children = n, this.positions = r, this.length = i, this.props = null, s && s.length) {\n      this.props = /* @__PURE__ */ Object.create(null);\n      for (let [o, a] of s)\n        this.props[typeof o == \"number\" ? o : o.id] = a;\n    }\n  }\n  /**\n  @internal\n  */\n  toString() {\n    let e = vl.get(this);\n    if (e && !e.overlay)\n      return e.tree.toString();\n    let n = \"\";\n    for (let r of this.children) {\n      let i = r.toString();\n      i && (n && (n += \",\"), n += i);\n    }\n    return this.type.name ? (/\\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (n.length ? \"(\" + n + \")\" : \"\") : n;\n  }\n  /**\n  Get a [tree cursor](#common.TreeCursor) positioned at the top of\n  the tree. Mode can be used to [control](#common.IterMode) which\n  nodes the cursor visits.\n  */\n  cursor(e = 0) {\n    return new Xu(this.topNode, e);\n  }\n  /**\n  Get a [tree cursor](#common.TreeCursor) pointing into this tree\n  at the given position and side (see\n  [`moveTo`](#common.TreeCursor.moveTo).\n  */\n  cursorAt(e, n = 0, r = 0) {\n    let i = Nc.get(this) || this.topNode, s = new Xu(i);\n    return s.moveTo(e, n), Nc.set(this, s._tree), s;\n  }\n  /**\n  Get a [syntax node](#common.SyntaxNode) object for the top of the\n  tree.\n  */\n  get topNode() {\n    return new ln(this, 0, 0, null);\n  }\n  /**\n  Get the [syntax node](#common.SyntaxNode) at the given position.\n  If `side` is -1, this will move into nodes that end at the\n  position. If 1, it'll move into nodes that start at the\n  position. With 0, it'll only enter nodes that cover the position\n  from both sides.\n  \n  Note that this will not enter\n  [overlays](#common.MountedTree.overlay), and you often want\n  [`resolveInner`](#common.Tree.resolveInner) instead.\n  */\n  resolve(e, n = 0) {\n    let r = yl(Nc.get(this) || this.topNode, e, n, !1);\n    return Nc.set(this, r), r;\n  }\n  /**\n  Like [`resolve`](#common.Tree.resolve), but will enter\n  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node\n  pointing into the innermost overlaid tree at the given position\n  (with parent links going through all parent structure, including\n  the host trees).\n  */\n  resolveInner(e, n = 0) {\n    let r = yl(Cv.get(this) || this.topNode, e, n, !0);\n    return Cv.set(this, r), r;\n  }\n  /**\n  In some situations, it can be useful to iterate through all\n  nodes around a position, including those in overlays that don't\n  directly cover the position. This method gives you an iterator\n  that will produce all nodes, from small to big, around the given\n  position.\n  */\n  resolveStack(e, n = 0) {\n    return wD(this, e, n);\n  }\n  /**\n  Iterate over the tree and its children, calling `enter` for any\n  node that touches the `from`/`to` region (if given) before\n  running over such a node's children, and `leave` (if given) when\n  leaving the node. When `enter` returns `false`, that node will\n  not have its children iterated over (or `leave` called).\n  */\n  iterate(e) {\n    let { enter: n, leave: r, from: i = 0, to: s = this.length } = e, o = e.mode || 0, a = (o & lt.IncludeAnonymous) > 0;\n    for (let l = this.cursor(o | lt.IncludeAnonymous); ; ) {\n      let c = !1;\n      if (l.from <= s && l.to >= i && (!a && l.type.isAnonymous || n(l) !== !1)) {\n        if (l.firstChild())\n          continue;\n        c = !0;\n      }\n      for (; c && r && (a || !l.type.isAnonymous) && r(l), !l.nextSibling(); ) {\n        if (!l.parent())\n          return;\n        c = !0;\n      }\n    }\n  }\n  /**\n  Get the value of the given [node prop](#common.NodeProp) for this\n  node. Works with both per-node and per-type props.\n  */\n  prop(e) {\n    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);\n  }\n  /**\n  Returns the node's [per-node props](#common.NodeProp.perNode) in a\n  format that can be passed to the [`Tree`](#common.Tree)\n  constructor.\n  */\n  get propValues() {\n    let e = [];\n    if (this.props)\n      for (let n in this.props)\n        e.push([+n, this.props[n]]);\n    return e;\n  }\n  /**\n  Balance the direct children of this tree, producing a copy of\n  which may have children grouped into subtrees with type\n  [`NodeType.none`](#common.NodeType^none).\n  */\n  balance(e = {}) {\n    return this.children.length <= 8 ? this : Og(On.none, this.children, this.positions, 0, this.children.length, 0, this.length, (n, r, i) => new gt(this.type, n, r, i, this.propValues), e.makeTree || ((n, r, i) => new gt(On.none, n, r, i)));\n  }\n  /**\n  Build a tree from a postfix-ordered buffer of node information,\n  or a cursor over such a buffer.\n  */\n  static build(e) {\n    return kD(e);\n  }\n}\ngt.empty = new gt(On.none, [], [], 0);\nclass hg {\n  constructor(e, n) {\n    this.buffer = e, this.index = n;\n  }\n  get id() {\n    return this.buffer[this.index - 4];\n  }\n  get start() {\n    return this.buffer[this.index - 3];\n  }\n  get end() {\n    return this.buffer[this.index - 2];\n  }\n  get size() {\n    return this.buffer[this.index - 1];\n  }\n  get pos() {\n    return this.index;\n  }\n  next() {\n    this.index -= 4;\n  }\n  fork() {\n    return new hg(this.buffer, this.index);\n  }\n}\nclass ls {\n  /**\n  Create a tree buffer.\n  */\n  constructor(e, n, r) {\n    this.buffer = e, this.length = n, this.set = r;\n  }\n  /**\n  @internal\n  */\n  get type() {\n    return On.none;\n  }\n  /**\n  @internal\n  */\n  toString() {\n    let e = [];\n    for (let n = 0; n < this.buffer.length; )\n      e.push(this.childString(n)), n = this.buffer[n + 3];\n    return e.join(\",\");\n  }\n  /**\n  @internal\n  */\n  childString(e) {\n    let n = this.buffer[e], r = this.buffer[e + 3], i = this.set.types[n], s = i.name;\n    if (/\\W/.test(s) && !i.isError && (s = JSON.stringify(s)), e += 4, r == e)\n      return s;\n    let o = [];\n    for (; e < r; )\n      o.push(this.childString(e)), e = this.buffer[e + 3];\n    return s + \"(\" + o.join(\",\") + \")\";\n  }\n  /**\n  @internal\n  */\n  findChild(e, n, r, i, s) {\n    let { buffer: o } = this, a = -1;\n    for (let l = e; l != n && !(Gk(s, i, o[l + 1], o[l + 2]) && (a = l, r > 0)); l = o[l + 3])\n      ;\n    return a;\n  }\n  /**\n  @internal\n  */\n  slice(e, n, r) {\n    let i = this.buffer, s = new Uint16Array(n - e), o = 0;\n    for (let a = e, l = 0; a < n; ) {\n      s[l++] = i[a++], s[l++] = i[a++] - r;\n      let c = s[l++] = i[a++] - r;\n      s[l++] = i[a++] - e, o = Math.max(o, c);\n    }\n    return new ls(s, o, this.set);\n  }\n}\nfunction Gk(t, e, n, r) {\n  switch (t) {\n    case -2:\n      return n < e;\n    case -1:\n      return r >= e && n < e;\n    case 0:\n      return n < e && r > e;\n    case 1:\n      return n <= e && r > e;\n    case 2:\n      return r > e;\n    case 4:\n      return !0;\n  }\n}\nfunction yl(t, e, n, r) {\n  for (var i; t.from == t.to || (n < 1 ? t.from >= e : t.from > e) || (n > -1 ? t.to <= e : t.to < e); ) {\n    let o = !r && t instanceof ln && t.index < 0 ? null : t.parent;\n    if (!o)\n      return t;\n    t = o;\n  }\n  let s = r ? 0 : lt.IgnoreOverlays;\n  if (r)\n    for (let o = t, a = o.parent; a; o = a, a = o.parent)\n      o instanceof ln && o.index < 0 && ((i = a.enter(e, n, s)) === null || i === void 0 ? void 0 : i.from) != o.from && (t = a);\n  for (; ; ) {\n    let o = t.enter(e, n, s);\n    if (!o)\n      return t;\n    t = o;\n  }\n}\nclass Kk {\n  cursor(e = 0) {\n    return new Xu(this, e);\n  }\n  getChild(e, n = null, r = null) {\n    let i = Av(this, e, n, r);\n    return i.length ? i[0] : null;\n  }\n  getChildren(e, n = null, r = null) {\n    return Av(this, e, n, r);\n  }\n  resolve(e, n = 0) {\n    return yl(this, e, n, !1);\n  }\n  resolveInner(e, n = 0) {\n    return yl(this, e, n, !0);\n  }\n  matchContext(e) {\n    return Sp(this, e);\n  }\n  enterUnfinishedNodesBefore(e) {\n    let n = this.childBefore(e), r = this;\n    for (; n; ) {\n      let i = n.lastChild;\n      if (!i || i.to != n.to)\n        break;\n      i.type.isError && i.from == i.to ? (r = n, n = i.prevSibling) : n = i;\n    }\n    return r;\n  }\n  get node() {\n    return this;\n  }\n  get next() {\n    return this.parent;\n  }\n}\nclass ln extends Kk {\n  constructor(e, n, r, i) {\n    super(), this._tree = e, this.from = n, this.index = r, this._parent = i;\n  }\n  get type() {\n    return this._tree.type;\n  }\n  get name() {\n    return this._tree.type.name;\n  }\n  get to() {\n    return this.from + this._tree.length;\n  }\n  nextChild(e, n, r, i, s = 0) {\n    for (let o = this; ; ) {\n      for (let { children: a, positions: l } = o._tree, c = n > 0 ? a.length : -1; e != c; e += n) {\n        let u = a[e], d = l[e] + o.from;\n        if (Gk(i, r, d, d + u.length)) {\n          if (u instanceof ls) {\n            if (s & lt.ExcludeBuffers)\n              continue;\n            let f = u.findChild(0, u.buffer.length, n, r - d, i);\n            if (f > -1)\n              return new Nr(new yD(o, u, e, d), null, f);\n          } else if (s & lt.IncludeAnonymous || !u.type.isAnonymous || pg(u)) {\n            let f;\n            if (!(s & lt.IgnoreMounts) && (f = vl.get(u)) && !f.overlay)\n              return new ln(f.tree, d, e, o);\n            let h = new ln(u, d, e, o);\n            return s & lt.IncludeAnonymous || !h.type.isAnonymous ? h : h.nextChild(n < 0 ? u.children.length - 1 : 0, n, r, i);\n          }\n        }\n      }\n      if (s & lt.IncludeAnonymous || !o.type.isAnonymous || (o.index >= 0 ? e = o.index + n : e = n < 0 ? -1 : o._parent._tree.children.length, o = o._parent, !o))\n        return null;\n    }\n  }\n  get firstChild() {\n    return this.nextChild(\n      0,\n      1,\n      0,\n      4\n      /* Side.DontCare */\n    );\n  }\n  get lastChild() {\n    return this.nextChild(\n      this._tree.children.length - 1,\n      -1,\n      0,\n      4\n      /* Side.DontCare */\n    );\n  }\n  childAfter(e) {\n    return this.nextChild(\n      0,\n      1,\n      e,\n      2\n      /* Side.After */\n    );\n  }\n  childBefore(e) {\n    return this.nextChild(\n      this._tree.children.length - 1,\n      -1,\n      e,\n      -2\n      /* Side.Before */\n    );\n  }\n  enter(e, n, r = 0) {\n    let i;\n    if (!(r & lt.IgnoreOverlays) && (i = vl.get(this._tree)) && i.overlay) {\n      let s = e - this.from;\n      for (let { from: o, to: a } of i.overlay)\n        if ((n > 0 ? o <= s : o < s) && (n < 0 ? a >= s : a > s))\n          return new ln(i.tree, i.overlay[0].from + this.from, -1, this);\n    }\n    return this.nextChild(0, 1, e, n, r);\n  }\n  nextSignificantParent() {\n    let e = this;\n    for (; e.type.isAnonymous && e._parent; )\n      e = e._parent;\n    return e;\n  }\n  get parent() {\n    return this._parent ? this._parent.nextSignificantParent() : null;\n  }\n  get nextSibling() {\n    return this._parent && this.index >= 0 ? this._parent.nextChild(\n      this.index + 1,\n      1,\n      0,\n      4\n      /* Side.DontCare */\n    ) : null;\n  }\n  get prevSibling() {\n    return this._parent && this.index >= 0 ? this._parent.nextChild(\n      this.index - 1,\n      -1,\n      0,\n      4\n      /* Side.DontCare */\n    ) : null;\n  }\n  get tree() {\n    return this._tree;\n  }\n  toTree() {\n    return this._tree;\n  }\n  /**\n  @internal\n  */\n  toString() {\n    return this._tree.toString();\n  }\n}\nfunction Av(t, e, n, r) {\n  let i = t.cursor(), s = [];\n  if (!i.firstChild())\n    return s;\n  if (n != null) {\n    for (let o = !1; !o; )\n      if (o = i.type.is(n), !i.nextSibling())\n        return s;\n  }\n  for (; ; ) {\n    if (r != null && i.type.is(r))\n      return s;\n    if (i.type.is(e) && s.push(i.node), !i.nextSibling())\n      return r == null ? s : [];\n  }\n}\nfunction Sp(t, e, n = e.length - 1) {\n  for (let r = t.parent; n >= 0; r = r.parent) {\n    if (!r)\n      return !1;\n    if (!r.type.isAnonymous) {\n      if (e[n] && e[n] != r.name)\n        return !1;\n      n--;\n    }\n  }\n  return !0;\n}\nclass yD {\n  constructor(e, n, r, i) {\n    this.parent = e, this.buffer = n, this.index = r, this.start = i;\n  }\n}\nclass Nr extends Kk {\n  get name() {\n    return this.type.name;\n  }\n  get from() {\n    return this.context.start + this.context.buffer.buffer[this.index + 1];\n  }\n  get to() {\n    return this.context.start + this.context.buffer.buffer[this.index + 2];\n  }\n  constructor(e, n, r) {\n    super(), this.context = e, this._parent = n, this.index = r, this.type = e.buffer.set.types[e.buffer.buffer[r]];\n  }\n  child(e, n, r) {\n    let { buffer: i } = this.context, s = i.findChild(this.index + 4, i.buffer[this.index + 3], e, n - this.context.start, r);\n    return s < 0 ? null : new Nr(this.context, this, s);\n  }\n  get firstChild() {\n    return this.child(\n      1,\n      0,\n      4\n      /* Side.DontCare */\n    );\n  }\n  get lastChild() {\n    return this.child(\n      -1,\n      0,\n      4\n      /* Side.DontCare */\n    );\n  }\n  childAfter(e) {\n    return this.child(\n      1,\n      e,\n      2\n      /* Side.After */\n    );\n  }\n  childBefore(e) {\n    return this.child(\n      -1,\n      e,\n      -2\n      /* Side.Before */\n    );\n  }\n  enter(e, n, r = 0) {\n    if (r & lt.ExcludeBuffers)\n      return null;\n    let { buffer: i } = this.context, s = i.findChild(this.index + 4, i.buffer[this.index + 3], n > 0 ? 1 : -1, e - this.context.start, n);\n    return s < 0 ? null : new Nr(this.context, this, s);\n  }\n  get parent() {\n    return this._parent || this.context.parent.nextSignificantParent();\n  }\n  externalSibling(e) {\n    return this._parent ? null : this.context.parent.nextChild(\n      this.context.index + e,\n      e,\n      0,\n      4\n      /* Side.DontCare */\n    );\n  }\n  get nextSibling() {\n    let { buffer: e } = this.context, n = e.buffer[this.index + 3];\n    return n < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new Nr(this.context, this._parent, n) : this.externalSibling(1);\n  }\n  get prevSibling() {\n    let { buffer: e } = this.context, n = this._parent ? this._parent.index + 4 : 0;\n    return this.index == n ? this.externalSibling(-1) : new Nr(this.context, this._parent, e.findChild(\n      n,\n      this.index,\n      -1,\n      0,\n      4\n      /* Side.DontCare */\n    ));\n  }\n  get tree() {\n    return null;\n  }\n  toTree() {\n    let e = [], n = [], { buffer: r } = this.context, i = this.index + 4, s = r.buffer[this.index + 3];\n    if (s > i) {\n      let o = r.buffer[this.index + 1];\n      e.push(r.slice(i, s, o)), n.push(0);\n    }\n    return new gt(this.type, e, n, this.to - this.from);\n  }\n  /**\n  @internal\n  */\n  toString() {\n    return this.context.buffer.childString(this.index);\n  }\n}\nfunction Jk(t) {\n  if (!t.length)\n    return null;\n  let e = 0, n = t[0];\n  for (let s = 1; s < t.length; s++) {\n    let o = t[s];\n    (o.from > n.from || o.to < n.to) && (n = o, e = s);\n  }\n  let r = n instanceof ln && n.index < 0 ? null : n.parent, i = t.slice();\n  return r ? i[e] = r : i.splice(e, 1), new SD(i, n);\n}\nclass SD {\n  constructor(e, n) {\n    this.heads = e, this.node = n;\n  }\n  get next() {\n    return Jk(this.heads);\n  }\n}\nfunction wD(t, e, n) {\n  let r = t.resolveInner(e, n), i = null;\n  for (let s = r instanceof ln ? r : r.context.parent; s; s = s.parent)\n    if (s.index < 0) {\n      let o = s.parent;\n      (i || (i = [r])).push(o.resolve(e, n)), s = o;\n    } else {\n      let o = vl.get(s.tree);\n      if (o && o.overlay && o.overlay[0].from <= e && o.overlay[o.overlay.length - 1].to >= e) {\n        let a = new ln(o.tree, o.overlay[0].from + s.from, -1, s);\n        (i || (i = [r])).push(yl(a, e, n, !1));\n      }\n    }\n  return i ? Jk(i) : r;\n}\nclass Xu {\n  /**\n  Shorthand for `.type.name`.\n  */\n  get name() {\n    return this.type.name;\n  }\n  /**\n  @internal\n  */\n  constructor(e, n = 0) {\n    if (this.mode = n, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof ln)\n      this.yieldNode(e);\n    else {\n      this._tree = e.context.parent, this.buffer = e.context;\n      for (let r = e._parent; r; r = r._parent)\n        this.stack.unshift(r.index);\n      this.bufferNode = e, this.yieldBuf(e.index);\n    }\n  }\n  yieldNode(e) {\n    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, !0) : !1;\n  }\n  yieldBuf(e, n) {\n    this.index = e;\n    let { start: r, buffer: i } = this.buffer;\n    return this.type = n || i.set.types[i.buffer[e]], this.from = r + i.buffer[e + 1], this.to = r + i.buffer[e + 2], !0;\n  }\n  /**\n  @internal\n  */\n  yield(e) {\n    return e ? e instanceof ln ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : !1;\n  }\n  /**\n  @internal\n  */\n  toString() {\n    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();\n  }\n  /**\n  @internal\n  */\n  enterChild(e, n, r) {\n    if (!this.buffer)\n      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, n, r, this.mode));\n    let { buffer: i } = this.buffer, s = i.findChild(this.index + 4, i.buffer[this.index + 3], e, n - this.buffer.start, r);\n    return s < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(s));\n  }\n  /**\n  Move the cursor to this node's first child. When this returns\n  false, the node has no child, and the cursor has not been moved.\n  */\n  firstChild() {\n    return this.enterChild(\n      1,\n      0,\n      4\n      /* Side.DontCare */\n    );\n  }\n  /**\n  Move the cursor to this node's last child.\n  */\n  lastChild() {\n    return this.enterChild(\n      -1,\n      0,\n      4\n      /* Side.DontCare */\n    );\n  }\n  /**\n  Move the cursor to the first child that ends after `pos`.\n  */\n  childAfter(e) {\n    return this.enterChild(\n      1,\n      e,\n      2\n      /* Side.After */\n    );\n  }\n  /**\n  Move to the last child that starts before `pos`.\n  */\n  childBefore(e) {\n    return this.enterChild(\n      -1,\n      e,\n      -2\n      /* Side.Before */\n    );\n  }\n  /**\n  Move the cursor to the child around `pos`. If side is -1 the\n  child may end at that position, when 1 it may start there. This\n  will also enter [overlaid](#common.MountedTree.overlay)\n  [mounted](#common.NodeProp^mounted) trees unless `overlays` is\n  set to false.\n  */\n  enter(e, n, r = this.mode) {\n    return this.buffer ? r & lt.ExcludeBuffers ? !1 : this.enterChild(1, e, n) : this.yield(this._tree.enter(e, n, r));\n  }\n  /**\n  Move to the node's parent node, if this isn't the top node.\n  */\n  parent() {\n    if (!this.buffer)\n      return this.yieldNode(this.mode & lt.IncludeAnonymous ? this._tree._parent : this._tree.parent);\n    if (this.stack.length)\n      return this.yieldBuf(this.stack.pop());\n    let e = this.mode & lt.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();\n    return this.buffer = null, this.yieldNode(e);\n  }\n  /**\n  @internal\n  */\n  sibling(e) {\n    if (!this.buffer)\n      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : !1;\n    let { buffer: n } = this.buffer, r = this.stack.length - 1;\n    if (e < 0) {\n      let i = r < 0 ? 0 : this.stack[r] + 4;\n      if (this.index != i)\n        return this.yieldBuf(n.findChild(\n          i,\n          this.index,\n          -1,\n          0,\n          4\n          /* Side.DontCare */\n        ));\n    } else {\n      let i = n.buffer[this.index + 3];\n      if (i < (r < 0 ? n.buffer.length : n.buffer[this.stack[r] + 3]))\n        return this.yieldBuf(i);\n    }\n    return r < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;\n  }\n  /**\n  Move to this node's next sibling, if any.\n  */\n  nextSibling() {\n    return this.sibling(1);\n  }\n  /**\n  Move to this node's previous sibling, if any.\n  */\n  prevSibling() {\n    return this.sibling(-1);\n  }\n  atLastNode(e) {\n    let n, r, { buffer: i } = this;\n    if (i) {\n      if (e > 0) {\n        if (this.index < i.buffer.buffer.length)\n          return !1;\n      } else\n        for (let s = 0; s < this.index; s++)\n          if (i.buffer.buffer[s + 3] < this.index)\n            return !1;\n      ({ index: n, parent: r } = i);\n    } else\n      ({ index: n, _parent: r } = this._tree);\n    for (; r; { index: n, _parent: r } = r)\n      if (n > -1)\n        for (let s = n + e, o = e < 0 ? -1 : r._tree.children.length; s != o; s += e) {\n          let a = r._tree.children[s];\n          if (this.mode & lt.IncludeAnonymous || a instanceof ls || !a.type.isAnonymous || pg(a))\n            return !1;\n        }\n    return !0;\n  }\n  move(e, n) {\n    if (n && this.enterChild(\n      e,\n      0,\n      4\n      /* Side.DontCare */\n    ))\n      return !0;\n    for (; ; ) {\n      if (this.sibling(e))\n        return !0;\n      if (this.atLastNode(e) || !this.parent())\n        return !1;\n    }\n  }\n  /**\n  Move to the next node in a\n  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)\n  traversal, going from a node to its first child or, if the\n  current node is empty or `enter` is false, its next sibling or\n  the next sibling of the first parent node that has one.\n  */\n  next(e = !0) {\n    return this.move(1, e);\n  }\n  /**\n  Move to the next node in a last-to-first pre-order traveral. A\n  node is followed by its last child or, if it has none, its\n  previous sibling or the previous sibling of the first parent\n  node that has one.\n  */\n  prev(e = !0) {\n    return this.move(-1, e);\n  }\n  /**\n  Move the cursor to the innermost node that covers `pos`. If\n  `side` is -1, it will enter nodes that end at `pos`. If it is 1,\n  it will enter nodes that start at `pos`.\n  */\n  moveTo(e, n = 0) {\n    for (; (this.from == this.to || (n < 1 ? this.from >= e : this.from > e) || (n > -1 ? this.to <= e : this.to < e)) && this.parent(); )\n      ;\n    for (; this.enterChild(1, e, n); )\n      ;\n    return this;\n  }\n  /**\n  Get a [syntax node](#common.SyntaxNode) at the cursor's current\n  position.\n  */\n  get node() {\n    if (!this.buffer)\n      return this._tree;\n    let e = this.bufferNode, n = null, r = 0;\n    if (e && e.context == this.buffer)\n      e:\n        for (let i = this.index, s = this.stack.length; s >= 0; ) {\n          for (let o = e; o; o = o._parent)\n            if (o.index == i) {\n              if (i == this.index)\n                return o;\n              n = o, r = s + 1;\n              break e;\n            }\n          i = this.stack[--s];\n        }\n    for (let i = r; i < this.stack.length; i++)\n      n = new Nr(this.buffer, n, this.stack[i]);\n    return this.bufferNode = new Nr(this.buffer, n, this.index);\n  }\n  /**\n  Get the [tree](#common.Tree) that represents the current node, if\n  any. Will return null when the node is in a [tree\n  buffer](#common.TreeBuffer).\n  */\n  get tree() {\n    return this.buffer ? null : this._tree._tree;\n  }\n  /**\n  Iterate over the current node and all its descendants, calling\n  `enter` when entering a node and `leave`, if given, when leaving\n  one. When `enter` returns `false`, any children of that node are\n  skipped, and `leave` isn't called for it.\n  */\n  iterate(e, n) {\n    for (let r = 0; ; ) {\n      let i = !1;\n      if (this.type.isAnonymous || e(this) !== !1) {\n        if (this.firstChild()) {\n          r++;\n          continue;\n        }\n        this.type.isAnonymous || (i = !0);\n      }\n      for (; i && n && n(this), i = this.type.isAnonymous, !this.nextSibling(); ) {\n        if (!r)\n          return;\n        this.parent(), r--, i = !0;\n      }\n    }\n  }\n  /**\n  Test whether the current node matches a given contexta sequence\n  of direct parent node names. Empty strings in the context array\n  are treated as wildcards.\n  */\n  matchContext(e) {\n    if (!this.buffer)\n      return Sp(this.node, e);\n    let { buffer: n } = this.buffer, { types: r } = n.set;\n    for (let i = e.length - 1, s = this.stack.length - 1; i >= 0; s--) {\n      if (s < 0)\n        return Sp(this.node, e, i);\n      let o = r[n.buffer[this.stack[s]]];\n      if (!o.isAnonymous) {\n        if (e[i] && e[i] != o.name)\n          return !1;\n        i--;\n      }\n    }\n    return !0;\n  }\n}\nfunction pg(t) {\n  return t.children.some((e) => e instanceof ls || !e.type.isAnonymous || pg(e));\n}\nfunction kD(t) {\n  var e;\n  let { buffer: n, nodeSet: r, maxBufferLength: i = Fk, reused: s = [], minRepeatType: o = r.types.length } = t, a = Array.isArray(n) ? new hg(n, n.length) : n, l = r.types, c = 0, u = 0;\n  function d(S, w, k, _, T, C) {\n    let { id: A, start: Q, end: W, size: L } = a, re = u;\n    for (; L < 0; )\n      if (a.next(), L == -1) {\n        let Ce = s[A];\n        k.push(Ce), _.push(Q - S);\n        return;\n      } else if (L == -3) {\n        c = A;\n        return;\n      } else if (L == -4) {\n        u = A;\n        return;\n      } else\n        throw new RangeError(`Unrecognized record size: ${L}`);\n    let Y = l[A], K, B, _e = Q - S;\n    if (W - Q <= i && (B = m(a.pos - w, T))) {\n      let Ce = new Uint16Array(B.size - B.skip), ue = a.pos - B.size, ge = Ce.length;\n      for (; a.pos > ue; )\n        ge = y(B.start, Ce, ge);\n      K = new ls(Ce, W - B.start, r), _e = B.start - S;\n    } else {\n      let Ce = a.pos - L;\n      a.next();\n      let ue = [], ge = [], Be = A >= o ? A : -1, Le = 0, Zt = W;\n      for (; a.pos > Ce; )\n        Be >= 0 && a.id == Be && a.size >= 0 ? (a.end <= Zt - i && (p(ue, ge, Q, Le, a.end, Zt, Be, re), Le = ue.length, Zt = a.end), a.next()) : C > 2500 ? f(Q, Ce, ue, ge) : d(Q, Ce, ue, ge, Be, C + 1);\n      if (Be >= 0 && Le > 0 && Le < ue.length && p(ue, ge, Q, Le, Q, Zt, Be, re), ue.reverse(), ge.reverse(), Be > -1 && Le > 0) {\n        let Vt = h(Y);\n        K = Og(Y, ue, ge, 0, ue.length, 0, W - Q, Vt, Vt);\n      } else\n        K = O(Y, ue, ge, W - Q, re - W);\n    }\n    k.push(K), _.push(_e);\n  }\n  function f(S, w, k, _) {\n    let T = [], C = 0, A = -1;\n    for (; a.pos > w; ) {\n      let { id: Q, start: W, end: L, size: re } = a;\n      if (re > 4)\n        a.next();\n      else {\n        if (A > -1 && W < A)\n          break;\n        A < 0 && (A = L - i), T.push(Q, W, L), C++, a.next();\n      }\n    }\n    if (C) {\n      let Q = new Uint16Array(C * 4), W = T[T.length - 2];\n      for (let L = T.length - 3, re = 0; L >= 0; L -= 3)\n        Q[re++] = T[L], Q[re++] = T[L + 1] - W, Q[re++] = T[L + 2] - W, Q[re++] = re;\n      k.push(new ls(Q, T[2] - W, r)), _.push(W - S);\n    }\n  }\n  function h(S) {\n    return (w, k, _) => {\n      let T = 0, C = w.length - 1, A, Q;\n      if (C >= 0 && (A = w[C]) instanceof gt) {\n        if (!C && A.type == S && A.length == _)\n          return A;\n        (Q = A.prop(Re.lookAhead)) && (T = k[C] + A.length + Q);\n      }\n      return O(S, w, k, _, T);\n    };\n  }\n  function p(S, w, k, _, T, C, A, Q) {\n    let W = [], L = [];\n    for (; S.length > _; )\n      W.push(S.pop()), L.push(w.pop() + k - T);\n    S.push(O(r.types[A], W, L, C - T, Q - C)), w.push(T - k);\n  }\n  function O(S, w, k, _, T = 0, C) {\n    if (c) {\n      let A = [Re.contextHash, c];\n      C = C ? [A].concat(C) : [A];\n    }\n    if (T > 25) {\n      let A = [Re.lookAhead, T];\n      C = C ? [A].concat(C) : [A];\n    }\n    return new gt(S, w, k, _, C);\n  }\n  function m(S, w) {\n    let k = a.fork(), _ = 0, T = 0, C = 0, A = k.end - i, Q = { size: 0, start: 0, skip: 0 };\n    e:\n      for (let W = k.pos - S; k.pos > W; ) {\n        let L = k.size;\n        if (k.id == w && L >= 0) {\n          Q.size = _, Q.start = T, Q.skip = C, C += 4, _ += 4, k.next();\n          continue;\n        }\n        let re = k.pos - L;\n        if (L < 0 || re < W || k.start < A)\n          break;\n        let Y = k.id >= o ? 4 : 0, K = k.start;\n        for (k.next(); k.pos > re; ) {\n          if (k.size < 0)\n            if (k.size == -3)\n              Y += 4;\n            else\n              break e;\n          else\n            k.id >= o && (Y += 4);\n          k.next();\n        }\n        T = K, _ += L, C += Y;\n      }\n    return (w < 0 || _ == S) && (Q.size = _, Q.start = T, Q.skip = C), Q.size > 4 ? Q : void 0;\n  }\n  function y(S, w, k) {\n    let { id: _, start: T, end: C, size: A } = a;\n    if (a.next(), A >= 0 && _ < o) {\n      let Q = k;\n      if (A > 4) {\n        let W = a.pos - (A - 4);\n        for (; a.pos > W; )\n          k = y(S, w, k);\n      }\n      w[--k] = Q, w[--k] = C - S, w[--k] = T - S, w[--k] = _;\n    } else\n      A == -3 ? c = _ : A == -4 && (u = _);\n    return k;\n  }\n  let b = [], g = [];\n  for (; a.pos > 0; )\n    d(t.start || 0, t.bufferStart || 0, b, g, -1, 0);\n  let v = (e = t.length) !== null && e !== void 0 ? e : b.length ? g[0] + b[0].length : 0;\n  return new gt(l[t.topID], b.reverse(), g.reverse(), v);\n}\nconst Rv = /* @__PURE__ */ new WeakMap();\nfunction lu(t, e) {\n  if (!t.isAnonymous || e instanceof ls || e.type != t)\n    return 1;\n  let n = Rv.get(e);\n  if (n == null) {\n    n = 1;\n    for (let r of e.children) {\n      if (r.type != t || !(r instanceof gt)) {\n        n = 1;\n        break;\n      }\n      n += lu(t, r);\n    }\n    Rv.set(e, n);\n  }\n  return n;\n}\nfunction Og(t, e, n, r, i, s, o, a, l) {\n  let c = 0;\n  for (let p = r; p < i; p++)\n    c += lu(t, e[p]);\n  let u = Math.ceil(\n    c * 1.5 / 8\n    /* Balance.BranchFactor */\n  ), d = [], f = [];\n  function h(p, O, m, y, b) {\n    for (let g = m; g < y; ) {\n      let v = g, S = O[g], w = lu(t, p[g]);\n      for (g++; g < y; g++) {\n        let k = lu(t, p[g]);\n        if (w + k >= u)\n          break;\n        w += k;\n      }\n      if (g == v + 1) {\n        if (w > u) {\n          let k = p[v];\n          h(k.children, k.positions, 0, k.children.length, O[v] + b);\n          continue;\n        }\n        d.push(p[v]);\n      } else {\n        let k = O[g - 1] + p[g - 1].length - S;\n        d.push(Og(t, p, O, v, g, S, k, null, l));\n      }\n      f.push(S + b - s);\n    }\n  }\n  return h(e, n, r, i, 0), (a || l)(d, f, o);\n}\nclass ex {\n  constructor() {\n    this.map = /* @__PURE__ */ new WeakMap();\n  }\n  setBuffer(e, n, r) {\n    let i = this.map.get(e);\n    i || this.map.set(e, i = /* @__PURE__ */ new Map()), i.set(n, r);\n  }\n  getBuffer(e, n) {\n    let r = this.map.get(e);\n    return r && r.get(n);\n  }\n  /**\n  Set the value for this syntax node.\n  */\n  set(e, n) {\n    e instanceof Nr ? this.setBuffer(e.context.buffer, e.index, n) : e instanceof ln && this.map.set(e.tree, n);\n  }\n  /**\n  Retrieve value for this syntax node, if it exists in the map.\n  */\n  get(e) {\n    return e instanceof Nr ? this.getBuffer(e.context.buffer, e.index) : e instanceof ln ? this.map.get(e.tree) : void 0;\n  }\n  /**\n  Set the value for the node that a cursor currently points to.\n  */\n  cursorSet(e, n) {\n    e.buffer ? this.setBuffer(e.buffer.buffer, e.index, n) : this.map.set(e.tree, n);\n  }\n  /**\n  Retrieve the value for the node that a cursor currently points\n  to.\n  */\n  cursorGet(e) {\n    return e.buffer ? this.getBuffer(e.buffer.buffer, e.index) : this.map.get(e.tree);\n  }\n}\nclass si {\n  /**\n  Construct a tree fragment. You'll usually want to use\n  [`addTree`](#common.TreeFragment^addTree) and\n  [`applyChanges`](#common.TreeFragment^applyChanges) instead of\n  calling this directly.\n  */\n  constructor(e, n, r, i, s = !1, o = !1) {\n    this.from = e, this.to = n, this.tree = r, this.offset = i, this.open = (s ? 1 : 0) | (o ? 2 : 0);\n  }\n  /**\n  Whether the start of the fragment represents the start of a\n  parse, or the end of a change. (In the second case, it may not\n  be safe to reuse some nodes at the start, depending on the\n  parsing algorithm.)\n  */\n  get openStart() {\n    return (this.open & 1) > 0;\n  }\n  /**\n  Whether the end of the fragment represents the end of a\n  full-document parse, or the start of a change.\n  */\n  get openEnd() {\n    return (this.open & 2) > 0;\n  }\n  /**\n  Create a set of fragments from a freshly parsed tree, or update\n  an existing set of fragments by replacing the ones that overlap\n  with a tree with content from the new tree. When `partial` is\n  true, the parse is treated as incomplete, and the resulting\n  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to\n  true.\n  */\n  static addTree(e, n = [], r = !1) {\n    let i = [new si(0, e.length, e, 0, !1, r)];\n    for (let s of n)\n      s.to > e.length && i.push(s);\n    return i;\n  }\n  /**\n  Apply a set of edits to an array of fragments, removing or\n  splitting fragments as necessary to remove edited ranges, and\n  adjusting offsets for fragments that moved.\n  */\n  static applyChanges(e, n, r = 128) {\n    if (!n.length)\n      return e;\n    let i = [], s = 1, o = e.length ? e[0] : null;\n    for (let a = 0, l = 0, c = 0; ; a++) {\n      let u = a < n.length ? n[a] : null, d = u ? u.fromA : 1e9;\n      if (d - l >= r)\n        for (; o && o.from < d; ) {\n          let f = o;\n          if (l >= f.from || d <= f.to || c) {\n            let h = Math.max(f.from, l) - c, p = Math.min(f.to, d) - c;\n            f = h >= p ? null : new si(h, p, f.tree, f.offset + c, a > 0, !!u);\n          }\n          if (f && i.push(f), o.to > d)\n            break;\n          o = s < e.length ? e[s++] : null;\n        }\n      if (!u)\n        break;\n      l = u.toA, c = u.toA - u.toB;\n    }\n    return i;\n  }\n}\nclass tx {\n  /**\n  Start a parse, returning a [partial parse](#common.PartialParse)\n  object. [`fragments`](#common.TreeFragment) can be passed in to\n  make the parse incremental.\n  \n  By default, the entire input is parsed. You can pass `ranges`,\n  which should be a sorted array of non-empty, non-overlapping\n  ranges, to parse only those ranges. The tree returned in that\n  case will start at `ranges[0].from`.\n  */\n  startParse(e, n, r) {\n    return typeof e == \"string\" && (e = new xD(e)), r = r ? r.length ? r.map((i) => new Fn(i.from, i.to)) : [new Fn(0, 0)] : [new Fn(0, e.length)], this.createParse(e, n || [], r);\n  }\n  /**\n  Run a full parse, returning the resulting tree.\n  */\n  parse(e, n, r) {\n    let i = this.startParse(e, n, r);\n    for (; ; ) {\n      let s = i.advance();\n      if (s)\n        return s;\n    }\n  }\n}\nclass xD {\n  constructor(e) {\n    this.string = e;\n  }\n  get length() {\n    return this.string.length;\n  }\n  chunk(e) {\n    return this.string.slice(e);\n  }\n  get lineChunks() {\n    return !1;\n  }\n  read(e, n) {\n    return this.string.slice(e, n);\n  }\n}\nfunction PD(t) {\n  return (e, n, r, i) => new TD(e, t, n, r, i);\n}\nclass Nv {\n  constructor(e, n, r, i, s) {\n    this.parser = e, this.parse = n, this.overlay = r, this.target = i, this.from = s;\n  }\n}\nfunction Dv(t) {\n  if (!t.length || t.some((e) => e.from >= e.to))\n    throw new RangeError(\"Invalid inner parse ranges given: \" + JSON.stringify(t));\n}\nclass _D {\n  constructor(e, n, r, i, s, o, a) {\n    this.parser = e, this.predicate = n, this.mounts = r, this.index = i, this.start = s, this.target = o, this.prev = a, this.depth = 0, this.ranges = [];\n  }\n}\nconst wp = new Re({ perNode: !0 });\nclass TD {\n  constructor(e, n, r, i, s) {\n    this.nest = n, this.input = r, this.fragments = i, this.ranges = s, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = e;\n  }\n  advance() {\n    if (this.baseParse) {\n      let r = this.baseParse.advance();\n      if (!r)\n        return null;\n      if (this.baseParse = null, this.baseTree = r, this.startInner(), this.stoppedAt != null)\n        for (let i of this.inner)\n          i.parse.stopAt(this.stoppedAt);\n    }\n    if (this.innerDone == this.inner.length) {\n      let r = this.baseTree;\n      return this.stoppedAt != null && (r = new gt(r.type, r.children, r.positions, r.length, r.propValues.concat([[wp, this.stoppedAt]]))), r;\n    }\n    let e = this.inner[this.innerDone], n = e.parse.advance();\n    if (n) {\n      this.innerDone++;\n      let r = Object.assign(/* @__PURE__ */ Object.create(null), e.target.props);\n      r[Re.mounted.id] = new vl(n, e.overlay, e.parser), e.target.props = r;\n    }\n    return null;\n  }\n  get parsedPos() {\n    if (this.baseParse)\n      return 0;\n    let e = this.input.length;\n    for (let n = this.innerDone; n < this.inner.length; n++)\n      this.inner[n].from < e && (e = Math.min(e, this.inner[n].parse.parsedPos));\n    return e;\n  }\n  stopAt(e) {\n    if (this.stoppedAt = e, this.baseParse)\n      this.baseParse.stopAt(e);\n    else\n      for (let n = this.innerDone; n < this.inner.length; n++)\n        this.inner[n].parse.stopAt(e);\n  }\n  startInner() {\n    let e = new QD(this.fragments), n = null, r = null, i = new Xu(new ln(this.baseTree, this.ranges[0].from, 0, null), lt.IncludeAnonymous | lt.IgnoreMounts);\n    e:\n      for (let s, o; ; ) {\n        let a = !0, l;\n        if (this.stoppedAt != null && i.from >= this.stoppedAt)\n          a = !1;\n        else if (e.hasNode(i)) {\n          if (n) {\n            let c = n.mounts.find((u) => u.frag.from <= i.from && u.frag.to >= i.to && u.mount.overlay);\n            if (c)\n              for (let u of c.mount.overlay) {\n                let d = u.from + c.pos, f = u.to + c.pos;\n                d >= i.from && f <= i.to && !n.ranges.some((h) => h.from < f && h.to > d) && n.ranges.push({ from: d, to: f });\n              }\n          }\n          a = !1;\n        } else if (r && (o = ED(r.ranges, i.from, i.to)))\n          a = o != 2;\n        else if (!i.type.isAnonymous && (s = this.nest(i, this.input)) && (i.from < i.to || !s.overlay)) {\n          i.tree || $D(i);\n          let c = e.findMounts(i.from, s.parser);\n          if (typeof s.overlay == \"function\")\n            n = new _D(s.parser, s.overlay, c, this.inner.length, i.from, i.tree, n);\n          else {\n            let u = Iv(this.ranges, s.overlay || (i.from < i.to ? [new Fn(i.from, i.to)] : []));\n            u.length && Dv(u), (u.length || !s.overlay) && this.inner.push(new Nv(s.parser, u.length ? s.parser.startParse(this.input, Wv(c, u), u) : s.parser.startParse(\"\"), s.overlay ? s.overlay.map((d) => new Fn(d.from - i.from, d.to - i.from)) : null, i.tree, u.length ? u[0].from : i.from)), s.overlay ? u.length && (r = { ranges: u, depth: 0, prev: r }) : a = !1;\n          }\n        } else\n          n && (l = n.predicate(i)) && (l === !0 && (l = new Fn(i.from, i.to)), l.from < l.to && n.ranges.push(l));\n        if (a && i.firstChild())\n          n && n.depth++, r && r.depth++;\n        else\n          for (; !i.nextSibling(); ) {\n            if (!i.parent())\n              break e;\n            if (n && !--n.depth) {\n              let c = Iv(this.ranges, n.ranges);\n              c.length && (Dv(c), this.inner.splice(n.index, 0, new Nv(n.parser, n.parser.startParse(this.input, Wv(n.mounts, c), c), n.ranges.map((u) => new Fn(u.from - n.start, u.to - n.start)), n.target, c[0].from))), n = n.prev;\n            }\n            r && !--r.depth && (r = r.prev);\n          }\n      }\n  }\n}\nfunction ED(t, e, n) {\n  for (let r of t) {\n    if (r.from >= n)\n      break;\n    if (r.to > e)\n      return r.from <= e && r.to >= n ? 2 : 1;\n  }\n  return 0;\n}\nfunction Zv(t, e, n, r, i, s) {\n  if (e < n) {\n    let o = t.buffer[e + 1];\n    r.push(t.slice(e, n, o)), i.push(o - s);\n  }\n}\nfunction $D(t) {\n  let { node: e } = t, n = [], r = e.context.buffer;\n  do\n    n.push(t.index), t.parent();\n  while (!t.tree);\n  let i = t.tree, s = i.children.indexOf(r), o = i.children[s], a = o.buffer, l = [s];\n  function c(u, d, f, h, p, O) {\n    let m = n[O], y = [], b = [];\n    Zv(o, u, m, y, b, h);\n    let g = a[m + 1], v = a[m + 2];\n    l.push(y.length);\n    let S = O ? c(m + 4, a[m + 3], o.set.types[a[m]], g, v - g, O - 1) : e.toTree();\n    return y.push(S), b.push(g - h), Zv(o, a[m + 3], d, y, b, h), new gt(f, y, b, p);\n  }\n  i.children[s] = c(0, a.length, On.none, 0, o.length, n.length - 1);\n  for (let u of l) {\n    let d = t.tree.children[u], f = t.tree.positions[u];\n    t.yield(new ln(d, f + t.from, u, t._tree));\n  }\n}\nclass Vv {\n  constructor(e, n) {\n    this.offset = n, this.done = !1, this.cursor = e.cursor(lt.IncludeAnonymous | lt.IgnoreMounts);\n  }\n  // Move to the first node (in pre-order) that starts at or after `pos`.\n  moveTo(e) {\n    let { cursor: n } = this, r = e - this.offset;\n    for (; !this.done && n.from < r; )\n      n.to >= e && n.enter(r, 1, lt.IgnoreOverlays | lt.ExcludeBuffers) || n.next(!1) || (this.done = !0);\n  }\n  hasNode(e) {\n    if (this.moveTo(e.from), !this.done && this.cursor.from + this.offset == e.from && this.cursor.tree)\n      for (let n = this.cursor.tree; ; ) {\n        if (n == e.tree)\n          return !0;\n        if (n.children.length && n.positions[0] == 0 && n.children[0] instanceof gt)\n          n = n.children[0];\n        else\n          break;\n      }\n    return !1;\n  }\n}\nlet QD = class {\n  constructor(e) {\n    var n;\n    if (this.fragments = e, this.curTo = 0, this.fragI = 0, e.length) {\n      let r = this.curFrag = e[0];\n      this.curTo = (n = r.tree.prop(wp)) !== null && n !== void 0 ? n : r.to, this.inner = new Vv(r.tree, -r.offset);\n    } else\n      this.curFrag = this.inner = null;\n  }\n  hasNode(e) {\n    for (; this.curFrag && e.from >= this.curTo; )\n      this.nextFrag();\n    return this.curFrag && this.curFrag.from <= e.from && this.curTo >= e.to && this.inner.hasNode(e);\n  }\n  nextFrag() {\n    var e;\n    if (this.fragI++, this.fragI == this.fragments.length)\n      this.curFrag = this.inner = null;\n    else {\n      let n = this.curFrag = this.fragments[this.fragI];\n      this.curTo = (e = n.tree.prop(wp)) !== null && e !== void 0 ? e : n.to, this.inner = new Vv(n.tree, -n.offset);\n    }\n  }\n  findMounts(e, n) {\n    var r;\n    let i = [];\n    if (this.inner) {\n      this.inner.cursor.moveTo(e, 1);\n      for (let s = this.inner.cursor.node; s; s = s.parent) {\n        let o = (r = s.tree) === null || r === void 0 ? void 0 : r.prop(Re.mounted);\n        if (o && o.parser == n)\n          for (let a = this.fragI; a < this.fragments.length; a++) {\n            let l = this.fragments[a];\n            if (l.from >= s.to)\n              break;\n            l.tree == this.curFrag.tree && i.push({\n              frag: l,\n              pos: s.from - l.offset,\n              mount: o\n            });\n          }\n      }\n    }\n    return i;\n  }\n};\nfunction Iv(t, e) {\n  let n = null, r = e;\n  for (let i = 1, s = 0; i < t.length; i++) {\n    let o = t[i - 1].to, a = t[i].from;\n    for (; s < r.length; s++) {\n      let l = r[s];\n      if (l.from >= a)\n        break;\n      l.to <= o || (n || (r = n = e.slice()), l.from < o ? (n[s] = new Fn(l.from, o), l.to > a && n.splice(s + 1, 0, new Fn(a, l.to))) : l.to > a ? n[s--] = new Fn(a, l.to) : n.splice(s--, 1));\n    }\n  }\n  return r;\n}\nfunction CD(t, e, n, r) {\n  let i = 0, s = 0, o = !1, a = !1, l = -1e9, c = [];\n  for (; ; ) {\n    let u = i == t.length ? 1e9 : o ? t[i].to : t[i].from, d = s == e.length ? 1e9 : a ? e[s].to : e[s].from;\n    if (o != a) {\n      let f = Math.max(l, n), h = Math.min(u, d, r);\n      f < h && c.push(new Fn(f, h));\n    }\n    if (l = Math.min(u, d), l == 1e9)\n      break;\n    u == l && (o ? (o = !1, i++) : o = !0), d == l && (a ? (a = !1, s++) : a = !0);\n  }\n  return c;\n}\nfunction Wv(t, e) {\n  let n = [];\n  for (let { pos: r, mount: i, frag: s } of t) {\n    let o = r + (i.overlay ? i.overlay[0].from : 0), a = o + i.tree.length, l = Math.max(s.from, o), c = Math.min(s.to, a);\n    if (i.overlay) {\n      let u = i.overlay.map((f) => new Fn(f.from + r, f.to + r)), d = CD(e, u, l, c);\n      for (let f = 0, h = l; ; f++) {\n        let p = f == d.length, O = p ? c : d[f].from;\n        if (O > h && n.push(new si(h, O, i.tree, -o, s.from >= h || s.openStart, s.to <= O || s.openEnd)), p)\n          break;\n        h = d[f].to;\n      }\n    } else\n      n.push(new si(l, c, i.tree, -o, s.from >= o || s.openStart, s.to <= a || s.openEnd));\n  }\n  return n;\n}\nlet AD = 0, Ni = class nx {\n  /**\n  @internal\n  */\n  constructor(e, n, r) {\n    this.set = e, this.base = n, this.modified = r, this.id = AD++;\n  }\n  /**\n  Define a new tag. If `parent` is given, the tag is treated as a\n  sub-tag of that parent, and\n  [highlighters](#highlight.tagHighlighter) that don't mention\n  this tag will try to fall back to the parent tag (or grandparent\n  tag, etc).\n  */\n  static define(e) {\n    if (e != null && e.base)\n      throw new Error(\"Can not derive from a modified tag\");\n    let n = new nx([], null, []);\n    if (n.set.push(n), e)\n      for (let r of e.set)\n        n.set.push(r);\n    return n;\n  }\n  /**\n  Define a tag _modifier_, which is a function that, given a tag,\n  will return a tag that is a subtag of the original. Applying the\n  same modifier to a twice tag will return the same value (`m1(t1)\n  == m1(t1)`) and applying multiple modifiers will, regardless or\n  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).\n  \n  When multiple modifiers are applied to a given base tag, each\n  smaller set of modifiers is registered as a parent, so that for\n  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,\n  `m1(m3(t1)`, and so on.\n  */\n  static defineModifier() {\n    let e = new ju();\n    return (n) => n.modified.indexOf(e) > -1 ? n : ju.get(n.base || n, n.modified.concat(e).sort((r, i) => r.id - i.id));\n  }\n}, RD = 0;\nclass ju {\n  constructor() {\n    this.instances = [], this.id = RD++;\n  }\n  static get(e, n) {\n    if (!n.length)\n      return e;\n    let r = n[0].instances.find((a) => a.base == e && ND(n, a.modified));\n    if (r)\n      return r;\n    let i = [], s = new Ni(i, e, n);\n    for (let a of n)\n      a.instances.push(s);\n    let o = DD(n);\n    for (let a of e.set)\n      if (!a.modified.length)\n        for (let l of o)\n          i.push(ju.get(a, l));\n    return s;\n  }\n}\nfunction ND(t, e) {\n  return t.length == e.length && t.every((n, r) => n == e[r]);\n}\nfunction DD(t) {\n  let e = [[]];\n  for (let n = 0; n < t.length; n++)\n    for (let r = 0, i = e.length; r < i; r++)\n      e.push(e[r].concat(t[n]));\n  return e.sort((n, r) => r.length - n.length);\n}\nfunction ia(t) {\n  let e = /* @__PURE__ */ Object.create(null);\n  for (let n in t) {\n    let r = t[n];\n    Array.isArray(r) || (r = [r]);\n    for (let i of n.split(\" \"))\n      if (i) {\n        let s = [], o = 2, a = i;\n        for (let d = 0; ; ) {\n          if (a == \"...\" && d > 0 && d + 3 == i.length) {\n            o = 1;\n            break;\n          }\n          let f = /^\"(?:[^\"\\\\]|\\\\.)*?\"|[^\\/!]+/.exec(a);\n          if (!f)\n            throw new RangeError(\"Invalid path: \" + i);\n          if (s.push(f[0] == \"*\" ? \"\" : f[0][0] == '\"' ? JSON.parse(f[0]) : f[0]), d += f[0].length, d == i.length)\n            break;\n          let h = i[d++];\n          if (d == i.length && h == \"!\") {\n            o = 0;\n            break;\n          }\n          if (h != \"/\")\n            throw new RangeError(\"Invalid path: \" + i);\n          a = i.slice(d);\n        }\n        let l = s.length - 1, c = s[l];\n        if (!c)\n          throw new RangeError(\"Invalid path: \" + i);\n        let u = new Bu(r, o, l > 0 ? s.slice(0, l) : null);\n        e[c] = u.sort(e[c]);\n      }\n  }\n  return rx.add(e);\n}\nconst rx = new Re();\nclass Bu {\n  constructor(e, n, r, i) {\n    this.tags = e, this.mode = n, this.context = r, this.next = i;\n  }\n  get opaque() {\n    return this.mode == 0;\n  }\n  get inherit() {\n    return this.mode == 1;\n  }\n  sort(e) {\n    return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);\n  }\n  get depth() {\n    return this.context ? this.context.length : 0;\n  }\n}\nBu.empty = new Bu([], 2, null);\nfunction ix(t, e) {\n  let n = /* @__PURE__ */ Object.create(null);\n  for (let s of t)\n    if (!Array.isArray(s.tag))\n      n[s.tag.id] = s.class;\n    else\n      for (let o of s.tag)\n        n[o.id] = s.class;\n  let { scope: r, all: i = null } = e || {};\n  return {\n    style: (s) => {\n      let o = i;\n      for (let a of s)\n        for (let l of a.set) {\n          let c = n[l.id];\n          if (c) {\n            o = o ? o + \" \" + c : c;\n            break;\n          }\n        }\n      return o;\n    },\n    scope: r\n  };\n}\nfunction ZD(t, e) {\n  let n = null;\n  for (let r of t) {\n    let i = r.style(e);\n    i && (n = n ? n + \" \" + i : i);\n  }\n  return n;\n}\nfunction VD(t, e, n, r = 0, i = t.length) {\n  let s = new ID(r, Array.isArray(e) ? e : [e], n);\n  s.highlightRange(t.cursor(), r, i, \"\", s.highlighters), s.flush(i);\n}\nclass ID {\n  constructor(e, n, r) {\n    this.at = e, this.highlighters = n, this.span = r, this.class = \"\";\n  }\n  startSpan(e, n) {\n    n != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = n);\n  }\n  flush(e) {\n    e > this.at && this.class && this.span(this.at, e, this.class);\n  }\n  highlightRange(e, n, r, i, s) {\n    let { type: o, from: a, to: l } = e;\n    if (a >= r || l <= n)\n      return;\n    o.isTop && (s = this.highlighters.filter((h) => !h.scope || h.scope(o)));\n    let c = i, u = WD(e) || Bu.empty, d = ZD(s, u.tags);\n    if (d && (c && (c += \" \"), c += d, u.mode == 1 && (i += (i ? \" \" : \"\") + d)), this.startSpan(Math.max(n, a), c), u.opaque)\n      return;\n    let f = e.tree && e.tree.prop(Re.mounted);\n    if (f && f.overlay) {\n      let h = e.node.enter(f.overlay[0].from + a, 1), p = this.highlighters.filter((m) => !m.scope || m.scope(f.tree.type)), O = e.firstChild();\n      for (let m = 0, y = a; ; m++) {\n        let b = m < f.overlay.length ? f.overlay[m] : null, g = b ? b.from + a : l, v = Math.max(n, y), S = Math.min(r, g);\n        if (v < S && O)\n          for (; e.from < S && (this.highlightRange(e, v, S, i, s), this.startSpan(Math.min(S, e.to), c), !(e.to >= g || !e.nextSibling())); )\n            ;\n        if (!b || g > r)\n          break;\n        y = b.to + a, y > n && (this.highlightRange(h.cursor(), Math.max(n, b.from + a), Math.min(r, y), \"\", p), this.startSpan(Math.min(r, y), c));\n      }\n      O && e.parent();\n    } else if (e.firstChild()) {\n      f && (i = \"\");\n      do\n        if (!(e.to <= n)) {\n          if (e.from >= r)\n            break;\n          this.highlightRange(e, n, r, i, s), this.startSpan(Math.min(r, e.to), c);\n        }\n      while (e.nextSibling());\n      e.parent();\n    }\n  }\n}\nfunction WD(t) {\n  let e = t.type.prop(rx);\n  for (; e && e.context && !t.matchContext(e.context); )\n    e = e.next;\n  return e || null;\n}\nconst te = Ni.define, Dc = te(), Di = te(), Mv = te(Di), Xv = te(Di), Zi = te(), Zc = te(Zi), Df = te(Zi), Pr = te(), ms = te(Pr), kr = te(), xr = te(), kp = te(), Sa = te(kp), Vc = te(), P = {\n  /**\n  A comment.\n  */\n  comment: Dc,\n  /**\n  A line [comment](#highlight.tags.comment).\n  */\n  lineComment: te(Dc),\n  /**\n  A block [comment](#highlight.tags.comment).\n  */\n  blockComment: te(Dc),\n  /**\n  A documentation [comment](#highlight.tags.comment).\n  */\n  docComment: te(Dc),\n  /**\n  Any kind of identifier.\n  */\n  name: Di,\n  /**\n  The [name](#highlight.tags.name) of a variable.\n  */\n  variableName: te(Di),\n  /**\n  A type [name](#highlight.tags.name).\n  */\n  typeName: Mv,\n  /**\n  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).\n  */\n  tagName: te(Mv),\n  /**\n  A property or field [name](#highlight.tags.name).\n  */\n  propertyName: Xv,\n  /**\n  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).\n  */\n  attributeName: te(Xv),\n  /**\n  The [name](#highlight.tags.name) of a class.\n  */\n  className: te(Di),\n  /**\n  A label [name](#highlight.tags.name).\n  */\n  labelName: te(Di),\n  /**\n  A namespace [name](#highlight.tags.name).\n  */\n  namespace: te(Di),\n  /**\n  The [name](#highlight.tags.name) of a macro.\n  */\n  macroName: te(Di),\n  /**\n  A literal value.\n  */\n  literal: Zi,\n  /**\n  A string [literal](#highlight.tags.literal).\n  */\n  string: Zc,\n  /**\n  A documentation [string](#highlight.tags.string).\n  */\n  docString: te(Zc),\n  /**\n  A character literal (subtag of [string](#highlight.tags.string)).\n  */\n  character: te(Zc),\n  /**\n  An attribute value (subtag of [string](#highlight.tags.string)).\n  */\n  attributeValue: te(Zc),\n  /**\n  A number [literal](#highlight.tags.literal).\n  */\n  number: Df,\n  /**\n  An integer [number](#highlight.tags.number) literal.\n  */\n  integer: te(Df),\n  /**\n  A floating-point [number](#highlight.tags.number) literal.\n  */\n  float: te(Df),\n  /**\n  A boolean [literal](#highlight.tags.literal).\n  */\n  bool: te(Zi),\n  /**\n  Regular expression [literal](#highlight.tags.literal).\n  */\n  regexp: te(Zi),\n  /**\n  An escape [literal](#highlight.tags.literal), for example a\n  backslash escape in a string.\n  */\n  escape: te(Zi),\n  /**\n  A color [literal](#highlight.tags.literal).\n  */\n  color: te(Zi),\n  /**\n  A URL [literal](#highlight.tags.literal).\n  */\n  url: te(Zi),\n  /**\n  A language keyword.\n  */\n  keyword: kr,\n  /**\n  The [keyword](#highlight.tags.keyword) for the self or this\n  object.\n  */\n  self: te(kr),\n  /**\n  The [keyword](#highlight.tags.keyword) for null.\n  */\n  null: te(kr),\n  /**\n  A [keyword](#highlight.tags.keyword) denoting some atomic value.\n  */\n  atom: te(kr),\n  /**\n  A [keyword](#highlight.tags.keyword) that represents a unit.\n  */\n  unit: te(kr),\n  /**\n  A modifier [keyword](#highlight.tags.keyword).\n  */\n  modifier: te(kr),\n  /**\n  A [keyword](#highlight.tags.keyword) that acts as an operator.\n  */\n  operatorKeyword: te(kr),\n  /**\n  A control-flow related [keyword](#highlight.tags.keyword).\n  */\n  controlKeyword: te(kr),\n  /**\n  A [keyword](#highlight.tags.keyword) that defines something.\n  */\n  definitionKeyword: te(kr),\n  /**\n  A [keyword](#highlight.tags.keyword) related to defining or\n  interfacing with modules.\n  */\n  moduleKeyword: te(kr),\n  /**\n  An operator.\n  */\n  operator: xr,\n  /**\n  An [operator](#highlight.tags.operator) that dereferences something.\n  */\n  derefOperator: te(xr),\n  /**\n  Arithmetic-related [operator](#highlight.tags.operator).\n  */\n  arithmeticOperator: te(xr),\n  /**\n  Logical [operator](#highlight.tags.operator).\n  */\n  logicOperator: te(xr),\n  /**\n  Bit [operator](#highlight.tags.operator).\n  */\n  bitwiseOperator: te(xr),\n  /**\n  Comparison [operator](#highlight.tags.operator).\n  */\n  compareOperator: te(xr),\n  /**\n  [Operator](#highlight.tags.operator) that updates its operand.\n  */\n  updateOperator: te(xr),\n  /**\n  [Operator](#highlight.tags.operator) that defines something.\n  */\n  definitionOperator: te(xr),\n  /**\n  Type-related [operator](#highlight.tags.operator).\n  */\n  typeOperator: te(xr),\n  /**\n  Control-flow [operator](#highlight.tags.operator).\n  */\n  controlOperator: te(xr),\n  /**\n  Program or markup punctuation.\n  */\n  punctuation: kp,\n  /**\n  [Punctuation](#highlight.tags.punctuation) that separates\n  things.\n  */\n  separator: te(kp),\n  /**\n  Bracket-style [punctuation](#highlight.tags.punctuation).\n  */\n  bracket: Sa,\n  /**\n  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`\n  tokens).\n  */\n  angleBracket: te(Sa),\n  /**\n  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`\n  tokens).\n  */\n  squareBracket: te(Sa),\n  /**\n  Parentheses (usually `(` and `)` tokens). Subtag of\n  [bracket](#highlight.tags.bracket).\n  */\n  paren: te(Sa),\n  /**\n  Braces (usually `{` and `}` tokens). Subtag of\n  [bracket](#highlight.tags.bracket).\n  */\n  brace: te(Sa),\n  /**\n  Content, for example plain text in XML or markup documents.\n  */\n  content: Pr,\n  /**\n  [Content](#highlight.tags.content) that represents a heading.\n  */\n  heading: ms,\n  /**\n  A level 1 [heading](#highlight.tags.heading).\n  */\n  heading1: te(ms),\n  /**\n  A level 2 [heading](#highlight.tags.heading).\n  */\n  heading2: te(ms),\n  /**\n  A level 3 [heading](#highlight.tags.heading).\n  */\n  heading3: te(ms),\n  /**\n  A level 4 [heading](#highlight.tags.heading).\n  */\n  heading4: te(ms),\n  /**\n  A level 5 [heading](#highlight.tags.heading).\n  */\n  heading5: te(ms),\n  /**\n  A level 6 [heading](#highlight.tags.heading).\n  */\n  heading6: te(ms),\n  /**\n  A prose separator (such as a horizontal rule).\n  */\n  contentSeparator: te(Pr),\n  /**\n  [Content](#highlight.tags.content) that represents a list.\n  */\n  list: te(Pr),\n  /**\n  [Content](#highlight.tags.content) that represents a quote.\n  */\n  quote: te(Pr),\n  /**\n  [Content](#highlight.tags.content) that is emphasized.\n  */\n  emphasis: te(Pr),\n  /**\n  [Content](#highlight.tags.content) that is styled strong.\n  */\n  strong: te(Pr),\n  /**\n  [Content](#highlight.tags.content) that is part of a link.\n  */\n  link: te(Pr),\n  /**\n  [Content](#highlight.tags.content) that is styled as code or\n  monospace.\n  */\n  monospace: te(Pr),\n  /**\n  [Content](#highlight.tags.content) that has a strike-through\n  style.\n  */\n  strikethrough: te(Pr),\n  /**\n  Inserted text in a change-tracking format.\n  */\n  inserted: te(),\n  /**\n  Deleted text.\n  */\n  deleted: te(),\n  /**\n  Changed text.\n  */\n  changed: te(),\n  /**\n  An invalid or unsyntactic element.\n  */\n  invalid: te(),\n  /**\n  Metadata or meta-instruction.\n  */\n  meta: Vc,\n  /**\n  [Metadata](#highlight.tags.meta) that applies to the entire\n  document.\n  */\n  documentMeta: te(Vc),\n  /**\n  [Metadata](#highlight.tags.meta) that annotates or adds\n  attributes to a given syntactic element.\n  */\n  annotation: te(Vc),\n  /**\n  Processing instruction or preprocessor directive. Subtag of\n  [meta](#highlight.tags.meta).\n  */\n  processingInstruction: te(Vc),\n  /**\n  [Modifier](#highlight.Tag^defineModifier) that indicates that a\n  given element is being defined. Expected to be used with the\n  various [name](#highlight.tags.name) tags.\n  */\n  definition: Ni.defineModifier(),\n  /**\n  [Modifier](#highlight.Tag^defineModifier) that indicates that\n  something is constant. Mostly expected to be used with\n  [variable names](#highlight.tags.variableName).\n  */\n  constant: Ni.defineModifier(),\n  /**\n  [Modifier](#highlight.Tag^defineModifier) used to indicate that\n  a [variable](#highlight.tags.variableName) or [property\n  name](#highlight.tags.propertyName) is being called or defined\n  as a function.\n  */\n  function: Ni.defineModifier(),\n  /**\n  [Modifier](#highlight.Tag^defineModifier) that can be applied to\n  [names](#highlight.tags.name) to indicate that they belong to\n  the language's standard environment.\n  */\n  standard: Ni.defineModifier(),\n  /**\n  [Modifier](#highlight.Tag^defineModifier) that indicates a given\n  [names](#highlight.tags.name) is local to some scope.\n  */\n  local: Ni.defineModifier(),\n  /**\n  A generic variant [modifier](#highlight.Tag^defineModifier) that\n  can be used to tag language-specific alternative variants of\n  some common tag. It is recommended for themes to define special\n  forms of at least the [string](#highlight.tags.string) and\n  [variable name](#highlight.tags.variableName) tags, since those\n  come up a lot.\n  */\n  special: Ni.defineModifier()\n};\nix([\n  { tag: P.link, class: \"tok-link\" },\n  { tag: P.heading, class: \"tok-heading\" },\n  { tag: P.emphasis, class: \"tok-emphasis\" },\n  { tag: P.strong, class: \"tok-strong\" },\n  { tag: P.keyword, class: \"tok-keyword\" },\n  { tag: P.atom, class: \"tok-atom\" },\n  { tag: P.bool, class: \"tok-bool\" },\n  { tag: P.url, class: \"tok-url\" },\n  { tag: P.labelName, class: \"tok-labelName\" },\n  { tag: P.inserted, class: \"tok-inserted\" },\n  { tag: P.deleted, class: \"tok-deleted\" },\n  { tag: P.literal, class: \"tok-literal\" },\n  { tag: P.string, class: \"tok-string\" },\n  { tag: P.number, class: \"tok-number\" },\n  { tag: [P.regexp, P.escape, P.special(P.string)], class: \"tok-string2\" },\n  { tag: P.variableName, class: \"tok-variableName\" },\n  { tag: P.local(P.variableName), class: \"tok-variableName tok-local\" },\n  { tag: P.definition(P.variableName), class: \"tok-variableName tok-definition\" },\n  { tag: P.special(P.variableName), class: \"tok-variableName2\" },\n  { tag: P.definition(P.propertyName), class: \"tok-propertyName tok-definition\" },\n  { tag: P.typeName, class: \"tok-typeName\" },\n  { tag: P.namespace, class: \"tok-namespace\" },\n  { tag: P.className, class: \"tok-className\" },\n  { tag: P.macroName, class: \"tok-macroName\" },\n  { tag: P.propertyName, class: \"tok-propertyName\" },\n  { tag: P.operator, class: \"tok-operator\" },\n  { tag: P.comment, class: \"tok-comment\" },\n  { tag: P.meta, class: \"tok-meta\" },\n  { tag: P.invalid, class: \"tok-invalid\" },\n  { tag: P.punctuation, class: \"tok-punctuation\" }\n]);\nvar Zf;\nconst Oo = /* @__PURE__ */ new Re();\nfunction sx(t) {\n  return ve.define({\n    combine: t ? (e) => e.concat(t) : void 0\n  });\n}\nconst gg = /* @__PURE__ */ new Re();\nclass ur {\n  /**\n  Construct a language object. If you need to invoke this\n  directly, first define a data facet with\n  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then\n  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it\n  to the language's outer syntax node.\n  */\n  constructor(e, n, r = [], i = \"\") {\n    this.data = e, this.name = i, Ye.prototype.hasOwnProperty(\"tree\") || Object.defineProperty(Ye.prototype, \"tree\", { get() {\n      return un(this);\n    } }), this.parser = n, this.extension = [\n      Uo.of(this),\n      Ye.languageData.of((s, o, a) => {\n        let l = jv(s, o, a), c = l.type.prop(Oo);\n        if (!c)\n          return [];\n        let u = s.facet(c), d = l.type.prop(gg);\n        if (d) {\n          let f = l.resolve(o - l.from, a);\n          for (let h of d)\n            if (h.test(f, s)) {\n              let p = s.facet(h.facet);\n              return h.type == \"replace\" ? p : p.concat(u);\n            }\n        }\n        return u;\n      })\n    ].concat(r);\n  }\n  /**\n  Query whether this language is active at the given position.\n  */\n  isActiveAt(e, n, r = -1) {\n    return jv(e, n, r).type.prop(Oo) == this.data;\n  }\n  /**\n  Find the document regions that were parsed using this language.\n  The returned regions will _include_ any nested languages rooted\n  in this language, when those exist.\n  */\n  findRegions(e) {\n    let n = e.facet(Uo);\n    if ((n == null ? void 0 : n.data) == this.data)\n      return [{ from: 0, to: e.doc.length }];\n    if (!n || !n.allowsNesting)\n      return [];\n    let r = [], i = (s, o) => {\n      if (s.prop(Oo) == this.data) {\n        r.push({ from: o, to: o + s.length });\n        return;\n      }\n      let a = s.prop(Re.mounted);\n      if (a) {\n        if (a.tree.prop(Oo) == this.data) {\n          if (a.overlay)\n            for (let l of a.overlay)\n              r.push({ from: l.from + o, to: l.to + o });\n          else\n            r.push({ from: o, to: o + s.length });\n          return;\n        } else if (a.overlay) {\n          let l = r.length;\n          if (i(a.tree, a.overlay[0].from + o), r.length > l)\n            return;\n        }\n      }\n      for (let l = 0; l < s.children.length; l++) {\n        let c = s.children[l];\n        c instanceof gt && i(c, s.positions[l] + o);\n      }\n    };\n    return i(un(e), 0), r;\n  }\n  /**\n  Indicates whether this language allows nested languages. The\n  default implementation returns true.\n  */\n  get allowsNesting() {\n    return !0;\n  }\n}\nur.setState = /* @__PURE__ */ ot.define();\nfunction jv(t, e, n) {\n  let r = t.facet(Uo), i = un(t).topNode;\n  if (!r || r.allowsNesting)\n    for (let s = i; s; s = s.enter(e, n, lt.ExcludeBuffers))\n      s.type.isTop && (i = s);\n  return i;\n}\nclass cs extends ur {\n  constructor(e, n, r) {\n    super(e, n, [], r), this.parser = n;\n  }\n  /**\n  Define a language from a parser.\n  */\n  static define(e) {\n    let n = sx(e.languageData);\n    return new cs(n, e.parser.configure({\n      props: [Oo.add((r) => r.isTop ? n : void 0)]\n    }), e.name);\n  }\n  /**\n  Create a new instance of this language with a reconfigured\n  version of its parser and optionally a new name.\n  */\n  configure(e, n) {\n    return new cs(this.data, this.parser.configure(e), n || this.name);\n  }\n  get allowsNesting() {\n    return this.parser.hasWrappers();\n  }\n}\nfunction un(t) {\n  let e = t.field(ur.state, !1);\n  return e ? e.tree : gt.empty;\n}\nclass MD {\n  /**\n  Create an input object for the given document.\n  */\n  constructor(e) {\n    this.doc = e, this.cursorPos = 0, this.string = \"\", this.cursor = e.iter();\n  }\n  get length() {\n    return this.doc.length;\n  }\n  syncTo(e) {\n    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;\n  }\n  chunk(e) {\n    return this.syncTo(e), this.string;\n  }\n  get lineChunks() {\n    return !0;\n  }\n  read(e, n) {\n    let r = this.cursorPos - this.string.length;\n    return e < r || n >= this.cursorPos ? this.doc.sliceString(e, n) : this.string.slice(e - r, n - r);\n  }\n}\nlet wa = null;\nclass Lu {\n  constructor(e, n, r = [], i, s, o, a, l) {\n    this.parser = e, this.state = n, this.fragments = r, this.tree = i, this.treeLen = s, this.viewport = o, this.skipped = a, this.scheduleOn = l, this.parse = null, this.tempSkipped = [];\n  }\n  /**\n  @internal\n  */\n  static create(e, n, r) {\n    return new Lu(e, n, [], gt.empty, 0, r, [], null);\n  }\n  startParse() {\n    return this.parser.startParse(new MD(this.state.doc), this.fragments);\n  }\n  /**\n  @internal\n  */\n  work(e, n) {\n    return n != null && n >= this.state.doc.length && (n = void 0), this.tree != gt.empty && this.isDone(n ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {\n      var r;\n      if (typeof e == \"number\") {\n        let i = Date.now() + e;\n        e = () => Date.now() > i;\n      }\n      for (this.parse || (this.parse = this.startParse()), n != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > n) && n < this.state.doc.length && this.parse.stopAt(n); ; ) {\n        let i = this.parse.advance();\n        if (i)\n          if (this.fragments = this.withoutTempSkipped(si.addTree(i, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (r = this.parse.stoppedAt) !== null && r !== void 0 ? r : this.state.doc.length, this.tree = i, this.parse = null, this.treeLen < (n ?? this.state.doc.length))\n            this.parse = this.startParse();\n          else\n            return !0;\n        if (e())\n          return !1;\n      }\n    });\n  }\n  /**\n  @internal\n  */\n  takeTree() {\n    let e, n;\n    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {\n      for (; !(n = this.parse.advance()); )\n        ;\n    }), this.treeLen = e, this.tree = n, this.fragments = this.withoutTempSkipped(si.addTree(this.tree, this.fragments, !0)), this.parse = null);\n  }\n  withContext(e) {\n    let n = wa;\n    wa = this;\n    try {\n      return e();\n    } finally {\n      wa = n;\n    }\n  }\n  withoutTempSkipped(e) {\n    for (let n; n = this.tempSkipped.pop(); )\n      e = Bv(e, n.from, n.to);\n    return e;\n  }\n  /**\n  @internal\n  */\n  changes(e, n) {\n    let { fragments: r, tree: i, treeLen: s, viewport: o, skipped: a } = this;\n    if (this.takeTree(), !e.empty) {\n      let l = [];\n      if (e.iterChangedRanges((c, u, d, f) => l.push({ fromA: c, toA: u, fromB: d, toB: f })), r = si.applyChanges(r, l), i = gt.empty, s = 0, o = { from: e.mapPos(o.from, -1), to: e.mapPos(o.to, 1) }, this.skipped.length) {\n        a = [];\n        for (let c of this.skipped) {\n          let u = e.mapPos(c.from, 1), d = e.mapPos(c.to, -1);\n          u < d && a.push({ from: u, to: d });\n        }\n      }\n    }\n    return new Lu(this.parser, n, r, i, s, o, a, this.scheduleOn);\n  }\n  /**\n  @internal\n  */\n  updateViewport(e) {\n    if (this.viewport.from == e.from && this.viewport.to == e.to)\n      return !1;\n    this.viewport = e;\n    let n = this.skipped.length;\n    for (let r = 0; r < this.skipped.length; r++) {\n      let { from: i, to: s } = this.skipped[r];\n      i < e.to && s > e.from && (this.fragments = Bv(this.fragments, i, s), this.skipped.splice(r--, 1));\n    }\n    return this.skipped.length >= n ? !1 : (this.reset(), !0);\n  }\n  /**\n  @internal\n  */\n  reset() {\n    this.parse && (this.takeTree(), this.parse = null);\n  }\n  /**\n  Notify the parse scheduler that the given region was skipped\n  because it wasn't in view, and the parse should be restarted\n  when it comes into view.\n  */\n  skipUntilInView(e, n) {\n    this.skipped.push({ from: e, to: n });\n  }\n  /**\n  Returns a parser intended to be used as placeholder when\n  asynchronously loading a nested parser. It'll skip its input and\n  mark it as not-really-parsed, so that the next update will parse\n  it again.\n  \n  When `until` is given, a reparse will be scheduled when that\n  promise resolves.\n  */\n  static getSkippingParser(e) {\n    return new class extends tx {\n      createParse(n, r, i) {\n        let s = i[0].from, o = i[i.length - 1].to;\n        return {\n          parsedPos: s,\n          advance() {\n            let l = wa;\n            if (l) {\n              for (let c of i)\n                l.tempSkipped.push(c);\n              e && (l.scheduleOn = l.scheduleOn ? Promise.all([l.scheduleOn, e]) : e);\n            }\n            return this.parsedPos = o, new gt(On.none, [], [], o - s);\n          },\n          stoppedAt: null,\n          stopAt() {\n          }\n        };\n      }\n    }();\n  }\n  /**\n  @internal\n  */\n  isDone(e) {\n    e = Math.min(e, this.state.doc.length);\n    let n = this.fragments;\n    return this.treeLen >= e && n.length && n[0].from == 0 && n[0].to >= e;\n  }\n  /**\n  Get the context for the current parse, or `null` if no editor\n  parse is in progress.\n  */\n  static get() {\n    return wa;\n  }\n}\nfunction Bv(t, e, n) {\n  return si.applyChanges(t, [{ fromA: e, toA: n, fromB: e, toB: n }]);\n}\nclass Lo {\n  constructor(e) {\n    this.context = e, this.tree = e.tree;\n  }\n  apply(e) {\n    if (!e.docChanged && this.tree == this.context.tree)\n      return this;\n    let n = this.context.changes(e.changes, e.state), r = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), n.viewport.to);\n    return n.work(20, r) || n.takeTree(), new Lo(n);\n  }\n  static init(e) {\n    let n = Math.min(3e3, e.doc.length), r = Lu.create(e.facet(Uo).parser, e, { from: 0, to: n });\n    return r.work(20, n) || r.takeTree(), new Lo(r);\n  }\n}\nur.state = /* @__PURE__ */ yr.define({\n  create: Lo.init,\n  update(t, e) {\n    for (let n of e.effects)\n      if (n.is(ur.setState))\n        return n.value;\n    return e.startState.facet(Uo) != e.state.facet(Uo) ? Lo.init(e.state) : t.apply(e);\n  }\n});\nlet ox = (t) => {\n  let e = setTimeout(\n    () => t(),\n    500\n    /* Work.MaxPause */\n  );\n  return () => clearTimeout(e);\n};\ntypeof requestIdleCallback < \"u\" && (ox = (t) => {\n  let e = -1, n = setTimeout(\n    () => {\n      e = requestIdleCallback(t, {\n        timeout: 400\n        /* Work.MinPause */\n      });\n    },\n    100\n    /* Work.MinPause */\n  );\n  return () => e < 0 ? clearTimeout(n) : cancelIdleCallback(e);\n});\nconst Vf = typeof navigator < \"u\" && (!((Zf = navigator.scheduling) === null || Zf === void 0) && Zf.isInputPending) ? () => navigator.scheduling.isInputPending() : null, XD = /* @__PURE__ */ rr.fromClass(class {\n  constructor(e) {\n    this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();\n  }\n  update(e) {\n    let n = this.view.state.field(ur.state).context;\n    (n.updateViewport(e.view.viewport) || this.view.viewport.to > n.treeLen) && this.scheduleWork(), (e.docChanged || e.selectionSet) && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(n);\n  }\n  scheduleWork() {\n    if (this.working)\n      return;\n    let { state: e } = this.view, n = e.field(ur.state);\n    (n.tree != n.context.tree || !n.context.isDone(e.doc.length)) && (this.working = ox(this.work));\n  }\n  work(e) {\n    this.working = null;\n    let n = Date.now();\n    if (this.chunkEnd < n && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = n + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)\n      return;\n    let { state: r, viewport: { to: i } } = this.view, s = r.field(ur.state);\n    if (s.tree == s.context.tree && s.context.isDone(\n      i + 1e5\n      /* Work.MaxParseAhead */\n    ))\n      return;\n    let o = Date.now() + Math.min(this.chunkBudget, 100, e && !Vf ? Math.max(25, e.timeRemaining() - 5) : 1e9), a = s.context.treeLen < i && r.doc.length > i + 1e3, l = s.context.work(() => Vf && Vf() || Date.now() > o, i + (a ? 0 : 1e5));\n    this.chunkBudget -= Date.now() - n, (l || this.chunkBudget <= 0) && (s.context.takeTree(), this.view.dispatch({ effects: ur.setState.of(new Lo(s.context)) })), this.chunkBudget > 0 && !(l && !a) && this.scheduleWork(), this.checkAsyncSchedule(s.context);\n  }\n  checkAsyncSchedule(e) {\n    e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((n) => hr(this.view.state, n)).then(() => this.workScheduled--), e.scheduleOn = null);\n  }\n  destroy() {\n    this.working && this.working();\n  }\n  isWorking() {\n    return !!(this.working || this.workScheduled > 0);\n  }\n}, {\n  eventHandlers: { focus() {\n    this.scheduleWork();\n  } }\n}), Uo = /* @__PURE__ */ ve.define({\n  combine(t) {\n    return t.length ? t[0] : null;\n  },\n  enables: (t) => [\n    ur.state,\n    XD,\n    Se.contentAttributes.compute([t], (e) => {\n      let n = e.facet(t);\n      return n && n.name ? { \"data-language\": n.name } : {};\n    })\n  ]\n});\nclass Gl {\n  /**\n  Create a language support object.\n  */\n  constructor(e, n = []) {\n    this.language = e, this.support = n, this.extension = [e, n];\n  }\n}\nconst jD = /* @__PURE__ */ ve.define(), zd = /* @__PURE__ */ ve.define({\n  combine: (t) => {\n    if (!t.length)\n      return \"  \";\n    let e = t[0];\n    if (!e || /\\S/.test(e) || Array.from(e).some((n) => n != e[0]))\n      throw new Error(\"Invalid indent unit: \" + JSON.stringify(t[0]));\n    return e;\n  }\n});\nfunction ax(t) {\n  let e = t.facet(zd);\n  return e.charCodeAt(0) == 9 ? t.tabSize * e.length : e.length;\n}\nfunction lx(t, e) {\n  let n = \"\", r = t.tabSize, i = t.facet(zd)[0];\n  if (i == \"\t\") {\n    for (; e >= r; )\n      n += \"\t\", e -= r;\n    i = \" \";\n  }\n  for (let s = 0; s < e; s++)\n    n += i;\n  return n;\n}\nfunction BD(t, e) {\n  t instanceof Ye && (t = new cx(t));\n  for (let r of t.state.facet(jD)) {\n    let i = r(t, e);\n    if (i !== void 0)\n      return i;\n  }\n  let n = un(t.state);\n  return n.length >= e ? LD(t, n, e) : null;\n}\nclass cx {\n  /**\n  Create an indent context.\n  */\n  constructor(e, n = {}) {\n    this.state = e, this.options = n, this.unit = ax(e);\n  }\n  /**\n  Get a description of the line at the given position, taking\n  [simulated line\n  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)\n  into account. If there is such a break at `pos`, the `bias`\n  argument determines whether the part of the line line before or\n  after the break is used.\n  */\n  lineAt(e, n = 1) {\n    let r = this.state.doc.lineAt(e), { simulateBreak: i, simulateDoubleBreak: s } = this.options;\n    return i != null && i >= r.from && i <= r.to ? s && i == e ? { text: \"\", from: e } : (n < 0 ? i < e : i <= e) ? { text: r.text.slice(i - r.from), from: i } : { text: r.text.slice(0, i - r.from), from: r.from } : r;\n  }\n  /**\n  Get the text directly after `pos`, either the entire line\n  or the next 100 characters, whichever is shorter.\n  */\n  textAfterPos(e, n = 1) {\n    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)\n      return \"\";\n    let { text: r, from: i } = this.lineAt(e, n);\n    return r.slice(e - i, Math.min(r.length, e + 100 - i));\n  }\n  /**\n  Find the column for the given position.\n  */\n  column(e, n = 1) {\n    let { text: r, from: i } = this.lineAt(e, n), s = this.countColumn(r, e - i), o = this.options.overrideIndentation ? this.options.overrideIndentation(i) : -1;\n    return o > -1 && (s += o - this.countColumn(r, r.search(/\\S|$/))), s;\n  }\n  /**\n  Find the column position (taking tabs into account) of the given\n  position in the given string.\n  */\n  countColumn(e, n = e.length) {\n    return ig(e, this.state.tabSize, n);\n  }\n  /**\n  Find the indentation column of the line at the given point.\n  */\n  lineIndent(e, n = 1) {\n    let { text: r, from: i } = this.lineAt(e, n), s = this.options.overrideIndentation;\n    if (s) {\n      let o = s(i);\n      if (o > -1)\n        return o;\n    }\n    return this.countColumn(r, r.search(/\\S|$/));\n  }\n  /**\n  Returns the [simulated line\n  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)\n  for this context, if any.\n  */\n  get simulatedBreak() {\n    return this.options.simulateBreak || null;\n  }\n}\nconst sa = /* @__PURE__ */ new Re();\nfunction LD(t, e, n) {\n  let r = e.resolveStack(n), i = r.node.enterUnfinishedNodesBefore(n);\n  if (i != r.node) {\n    let s = [];\n    for (let o = i; o != r.node; o = o.parent)\n      s.push(o);\n    for (let o = s.length - 1; o >= 0; o--)\n      r = { node: s[o], next: r };\n  }\n  return ux(r, t, n);\n}\nfunction ux(t, e, n) {\n  for (let r = t; r; r = r.next) {\n    let i = qD(r.node);\n    if (i)\n      return i(mg.create(e, n, r));\n  }\n  return 0;\n}\nfunction UD(t) {\n  return t.pos == t.options.simulateBreak && t.options.simulateDoubleBreak;\n}\nfunction qD(t) {\n  let e = t.type.prop(sa);\n  if (e)\n    return e;\n  let n = t.firstChild, r;\n  if (n && (r = n.type.prop(Re.closedBy))) {\n    let i = t.lastChild, s = i && r.indexOf(i.name) > -1;\n    return (o) => dx(o, !0, 1, void 0, s && !UD(o) ? i.from : void 0);\n  }\n  return t.parent == null ? YD : null;\n}\nfunction YD() {\n  return 0;\n}\nclass mg extends cx {\n  constructor(e, n, r) {\n    super(e.state, e.options), this.base = e, this.pos = n, this.context = r;\n  }\n  /**\n  The syntax tree node to which the indentation strategy\n  applies.\n  */\n  get node() {\n    return this.context.node;\n  }\n  /**\n  @internal\n  */\n  static create(e, n, r) {\n    return new mg(e, n, r);\n  }\n  /**\n  Get the text directly after `this.pos`, either the entire line\n  or the next 100 characters, whichever is shorter.\n  */\n  get textAfter() {\n    return this.textAfterPos(this.pos);\n  }\n  /**\n  Get the indentation at the reference line for `this.node`, which\n  is the line on which it starts, unless there is a node that is\n  _not_ a parent of this node covering the start of that line. If\n  so, the line at the start of that node is tried, again skipping\n  on if it is covered by another such node.\n  */\n  get baseIndent() {\n    return this.baseIndentFor(this.node);\n  }\n  /**\n  Get the indentation for the reference line of the given node\n  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).\n  */\n  baseIndentFor(e) {\n    let n = this.state.doc.lineAt(e.from);\n    for (; ; ) {\n      let r = e.resolve(n.from);\n      for (; r.parent && r.parent.from == r.from; )\n        r = r.parent;\n      if (zD(r, e))\n        break;\n      n = this.state.doc.lineAt(r.from);\n    }\n    return this.lineIndent(n.from);\n  }\n  /**\n  Continue looking for indentations in the node's parent nodes,\n  and return the result of that.\n  */\n  continue() {\n    return ux(this.context.next, this.base, this.pos);\n  }\n}\nfunction zD(t, e) {\n  for (let n = e; n; n = n.parent)\n    if (t == n)\n      return !0;\n  return !1;\n}\nfunction HD(t) {\n  let e = t.node, n = e.childAfter(e.from), r = e.lastChild;\n  if (!n)\n    return null;\n  let i = t.options.simulateBreak, s = t.state.doc.lineAt(n.from), o = i == null || i <= s.from ? s.to : Math.min(s.to, i);\n  for (let a = n.to; ; ) {\n    let l = e.childAfter(a);\n    if (!l || l == r)\n      return null;\n    if (!l.type.isSkipped)\n      return l.from < o ? n : null;\n    a = l.to;\n  }\n}\nfunction xp({ closing: t, align: e = !0, units: n = 1 }) {\n  return (r) => dx(r, e, n, t);\n}\nfunction dx(t, e, n, r, i) {\n  let s = t.textAfter, o = s.match(/^\\s*/)[0].length, a = r && s.slice(o, o + r.length) == r || i == t.pos + o, l = e ? HD(t) : null;\n  return l ? a ? t.column(l.from) : t.column(l.to) : t.baseIndent + (a ? 0 : t.unit * n);\n}\nconst FD = (t) => t.baseIndent;\nfunction $o({ except: t, units: e = 1 } = {}) {\n  return (n) => {\n    let r = t && t.test(n.textAfter);\n    return n.baseIndent + (r ? 0 : e * n.unit);\n  };\n}\nconst GD = 200;\nfunction KD() {\n  return Ye.transactionFilter.of((t) => {\n    if (!t.docChanged || !t.isUserEvent(\"input.type\") && !t.isUserEvent(\"input.complete\"))\n      return t;\n    let e = t.startState.languageDataAt(\"indentOnInput\", t.startState.selection.main.head);\n    if (!e.length)\n      return t;\n    let n = t.newDoc, { head: r } = t.newSelection.main, i = n.lineAt(r);\n    if (r > i.from + GD)\n      return t;\n    let s = n.sliceString(i.from, r);\n    if (!e.some((c) => c.test(s)))\n      return t;\n    let { state: o } = t, a = -1, l = [];\n    for (let { head: c } of o.selection.ranges) {\n      let u = o.doc.lineAt(c);\n      if (u.from == a)\n        continue;\n      a = u.from;\n      let d = BD(o, u.from);\n      if (d == null)\n        continue;\n      let f = /^\\s*/.exec(u.text)[0], h = lx(o, d);\n      f != h && l.push({ from: u.from, to: u.from + f.length, insert: h });\n    }\n    return l.length ? [t, { changes: l, sequential: !0 }] : t;\n  });\n}\nconst Kl = /* @__PURE__ */ new Re();\nfunction Hd(t) {\n  let e = t.firstChild, n = t.lastChild;\n  return e && e.to < n.from ? { from: e.to, to: n.type.isError ? t.to : n.from } : null;\n}\nclass Jl {\n  constructor(e, n) {\n    this.specs = e;\n    let r;\n    function i(a) {\n      let l = ss.newName();\n      return (r || (r = /* @__PURE__ */ Object.create(null)))[\".\" + l] = a, l;\n    }\n    const s = typeof n.all == \"string\" ? n.all : n.all ? i(n.all) : void 0, o = n.scope;\n    this.scope = o instanceof ur ? (a) => a.prop(Oo) == o.data : o ? (a) => a == o : void 0, this.style = ix(e.map((a) => ({\n      tag: a.tag,\n      class: a.class || i(Object.assign({}, a, { tag: null }))\n    })), {\n      all: s\n    }).style, this.module = r ? new ss(r) : null, this.themeType = n.themeType;\n  }\n  /**\n  Create a highlighter style that associates the given styles to\n  the given tags. The specs must be objects that hold a style tag\n  or array of tags in their `tag` property, and either a single\n  `class` property providing a static CSS class (for highlighter\n  that rely on external styling), or a\n  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style\n  set of CSS properties (which define the styling for those tags).\n  \n  The CSS rules created for a highlighter will be emitted in the\n  order of the spec's properties. That means that for elements that\n  have multiple tags associated with them, styles defined further\n  down in the list will have a higher CSS precedence than styles\n  defined earlier.\n  */\n  static define(e, n) {\n    return new Jl(e, n || {});\n  }\n}\nconst Pp = /* @__PURE__ */ ve.define(), fx = /* @__PURE__ */ ve.define({\n  combine(t) {\n    return t.length ? [t[0]] : null;\n  }\n});\nfunction If(t) {\n  let e = t.facet(Pp);\n  return e.length ? e : t.facet(fx);\n}\nfunction hx(t, e) {\n  let n = [eZ], r;\n  return t instanceof Jl && (t.module && n.push(Se.styleModule.of(t.module)), r = t.themeType), e != null && e.fallback ? n.push(fx.of(t)) : r ? n.push(Pp.computeN([Se.darkTheme], (i) => i.facet(Se.darkTheme) == (r == \"dark\") ? [t] : [])) : n.push(Pp.of(t)), n;\n}\nclass JD {\n  constructor(e) {\n    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = un(e.state), this.decorations = this.buildDeco(e, If(e.state)), this.decoratedTo = e.viewport.to;\n  }\n  update(e) {\n    let n = un(e.state), r = If(e.state), i = r != If(e.startState), { viewport: s } = e.view, o = e.changes.mapPos(this.decoratedTo, 1);\n    n.length < s.to && !i && n.type == this.tree.type && o >= s.to ? (this.decorations = this.decorations.map(e.changes), this.decoratedTo = o) : (n != this.tree || e.viewportChanged || i) && (this.tree = n, this.decorations = this.buildDeco(e.view, r), this.decoratedTo = s.to);\n  }\n  buildDeco(e, n) {\n    if (!n || !this.tree.length)\n      return Je.none;\n    let r = new jo();\n    for (let { from: i, to: s } of e.visibleRanges)\n      VD(this.tree, n, (o, a, l) => {\n        r.add(o, a, this.markCache[l] || (this.markCache[l] = Je.mark({ class: l })));\n      }, i, s);\n    return r.finish();\n  }\n}\nconst eZ = /* @__PURE__ */ zl.high(/* @__PURE__ */ rr.fromClass(JD, {\n  decorations: (t) => t.decorations\n})), tZ = /* @__PURE__ */ Jl.define([\n  {\n    tag: P.meta,\n    color: \"#404740\"\n  },\n  {\n    tag: P.link,\n    textDecoration: \"underline\"\n  },\n  {\n    tag: P.heading,\n    textDecoration: \"underline\",\n    fontWeight: \"bold\"\n  },\n  {\n    tag: P.emphasis,\n    fontStyle: \"italic\"\n  },\n  {\n    tag: P.strong,\n    fontWeight: \"bold\"\n  },\n  {\n    tag: P.strikethrough,\n    textDecoration: \"line-through\"\n  },\n  {\n    tag: P.keyword,\n    color: \"#708\"\n  },\n  {\n    tag: [P.atom, P.bool, P.url, P.contentSeparator, P.labelName],\n    color: \"#219\"\n  },\n  {\n    tag: [P.literal, P.inserted],\n    color: \"#164\"\n  },\n  {\n    tag: [P.string, P.deleted],\n    color: \"#a11\"\n  },\n  {\n    tag: [P.regexp, P.escape, /* @__PURE__ */ P.special(P.string)],\n    color: \"#e40\"\n  },\n  {\n    tag: /* @__PURE__ */ P.definition(P.variableName),\n    color: \"#00f\"\n  },\n  {\n    tag: /* @__PURE__ */ P.local(P.variableName),\n    color: \"#30a\"\n  },\n  {\n    tag: [P.typeName, P.namespace],\n    color: \"#085\"\n  },\n  {\n    tag: P.className,\n    color: \"#167\"\n  },\n  {\n    tag: [/* @__PURE__ */ P.special(P.variableName), P.macroName],\n    color: \"#256\"\n  },\n  {\n    tag: /* @__PURE__ */ P.definition(P.propertyName),\n    color: \"#00c\"\n  },\n  {\n    tag: P.comment,\n    color: \"#940\"\n  },\n  {\n    tag: P.invalid,\n    color: \"#f00\"\n  }\n]), nZ = /* @__PURE__ */ Se.baseTheme({\n  \"&.cm-focused .cm-matchingBracket\": { backgroundColor: \"#328c8252\" },\n  \"&.cm-focused .cm-nonmatchingBracket\": { backgroundColor: \"#bb555544\" }\n}), px = 1e4, Ox = \"()[]{}\", gx = /* @__PURE__ */ ve.define({\n  combine(t) {\n    return Ud(t, {\n      afterCursor: !0,\n      brackets: Ox,\n      maxScanDistance: px,\n      renderMatch: sZ\n    });\n  }\n}), rZ = /* @__PURE__ */ Je.mark({ class: \"cm-matchingBracket\" }), iZ = /* @__PURE__ */ Je.mark({ class: \"cm-nonmatchingBracket\" });\nfunction sZ(t) {\n  let e = [], n = t.matched ? rZ : iZ;\n  return e.push(n.range(t.start.from, t.start.to)), t.end && e.push(n.range(t.end.from, t.end.to)), e;\n}\nconst oZ = /* @__PURE__ */ yr.define({\n  create() {\n    return Je.none;\n  },\n  update(t, e) {\n    if (!e.docChanged && !e.selection)\n      return t;\n    let n = [], r = e.state.facet(gx);\n    for (let i of e.state.selection.ranges) {\n      if (!i.empty)\n        continue;\n      let s = Ic(e.state, i.head, -1, r) || i.head > 0 && Ic(e.state, i.head - 1, 1, r) || r.afterCursor && (Ic(e.state, i.head, 1, r) || i.head < e.state.doc.length && Ic(e.state, i.head + 1, -1, r));\n      s && (n = n.concat(r.renderMatch(s, e.state)));\n    }\n    return Je.set(n, !0);\n  },\n  provide: (t) => Se.decorations.from(t)\n}), aZ = [\n  oZ,\n  nZ\n];\nfunction lZ(t = {}) {\n  return [gx.of(t), aZ];\n}\nconst mx = /* @__PURE__ */ new Re();\nfunction _p(t, e, n) {\n  let r = t.prop(e < 0 ? Re.openedBy : Re.closedBy);\n  if (r)\n    return r;\n  if (t.name.length == 1) {\n    let i = n.indexOf(t.name);\n    if (i > -1 && i % 2 == (e < 0 ? 1 : 0))\n      return [n[i + e]];\n  }\n  return null;\n}\nfunction Tp(t) {\n  let e = t.type.prop(mx);\n  return e ? e(t.node) : t;\n}\nfunction Ic(t, e, n, r = {}) {\n  let i = r.maxScanDistance || px, s = r.brackets || Ox, o = un(t), a = o.resolveInner(e, n);\n  for (let l = a; l; l = l.parent) {\n    let c = _p(l.type, n, s);\n    if (c && l.from < l.to) {\n      let u = Tp(l);\n      if (u && (n > 0 ? e >= u.from && e < u.to : e > u.from && e <= u.to))\n        return cZ(t, e, n, l, u, c, s);\n    }\n  }\n  return uZ(t, e, n, o, a.type, i, s);\n}\nfunction cZ(t, e, n, r, i, s, o) {\n  let a = r.parent, l = { from: i.from, to: i.to }, c = 0, u = a == null ? void 0 : a.cursor();\n  if (u && (n < 0 ? u.childBefore(r.from) : u.childAfter(r.to)))\n    do\n      if (n < 0 ? u.to <= r.from : u.from >= r.to) {\n        if (c == 0 && s.indexOf(u.type.name) > -1 && u.from < u.to) {\n          let d = Tp(u);\n          return { start: l, end: d ? { from: d.from, to: d.to } : void 0, matched: !0 };\n        } else if (_p(u.type, n, o))\n          c++;\n        else if (_p(u.type, -n, o)) {\n          if (c == 0) {\n            let d = Tp(u);\n            return {\n              start: l,\n              end: d && d.from < d.to ? { from: d.from, to: d.to } : void 0,\n              matched: !1\n            };\n          }\n          c--;\n        }\n      }\n    while (n < 0 ? u.prevSibling() : u.nextSibling());\n  return { start: l, matched: !1 };\n}\nfunction uZ(t, e, n, r, i, s, o) {\n  let a = n < 0 ? t.sliceDoc(e - 1, e) : t.sliceDoc(e, e + 1), l = o.indexOf(a);\n  if (l < 0 || l % 2 == 0 != n > 0)\n    return null;\n  let c = { from: n < 0 ? e - 1 : e, to: n > 0 ? e + 1 : e }, u = t.doc.iterRange(e, n > 0 ? t.doc.length : 0), d = 0;\n  for (let f = 0; !u.next().done && f <= s; ) {\n    let h = u.value;\n    n < 0 && (f += h.length);\n    let p = e + f * n;\n    for (let O = n > 0 ? 0 : h.length - 1, m = n > 0 ? h.length : -1; O != m; O += n) {\n      let y = o.indexOf(h[O]);\n      if (!(y < 0 || r.resolveInner(p + O, 1).type != i))\n        if (y % 2 == 0 == n > 0)\n          d++;\n        else {\n          if (d == 1)\n            return { start: c, end: { from: p + O, to: p + O + 1 }, matched: y >> 1 == l >> 1 };\n          d--;\n        }\n    }\n    n > 0 && (f += h.length);\n  }\n  return u.done ? { start: c, matched: !1 } : null;\n}\nconst dZ = /* @__PURE__ */ Object.create(null), Lv = [On.none], Uv = [], qv = /* @__PURE__ */ Object.create(null), fZ = /* @__PURE__ */ Object.create(null);\nfor (let [t, e] of [\n  [\"variable\", \"variableName\"],\n  [\"variable-2\", \"variableName.special\"],\n  [\"string-2\", \"string.special\"],\n  [\"def\", \"variableName.definition\"],\n  [\"tag\", \"tagName\"],\n  [\"attribute\", \"attributeName\"],\n  [\"type\", \"typeName\"],\n  [\"builtin\", \"variableName.standard\"],\n  [\"qualifier\", \"modifier\"],\n  [\"error\", \"invalid\"],\n  [\"header\", \"heading\"],\n  [\"property\", \"propertyName\"]\n])\n  fZ[t] = /* @__PURE__ */ hZ(dZ, e);\nfunction Wf(t, e) {\n  Uv.indexOf(t) > -1 || (Uv.push(t), console.warn(e));\n}\nfunction hZ(t, e) {\n  let n = [];\n  for (let a of e.split(\" \")) {\n    let l = [];\n    for (let c of a.split(\".\")) {\n      let u = t[c] || P[c];\n      u ? typeof u == \"function\" ? l.length ? l = l.map(u) : Wf(c, `Modifier ${c} used at start of tag`) : l.length ? Wf(c, `Tag ${c} used as modifier`) : l = Array.isArray(u) ? u : [u] : Wf(c, `Unknown highlighting tag ${c}`);\n    }\n    for (let c of l)\n      n.push(c);\n  }\n  if (!n.length)\n    return 0;\n  let r = e.replace(/ /g, \"_\"), i = r + \" \" + n.map((a) => a.id), s = qv[i];\n  if (s)\n    return s.id;\n  let o = qv[i] = On.define({\n    id: Lv.length,\n    name: r,\n    props: [ia({ [r]: n })]\n  });\n  return Lv.push(o), o.id;\n}\nQt.RTL, Qt.LTR;\nclass bx {\n  /**\n  Create a new completion context. (Mostly useful for testing\n  completion sourcesin the editor, the extension will create\n  these for you.)\n  */\n  constructor(e, n, r) {\n    this.state = e, this.pos = n, this.explicit = r, this.abortListeners = [];\n  }\n  /**\n  Get the extent, content, and (if there is a token) type of the\n  token before `this.pos`.\n  */\n  tokenBefore(e) {\n    let n = un(this.state).resolveInner(this.pos, -1);\n    for (; n && e.indexOf(n.name) < 0; )\n      n = n.parent;\n    return n ? {\n      from: n.from,\n      to: this.pos,\n      text: this.state.sliceDoc(n.from, this.pos),\n      type: n.type\n    } : null;\n  }\n  /**\n  Get the match of the given expression directly before the\n  cursor.\n  */\n  matchBefore(e) {\n    let n = this.state.doc.lineAt(this.pos), r = Math.max(n.from, this.pos - 250), i = n.text.slice(r - n.from, this.pos - n.from), s = i.search(yx(e, !1));\n    return s < 0 ? null : { from: r + s, to: this.pos, text: i.slice(s) };\n  }\n  /**\n  Yields true when the query has been aborted. Can be useful in\n  asynchronous queries to avoid doing work that will be ignored.\n  */\n  get aborted() {\n    return this.abortListeners == null;\n  }\n  /**\n  Allows you to register abort handlers, which will be called when\n  the query is\n  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).\n  */\n  addEventListener(e, n) {\n    e == \"abort\" && this.abortListeners && this.abortListeners.push(n);\n  }\n}\nfunction Yv(t) {\n  let e = Object.keys(t).join(\"\"), n = /\\w/.test(e);\n  return n && (e = e.replace(/\\w/g, \"\")), `[${n ? \"\\\\w\" : \"\"}${e.replace(/[^\\w\\s]/g, \"\\\\$&\")}]`;\n}\nfunction pZ(t) {\n  let e = /* @__PURE__ */ Object.create(null), n = /* @__PURE__ */ Object.create(null);\n  for (let { label: i } of t) {\n    e[i[0]] = !0;\n    for (let s = 1; s < i.length; s++)\n      n[i[s]] = !0;\n  }\n  let r = Yv(e) + Yv(n) + \"*$\";\n  return [new RegExp(\"^\" + r), new RegExp(r)];\n}\nfunction vx(t) {\n  let e = t.map((i) => typeof i == \"string\" ? { label: i } : i), [n, r] = e.every((i) => /^\\w+$/.test(i.label)) ? [/\\w*$/, /\\w+$/] : pZ(e);\n  return (i) => {\n    let s = i.matchBefore(r);\n    return s || i.explicit ? { from: s ? s.from : i.pos, options: e, validFor: n } : null;\n  };\n}\nfunction OZ(t, e) {\n  return (n) => {\n    for (let r = un(n.state).resolveInner(n.pos, -1); r; r = r.parent) {\n      if (t.indexOf(r.name) > -1)\n        return null;\n      if (r.type.isTop)\n        break;\n    }\n    return e(n);\n  };\n}\nclass zv {\n  constructor(e, n, r, i) {\n    this.completion = e, this.source = n, this.match = r, this.score = i;\n  }\n}\nfunction Ji(t) {\n  return t.selection.main.from;\n}\nfunction yx(t, e) {\n  var n;\n  let { source: r } = t, i = e && r[0] != \"^\", s = r[r.length - 1] != \"$\";\n  return !i && !s ? t : new RegExp(`${i ? \"^\" : \"\"}(?:${r})${s ? \"$\" : \"\"}`, (n = t.flags) !== null && n !== void 0 ? n : t.ignoreCase ? \"i\" : \"\");\n}\nconst Sx = /* @__PURE__ */ no.define();\nfunction gZ(t, e, n, r) {\n  let { main: i } = t.selection, s = n - i.from, o = r - i.from;\n  return Object.assign(Object.assign({}, t.changeByRange((a) => a != i && n != r && t.sliceDoc(a.from + s, a.from + o) != t.sliceDoc(n, r) ? { range: a } : {\n    changes: { from: a.from + s, to: r == i.from ? a.to : a.from + o, insert: e },\n    range: ae.cursor(a.from + s + e.length)\n  })), { scrollIntoView: !0, userEvent: \"input.complete\" });\n}\nconst Hv = /* @__PURE__ */ new WeakMap();\nfunction mZ(t) {\n  if (!Array.isArray(t))\n    return t;\n  let e = Hv.get(t);\n  return e || Hv.set(t, e = vx(t)), e;\n}\nconst Uu = /* @__PURE__ */ ot.define(), Sl = /* @__PURE__ */ ot.define();\nclass bZ {\n  constructor(e) {\n    this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];\n    for (let n = 0; n < e.length; ) {\n      let r = nn(e, n), i = cr(r);\n      this.chars.push(r);\n      let s = e.slice(n, n + i), o = s.toUpperCase();\n      this.folded.push(nn(o == s ? s.toLowerCase() : o, 0)), n += i;\n    }\n    this.astral = e.length != this.chars.length;\n  }\n  ret(e, n) {\n    return this.score = e, this.matched = n, !0;\n  }\n  // Matches a given word (completion) against the pattern (input).\n  // Will return a boolean indicating whether there was a match and,\n  // on success, set `this.score` to the score, `this.matched` to an\n  // array of `from, to` pairs indicating the matched parts of `word`.\n  //\n  // The score is a number that is more negative the worse the match\n  // is. See `Penalty` above.\n  match(e) {\n    if (this.pattern.length == 0)\n      return this.ret(-100, []);\n    if (e.length < this.pattern.length)\n      return !1;\n    let { chars: n, folded: r, any: i, precise: s, byWord: o } = this;\n    if (n.length == 1) {\n      let b = nn(e, 0), g = cr(b), v = g == e.length ? 0 : -100;\n      if (b != n[0])\n        if (b == r[0])\n          v += -200;\n        else\n          return !1;\n      return this.ret(v, [0, g]);\n    }\n    let a = e.indexOf(this.pattern);\n    if (a == 0)\n      return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);\n    let l = n.length, c = 0;\n    if (a < 0) {\n      for (let b = 0, g = Math.min(e.length, 200); b < g && c < l; ) {\n        let v = nn(e, b);\n        (v == n[c] || v == r[c]) && (i[c++] = b), b += cr(v);\n      }\n      if (c < l)\n        return !1;\n    }\n    let u = 0, d = 0, f = !1, h = 0, p = -1, O = -1, m = /[a-z]/.test(e), y = !0;\n    for (let b = 0, g = Math.min(e.length, 200), v = 0; b < g && d < l; ) {\n      let S = nn(e, b);\n      a < 0 && (u < l && S == n[u] && (s[u++] = b), h < l && (S == n[h] || S == r[h] ? (h == 0 && (p = b), O = b + 1, h++) : h = 0));\n      let w, k = S < 255 ? S >= 48 && S <= 57 || S >= 97 && S <= 122 ? 2 : S >= 65 && S <= 90 ? 1 : 0 : (w = Iw(S)) != w.toLowerCase() ? 1 : w != w.toUpperCase() ? 2 : 0;\n      (!b || k == 1 && m || v == 0 && k != 0) && (n[d] == S || r[d] == S && (f = !0) ? o[d++] = b : o.length && (y = !1)), v = k, b += cr(S);\n    }\n    return d == l && o[0] == 0 && y ? this.result(-100 + (f ? -200 : 0), o, e) : h == l && p == 0 ? this.ret(-200 - e.length + (O == e.length ? 0 : -100), [0, O]) : a > -1 ? this.ret(-700 - e.length, [a, a + this.pattern.length]) : h == l ? this.ret(-900 - e.length, [p, O]) : d == l ? this.result(-100 + (f ? -200 : 0) + -700 + (y ? 0 : -1100), o, e) : n.length == 2 ? !1 : this.result((i[0] ? -700 : 0) + -200 + -1100, i, e);\n  }\n  result(e, n, r) {\n    let i = [], s = 0;\n    for (let o of n) {\n      let a = o + (this.astral ? cr(nn(r, o)) : 1);\n      s && i[s - 1] == o ? i[s - 1] = a : (i[s++] = o, i[s++] = a);\n    }\n    return this.ret(e - r.length, i);\n  }\n}\nconst Ft = /* @__PURE__ */ ve.define({\n  combine(t) {\n    return Ud(t, {\n      activateOnTyping: !0,\n      activateOnTypingDelay: 100,\n      selectOnOpen: !0,\n      override: null,\n      closeOnBlur: !0,\n      maxRenderedOptions: 100,\n      defaultKeymap: !0,\n      tooltipClass: () => \"\",\n      optionClass: () => \"\",\n      aboveCursor: !1,\n      icons: !0,\n      addToOptions: [],\n      positionInfo: vZ,\n      compareCompletions: (e, n) => e.label.localeCompare(n.label),\n      interactionDelay: 75,\n      updateSyncTime: 100\n    }, {\n      defaultKeymap: (e, n) => e && n,\n      closeOnBlur: (e, n) => e && n,\n      icons: (e, n) => e && n,\n      tooltipClass: (e, n) => (r) => Fv(e(r), n(r)),\n      optionClass: (e, n) => (r) => Fv(e(r), n(r)),\n      addToOptions: (e, n) => e.concat(n)\n    });\n  }\n});\nfunction Fv(t, e) {\n  return t ? e ? t + \" \" + e : t : e;\n}\nfunction vZ(t, e, n, r, i, s) {\n  let o = t.textDirection == Qt.RTL, a = o, l = !1, c = \"top\", u, d, f = e.left - i.left, h = i.right - e.right, p = r.right - r.left, O = r.bottom - r.top;\n  if (a && f < Math.min(p, h) ? a = !1 : !a && h < Math.min(p, f) && (a = !0), p <= (a ? f : h))\n    u = Math.max(i.top, Math.min(n.top, i.bottom - O)) - e.top, d = Math.min(400, a ? f : h);\n  else {\n    l = !0, d = Math.min(\n      400,\n      (o ? e.right : i.right - e.left) - 30\n      /* Info.Margin */\n    );\n    let b = i.bottom - e.bottom;\n    b >= O || b > e.top ? u = n.bottom - e.top : (c = \"bottom\", u = e.bottom - n.top);\n  }\n  let m = (e.bottom - e.top) / s.offsetHeight, y = (e.right - e.left) / s.offsetWidth;\n  return {\n    style: `${c}: ${u / m}px; max-width: ${d / y}px`,\n    class: \"cm-completionInfo-\" + (l ? o ? \"left-narrow\" : \"right-narrow\" : a ? \"left\" : \"right\")\n  };\n}\nfunction yZ(t) {\n  let e = t.addToOptions.slice();\n  return t.icons && e.push({\n    render(n) {\n      let r = document.createElement(\"div\");\n      return r.classList.add(\"cm-completionIcon\"), n.type && r.classList.add(...n.type.split(/\\s+/g).map((i) => \"cm-completionIcon-\" + i)), r.setAttribute(\"aria-hidden\", \"true\"), r;\n    },\n    position: 20\n  }), e.push({\n    render(n, r, i, s) {\n      let o = document.createElement(\"span\");\n      o.className = \"cm-completionLabel\";\n      let a = n.displayLabel || n.label, l = 0;\n      for (let c = 0; c < s.length; ) {\n        let u = s[c++], d = s[c++];\n        u > l && o.appendChild(document.createTextNode(a.slice(l, u)));\n        let f = o.appendChild(document.createElement(\"span\"));\n        f.appendChild(document.createTextNode(a.slice(u, d))), f.className = \"cm-completionMatchedText\", l = d;\n      }\n      return l < a.length && o.appendChild(document.createTextNode(a.slice(l))), o;\n    },\n    position: 50\n  }, {\n    render(n) {\n      if (!n.detail)\n        return null;\n      let r = document.createElement(\"span\");\n      return r.className = \"cm-completionDetail\", r.textContent = n.detail, r;\n    },\n    position: 80\n  }), e.sort((n, r) => n.position - r.position).map((n) => n.render);\n}\nfunction Mf(t, e, n) {\n  if (t <= n)\n    return { from: 0, to: t };\n  if (e < 0 && (e = 0), e <= t >> 1) {\n    let i = Math.floor(e / n);\n    return { from: i * n, to: (i + 1) * n };\n  }\n  let r = Math.floor((t - e) / n);\n  return { from: t - (r + 1) * n, to: t - r * n };\n}\nclass SZ {\n  constructor(e, n, r) {\n    this.view = e, this.stateField = n, this.applyCompletion = r, this.info = null, this.infoDestroy = null, this.placeInfoReq = {\n      read: () => this.measureInfo(),\n      write: (l) => this.placeInfo(l),\n      key: this\n    }, this.space = null, this.currentClass = \"\";\n    let i = e.state.field(n), { options: s, selected: o } = i.open, a = e.state.facet(Ft);\n    this.optionContent = yZ(a), this.optionClass = a.optionClass, this.tooltipClass = a.tooltipClass, this.range = Mf(s.length, o, a.maxRenderedOptions), this.dom = document.createElement(\"div\"), this.dom.className = \"cm-tooltip-autocomplete\", this.updateTooltipClass(e.state), this.dom.addEventListener(\"mousedown\", (l) => {\n      let { options: c } = e.state.field(n).open;\n      for (let u = l.target, d; u && u != this.dom; u = u.parentNode)\n        if (u.nodeName == \"LI\" && (d = /-(\\d+)$/.exec(u.id)) && +d[1] < c.length) {\n          this.applyCompletion(e, c[+d[1]]), l.preventDefault();\n          return;\n        }\n    }), this.dom.addEventListener(\"focusout\", (l) => {\n      let c = e.state.field(this.stateField, !1);\n      c && c.tooltip && e.state.facet(Ft).closeOnBlur && l.relatedTarget != e.contentDOM && e.dispatch({ effects: Sl.of(null) });\n    }), this.showOptions(s, i.id);\n  }\n  mount() {\n    this.updateSel();\n  }\n  showOptions(e, n) {\n    this.list && this.list.remove(), this.list = this.dom.appendChild(this.createListBox(e, n, this.range)), this.list.addEventListener(\"scroll\", () => {\n      this.info && this.view.requestMeasure(this.placeInfoReq);\n    });\n  }\n  update(e) {\n    var n;\n    let r = e.state.field(this.stateField), i = e.startState.field(this.stateField);\n    if (this.updateTooltipClass(e.state), r != i) {\n      let { options: s, selected: o, disabled: a } = r.open;\n      (!i.open || i.open.options != s) && (this.range = Mf(s.length, o, e.state.facet(Ft).maxRenderedOptions), this.showOptions(s, r.id)), this.updateSel(), a != ((n = i.open) === null || n === void 0 ? void 0 : n.disabled) && this.dom.classList.toggle(\"cm-tooltip-autocomplete-disabled\", !!a);\n    }\n  }\n  updateTooltipClass(e) {\n    let n = this.tooltipClass(e);\n    if (n != this.currentClass) {\n      for (let r of this.currentClass.split(\" \"))\n        r && this.dom.classList.remove(r);\n      for (let r of n.split(\" \"))\n        r && this.dom.classList.add(r);\n      this.currentClass = n;\n    }\n  }\n  positioned(e) {\n    this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq);\n  }\n  updateSel() {\n    let e = this.view.state.field(this.stateField), n = e.open;\n    if ((n.selected > -1 && n.selected < this.range.from || n.selected >= this.range.to) && (this.range = Mf(n.options.length, n.selected, this.view.state.facet(Ft).maxRenderedOptions), this.showOptions(n.options, e.id)), this.updateSelectedOption(n.selected)) {\n      this.destroyInfo();\n      let { completion: r } = n.options[n.selected], { info: i } = r;\n      if (!i)\n        return;\n      let s = typeof i == \"string\" ? document.createTextNode(i) : i(r);\n      if (!s)\n        return;\n      \"then\" in s ? s.then((o) => {\n        o && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(o, r);\n      }).catch((o) => hr(this.view.state, o, \"completion info\")) : this.addInfoPane(s, r);\n    }\n  }\n  addInfoPane(e, n) {\n    this.destroyInfo();\n    let r = this.info = document.createElement(\"div\");\n    if (r.className = \"cm-tooltip cm-completionInfo\", e.nodeType != null)\n      r.appendChild(e), this.infoDestroy = null;\n    else {\n      let { dom: i, destroy: s } = e;\n      r.appendChild(i), this.infoDestroy = s || null;\n    }\n    this.dom.appendChild(r), this.view.requestMeasure(this.placeInfoReq);\n  }\n  updateSelectedOption(e) {\n    let n = null;\n    for (let r = this.list.firstChild, i = this.range.from; r; r = r.nextSibling, i++)\n      r.nodeName != \"LI\" || !r.id ? i-- : i == e ? r.hasAttribute(\"aria-selected\") || (r.setAttribute(\"aria-selected\", \"true\"), n = r) : r.hasAttribute(\"aria-selected\") && r.removeAttribute(\"aria-selected\");\n    return n && kZ(this.list, n), n;\n  }\n  measureInfo() {\n    let e = this.dom.querySelector(\"[aria-selected]\");\n    if (!e || !this.info)\n      return null;\n    let n = this.dom.getBoundingClientRect(), r = this.info.getBoundingClientRect(), i = e.getBoundingClientRect(), s = this.space;\n    if (!s) {\n      let o = this.dom.ownerDocument.defaultView || window;\n      s = { left: 0, top: 0, right: o.innerWidth, bottom: o.innerHeight };\n    }\n    return i.top > Math.min(s.bottom, n.bottom) - 10 || i.bottom < Math.max(s.top, n.top) + 10 ? null : this.view.state.facet(Ft).positionInfo(this.view, n, i, r, s, this.dom);\n  }\n  placeInfo(e) {\n    this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = \"cm-tooltip cm-completionInfo \" + (e.class || \"\")) : this.info.style.cssText = \"top: -1e6px\");\n  }\n  createListBox(e, n, r) {\n    const i = document.createElement(\"ul\");\n    i.id = n, i.setAttribute(\"role\", \"listbox\"), i.setAttribute(\"aria-expanded\", \"true\"), i.setAttribute(\"aria-label\", this.view.state.phrase(\"Completions\"));\n    let s = null;\n    for (let o = r.from; o < r.to; o++) {\n      let { completion: a, match: l } = e[o], { section: c } = a;\n      if (c) {\n        let f = typeof c == \"string\" ? c : c.name;\n        if (f != s && (o > r.from || r.from == 0))\n          if (s = f, typeof c != \"string\" && c.header)\n            i.appendChild(c.header(c));\n          else {\n            let h = i.appendChild(document.createElement(\"completion-section\"));\n            h.textContent = f;\n          }\n      }\n      const u = i.appendChild(document.createElement(\"li\"));\n      u.id = n + \"-\" + o, u.setAttribute(\"role\", \"option\");\n      let d = this.optionClass(a);\n      d && (u.className = d);\n      for (let f of this.optionContent) {\n        let h = f(a, this.view.state, this.view, l);\n        h && u.appendChild(h);\n      }\n    }\n    return r.from && i.classList.add(\"cm-completionListIncompleteTop\"), r.to < e.length && i.classList.add(\"cm-completionListIncompleteBottom\"), i;\n  }\n  destroyInfo() {\n    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);\n  }\n  destroy() {\n    this.destroyInfo();\n  }\n}\nfunction wZ(t, e) {\n  return (n) => new SZ(n, t, e);\n}\nfunction kZ(t, e) {\n  let n = t.getBoundingClientRect(), r = e.getBoundingClientRect(), i = n.height / t.offsetHeight;\n  r.top < n.top ? t.scrollTop -= (n.top - r.top) / i : r.bottom > n.bottom && (t.scrollTop += (r.bottom - n.bottom) / i);\n}\nfunction Gv(t) {\n  return (t.boost || 0) * 100 + (t.apply ? 10 : 0) + (t.info ? 5 : 0) + (t.type ? 1 : 0);\n}\nfunction xZ(t, e) {\n  let n = [], r = null, i = (l) => {\n    n.push(l);\n    let { section: c } = l.completion;\n    if (c) {\n      r || (r = []);\n      let u = typeof c == \"string\" ? c : c.name;\n      r.some((d) => d.name == u) || r.push(typeof c == \"string\" ? { name: u } : c);\n    }\n  };\n  for (let l of t)\n    if (l.hasResult()) {\n      let c = l.result.getMatch;\n      if (l.result.filter === !1)\n        for (let u of l.result.options)\n          i(new zv(u, l.source, c ? c(u) : [], 1e9 - n.length));\n      else {\n        let u = new bZ(e.sliceDoc(l.from, l.to));\n        for (let d of l.result.options)\n          if (u.match(d.label)) {\n            let f = d.displayLabel ? c ? c(d, u.matched) : [] : u.matched;\n            i(new zv(d, l.source, f, u.score + (d.boost || 0)));\n          }\n      }\n    }\n  if (r) {\n    let l = /* @__PURE__ */ Object.create(null), c = 0, u = (d, f) => {\n      var h, p;\n      return ((h = d.rank) !== null && h !== void 0 ? h : 1e9) - ((p = f.rank) !== null && p !== void 0 ? p : 1e9) || (d.name < f.name ? -1 : 1);\n    };\n    for (let d of r.sort(u))\n      c -= 1e5, l[d.name] = c;\n    for (let d of n) {\n      let { section: f } = d.completion;\n      f && (d.score += l[typeof f == \"string\" ? f : f.name]);\n    }\n  }\n  let s = [], o = null, a = e.facet(Ft).compareCompletions;\n  for (let l of n.sort((c, u) => u.score - c.score || a(c.completion, u.completion))) {\n    let c = l.completion;\n    !o || o.label != c.label || o.detail != c.detail || o.type != null && c.type != null && o.type != c.type || o.apply != c.apply || o.boost != c.boost ? s.push(l) : Gv(l.completion) > Gv(o) && (s[s.length - 1] = l), o = l.completion;\n  }\n  return s;\n}\nclass go {\n  constructor(e, n, r, i, s, o) {\n    this.options = e, this.attrs = n, this.tooltip = r, this.timestamp = i, this.selected = s, this.disabled = o;\n  }\n  setSelected(e, n) {\n    return e == this.selected || e >= this.options.length ? this : new go(this.options, Kv(n, e), this.tooltip, this.timestamp, e, this.disabled);\n  }\n  static build(e, n, r, i, s) {\n    let o = xZ(e, n);\n    if (!o.length)\n      return i && e.some(\n        (l) => l.state == 1\n        /* State.Pending */\n      ) ? new go(i.options, i.attrs, i.tooltip, i.timestamp, i.selected, !0) : null;\n    let a = n.facet(Ft).selectOnOpen ? 0 : -1;\n    if (i && i.selected != a && i.selected != -1) {\n      let l = i.options[i.selected].completion;\n      for (let c = 0; c < o.length; c++)\n        if (o[c].completion == l) {\n          a = c;\n          break;\n        }\n    }\n    return new go(o, Kv(r, a), {\n      pos: e.reduce((l, c) => c.hasResult() ? Math.min(l, c.from) : l, 1e8),\n      create: $Z,\n      above: s.aboveCursor\n    }, i ? i.timestamp : Date.now(), a, !1);\n  }\n  map(e) {\n    return new go(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: e.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);\n  }\n}\nclass qu {\n  constructor(e, n, r) {\n    this.active = e, this.id = n, this.open = r;\n  }\n  static start() {\n    return new qu(TZ, \"cm-ac-\" + Math.floor(Math.random() * 2e6).toString(36), null);\n  }\n  update(e) {\n    let { state: n } = e, r = n.facet(Ft), s = (r.override || n.languageDataAt(\"autocomplete\", Ji(n)).map(mZ)).map((a) => (this.active.find((c) => c.source == a) || new wn(\n      a,\n      this.active.some(\n        (c) => c.state != 0\n        /* State.Inactive */\n      ) ? 1 : 0\n      /* State.Inactive */\n    )).update(e, r));\n    s.length == this.active.length && s.every((a, l) => a == this.active[l]) && (s = this.active);\n    let o = this.open;\n    o && e.docChanged && (o = o.map(e.changes)), e.selection || s.some((a) => a.hasResult() && e.changes.touchesRange(a.from, a.to)) || !PZ(s, this.active) ? o = go.build(s, n, this.id, o, r) : o && o.disabled && !s.some(\n      (a) => a.state == 1\n      /* State.Pending */\n    ) && (o = null), !o && s.every(\n      (a) => a.state != 1\n      /* State.Pending */\n    ) && s.some((a) => a.hasResult()) && (s = s.map((a) => a.hasResult() ? new wn(\n      a.source,\n      0\n      /* State.Inactive */\n    ) : a));\n    for (let a of e.effects)\n      a.is(kx) && (o = o && o.setSelected(a.value, this.id));\n    return s == this.active && o == this.open ? this : new qu(s, this.id, o);\n  }\n  get tooltip() {\n    return this.open ? this.open.tooltip : null;\n  }\n  get attrs() {\n    return this.open ? this.open.attrs : _Z;\n  }\n}\nfunction PZ(t, e) {\n  if (t == e)\n    return !0;\n  for (let n = 0, r = 0; ; ) {\n    for (; n < t.length && !t[n].hasResult; )\n      n++;\n    for (; r < e.length && !e[r].hasResult; )\n      r++;\n    let i = n == t.length, s = r == e.length;\n    if (i || s)\n      return i == s;\n    if (t[n++].result != e[r++].result)\n      return !1;\n  }\n}\nconst _Z = {\n  \"aria-autocomplete\": \"list\"\n};\nfunction Kv(t, e) {\n  let n = {\n    \"aria-autocomplete\": \"list\",\n    \"aria-haspopup\": \"listbox\",\n    \"aria-controls\": t\n  };\n  return e > -1 && (n[\"aria-activedescendant\"] = t + \"-\" + e), n;\n}\nconst TZ = [];\nfunction Ep(t) {\n  return t.isUserEvent(\"input.type\") ? \"input\" : t.isUserEvent(\"delete.backward\") ? \"delete\" : null;\n}\nclass wn {\n  constructor(e, n, r = -1) {\n    this.source = e, this.state = n, this.explicitPos = r;\n  }\n  hasResult() {\n    return !1;\n  }\n  update(e, n) {\n    let r = Ep(e), i = this;\n    r ? i = i.handleUserEvent(e, r, n) : e.docChanged ? i = i.handleChange(e) : e.selection && i.state != 0 && (i = new wn(\n      i.source,\n      0\n      /* State.Inactive */\n    ));\n    for (let s of e.effects)\n      if (s.is(Uu))\n        i = new wn(i.source, 1, s.value ? Ji(e.state) : -1);\n      else if (s.is(Sl))\n        i = new wn(\n          i.source,\n          0\n          /* State.Inactive */\n        );\n      else if (s.is(wx))\n        for (let o of s.value)\n          o.source == i.source && (i = o);\n    return i;\n  }\n  handleUserEvent(e, n, r) {\n    return n == \"delete\" || !r.activateOnTyping ? this.map(e.changes) : new wn(\n      this.source,\n      1\n      /* State.Pending */\n    );\n  }\n  handleChange(e) {\n    return e.changes.touchesRange(Ji(e.startState)) ? new wn(\n      this.source,\n      0\n      /* State.Inactive */\n    ) : this.map(e.changes);\n  }\n  map(e) {\n    return e.empty || this.explicitPos < 0 ? this : new wn(this.source, this.state, e.mapPos(this.explicitPos));\n  }\n}\nclass Qo extends wn {\n  constructor(e, n, r, i, s) {\n    super(e, 2, n), this.result = r, this.from = i, this.to = s;\n  }\n  hasResult() {\n    return !0;\n  }\n  handleUserEvent(e, n, r) {\n    var i;\n    let s = e.changes.mapPos(this.from), o = e.changes.mapPos(this.to, 1), a = Ji(e.state);\n    if ((this.explicitPos < 0 ? a <= s : a < this.from) || a > o || n == \"delete\" && Ji(e.startState) == this.from)\n      return new wn(\n        this.source,\n        n == \"input\" && r.activateOnTyping ? 1 : 0\n        /* State.Inactive */\n      );\n    let l = this.explicitPos < 0 ? -1 : e.changes.mapPos(this.explicitPos), c;\n    return EZ(this.result.validFor, e.state, s, o) ? new Qo(this.source, l, this.result, s, o) : this.result.update && (c = this.result.update(this.result, s, o, new bx(e.state, a, l >= 0))) ? new Qo(this.source, l, c, c.from, (i = c.to) !== null && i !== void 0 ? i : Ji(e.state)) : new wn(this.source, 1, l);\n  }\n  handleChange(e) {\n    return e.changes.touchesRange(this.from, this.to) ? new wn(\n      this.source,\n      0\n      /* State.Inactive */\n    ) : this.map(e.changes);\n  }\n  map(e) {\n    return e.empty ? this : new Qo(this.source, this.explicitPos < 0 ? -1 : e.mapPos(this.explicitPos), this.result, e.mapPos(this.from), e.mapPos(this.to, 1));\n  }\n}\nfunction EZ(t, e, n, r) {\n  if (!t)\n    return !1;\n  let i = e.sliceDoc(n, r);\n  return typeof t == \"function\" ? t(i, n, r, e) : yx(t, !0).test(i);\n}\nconst wx = /* @__PURE__ */ ot.define({\n  map(t, e) {\n    return t.map((n) => n.map(e));\n  }\n}), kx = /* @__PURE__ */ ot.define(), Zn = /* @__PURE__ */ yr.define({\n  create() {\n    return qu.start();\n  },\n  update(t, e) {\n    return t.update(e);\n  },\n  provide: (t) => [\n    Yk.from(t, (e) => e.tooltip),\n    Se.contentAttributes.from(t, (e) => e.attrs)\n  ]\n});\nfunction xx(t, e) {\n  const n = e.completion.apply || e.completion.label;\n  let r = t.state.field(Zn).active.find((i) => i.source == e.source);\n  return r instanceof Qo ? (typeof n == \"string\" ? t.dispatch(Object.assign(Object.assign({}, gZ(t.state, n, r.from, r.to)), { annotations: Sx.of(e.completion) })) : n(t, e.completion, r.from, r.to), !0) : !1;\n}\nconst $Z = /* @__PURE__ */ wZ(Zn, xx);\nfunction Wc(t, e = \"option\") {\n  return (n) => {\n    let r = n.state.field(Zn, !1);\n    if (!r || !r.open || r.open.disabled || Date.now() - r.open.timestamp < n.state.facet(Ft).interactionDelay)\n      return !1;\n    let i = 1, s;\n    e == \"page\" && (s = zk(n, r.open.tooltip)) && (i = Math.max(2, Math.floor(s.dom.offsetHeight / s.dom.querySelector(\"li\").offsetHeight) - 1));\n    let { length: o } = r.open.options, a = r.open.selected > -1 ? r.open.selected + i * (t ? 1 : -1) : t ? 0 : o - 1;\n    return a < 0 ? a = e == \"page\" ? 0 : o - 1 : a >= o && (a = e == \"page\" ? o - 1 : 0), n.dispatch({ effects: kx.of(a) }), !0;\n  };\n}\nconst QZ = (t) => {\n  let e = t.state.field(Zn, !1);\n  return t.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < t.state.facet(Ft).interactionDelay ? !1 : xx(t, e.open.options[e.open.selected]);\n}, CZ = (t) => t.state.field(Zn, !1) ? (t.dispatch({ effects: Uu.of(!0) }), !0) : !1, AZ = (t) => {\n  let e = t.state.field(Zn, !1);\n  return !e || !e.active.some(\n    (n) => n.state != 0\n    /* State.Inactive */\n  ) ? !1 : (t.dispatch({ effects: Sl.of(null) }), !0);\n};\nclass RZ {\n  constructor(e, n) {\n    this.active = e, this.context = n, this.time = Date.now(), this.updates = [], this.done = void 0;\n  }\n}\nconst NZ = 50, DZ = 1e3, ZZ = /* @__PURE__ */ rr.fromClass(class {\n  constructor(t) {\n    this.view = t, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.pendingStart = !1, this.composing = 0;\n    for (let e of t.state.field(Zn).active)\n      e.state == 1 && this.startQuery(e);\n  }\n  update(t) {\n    let e = t.state.field(Zn);\n    if (!t.selectionSet && !t.docChanged && t.startState.field(Zn) == e)\n      return;\n    let n = t.transactions.some((i) => (i.selection || i.docChanged) && !Ep(i));\n    for (let i = 0; i < this.running.length; i++) {\n      let s = this.running[i];\n      if (n || s.updates.length + t.transactions.length > NZ && Date.now() - s.time > DZ) {\n        for (let o of s.context.abortListeners)\n          try {\n            o();\n          } catch (a) {\n            hr(this.view.state, a);\n          }\n        s.context.abortListeners = null, this.running.splice(i--, 1);\n      } else\n        s.updates.push(...t.transactions);\n    }\n    this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), t.transactions.some((i) => i.effects.some((s) => s.is(Uu))) && (this.pendingStart = !0);\n    let r = this.pendingStart ? 50 : t.state.facet(Ft).activateOnTypingDelay;\n    if (this.debounceUpdate = e.active.some((i) => i.state == 1 && !this.running.some((s) => s.active.source == i.source)) ? setTimeout(() => this.startUpdate(), r) : -1, this.composing != 0)\n      for (let i of t.transactions)\n        Ep(i) == \"input\" ? this.composing = 2 : this.composing == 2 && i.selection && (this.composing = 3);\n  }\n  startUpdate() {\n    this.debounceUpdate = -1, this.pendingStart = !1;\n    let { state: t } = this.view, e = t.field(Zn);\n    for (let n of e.active)\n      n.state == 1 && !this.running.some((r) => r.active.source == n.source) && this.startQuery(n);\n  }\n  startQuery(t) {\n    let { state: e } = this.view, n = Ji(e), r = new bx(e, n, t.explicitPos == n), i = new RZ(t, r);\n    this.running.push(i), Promise.resolve(t.source(r)).then((s) => {\n      i.context.aborted || (i.done = s || null, this.scheduleAccept());\n    }, (s) => {\n      this.view.dispatch({ effects: Sl.of(null) }), hr(this.view.state, s);\n    });\n  }\n  scheduleAccept() {\n    this.running.every((t) => t.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), this.view.state.facet(Ft).updateSyncTime));\n  }\n  // For each finished query in this.running, try to create a result\n  // or, if appropriate, restart the query.\n  accept() {\n    var t;\n    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;\n    let e = [], n = this.view.state.facet(Ft);\n    for (let r = 0; r < this.running.length; r++) {\n      let i = this.running[r];\n      if (i.done === void 0)\n        continue;\n      if (this.running.splice(r--, 1), i.done) {\n        let o = new Qo(i.active.source, i.active.explicitPos, i.done, i.done.from, (t = i.done.to) !== null && t !== void 0 ? t : Ji(i.updates.length ? i.updates[0].startState : this.view.state));\n        for (let a of i.updates)\n          o = o.update(a, n);\n        if (o.hasResult()) {\n          e.push(o);\n          continue;\n        }\n      }\n      let s = this.view.state.field(Zn).active.find((o) => o.source == i.active.source);\n      if (s && s.state == 1)\n        if (i.done == null) {\n          let o = new wn(\n            i.active.source,\n            0\n            /* State.Inactive */\n          );\n          for (let a of i.updates)\n            o = o.update(a, n);\n          o.state != 1 && e.push(o);\n        } else\n          this.startQuery(s);\n    }\n    e.length && this.view.dispatch({ effects: wx.of(e) });\n  }\n}, {\n  eventHandlers: {\n    blur(t) {\n      let e = this.view.state.field(Zn, !1);\n      if (e && e.tooltip && this.view.state.facet(Ft).closeOnBlur) {\n        let n = e.open && zk(this.view, e.open.tooltip);\n        (!n || !n.dom.contains(t.relatedTarget)) && setTimeout(() => this.view.dispatch({ effects: Sl.of(null) }), 10);\n      }\n    },\n    compositionstart() {\n      this.composing = 1;\n    },\n    compositionend() {\n      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: Uu.of(!1) }), 20), this.composing = 0;\n    }\n  }\n}), Px = /* @__PURE__ */ Se.baseTheme({\n  \".cm-tooltip.cm-tooltip-autocomplete\": {\n    \"& > ul\": {\n      fontFamily: \"monospace\",\n      whiteSpace: \"nowrap\",\n      overflow: \"hidden auto\",\n      maxWidth_fallback: \"700px\",\n      maxWidth: \"min(700px, 95vw)\",\n      minWidth: \"250px\",\n      maxHeight: \"10em\",\n      height: \"100%\",\n      listStyle: \"none\",\n      margin: 0,\n      padding: 0,\n      \"& > li, & > completion-section\": {\n        padding: \"1px 3px\",\n        lineHeight: 1.2\n      },\n      \"& > li\": {\n        overflowX: \"hidden\",\n        textOverflow: \"ellipsis\",\n        cursor: \"pointer\"\n      },\n      \"& > completion-section\": {\n        display: \"list-item\",\n        borderBottom: \"1px solid silver\",\n        paddingLeft: \"0.5em\",\n        opacity: 0.7\n      }\n    }\n  },\n  \"&light .cm-tooltip-autocomplete ul li[aria-selected]\": {\n    background: \"#17c\",\n    color: \"white\"\n  },\n  \"&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]\": {\n    background: \"#777\"\n  },\n  \"&dark .cm-tooltip-autocomplete ul li[aria-selected]\": {\n    background: \"#347\",\n    color: \"white\"\n  },\n  \"&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]\": {\n    background: \"#444\"\n  },\n  \".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after\": {\n    content: '\"\"',\n    opacity: 0.5,\n    display: \"block\",\n    textAlign: \"center\"\n  },\n  \".cm-tooltip.cm-completionInfo\": {\n    position: \"absolute\",\n    padding: \"3px 9px\",\n    width: \"max-content\",\n    maxWidth: \"400px\",\n    boxSizing: \"border-box\"\n  },\n  \".cm-completionInfo.cm-completionInfo-left\": { right: \"100%\" },\n  \".cm-completionInfo.cm-completionInfo-right\": { left: \"100%\" },\n  \".cm-completionInfo.cm-completionInfo-left-narrow\": { right: \"30px\" },\n  \".cm-completionInfo.cm-completionInfo-right-narrow\": { left: \"30px\" },\n  \"&light .cm-snippetField\": { backgroundColor: \"#00000022\" },\n  \"&dark .cm-snippetField\": { backgroundColor: \"#ffffff22\" },\n  \".cm-snippetFieldPosition\": {\n    verticalAlign: \"text-top\",\n    width: 0,\n    height: \"1.15em\",\n    display: \"inline-block\",\n    margin: \"0 -0.7px -.7em\",\n    borderLeft: \"1.4px dotted #888\"\n  },\n  \".cm-completionMatchedText\": {\n    textDecoration: \"underline\"\n  },\n  \".cm-completionDetail\": {\n    marginLeft: \"0.5em\",\n    fontStyle: \"italic\"\n  },\n  \".cm-completionIcon\": {\n    fontSize: \"90%\",\n    width: \".8em\",\n    display: \"inline-block\",\n    textAlign: \"center\",\n    paddingRight: \".6em\",\n    opacity: \"0.6\",\n    boxSizing: \"content-box\"\n  },\n  \".cm-completionIcon-function, .cm-completionIcon-method\": {\n    \"&:after\": { content: \"''\" }\n  },\n  \".cm-completionIcon-class\": {\n    \"&:after\": { content: \"''\" }\n  },\n  \".cm-completionIcon-interface\": {\n    \"&:after\": { content: \"''\" }\n  },\n  \".cm-completionIcon-variable\": {\n    \"&:after\": { content: \"''\" }\n  },\n  \".cm-completionIcon-constant\": {\n    \"&:after\": { content: \"''\" }\n  },\n  \".cm-completionIcon-type\": {\n    \"&:after\": { content: \"''\" }\n  },\n  \".cm-completionIcon-enum\": {\n    \"&:after\": { content: \"''\" }\n  },\n  \".cm-completionIcon-property\": {\n    \"&:after\": { content: \"''\" }\n  },\n  \".cm-completionIcon-keyword\": {\n    \"&:after\": { content: \"''\" }\n    // Disable emoji rendering\n  },\n  \".cm-completionIcon-namespace\": {\n    \"&:after\": { content: \"''\" }\n  },\n  \".cm-completionIcon-text\": {\n    \"&:after\": { content: \"'abc'\", fontSize: \"50%\", verticalAlign: \"middle\" }\n  }\n});\nclass VZ {\n  constructor(e, n, r, i) {\n    this.field = e, this.line = n, this.from = r, this.to = i;\n  }\n}\nclass bg {\n  constructor(e, n, r) {\n    this.field = e, this.from = n, this.to = r;\n  }\n  map(e) {\n    let n = e.mapPos(this.from, -1, on.TrackDel), r = e.mapPos(this.to, 1, on.TrackDel);\n    return n == null || r == null ? null : new bg(this.field, n, r);\n  }\n}\nclass vg {\n  constructor(e, n) {\n    this.lines = e, this.fieldPositions = n;\n  }\n  instantiate(e, n) {\n    let r = [], i = [n], s = e.doc.lineAt(n), o = /^\\s*/.exec(s.text)[0];\n    for (let l of this.lines) {\n      if (r.length) {\n        let c = o, u = /^\\t*/.exec(l)[0].length;\n        for (let d = 0; d < u; d++)\n          c += e.facet(zd);\n        i.push(n + c.length - u), l = c + l.slice(u);\n      }\n      r.push(l), n += l.length + 1;\n    }\n    let a = this.fieldPositions.map((l) => new bg(l.field, i[l.line] + l.from, i[l.line] + l.to));\n    return { text: r, ranges: a };\n  }\n  static parse(e) {\n    let n = [], r = [], i = [], s;\n    for (let o of e.split(/\\r\\n?|\\n/)) {\n      for (; s = /[#$]\\{(?:(\\d+)(?::([^}]*))?|([^}]*))\\}/.exec(o); ) {\n        let a = s[1] ? +s[1] : null, l = s[2] || s[3] || \"\", c = -1;\n        for (let u = 0; u < n.length; u++)\n          (a != null ? n[u].seq == a : l && n[u].name == l) && (c = u);\n        if (c < 0) {\n          let u = 0;\n          for (; u < n.length && (a == null || n[u].seq != null && n[u].seq < a); )\n            u++;\n          n.splice(u, 0, { seq: a, name: l }), c = u;\n          for (let d of i)\n            d.field >= c && d.field++;\n        }\n        i.push(new VZ(c, r.length, s.index, s.index + l.length)), o = o.slice(0, s.index) + l + o.slice(s.index + s[0].length);\n      }\n      for (let a; a = /\\\\([{}])/.exec(o); ) {\n        o = o.slice(0, a.index) + a[1] + o.slice(a.index + a[0].length);\n        for (let l of i)\n          l.line == r.length && l.from > a.index && (l.from--, l.to--);\n      }\n      r.push(o);\n    }\n    return new vg(r, i);\n  }\n}\nlet IZ = /* @__PURE__ */ Je.widget({ widget: /* @__PURE__ */ new class extends ra {\n  toDOM() {\n    let t = document.createElement(\"span\");\n    return t.className = \"cm-snippetFieldPosition\", t;\n  }\n  ignoreEvent() {\n    return !1;\n  }\n}() }), WZ = /* @__PURE__ */ Je.mark({ class: \"cm-snippetField\" });\nclass oa {\n  constructor(e, n) {\n    this.ranges = e, this.active = n, this.deco = Je.set(e.map((r) => (r.from == r.to ? IZ : WZ).range(r.from, r.to)));\n  }\n  map(e) {\n    let n = [];\n    for (let r of this.ranges) {\n      let i = r.map(e);\n      if (!i)\n        return null;\n      n.push(i);\n    }\n    return new oa(n, this.active);\n  }\n  selectionInsideField(e) {\n    return e.ranges.every((n) => this.ranges.some((r) => r.field == this.active && r.from <= n.from && r.to >= n.to));\n  }\n}\nconst ec = /* @__PURE__ */ ot.define({\n  map(t, e) {\n    return t && t.map(e);\n  }\n}), MZ = /* @__PURE__ */ ot.define(), wl = /* @__PURE__ */ yr.define({\n  create() {\n    return null;\n  },\n  update(t, e) {\n    for (let n of e.effects) {\n      if (n.is(ec))\n        return n.value;\n      if (n.is(MZ) && t)\n        return new oa(t.ranges, n.value);\n    }\n    return t && e.docChanged && (t = t.map(e.changes)), t && e.selection && !t.selectionInsideField(e.selection) && (t = null), t;\n  },\n  provide: (t) => Se.decorations.from(t, (e) => e ? e.deco : Je.none)\n});\nfunction yg(t, e) {\n  return ae.create(t.filter((n) => n.field == e).map((n) => ae.range(n.from, n.to)));\n}\nfunction XZ(t) {\n  let e = vg.parse(t);\n  return (n, r, i, s) => {\n    let { text: o, ranges: a } = e.instantiate(n.state, i), l = {\n      changes: { from: i, to: s, insert: Fe.of(o) },\n      scrollIntoView: !0,\n      annotations: r ? [Sx.of(r), Gt.userEvent.of(\"input.complete\")] : void 0\n    };\n    if (a.length && (l.selection = yg(a, 0)), a.some((c) => c.field > 0)) {\n      let c = new oa(a, 0), u = l.effects = [ec.of(c)];\n      n.state.field(wl, !1) === void 0 && u.push(ot.appendConfig.of([wl, qZ, YZ, Px]));\n    }\n    n.dispatch(n.state.update(l));\n  };\n}\nfunction _x(t) {\n  return ({ state: e, dispatch: n }) => {\n    let r = e.field(wl, !1);\n    if (!r || t < 0 && r.active == 0)\n      return !1;\n    let i = r.active + t, s = t > 0 && !r.ranges.some((o) => o.field == i + t);\n    return n(e.update({\n      selection: yg(r.ranges, i),\n      effects: ec.of(s ? null : new oa(r.ranges, i)),\n      scrollIntoView: !0\n    })), !0;\n  };\n}\nconst jZ = ({ state: t, dispatch: e }) => t.field(wl, !1) ? (e(t.update({ effects: ec.of(null) })), !0) : !1, BZ = /* @__PURE__ */ _x(1), LZ = /* @__PURE__ */ _x(-1), UZ = [\n  { key: \"Tab\", run: BZ, shift: LZ },\n  { key: \"Escape\", run: jZ }\n], Jv = /* @__PURE__ */ ve.define({\n  combine(t) {\n    return t.length ? t[0] : UZ;\n  }\n}), qZ = /* @__PURE__ */ zl.highest(/* @__PURE__ */ bl.compute([Jv], (t) => t.facet(Jv)));\nfunction vn(t, e) {\n  return Object.assign(Object.assign({}, e), { apply: XZ(t) });\n}\nconst YZ = /* @__PURE__ */ Se.domEventHandlers({\n  mousedown(t, e) {\n    let n = e.state.field(wl, !1), r;\n    if (!n || (r = e.posAtCoords({ x: t.clientX, y: t.clientY })) == null)\n      return !1;\n    let i = n.ranges.find((s) => s.from <= r && s.to >= r);\n    return !i || i.field == n.active ? !1 : (e.dispatch({\n      selection: yg(n.ranges, i.field),\n      effects: ec.of(n.ranges.some((s) => s.field > i.field) ? new oa(n.ranges, i.field) : null),\n      scrollIntoView: !0\n    }), !0);\n  }\n}), kl = {\n  brackets: [\"(\", \"[\", \"{\", \"'\", '\"'],\n  before: \")]}:;>\",\n  stringPrefixes: []\n}, _s = /* @__PURE__ */ ot.define({\n  map(t, e) {\n    let n = e.mapPos(t, -1, on.TrackAfter);\n    return n ?? void 0;\n  }\n}), Sg = /* @__PURE__ */ new class extends qs {\n}();\nSg.startSide = 1;\nSg.endSide = -1;\nconst Tx = /* @__PURE__ */ yr.define({\n  create() {\n    return ze.empty;\n  },\n  update(t, e) {\n    if (t = t.map(e.changes), e.selection) {\n      let n = e.state.doc.lineAt(e.selection.main.head);\n      t = t.update({ filter: (r) => r >= n.from && r <= n.to });\n    }\n    for (let n of e.effects)\n      n.is(_s) && (t = t.update({ add: [Sg.range(n.value, n.value + 1)] }));\n    return t;\n  }\n});\nfunction zZ() {\n  return [FZ, Tx];\n}\nconst Xf = \"()[]{}<>\";\nfunction Ex(t) {\n  for (let e = 0; e < Xf.length; e += 2)\n    if (Xf.charCodeAt(e) == t)\n      return Xf.charAt(e + 1);\n  return Iw(t < 128 ? t : t + 1);\n}\nfunction $x(t, e) {\n  return t.languageDataAt(\"closeBrackets\", e)[0] || kl;\n}\nconst HZ = typeof navigator == \"object\" && /* @__PURE__ */ /Android\\b/.test(navigator.userAgent), FZ = /* @__PURE__ */ Se.inputHandler.of((t, e, n, r) => {\n  if ((HZ ? t.composing : t.compositionStarted) || t.state.readOnly)\n    return !1;\n  let i = t.state.selection.main;\n  if (r.length > 2 || r.length == 2 && cr(nn(r, 0)) == 1 || e != i.from || n != i.to)\n    return !1;\n  let s = JZ(t.state, r);\n  return s ? (t.dispatch(s), !0) : !1;\n}), GZ = ({ state: t, dispatch: e }) => {\n  if (t.readOnly)\n    return !1;\n  let r = $x(t, t.selection.main.head).brackets || kl.brackets, i = null, s = t.changeByRange((o) => {\n    if (o.empty) {\n      let a = eV(t.doc, o.head);\n      for (let l of r)\n        if (l == a && Fd(t.doc, o.head) == Ex(nn(l, 0)))\n          return {\n            changes: { from: o.head - l.length, to: o.head + l.length },\n            range: ae.cursor(o.head - l.length)\n          };\n    }\n    return { range: i = o };\n  });\n  return i || e(t.update(s, { scrollIntoView: !0, userEvent: \"delete.backward\" })), !i;\n}, KZ = [\n  { key: \"Backspace\", run: GZ }\n];\nfunction JZ(t, e) {\n  let n = $x(t, t.selection.main.head), r = n.brackets || kl.brackets;\n  for (let i of r) {\n    let s = Ex(nn(i, 0));\n    if (e == i)\n      return s == i ? rV(t, i, r.indexOf(i + i + i) > -1, n) : tV(t, i, s, n.before || kl.before);\n    if (e == s && Qx(t, t.selection.main.from))\n      return nV(t, i, s);\n  }\n  return null;\n}\nfunction Qx(t, e) {\n  let n = !1;\n  return t.field(Tx).between(0, t.doc.length, (r) => {\n    r == e && (n = !0);\n  }), n;\n}\nfunction Fd(t, e) {\n  let n = t.sliceString(e, e + 2);\n  return n.slice(0, cr(nn(n, 0)));\n}\nfunction eV(t, e) {\n  let n = t.sliceString(e - 2, e);\n  return cr(nn(n, 0)) == n.length ? n : n.slice(1);\n}\nfunction tV(t, e, n, r) {\n  let i = null, s = t.changeByRange((o) => {\n    if (!o.empty)\n      return {\n        changes: [{ insert: e, from: o.from }, { insert: n, from: o.to }],\n        effects: _s.of(o.to + e.length),\n        range: ae.range(o.anchor + e.length, o.head + e.length)\n      };\n    let a = Fd(t.doc, o.head);\n    return !a || /\\s/.test(a) || r.indexOf(a) > -1 ? {\n      changes: { insert: e + n, from: o.head },\n      effects: _s.of(o.head + e.length),\n      range: ae.cursor(o.head + e.length)\n    } : { range: i = o };\n  });\n  return i ? null : t.update(s, {\n    scrollIntoView: !0,\n    userEvent: \"input.type\"\n  });\n}\nfunction nV(t, e, n) {\n  let r = null, i = t.changeByRange((s) => s.empty && Fd(t.doc, s.head) == n ? {\n    changes: { from: s.head, to: s.head + n.length, insert: n },\n    range: ae.cursor(s.head + n.length)\n  } : r = { range: s });\n  return r ? null : t.update(i, {\n    scrollIntoView: !0,\n    userEvent: \"input.type\"\n  });\n}\nfunction rV(t, e, n, r) {\n  let i = r.stringPrefixes || kl.stringPrefixes, s = null, o = t.changeByRange((a) => {\n    if (!a.empty)\n      return {\n        changes: [{ insert: e, from: a.from }, { insert: e, from: a.to }],\n        effects: _s.of(a.to + e.length),\n        range: ae.range(a.anchor + e.length, a.head + e.length)\n      };\n    let l = a.head, c = Fd(t.doc, l), u;\n    if (c == e) {\n      if (e0(t, l))\n        return {\n          changes: { insert: e + e, from: l },\n          effects: _s.of(l + e.length),\n          range: ae.cursor(l + e.length)\n        };\n      if (Qx(t, l)) {\n        let f = n && t.sliceDoc(l, l + e.length * 3) == e + e + e ? e + e + e : e;\n        return {\n          changes: { from: l, to: l + f.length, insert: f },\n          range: ae.cursor(l + f.length)\n        };\n      }\n    } else {\n      if (n && t.sliceDoc(l - 2 * e.length, l) == e + e && (u = t0(t, l - 2 * e.length, i)) > -1 && e0(t, u))\n        return {\n          changes: { insert: e + e + e + e, from: l },\n          effects: _s.of(l + e.length),\n          range: ae.cursor(l + e.length)\n        };\n      if (t.charCategorizer(l)(c) != Hn.Word && t0(t, l, i) > -1 && !iV(t, l, e, i))\n        return {\n          changes: { insert: e + e, from: l },\n          effects: _s.of(l + e.length),\n          range: ae.cursor(l + e.length)\n        };\n    }\n    return { range: s = a };\n  });\n  return s ? null : t.update(o, {\n    scrollIntoView: !0,\n    userEvent: \"input.type\"\n  });\n}\nfunction e0(t, e) {\n  let n = un(t).resolveInner(e + 1);\n  return n.parent && n.from == e;\n}\nfunction iV(t, e, n, r) {\n  let i = un(t).resolveInner(e, -1), s = r.reduce((o, a) => Math.max(o, a.length), 0);\n  for (let o = 0; o < 5; o++) {\n    let a = t.sliceDoc(i.from, Math.min(i.to, i.from + n.length + s)), l = a.indexOf(n);\n    if (!l || l > -1 && r.indexOf(a.slice(0, l)) > -1) {\n      let u = i.firstChild;\n      for (; u && u.from == i.from && u.to - u.from > n.length + l; ) {\n        if (t.sliceDoc(u.to - n.length, u.to) == n)\n          return !1;\n        u = u.firstChild;\n      }\n      return !0;\n    }\n    let c = i.to == e && i.parent;\n    if (!c)\n      break;\n    i = c;\n  }\n  return !1;\n}\nfunction t0(t, e, n) {\n  let r = t.charCategorizer(e);\n  if (r(t.sliceDoc(e - 1, e)) != Hn.Word)\n    return e;\n  for (let i of n) {\n    let s = e - i.length;\n    if (t.sliceDoc(s, e) == i && r(t.sliceDoc(s - 1, s)) != Hn.Word)\n      return s;\n  }\n  return -1;\n}\nfunction sV(t = {}) {\n  return [\n    Zn,\n    Ft.of(t),\n    ZZ,\n    oV,\n    Px\n  ];\n}\nconst Cx = [\n  { key: \"Ctrl-Space\", run: CZ },\n  { key: \"Escape\", run: AZ },\n  { key: \"ArrowDown\", run: /* @__PURE__ */ Wc(!0) },\n  { key: \"ArrowUp\", run: /* @__PURE__ */ Wc(!1) },\n  { key: \"PageDown\", run: /* @__PURE__ */ Wc(!0, \"page\") },\n  { key: \"PageUp\", run: /* @__PURE__ */ Wc(!1, \"page\") },\n  { key: \"Enter\", run: QZ }\n], oV = /* @__PURE__ */ zl.highest(/* @__PURE__ */ bl.computeN([Ft], (t) => t.facet(Ft).defaultKeymap ? [Cx] : []));\nfunction Ax(t, e) {\n  let n = -1;\n  return t.changeByRange((r) => {\n    let i = [];\n    for (let o = r.from; o <= r.to; ) {\n      let a = t.doc.lineAt(o);\n      a.number > n && (r.empty || r.to > a.from) && (e(a, i, r), n = a.number), o = a.to + 1;\n    }\n    let s = t.changes(i);\n    return {\n      changes: i,\n      range: ae.range(s.mapPos(r.anchor, 1), s.mapPos(r.head, 1))\n    };\n  });\n}\nconst aV = ({ state: t, dispatch: e }) => t.readOnly ? !1 : (e(t.update(Ax(t, (n, r) => {\n  r.push({ from: n.from, insert: t.facet(zd) });\n}), { userEvent: \"input.indent\" })), !0), lV = ({ state: t, dispatch: e }) => t.readOnly ? !1 : (e(t.update(Ax(t, (n, r) => {\n  let i = /^\\s*/.exec(n.text)[0];\n  if (!i)\n    return;\n  let s = ig(i, t.tabSize), o = 0, a = lx(t, Math.max(0, s - ax(t)));\n  for (; o < i.length && o < a.length && i.charCodeAt(o) == a.charCodeAt(o); )\n    o++;\n  r.push({ from: n.from + o, to: n.from + i.length, insert: a.slice(o) });\n}), { userEvent: \"delete.dedent\" })), !0), cV = { key: \"Tab\", run: aV, shift: lV };\nclass Yu {\n  /**\n  @internal\n  */\n  constructor(e, n, r, i, s, o, a, l, c, u = 0, d) {\n    this.p = e, this.stack = n, this.state = r, this.reducePos = i, this.pos = s, this.score = o, this.buffer = a, this.bufferBase = l, this.curContext = c, this.lookAhead = u, this.parent = d;\n  }\n  /**\n  @internal\n  */\n  toString() {\n    return `[${this.stack.filter((e, n) => n % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? \"!\" + this.score : \"\"}`;\n  }\n  // Start an empty stack\n  /**\n  @internal\n  */\n  static start(e, n, r = 0) {\n    let i = e.parser.context;\n    return new Yu(e, [], n, r, r, 0, [], 0, i ? new n0(i, i.start) : null, 0, null);\n  }\n  /**\n  The stack's current [context](#lr.ContextTracker) value, if\n  any. Its type will depend on the context tracker's type\n  parameter, or it will be `null` if there is no context\n  tracker.\n  */\n  get context() {\n    return this.curContext ? this.curContext.context : null;\n  }\n  // Push a state onto the stack, tracking its start position as well\n  // as the buffer base at that point.\n  /**\n  @internal\n  */\n  pushState(e, n) {\n    this.stack.push(this.state, n, this.bufferBase + this.buffer.length), this.state = e;\n  }\n  // Apply a reduce action\n  /**\n  @internal\n  */\n  reduce(e) {\n    var n;\n    let r = e >> 19, i = e & 65535, { parser: s } = this.p, o = s.dynamicPrecedence(i);\n    if (o && (this.score += o), r == 0) {\n      this.pushState(s.getGoto(this.state, i, !0), this.reducePos), i < s.minRepeatTerm && this.storeNode(i, this.reducePos, this.reducePos, 4, !0), this.reduceContext(i, this.reducePos);\n      return;\n    }\n    let a = this.stack.length - (r - 1) * 3 - (e & 262144 ? 6 : 0), l = a ? this.stack[a - 2] : this.p.ranges[0].from, c = this.reducePos - l;\n    c >= 2e3 && !(!((n = this.p.parser.nodeSet.types[i]) === null || n === void 0) && n.isAnonymous) && (l == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = c) : this.p.lastBigReductionSize < c && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = l, this.p.lastBigReductionSize = c));\n    let u = a ? this.stack[a - 1] : 0, d = this.bufferBase + this.buffer.length - u;\n    if (i < s.minRepeatTerm || e & 131072) {\n      let f = s.stateFlag(\n        this.state,\n        1\n        /* StateFlag.Skipped */\n      ) ? this.pos : this.reducePos;\n      this.storeNode(i, l, f, d + 4, !0);\n    }\n    if (e & 262144)\n      this.state = this.stack[a];\n    else {\n      let f = this.stack[a - 3];\n      this.state = s.getGoto(f, i, !0);\n    }\n    for (; this.stack.length > a; )\n      this.stack.pop();\n    this.reduceContext(i, l);\n  }\n  // Shift a value into the buffer\n  /**\n  @internal\n  */\n  storeNode(e, n, r, i = 4, s = !1) {\n    if (e == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {\n      let o = this, a = this.buffer.length;\n      if (a == 0 && o.parent && (a = o.bufferBase - o.parent.bufferBase, o = o.parent), a > 0 && o.buffer[a - 4] == 0 && o.buffer[a - 1] > -1) {\n        if (n == r)\n          return;\n        if (o.buffer[a - 2] >= n) {\n          o.buffer[a - 2] = r;\n          return;\n        }\n      }\n    }\n    if (!s || this.pos == r)\n      this.buffer.push(e, n, r, i);\n    else {\n      let o = this.buffer.length;\n      if (o > 0 && this.buffer[o - 4] != 0)\n        for (; o > 0 && this.buffer[o - 2] > r; )\n          this.buffer[o] = this.buffer[o - 4], this.buffer[o + 1] = this.buffer[o - 3], this.buffer[o + 2] = this.buffer[o - 2], this.buffer[o + 3] = this.buffer[o - 1], o -= 4, i > 4 && (i -= 4);\n      this.buffer[o] = e, this.buffer[o + 1] = n, this.buffer[o + 2] = r, this.buffer[o + 3] = i;\n    }\n  }\n  // Apply a shift action\n  /**\n  @internal\n  */\n  shift(e, n, r, i) {\n    if (e & 131072)\n      this.pushState(e & 65535, this.pos);\n    else if (e & 262144)\n      this.pos = i, this.shiftContext(n, r), n <= this.p.parser.maxNode && this.buffer.push(n, r, i, 4);\n    else {\n      let s = e, { parser: o } = this.p;\n      (i > this.pos || n <= o.maxNode) && (this.pos = i, o.stateFlag(\n        s,\n        1\n        /* StateFlag.Skipped */\n      ) || (this.reducePos = i)), this.pushState(s, r), this.shiftContext(n, r), n <= o.maxNode && this.buffer.push(n, r, i, 4);\n    }\n  }\n  // Apply an action\n  /**\n  @internal\n  */\n  apply(e, n, r, i) {\n    e & 65536 ? this.reduce(e) : this.shift(e, n, r, i);\n  }\n  // Add a prebuilt (reused) node into the buffer.\n  /**\n  @internal\n  */\n  useNode(e, n) {\n    let r = this.p.reused.length - 1;\n    (r < 0 || this.p.reused[r] != e) && (this.p.reused.push(e), r++);\n    let i = this.pos;\n    this.reducePos = this.pos = i + e.length, this.pushState(n, i), this.buffer.push(\n      r,\n      i,\n      this.reducePos,\n      -1\n      /* size == -1 means this is a reused value */\n    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, e, this, this.p.stream.reset(this.pos - e.length)));\n  }\n  // Split the stack. Due to the buffer sharing and the fact\n  // that `this.stack` tends to stay quite shallow, this isn't very\n  // expensive.\n  /**\n  @internal\n  */\n  split() {\n    let e = this, n = e.buffer.length;\n    for (; n > 0 && e.buffer[n - 2] > e.reducePos; )\n      n -= 4;\n    let r = e.buffer.slice(n), i = e.bufferBase + n;\n    for (; e && i == e.bufferBase; )\n      e = e.parent;\n    return new Yu(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, r, i, this.curContext, this.lookAhead, e);\n  }\n  // Try to recover from an error by 'deleting' (ignoring) one token.\n  /**\n  @internal\n  */\n  recoverByDelete(e, n) {\n    let r = e <= this.p.parser.maxNode;\n    r && this.storeNode(e, this.pos, n, 4), this.storeNode(0, this.pos, n, r ? 8 : 4), this.pos = this.reducePos = n, this.score -= 190;\n  }\n  /**\n  Check if the given term would be able to be shifted (optionally\n  after some reductions) on this stack. This can be useful for\n  external tokenizers that want to make sure they only provide a\n  given token when it applies.\n  */\n  canShift(e) {\n    for (let n = new uV(this); ; ) {\n      let r = this.p.parser.stateSlot(\n        n.state,\n        4\n        /* ParseState.DefaultReduce */\n      ) || this.p.parser.hasAction(n.state, e);\n      if (r == 0)\n        return !1;\n      if (!(r & 65536))\n        return !0;\n      n.reduce(r);\n    }\n  }\n  // Apply up to Recover.MaxNext recovery actions that conceptually\n  // inserts some missing token or rule.\n  /**\n  @internal\n  */\n  recoverByInsert(e) {\n    if (this.stack.length >= 300)\n      return [];\n    let n = this.p.parser.nextStates(this.state);\n    if (n.length > 8 || this.stack.length >= 120) {\n      let i = [];\n      for (let s = 0, o; s < n.length; s += 2)\n        (o = n[s + 1]) != this.state && this.p.parser.hasAction(o, e) && i.push(n[s], o);\n      if (this.stack.length < 120)\n        for (let s = 0; i.length < 8 && s < n.length; s += 2) {\n          let o = n[s + 1];\n          i.some((a, l) => l & 1 && a == o) || i.push(n[s], o);\n        }\n      n = i;\n    }\n    let r = [];\n    for (let i = 0; i < n.length && r.length < 4; i += 2) {\n      let s = n[i + 1];\n      if (s == this.state)\n        continue;\n      let o = this.split();\n      o.pushState(s, this.pos), o.storeNode(0, o.pos, o.pos, 4, !0), o.shiftContext(n[i], this.pos), o.reducePos = this.pos, o.score -= 200, r.push(o);\n    }\n    return r;\n  }\n  // Force a reduce, if possible. Return false if that can't\n  // be done.\n  /**\n  @internal\n  */\n  forceReduce() {\n    let { parser: e } = this.p, n = e.stateSlot(\n      this.state,\n      5\n      /* ParseState.ForcedReduce */\n    );\n    if (!(n & 65536))\n      return !1;\n    if (!e.validAction(this.state, n)) {\n      let r = n >> 19, i = n & 65535, s = this.stack.length - r * 3;\n      if (s < 0 || e.getGoto(this.stack[s], i, !1) < 0) {\n        let o = this.findForcedReduction();\n        if (o == null)\n          return !1;\n        n = o;\n      }\n      this.storeNode(0, this.pos, this.pos, 4, !0), this.score -= 100;\n    }\n    return this.reducePos = this.pos, this.reduce(n), !0;\n  }\n  /**\n  Try to scan through the automaton to find some kind of reduction\n  that can be applied. Used when the regular ForcedReduce field\n  isn't a valid action. @internal\n  */\n  findForcedReduction() {\n    let { parser: e } = this.p, n = [], r = (i, s) => {\n      if (!n.includes(i))\n        return n.push(i), e.allActions(i, (o) => {\n          if (!(o & 393216))\n            if (o & 65536) {\n              let a = (o >> 19) - s;\n              if (a > 1) {\n                let l = o & 65535, c = this.stack.length - a * 3;\n                if (c >= 0 && e.getGoto(this.stack[c], l, !1) >= 0)\n                  return a << 19 | 65536 | l;\n              }\n            } else {\n              let a = r(o, s + 1);\n              if (a != null)\n                return a;\n            }\n        });\n    };\n    return r(this.state, 0);\n  }\n  /**\n  @internal\n  */\n  forceAll() {\n    for (; !this.p.parser.stateFlag(\n      this.state,\n      2\n      /* StateFlag.Accepting */\n    ); )\n      if (!this.forceReduce()) {\n        this.storeNode(0, this.pos, this.pos, 4, !0);\n        break;\n      }\n    return this;\n  }\n  /**\n  Check whether this state has no further actions (assumed to be a direct descendant of the\n  top state, since any other states must be able to continue\n  somehow). @internal\n  */\n  get deadEnd() {\n    if (this.stack.length != 3)\n      return !1;\n    let { parser: e } = this.p;\n    return e.data[e.stateSlot(\n      this.state,\n      1\n      /* ParseState.Actions */\n    )] == 65535 && !e.stateSlot(\n      this.state,\n      4\n      /* ParseState.DefaultReduce */\n    );\n  }\n  /**\n  Restart the stack (put it back in its start state). Only safe\n  when this.stack.length == 3 (state is directly below the top\n  state). @internal\n  */\n  restart() {\n    this.storeNode(0, this.pos, this.pos, 4, !0), this.state = this.stack[0], this.stack.length = 0;\n  }\n  /**\n  @internal\n  */\n  sameState(e) {\n    if (this.state != e.state || this.stack.length != e.stack.length)\n      return !1;\n    for (let n = 0; n < this.stack.length; n += 3)\n      if (this.stack[n] != e.stack[n])\n        return !1;\n    return !0;\n  }\n  /**\n  Get the parser used by this stack.\n  */\n  get parser() {\n    return this.p.parser;\n  }\n  /**\n  Test whether a given dialect (by numeric ID, as exported from\n  the terms file) is enabled.\n  */\n  dialectEnabled(e) {\n    return this.p.parser.dialect.flags[e];\n  }\n  shiftContext(e, n) {\n    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, e, this, this.p.stream.reset(n)));\n  }\n  reduceContext(e, n) {\n    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, e, this, this.p.stream.reset(n)));\n  }\n  /**\n  @internal\n  */\n  emitContext() {\n    let e = this.buffer.length - 1;\n    (e < 0 || this.buffer[e] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);\n  }\n  /**\n  @internal\n  */\n  emitLookAhead() {\n    let e = this.buffer.length - 1;\n    (e < 0 || this.buffer[e] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);\n  }\n  updateContext(e) {\n    if (e != this.curContext.context) {\n      let n = new n0(this.curContext.tracker, e);\n      n.hash != this.curContext.hash && this.emitContext(), this.curContext = n;\n    }\n  }\n  /**\n  @internal\n  */\n  setLookAhead(e) {\n    e > this.lookAhead && (this.emitLookAhead(), this.lookAhead = e);\n  }\n  /**\n  @internal\n  */\n  close() {\n    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();\n  }\n}\nclass n0 {\n  constructor(e, n) {\n    this.tracker = e, this.context = n, this.hash = e.strict ? e.hash(n) : 0;\n  }\n}\nclass uV {\n  constructor(e) {\n    this.start = e, this.state = e.state, this.stack = e.stack, this.base = this.stack.length;\n  }\n  reduce(e) {\n    let n = e & 65535, r = e >> 19;\n    r == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (r - 1) * 3;\n    let i = this.start.p.parser.getGoto(this.stack[this.base - 3], n, !0);\n    this.state = i;\n  }\n}\nclass zu {\n  constructor(e, n, r) {\n    this.stack = e, this.pos = n, this.index = r, this.buffer = e.buffer, this.index == 0 && this.maybeNext();\n  }\n  static create(e, n = e.bufferBase + e.buffer.length) {\n    return new zu(e, n, n - e.bufferBase);\n  }\n  maybeNext() {\n    let e = this.stack.parent;\n    e != null && (this.index = this.stack.bufferBase - e.bufferBase, this.stack = e, this.buffer = e.buffer);\n  }\n  get id() {\n    return this.buffer[this.index - 4];\n  }\n  get start() {\n    return this.buffer[this.index - 3];\n  }\n  get end() {\n    return this.buffer[this.index - 2];\n  }\n  get size() {\n    return this.buffer[this.index - 1];\n  }\n  next() {\n    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();\n  }\n  fork() {\n    return new zu(this.stack, this.pos, this.index);\n  }\n}\nfunction Va(t, e = Uint16Array) {\n  if (typeof t != \"string\")\n    return t;\n  let n = null;\n  for (let r = 0, i = 0; r < t.length; ) {\n    let s = 0;\n    for (; ; ) {\n      let o = t.charCodeAt(r++), a = !1;\n      if (o == 126) {\n        s = 65535;\n        break;\n      }\n      o >= 92 && o--, o >= 34 && o--;\n      let l = o - 32;\n      if (l >= 46 && (l -= 46, a = !0), s += l, a)\n        break;\n      s *= 46;\n    }\n    n ? n[i++] = s : n = new e(s);\n  }\n  return n;\n}\nclass cu {\n  constructor() {\n    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;\n  }\n}\nconst r0 = new cu();\nclass dV {\n  /**\n  @internal\n  */\n  constructor(e, n) {\n    this.input = e, this.ranges = n, this.chunk = \"\", this.chunkOff = 0, this.chunk2 = \"\", this.chunk2Pos = 0, this.next = -1, this.token = r0, this.rangeIndex = 0, this.pos = this.chunkPos = n[0].from, this.range = n[0], this.end = n[n.length - 1].to, this.readNext();\n  }\n  /**\n  @internal\n  */\n  resolveOffset(e, n) {\n    let r = this.range, i = this.rangeIndex, s = this.pos + e;\n    for (; s < r.from; ) {\n      if (!i)\n        return null;\n      let o = this.ranges[--i];\n      s -= r.from - o.to, r = o;\n    }\n    for (; n < 0 ? s > r.to : s >= r.to; ) {\n      if (i == this.ranges.length - 1)\n        return null;\n      let o = this.ranges[++i];\n      s += o.from - r.to, r = o;\n    }\n    return s;\n  }\n  /**\n  @internal\n  */\n  clipPos(e) {\n    if (e >= this.range.from && e < this.range.to)\n      return e;\n    for (let n of this.ranges)\n      if (n.to > e)\n        return Math.max(e, n.from);\n    return this.end;\n  }\n  /**\n  Look at a code unit near the stream position. `.peek(0)` equals\n  `.next`, `.peek(-1)` gives you the previous character, and so\n  on.\n  \n  Note that looking around during tokenizing creates dependencies\n  on potentially far-away content, which may reduce the\n  effectiveness incremental parsingwhen looking forwardor even\n  cause invalid reparses when looking backward more than 25 code\n  units, since the library does not track lookbehind.\n  */\n  peek(e) {\n    let n = this.chunkOff + e, r, i;\n    if (n >= 0 && n < this.chunk.length)\n      r = this.pos + e, i = this.chunk.charCodeAt(n);\n    else {\n      let s = this.resolveOffset(e, 1);\n      if (s == null)\n        return -1;\n      if (r = s, r >= this.chunk2Pos && r < this.chunk2Pos + this.chunk2.length)\n        i = this.chunk2.charCodeAt(r - this.chunk2Pos);\n      else {\n        let o = this.rangeIndex, a = this.range;\n        for (; a.to <= r; )\n          a = this.ranges[++o];\n        this.chunk2 = this.input.chunk(this.chunk2Pos = r), r + this.chunk2.length > a.to && (this.chunk2 = this.chunk2.slice(0, a.to - r)), i = this.chunk2.charCodeAt(0);\n      }\n    }\n    return r >= this.token.lookAhead && (this.token.lookAhead = r + 1), i;\n  }\n  /**\n  Accept a token. By default, the end of the token is set to the\n  current stream position, but you can pass an offset (relative to\n  the stream position) to change that.\n  */\n  acceptToken(e, n = 0) {\n    let r = n ? this.resolveOffset(n, -1) : this.pos;\n    if (r == null || r < this.token.start)\n      throw new RangeError(\"Token end out of bounds\");\n    this.token.value = e, this.token.end = r;\n  }\n  /**\n  Accept a token ending at a specific given position.\n  */\n  acceptTokenTo(e, n) {\n    this.token.value = e, this.token.end = n;\n  }\n  getChunk() {\n    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {\n      let { chunk: e, chunkPos: n } = this;\n      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = e, this.chunk2Pos = n, this.chunkOff = this.pos - this.chunkPos;\n    } else {\n      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;\n      let e = this.input.chunk(this.pos), n = this.pos + e.length;\n      this.chunk = n > this.range.to ? e.slice(0, this.range.to - this.pos) : e, this.chunkPos = this.pos, this.chunkOff = 0;\n    }\n  }\n  readNext() {\n    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);\n  }\n  /**\n  Move the stream forward N (defaults to 1) code units. Returns\n  the new value of [`next`](#lr.InputStream.next).\n  */\n  advance(e = 1) {\n    for (this.chunkOff += e; this.pos + e >= this.range.to; ) {\n      if (this.rangeIndex == this.ranges.length - 1)\n        return this.setDone();\n      e -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;\n    }\n    return this.pos += e, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();\n  }\n  setDone() {\n    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = \"\", this.next = -1;\n  }\n  /**\n  @internal\n  */\n  reset(e, n) {\n    if (n ? (this.token = n, n.start = e, n.lookAhead = e + 1, n.value = n.extended = -1) : this.token = r0, this.pos != e) {\n      if (this.pos = e, e == this.end)\n        return this.setDone(), this;\n      for (; e < this.range.from; )\n        this.range = this.ranges[--this.rangeIndex];\n      for (; e >= this.range.to; )\n        this.range = this.ranges[++this.rangeIndex];\n      e >= this.chunkPos && e < this.chunkPos + this.chunk.length ? this.chunkOff = e - this.chunkPos : (this.chunk = \"\", this.chunkOff = 0), this.readNext();\n    }\n    return this;\n  }\n  /**\n  @internal\n  */\n  read(e, n) {\n    if (e >= this.chunkPos && n <= this.chunkPos + this.chunk.length)\n      return this.chunk.slice(e - this.chunkPos, n - this.chunkPos);\n    if (e >= this.chunk2Pos && n <= this.chunk2Pos + this.chunk2.length)\n      return this.chunk2.slice(e - this.chunk2Pos, n - this.chunk2Pos);\n    if (e >= this.range.from && n <= this.range.to)\n      return this.input.read(e, n);\n    let r = \"\";\n    for (let i of this.ranges) {\n      if (i.from >= n)\n        break;\n      i.to > e && (r += this.input.read(Math.max(i.from, e), Math.min(i.to, n)));\n    }\n    return r;\n  }\n}\nclass Co {\n  constructor(e, n) {\n    this.data = e, this.id = n;\n  }\n  token(e, n) {\n    let { parser: r } = n.p;\n    Rx(this.data, e, n, this.id, r.data, r.tokenPrecTable);\n  }\n}\nCo.prototype.contextual = Co.prototype.fallback = Co.prototype.extend = !1;\nclass Hu {\n  constructor(e, n, r) {\n    this.precTable = n, this.elseToken = r, this.data = typeof e == \"string\" ? Va(e) : e;\n  }\n  token(e, n) {\n    let r = e.pos, i = 0;\n    for (; ; ) {\n      let s = e.next < 0, o = e.resolveOffset(1, 1);\n      if (Rx(this.data, e, n, 0, this.data, this.precTable), e.token.value > -1)\n        break;\n      if (this.elseToken == null)\n        return;\n      if (s || i++, o == null)\n        break;\n      e.reset(o, e.token);\n    }\n    i && (e.reset(r, e.token), e.acceptToken(this.elseToken, i));\n  }\n}\nHu.prototype.contextual = Co.prototype.fallback = Co.prototype.extend = !1;\nclass gn {\n  /**\n  Create a tokenizer. The first argument is the function that,\n  given an input stream, scans for the types of tokens it\n  recognizes at the stream's position, and calls\n  [`acceptToken`](#lr.InputStream.acceptToken) when it finds\n  one.\n  */\n  constructor(e, n = {}) {\n    this.token = e, this.contextual = !!n.contextual, this.fallback = !!n.fallback, this.extend = !!n.extend;\n  }\n}\nfunction Rx(t, e, n, r, i, s) {\n  let o = 0, a = 1 << r, { dialect: l } = n.p.parser;\n  e:\n    for (; a & t[o]; ) {\n      let c = t[o + 1];\n      for (let h = o + 3; h < c; h += 2)\n        if ((t[h + 1] & a) > 0) {\n          let p = t[h];\n          if (l.allows(p) && (e.token.value == -1 || e.token.value == p || fV(p, e.token.value, i, s))) {\n            e.acceptToken(p);\n            break;\n          }\n        }\n      let u = e.next, d = 0, f = t[o + 2];\n      if (e.next < 0 && f > d && t[c + f * 3 - 3] == 65535) {\n        o = t[c + f * 3 - 1];\n        continue e;\n      }\n      for (; d < f; ) {\n        let h = d + f >> 1, p = c + h + (h << 1), O = t[p], m = t[p + 1] || 65536;\n        if (u < O)\n          f = h;\n        else if (u >= m)\n          d = h + 1;\n        else {\n          o = t[p + 2], e.advance();\n          continue e;\n        }\n      }\n      break;\n    }\n}\nfunction i0(t, e, n) {\n  for (let r = e, i; (i = t[r]) != 65535; r++)\n    if (i == n)\n      return r - e;\n  return -1;\n}\nfunction fV(t, e, n, r) {\n  let i = i0(n, r, e);\n  return i < 0 || i0(n, r, t) < i;\n}\nconst Qn = typeof process < \"u\" && process.env && /\\bparse\\b/.test(process.env.LOG);\nlet jf = null;\nfunction s0(t, e, n) {\n  let r = t.cursor(lt.IncludeAnonymous);\n  for (r.moveTo(e); ; )\n    if (!(n < 0 ? r.childBefore(e) : r.childAfter(e)))\n      for (; ; ) {\n        if ((n < 0 ? r.to < e : r.from > e) && !r.type.isError)\n          return n < 0 ? Math.max(0, Math.min(\n            r.to - 1,\n            e - 25\n            /* Safety.Margin */\n          )) : Math.min(t.length, Math.max(\n            r.from + 1,\n            e + 25\n            /* Safety.Margin */\n          ));\n        if (n < 0 ? r.prevSibling() : r.nextSibling())\n          break;\n        if (!r.parent())\n          return n < 0 ? 0 : t.length;\n      }\n}\nclass hV {\n  constructor(e, n) {\n    this.fragments = e, this.nodeSet = n, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();\n  }\n  nextFragment() {\n    let e = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];\n    if (e) {\n      for (this.safeFrom = e.openStart ? s0(e.tree, e.from + e.offset, 1) - e.offset : e.from, this.safeTo = e.openEnd ? s0(e.tree, e.to + e.offset, -1) - e.offset : e.to; this.trees.length; )\n        this.trees.pop(), this.start.pop(), this.index.pop();\n      this.trees.push(e.tree), this.start.push(-e.offset), this.index.push(0), this.nextStart = this.safeFrom;\n    } else\n      this.nextStart = 1e9;\n  }\n  // `pos` must be >= any previously given `pos` for this cursor\n  nodeAt(e) {\n    if (e < this.nextStart)\n      return null;\n    for (; this.fragment && this.safeTo <= e; )\n      this.nextFragment();\n    if (!this.fragment)\n      return null;\n    for (; ; ) {\n      let n = this.trees.length - 1;\n      if (n < 0)\n        return this.nextFragment(), null;\n      let r = this.trees[n], i = this.index[n];\n      if (i == r.children.length) {\n        this.trees.pop(), this.start.pop(), this.index.pop();\n        continue;\n      }\n      let s = r.children[i], o = this.start[n] + r.positions[i];\n      if (o > e)\n        return this.nextStart = o, null;\n      if (s instanceof gt) {\n        if (o == e) {\n          if (o < this.safeFrom)\n            return null;\n          let a = o + s.length;\n          if (a <= this.safeTo) {\n            let l = s.prop(Re.lookAhead);\n            if (!l || a + l < this.fragment.to)\n              return s;\n          }\n        }\n        this.index[n]++, o + s.length >= Math.max(this.safeFrom, e) && (this.trees.push(s), this.start.push(o), this.index.push(0));\n      } else\n        this.index[n]++, this.nextStart = o + s.length;\n    }\n  }\n}\nclass pV {\n  constructor(e, n) {\n    this.stream = n, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = e.tokenizers.map((r) => new cu());\n  }\n  getActions(e) {\n    let n = 0, r = null, { parser: i } = e.p, { tokenizers: s } = i, o = i.stateSlot(\n      e.state,\n      3\n      /* ParseState.TokenizerMask */\n    ), a = e.curContext ? e.curContext.hash : 0, l = 0;\n    for (let c = 0; c < s.length; c++) {\n      if (!(1 << c & o))\n        continue;\n      let u = s[c], d = this.tokens[c];\n      if (!(r && !u.fallback) && ((u.contextual || d.start != e.pos || d.mask != o || d.context != a) && (this.updateCachedToken(d, u, e), d.mask = o, d.context = a), d.lookAhead > d.end + 25 && (l = Math.max(d.lookAhead, l)), d.value != 0)) {\n        let f = n;\n        if (d.extended > -1 && (n = this.addActions(e, d.extended, d.end, n)), n = this.addActions(e, d.value, d.end, n), !u.extend && (r = d, n > f))\n          break;\n      }\n    }\n    for (; this.actions.length > n; )\n      this.actions.pop();\n    return l && e.setLookAhead(l), !r && e.pos == this.stream.end && (r = new cu(), r.value = e.p.parser.eofTerm, r.start = r.end = e.pos, n = this.addActions(e, r.value, r.end, n)), this.mainToken = r, this.actions;\n  }\n  getMainToken(e) {\n    if (this.mainToken)\n      return this.mainToken;\n    let n = new cu(), { pos: r, p: i } = e;\n    return n.start = r, n.end = Math.min(r + 1, i.stream.end), n.value = r == i.stream.end ? i.parser.eofTerm : 0, n;\n  }\n  updateCachedToken(e, n, r) {\n    let i = this.stream.clipPos(r.pos);\n    if (n.token(this.stream.reset(i, e), r), e.value > -1) {\n      let { parser: s } = r.p;\n      for (let o = 0; o < s.specialized.length; o++)\n        if (s.specialized[o] == e.value) {\n          let a = s.specializers[o](this.stream.read(e.start, e.end), r);\n          if (a >= 0 && r.p.parser.dialect.allows(a >> 1)) {\n            a & 1 ? e.extended = a >> 1 : e.value = a >> 1;\n            break;\n          }\n        }\n    } else\n      e.value = 0, e.end = this.stream.clipPos(i + 1);\n  }\n  putAction(e, n, r, i) {\n    for (let s = 0; s < i; s += 3)\n      if (this.actions[s] == e)\n        return i;\n    return this.actions[i++] = e, this.actions[i++] = n, this.actions[i++] = r, i;\n  }\n  addActions(e, n, r, i) {\n    let { state: s } = e, { parser: o } = e.p, { data: a } = o;\n    for (let l = 0; l < 2; l++)\n      for (let c = o.stateSlot(\n        s,\n        l ? 2 : 1\n        /* ParseState.Actions */\n      ); ; c += 3) {\n        if (a[c] == 65535)\n          if (a[c + 1] == 1)\n            c = ti(a, c + 2);\n          else {\n            i == 0 && a[c + 1] == 2 && (i = this.putAction(ti(a, c + 2), n, r, i));\n            break;\n          }\n        a[c] == n && (i = this.putAction(ti(a, c + 1), n, r, i));\n      }\n    return i;\n  }\n}\nclass OV {\n  constructor(e, n, r, i) {\n    this.parser = e, this.input = n, this.ranges = i, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new dV(n, i), this.tokens = new pV(e, this.stream), this.topTerm = e.top[1];\n    let { from: s } = i[0];\n    this.stacks = [Yu.start(this, e.top[0], s)], this.fragments = r.length && this.stream.end - s > e.bufferLength * 4 ? new hV(r, e.nodeSet) : null;\n  }\n  get parsedPos() {\n    return this.minStackPos;\n  }\n  // Move the parser forward. This will process all parse stacks at\n  // `this.pos` and try to advance them to a further position. If no\n  // stack for such a position is found, it'll start error-recovery.\n  //\n  // When the parse is finished, this will return a syntax tree. When\n  // not, it returns `null`.\n  advance() {\n    let e = this.stacks, n = this.minStackPos, r = this.stacks = [], i, s;\n    if (this.bigReductionCount > 300 && e.length == 1) {\n      let [o] = e;\n      for (; o.forceReduce() && o.stack.length && o.stack[o.stack.length - 2] >= this.lastBigReductionStart; )\n        ;\n      this.bigReductionCount = this.lastBigReductionSize = 0;\n    }\n    for (let o = 0; o < e.length; o++) {\n      let a = e[o];\n      for (; ; ) {\n        if (this.tokens.mainToken = null, a.pos > n)\n          r.push(a);\n        else {\n          if (this.advanceStack(a, r, e))\n            continue;\n          {\n            i || (i = [], s = []), i.push(a);\n            let l = this.tokens.getMainToken(a);\n            s.push(l.value, l.end);\n          }\n        }\n        break;\n      }\n    }\n    if (!r.length) {\n      let o = i && mV(i);\n      if (o)\n        return Qn && console.log(\"Finish with \" + this.stackID(o)), this.stackToTree(o);\n      if (this.parser.strict)\n        throw Qn && i && console.log(\"Stuck with token \" + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : \"none\")), new SyntaxError(\"No parse at \" + n);\n      this.recovering || (this.recovering = 5);\n    }\n    if (this.recovering && i) {\n      let o = this.stoppedAt != null && i[0].pos > this.stoppedAt ? i[0] : this.runRecovery(i, s, r);\n      if (o)\n        return Qn && console.log(\"Force-finish \" + this.stackID(o)), this.stackToTree(o.forceAll());\n    }\n    if (this.recovering) {\n      let o = this.recovering == 1 ? 1 : this.recovering * 3;\n      if (r.length > o)\n        for (r.sort((a, l) => l.score - a.score); r.length > o; )\n          r.pop();\n      r.some((a) => a.reducePos > n) && this.recovering--;\n    } else if (r.length > 1) {\n      e:\n        for (let o = 0; o < r.length - 1; o++) {\n          let a = r[o];\n          for (let l = o + 1; l < r.length; l++) {\n            let c = r[l];\n            if (a.sameState(c) || a.buffer.length > 500 && c.buffer.length > 500)\n              if ((a.score - c.score || a.buffer.length - c.buffer.length) > 0)\n                r.splice(l--, 1);\n              else {\n                r.splice(o--, 1);\n                continue e;\n              }\n          }\n        }\n      r.length > 12 && r.splice(\n        12,\n        r.length - 12\n        /* Rec.MaxStackCount */\n      );\n    }\n    this.minStackPos = r[0].pos;\n    for (let o = 1; o < r.length; o++)\n      r[o].pos < this.minStackPos && (this.minStackPos = r[o].pos);\n    return null;\n  }\n  stopAt(e) {\n    if (this.stoppedAt != null && this.stoppedAt < e)\n      throw new RangeError(\"Can't move stoppedAt forward\");\n    this.stoppedAt = e;\n  }\n  // Returns an updated version of the given stack, or null if the\n  // stack can't advance normally. When `split` and `stacks` are\n  // given, stacks split off by ambiguous operations will be pushed to\n  // `split`, or added to `stacks` if they move `pos` forward.\n  advanceStack(e, n, r) {\n    let i = e.pos, { parser: s } = this, o = Qn ? this.stackID(e) + \" -> \" : \"\";\n    if (this.stoppedAt != null && i > this.stoppedAt)\n      return e.forceReduce() ? e : null;\n    if (this.fragments) {\n      let c = e.curContext && e.curContext.tracker.strict, u = c ? e.curContext.hash : 0;\n      for (let d = this.fragments.nodeAt(i); d; ) {\n        let f = this.parser.nodeSet.types[d.type.id] == d.type ? s.getGoto(e.state, d.type.id) : -1;\n        if (f > -1 && d.length && (!c || (d.prop(Re.contextHash) || 0) == u))\n          return e.useNode(d, f), Qn && console.log(o + this.stackID(e) + ` (via reuse of ${s.getName(d.type.id)})`), !0;\n        if (!(d instanceof gt) || d.children.length == 0 || d.positions[0] > 0)\n          break;\n        let h = d.children[0];\n        if (h instanceof gt && d.positions[0] == 0)\n          d = h;\n        else\n          break;\n      }\n    }\n    let a = s.stateSlot(\n      e.state,\n      4\n      /* ParseState.DefaultReduce */\n    );\n    if (a > 0)\n      return e.reduce(a), Qn && console.log(o + this.stackID(e) + ` (via always-reduce ${s.getName(\n        a & 65535\n        /* Action.ValueMask */\n      )})`), !0;\n    if (e.stack.length >= 8400)\n      for (; e.stack.length > 6e3 && e.forceReduce(); )\n        ;\n    let l = this.tokens.getActions(e);\n    for (let c = 0; c < l.length; ) {\n      let u = l[c++], d = l[c++], f = l[c++], h = c == l.length || !r, p = h ? e : e.split(), O = this.tokens.mainToken;\n      if (p.apply(u, d, O ? O.start : p.pos, f), Qn && console.log(o + this.stackID(p) + ` (via ${u & 65536 ? `reduce of ${s.getName(\n        u & 65535\n        /* Action.ValueMask */\n      )}` : \"shift\"} for ${s.getName(d)} @ ${i}${p == e ? \"\" : \", split\"})`), h)\n        return !0;\n      p.pos > i ? n.push(p) : r.push(p);\n    }\n    return !1;\n  }\n  // Advance a given stack forward as far as it will go. Returns the\n  // (possibly updated) stack if it got stuck, or null if it moved\n  // forward and was given to `pushStackDedup`.\n  advanceFully(e, n) {\n    let r = e.pos;\n    for (; ; ) {\n      if (!this.advanceStack(e, null, null))\n        return !1;\n      if (e.pos > r)\n        return o0(e, n), !0;\n    }\n  }\n  runRecovery(e, n, r) {\n    let i = null, s = !1;\n    for (let o = 0; o < e.length; o++) {\n      let a = e[o], l = n[o << 1], c = n[(o << 1) + 1], u = Qn ? this.stackID(a) + \" -> \" : \"\";\n      if (a.deadEnd && (s || (s = !0, a.restart(), Qn && console.log(u + this.stackID(a) + \" (restarted)\"), this.advanceFully(a, r))))\n        continue;\n      let d = a.split(), f = u;\n      for (let h = 0; d.forceReduce() && h < 10 && (Qn && console.log(f + this.stackID(d) + \" (via force-reduce)\"), !this.advanceFully(d, r)); h++)\n        Qn && (f = this.stackID(d) + \" -> \");\n      for (let h of a.recoverByInsert(l))\n        Qn && console.log(u + this.stackID(h) + \" (via recover-insert)\"), this.advanceFully(h, r);\n      this.stream.end > a.pos ? (c == a.pos && (c++, l = 0), a.recoverByDelete(l, c), Qn && console.log(u + this.stackID(a) + ` (via recover-delete ${this.parser.getName(l)})`), o0(a, r)) : (!i || i.score < a.score) && (i = a);\n    }\n    return i;\n  }\n  // Convert the stack's buffer to a syntax tree.\n  stackToTree(e) {\n    return e.close(), gt.build({\n      buffer: zu.create(e),\n      nodeSet: this.parser.nodeSet,\n      topID: this.topTerm,\n      maxBufferLength: this.parser.bufferLength,\n      reused: this.reused,\n      start: this.ranges[0].from,\n      length: e.pos - this.ranges[0].from,\n      minRepeatType: this.parser.minRepeatTerm\n    });\n  }\n  stackID(e) {\n    let n = (jf || (jf = /* @__PURE__ */ new WeakMap())).get(e);\n    return n || jf.set(e, n = String.fromCodePoint(this.nextStackID++)), n + e;\n  }\n}\nfunction o0(t, e) {\n  for (let n = 0; n < e.length; n++) {\n    let r = e[n];\n    if (r.pos == t.pos && r.sameState(t)) {\n      e[n].score < t.score && (e[n] = t);\n      return;\n    }\n  }\n  e.push(t);\n}\nclass gV {\n  constructor(e, n, r) {\n    this.source = e, this.flags = n, this.disabled = r;\n  }\n  allows(e) {\n    return !this.disabled || this.disabled[e] == 0;\n  }\n}\nconst Bf = (t) => t;\nclass wg {\n  /**\n  Define a context tracker.\n  */\n  constructor(e) {\n    this.start = e.start, this.shift = e.shift || Bf, this.reduce = e.reduce || Bf, this.reuse = e.reuse || Bf, this.hash = e.hash || (() => 0), this.strict = e.strict !== !1;\n  }\n}\nclass us extends tx {\n  /**\n  @internal\n  */\n  constructor(e) {\n    if (super(), this.wrappers = [], e.version != 14)\n      throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (14)`);\n    let n = e.nodeNames.split(\" \");\n    this.minRepeatTerm = n.length;\n    for (let a = 0; a < e.repeatNodeCount; a++)\n      n.push(\"\");\n    let r = Object.keys(e.topRules).map((a) => e.topRules[a][1]), i = [];\n    for (let a = 0; a < n.length; a++)\n      i.push([]);\n    function s(a, l, c) {\n      i[a].push([l, l.deserialize(String(c))]);\n    }\n    if (e.nodeProps)\n      for (let a of e.nodeProps) {\n        let l = a[0];\n        typeof l == \"string\" && (l = Re[l]);\n        for (let c = 1; c < a.length; ) {\n          let u = a[c++];\n          if (u >= 0)\n            s(u, l, a[c++]);\n          else {\n            let d = a[c + -u];\n            for (let f = -u; f > 0; f--)\n              s(a[c++], l, d);\n            c++;\n          }\n        }\n      }\n    this.nodeSet = new fg(n.map((a, l) => On.define({\n      name: l >= this.minRepeatTerm ? void 0 : a,\n      id: l,\n      props: i[l],\n      top: r.indexOf(l) > -1,\n      error: l == 0,\n      skipped: e.skippedNodes && e.skippedNodes.indexOf(l) > -1\n    }))), e.propSources && (this.nodeSet = this.nodeSet.extend(...e.propSources)), this.strict = !1, this.bufferLength = Fk;\n    let o = Va(e.tokenData);\n    this.context = e.context, this.specializerSpecs = e.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);\n    for (let a = 0; a < this.specializerSpecs.length; a++)\n      this.specialized[a] = this.specializerSpecs[a].term;\n    this.specializers = this.specializerSpecs.map(a0), this.states = Va(e.states, Uint32Array), this.data = Va(e.stateData), this.goto = Va(e.goto), this.maxTerm = e.maxTerm, this.tokenizers = e.tokenizers.map((a) => typeof a == \"number\" ? new Co(o, a) : a), this.topRules = e.topRules, this.dialects = e.dialects || {}, this.dynamicPrecedences = e.dynamicPrecedences || null, this.tokenPrecTable = e.tokenPrec, this.termNames = e.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];\n  }\n  createParse(e, n, r) {\n    let i = new OV(this, e, n, r);\n    for (let s of this.wrappers)\n      i = s(i, e, n, r);\n    return i;\n  }\n  /**\n  Get a goto table entry @internal\n  */\n  getGoto(e, n, r = !1) {\n    let i = this.goto;\n    if (n >= i[0])\n      return -1;\n    for (let s = i[n + 1]; ; ) {\n      let o = i[s++], a = o & 1, l = i[s++];\n      if (a && r)\n        return l;\n      for (let c = s + (o >> 1); s < c; s++)\n        if (i[s] == e)\n          return l;\n      if (a)\n        return -1;\n    }\n  }\n  /**\n  Check if this state has an action for a given terminal @internal\n  */\n  hasAction(e, n) {\n    let r = this.data;\n    for (let i = 0; i < 2; i++)\n      for (let s = this.stateSlot(\n        e,\n        i ? 2 : 1\n        /* ParseState.Actions */\n      ), o; ; s += 3) {\n        if ((o = r[s]) == 65535)\n          if (r[s + 1] == 1)\n            o = r[s = ti(r, s + 2)];\n          else {\n            if (r[s + 1] == 2)\n              return ti(r, s + 2);\n            break;\n          }\n        if (o == n || o == 0)\n          return ti(r, s + 1);\n      }\n    return 0;\n  }\n  /**\n  @internal\n  */\n  stateSlot(e, n) {\n    return this.states[e * 6 + n];\n  }\n  /**\n  @internal\n  */\n  stateFlag(e, n) {\n    return (this.stateSlot(\n      e,\n      0\n      /* ParseState.Flags */\n    ) & n) > 0;\n  }\n  /**\n  @internal\n  */\n  validAction(e, n) {\n    return !!this.allActions(e, (r) => r == n ? !0 : null);\n  }\n  /**\n  @internal\n  */\n  allActions(e, n) {\n    let r = this.stateSlot(\n      e,\n      4\n      /* ParseState.DefaultReduce */\n    ), i = r ? n(r) : void 0;\n    for (let s = this.stateSlot(\n      e,\n      1\n      /* ParseState.Actions */\n    ); i == null; s += 3) {\n      if (this.data[s] == 65535)\n        if (this.data[s + 1] == 1)\n          s = ti(this.data, s + 2);\n        else\n          break;\n      i = n(ti(this.data, s + 1));\n    }\n    return i;\n  }\n  /**\n  Get the states that can follow this one through shift actions or\n  goto jumps. @internal\n  */\n  nextStates(e) {\n    let n = [];\n    for (let r = this.stateSlot(\n      e,\n      1\n      /* ParseState.Actions */\n    ); ; r += 3) {\n      if (this.data[r] == 65535)\n        if (this.data[r + 1] == 1)\n          r = ti(this.data, r + 2);\n        else\n          break;\n      if (!(this.data[r + 2] & 1)) {\n        let i = this.data[r + 1];\n        n.some((s, o) => o & 1 && s == i) || n.push(this.data[r], i);\n      }\n    }\n    return n;\n  }\n  /**\n  Configure the parser. Returns a new parser instance that has the\n  given settings modified. Settings not provided in `config` are\n  kept from the original parser.\n  */\n  configure(e) {\n    let n = Object.assign(Object.create(us.prototype), this);\n    if (e.props && (n.nodeSet = this.nodeSet.extend(...e.props)), e.top) {\n      let r = this.topRules[e.top];\n      if (!r)\n        throw new RangeError(`Invalid top rule name ${e.top}`);\n      n.top = r;\n    }\n    return e.tokenizers && (n.tokenizers = this.tokenizers.map((r) => {\n      let i = e.tokenizers.find((s) => s.from == r);\n      return i ? i.to : r;\n    })), e.specializers && (n.specializers = this.specializers.slice(), n.specializerSpecs = this.specializerSpecs.map((r, i) => {\n      let s = e.specializers.find((a) => a.from == r.external);\n      if (!s)\n        return r;\n      let o = Object.assign(Object.assign({}, r), { external: s.to });\n      return n.specializers[i] = a0(o), o;\n    })), e.contextTracker && (n.context = e.contextTracker), e.dialect && (n.dialect = this.parseDialect(e.dialect)), e.strict != null && (n.strict = e.strict), e.wrap && (n.wrappers = n.wrappers.concat(e.wrap)), e.bufferLength != null && (n.bufferLength = e.bufferLength), n;\n  }\n  /**\n  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)\n  are registered for this parser.\n  */\n  hasWrappers() {\n    return this.wrappers.length > 0;\n  }\n  /**\n  Returns the name associated with a given term. This will only\n  work for all terms when the parser was generated with the\n  `--names` option. By default, only the names of tagged terms are\n  stored.\n  */\n  getName(e) {\n    return this.termNames ? this.termNames[e] : String(e <= this.maxNode && this.nodeSet.types[e].name || e);\n  }\n  /**\n  The eof term id is always allocated directly after the node\n  types. @internal\n  */\n  get eofTerm() {\n    return this.maxNode + 1;\n  }\n  /**\n  The type of top node produced by the parser.\n  */\n  get topNode() {\n    return this.nodeSet.types[this.top[1]];\n  }\n  /**\n  @internal\n  */\n  dynamicPrecedence(e) {\n    let n = this.dynamicPrecedences;\n    return n == null ? 0 : n[e] || 0;\n  }\n  /**\n  @internal\n  */\n  parseDialect(e) {\n    let n = Object.keys(this.dialects), r = n.map(() => !1);\n    if (e)\n      for (let s of e.split(\" \")) {\n        let o = n.indexOf(s);\n        o >= 0 && (r[o] = !0);\n      }\n    let i = null;\n    for (let s = 0; s < n.length; s++)\n      if (!r[s])\n        for (let o = this.dialects[n[s]], a; (a = this.data[o++]) != 65535; )\n          (i || (i = new Uint8Array(this.maxTerm + 1)))[a] = 1;\n    return new gV(e, r, i);\n  }\n  /**\n  Used by the output of the parser generator. Not available to\n  user code. @hide\n  */\n  static deserialize(e) {\n    return new us(e);\n  }\n}\nfunction ti(t, e) {\n  return t[e] | t[e + 1] << 16;\n}\nfunction mV(t) {\n  let e = null;\n  for (let n of t) {\n    let r = n.p.stoppedAt;\n    (n.pos == n.p.stream.end || r != null && n.pos > r) && n.p.parser.stateFlag(\n      n.state,\n      2\n      /* StateFlag.Accepting */\n    ) && (!e || e.score < n.score) && (e = n);\n  }\n  return e;\n}\nfunction a0(t) {\n  if (t.external) {\n    let e = t.extend ? 1 : 0;\n    return (n, r) => t.external(n, r) << 1 | e;\n  }\n  return t.get;\n}\nconst bV = 99, l0 = 1, vV = 100, yV = 101, c0 = 2, Nx = [\n  9,\n  10,\n  11,\n  12,\n  13,\n  32,\n  133,\n  160,\n  5760,\n  8192,\n  8193,\n  8194,\n  8195,\n  8196,\n  8197,\n  8198,\n  8199,\n  8200,\n  8201,\n  8202,\n  8232,\n  8233,\n  8239,\n  8287,\n  12288\n], SV = 58, wV = 40, Dx = 95, kV = 91, uu = 45, xV = 46, PV = 35, _V = 37, TV = 38, EV = 92, $V = 10;\nfunction xl(t) {\n  return t >= 65 && t <= 90 || t >= 97 && t <= 122 || t >= 161;\n}\nfunction Zx(t) {\n  return t >= 48 && t <= 57;\n}\nconst QV = new gn((t, e) => {\n  for (let n = !1, r = 0, i = 0; ; i++) {\n    let { next: s } = t;\n    if (xl(s) || s == uu || s == Dx || n && Zx(s))\n      !n && (s != uu || i > 0) && (n = !0), r === i && s == uu && r++, t.advance();\n    else if (s == EV && t.peek(1) != $V)\n      t.advance(), t.next > -1 && t.advance(), n = !0;\n    else {\n      n && t.acceptToken(s == wV ? vV : r == 2 && e.canShift(c0) ? c0 : yV);\n      break;\n    }\n  }\n}), CV = new gn((t) => {\n  if (Nx.includes(t.peek(-1))) {\n    let { next: e } = t;\n    (xl(e) || e == Dx || e == PV || e == xV || e == kV || e == SV && xl(t.peek(1)) || e == uu || e == TV) && t.acceptToken(bV);\n  }\n}), AV = new gn((t) => {\n  if (!Nx.includes(t.peek(-1))) {\n    let { next: e } = t;\n    if (e == _V && (t.advance(), t.acceptToken(l0)), xl(e)) {\n      do\n        t.advance();\n      while (xl(t.next) || Zx(t.next));\n      t.acceptToken(l0);\n    }\n  }\n}), RV = ia({\n  \"AtKeyword import charset namespace keyframes media supports\": P.definitionKeyword,\n  \"from to selector\": P.keyword,\n  NamespaceName: P.namespace,\n  KeyframeName: P.labelName,\n  KeyframeRangeName: P.operatorKeyword,\n  TagName: P.tagName,\n  ClassName: P.className,\n  PseudoClassName: P.constant(P.className),\n  IdName: P.labelName,\n  \"FeatureName PropertyName\": P.propertyName,\n  AttributeName: P.attributeName,\n  NumberLiteral: P.number,\n  KeywordQuery: P.keyword,\n  UnaryQueryOp: P.operatorKeyword,\n  \"CallTag ValueName\": P.atom,\n  VariableName: P.variableName,\n  Callee: P.operatorKeyword,\n  Unit: P.unit,\n  \"UniversalSelector NestingSelector\": P.definitionOperator,\n  MatchOp: P.compareOperator,\n  \"ChildOp SiblingOp, LogicOp\": P.logicOperator,\n  BinOp: P.arithmeticOperator,\n  Important: P.modifier,\n  Comment: P.blockComment,\n  ColorLiteral: P.color,\n  \"ParenthesizedContent StringLiteral\": P.string,\n  \":\": P.punctuation,\n  \"PseudoOp #\": P.derefOperator,\n  \"; ,\": P.separator,\n  \"( )\": P.paren,\n  \"[ ]\": P.squareBracket,\n  \"{ }\": P.brace\n}), NV = { __proto__: null, lang: 32, \"nth-child\": 32, \"nth-last-child\": 32, \"nth-of-type\": 32, \"nth-last-of-type\": 32, dir: 32, \"host-context\": 32, url: 60, \"url-prefix\": 60, domain: 60, regexp: 60, selector: 138 }, DV = { __proto__: null, \"@import\": 118, \"@media\": 142, \"@charset\": 146, \"@namespace\": 150, \"@keyframes\": 156, \"@supports\": 168 }, ZV = { __proto__: null, not: 132, only: 132 }, VV = us.deserialize({\n  version: 14,\n  states: \":^QYQ[OOO#_Q[OOP#fOWOOOOQP'#Cd'#CdOOQP'#Cc'#CcO#kQ[O'#CfO$_QXO'#CaO$fQ[O'#ChO$qQ[O'#DTO$vQ[O'#DWOOQP'#Em'#EmO${QdO'#DgO%jQ[O'#DtO${QdO'#DvO%{Q[O'#DxO&WQ[O'#D{O&`Q[O'#ERO&nQ[O'#ETOOQS'#El'#ElOOQS'#EW'#EWQYQ[OOO&uQXO'#CdO'jQWO'#DcO'oQWO'#EsO'zQ[O'#EsQOQWOOP(UO#tO'#C_POOO)C@[)C@[OOQP'#Cg'#CgOOQP,59Q,59QO#kQ[O,59QO(aQ[O'#E[O({QWO,58{O)TQ[O,59SO$qQ[O,59oO$vQ[O,59rO(aQ[O,59uO(aQ[O,59wO(aQ[O,59xO)`Q[O'#DbOOQS,58{,58{OOQP'#Ck'#CkOOQO'#DR'#DROOQP,59S,59SO)gQWO,59SO)lQWO,59SOOQP'#DV'#DVOOQP,59o,59oOOQO'#DX'#DXO)qQ`O,59rOOQS'#Cp'#CpO${QdO'#CqO)yQvO'#CsO+ZQtO,5:ROOQO'#Cx'#CxO)lQWO'#CwO+oQWO'#CyO+tQ[O'#DOOOQS'#Ep'#EpOOQO'#Dj'#DjO+|Q[O'#DqO,[QWO'#EtO&`Q[O'#DoO,jQWO'#DrOOQO'#Eu'#EuO)OQWO,5:`O,oQpO,5:bOOQS'#Dz'#DzO,wQWO,5:dO,|Q[O,5:dOOQO'#D}'#D}O-UQWO,5:gO-ZQWO,5:mO-cQWO,5:oOOQS-E8U-E8UO${QdO,59}O-kQ[O'#E^O-xQWO,5;_O-xQWO,5;_POOO'#EV'#EVP.TO#tO,58yPOOO,58y,58yOOQP1G.l1G.lO.zQXO,5:vOOQO-E8Y-E8YOOQS1G.g1G.gOOQP1G.n1G.nO)gQWO1G.nO)lQWO1G.nOOQP1G/Z1G/ZO/XQ`O1G/^O/rQXO1G/aO0YQXO1G/cO0pQXO1G/dO1WQWO,59|O1]Q[O'#DSO1dQdO'#CoOOQP1G/^1G/^O${QdO1G/^O1kQpO,59]OOQS,59_,59_O${QdO,59aO1sQWO1G/mOOQS,59c,59cO1xQ!bO,59eOOQS'#DP'#DPOOQS'#EY'#EYO2QQ[O,59jOOQS,59j,59jO2YQWO'#DjO2eQWO,5:VO2jQWO,5:]O&`Q[O,5:XO&`Q[O'#E_O2rQWO,5;`O2}QWO,5:ZO(aQ[O,5:^OOQS1G/z1G/zOOQS1G/|1G/|OOQS1G0O1G0OO3`QWO1G0OO3eQdO'#EOOOQS1G0R1G0ROOQS1G0X1G0XOOQS1G0Z1G0ZO3pQtO1G/iOOQO,5:x,5:xO4WQ[O,5:xOOQO-E8[-E8[O4eQWO1G0yPOOO-E8T-E8TPOOO1G.e1G.eOOQP7+$Y7+$YOOQP7+$x7+$xO${QdO7+$xOOQS1G/h1G/hO4pQXO'#ErO4wQWO,59nO4|QtO'#EXO5tQdO'#EoO6OQWO,59ZO6TQpO7+$xOOQS1G.w1G.wOOQS1G.{1G.{OOQS7+%X7+%XO6]QWO1G/POOQS-E8W-E8WOOQS1G/U1G/UO${QdO1G/qOOQO1G/w1G/wOOQO1G/s1G/sO6bQWO,5:yOOQO-E8]-E8]O6pQXO1G/xOOQS7+%j7+%jO6wQYO'#CsOOQO'#EQ'#EQO7SQ`O'#EPOOQO'#EP'#EPO7_QWO'#E`O7gQdO,5:jOOQS,5:j,5:jO7rQtO'#E]O${QdO'#E]O8sQdO7+%TOOQO7+%T7+%TOOQO1G0d1G0dO9WQpO<<HdO9`QWO,5;^OOQP1G/Y1G/YOOQS-E8V-E8VO${QdO'#EZO9hQWO,5;ZOOQT1G.u1G.uOOQP<<Hd<<HdOOQS7+$k7+$kO9pQdO7+%]OOQO7+%d7+%dOOQO,5:k,5:kO3hQdO'#EaO7_QWO,5:zOOQS,5:z,5:zOOQS-E8^-E8^OOQS1G0U1G0UO9wQtO,5:wOOQS-E8Z-E8ZOOQO<<Ho<<HoOOQPAN>OAN>OO:xQdO,5:uOOQO-E8X-E8XOOQO<<Hw<<HwOOQO,5:{,5:{OOQO-E8_-E8_OOQS1G0f1G0f\",\n  stateData: \";[~O#ZOS#[QQ~OUYOXYO]VO^VOqXOxWO![aO!]ZO!i[O!k]O!m^O!p_O!v`O#XRO#bTO~OQfOUYOXYO]VO^VOqXOxWO![aO!]ZO!i[O!k]O!m^O!p_O!v`O#XeO#bTO~O#U#gP~P!ZO#[jO~O#XlO~O]qO^qOqsOtoOxrO!OtO!RvO#VuO#bnO~O!TwO~P#pO`}O#WzO#XyO~O#X!OO~O#X!QO~OQ![Ob!TOf![Oh![On!YOq!ZO#W!WO#X!SO#e!UO~Ob!^O!d!`O!g!aO#X!]O!T#hP~Oh!fOn!YO#X!eO~Oh!hO#X!hO~Ob!^O!d!`O!g!aO#X!]O~O!Y#hP~P%jO]WX]!WX^WXqWXtWXxWX!OWX!RWX!TWX#VWX#bWX~O]!mO~O!Y!nO#U#gX!S#gX~O#U#gX!S#gX~P!ZO#]!qO#^!qO#_!sO~OUYOXYO]VO^VOqXOxWO#XRO#bTO~OtoO!TwO~O`!zO#WzO#XyO~O!S#gP~P!ZOb#RO~Ob#SO~Op#TO|#UO~OP#WObgXjgX!YgX!dgX!ggX#XgXagXQgXfgXhgXngXqgXtgX!XgX#UgX#WgX#egXpgX!SgX~Ob!^Oj#XO!d!`O!g!aO#X!]O!Y#hP~Ob#[O~Op#`O#X#]O~Ob!^O!d!`O!g!aO#X#aO~Ot#eO!b#dO!T#hX!Y#hX~Ob#hO~Oj#XO!Y#jO~O!Y#kO~Oh#lOn!YO~O!T#mO~O!TwO!b#dO~O!TwO!Y#pO~O!Y#QX#U#QX!S#QX~P!ZO!Y!nO#U#ga!S#ga~O#]!qO#^!qO#_#wO~O]qO^qOqsOxrO!OtO!RvO#VuO#bnO~Ot#Oa!T#Oaa#Oa~P.`Op#yO|#zO~O]qO^qOqsOxrO#bnO~Ot}i!O}i!R}i!T}i#V}ia}i~P/aOt!Pi!O!Pi!R!Pi!T!Pi#V!Pia!Pi~P/aOt!Qi!O!Qi!R!Qi!T!Qi#V!Qia!Qi~P/aO!S#{O~Oa#fP~P(aOa#cP~P${Oa$SOj#XO~O!Y$UO~Oh$VOo$VO~Op$XO#X#]O~O]!`Xa!^X!b!^X~O]$YO~Oa$ZO!b#dO~Ot#eO!T#ha!Y#ha~O!b#dOt!ca!T!ca!Y!caa!ca~O!Y$`O~O!S$gO#X$bO#e$aO~Oj#XOt$iO!X$kO!Y!Vi#U!Vi!S!Vi~P${O!Y#Qa#U#Qa!S#Qa~P!ZO!Y!nO#U#gi!S#gi~Oa#fX~P#pOa$oO~Oj#XOQ!{Xa!{Xb!{Xf!{Xh!{Xn!{Xq!{Xt!{X#W!{X#X!{X#e!{X~Ot$qOa#cX~P${Oa$sO~Oj#XOp$tO~Oa$uO~O!b#dOt#Ra!T#Ra!Y#Ra~Oa$wO~P.`OP#WOtgX!TgX~O#e$aOt!sX!T!sX~Ot$yO!TwO~O!S$}O#X$bO#e$aO~Oj#XOQ#PXb#PXf#PXh#PXn#PXq#PXt#PX!X#PX!Y#PX#U#PX#W#PX#X#PX#e#PX!S#PX~Ot$iO!X%QO!Y!Vq#U!Vq!S!Vq~P${Oj#XOp%RO~OtoOa#fa~Ot$qOa#ca~Oa%UO~P${Oj#XOQ#Pab#Paf#Pah#Pan#Paq#Pat#Pa!X#Pa!Y#Pa#U#Pa#W#Pa#X#Pa#e#Pa!S#Pa~Oa!}at!}a~P${O#Zo#[#ej!R#e~\",\n  goto: \"-g#jPPP#kP#nP#w$WP#w$g#wPP$mPPP$s$|$|P%`P$|P$|%z&^PPPP$|&vP&z'Q#wP'W#w'^P#wP#w#wPPP'd'y(WPP#nPP(_(_(i(_P(_P(_(_P#nP#nP#nP(l#nP(o(r(u(|#nP#nP)R)X)h)v)|*S*^*d*n*t*zPPPPPPPPPP+Q+ZP+v+yP,o,r,x-RRkQ_bOPdhw!n#skYOPdhotuvw!n#R#h#skSOPdhotuvw!n#R#h#sQmTR!tnQ{VR!xqQ!x}Q#Z!XR#x!zq![Z]!T!m#S#U#X#q#z$P$Y$i$j$q$v%Sp![Z]!T!m#S#U#X#q#z$P$Y$i$j$q$v%SU$d#m$f$yR$x$cq!XZ]!T!m#S#U#X#q#z$P$Y$i$j$q$v%Sp![Z]!T!m#S#U#X#q#z$P$Y$i$j$q$v%SQ!f^R#l!gT#^!Z#_Q|VR!yqQ!x|R#x!yQ!PWR!{rQ!RXR!|sQxUQ!wpQ#i!cQ#o!jQ#p!kQ${$eR%X$zSgPwQ!phQ#r!nR$l#sZfPhw!n#sa!b[`a!V!^!`#d#eR#b!^R!g^R!i_R#n!iS$e#m$fR%V$yV$c#m$f$yQ!rjR#v!rQdOShPwU!ldh#sR#s!nQ$P#SU$p$P$v%SQ$v$YR%S$qQ#_!ZR$W#_Q$r$PR%T$rQpUS!vp$nR$n#|Q$j#qR%P$jQ!ogS#t!o#uR#u!pQ#f!_R$^#fQ$f#mR$|$fQ$z$eR%W$z_cOPdhw!n#s^UOPdhw!n#sQ!uoQ!}tQ#OuQ#PvQ#|#RR$_#hR$Q#SQ!VZQ!d]Q#V!TQ#q!m[$O#S$P$Y$q$v%SQ$R#UQ$T#XS$h#q$jQ$m#zR%O$iR#}#RQiPR#QwQ!c[Q!kaR#Y!VU!_[a!VQ!j`Q#c!^Q#g!`Q$[#dR$]#e\",\n  nodeNames: \" Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent ] [ LineNames LineName , PseudoClassName ArgList IdSelector # IdName AttributeSelector AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports AtRule Styles\",\n  maxTerm: 117,\n  nodeProps: [\n    [\"isolate\", -2, 3, 24, \"\"],\n    [\"openedBy\", 17, \"(\", 32, \"[\", 50, \"{\"],\n    [\"closedBy\", 18, \")\", 33, \"]\", 51, \"}\"]\n  ],\n  propSources: [RV],\n  skippedNodes: [0, 3, 87],\n  repeatNodeCount: 11,\n  tokenData: \"J^~R!^OX$}X^%u^p$}pq%uqr)Xrs.Rst/utu6duv$}vw7^wx7oxy9^yz9oz{9t{|:_|}?Q}!O?c!O!P@Q!P!Q@i!Q![Ab![!]B]!]!^CX!^!_$}!_!`Cj!`!aC{!a!b$}!b!cDw!c!}$}!}#OFa#O#P$}#P#QFr#Q#R6d#R#T$}#T#UGT#U#c$}#c#dHf#d#o$}#o#pH{#p#q6d#q#rI^#r#sIo#s#y$}#y#z%u#z$f$}$f$g%u$g#BY$}#BY#BZ%u#BZ$IS$}$IS$I_%u$I_$I|$}$I|$JO%u$JO$JT$}$JT$JU%u$JU$KV$}$KV$KW%u$KW&FU$}&FU&FV%u&FV;'S$};'S;=`JW<%lO$}`%QSOy%^z;'S%^;'S;=`%o<%lO%^`%cSo`Oy%^z;'S%^;'S;=`%o<%lO%^`%rP;=`<%l%^~%zh#Z~OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^~'mh#Z~o`OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^l)[UOy%^z#]%^#]#^)n#^;'S%^;'S;=`%o<%lO%^l)sUo`Oy%^z#a%^#a#b*V#b;'S%^;'S;=`%o<%lO%^l*[Uo`Oy%^z#d%^#d#e*n#e;'S%^;'S;=`%o<%lO%^l*sUo`Oy%^z#c%^#c#d+V#d;'S%^;'S;=`%o<%lO%^l+[Uo`Oy%^z#f%^#f#g+n#g;'S%^;'S;=`%o<%lO%^l+sUo`Oy%^z#h%^#h#i,V#i;'S%^;'S;=`%o<%lO%^l,[Uo`Oy%^z#T%^#T#U,n#U;'S%^;'S;=`%o<%lO%^l,sUo`Oy%^z#b%^#b#c-V#c;'S%^;'S;=`%o<%lO%^l-[Uo`Oy%^z#h%^#h#i-n#i;'S%^;'S;=`%o<%lO%^l-uS!X[o`Oy%^z;'S%^;'S;=`%o<%lO%^~.UWOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o<%lO.R~.sOh~~.vRO;'S.R;'S;=`/P;=`O.R~/SXOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o;=`<%l.R<%lO.R~/rP;=`<%l.Rn/zYxQOy%^z!Q%^!Q![0j![!c%^!c!i0j!i#T%^#T#Z0j#Z;'S%^;'S;=`%o<%lO%^l0oYo`Oy%^z!Q%^!Q![1_![!c%^!c!i1_!i#T%^#T#Z1_#Z;'S%^;'S;=`%o<%lO%^l1dYo`Oy%^z!Q%^!Q![2S![!c%^!c!i2S!i#T%^#T#Z2S#Z;'S%^;'S;=`%o<%lO%^l2ZYf[o`Oy%^z!Q%^!Q![2y![!c%^!c!i2y!i#T%^#T#Z2y#Z;'S%^;'S;=`%o<%lO%^l3QYf[o`Oy%^z!Q%^!Q![3p![!c%^!c!i3p!i#T%^#T#Z3p#Z;'S%^;'S;=`%o<%lO%^l3uYo`Oy%^z!Q%^!Q![4e![!c%^!c!i4e!i#T%^#T#Z4e#Z;'S%^;'S;=`%o<%lO%^l4lYf[o`Oy%^z!Q%^!Q![5[![!c%^!c!i5[!i#T%^#T#Z5[#Z;'S%^;'S;=`%o<%lO%^l5aYo`Oy%^z!Q%^!Q![6P![!c%^!c!i6P!i#T%^#T#Z6P#Z;'S%^;'S;=`%o<%lO%^l6WSf[o`Oy%^z;'S%^;'S;=`%o<%lO%^d6gUOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^d7QS|So`Oy%^z;'S%^;'S;=`%o<%lO%^b7cSXQOy%^z;'S%^;'S;=`%o<%lO%^~7rWOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W<%lO7o~8_RO;'S7o;'S;=`8h;=`O7o~8kXOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W;=`<%l7o<%lO7o~9ZP;=`<%l7on9cSb^Oy%^z;'S%^;'S;=`%o<%lO%^~9tOa~n9{UUQjWOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^n:fWjW!RQOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^l;TUo`Oy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^l;nYo`#e[Oy%^z!Q%^!Q![;g![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^l<cYo`Oy%^z{%^{|=R|}%^}!O=R!O!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=WUo`Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=qUo`#e[Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l>[[o`#e[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^n?VSt^Oy%^z;'S%^;'S;=`%o<%lO%^l?hWjWOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^n@VU#bQOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^~@nTjWOy%^z{@}{;'S%^;'S;=`%o<%lO%^~AUSo`#[~Oy%^z;'S%^;'S;=`%o<%lO%^lAg[#e[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^bBbU]QOy%^z![%^![!]Bt!];'S%^;'S;=`%o<%lO%^bB{S^Qo`Oy%^z;'S%^;'S;=`%o<%lO%^nC^S!Y^Oy%^z;'S%^;'S;=`%o<%lO%^dCoS|SOy%^z;'S%^;'S;=`%o<%lO%^bDQU!OQOy%^z!`%^!`!aDd!a;'S%^;'S;=`%o<%lO%^bDkS!OQo`Oy%^z;'S%^;'S;=`%o<%lO%^bDzWOy%^z!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^bEk[![Qo`Oy%^z}%^}!OEd!O!Q%^!Q![Ed![!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^nFfSq^Oy%^z;'S%^;'S;=`%o<%lO%^nFwSp^Oy%^z;'S%^;'S;=`%o<%lO%^bGWUOy%^z#b%^#b#cGj#c;'S%^;'S;=`%o<%lO%^bGoUo`Oy%^z#W%^#W#XHR#X;'S%^;'S;=`%o<%lO%^bHYS!bQo`Oy%^z;'S%^;'S;=`%o<%lO%^bHiUOy%^z#f%^#f#gHR#g;'S%^;'S;=`%o<%lO%^fIQS!TUOy%^z;'S%^;'S;=`%o<%lO%^nIcS!S^Oy%^z;'S%^;'S;=`%o<%lO%^fItU!RQOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^`JZP;=`<%l$}\",\n  tokenizers: [CV, AV, QV, 1, 2, 3, 4, new Hu(\"m~RRYZ[z{a~~g~aO#^~~dP!P!Qg~lO#_~~\", 28, 105)],\n  topRules: { StyleSheet: [0, 4], Styles: [1, 86] },\n  specialized: [{ term: 100, get: (t) => NV[t] || -1 }, { term: 58, get: (t) => DV[t] || -1 }, { term: 101, get: (t) => ZV[t] || -1 }],\n  tokenPrec: 1200\n});\nlet Lf = null;\nfunction Uf() {\n  if (!Lf && typeof document == \"object\" && document.body) {\n    let { style: t } = document.body, e = [], n = /* @__PURE__ */ new Set();\n    for (let r in t)\n      r != \"cssText\" && r != \"cssFloat\" && typeof t[r] == \"string\" && (/[A-Z]/.test(r) && (r = r.replace(/[A-Z]/g, (i) => \"-\" + i.toLowerCase())), n.has(r) || (e.push(r), n.add(r)));\n    Lf = e.sort().map((r) => ({ type: \"property\", label: r }));\n  }\n  return Lf || [];\n}\nconst u0 = /* @__PURE__ */ [\n  \"active\",\n  \"after\",\n  \"any-link\",\n  \"autofill\",\n  \"backdrop\",\n  \"before\",\n  \"checked\",\n  \"cue\",\n  \"default\",\n  \"defined\",\n  \"disabled\",\n  \"empty\",\n  \"enabled\",\n  \"file-selector-button\",\n  \"first\",\n  \"first-child\",\n  \"first-letter\",\n  \"first-line\",\n  \"first-of-type\",\n  \"focus\",\n  \"focus-visible\",\n  \"focus-within\",\n  \"fullscreen\",\n  \"has\",\n  \"host\",\n  \"host-context\",\n  \"hover\",\n  \"in-range\",\n  \"indeterminate\",\n  \"invalid\",\n  \"is\",\n  \"lang\",\n  \"last-child\",\n  \"last-of-type\",\n  \"left\",\n  \"link\",\n  \"marker\",\n  \"modal\",\n  \"not\",\n  \"nth-child\",\n  \"nth-last-child\",\n  \"nth-last-of-type\",\n  \"nth-of-type\",\n  \"only-child\",\n  \"only-of-type\",\n  \"optional\",\n  \"out-of-range\",\n  \"part\",\n  \"placeholder\",\n  \"placeholder-shown\",\n  \"read-only\",\n  \"read-write\",\n  \"required\",\n  \"right\",\n  \"root\",\n  \"scope\",\n  \"selection\",\n  \"slotted\",\n  \"target\",\n  \"target-text\",\n  \"valid\",\n  \"visited\",\n  \"where\"\n].map((t) => ({ type: \"class\", label: t })), d0 = /* @__PURE__ */ [\n  \"above\",\n  \"absolute\",\n  \"activeborder\",\n  \"additive\",\n  \"activecaption\",\n  \"after-white-space\",\n  \"ahead\",\n  \"alias\",\n  \"all\",\n  \"all-scroll\",\n  \"alphabetic\",\n  \"alternate\",\n  \"always\",\n  \"antialiased\",\n  \"appworkspace\",\n  \"asterisks\",\n  \"attr\",\n  \"auto\",\n  \"auto-flow\",\n  \"avoid\",\n  \"avoid-column\",\n  \"avoid-page\",\n  \"avoid-region\",\n  \"axis-pan\",\n  \"background\",\n  \"backwards\",\n  \"baseline\",\n  \"below\",\n  \"bidi-override\",\n  \"blink\",\n  \"block\",\n  \"block-axis\",\n  \"bold\",\n  \"bolder\",\n  \"border\",\n  \"border-box\",\n  \"both\",\n  \"bottom\",\n  \"break\",\n  \"break-all\",\n  \"break-word\",\n  \"bullets\",\n  \"button\",\n  \"button-bevel\",\n  \"buttonface\",\n  \"buttonhighlight\",\n  \"buttonshadow\",\n  \"buttontext\",\n  \"calc\",\n  \"capitalize\",\n  \"caps-lock-indicator\",\n  \"caption\",\n  \"captiontext\",\n  \"caret\",\n  \"cell\",\n  \"center\",\n  \"checkbox\",\n  \"circle\",\n  \"cjk-decimal\",\n  \"clear\",\n  \"clip\",\n  \"close-quote\",\n  \"col-resize\",\n  \"collapse\",\n  \"color\",\n  \"color-burn\",\n  \"color-dodge\",\n  \"column\",\n  \"column-reverse\",\n  \"compact\",\n  \"condensed\",\n  \"contain\",\n  \"content\",\n  \"contents\",\n  \"content-box\",\n  \"context-menu\",\n  \"continuous\",\n  \"copy\",\n  \"counter\",\n  \"counters\",\n  \"cover\",\n  \"crop\",\n  \"cross\",\n  \"crosshair\",\n  \"currentcolor\",\n  \"cursive\",\n  \"cyclic\",\n  \"darken\",\n  \"dashed\",\n  \"decimal\",\n  \"decimal-leading-zero\",\n  \"default\",\n  \"default-button\",\n  \"dense\",\n  \"destination-atop\",\n  \"destination-in\",\n  \"destination-out\",\n  \"destination-over\",\n  \"difference\",\n  \"disc\",\n  \"discard\",\n  \"disclosure-closed\",\n  \"disclosure-open\",\n  \"document\",\n  \"dot-dash\",\n  \"dot-dot-dash\",\n  \"dotted\",\n  \"double\",\n  \"down\",\n  \"e-resize\",\n  \"ease\",\n  \"ease-in\",\n  \"ease-in-out\",\n  \"ease-out\",\n  \"element\",\n  \"ellipse\",\n  \"ellipsis\",\n  \"embed\",\n  \"end\",\n  \"ethiopic-abegede-gez\",\n  \"ethiopic-halehame-aa-er\",\n  \"ethiopic-halehame-gez\",\n  \"ew-resize\",\n  \"exclusion\",\n  \"expanded\",\n  \"extends\",\n  \"extra-condensed\",\n  \"extra-expanded\",\n  \"fantasy\",\n  \"fast\",\n  \"fill\",\n  \"fill-box\",\n  \"fixed\",\n  \"flat\",\n  \"flex\",\n  \"flex-end\",\n  \"flex-start\",\n  \"footnotes\",\n  \"forwards\",\n  \"from\",\n  \"geometricPrecision\",\n  \"graytext\",\n  \"grid\",\n  \"groove\",\n  \"hand\",\n  \"hard-light\",\n  \"help\",\n  \"hidden\",\n  \"hide\",\n  \"higher\",\n  \"highlight\",\n  \"highlighttext\",\n  \"horizontal\",\n  \"hsl\",\n  \"hsla\",\n  \"hue\",\n  \"icon\",\n  \"ignore\",\n  \"inactiveborder\",\n  \"inactivecaption\",\n  \"inactivecaptiontext\",\n  \"infinite\",\n  \"infobackground\",\n  \"infotext\",\n  \"inherit\",\n  \"initial\",\n  \"inline\",\n  \"inline-axis\",\n  \"inline-block\",\n  \"inline-flex\",\n  \"inline-grid\",\n  \"inline-table\",\n  \"inset\",\n  \"inside\",\n  \"intrinsic\",\n  \"invert\",\n  \"italic\",\n  \"justify\",\n  \"keep-all\",\n  \"landscape\",\n  \"large\",\n  \"larger\",\n  \"left\",\n  \"level\",\n  \"lighter\",\n  \"lighten\",\n  \"line-through\",\n  \"linear\",\n  \"linear-gradient\",\n  \"lines\",\n  \"list-item\",\n  \"listbox\",\n  \"listitem\",\n  \"local\",\n  \"logical\",\n  \"loud\",\n  \"lower\",\n  \"lower-hexadecimal\",\n  \"lower-latin\",\n  \"lower-norwegian\",\n  \"lowercase\",\n  \"ltr\",\n  \"luminosity\",\n  \"manipulation\",\n  \"match\",\n  \"matrix\",\n  \"matrix3d\",\n  \"medium\",\n  \"menu\",\n  \"menutext\",\n  \"message-box\",\n  \"middle\",\n  \"min-intrinsic\",\n  \"mix\",\n  \"monospace\",\n  \"move\",\n  \"multiple\",\n  \"multiple_mask_images\",\n  \"multiply\",\n  \"n-resize\",\n  \"narrower\",\n  \"ne-resize\",\n  \"nesw-resize\",\n  \"no-close-quote\",\n  \"no-drop\",\n  \"no-open-quote\",\n  \"no-repeat\",\n  \"none\",\n  \"normal\",\n  \"not-allowed\",\n  \"nowrap\",\n  \"ns-resize\",\n  \"numbers\",\n  \"numeric\",\n  \"nw-resize\",\n  \"nwse-resize\",\n  \"oblique\",\n  \"opacity\",\n  \"open-quote\",\n  \"optimizeLegibility\",\n  \"optimizeSpeed\",\n  \"outset\",\n  \"outside\",\n  \"outside-shape\",\n  \"overlay\",\n  \"overline\",\n  \"padding\",\n  \"padding-box\",\n  \"painted\",\n  \"page\",\n  \"paused\",\n  \"perspective\",\n  \"pinch-zoom\",\n  \"plus-darker\",\n  \"plus-lighter\",\n  \"pointer\",\n  \"polygon\",\n  \"portrait\",\n  \"pre\",\n  \"pre-line\",\n  \"pre-wrap\",\n  \"preserve-3d\",\n  \"progress\",\n  \"push-button\",\n  \"radial-gradient\",\n  \"radio\",\n  \"read-only\",\n  \"read-write\",\n  \"read-write-plaintext-only\",\n  \"rectangle\",\n  \"region\",\n  \"relative\",\n  \"repeat\",\n  \"repeating-linear-gradient\",\n  \"repeating-radial-gradient\",\n  \"repeat-x\",\n  \"repeat-y\",\n  \"reset\",\n  \"reverse\",\n  \"rgb\",\n  \"rgba\",\n  \"ridge\",\n  \"right\",\n  \"rotate\",\n  \"rotate3d\",\n  \"rotateX\",\n  \"rotateY\",\n  \"rotateZ\",\n  \"round\",\n  \"row\",\n  \"row-resize\",\n  \"row-reverse\",\n  \"rtl\",\n  \"run-in\",\n  \"running\",\n  \"s-resize\",\n  \"sans-serif\",\n  \"saturation\",\n  \"scale\",\n  \"scale3d\",\n  \"scaleX\",\n  \"scaleY\",\n  \"scaleZ\",\n  \"screen\",\n  \"scroll\",\n  \"scrollbar\",\n  \"scroll-position\",\n  \"se-resize\",\n  \"self-start\",\n  \"self-end\",\n  \"semi-condensed\",\n  \"semi-expanded\",\n  \"separate\",\n  \"serif\",\n  \"show\",\n  \"single\",\n  \"skew\",\n  \"skewX\",\n  \"skewY\",\n  \"skip-white-space\",\n  \"slide\",\n  \"slider-horizontal\",\n  \"slider-vertical\",\n  \"sliderthumb-horizontal\",\n  \"sliderthumb-vertical\",\n  \"slow\",\n  \"small\",\n  \"small-caps\",\n  \"small-caption\",\n  \"smaller\",\n  \"soft-light\",\n  \"solid\",\n  \"source-atop\",\n  \"source-in\",\n  \"source-out\",\n  \"source-over\",\n  \"space\",\n  \"space-around\",\n  \"space-between\",\n  \"space-evenly\",\n  \"spell-out\",\n  \"square\",\n  \"start\",\n  \"static\",\n  \"status-bar\",\n  \"stretch\",\n  \"stroke\",\n  \"stroke-box\",\n  \"sub\",\n  \"subpixel-antialiased\",\n  \"svg_masks\",\n  \"super\",\n  \"sw-resize\",\n  \"symbolic\",\n  \"symbols\",\n  \"system-ui\",\n  \"table\",\n  \"table-caption\",\n  \"table-cell\",\n  \"table-column\",\n  \"table-column-group\",\n  \"table-footer-group\",\n  \"table-header-group\",\n  \"table-row\",\n  \"table-row-group\",\n  \"text\",\n  \"text-bottom\",\n  \"text-top\",\n  \"textarea\",\n  \"textfield\",\n  \"thick\",\n  \"thin\",\n  \"threeddarkshadow\",\n  \"threedface\",\n  \"threedhighlight\",\n  \"threedlightshadow\",\n  \"threedshadow\",\n  \"to\",\n  \"top\",\n  \"transform\",\n  \"translate\",\n  \"translate3d\",\n  \"translateX\",\n  \"translateY\",\n  \"translateZ\",\n  \"transparent\",\n  \"ultra-condensed\",\n  \"ultra-expanded\",\n  \"underline\",\n  \"unidirectional-pan\",\n  \"unset\",\n  \"up\",\n  \"upper-latin\",\n  \"uppercase\",\n  \"url\",\n  \"var\",\n  \"vertical\",\n  \"vertical-text\",\n  \"view-box\",\n  \"visible\",\n  \"visibleFill\",\n  \"visiblePainted\",\n  \"visibleStroke\",\n  \"visual\",\n  \"w-resize\",\n  \"wait\",\n  \"wave\",\n  \"wider\",\n  \"window\",\n  \"windowframe\",\n  \"windowtext\",\n  \"words\",\n  \"wrap\",\n  \"wrap-reverse\",\n  \"x-large\",\n  \"x-small\",\n  \"xor\",\n  \"xx-large\",\n  \"xx-small\"\n].map((t) => ({ type: \"keyword\", label: t })).concat(/* @__PURE__ */ [\n  \"aliceblue\",\n  \"antiquewhite\",\n  \"aqua\",\n  \"aquamarine\",\n  \"azure\",\n  \"beige\",\n  \"bisque\",\n  \"black\",\n  \"blanchedalmond\",\n  \"blue\",\n  \"blueviolet\",\n  \"brown\",\n  \"burlywood\",\n  \"cadetblue\",\n  \"chartreuse\",\n  \"chocolate\",\n  \"coral\",\n  \"cornflowerblue\",\n  \"cornsilk\",\n  \"crimson\",\n  \"cyan\",\n  \"darkblue\",\n  \"darkcyan\",\n  \"darkgoldenrod\",\n  \"darkgray\",\n  \"darkgreen\",\n  \"darkkhaki\",\n  \"darkmagenta\",\n  \"darkolivegreen\",\n  \"darkorange\",\n  \"darkorchid\",\n  \"darkred\",\n  \"darksalmon\",\n  \"darkseagreen\",\n  \"darkslateblue\",\n  \"darkslategray\",\n  \"darkturquoise\",\n  \"darkviolet\",\n  \"deeppink\",\n  \"deepskyblue\",\n  \"dimgray\",\n  \"dodgerblue\",\n  \"firebrick\",\n  \"floralwhite\",\n  \"forestgreen\",\n  \"fuchsia\",\n  \"gainsboro\",\n  \"ghostwhite\",\n  \"gold\",\n  \"goldenrod\",\n  \"gray\",\n  \"grey\",\n  \"green\",\n  \"greenyellow\",\n  \"honeydew\",\n  \"hotpink\",\n  \"indianred\",\n  \"indigo\",\n  \"ivory\",\n  \"khaki\",\n  \"lavender\",\n  \"lavenderblush\",\n  \"lawngreen\",\n  \"lemonchiffon\",\n  \"lightblue\",\n  \"lightcoral\",\n  \"lightcyan\",\n  \"lightgoldenrodyellow\",\n  \"lightgray\",\n  \"lightgreen\",\n  \"lightpink\",\n  \"lightsalmon\",\n  \"lightseagreen\",\n  \"lightskyblue\",\n  \"lightslategray\",\n  \"lightsteelblue\",\n  \"lightyellow\",\n  \"lime\",\n  \"limegreen\",\n  \"linen\",\n  \"magenta\",\n  \"maroon\",\n  \"mediumaquamarine\",\n  \"mediumblue\",\n  \"mediumorchid\",\n  \"mediumpurple\",\n  \"mediumseagreen\",\n  \"mediumslateblue\",\n  \"mediumspringgreen\",\n  \"mediumturquoise\",\n  \"mediumvioletred\",\n  \"midnightblue\",\n  \"mintcream\",\n  \"mistyrose\",\n  \"moccasin\",\n  \"navajowhite\",\n  \"navy\",\n  \"oldlace\",\n  \"olive\",\n  \"olivedrab\",\n  \"orange\",\n  \"orangered\",\n  \"orchid\",\n  \"palegoldenrod\",\n  \"palegreen\",\n  \"paleturquoise\",\n  \"palevioletred\",\n  \"papayawhip\",\n  \"peachpuff\",\n  \"peru\",\n  \"pink\",\n  \"plum\",\n  \"powderblue\",\n  \"purple\",\n  \"rebeccapurple\",\n  \"red\",\n  \"rosybrown\",\n  \"royalblue\",\n  \"saddlebrown\",\n  \"salmon\",\n  \"sandybrown\",\n  \"seagreen\",\n  \"seashell\",\n  \"sienna\",\n  \"silver\",\n  \"skyblue\",\n  \"slateblue\",\n  \"slategray\",\n  \"snow\",\n  \"springgreen\",\n  \"steelblue\",\n  \"tan\",\n  \"teal\",\n  \"thistle\",\n  \"tomato\",\n  \"turquoise\",\n  \"violet\",\n  \"wheat\",\n  \"white\",\n  \"whitesmoke\",\n  \"yellow\",\n  \"yellowgreen\"\n].map((t) => ({ type: \"constant\", label: t }))), IV = /* @__PURE__ */ [\n  \"a\",\n  \"abbr\",\n  \"address\",\n  \"article\",\n  \"aside\",\n  \"b\",\n  \"bdi\",\n  \"bdo\",\n  \"blockquote\",\n  \"body\",\n  \"br\",\n  \"button\",\n  \"canvas\",\n  \"caption\",\n  \"cite\",\n  \"code\",\n  \"col\",\n  \"colgroup\",\n  \"dd\",\n  \"del\",\n  \"details\",\n  \"dfn\",\n  \"dialog\",\n  \"div\",\n  \"dl\",\n  \"dt\",\n  \"em\",\n  \"figcaption\",\n  \"figure\",\n  \"footer\",\n  \"form\",\n  \"header\",\n  \"hgroup\",\n  \"h1\",\n  \"h2\",\n  \"h3\",\n  \"h4\",\n  \"h5\",\n  \"h6\",\n  \"hr\",\n  \"html\",\n  \"i\",\n  \"iframe\",\n  \"img\",\n  \"input\",\n  \"ins\",\n  \"kbd\",\n  \"label\",\n  \"legend\",\n  \"li\",\n  \"main\",\n  \"meter\",\n  \"nav\",\n  \"ol\",\n  \"output\",\n  \"p\",\n  \"pre\",\n  \"ruby\",\n  \"section\",\n  \"select\",\n  \"small\",\n  \"source\",\n  \"span\",\n  \"strong\",\n  \"sub\",\n  \"summary\",\n  \"sup\",\n  \"table\",\n  \"tbody\",\n  \"td\",\n  \"template\",\n  \"textarea\",\n  \"tfoot\",\n  \"th\",\n  \"thead\",\n  \"tr\",\n  \"u\",\n  \"ul\"\n].map((t) => ({ type: \"type\", label: t })), xi = /^(\\w[\\w-]*|-\\w[\\w-]*|)$/, WV = /^-(-[\\w-]*)?$/;\nfunction MV(t, e) {\n  var n;\n  if ((t.name == \"(\" || t.type.isError) && (t = t.parent || t), t.name != \"ArgList\")\n    return !1;\n  let r = (n = t.parent) === null || n === void 0 ? void 0 : n.firstChild;\n  return (r == null ? void 0 : r.name) != \"Callee\" ? !1 : e.sliceString(r.from, r.to) == \"var\";\n}\nconst f0 = /* @__PURE__ */ new ex(), XV = [\"Declaration\"];\nfunction jV(t) {\n  for (let e = t; ; ) {\n    if (e.type.isTop)\n      return e;\n    if (!(e = e.parent))\n      return t;\n  }\n}\nfunction Vx(t, e, n) {\n  if (e.to - e.from > 4096) {\n    let r = f0.get(e);\n    if (r)\n      return r;\n    let i = [], s = /* @__PURE__ */ new Set(), o = e.cursor(lt.IncludeAnonymous);\n    if (o.firstChild())\n      do\n        for (let a of Vx(t, o.node, n))\n          s.has(a.label) || (s.add(a.label), i.push(a));\n      while (o.nextSibling());\n    return f0.set(e, i), i;\n  } else {\n    let r = [], i = /* @__PURE__ */ new Set();\n    return e.cursor().iterate((s) => {\n      var o;\n      if (n(s) && s.matchContext(XV) && ((o = s.node.nextSibling) === null || o === void 0 ? void 0 : o.name) == \":\") {\n        let a = t.sliceString(s.from, s.to);\n        i.has(a) || (i.add(a), r.push({ label: a, type: \"variable\" }));\n      }\n    }), r;\n  }\n}\nconst BV = (t) => (e) => {\n  let { state: n, pos: r } = e, i = un(n).resolveInner(r, -1), s = i.type.isError && i.from == i.to - 1 && n.doc.sliceString(i.from, i.to) == \"-\";\n  if (i.name == \"PropertyName\" || (s || i.name == \"TagName\") && /^(Block|Styles)$/.test(i.resolve(i.to).name))\n    return { from: i.from, options: Uf(), validFor: xi };\n  if (i.name == \"ValueName\")\n    return { from: i.from, options: d0, validFor: xi };\n  if (i.name == \"PseudoClassName\")\n    return { from: i.from, options: u0, validFor: xi };\n  if (t(i) || (e.explicit || s) && MV(i, n.doc))\n    return {\n      from: t(i) || s ? i.from : r,\n      options: Vx(n.doc, jV(i), t),\n      validFor: WV\n    };\n  if (i.name == \"TagName\") {\n    for (let { parent: l } = i; l; l = l.parent)\n      if (l.name == \"Block\")\n        return { from: i.from, options: Uf(), validFor: xi };\n    return { from: i.from, options: IV, validFor: xi };\n  }\n  if (!e.explicit)\n    return null;\n  let o = i.resolve(r), a = o.childBefore(r);\n  return a && a.name == \":\" && o.name == \"PseudoClassSelector\" ? { from: r, options: u0, validFor: xi } : a && a.name == \":\" && o.name == \"Declaration\" || o.name == \"ArgList\" ? { from: r, options: d0, validFor: xi } : o.name == \"Block\" || o.name == \"Styles\" ? { from: r, options: Uf(), validFor: xi } : null;\n}, LV = /* @__PURE__ */ BV((t) => t.name == \"VariableName\"), Fu = /* @__PURE__ */ cs.define({\n  name: \"css\",\n  parser: /* @__PURE__ */ VV.configure({\n    props: [\n      /* @__PURE__ */ sa.add({\n        Declaration: /* @__PURE__ */ $o()\n      }),\n      /* @__PURE__ */ Kl.add({\n        \"Block KeyframeList\": Hd\n      })\n    ]\n  }),\n  languageData: {\n    commentTokens: { block: { open: \"/*\", close: \"*/\" } },\n    indentOnInput: /^\\s*\\}$/,\n    wordChars: \"-\"\n  }\n});\nfunction Ix() {\n  return new Gl(Fu, Fu.data.of({ autocomplete: LV }));\n}\nconst UV = 54, qV = 1, YV = 55, zV = 2, HV = 56, FV = 3, h0 = 4, GV = 5, Gu = 6, Wx = 7, Mx = 8, Xx = 9, jx = 10, KV = 11, JV = 12, e3 = 13, qf = 57, t3 = 14, p0 = 58, Bx = 20, n3 = 22, Lx = 23, r3 = 24, $p = 26, Ux = 27, i3 = 28, s3 = 31, o3 = 34, a3 = 36, l3 = 37, c3 = 0, u3 = 1, d3 = {\n  area: !0,\n  base: !0,\n  br: !0,\n  col: !0,\n  command: !0,\n  embed: !0,\n  frame: !0,\n  hr: !0,\n  img: !0,\n  input: !0,\n  keygen: !0,\n  link: !0,\n  meta: !0,\n  param: !0,\n  source: !0,\n  track: !0,\n  wbr: !0,\n  menuitem: !0\n}, f3 = {\n  dd: !0,\n  li: !0,\n  optgroup: !0,\n  option: !0,\n  p: !0,\n  rp: !0,\n  rt: !0,\n  tbody: !0,\n  td: !0,\n  tfoot: !0,\n  th: !0,\n  tr: !0\n}, O0 = {\n  dd: { dd: !0, dt: !0 },\n  dt: { dd: !0, dt: !0 },\n  li: { li: !0 },\n  option: { option: !0, optgroup: !0 },\n  optgroup: { optgroup: !0 },\n  p: {\n    address: !0,\n    article: !0,\n    aside: !0,\n    blockquote: !0,\n    dir: !0,\n    div: !0,\n    dl: !0,\n    fieldset: !0,\n    footer: !0,\n    form: !0,\n    h1: !0,\n    h2: !0,\n    h3: !0,\n    h4: !0,\n    h5: !0,\n    h6: !0,\n    header: !0,\n    hgroup: !0,\n    hr: !0,\n    menu: !0,\n    nav: !0,\n    ol: !0,\n    p: !0,\n    pre: !0,\n    section: !0,\n    table: !0,\n    ul: !0\n  },\n  rp: { rp: !0, rt: !0 },\n  rt: { rp: !0, rt: !0 },\n  tbody: { tbody: !0, tfoot: !0 },\n  td: { td: !0, th: !0 },\n  tfoot: { tbody: !0 },\n  th: { td: !0, th: !0 },\n  thead: { tbody: !0, tfoot: !0 },\n  tr: { tr: !0 }\n};\nfunction h3(t) {\n  return t == 45 || t == 46 || t == 58 || t >= 65 && t <= 90 || t == 95 || t >= 97 && t <= 122 || t >= 161;\n}\nfunction qx(t) {\n  return t == 9 || t == 10 || t == 13 || t == 32;\n}\nlet g0 = null, m0 = null, b0 = 0;\nfunction Qp(t, e) {\n  let n = t.pos + e;\n  if (b0 == n && m0 == t)\n    return g0;\n  let r = t.peek(e);\n  for (; qx(r); )\n    r = t.peek(++e);\n  let i = \"\";\n  for (; h3(r); )\n    i += String.fromCharCode(r), r = t.peek(++e);\n  return m0 = t, b0 = n, g0 = i ? i.toLowerCase() : r == p3 || r == O3 ? void 0 : null;\n}\nconst Yx = 60, Ku = 62, kg = 47, p3 = 63, O3 = 33, g3 = 45;\nfunction v0(t, e) {\n  this.name = t, this.parent = e, this.hash = e ? e.hash : 0;\n  for (let n = 0; n < t.length; n++)\n    this.hash += (this.hash << 4) + t.charCodeAt(n) + (t.charCodeAt(n) << 8);\n}\nconst m3 = [Gu, jx, Wx, Mx, Xx], b3 = new wg({\n  start: null,\n  shift(t, e, n, r) {\n    return m3.indexOf(e) > -1 ? new v0(Qp(r, 1) || \"\", t) : t;\n  },\n  reduce(t, e) {\n    return e == Bx && t ? t.parent : t;\n  },\n  reuse(t, e, n, r) {\n    let i = e.type.id;\n    return i == Gu || i == a3 ? new v0(Qp(r, 1) || \"\", t) : t;\n  },\n  hash(t) {\n    return t ? t.hash : 0;\n  },\n  strict: !1\n}), v3 = new gn((t, e) => {\n  if (t.next != Yx) {\n    t.next < 0 && e.context && t.acceptToken(qf);\n    return;\n  }\n  t.advance();\n  let n = t.next == kg;\n  n && t.advance();\n  let r = Qp(t, 0);\n  if (r === void 0)\n    return;\n  if (!r)\n    return t.acceptToken(n ? t3 : Gu);\n  let i = e.context ? e.context.name : null;\n  if (n) {\n    if (r == i)\n      return t.acceptToken(KV);\n    if (i && f3[i])\n      return t.acceptToken(qf, -2);\n    if (e.dialectEnabled(c3))\n      return t.acceptToken(JV);\n    for (let s = e.context; s; s = s.parent)\n      if (s.name == r)\n        return;\n    t.acceptToken(e3);\n  } else {\n    if (r == \"script\")\n      return t.acceptToken(Wx);\n    if (r == \"style\")\n      return t.acceptToken(Mx);\n    if (r == \"textarea\")\n      return t.acceptToken(Xx);\n    if (d3.hasOwnProperty(r))\n      return t.acceptToken(jx);\n    i && O0[i] && O0[i][r] ? t.acceptToken(qf, -1) : t.acceptToken(Gu);\n  }\n}, { contextual: !0 }), y3 = new gn((t) => {\n  for (let e = 0, n = 0; ; n++) {\n    if (t.next < 0) {\n      n && t.acceptToken(p0);\n      break;\n    }\n    if (t.next == g3)\n      e++;\n    else if (t.next == Ku && e >= 2) {\n      n >= 3 && t.acceptToken(p0, -2);\n      break;\n    } else\n      e = 0;\n    t.advance();\n  }\n});\nfunction S3(t) {\n  for (; t; t = t.parent)\n    if (t.name == \"svg\" || t.name == \"math\")\n      return !0;\n  return !1;\n}\nconst w3 = new gn((t, e) => {\n  if (t.next == kg && t.peek(1) == Ku) {\n    let n = e.dialectEnabled(u3) || S3(e.context);\n    t.acceptToken(n ? GV : h0, 2);\n  } else\n    t.next == Ku && t.acceptToken(h0, 1);\n});\nfunction xg(t, e, n) {\n  let r = 2 + t.length;\n  return new gn((i) => {\n    for (let s = 0, o = 0, a = 0; ; a++) {\n      if (i.next < 0) {\n        a && i.acceptToken(e);\n        break;\n      }\n      if (s == 0 && i.next == Yx || s == 1 && i.next == kg || s >= 2 && s < r && i.next == t.charCodeAt(s - 2))\n        s++, o++;\n      else if ((s == 2 || s == r) && qx(i.next))\n        o++;\n      else if (s == r && i.next == Ku) {\n        a > o ? i.acceptToken(e, -o) : i.acceptToken(n, -(o - 2));\n        break;\n      } else if ((i.next == 10 || i.next == 13) && a) {\n        i.acceptToken(e, 1);\n        break;\n      } else\n        s = o = 0;\n      i.advance();\n    }\n  });\n}\nconst k3 = xg(\"script\", UV, qV), x3 = xg(\"style\", YV, zV), P3 = xg(\"textarea\", HV, FV), _3 = ia({\n  \"Text RawText\": P.content,\n  \"StartTag StartCloseTag SelfClosingEndTag EndTag\": P.angleBracket,\n  TagName: P.tagName,\n  \"MismatchedCloseTag/TagName\": [P.tagName, P.invalid],\n  AttributeName: P.attributeName,\n  \"AttributeValue UnquotedAttributeValue\": P.attributeValue,\n  Is: P.definitionOperator,\n  \"EntityReference CharacterReference\": P.character,\n  Comment: P.blockComment,\n  ProcessingInst: P.processingInstruction,\n  DoctypeDecl: P.documentMeta\n}), T3 = us.deserialize({\n  version: 14,\n  states: \",xOVO!rOOO!WQ#tO'#CqO!]Q#tO'#CzO!bQ#tO'#C}O!gQ#tO'#DQO!lQ#tO'#DSO!qOaO'#CpO!|ObO'#CpO#XOdO'#CpO$eO!rO'#CpOOO`'#Cp'#CpO$lO$fO'#DTO$tQ#tO'#DVO$yQ#tO'#DWOOO`'#Dk'#DkOOO`'#DY'#DYQVO!rOOO%OQ&rO,59]O%ZQ&rO,59fO%fQ&rO,59iO%qQ&rO,59lO%|Q&rO,59nOOOa'#D^'#D^O&XOaO'#CxO&dOaO,59[OOOb'#D_'#D_O&lObO'#C{O&wObO,59[OOOd'#D`'#D`O'POdO'#DOO'[OdO,59[OOO`'#Da'#DaO'dO!rO,59[O'kQ#tO'#DROOO`,59[,59[OOOp'#Db'#DbO'pO$fO,59oOOO`,59o,59oO'xQ#|O,59qO'}Q#|O,59rOOO`-E7W-E7WO(SQ&rO'#CsOOQW'#DZ'#DZO(bQ&rO1G.wOOOa1G.w1G.wOOO`1G/Y1G/YO(mQ&rO1G/QOOOb1G/Q1G/QO(xQ&rO1G/TOOOd1G/T1G/TO)TQ&rO1G/WOOO`1G/W1G/WO)`Q&rO1G/YOOOa-E7[-E7[O)kQ#tO'#CyOOO`1G.v1G.vOOOb-E7]-E7]O)pQ#tO'#C|OOOd-E7^-E7^O)uQ#tO'#DPOOO`-E7_-E7_O)zQ#|O,59mOOOp-E7`-E7`OOO`1G/Z1G/ZOOO`1G/]1G/]OOO`1G/^1G/^O*PQ,UO,59_OOQW-E7X-E7XOOOa7+$c7+$cOOO`7+$t7+$tOOOb7+$l7+$lOOOd7+$o7+$oOOO`7+$r7+$rO*[Q#|O,59eO*aQ#|O,59hO*fQ#|O,59kOOO`1G/X1G/XO*kO7[O'#CvO*|OMhO'#CvOOQW1G.y1G.yOOO`1G/P1G/POOO`1G/S1G/SOOO`1G/V1G/VOOOO'#D['#D[O+_O7[O,59bOOQW,59b,59bOOOO'#D]'#D]O+pOMhO,59bOOOO-E7Y-E7YOOQW1G.|1G.|OOOO-E7Z-E7Z\",\n  stateData: \",]~O!^OS~OUSOVPOWQOXROYTO[]O][O^^O`^Oa^Ob^Oc^Ox^O{_O!dZO~OfaO~OfbO~OfcO~OfdO~OfeO~O!WfOPlP!ZlP~O!XiOQoP!ZoP~O!YlORrP!ZrP~OUSOVPOWQOXROYTOZqO[]O][O^^O`^Oa^Ob^Oc^Ox^O!dZO~O!ZrO~P#dO![sO!euO~OfvO~OfwO~OS|OT}OhyO~OS!POT}OhyO~OS!ROT}OhyO~OS!TOT}OhyO~OS}OT}OhyO~O!WfOPlX!ZlX~OP!WO!Z!XO~O!XiOQoX!ZoX~OQ!ZO!Z!XO~O!YlORrX!ZrX~OR!]O!Z!XO~O!Z!XO~P#dOf!_O~O![sO!e!aO~OS!bO~OS!cO~Oi!dOSgXTgXhgX~OS!fOT!gOhyO~OS!hOT!gOhyO~OS!iOT!gOhyO~OS!jOT!gOhyO~OS!gOT!gOhyO~Of!kO~Of!lO~Of!mO~OS!nO~Ok!qO!`!oO!b!pO~OS!rO~OS!sO~OS!tO~Oa!uOb!uOc!uO!`!wO!a!uO~Oa!xOb!xOc!xO!b!wO!c!xO~Oa!uOb!uOc!uO!`!{O!a!uO~Oa!xOb!xOc!xO!b!{O!c!xO~OT~bac!dx{!d~\",\n  goto: \"%p!`PPPPPPPPPPPPPPPPPPPP!a!gP!mPP!yP!|#P#S#Y#]#`#f#i#l#r#x!aP!a!aP$O$U$l$r$x%O%U%[%bPPPPPPPP%hX^OX`pXUOX`pezabcde{!O!Q!S!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ!ObQ!QcQ!SdQ!UeZ!e{!O!Q!S!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp\",\n  nodeNames: \" StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl\",\n  maxTerm: 67,\n  context: b3,\n  nodeProps: [\n    [\"closedBy\", -10, 1, 2, 3, 7, 8, 9, 10, 11, 12, 13, \"EndTag\", 6, \"EndTag SelfClosingEndTag\", -4, 21, 30, 33, 36, \"CloseTag\"],\n    [\"openedBy\", 4, \"StartTag StartCloseTag\", 5, \"StartTag\", -4, 29, 32, 35, 37, \"OpenTag\"],\n    [\"group\", -9, 14, 17, 18, 19, 20, 39, 40, 41, 42, \"Entity\", 16, \"Entity TextContent\", -3, 28, 31, 34, \"TextContent Entity\"],\n    [\"isolate\", -11, 21, 29, 30, 32, 33, 35, 36, 37, 38, 41, 42, \"ltr\", -3, 26, 27, 39, \"\"]\n  ],\n  propSources: [_3],\n  skippedNodes: [0],\n  repeatNodeCount: 9,\n  tokenData: \"!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|c`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bX`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UV`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pT`POv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!cpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({W`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!a`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!a`!cpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYkWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]``P!a`!cp!^^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebhSkWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXhSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vchS`P!a`!cpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!`h`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WihSkWc!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zbkWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOa!R!R7tP;=`<%l7S!Z8OYkWa!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{ihSkWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbhSkWa!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QchSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXhSa!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TakWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOb!R!RAwP;=`<%lAY!ZBRYkWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbhSkWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbhSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXhSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!bx`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYlhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_khS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_X`P!a`!cp!eQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZhSfQ`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!a`!cpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!a`!cp!dPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!a`!cpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!a`!cpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!a`!cpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!a`!cpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!a`!cpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!a`!cpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!a`!cpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!cpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO{PP!-nP;=`<%l!-Sq!-xS!cp{POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!a`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!a`{POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!a`!cp{POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!a`!cpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!a`!cpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!a`!cpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!a`!cpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!a`!cpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!a`!cpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!cpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOxPP!7TP;=`<%l!6Vq!7]V!cpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!cpxPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!a`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!a`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!a`xPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!a`!cpxPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXiS`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X\",\n  tokenizers: [k3, x3, P3, w3, v3, y3, 0, 1, 2, 3, 4, 5],\n  topRules: { Document: [0, 15] },\n  dialects: { noMatch: 0, selfClosing: 509 },\n  tokenPrec: 511\n});\nfunction zx(t, e) {\n  let n = /* @__PURE__ */ Object.create(null);\n  for (let r of t.getChildren(Lx)) {\n    let i = r.getChild(r3), s = r.getChild($p) || r.getChild(Ux);\n    i && (n[e.read(i.from, i.to)] = s ? s.type.id == $p ? e.read(s.from + 1, s.to - 1) : e.read(s.from, s.to) : \"\");\n  }\n  return n;\n}\nfunction y0(t, e) {\n  let n = t.getChild(n3);\n  return n ? e.read(n.from, n.to) : \" \";\n}\nfunction Yf(t, e, n) {\n  let r;\n  for (let i of n)\n    if (!i.attrs || i.attrs(r || (r = zx(t.node.parent.firstChild, e))))\n      return { parser: i.parser };\n  return null;\n}\nfunction Hx(t = [], e = []) {\n  let n = [], r = [], i = [], s = [];\n  for (let a of t)\n    (a.tag == \"script\" ? n : a.tag == \"style\" ? r : a.tag == \"textarea\" ? i : s).push(a);\n  let o = e.length ? /* @__PURE__ */ Object.create(null) : null;\n  for (let a of e)\n    (o[a.name] || (o[a.name] = [])).push(a);\n  return PD((a, l) => {\n    let c = a.type.id;\n    if (c == i3)\n      return Yf(a, l, n);\n    if (c == s3)\n      return Yf(a, l, r);\n    if (c == o3)\n      return Yf(a, l, i);\n    if (c == Bx && s.length) {\n      let u = a.node, d = u.firstChild, f = d && y0(d, l), h;\n      if (f) {\n        for (let p of s)\n          if (p.tag == f && (!p.attrs || p.attrs(h || (h = zx(u, l))))) {\n            let O = u.lastChild, m = O.type.id == l3 ? O.from : u.to;\n            if (m > d.to)\n              return { parser: p.parser, overlay: [{ from: d.to, to: m }] };\n          }\n      }\n    }\n    if (o && c == Lx) {\n      let u = a.node, d;\n      if (d = u.firstChild) {\n        let f = o[l.read(d.from, d.to)];\n        if (f)\n          for (let h of f) {\n            if (h.tagName && h.tagName != y0(u.parent, l))\n              continue;\n            let p = u.lastChild;\n            if (p.type.id == $p) {\n              let O = p.from + 1, m = p.lastChild, y = p.to - (m && m.isError ? 0 : 1);\n              if (y > O)\n                return { parser: h.parser, overlay: [{ from: O, to: y }] };\n            } else if (p.type.id == Ux)\n              return { parser: h.parser, overlay: [{ from: p.from, to: p.to }] };\n          }\n      }\n    }\n    return null;\n  });\n}\nconst E3 = 309, S0 = 1, $3 = 2, Q3 = 3, C3 = 310, A3 = 312, R3 = 313, N3 = 4, D3 = 5, Z3 = 0, Cp = [\n  9,\n  10,\n  11,\n  12,\n  13,\n  32,\n  133,\n  160,\n  5760,\n  8192,\n  8193,\n  8194,\n  8195,\n  8196,\n  8197,\n  8198,\n  8199,\n  8200,\n  8201,\n  8202,\n  8232,\n  8233,\n  8239,\n  8287,\n  12288\n], Fx = 125, V3 = 59, Ap = 47, I3 = 42, W3 = 43, M3 = 45, X3 = 60, j3 = 44, B3 = new wg({\n  start: !1,\n  shift(t, e) {\n    return e == N3 || e == D3 || e == A3 ? t : e == R3;\n  },\n  strict: !1\n}), L3 = new gn((t, e) => {\n  let { next: n } = t;\n  (n == Fx || n == -1 || e.context) && t.acceptToken(C3);\n}, { contextual: !0, fallback: !0 }), U3 = new gn((t, e) => {\n  let { next: n } = t, r;\n  Cp.indexOf(n) > -1 || n == Ap && ((r = t.peek(1)) == Ap || r == I3) || n != Fx && n != V3 && n != -1 && !e.context && t.acceptToken(E3);\n}, { contextual: !0 }), q3 = new gn((t, e) => {\n  let { next: n } = t;\n  if ((n == W3 || n == M3) && (t.advance(), n == t.next)) {\n    t.advance();\n    let r = !e.context && e.canShift(S0);\n    t.acceptToken(r ? S0 : $3);\n  }\n}, { contextual: !0 });\nfunction zf(t, e) {\n  return t >= 65 && t <= 90 || t >= 97 && t <= 122 || t == 95 || t >= 192 || !e && t >= 48 && t <= 57;\n}\nconst Y3 = new gn((t, e) => {\n  if (t.next != X3 || !e.dialectEnabled(Z3) || (t.advance(), t.next == Ap))\n    return;\n  let n = 0;\n  for (; Cp.indexOf(t.next) > -1; )\n    t.advance(), n++;\n  if (zf(t.next, !0)) {\n    for (t.advance(), n++; zf(t.next, !1); )\n      t.advance(), n++;\n    for (; Cp.indexOf(t.next) > -1; )\n      t.advance(), n++;\n    if (t.next == j3)\n      return;\n    for (let r = 0; ; r++) {\n      if (r == 7) {\n        if (!zf(t.next, !0))\n          return;\n        break;\n      }\n      if (t.next != \"extends\".charCodeAt(r))\n        break;\n      t.advance(), n++;\n    }\n  }\n  t.acceptToken(Q3, -n);\n}), z3 = ia({\n  \"get set async static\": P.modifier,\n  \"for while do if else switch try catch finally return throw break continue default case\": P.controlKeyword,\n  \"in of await yield void typeof delete instanceof\": P.operatorKeyword,\n  \"let var const using function class extends\": P.definitionKeyword,\n  \"import export from\": P.moduleKeyword,\n  \"with debugger as new\": P.keyword,\n  TemplateString: P.special(P.string),\n  super: P.atom,\n  BooleanLiteral: P.bool,\n  this: P.self,\n  null: P.null,\n  Star: P.modifier,\n  VariableName: P.variableName,\n  \"CallExpression/VariableName TaggedTemplateExpression/VariableName\": P.function(P.variableName),\n  VariableDefinition: P.definition(P.variableName),\n  Label: P.labelName,\n  PropertyName: P.propertyName,\n  PrivatePropertyName: P.special(P.propertyName),\n  \"CallExpression/MemberExpression/PropertyName\": P.function(P.propertyName),\n  \"FunctionDeclaration/VariableDefinition\": P.function(P.definition(P.variableName)),\n  \"ClassDeclaration/VariableDefinition\": P.definition(P.className),\n  PropertyDefinition: P.definition(P.propertyName),\n  PrivatePropertyDefinition: P.definition(P.special(P.propertyName)),\n  UpdateOp: P.updateOperator,\n  \"LineComment Hashbang\": P.lineComment,\n  BlockComment: P.blockComment,\n  Number: P.number,\n  String: P.string,\n  Escape: P.escape,\n  ArithOp: P.arithmeticOperator,\n  LogicOp: P.logicOperator,\n  BitOp: P.bitwiseOperator,\n  CompareOp: P.compareOperator,\n  RegExp: P.regexp,\n  Equals: P.definitionOperator,\n  Arrow: P.function(P.punctuation),\n  \": Spread\": P.punctuation,\n  \"( )\": P.paren,\n  \"[ ]\": P.squareBracket,\n  \"{ }\": P.brace,\n  \"InterpolationStart InterpolationEnd\": P.special(P.brace),\n  \".\": P.derefOperator,\n  \", ;\": P.separator,\n  \"@\": P.meta,\n  TypeName: P.typeName,\n  TypeDefinition: P.definition(P.typeName),\n  \"type enum interface implements namespace module declare\": P.definitionKeyword,\n  \"abstract global Privacy readonly override\": P.modifier,\n  \"is keyof unique infer\": P.operatorKeyword,\n  JSXAttributeValue: P.attributeValue,\n  JSXText: P.content,\n  \"JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag\": P.angleBracket,\n  \"JSXIdentifier JSXNameSpacedName\": P.tagName,\n  \"JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName\": P.attributeName,\n  \"JSXBuiltin/JSXIdentifier\": P.standard(P.tagName)\n}), H3 = { __proto__: null, export: 18, as: 23, from: 31, default: 34, async: 39, function: 40, extends: 52, this: 56, true: 64, false: 64, null: 76, void: 80, typeof: 84, super: 102, new: 136, delete: 152, yield: 161, await: 165, class: 170, public: 227, private: 227, protected: 227, readonly: 229, instanceof: 248, satisfies: 251, in: 252, const: 254, import: 286, keyof: 339, unique: 343, infer: 349, is: 385, abstract: 405, implements: 407, type: 409, let: 412, var: 414, using: 417, interface: 423, enum: 427, namespace: 433, module: 435, declare: 439, global: 443, for: 462, of: 471, while: 474, with: 478, do: 482, if: 486, else: 488, switch: 492, case: 498, try: 504, catch: 508, finally: 512, return: 516, throw: 520, break: 524, continue: 528, debugger: 532 }, F3 = { __proto__: null, async: 123, get: 125, set: 127, declare: 187, public: 189, private: 189, protected: 189, static: 191, abstract: 193, override: 195, readonly: 201, accessor: 203, new: 389 }, G3 = { __proto__: null, \"<\": 143 }, K3 = us.deserialize({\n  version: 14,\n  states: \"$<UO%TQ^OOO%[Q^OOO'_Q`OOP(lOWOOO*zQ08SO'#ChO+RO!bO'#CiO+aO#tO'#CiO+oO?MpO'#D^O.QQ^O'#DdO.bQ^O'#DoO%[Q^O'#DyO0fQ^O'#EROOQ07b'#EZ'#EZO1PQWO'#EWOOQO'#El'#ElOOQO'#Ie'#IeO1XQWO'#GmO1dQWO'#EkO1iQWO'#EkO3kQ08SO'#JiO6[Q08SO'#JjO6xQWO'#FZO6}Q&jO'#FqOOQ07b'#Fc'#FcO7YO,YO'#FcO7hQ7[O'#FxO9UQWO'#FwOOQ07b'#Jj'#JjOOQ07`'#Ji'#JiO9ZQWO'#GqOOQU'#KU'#KUO9fQWO'#IRO9kQ07hO'#ISOOQU'#JW'#JWOOQU'#IW'#IWQ`Q^OOO`Q^OOO%[Q^O'#DqO9sQ^O'#D}O9zQ^O'#EPO9aQWO'#GmO:RQ7[O'#CnO:aQWO'#EjO:lQWO'#EuO:qQ7[O'#FbO;`QWO'#GmOOQO'#KV'#KVO;eQWO'#KVO;sQWO'#GuO;sQWO'#GvO;sQWO'#GxO9aQWO'#G{O<jQWO'#HOO>RQWO'#CdO>cQWO'#H[O>kQWO'#HbO>kQWO'#HdO`Q^O'#HfO>kQWO'#HhO>kQWO'#HkO>pQWO'#HqO>uQ07iO'#HwO%[Q^O'#HyO?QQ07iO'#H{O?]Q07iO'#H}O9kQ07hO'#IPO?hQ08SO'#ChO@jQ`O'#DiQOQWOOO%[Q^O'#EPOAQQWO'#ESO:RQ7[O'#EjOA]QWO'#EjOAhQpO'#FbOOQU'#Cf'#CfOOQ07`'#Dn'#DnOOQ07`'#Jm'#JmO%[Q^O'#JmOOQO'#Jq'#JqOOQO'#Ib'#IbOBhQ`O'#EcOOQ07`'#Eb'#EbOCdQ07pO'#EcOCnQ`O'#EVOOQO'#Jp'#JpODSQ`O'#JqOEaQ`O'#EVOCnQ`O'#EcPEnO!0LbO'#CaPOOO)CDu)CDuOOOO'#IX'#IXOEyO!bO,59TOOQ07b,59T,59TOOOO'#IY'#IYOFXO#tO,59TO%[Q^O'#D`OOOO'#I['#I[OFgO?MpO,59xOOQ07b,59x,59xOFuQ^O'#I]OGYQWO'#JkOI[QrO'#JkO+}Q^O'#JkOIcQWO,5:OOIyQWO'#ElOJWQWO'#JyOJcQWO'#JxOJcQWO'#JxOJkQWO,5;YOJpQWO'#JwOOQ07f,5:Z,5:ZOJwQ^O,5:ZOLxQ08SO,5:eOMiQWO,5:mONSQ07hO'#JvONZQWO'#JuO9ZQWO'#JuONoQWO'#JuONwQWO,5;XON|QWO'#JuO!#UQrO'#JjOOQ07b'#Ch'#ChO%[Q^O'#ERO!#tQpO,5:rOOQO'#Jr'#JrOOQO-E<c-E<cO9aQWO,5=XO!$[QWO,5=XO!$aQ^O,5;VO!&dQ7[O'#EgO!'}QWO,5;VO!)mQ7[O'#DsO!)tQ^O'#DxO!*OQ`O,5;`O!*WQ`O,5;`O%[Q^O,5;`OOQU'#FR'#FROOQU'#FT'#FTO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aO%[Q^O,5;aOOQU'#FX'#FXO!*fQ^O,5;rOOQ07b,5;w,5;wOOQ07b,5;x,5;xO!,iQWO,5;xOOQ07b,5;y,5;yO%[Q^O'#IiO!,qQ07hO,5<eO!&dQ7[O,5;aO!-`Q7[O,5;aO%[Q^O,5;uO!-gQ&jO'#FgO!.dQ&jO'#J}O!.OQ&jO'#J}O!.kQ&jO'#J}OOQO'#J}'#J}O!/PQ&jO,5<POOOS,5<],5<]O!/bQ^O'#FsOOOS'#Ih'#IhO7YO,YO,5;}O!/iQ&jO'#FuOOQ07b,5;},5;}O!0YQMhO'#CuOOQ07b'#Cy'#CyO!0mQWO'#CyO!0rO?MpO'#C}O!1`Q7[O,5<bO!1gQWO,5<dO!3SQ!LQO'#GSO!3aQWO'#GTO!3fQWO'#GTO!3kQ!LQO'#GXO!4jQ`O'#G]OOQO'#Gh'#GhO!(SQ7[O'#GgOOQO'#Gj'#GjO!(SQ7[O'#GiO!5]QMhO'#JdOOQ07b'#Jd'#JdO!5gQWO'#JcO!5uQWO'#JbO!5}QWO'#CtOOQ07b'#Cw'#CwOOQ07b'#DR'#DROOQ07b'#DT'#DTO1SQWO'#DVO!(SQ7[O'#FzO!(SQ7[O'#F|O!6VQWO'#GOO!6[QWO'#GPO!3fQWO'#GVO!(SQ7[O'#G[O!6aQWO'#EmO!7OQWO,5<cOOQ07`'#Cq'#CqO!7WQWO'#EnO!8QQ`O'#EoOOQ07`'#Jw'#JwO!8XQ07hO'#KWO9kQ07hO,5=]O`Q^O,5>mOOQU'#J`'#J`OOQU,5>n,5>nOOQU-E<U-E<UO!:ZQ08SO,5:]O!<wQ08SO,5:iO%[Q^O,5:iO!?bQ08SO,5:kOOQO,5@q,5@qO!@RQ7[O,5=XO!@aQ07hO'#JaO9UQWO'#JaO!@rQ07hO,59YO!@}Q`O,59YO!AVQ7[O,59YO:RQ7[O,59YO!AbQWO,5;VO!AjQWO'#HZO!BOQWO'#KZO%[Q^O,5;zO!7{Q`O,5;|O!BWQWO,5=tO!B]QWO,5=tO!BbQWO,5=tO9kQ07hO,5=tO;sQWO,5=dOOQO'#Cu'#CuO!BpQ`O,5=aO!BxQ7[O,5=bO!CTQWO,5=dO!CYQpO,5=gO!CbQWO'#KVO>pQWO'#HQO9aQWO'#HSO!CgQWO'#HSO:RQ7[O'#HUO!ClQWO'#HUOOQU,5=j,5=jO!CqQWO'#HVO!DSQWO'#CnO!DXQWO,59OO!DcQWO,59OO!FhQ^O,59OOOQU,59O,59OO!FxQ07hO,59OO%[Q^O,59OO!ITQ^O'#H^OOQU'#H_'#H_OOQU'#H`'#H`O`Q^O,5=vO!IkQWO,5=vO`Q^O,5=|O`Q^O,5>OO!IpQWO,5>QO`Q^O,5>SO!IuQWO,5>VO!IzQ^O,5>]OOQU,5>c,5>cO%[Q^O,5>cO9kQ07hO,5>eOOQU,5>g,5>gO!NUQWO,5>gOOQU,5>i,5>iO!NUQWO,5>iOOQU,5>k,5>kO!NZQ`O'#D[O%[Q^O'#JmO!NxQ`O'#JmO# gQ`O'#DjO# xQ`O'#DjO#$ZQ^O'#DjO#$bQWO'#JlO#$jQWO,5:TO#$oQWO'#EpO#$}QWO'#JzO#%VQWO,5;ZO#%[Q`O'#DjO#%iQ`O'#EUOOQ07b,5:n,5:nO%[Q^O,5:nO#%pQWO,5:nO>pQWO,5;UO!@}Q`O,5;UO!AVQ7[O,5;UO:RQ7[O,5;UO#%xQWO,5@XO#%}Q$ISO,5:rOOQO-E<`-E<`O#'TQ07pO,5:}OCnQ`O,5:qO#'_Q`O,5:qOCnQ`O,5:}O!@rQ07hO,5:qOOQ07`'#Ef'#EfOOQO,5:},5:}O%[Q^O,5:}O#'lQ07hO,5:}O#'wQ07hO,5:}O!@}Q`O,5:qOOQO,5;T,5;TO#(VQ07hO,5:}POOO'#IV'#IVP#(kO!0LbO,58{POOO,58{,58{OOOO-E<V-E<VOOQ07b1G.o1G.oOOOO-E<W-E<WO#(vQpO,59zOOOO-E<Y-E<YOOQ07b1G/d1G/dO#({QrO,5>wO+}Q^O,5>wOOQO,5>},5>}O#)VQ^O'#I]OOQO-E<Z-E<ZO#)dQWO,5@VO#)lQrO,5@VO#)sQWO,5@dOOQ07b1G/j1G/jO%[Q^O,5@eO#){QWO'#IcOOQO-E<a-E<aO#)sQWO,5@dOOQ07`1G0t1G0tOOQ07f1G/u1G/uOOQ07f1G0X1G0XO%[Q^O,5@bO#*aQ07hO,5@bO#*rQ07hO,5@bO#*yQWO,5@aO9ZQWO,5@aO#+RQWO,5@aO#+aQWO'#IfO#*yQWO,5@aOOQ07`1G0s1G0sO!*OQ`O,5:tO!*ZQ`O,5:tOOQO,5:v,5:vO#,RQWO,5:vO#,ZQ7[O1G2sO9aQWO1G2sOOQ07b1G0q1G0qO#,iQ08SO1G0qO#-nQ08QO,5;ROOQ07b'#GR'#GRO#.[Q08SO'#JdO!$aQ^O1G0qO#0dQ7[O'#JnO#0nQWO,5:_O#0sQrO'#JoO%[Q^O'#JoO#0}QWO,5:dOOQ07b'#D['#D[OOQ07b1G0z1G0zO%[Q^O1G0zOOQ07b1G1d1G1dO#1SQWO1G0zO#3kQ08SO1G0{O#3rQ08SO1G0{O#6]Q08SO1G0{O#6dQ08SO1G0{O#8nQ08SO1G0{O#9UQ08SO1G0{O#<OQ08SO1G0{O#<VQ08SO1G0{O#>jQ08SO1G0{O#>wQ08SO1G0{O#@uQ08SO1G0{O#CuQ(CYO'#ChO#EsQ(CYO1G1^O#EzQ(CYO'#JjO!,lQWO1G1dO#F[Q08SO,5?TOOQ07`-E<g-E<gO#GOQ08SO1G0{OOQ07b1G0{1G0{O#IZQ08SO1G1aO#I}Q&jO,5<TO#JVQ&jO,5<UO#J_Q&jO'#FlO#JvQWO'#FkOOQO'#KO'#KOOOQO'#Ig'#IgO#J{Q&jO1G1kOOQ07b1G1k1G1kOOOS1G1v1G1vO#K^Q(CYO'#JiO#KhQWO,5<_O!*fQ^O,5<_OOOS-E<f-E<fOOQ07b1G1i1G1iO#KmQ`O'#J}OOQ07b,5<a,5<aO#KuQ`O,5<aOOQ07b,59e,59eO!&dQ7[O'#DPOOOO'#IZ'#IZO#KzO?MpO,59iOOQ07b,59i,59iO%[Q^O1G1|O!6[QWO'#IkO#LVQ7[O,5<uOOQ07b,5<r,5<rO!(SQ7[O'#InO#LuQ7[O,5=RO!(SQ7[O'#IpO#MhQ7[O,5=TO!&dQ7[O,5=VOOQO1G2O1G2OO#MrQpO'#CqO#NVQpO,5<nO#N^QWO'#KRO9aQWO'#KRO#NlQWO,5<pO!(SQ7[O,5<oO#NqQWO'#GUO#N|QWO,5<oO$ RQpO'#GRO$ `QpO'#KSO$ jQWO'#KSO!&dQ7[O'#KSO$ oQWO,5<sO$ tQ`O'#G^O!4eQ`O'#G^O$!VQWO'#G`O$![QWO'#GbO!3fQWO'#GeO$!aQ07hO'#ImO$!lQ`O,5<wOOQ07f,5<w,5<wO$!sQ`O'#G^O$#RQ`O'#G_O$#ZQ`O'#G_O$#`Q7[O,5=RO$#pQ7[O,5=TOOQ07b,5=W,5=WO!(SQ7[O,5?}O!(SQ7[O,5?}O$$QQWO'#IrO$$]QWO,5?|O$$eQWO,59`O$%UQ7[O,59qOOQ07b,59q,59qO$%wQ7[O,5<fO$&jQ7[O,5<hO@bQWO,5<jOOQ07b,5<k,5<kO$&tQWO,5<qO$&yQ7[O,5<vO$'ZQWO'#JuO!$aQ^O1G1}O$'`QWO1G1}O9ZQWO'#JxO9ZQWO'#EpO%[Q^O'#EpO9ZQWO'#ItO$'eQ07hO,5@rOOQU1G2w1G2wOOQU1G4X1G4XOOQ07b1G/w1G/wO!,iQWO1G/wO$)jQ08SO1G0TOOQU1G2s1G2sO!&dQ7[O1G2sO%[Q^O1G2sO#,^QWO1G2sO$+nQ7[O'#EgOOQ07`,5?{,5?{O$+xQ07hO,5?{OOQU1G.t1G.tO!@rQ07hO1G.tO!@}Q`O1G.tO!AVQ7[O1G.tO$,ZQWO1G0qO$,`QWO'#ChO$,kQWO'#K[O$,sQWO,5=uO$,xQWO'#K[O$,}QWO'#K[O$-]QWO'#IzO$-kQWO,5@uO$-sQrO1G1fOOQ07b1G1h1G1hO9aQWO1G3`O@bQWO1G3`O$-zQWO1G3`O$.PQWO1G3`OOQU1G3`1G3`O!CTQWO1G3OO!&dQ7[O1G2{O$.UQWO1G2{OOQU1G2|1G2|O!&dQ7[O1G2|O$.ZQWO1G2|O$.cQ`O'#GzOOQU1G3O1G3OO!4eQ`O'#IvO!CYQpO1G3ROOQU1G3R1G3ROOQU,5=l,5=lO$.kQ7[O,5=nO9aQWO,5=nO$![QWO,5=pO9UQWO,5=pO!@}Q`O,5=pO!AVQ7[O,5=pO:RQ7[O,5=pO$.yQWO'#KYO$/UQWO,5=qOOQU1G.j1G.jO$/ZQ07hO1G.jO@bQWO1G.jO$/fQWO1G.jO9kQ07hO1G.jO$1kQrO,5@wO$1{QWO,5@wO9ZQWO,5@wO$2WQ^O,5=xO$2_QWO,5=xOOQU1G3b1G3bO`Q^O1G3bOOQU1G3h1G3hOOQU1G3j1G3jO>kQWO1G3lO$2dQ^O1G3nO$6hQ^O'#HmOOQU1G3q1G3qO$6uQWO'#HsO>pQWO'#HuOOQU1G3w1G3wO$6}Q^O1G3wO9kQ07hO1G3}OOQU1G4P1G4POOQ07`'#GY'#GYO9kQ07hO1G4RO9kQ07hO1G4TO$;UQWO,5@XO!*fQ^O,5;[O9ZQWO,5;[O>pQWO,5:UO!*fQ^O,5:UO!@}Q`O,5:UO$;ZQ(CYO,5:UOOQO,5;[,5;[O$;eQ`O'#I^O$;{QWO,5@WOOQ07b1G/o1G/oO$<TQ`O'#IdO$<_QWO,5@fOOQ07`1G0u1G0uO# xQ`O,5:UOOQO'#Ia'#IaO$<gQ`O,5:pOOQ07f,5:p,5:pO#%sQWO1G0YOOQ07b1G0Y1G0YO%[Q^O1G0YOOQ07b1G0p1G0pO>pQWO1G0pO!@}Q`O1G0pO!AVQ7[O1G0pOOQ07`1G5s1G5sO!@rQ07hO1G0]OOQO1G0i1G0iO%[Q^O1G0iO$<nQ07hO1G0iO$<yQ07hO1G0iO!@}Q`O1G0]OCnQ`O1G0]O$=XQ07hO1G0iOOQO1G0]1G0]O$=mQ08SO1G0iPOOO-E<T-E<TPOOO1G.g1G.gOOOO1G/f1G/fO$=wQpO,5<eO$>PQrO1G4cOOQO1G4i1G4iO%[Q^O,5>wO$>ZQWO1G5qO$>cQWO1G6OO$>kQrO1G6PO9ZQWO,5>}O$>uQ08SO1G5|O%[Q^O1G5|O$?VQ07hO1G5|O$?hQWO1G5{O$?hQWO1G5{O9ZQWO1G5{O$?pQWO,5?QO9ZQWO,5?QOOQO,5?Q,5?QO$@UQWO,5?QO$'ZQWO,5?QOOQO-E<d-E<dOOQO1G0`1G0`OOQO1G0b1G0bO!,lQWO1G0bOOQU7+(_7+(_O!&dQ7[O7+(_O%[Q^O7+(_O$@dQWO7+(_O$@oQ7[O7+(_O$@}Q08SO,5=RO$CYQ08SO,5=TO$EeQ08SO,5=RO$GvQ08SO,5=TO$JXQ08SO,59qO$LaQ08SO,5<fO$NlQ08SO,5<hO%!wQ08SO,5<vOOQ07b7+&]7+&]O%%YQ08SO7+&]O%%|Q7[O'#I_O%&WQWO,5@YOOQ07b1G/y1G/yO%&`Q^O'#I`O%&mQWO,5@ZO%&uQrO,5@ZOOQ07b1G0O1G0OO%'PQWO7+&fOOQ07b7+&f7+&fO%'UQ(CYO,5:eO%[Q^O7+&xO%'`Q(CYO,5:]O%'mQ(CYO,5:iO%'wQ(CYO,5:kOOQ07b7+'O7+'OOOQO1G1o1G1oOOQO1G1p1G1pO%(RQtO,5<WO!*fQ^O,5<VOOQO-E<e-E<eOOQ07b7+'V7+'VOOOS7+'b7+'bOOOS1G1y1G1yO%(^QWO1G1yOOQ07b1G1{1G1{O%(cQpO,59kOOOO-E<X-E<XOOQ07b1G/T1G/TO%(jQ08SO7+'hOOQ07b,5?V,5?VO%)^QpO,5?VOOQ07b1G2a1G2aP!&dQ7[O'#IkPOQ07b-E<i-E<iO%)|Q7[O,5?YOOQ07b-E<l-E<lO%*oQ7[O,5?[OOQ07b-E<n-E<nO%*yQpO1G2qOOQ07b1G2Y1G2YO%+QQWO'#IjO%+`QWO,5@mO%+`QWO,5@mO%+hQWO,5@mO%+sQWO,5@mOOQO1G2[1G2[O%,RQ7[O1G2ZO!(SQ7[O1G2ZO%,cQ!LQO'#IlO%,sQWO,5@nO!&dQ7[O,5@nO%,{QpO,5@nOOQ07b1G2_1G2_OOQ07`,5<x,5<xOOQ07`,5<y,5<yO$'ZQWO,5<yOC_QWO,5<yO!@}Q`O,5<xOOQO'#Ga'#GaO%-VQWO,5<zOOQ07`,5<|,5<|O$'ZQWO,5=POOQO,5?X,5?XOOQO-E<k-E<kOOQ07f1G2c1G2cO!4eQ`O,5<xO%-_QWO,5<yO$!VQWO,5<zO!4eQ`O,5<yO!(SQ7[O'#InO%.RQ7[O1G2mO!(SQ7[O'#IpO%.tQ7[O1G2oO%/OQ7[O1G5iO%/YQ7[O1G5iOOQO,5?^,5?^OOQO-E<p-E<pOOQO1G.z1G.zO!7{Q`O,59sO%[Q^O,59sO%/gQWO1G2UO!(SQ7[O1G2]O%/lQ08SO7+'iOOQ07b7+'i7+'iO!$aQ^O7+'iO%0`QWO,5;[OOQ07`,5?`,5?`OOQ07`-E<r-E<rOOQ07b7+%c7+%cO%0eQpO'#KTO#%sQWO7+(_O%0oQrO7+(_O$@gQWO7+(_O%0vQ08QO'#ChO%1ZQ08QO,5<}O%1{QWO,5<}OOQ07`1G5g1G5gOOQU7+$`7+$`O!@rQ07hO7+$`O!@}Q`O7+$`O!$aQ^O7+&]O%2QQWO'#IyO%2iQWO,5@vOOQO1G3a1G3aO9aQWO,5@vO%2iQWO,5@vO%2qQWO,5@vOOQO,5?f,5?fOOQO-E<x-E<xOOQ07b7+'Q7+'QO%2vQWO7+(zO9kQ07hO7+(zO9aQWO7+(zO@bQWO7+(zOOQU7+(j7+(jO%2{Q08QO7+(gO!&dQ7[O7+(gO%3VQpO7+(hOOQU7+(h7+(hO!&dQ7[O7+(hO%3^QWO'#KXO%3iQWO,5=fOOQO,5?b,5?bOOQO-E<t-E<tOOQU7+(m7+(mO%4xQ`O'#HTOOQU1G3Y1G3YO!&dQ7[O1G3YO%[Q^O1G3YO%5PQWO1G3YO%5[Q7[O1G3YO9kQ07hO1G3[O$![QWO1G3[O9UQWO1G3[O!@}Q`O1G3[O!AVQ7[O1G3[O%5jQWO'#IxO%6OQWO,5@tO%6WQ`O,5@tOOQ07`1G3]1G3]OOQU7+$U7+$UO@bQWO7+$UO9kQ07hO7+$UO%6cQWO7+$UO%[Q^O1G6cO%[Q^O1G6dO%6hQ07hO1G6cO%6rQ^O1G3dO%6yQWO1G3dO%7OQ^O1G3dOOQU7+(|7+(|O9kQ07hO7+)WO`Q^O7+)YOOQU'#K_'#K_OOQU'#I{'#I{O%7VQ^O,5>XOOQU,5>X,5>XO%[Q^O'#HnO%7dQWO'#HpOOQU,5>_,5>_O9ZQWO,5>_OOQU,5>a,5>aOOQU7+)c7+)cOOQU7+)i7+)iOOQU7+)m7+)mOOQU7+)o7+)oO%7iQ`O1G5sO%7}Q(CYO1G0vO%8XQWO1G0vOOQO1G/p1G/pO%8dQ(CYO1G/pO>pQWO1G/pO!*fQ^O'#DjOOQO,5>x,5>xOOQO-E<[-E<[OOQO,5?O,5?OOOQO-E<b-E<bO!@}Q`O1G/pOOQO-E<_-E<_OOQ07f1G0[1G0[OOQ07b7+%t7+%tO#%sQWO7+%tOOQ07b7+&[7+&[O>pQWO7+&[O!@}Q`O7+&[OOQO7+%w7+%wO$=mQ08SO7+&TOOQO7+&T7+&TO%[Q^O7+&TO%8nQ07hO7+&TO!@rQ07hO7+%wO!@}Q`O7+%wO%8yQ07hO7+&TO%9XQ08SO7++hO%[Q^O7++hO%9iQWO7++gO%9iQWO7++gOOQO1G4l1G4lO9ZQWO1G4lO%9qQWO1G4lOOQO7+%|7+%|O#%sQWO<<KyO%0oQrO<<KyO%:PQWO<<KyOOQU<<Ky<<KyO!&dQ7[O<<KyO%[Q^O<<KyO%:XQWO<<KyO%:dQ08SO,5?YO%<oQ08SO,5?[O%>zQ08SO1G2ZO%A]Q08SO1G2mO%ChQ08SO1G2oO%EsQ7[O,5>yOOQO-E<]-E<]O%E}QrO,5>zO%[Q^O,5>zOOQO-E<^-E<^O%FXQWO1G5uOOQ07b<<JQ<<JQO%FaQ(CYO1G0qO%HkQ(CYO1G0{O%HrQ(CYO1G0{O%JvQ(CYO1G0{O%J}Q(CYO1G0{O%LrQ(CYO1G0{O%MYQ(CYO1G0{O& mQ(CYO1G0{O& tQ(CYO1G0{O&#rQ(CYO1G0{O&$PQ(CYO1G0{O&%}Q(CYO1G0{O&&bQ08SO<<JdO&'gQ(CYO1G0{O&)]Q(CYO'#JdO&+`Q(CYO1G1aO&+mQ(CYO1G0TO!*fQ^O'#FnOOQO'#KP'#KPOOQO1G1r1G1rO&+wQWO1G1qO&+|Q(CYO,5?TOOOS7+'e7+'eOOOO1G/V1G/VOOQ07b1G4q1G4qO!(SQ7[O7+(]O&,WQWO,5?UO9aQWO,5?UOOQO-E<h-E<hO&,fQWO1G6XO&,fQWO1G6XO&,nQWO1G6XO&,yQ7[O7+'uO&-ZQpO,5?WO&-eQWO,5?WO!&dQ7[O,5?WOOQO-E<j-E<jO&-jQpO1G6YO&-tQWO1G6YOOQ07`1G2e1G2eO$'ZQWO1G2eOOQ07`1G2d1G2dO&-|QWO1G2fO!&dQ7[O1G2fOOQ07`1G2k1G2kO!@}Q`O1G2dOC_QWO1G2eO&.RQWO1G2fO&.ZQWO1G2eO&.}Q7[O,5?YOOQ07b-E<m-E<mO&/pQ7[O,5?[OOQ07b-E<o-E<oO!(SQ7[O7++TOOQ07b1G/_1G/_O&/zQWO1G/_OOQ07b7+'p7+'pO&0PQ7[O7+'wO&0aQ08SO<<KTOOQ07b<<KT<<KTO&1TQWO1G0vO!&dQ7[O'#IsO&1YQWO,5@oO!&dQ7[O1G2iOOQU<<Gz<<GzO!@rQ07hO<<GzO&1bQ08SO<<IwOOQ07b<<Iw<<IwOOQO,5?e,5?eO&2UQWO,5?eO&2ZQWO,5?eOOQO-E<w-E<wO&2iQWO1G6bO&2iQWO1G6bO9aQWO1G6bO@bQWO<<LfOOQU<<Lf<<LfO&2qQWO<<LfO9kQ07hO<<LfOOQU<<LR<<LRO%2{Q08QO<<LROOQU<<LS<<LSO%3VQpO<<LSO&2vQ`O'#IuO&3RQWO,5@sO!*fQ^O,5@sOOQU1G3Q1G3QO&3ZQ^O'#JmOOQO'#Iw'#IwO9kQ07hO'#IwO&3eQ`O,5=oOOQU,5=o,5=oO&3lQ`O'#EcO&4QQWO7+(tO&4VQWO7+(tOOQU7+(t7+(tO!&dQ7[O7+(tO%[Q^O7+(tO&4_QWO7+(tOOQU7+(v7+(vO9kQ07hO7+(vO$![QWO7+(vO9UQWO7+(vO!@}Q`O7+(vO&4jQWO,5?dOOQO-E<v-E<vOOQO'#HW'#HWO&4uQWO1G6`O9kQ07hO<<GpOOQU<<Gp<<GpO@bQWO<<GpO&4}QWO7++}O&5SQWO7+,OO%[Q^O7++}O%[Q^O7+,OOOQU7+)O7+)OO&5XQWO7+)OO&5^Q^O7+)OO&5eQWO7+)OOOQU<<Lr<<LrOOQU<<Lt<<LtOOQU-E<y-E<yOOQU1G3s1G3sO&5jQWO,5>YOOQU,5>[,5>[O&5oQWO1G3yO9ZQWO7+&bO!*fQ^O7+&bOOQO7+%[7+%[O&5tQ(CYO1G6PO>pQWO7+%[OOQ07b<<I`<<I`OOQ07b<<Iv<<IvO>pQWO<<IvOOQO<<Io<<IoO$=mQ08SO<<IoO%[Q^O<<IoOOQO<<Ic<<IcO!@rQ07hO<<IcO&6OQ07hO<<IoO&6ZQ08SO<= SO&6kQWO<= ROOQO7+*W7+*WO9ZQWO7+*WOOQUANAeANAeO&6sQWOANAeO!&dQ7[OANAeO#%sQWOANAeO%0oQrOANAeO%[Q^OANAeO&6{Q08SO7+'uO&9^Q08SO,5?YO&;iQ08SO,5?[O&=tQ08SO7+'wO&@VQrO1G4fO&@aQ(CYO7+&]O&BeQ(CYO,5=RO&DlQ(CYO,5=TO&D|Q(CYO,5=RO&E^Q(CYO,5=TO&EnQ(CYO,59qO&GqQ(CYO,5<fO&ItQ(CYO,5<hO&KwQ(CYO,5<vO&MmQ(CYO7+'hO&MzQ(CYO7+'iO&NXQWO,5<YOOQO7+']7+']O&N^Q7[O<<KwOOQO1G4p1G4pO&NeQWO1G4pO&NpQWO1G4pO' OQWO7++sO' OQWO7++sO!&dQ7[O1G4rO' WQpO1G4rO' bQWO7++tOOQ07`7+(P7+(PO$'ZQWO7+(QO' jQpO7+(QOOQ07`7+(O7+(OO$'ZQWO7+(PO' qQWO7+(QO!&dQ7[O7+(QOC_QWO7+(PO' vQ7[O<<NoOOQ07b7+$y7+$yO'!QQpO,5?_OOQO-E<q-E<qO'![Q08QO7+(TOOQUAN=fAN=fO9aQWO1G5POOQO1G5P1G5PO'!lQWO1G5PO'!qQWO7++|O'!qQWO7++|O9kQ07hOANBQO@bQWOANBQOOQUANBQANBQOOQUANAmANAmOOQUANAnANAnO'!yQWO,5?aOOQO-E<s-E<sO'#UQ(CYO1G6_O'%fQrO'#ChOOQO,5?c,5?cOOQO-E<u-E<uOOQU1G3Z1G3ZO&3ZQ^O,5<zOOQU<<L`<<L`O!&dQ7[O<<L`O&4QQWO<<L`O'%pQWO<<L`O%[Q^O<<L`OOQU<<Lb<<LbO9kQ07hO<<LbO$![QWO<<LbO9UQWO<<LbO'%xQ`O1G5OO'&TQWO7++zOOQUAN=[AN=[O9kQ07hOAN=[OOQU<= i<= iOOQU<= j<= jO'&]QWO<= iO'&bQWO<= jOOQU<<Lj<<LjO'&gQWO<<LjO'&lQ^O<<LjOOQU1G3t1G3tO>pQWO7+)eO'&sQWO<<I|O''OQ(CYO<<I|OOQO<<Hv<<HvOOQ07bAN?bAN?bOOQOAN?ZAN?ZO$=mQ08SOAN?ZOOQOAN>}AN>}O%[Q^OAN?ZOOQO<<Mr<<MrOOQUG27PG27PO!&dQ7[OG27PO#%sQWOG27PO''YQWOG27PO%0oQrOG27PO''bQ(CYO<<JdO''oQ(CYO1G2ZO')eQ(CYO,5?YO'+hQ(CYO,5?[O'-kQ(CYO1G2mO'/nQ(CYO1G2oO'1qQ(CYO<<KTO'2OQ(CYO<<IwOOQO1G1t1G1tO!(SQ7[OANAcOOQO7+*[7+*[O'2]QWO7+*[O'2hQWO<= _O'2pQpO7+*^OOQ07`<<Kl<<KlO$'ZQWO<<KlOOQ07`<<Kk<<KkO'2zQpO<<KlO$'ZQWO<<KkOOQO7+*k7+*kO9aQWO7+*kO'3RQWO<= hOOQUG27lG27lO9kQ07hOG27lO!*fQ^O1G4{O'3ZQWO7++yO&4QQWOANAzOOQUANAzANAzO!&dQ7[OANAzO'3cQWOANAzOOQUANA|ANA|O9kQ07hOANA|O$![QWOANA|OOQO'#HX'#HXOOQO7+*j7+*jOOQUG22vG22vOOQUANETANETOOQUANEUANEUOOQUANBUANBUO'3kQWOANBUOOQU<<MP<<MPO!*fQ^OAN?hOOQOG24uG24uO$=mQ08SOG24uO#%sQWOLD,kOOQULD,kLD,kO!&dQ7[OLD,kO'3pQWOLD,kO'3xQ(CYO7+'uO'5nQ(CYO,5?YO'7qQ(CYO,5?[O'9tQ(CYO7+'wO';jQ7[OG26}OOQO<<Mv<<MvOOQ07`ANAWANAWO$'ZQWOANAWOOQ07`ANAVANAVOOQO<<NV<<NVOOQULD-WLD-WO';zQ(CYO7+*gOOQUG27fG27fO&4QQWOG27fO!&dQ7[OG27fOOQUG27hG27hO9kQ07hOG27hOOQUG27pG27pO'<UQ(CYOG25SOOQOLD*aLD*aOOQU!$(!V!$(!VO#%sQWO!$(!VO!&dQ7[O!$(!VO'<`Q08SOG26}OOQ07`G26rG26rOOQULD-QLD-QO&4QQWOLD-QOOQULD-SLD-SOOQU!)9Eq!)9EqO#%sQWO!)9EqOOQU!$(!l!$(!lOOQU!.K;]!.K;]O'>qQ(CYOG26}O!*fQ^O'#DyO1PQWO'#EWO'@gQrO'#JiO!*fQ^O'#DqO'@nQ^O'#D}O'@uQrO'#ChO'C]QrO'#ChO!*fQ^O'#EPO'CmQ^O,5;VO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O,5;aO!*fQ^O'#IiO'EpQWO,5<eO'ExQ7[O,5;aO'GcQ7[O,5;aO!*fQ^O,5;uO!&dQ7[O'#GgO'ExQ7[O'#GgO!&dQ7[O'#GiO'ExQ7[O'#GiO1SQWO'#DVO1SQWO'#DVO!&dQ7[O'#FzO'ExQ7[O'#FzO!&dQ7[O'#F|O'ExQ7[O'#F|O!&dQ7[O'#G[O'ExQ7[O'#G[O!*fQ^O,5:iO!*fQ^O,5@eO'CmQ^O1G0qO'GjQ(CYO'#ChO!*fQ^O1G1|O!&dQ7[O'#InO'ExQ7[O'#InO!&dQ7[O'#IpO'ExQ7[O'#IpO!&dQ7[O,5<oO'ExQ7[O,5<oO'CmQ^O1G1}O!*fQ^O7+&xO!&dQ7[O1G2ZO'ExQ7[O1G2ZO!&dQ7[O'#InO'ExQ7[O'#InO!&dQ7[O'#IpO'ExQ7[O'#IpO!&dQ7[O1G2]O'ExQ7[O1G2]O'CmQ^O7+'iO'CmQ^O7+&]O!&dQ7[OANAcO'ExQ7[OANAcO'GtQWO'#EkO'GyQWO'#EkO'HRQWO'#FZO'HWQWO'#EuO'H]QWO'#JyO'HhQWO'#JwO'HsQWO,5;VO'HxQ7[O,5<bO'IPQWO'#GTO'IUQWO'#GTO'IZQWO,5<cO'IcQWO,5;VO'IkQ(CYO1G1^O'IrQWO,5<oO'IwQWO,5<oO'I|QWO,5<qO'JRQWO,5<qO'JWQWO1G1}O'J]QWO1G0qO'JbQ7[O<<KwO'JiQ7[O<<KwO7hQ7[O'#FxO9UQWO'#FwOA]QWO'#EjO!*fQ^O,5;rO!3fQWO'#GTO!3fQWO'#GTO!3fQWO'#GVO!3fQWO'#GVO!(SQ7[O7+(]O!(SQ7[O7+(]O%*yQpO1G2qO%*yQpO1G2qO!&dQ7[O,5=VO!&dQ7[O,5=V\",\n  stateData: \"'Km~O'tOS'uOSSOS'vRQ~OPYOQYORfOX!VO`qOczOdyOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![XO!fuO!kZO!nYO!oYO!pYO!rvO!twO!wxO!{]O#s!PO$T|O%b}O%d!QO%f!OO%g!OO%h!OO%k!RO%m!SO%p!TO%q!TO%s!UO&P!WO&V!XO&X!YO&Z!ZO&]![O&`!]O&f!^O&l!_O&n!`O&p!aO&r!bO&t!cO'{SO'}TO(QUO(XVO(g[O(tiO~OVtO~P`OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'{!dO'}TO(QUO(XVO(g[O(tiO~O`!vOo!nO!P!oO!_!xO!`!uO!a!uO!{:dO#P!pO#Q!pO#R!wO#S!pO#T!pO#W!yO#X!yO'|!lO'}TO(QUO([!mO(g!sO~O'v!zO~OP[XZ[X`[Xn[X|[X}[X!P[X!Y[X!h[X!i[X!k[X!o[X#[[X#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X'r[X(X[X(h[X(o[X(p[X~O!d$|X~P(qO^!|O'}#OO(O!|O(P#OO~O^#PO(P#OO(Q#OO(R#PO~Ot#RO!R#SO(Y#SO(Z#UO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'{:hO'}TO(QUO(XVO(g[O(tiO~O!X#YO!Y#VO!V(_P!V(lP~P+}O!Z#bO~P`OPYOQYORfOc!jOd!iOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'}TO(QUO(XVO(g[O(tiO~Ol#lO!X#hO!{]O#e#kO#f#hO'{:iO!j(iP~P.iO!k#nO'{#mO~O!w#rO!{]O%b#sO~O#g#tO~O!d#uO#g#tO~OP$]OZ$dOn$QO|#yO}#zO!P#{O!Y$aO!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO#y$YO(XVO(h$ZO(o#|O(p#}O~O`(]X'r(]X'p(]X!j(]X!V(]X![(]X%c(]X!d(]X~P1qO#[$eO$O$eOP(^XZ(^Xn(^X|(^X}(^X!P(^X!Y(^X!h(^X!k(^X!o(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#r(^X#t(^X#v(^X#x(^X#y(^X(X(^X(h(^X(o(^X(p(^X![(^X%c(^X~O`(^X!i(^X'r(^X'p(^X!V(^X!j(^Xr(^X!d(^X~P4XO#[$eO~O$Y$gO$[$fO$c$lO~ORfO![$mO$f$nO$h$pO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz%ZO!P${O![$|O!f%`O!k$xO#f%aO$T%^O$o%[O$q%]O$t%_O'{$rO'}TO(QUO(X$uO(o$}O(p%POf(UP~O!k%bO~O!P%eO![%fO'{%dO~O!d%jO~O`%kO'r%kO~O'|!lO~P%[O%h%rO~P%[Og%VO!k%bO'{%dO'|!lO~Od%yO!k%bO'{%dO~O#r$SO~O|&OO![%{O!k%}O%d&RO'{%dO'|!lO'}TO(QUO_(}P~O!w#rO~O%m&TO!P(yX![(yX'{(yX~O'{&UO~O!t&ZO#s!PO%d!QO%f!OO%g!OO%h!OO%k!RO%m!SO%p!TO%q!TO~Oc&`Od&_O!w&]O%b&^O%u&[O~P;xOc&cOdyO![&bO!t&ZO!wxO!{]O#s!PO%b}O%f!OO%g!OO%h!OO%k!RO%m!SO%p!TO%q!TO%s!UO~Oa&fO#[&iO%d&dO'|!lO~P<}O!k&jO!t&nO~O!k#nO~O![XO~O`%kO'q&vO'r%kO~O`%kO'q&yO'r%kO~O`%kO'q&{O'r%kO~O'p[X!V[Xr[X!j[X&T[X![[X%c[X!d[X~P(qO!_'YO!`'RO!a'RO'|!lO'}TO(QUO~Oo'PO!P'OO!X'SO([&}O!Z(`P!Z(nP~P@UOj']O!['ZO'{%dO~Od'bO!k%bO'{%dO~O|&OO!k%}O~Oo!nO!P!oO!{:dO#P!pO#Q!pO#S!pO#T!pO'|!lO'}TO(QUO([!mO(g!sO~O!_'hO!`'gO!a'gO#R!pO#W'iO#X'iO~PApO`%kOg%VO!d#uO!k%bO'r%kO(h'kO~O!o'oO#['mO~PCOOo!nO!P!oO'}TO(QUO([!mO(g!sO~O![XOo(eX!P(eX!_(eX!`(eX!a(eX!{(eX#P(eX#Q(eX#R(eX#S(eX#T(eX#W(eX#X(eX'|(eX'}(eX(Q(eX([(eX(g(eX~O!`'gO!a'gO'|!lO~PCnO'w'sO'x'sO'y'uO~O^!|O'}'wO(O!|O(P'wO~O^#PO(P'wO(Q'wO(R#PO~Ot#RO!R#SO(Y#SO(Z'{O~O!X'}O!V'PX!V'VX!Y'PX!Y'VX~P+}O!Y(PO!V(_X~OP$]OZ$dOn$QO|#yO}#zO!P#{O!Y(PO!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO#y$YO(XVO(h$ZO(o#|O(p#}O~O!V(_X~PGbO!V(UO~O!V(kX!Y(kX!d(kX!j(kX(h(kX~O#[(kX#g#`X!Z(kX~PIhO#[(VO!V(mX!Y(mX~O!Y(WO!V(lX~O!V(ZO~O#[$eO~PIhO!Z([O~P`O|#yO}#zO!P#{O!i#wO!k#xO(XVOP!maZ!man!ma!Y!ma!h!ma!o!ma#j!ma#k!ma#l!ma#m!ma#n!ma#o!ma#p!ma#q!ma#r!ma#t!ma#v!ma#x!ma#y!ma(h!ma(o!ma(p!ma~O`!ma'r!ma'p!ma!V!ma!j!mar!ma![!ma%c!ma!d!ma~PKOO!j(]O~O!d#uO#[(^O(h'kO!Y(jX`(jX'r(jX~O!j(jX~PMnO!P%eO![%fO!{]O#e(cO#f(bO'{%dO~O!Y(dO!j(iX~O!j(fO~O!P%eO![%fO#f(bO'{%dO~OP(^XZ(^Xn(^X|(^X}(^X!P(^X!Y(^X!h(^X!i(^X!k(^X!o(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#r(^X#t(^X#v(^X#x(^X#y(^X(X(^X(h(^X(o(^X(p(^X~O!d#uO!j(^X~P! [O|(gO}(hO!i#wO!k#xO!{!za!P!za~O!w!za%b!za![!za#e!za#f!za'{!za~P!#`O!w(lO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![XO!fuO!kZO!nYO!oYO!pYO!rvO!t!gO!w!hO$T!kO'{!dO'}TO(QUO(XVO(g[O(tiO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz;QO!P${O![$|O!f<`O!k$xO#f;WO$T%^O$o;SO$q;UO$t%_O'{(pO'}TO(QUO(X$uO(o$}O(p%PO~O#g(rO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz%ZO!P${O![$|O!f%`O!k$xO#f%aO$T%^O$o%[O$q%]O$t%_O'{(pO'}TO(QUO(X$uO(o$}O(p%PO~Of(bP~P!(SO!X(vO!j(cP~P%[O([(xO(g[O~O!P(zO!k#xO([(xO(g[O~OP:cOQ:cORfOc<[Od!iOlkOn:cOokOpkOvkOx:cOz:cO!PWO!TkO!UkO![!eO!f:fO!kZO!n:cO!o:cO!p:cO!r:gO!t:jO!w!hO$T!kO'{)YO'}TO(QUO(XVO(g[O(t<YO~O})]O!k#xO~O!Y$aO`$ma'r$ma'p$ma!j$ma!V$ma![$ma%c$ma!d$ma~O#s)aO~P!&dO|)dO!d)cO![$ZX$W$ZX$Y$ZX$[$ZX$c$ZX~O!d)cO![(qX$W(qX$Y(qX$[(qX$c(qX~O|)dO~P!.OO|)dO![(qX$W(qX$Y(qX$[(qX$c(qX~O![)fO$W)jO$Y)eO$[)eO$c)kO~O!X)nO~P!*fO$Y$gO$[$fO$c)rO~Oj$uX|$uX!P$uX!i$uX(o$uX(p$uX~OfiXf$uXjiX!YiX#[iX~P!/tOo)tO~Ot)uO(Y)vO(Z)xO~Oj*RO|)zO!P){O(o$}O(p%PO~Of)yO~P!0}Of*SO~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz;QO!P${O![$|O!f<`O!k$xO#f;WO$T%^O$o;SO$q;UO$t%_O'}TO(QUO(X$uO(o$}O(p%PO~O!X*WO'{*TO!j(uP~P!1lO#g*YO~O!k*ZO~O!X*`O'{*]O!V(vP~P!1lOn*lO!P*dO!_*jO!`*cO!a*cO!k*ZO#W*kO%Y*fO'|!lO([!mO~O!Z*iO~P!3xO!i#wOj(WX|(WX!P(WX(o(WX(p(WX!Y(WX#[(WX~Of(WX#|(WX~P!4qOj*qO#[*pOf(VX!Y(VX~O!Y*rOf(UX~O'{&UOf(UP~O!k*yO~O'{(pO~Ol*}O!P%eO!X#hO![%fO!{]O#e#kO#f#hO'{%dO!j(iP~O!d#uO#g+OO~O!P%eO!X+QO!Y(WO![%fO'{%dO!V(lP~Oo'VO!P+SO!X+RO'}TO(QUO([(xO~O!Z(nP~P!7lO!Y+TO`(zX'r(zX~OP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO#y$YO(XVO(h$ZO(o#|O(p#}O~O`!ea!Y!ea'r!ea'p!ea!V!ea!j!ear!ea![!ea%c!ea!d!ea~P!8dO|#yO}#zO!P#{O!i#wO!k#xO(XVOP!qaZ!qan!qa!Y!qa!h!qa!o!qa#j!qa#k!qa#l!qa#m!qa#n!qa#o!qa#p!qa#q!qa#r!qa#t!qa#v!qa#x!qa#y!qa(h!qa(o!qa(p!qa~O`!qa'r!qa'p!qa!V!qa!j!qar!qa![!qa%c!qa!d!qa~P!:}O|#yO}#zO!P#{O!i#wO!k#xO(XVOP!saZ!san!sa!Y!sa!h!sa!o!sa#j!sa#k!sa#l!sa#m!sa#n!sa#o!sa#p!sa#q!sa#r!sa#t!sa#v!sa#x!sa#y!sa(h!sa(o!sa(p!sa~O`!sa'r!sa'p!sa!V!sa!j!sar!sa![!sa%c!sa!d!sa~P!=hOg%VOj+^O!['ZO%c+]O~O!d+`O`(TX![(TX'r(TX!Y(TX~O`%kO![XO'r%kO~Og%VO!k%bO~Og%VO!k%bO'{%dO~O!d#uO#g(rO~Oa+kO%d+lO'{+hO'}TO(QUO!Z)OP~O!Y+mO_(}X~OZ+qO~O_+rO~O![%{O'{%dO'|!lO_(}P~Og%VO#[+wO~Og%VOj+zO![$|O~O![+|O~O|,OO![XO~O%h%rO~O!w,TO~Od,YO~Oa,ZO'{#mO'}TO(QUO!Z(|P~Od%yO~O%d!QO'{&UO~P<}OZ,`O_,_O~OPYOQYORfOczOdyOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO!fuO!kZO!nYO!oYO!pYO!rvO!wxO!{]O%b}O'}TO(QUO(XVO(g[O(tiO~O![!eO!t!gO$T!kO'{!dO~P!DkO_,_O`%kO'r%kO~OPYOQYORfOc!jOd!iOlkOnYOokOpkOvkOxYOzYO!PWO!TkO!UkO![!eO!fuO!kZO!nYO!oYO!pYO!rvO!w!hO$T!kO'{!dO'}TO(QUO(XVO(g[O(tiO~O`,eO!twO#s!OO%f!OO%g!OO%h!OO~P!GTO!k&jO~O&V,kO~O![,mO~O&h,oO&j,pOP&eaQ&eaR&eaX&ea`&eac&ead&eal&ean&eao&eap&eav&eax&eaz&ea!P&ea!T&ea!U&ea![&ea!f&ea!k&ea!n&ea!o&ea!p&ea!r&ea!t&ea!w&ea!{&ea#s&ea$T&ea%b&ea%d&ea%f&ea%g&ea%h&ea%k&ea%m&ea%p&ea%q&ea%s&ea&P&ea&V&ea&X&ea&Z&ea&]&ea&`&ea&f&ea&l&ea&n&ea&p&ea&r&ea&t&ea'p&ea'{&ea'}&ea(Q&ea(X&ea(g&ea(t&ea!Z&ea&^&eaa&ea&c&ea~O'{,uO~Og!bX!Y!OX!Y!bX!Z!OX!Z!bX!d!OX!d!bX!k!bX#[!OX~O!d,zO#[,yOg(aX!Y#dX!Y(aX!Z#dX!Z(aX!d(aX!k(aX~Og%VO!d,|O!k%bO!Y!^X!Z!^X~Oo!nO!P!oO'}TO(QUO([!mO~OP:cOQ:cORfOc<[Od!iOlkOn:cOokOpkOvkOx:cOz:cO!PWO!TkO!UkO![!eO!f:fO!kZO!n:cO!o:cO!p:cO!r:gO!t:jO!w!hO$T!kO'}TO(QUO(XVO(g[O(t<YO~O'{;]O~P#!ZO!Y-QO!Z(`X~O!Z-SO~O!d,zO#[,yO!Y#dX!Z#dX~O!Y-TO!Z(nX~O!Z-VO~O!`-WO!a-WO'|!lO~P# xO!Z-ZO~P'_Oj-^O!['ZO~O!V-cO~Oo!za!_!za!`!za!a!za#P!za#Q!za#R!za#S!za#T!za#W!za#X!za'|!za'}!za(Q!za([!za(g!za~P!#`O!o-hO#[-fO~PCOO!`-jO!a-jO'|!lO~PCnO`%kO#[-fO'r%kO~O`%kO!d#uO#[-fO'r%kO~O`%kO!d#uO!o-hO#[-fO'r%kO(h'kO~O'w'sO'x'sO'y-oO~Or-pO~O!V'Pa!Y'Pa~P!8dO!X-tO!V'PX!Y'PX~P%[O!Y(PO!V(_a~O!V(_a~PGbO!Y(WO!V(la~O!P%eO!X-xO![%fO'{%dO!V'VX!Y'VX~O#[-zO!Y(ja!j(ja`(ja'r(ja~O!d#uO~P#*aO!Y(dO!j(ia~O!P%eO![%fO#f.OO'{%dO~Ol.TO!P%eO!X.QO![%fO!{]O#e.SO#f.QO'{%dO!Y'YX!j'YX~O}.XO!k#xO~Og%VOj.[O!['ZO%c.ZO~O`#_i!Y#_i'r#_i'p#_i!V#_i!j#_ir#_i![#_i%c#_i!d#_i~P!8dOj<fO|)zO!P){O(o$}O(p%PO~O#g#Za`#Za#[#Za'r#Za!Y#Za!j#Za![#Za!V#Za~P#-]O#g(WXP(WXZ(WX`(WXn(WX}(WX!h(WX!k(WX!o(WX#j(WX#k(WX#l(WX#m(WX#n(WX#o(WX#p(WX#q(WX#r(WX#t(WX#v(WX#x(WX#y(WX'r(WX(X(WX(h(WX!j(WX!V(WX'p(WXr(WX![(WX%c(WX!d(WX~P!4qO!Y.iOf(bX~P!0}Of.kO~O!Y.lO!j(cX~P!8dO!j.oO~O!V.qO~OP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O(XVOZ#ii`#iin#ii!Y#ii!h#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii'r#ii(h#ii(o#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~O#j#ii~P#1XO#j$OO~P#1XOP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO(XVOZ#ii`#ii!Y#ii!h#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii'r#ii(h#ii(o#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~On#ii~P#3yOn$QO~P#3yOP$]On$QO|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO(XVO`#ii!Y#ii#t#ii#v#ii#x#ii#y#ii'r#ii(h#ii(o#ii(p#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~OZ#ii!h#ii#o#ii#p#ii#q#ii#r#ii~P#6kOZ$dO!h$SO#o$SO#p$SO#q$cO#r$SO~P#6kOP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO(XVO(p#}O`#ii!Y#ii#x#ii#y#ii'r#ii(h#ii(o#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~O#v$VO~P#9lO#v#ii~P#9lOP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO(XVO`#ii!Y#ii#x#ii#y#ii'r#ii(h#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~O#v#ii(o#ii(p#ii~P#<^O#v$VO(o#|O(p#}O~P#<^OP$]OZ$dOn$QO|#yO}#zO!P#{O!h$SO!i#wO!k#xO!o$]O#j$OO#k$PO#l$PO#m$PO#n$RO#o$SO#p$SO#q$cO#r$SO#t$TO#v$VO#x$XO(XVO(o#|O(p#}O~O`#ii!Y#ii#y#ii'r#ii(h#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~P#?UOP[XZ[Xn[X|[X}[X!P[X!h[X!i[X!k[X!o[X#[[X#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X(X[X(h[X(o[X(p[X!Y[X!Z[X~O#|[X~P#AoOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO#v:sO#x:uO#y:vO(XVO(h$ZO(o#|O(p#}O~O#|.sO~P#C|O#[:{O$O:{O#|(^X!Z(^X~P! [O`']a!Y']a'r']a'p']a!j']a!V']ar']a![']a%c']a!d']a~P!8dOP#iiZ#ii`#iin#ii}#ii!Y#ii!h#ii!i#ii!k#ii!o#ii#j#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii'r#ii(X#ii(h#ii'p#ii!V#ii!j#iir#ii![#ii%c#ii!d#ii~P#-]O`#}i!Y#}i'r#}i'p#}i!V#}i!j#}ir#}i![#}i%c#}i!d#}i~P!8dO$Y.xO$[.xO~O$Y.yO$[.yO~O!d)cO#[.zO![$`X$W$`X$Y$`X$[$`X$c$`X~O!X.{O~O![)fO$W.}O$Y)eO$[)eO$c/OO~O!Y:wO!Z(]X~P#C|O!Z/PO~O!d)cO$c(qX~O$c/RO~Ot)uO(Y)vO(Z/UO~O!V/YO~P!&dO(o$}Oj%Za|%Za!P%Za(p%Za!Y%Za#[%Za~Of%Za#|%Za~P#L^O(p%POj%]a|%]a!P%]a(o%]a!Y%]a#[%]a~Of%]a#|%]a~P#MPO!YeX!deX!jeX!j$uX(heX~P!/tO!j/bO~P#-]O!Y/cO!d#uO(h'kO!j(uX~O!j/hO~O!X*WO'{%dO!j(uP~O#g/jO~O!V$uX!Y$uX!d$|X~P!/tO!Y/kO!V(vX~P#-]O!d/mO~O!V/oO~Og%VOn/sO!d#uO!k%bO(h'kO~O'{/uO~O!d+`O~O`%kO!Y/yO'r%kO~O!Z/{O~P!3xO!`/|O!a/|O'|!lO([!mO~O!P0OO([!mO~O#W0PO~Of%Za!Y%Za#[%Za#|%Za~P!0}Of%]a!Y%]a#[%]a#|%]a~P!0}O'{&UOf'fX!Y'fX~O!Y*rOf(Ua~Of0YO~O|0ZO}0ZO!P0[Ojya(oya(pya!Yya#[ya~Ofya#|ya~P$$jO|)zO!P){Oj$na(o$na(p$na!Y$na#[$na~Of$na#|$na~P$%`O|)zO!P){Oj$pa(o$pa(p$pa!Y$pa#[$pa~Of$pa#|$pa~P$&RO#g0^O~Of%Oa!Y%Oa#[%Oa#|%Oa~P!0}O!d#uO~O#g0aO~O!Y+TO`(za'r(za~O|#yO}#zO!P#{O!i#wO!k#xO(XVOP!qiZ!qin!qi!Y!qi!h!qi!o!qi#j!qi#k!qi#l!qi#m!qi#n!qi#o!qi#p!qi#q!qi#r!qi#t!qi#v!qi#x!qi#y!qi(h!qi(o!qi(p!qi~O`!qi'r!qi'p!qi!V!qi!j!qir!qi![!qi%c!qi!d!qi~P$'pOg%VOn$tOo$sOp$sOv%XOx%YOz;QO!P${O![$|O!f<`O!k$xO#f;WO$T%^O$o;SO$q;UO$t%_O'}TO(QUO(X$uO(o$}O(p%PO~Ol0kO'{0jO~P$*ZO!d+`O`(Ta![(Ta'r(Ta!Y(Ta~O#g0qO~OZ[X!YeX!ZeX~O!Y0rO!Z)OX~O!Z0tO~OZ0uO~Oa0wO'{+hO'}TO(QUO~O![%{O'{%dO_'nX!Y'nX~O!Y+mO_(}a~O!j0zO~P!8dOZ0}O~O_1OO~O#[1RO~Oj1UO![$|O~O([(xO!Z({P~Og%VOj1_O![1[O%c1^O~OZ1iO!Y1gO!Z(|X~O!Z1jO~O_1lO`%kO'r%kO~O'{#mO'}TO(QUO~O#[$eO$O$eOP(^XZ(^Xn(^X|(^X}(^X!P(^X!Y(^X!h(^X!k(^X!o(^X#j(^X#k(^X#l(^X#m(^X#n(^X#o(^X#p(^X#q(^X#t(^X#v(^X#x(^X#y(^X(X(^X(h(^X(o(^X(p(^X~O#r1oO&T1pO`(^X!i(^X~P$/qO#[$eO#r1oO&T1pO~O`1rO~P%[O`1tO~O&^1wOP&[iQ&[iR&[iX&[i`&[ic&[id&[il&[in&[io&[ip&[iv&[ix&[iz&[i!P&[i!T&[i!U&[i![&[i!f&[i!k&[i!n&[i!o&[i!p&[i!r&[i!t&[i!w&[i!{&[i#s&[i$T&[i%b&[i%d&[i%f&[i%g&[i%h&[i%k&[i%m&[i%p&[i%q&[i%s&[i&P&[i&V&[i&X&[i&Z&[i&]&[i&`&[i&f&[i&l&[i&n&[i&p&[i&r&[i&t&[i'p&[i'{&[i'}&[i(Q&[i(X&[i(g&[i(t&[i!Z&[ia&[i&c&[i~Oa1}O!Z1{O&c1|O~P`O![XO!k2PO~O&j,pOP&eiQ&eiR&eiX&ei`&eic&eid&eil&ein&eio&eip&eiv&eix&eiz&ei!P&ei!T&ei!U&ei![&ei!f&ei!k&ei!n&ei!o&ei!p&ei!r&ei!t&ei!w&ei!{&ei#s&ei$T&ei%b&ei%d&ei%f&ei%g&ei%h&ei%k&ei%m&ei%p&ei%q&ei%s&ei&P&ei&V&ei&X&ei&Z&ei&]&ei&`&ei&f&ei&l&ei&n&ei&p&ei&r&ei&t&ei'p&ei'{&ei'}&ei(Q&ei(X&ei(g&ei(t&ei!Z&ei&^&eia&ei&c&ei~O!V2VO~O!Y!^a!Z!^a~P#C|Oo!nO!P!oO!X2]O([!mO!Y'QX!Z'QX~P@UO!Y-QO!Z(`a~O!Y'WX!Z'WX~P!7lO!Y-TO!Z(na~O!Z2dO~P'_O`%kO#[2mO'r%kO~O`%kO!d#uO#[2mO'r%kO~O`%kO!d#uO!o2qO#[2mO'r%kO(h'kO~O`%kO'r%kO~P!8dO!Y$aOr$ma~O!V'Pi!Y'Pi~P!8dO!Y(PO!V(_i~O!Y(WO!V(li~O!V(mi!Y(mi~P!8dO!Y(ji!j(ji`(ji'r(ji~P!8dO#[2sO!Y(ji!j(ji`(ji'r(ji~O!Y(dO!j(ii~O!P%eO![%fO!{]O#e2xO#f2wO'{%dO~O!P%eO![%fO#f2wO'{%dO~Oj3PO!['ZO%c3OO~Og%VOj3PO!['ZO%c3OO~O#g%ZaP%ZaZ%Za`%Zan%Za}%Za!h%Za!i%Za!k%Za!o%Za#j%Za#k%Za#l%Za#m%Za#n%Za#o%Za#p%Za#q%Za#r%Za#t%Za#v%Za#x%Za#y%Za'r%Za(X%Za(h%Za!j%Za!V%Za'p%Zar%Za![%Za%c%Za!d%Za~P#L^O#g%]aP%]aZ%]a`%]an%]a}%]a!h%]a!i%]a!k%]a!o%]a#j%]a#k%]a#l%]a#m%]a#n%]a#o%]a#p%]a#q%]a#r%]a#t%]a#v%]a#x%]a#y%]a'r%]a(X%]a(h%]a!j%]a!V%]a'p%]ar%]a![%]a%c%]a!d%]a~P#MPO#g%ZaP%ZaZ%Za`%Zan%Za}%Za!Y%Za!h%Za!i%Za!k%Za!o%Za#j%Za#k%Za#l%Za#m%Za#n%Za#o%Za#p%Za#q%Za#r%Za#t%Za#v%Za#x%Za#y%Za'r%Za(X%Za(h%Za!j%Za!V%Za'p%Za#[%Zar%Za![%Za%c%Za!d%Za~P#-]O#g%]aP%]aZ%]a`%]an%]a}%]a!Y%]a!h%]a!i%]a!k%]a!o%]a#j%]a#k%]a#l%]a#m%]a#n%]a#o%]a#p%]a#q%]a#r%]a#t%]a#v%]a#x%]a#y%]a'r%]a(X%]a(h%]a!j%]a!V%]a'p%]a#[%]ar%]a![%]a%c%]a!d%]a~P#-]O#gyaPyaZya`yanya!hya!iya!kya!oya#jya#kya#lya#mya#nya#oya#pya#qya#rya#tya#vya#xya#yya'rya(Xya(hya!jya!Vya'pyarya![ya%cya!dya~P$$jO#g$naP$naZ$na`$nan$na}$na!h$na!i$na!k$na!o$na#j$na#k$na#l$na#m$na#n$na#o$na#p$na#q$na#r$na#t$na#v$na#x$na#y$na'r$na(X$na(h$na!j$na!V$na'p$nar$na![$na%c$na!d$na~P$%`O#g$paP$paZ$pa`$pan$pa}$pa!h$pa!i$pa!k$pa!o$pa#j$pa#k$pa#l$pa#m$pa#n$pa#o$pa#p$pa#q$pa#r$pa#t$pa#v$pa#x$pa#y$pa'r$pa(X$pa(h$pa!j$pa!V$pa'p$par$pa![$pa%c$pa!d$pa~P$&RO#g%OaP%OaZ%Oa`%Oan%Oa}%Oa!Y%Oa!h%Oa!i%Oa!k%Oa!o%Oa#j%Oa#k%Oa#l%Oa#m%Oa#n%Oa#o%Oa#p%Oa#q%Oa#r%Oa#t%Oa#v%Oa#x%Oa#y%Oa'r%Oa(X%Oa(h%Oa!j%Oa!V%Oa'p%Oa#[%Oar%Oa![%Oa%c%Oa!d%Oa~P#-]O`#_q!Y#_q'r#_q'p#_q!V#_q!j#_qr#_q![#_q%c#_q!d#_q~P!8dOf'RX!Y'RX~P!(SO!Y.iOf(ba~O!X3ZO!Y'SX!j'SX~P%[O!Y.lO!j(ca~O!Y.lO!j(ca~P!8dO!V3^O~O#|!ma!Z!ma~PKOO#|!ea!Y!ea!Z!ea~P#C|O#|!qa!Z!qa~P!:}O#|!sa!Z!sa~P!=hORfO![3pO$a3qO~O!Z3uO~Or3vO~P#-]O`$jq!Y$jq'r$jq'p$jq!V$jq!j$jqr$jq![$jq%c$jq!d$jq~P!8dO!V3wO~P#-]O|)zO!P){O(p%POj'ba(o'ba!Y'ba#['ba~Of'ba#|'ba~P%)eO|)zO!P){Oj'da(o'da(p'da!Y'da#['da~Of'da#|'da~P%*WO(h$ZO~P#-]O!X3zO'{%dO!Y'^X!j'^X~O!Y/cO!j(ua~O!Y/cO!d#uO!j(ua~O!Y/cO!d#uO(h'kO!j(ua~Of$wi!Y$wi#[$wi#|$wi~P!0}O!X4SO'{*]O!V'`X!Y'`X~P!1lO!Y/kO!V(va~O!Y/kO!V(va~P#-]O!d#uO#r4[O~On4_O!d#uO(h'kO~O(o$}Oj%Zi|%Zi!P%Zi(p%Zi!Y%Zi#[%Zi~Of%Zi#|%Zi~P%-jO(p%POj%]i|%]i!P%]i(o%]i!Y%]i#[%]i~Of%]i#|%]i~P%.]Of(Vi!Y(Vi~P!0}O#[4fOf(Vi!Y(Vi~P!0}O!j4iO~O`$kq!Y$kq'r$kq'p$kq!V$kq!j$kqr$kq![$kq%c$kq!d$kq~P!8dO!V4mO~O!Y4nO![(wX~P#-]O!i#wO~P4XO`$uX![$uX%W[X'r$uX!Y$uX~P!/tO%W4pO`kXjkX|kX!PkX![kX'rkX(okX(pkX!YkX~O%W4pO~Oa4vO%d4wO'{+hO'}TO(QUO!Y'mX!Z'mX~O!Y0rO!Z)Oa~OZ4{O~O_4|O~O`%kO'r%kO~P#-]O![$|O~P#-]O!Y5UO#[5WO!Z({X~O!Z5XO~Oo!nO!P5YO!_!xO!`!uO!a!uO!{:dO#P!pO#Q!pO#R!pO#S!pO#T!pO#W5_O#X!yO'|!lO'}TO(QUO([!mO(g!sO~O!Z5^O~P%3nOj5dO![1[O%c5cO~Og%VOj5dO![1[O%c5cO~Oa5kO'{#mO'}TO(QUO!Y'lX!Z'lX~O!Y1gO!Z(|a~O'}TO(QUO([5mO~O_5qO~O#r5tO&T5uO~PMnO!j5vO~P%[O`5xO~O`5xO~P%[Oa1}O!Z5}O&c1|O~P`O!d6PO~O!d6ROg(ai!Y(ai!Z(ai!d(ai!k(ai~O!Y#di!Z#di~P#C|O#[6SO!Y#di!Z#di~O!Y!^i!Z!^i~P#C|O`%kO#[6]O'r%kO~O`%kO!d#uO#[6]O'r%kO~O!Y(jq!j(jq`(jq'r(jq~P!8dO!Y(dO!j(iq~O!P%eO![%fO#f6dO'{%dO~O!['ZO%c6gO~Oj6jO!['ZO%c6gO~O#g'baP'baZ'ba`'ban'ba}'ba!h'ba!i'ba!k'ba!o'ba#j'ba#k'ba#l'ba#m'ba#n'ba#o'ba#p'ba#q'ba#r'ba#t'ba#v'ba#x'ba#y'ba'r'ba(X'ba(h'ba!j'ba!V'ba'p'bar'ba!['ba%c'ba!d'ba~P%)eO#g'daP'daZ'da`'dan'da}'da!h'da!i'da!k'da!o'da#j'da#k'da#l'da#m'da#n'da#o'da#p'da#q'da#r'da#t'da#v'da#x'da#y'da'r'da(X'da(h'da!j'da!V'da'p'dar'da!['da%c'da!d'da~P%*WO#g$wiP$wiZ$wi`$win$wi}$wi!Y$wi!h$wi!i$wi!k$wi!o$wi#j$wi#k$wi#l$wi#m$wi#n$wi#o$wi#p$wi#q$wi#r$wi#t$wi#v$wi#x$wi#y$wi'r$wi(X$wi(h$wi!j$wi!V$wi'p$wi#[$wir$wi![$wi%c$wi!d$wi~P#-]O#g%ZiP%ZiZ%Zi`%Zin%Zi}%Zi!h%Zi!i%Zi!k%Zi!o%Zi#j%Zi#k%Zi#l%Zi#m%Zi#n%Zi#o%Zi#p%Zi#q%Zi#r%Zi#t%Zi#v%Zi#x%Zi#y%Zi'r%Zi(X%Zi(h%Zi!j%Zi!V%Zi'p%Zir%Zi![%Zi%c%Zi!d%Zi~P%-jO#g%]iP%]iZ%]i`%]in%]i}%]i!h%]i!i%]i!k%]i!o%]i#j%]i#k%]i#l%]i#m%]i#n%]i#o%]i#p%]i#q%]i#r%]i#t%]i#v%]i#x%]i#y%]i'r%]i(X%]i(h%]i!j%]i!V%]i'p%]ir%]i![%]i%c%]i!d%]i~P%.]Of'Ra!Y'Ra~P!0}O!Y'Sa!j'Sa~P!8dO!Y.lO!j(ci~O#|#_i!Y#_i!Z#_i~P#C|OP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O(XVOZ#iin#ii!h#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii#|#ii(h#ii(o#ii(p#ii!Y#ii!Z#ii~O#j#ii~P%FnO#j:lO~P%FnOP$]O|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO(XVOZ#ii!h#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii#|#ii(h#ii(o#ii(p#ii!Y#ii!Z#ii~On#ii~P%HyOn:nO~P%HyOP$]On:nO|#yO}#zO!P#{O!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO(XVO#t#ii#v#ii#x#ii#y#ii#|#ii(h#ii(o#ii(p#ii!Y#ii!Z#ii~OZ#ii!h#ii#o#ii#p#ii#q#ii#r#ii~P%KUOZ:zO!h:pO#o:pO#p:pO#q:yO#r:pO~P%KUOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO(XVO(p#}O#x#ii#y#ii#|#ii(h#ii(o#ii!Y#ii!Z#ii~O#v:sO~P%MpO#v#ii~P%MpOP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO(XVO#x#ii#y#ii#|#ii(h#ii!Y#ii!Z#ii~O#v#ii(o#ii(p#ii~P& {O#v:sO(o#|O(p#}O~P& {OP$]OZ:zOn:nO|#yO}#zO!P#{O!h:pO!i#wO!k#xO!o$]O#j:lO#k:mO#l:mO#m:mO#n:oO#o:pO#p:pO#q:yO#r:pO#t:qO#v:sO#x:uO(XVO(o#|O(p#}O~O#y#ii#|#ii(h#ii!Y#ii!Z#ii~P&$^O`#zy!Y#zy'r#zy'p#zy!V#zy!j#zyr#zy![#zy%c#zy!d#zy~P!8dOj<gO|)zO!P){O(o$}O(p%PO~OP#iiZ#iin#ii}#ii!h#ii!i#ii!k#ii!o#ii#j#ii#k#ii#l#ii#m#ii#n#ii#o#ii#p#ii#q#ii#r#ii#t#ii#v#ii#x#ii#y#ii#|#ii(X#ii(h#ii!Y#ii!Z#ii~P&'UO!i#wOP(WXZ(WXj(WXn(WX|(WX}(WX!P(WX!h(WX!k(WX!o(WX#j(WX#k(WX#l(WX#m(WX#n(WX#o(WX#p(WX#q(WX#r(WX#t(WX#v(WX#x(WX#y(WX#|(WX(X(WX(h(WX(o(WX(p(WX!Y(WX!Z(WX~O#|#}i!Y#}i!Z#}i~P#C|O#|!qi!Z!qi~P$'pO!Z6|O~O!Y']a!Z']a~P#C|O!d#uO(h'kO!Y'^a!j'^a~O!Y/cO!j(ui~O!Y/cO!d#uO!j(ui~Of$wq!Y$wq#[$wq#|$wq~P!0}O!V'`a!Y'`a~P#-]O!d7TO~O!Y/kO!V(vi~P#-]O!Y/kO!V(vi~O!V7XO~O!d#uO#r7^O~On7_O!d#uO(h'kO~O|)zO!P){O(p%POj'ca(o'ca!Y'ca#['ca~Of'ca#|'ca~P&.fO|)zO!P){Oj'ea(o'ea(p'ea!Y'ea#['ea~Of'ea#|'ea~P&/XO!V7aO~Of$yq!Y$yq#[$yq#|$yq~P!0}O`$ky!Y$ky'r$ky'p$ky!V$ky!j$kyr$ky![$ky%c$ky!d$ky~P!8dO!d6RO~O!Y4nO![(wa~O`#_y!Y#_y'r#_y'p#_y!V#_y!j#_yr#_y![#_y%c#_y!d#_y~P!8dOZ7fO~Oa7hO'{+hO'}TO(QUO~O!Y0rO!Z)Oi~O_7lO~O([(xO!Y'iX!Z'iX~O!Y5UO!Z({a~OlkO'{7sO~P.iO!Z7vO~P%3nOo!nO!P7wO'}TO(QUO([!mO(g!sO~O![1[O~O![1[O%c7yO~Oj7|O![1[O%c7yO~OZ8RO!Y'la!Z'la~O!Y1gO!Z(|i~O!j8VO~O!j8WO~O!j8ZO~O!j8ZO~P%[O`8]O~O!d8^O~O!j8_O~O!Y(mi!Z(mi~P#C|O`%kO#[8gO'r%kO~O!Y(jy!j(jy`(jy'r(jy~P!8dO!Y(dO!j(iy~O!['ZO%c8jO~O#g$wqP$wqZ$wq`$wqn$wq}$wq!Y$wq!h$wq!i$wq!k$wq!o$wq#j$wq#k$wq#l$wq#m$wq#n$wq#o$wq#p$wq#q$wq#r$wq#t$wq#v$wq#x$wq#y$wq'r$wq(X$wq(h$wq!j$wq!V$wq'p$wq#[$wqr$wq![$wq%c$wq!d$wq~P#-]O#g'caP'caZ'ca`'can'ca}'ca!h'ca!i'ca!k'ca!o'ca#j'ca#k'ca#l'ca#m'ca#n'ca#o'ca#p'ca#q'ca#r'ca#t'ca#v'ca#x'ca#y'ca'r'ca(X'ca(h'ca!j'ca!V'ca'p'car'ca!['ca%c'ca!d'ca~P&.fO#g'eaP'eaZ'ea`'ean'ea}'ea!h'ea!i'ea!k'ea!o'ea#j'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#t'ea#v'ea#x'ea#y'ea'r'ea(X'ea(h'ea!j'ea!V'ea'p'ear'ea!['ea%c'ea!d'ea~P&/XO#g$yqP$yqZ$yq`$yqn$yq}$yq!Y$yq!h$yq!i$yq!k$yq!o$yq#j$yq#k$yq#l$yq#m$yq#n$yq#o$yq#p$yq#q$yq#r$yq#t$yq#v$yq#x$yq#y$yq'r$yq(X$yq(h$yq!j$yq!V$yq'p$yq#[$yqr$yq![$yq%c$yq!d$yq~P#-]O!Y'Si!j'Si~P!8dO#|#_q!Y#_q!Z#_q~P#C|O(o$}OP%ZaZ%Zan%Za}%Za!h%Za!i%Za!k%Za!o%Za#j%Za#k%Za#l%Za#m%Za#n%Za#o%Za#p%Za#q%Za#r%Za#t%Za#v%Za#x%Za#y%Za#|%Za(X%Za(h%Za!Y%Za!Z%Za~Oj%Za|%Za!P%Za(p%Za~P&@nO(p%POP%]aZ%]an%]a}%]a!h%]a!i%]a!k%]a!o%]a#j%]a#k%]a#l%]a#m%]a#n%]a#o%]a#p%]a#q%]a#r%]a#t%]a#v%]a#x%]a#y%]a#|%]a(X%]a(h%]a!Y%]a!Z%]a~Oj%]a|%]a!P%]a(o%]a~P&BuOj<gO|)zO!P){O(p%PO~P&@nOj<gO|)zO!P){O(o$}O~P&BuO|0ZO}0ZO!P0[OPyaZyajyanya!hya!iya!kya!oya#jya#kya#lya#mya#nya#oya#pya#qya#rya#tya#vya#xya#yya#|ya(Xya(hya(oya(pya!Yya!Zya~O|)zO!P){OP$naZ$naj$nan$na}$na!h$na!i$na!k$na!o$na#j$na#k$na#l$na#m$na#n$na#o$na#p$na#q$na#r$na#t$na#v$na#x$na#y$na#|$na(X$na(h$na(o$na(p$na!Y$na!Z$na~O|)zO!P){OP$paZ$paj$pan$pa}$pa!h$pa!i$pa!k$pa!o$pa#j$pa#k$pa#l$pa#m$pa#n$pa#o$pa#p$pa#q$pa#r$pa#t$pa#v$pa#x$pa#y$pa#|$pa(X$pa(h$pa(o$pa(p$pa!Y$pa!Z$pa~OP%OaZ%Oan%Oa}%Oa!h%Oa!i%Oa!k%Oa!o%Oa#j%Oa#k%Oa#l%Oa#m%Oa#n%Oa#o%Oa#p%Oa#q%Oa#r%Oa#t%Oa#v%Oa#x%Oa#y%Oa#|%Oa(X%Oa(h%Oa!Y%Oa!Z%Oa~P&'UO#|$jq!Y$jq!Z$jq~P#C|O#|$kq!Y$kq!Z$kq~P#C|O!Z8vO~O#|8wO~P!0}O!d#uO!Y'^i!j'^i~O!d#uO(h'kO!Y'^i!j'^i~O!Y/cO!j(uq~O!V'`i!Y'`i~P#-]O!Y/kO!V(vq~O!V8}O~P#-]O!V8}O~Of(Vy!Y(Vy~P!0}O!Y'ga!['ga~P#-]O`%Vq![%Vq'r%Vq!Y%Vq~P#-]OZ9SO~O!Y0rO!Z)Oq~O#[9WO!Y'ia!Z'ia~O!Y5UO!Z({i~P#C|OP[XZ[Xn[X|[X}[X!P[X!V[X!Y[X!h[X!i[X!k[X!o[X#[[X#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X(X[X(h[X(o[X(p[X~O!d%TX#r%TX~P'#`O![1[O%c9[O~O'}TO(QUO([9aO~O!Y1gO!Z(|q~O!j9dO~O!j9eO~O!j9fO~O!j9fO~P%[O#[9iO!Y#dy!Z#dy~O!Y#dy!Z#dy~P#C|O!['ZO%c9nO~O#|#zy!Y#zy!Z#zy~P#C|OP$wiZ$win$wi}$wi!h$wi!i$wi!k$wi!o$wi#j$wi#k$wi#l$wi#m$wi#n$wi#o$wi#p$wi#q$wi#r$wi#t$wi#v$wi#x$wi#y$wi#|$wi(X$wi(h$wi!Y$wi!Z$wi~P&'UO|)zO!P){O(p%POP'baZ'baj'ban'ba}'ba!h'ba!i'ba!k'ba!o'ba#j'ba#k'ba#l'ba#m'ba#n'ba#o'ba#p'ba#q'ba#r'ba#t'ba#v'ba#x'ba#y'ba#|'ba(X'ba(h'ba(o'ba!Y'ba!Z'ba~O|)zO!P){OP'daZ'daj'dan'da}'da!h'da!i'da!k'da!o'da#j'da#k'da#l'da#m'da#n'da#o'da#p'da#q'da#r'da#t'da#v'da#x'da#y'da#|'da(X'da(h'da(o'da(p'da!Y'da!Z'da~O(o$}OP%ZiZ%Zij%Zin%Zi|%Zi}%Zi!P%Zi!h%Zi!i%Zi!k%Zi!o%Zi#j%Zi#k%Zi#l%Zi#m%Zi#n%Zi#o%Zi#p%Zi#q%Zi#r%Zi#t%Zi#v%Zi#x%Zi#y%Zi#|%Zi(X%Zi(h%Zi(p%Zi!Y%Zi!Z%Zi~O(p%POP%]iZ%]ij%]in%]i|%]i}%]i!P%]i!h%]i!i%]i!k%]i!o%]i#j%]i#k%]i#l%]i#m%]i#n%]i#o%]i#p%]i#q%]i#r%]i#t%]i#v%]i#x%]i#y%]i#|%]i(X%]i(h%]i(o%]i!Y%]i!Z%]i~O#|$ky!Y$ky!Z$ky~P#C|O#|#_y!Y#_y!Z#_y~P#C|O!d#uO!Y'^q!j'^q~O!Y/cO!j(uy~O!V'`q!Y'`q~P#-]O!V9wO~P#-]O!Y0rO!Z)Oy~O!Y5UO!Z({q~O![1[O%c:OO~O!j:RO~O!['ZO%c:WO~OP$wqZ$wqn$wq}$wq!h$wq!i$wq!k$wq!o$wq#j$wq#k$wq#l$wq#m$wq#n$wq#o$wq#p$wq#q$wq#r$wq#t$wq#v$wq#x$wq#y$wq#|$wq(X$wq(h$wq!Y$wq!Z$wq~P&'UO|)zO!P){O(p%POP'caZ'caj'can'ca}'ca!h'ca!i'ca!k'ca!o'ca#j'ca#k'ca#l'ca#m'ca#n'ca#o'ca#p'ca#q'ca#r'ca#t'ca#v'ca#x'ca#y'ca#|'ca(X'ca(h'ca(o'ca!Y'ca!Z'ca~O|)zO!P){OP'eaZ'eaj'ean'ea}'ea!h'ea!i'ea!k'ea!o'ea#j'ea#k'ea#l'ea#m'ea#n'ea#o'ea#p'ea#q'ea#r'ea#t'ea#v'ea#x'ea#y'ea#|'ea(X'ea(h'ea(o'ea(p'ea!Y'ea!Z'ea~OP$yqZ$yqn$yq}$yq!h$yq!i$yq!k$yq!o$yq#j$yq#k$yq#l$yq#m$yq#n$yq#o$yq#p$yq#q$yq#r$yq#t$yq#v$yq#x$yq#y$yq#|$yq(X$yq(h$yq!Y$yq!Z$yq~P&'UOf%_!Z!Y%_!Z#[%_!Z#|%_!Z~P!0}O!Y'iq!Z'iq~P#C|O!Y#d!Z!Z#d!Z~P#C|O#g%_!ZP%_!ZZ%_!Z`%_!Zn%_!Z}%_!Z!Y%_!Z!h%_!Z!i%_!Z!k%_!Z!o%_!Z#j%_!Z#k%_!Z#l%_!Z#m%_!Z#n%_!Z#o%_!Z#p%_!Z#q%_!Z#r%_!Z#t%_!Z#v%_!Z#x%_!Z#y%_!Z'r%_!Z(X%_!Z(h%_!Z!j%_!Z!V%_!Z'p%_!Z#[%_!Zr%_!Z![%_!Z%c%_!Z!d%_!Z~P#-]OP%_!ZZ%_!Zn%_!Z}%_!Z!h%_!Z!i%_!Z!k%_!Z!o%_!Z#j%_!Z#k%_!Z#l%_!Z#m%_!Z#n%_!Z#o%_!Z#p%_!Z#q%_!Z#r%_!Z#t%_!Z#v%_!Z#x%_!Z#y%_!Z#|%_!Z(X%_!Z(h%_!Z!Y%_!Z!Z%_!Z~P&'UOr(]X~P1qO'|!lO~P!*fO!VeX!YeX#[eX~P'#`OP[XZ[Xn[X|[X}[X!P[X!Y[X!YeX!h[X!i[X!k[X!o[X#[[X#[eX#geX#j[X#k[X#l[X#m[X#n[X#o[X#p[X#q[X#r[X#t[X#v[X#x[X#y[X$O[X(X[X(h[X(o[X(p[X~O!deX!j[X!jeX(heX~P'ASOP:cOQ:cORfOc<[Od!iOlkOn:cOokOpkOvkOx:cOz:cO!PWO!TkO!UkO![XO!f:fO!kZO!n:cO!o:cO!p:cO!r:gO!t:jO!w!hO$T!kO'{)YO'}TO(QUO(XVO(g[O(t<YO~O!Y:wO!Z$ma~Og%VOl%WOn$tOo$sOp$sOv%XOx%YOz;RO!P${O![$|O!f<aO!k$xO#f;XO$T%^O$o;TO$q;VO$t%_O'{(pO'}TO(QUO(X$uO(o$}O(p%PO~O#s)aO~P'ExO!Z[X!ZeX~P'ASO#g:kO~O!d#uO#g:kO~O#[:{O~O#r:pO~O#[;ZO!Y(mX!Z(mX~O#[:{O!Y(kX!Z(kX~O#g;[O~Of;^O~P!0}O#g;cO~O#g;dO~O!d#uO#g;eO~O!d#uO#g;[O~O#|;fO~P#C|O#g;gO~O#g;hO~O#g;mO~O#g;nO~O#g;oO~O#g;pO~O#|;qO~P!0}O#|;rO~P!0}O!i#P#Q#S#T#W#e#f#q(t$o$q$t%W%b%c%d%k%m%p%q%s%u~'vS#k!U't'|#lo#j#mn|'u$Y'u'{$[([~\",\n  goto: \"$2p)SPPPPP)TPP)WP)iP*x.|PPPP5pPP6WPP<S?gP?zP?zPPP?zPAxP?zP?zP?zPA|PPBRPBlPGdPPPGhPPPPGhJiPPPJoKjPGhPMxPPPP!!WGhPPPGhPGhP!$fGhP!'z!(|!)VP!)y!)}!)yPPPPP!-Y!(|PP!-v!.pP!1dGhGh!1i!4s!9Y!9Y!=OPPP!=VGhPPPPPPPPPPP!@dP!AqPPGh!CSPGhPGhGhGhGhPGh!DfP!GnP!JrP!Jv!KQ!KU!KUP!GkP!KY!KYP!N^P!NbGhGh!Nh##k?zP?zP?z?zP#$v?z?z#'O?z#)k?z#+m?z?z#,[#.f#.f#.j#.r#.f#.zP#.fP?z#/d?z#3R?z?z5pPPP#6vPPP#7a#7aP#7aP#7w#7aPP#7}P#7tP#7t#8b#7t#8|#9S5m)W#9V)WP#9^#9^#9^P)WP)WP)WP)WPP)WP#9d#9gP#9g)WP#9kP#9nP)WP)WP)WP)WP)WP)W)WPP#9t#9z#:V#:]#:c#:i#:o#:}#;T#;Z#;e#;k#;u#<U#<[#<|#=`#=f#=l#=z#>a#@O#@^#@d#Ax#BW#Cr#DQ#DW#D^#Dd#Dn#Dt#Dz#EU#Eh#EnPPPPPPPPPP#EtPPPPPPP#Fi#Ip#KP#KW#K`PPPP$!d$%Z$+r$+u$+x$,q$,t$,w$-O$-WPP$-^$-b$.Y$/X$/]$/qPP$/u$/{$0PP$0S$0W$0Z$1P$1h$2P$2T$2W$2Z$2a$2d$2h$2lR!{RoqOXst!Z#c%j&m&o&p&r,h,m1w1zY!uQ'Z-Y1[5]Q%pvQ%xyQ&P|Q&e!VS'R!e-QQ'a!iS'g!r!xS*c$|*hQ+f%yQ+s&RQ,X&_Q-W'YQ-b'bQ-j'hQ/|*jQ1f,YR;Y:g%OdOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S,e,h,m-^-f-t-z.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3Z5Y5d5t5u5x6]7w7|8]8gS#p]:d!r)[$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q*u%ZQ+k%{Q,Z&bQ,b&jQ.c;QQ0h+^Q0l+`Q0w+lQ1n,`Q2{.[Q4v0rQ5k1gQ6i3PQ6u;RQ7h4wR8m6j&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]t!nQ!r!u!x!y'R'Y'Z'g'h'i-Q-W-Y-j1[5]5_$v$si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gQ&S|Q'P!eS'V%f-TQ+k%{Q,Z&bQ0]*yQ0w+lQ0|+rQ1m,_Q1n,`Q4v0rQ5P1OQ5k1gQ5n1iQ5o1lQ7h4wQ7k4|Q8U5qQ9V7lR9b8RrnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zR,]&f&v^OPXYstuvwz!Z!`!g!j!o#R#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O']'m(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<[<][#[WZ#V#Y'S'}!S%gm#g#h#k%b%e(W(b(c(d+Q+R+T,d,z-x.O.P.Q.S2P2w2x6R6dQ%sxQ%wyS%||&RQ&Y!TQ'^!hQ'`!iQ(k#rS*V$x*ZS+e%x%yQ+i%{Q,S&]Q,W&_S-a'a'bQ.^(lQ/g*WQ0p+fQ0v+lQ0x+mQ0{+qQ1a,TS1e,X,YQ2i-bQ3y/cQ4u0rQ4y0uQ5O0}Q5j1fQ7Q3zQ7g4wQ7j4{Q9R7fR9y9S!O$zi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c!S%uy!i!t%w%x%y'Q'`'a'b'f'p*b+e+f,}-a-b-i/t0p2b2i2p4^Q+_%sQ+x&VQ+{&WQ,V&_Q.](kQ1`,SU1d,W,X,YQ3Q.^Q5e1aS5i1e1fQ8Q5j#W<^#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<go<_:y:z:};P;T;V;X;`;b;d;h;j;l;n;rW%Ti%V*r<YS&V!Q&dQ&W!RQ&X!SR+v&T$w%Si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gT)v$u)wV*v%Z;Q;RU'V!e%f-TS(y#y#zQ+p&OS.V(g(hQ1V+|Q4g0ZR7p5U&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]$i$`c#X#d%n%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.t.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PT#SV#T&}kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q'T!eR2^-Qv!nQ!e!r!u!x!y'R'Y'Z'g'h'i-Q-W-Y-j1[5]5_S*b$|*hS/t*c*jQ/}*kQ1X,OQ4^/|R4a0PnqOXst!Z#c%j&m&o&p&r,h,m1w1zQ&t!^Q'q!wS(m#t:kQ+c%vQ,Q&YQ,R&[Q-_'_Q-l'jS.g(r;[S0`+O;eQ0n+dQ1Z,PQ2O,oQ2Q,pQ2Y,{Q2g-`Q2j-dS4l0a;oQ4q0oS4t0q;pQ6T2[Q6X2hQ6^2oQ7e4rQ8b6VQ8c6YQ8f6_R9h8_$d$_c#X#d%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PS(j#o'dU*o%R(q3mS+Y%n.tQ2|0hQ6f2{Q8l6iR9o8m$d$^c#X#d%o%q'|(S(n(u(})O)P)Q)R)S)T)U)V)W)X)Z)^)b)l+Z+o-O-m-r-w-y.h.n.r.u.v/V0_2W2Z2k2r3Y3_3`3a3b3c3d3e3f3g3h3i3j3k3n3o3t4k4s6U6[6a6o6p6y6z7r8a8e8n8t8u9k9{:S:e<PS(i#o'dS({#z$_S+X%n.tS.W(h(jQ.w)]Q0e+YR2y.X&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]S#p]:dQ&o!XQ&p!YQ&r![Q&s!]R1v,kQ'[!hQ+[%sQ-]'^S.Y(k+_Q2e-[W2}.].^0g0iQ6W2fU6e2z2|3QS8i6f6hS9m8k8lS:U9l9oQ:^:VR:a:_U!vQ'Z-YT5Z1[5]!Q_OXZ`st!V!Z#c#g%b%j&d&f&m&o&p&r(d,h,m.P1w1z]!pQ!r'Z-Y1[5]T#p]:d%Y{OPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gS(y#y#zS.V(g(h!s;v$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Y!tQ'Z-Y1[5]Q'f!rS'p!u!xS'r!y5_S-i'g'hQ-k'iR2p-jQ'o!tS(`#f1qS-h'f'rQ/f*VQ/r*bQ2q-kQ4O/gS4X/s/}Q7P3yS7[4_4aQ8y7QR9Q7_Q#vbQ'n!tS(_#f1qS(a#l*}Q+P%cQ+a%tQ+g%zU-g'f'o'rQ-{(`Q/e*VQ/q*bQ/w*eQ0m+bQ1b,US2n-h-kQ2v.TS3}/f/gS4W/r/}Q4Z/vQ4]/xQ5g1cQ6`2qQ7O3yQ7S4OS7W4X4aQ7]4`Q8O5hS8x7P7QQ8|7XQ9O7[Q9_8PQ9u8yQ9v8}Q9x9QQ:Q9`Q:Y9wQ;y;tQ<U;}R<V<OV!vQ'Z-Y%YaOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gS#vz!j!r;s$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]R;y<[%YbOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gQ%cj!S%ty!i!t%w%x%y'Q'`'a'b'f'p*b+e+f,}-a-b-i/t0p2b2i2p4^S%zz!jQ+b%uQ,U&_W1c,V,W,X,YU5h1d1e1fS8P5i5jQ9`8Q!r;t$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q;}<ZR<O<[$|eOPXYstuvw!Z!`!g!o#R#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8gY#aWZ#V#Y'}!S%gm#g#h#k%b%e(W(b(c(d+Q+R+T,d,z-x.O.P.Q.S2P2w2x6R6dQ,c&j!p;u$[$m)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]R;x'SS'W!e%fR2`-T%OdOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S,e,h,m-^-f-t-z.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3Z5Y5d5t5u5x6]7w7|8]8g!r)[$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]Q,b&jQ0h+^Q2{.[Q6i3PR8m6j!b$Uc#X%n'|(S(n(u)W)X)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:e!P:r)Z)l-O.t2W2Z3_3i3j3n3t6U6p6y6z7r8a8n8t8u9{:S<P!f$Wc#X%n'|(S(n(u)T)U)W)X)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:e!T:t)Z)l-O.t2W2Z3_3f3g3i3j3n3t6U6p6y6z7r8a8n8t8u9{:S<P!^$[c#X%n'|(S(n(u)^)b+o-m-r-w-y.h.n/V0_2k2r3Y3k4k4s6[6a6o8e9k:eQ3x/az<])Z)l-O.t2W2Z3_3n3t6U6p6y6z7r8a8n8t8u9{:S<PQ<b<dR<c<e&|kOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]S$nh$oR3q.z'TgOPWXYZhstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m$o%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.z.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]T$jf$pQ$hfS)e$k)iR)q$pT$if$pT)g$k)i'ThOPWXYZhstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$[$a$e$m$o%j%p%}&f&i&j&m&o&p&r&v'O'S']'m'}(P(V(^(r(v(z)n)y+O+S+^,e,h,m,y,|-^-f-t-z.[.l.s.z.{0[0a0q1_1o1p1r1t1w1z1|2]2m2s3P3Z3p5W5Y5d5t5u5x6S6]6j7w7|8]8g9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]T$nh$oQ$qhR)p$o%YjOPWXYZstuvw!Z!`!g!o#R#V#Y#c#n#t#x#{$O$P$Q$R$S$T$U$V$W$X$Y$a$e%j%p%}&f&i&j&m&o&p&r&v'O']'m'}(P(V(^(r(v(z)y+O+S+^,e,h,m-^-f-t-z.[.l.s0[0a0q1_1o1p1r1t1w1z1|2m2s3P3Z5Y5d5t5u5x6]6j7w7|8]8g!s<Z$[$m'S)n,y,|.{2]3p5W6S9W9i:c:f:g:j:k:l:m:n:o:p:q:r:s:t:u:v:w:{;Y;Z;[;^;e;f;o;p<]#clOPXZst!Z!`!o#R#c#n#{$m%j&f&i&j&m&o&p&r&v'O'](z)n+S+^,e,h,m-^.[.{0[1_1o1p1r1t1w1z1|3P3p5Y5d5t5u5x6j7w7|8]!O%Ri#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c#W(q#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gQ*z%_Q/W)zo3m:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!O$yi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cQ*[$zS*e$|*hQ*{%`Q/x*f#W;{#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn;|:y:z:};P;T;V;X;`;b;d;h;j;l;n;rQ<Q<^Q<R<_Q<S<`R<T<a!O%Ri#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<c#W(q#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<go3m:y:z:};P;T;V;X;`;b;d;h;j;l;n;rnoOXst!Z#c%j&m&o&p&r,h,m1w1zQ*_${Q,v&yQ,w&{R4R/k$v%Si#u#w$c$d$x${%O%Q%[%]%a)u){)}*P*R*Y*`*p*q+]+`+w+z.Z.i/Z/j/k/m0Q0S0^1R1U1^3O3x4S4[4f4n4p5c6g7T7^7y8j8w9[9n:O:W:y:z:|:};O;P;S;T;U;V;W;X;_;`;a;b;c;d;g;h;i;j;k;l;m;n;q;r<Y<b<c<f<gQ+y&WQ1T+{Q5S1SR7o5TT*g$|*hS*g$|*hT5[1[5]S/v*d5YT4`0O7wQ+a%tQ/w*eQ0m+bQ1b,UQ5g1cQ8O5hQ9_8PR:Q9`!O%Oi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cr)}$v(s*O*n*|/i0U0V3W4P4j6}7`9t;z<W<XS0Q*m0R#W:|#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn:}:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!^;_(o)`*U*^._.b.f/S/X/a/n0f1Q1S3T4Q4U5R5T6k6n7U7Y7b7d8{9P:X<d<e`;`3l6q6t6x8o9p9s:bS;i.a3UT;j6s8r!O%Qi#w%O%Q%[%]%a)}*P*Y*p*q.i/j0Q0S0^3x4f8w<Y<b<cv*P$v(s*Q*m*|/]/i0U0V3W4P4b4j6}7`9t;z<W<XS0S*n0T#W;O#u$c$d$x${)u){*R*`+]+`+w+z.Z/Z/k/m1R1U1^3O4S4[4n4p5c6g7T7^7y8j9[9n:O:W:|;O;S;U;W;_;a;c;g;i;k;m;q<f<gn;P:y:z:};P;T;V;X;`;b;d;h;j;l;n;r!b;a(o)`*U*^.`.a.f/S/X/a/n0f1Q1S3R3T4Q4U5R5T6k6l6n7U7Y7b7d8{9P:X<d<ed;b3l6r6s6x8o8p9p9q9s:bS;k.b3VT;l6t8srnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zQ&a!UR,e&jrnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zR&a!UQ+}&XR1P+vsnOXst!V!Z#c%j&d&m&o&p&r,h,m1w1zQ1],SS5b1`1aU7x5`5a5eS9Z7z7{S9|9Y9]Q:Z9}R:`:[Q&h!VR,^&dR5n1iS%||&RR0x+mQ&m!WR,h&nR,n&sT1x,m1zR,r&tQ,q&tR2R,rQ't!zR-n'tSsOtQ#cXT%ms#cQ!}TR'v!}Q#QUR'x#QQ)w$uR/T)wQ#TVR'z#TQ#WWU(Q#W(R-uQ(R#XR-u(SQ-R'TR2_-RQ.j(sR3X.jQ.m(uS3[.m3]R3].nQ-Y'ZR2c-YY!rQ'Z-Y1[5]R'e!rS#^W%eU(X#^(Y-vQ(Y#_R-v(TQ-U'WR2a-Ut`OXst!V!Z#c%j&d&f&m&o&p&r,h,m1w1zS#gZ%bU#q`#g.PR.P(dQ(e#iQ-|(aW.U(e-|2t6bQ2t-}R6b2uQ)i$kR.|)iQ$ohR)o$oQ$bcU)_$b-q:xQ-q:eR:x)lQ/d*VW3{/d3|7R8zU3|/e/f/gS7R3}4OR8z7S$X)|$v(o(s)`*U*^*m*n*w*x*|.a.b.d.e.f/S/X/]/_/a/i/n0U0V0f1Q1S3R3S3T3W3l4P4Q4U4b4d4j5R5T6k6l6m6n6s6t6v6w6x6}7U7Y7`7b7d8o8p8q8{9P9p9q9r9s9t:X:b;z<W<X<d<eQ/l*^U4T/l4V7VQ4V/nR7V4UQ*h$|R/z*hr*O$v(s*m*n*|/i0U0V3W4P4j6}7`9t;z<W<X!^._(o)`*U*^.a.b.f/S/X/a/n0f1Q1S3T4Q4U5R5T6k6n7U7Y7b7d8{9P:X<d<eU/^*O._6qa6q3l6s6t6x8o9p9s:bQ0R*mQ3U.aU4c0R3U8rR8r6sv*Q$v(s*m*n*|/]/i0U0V3W4P4b4j6}7`9t;z<W<X!b.`(o)`*U*^.a.b.f/S/X/a/n0f1Q1S3R3T4Q4U5R5T6k6l6n7U7Y7b7d8{9P:X<d<eU/`*Q.`6re6r3l6s6t6x8o8p9p9q9s:bQ0T*nQ3V.bU4e0T3V8sR8s6tQ*s%UR0X*sQ4o0fR7c4oQ+U%hR0d+UQ5V1VS7q5V9XR9X7rQ,P&YR1Y,PQ5]1[R7u5]Q1h,ZS5l1h8SR8S5nQ0s+iW4x0s4z7i9TQ4z0vQ7i4yR9T7jQ+n%|R0y+nQ1z,mR5|1zYrOXst#cQ&q!ZQ+W%jQ,g&mQ,i&oQ,j&pQ,l&rQ1u,hS1x,m1zR5{1wQ%lpQ&u!_Q&x!aQ&z!bQ&|!cQ'l!tQ+V%iQ+c%vQ+u&SQ,]&hQ,t&wW-e'f'n'o'rQ-l'jQ/y*gQ0n+dS1k,^,aQ2S,sQ2T,vQ2U,wQ2j-dW2l-g-h-k-mQ4q0oQ4}0|Q5Q1QQ5f1bQ5p1mQ5z1vU6Z2k2n2qQ6^2oQ7e4rQ7m5PQ7n5RQ7t5[Q7}5gQ8T5oS8d6[6`Q8f6_Q9U7kQ9^8OQ9c8UQ9j8eQ9z9VQ:P9_Q:T9kR:]:QQ%vyQ'_!iQ'j!tU+d%w%x%yQ,{'QU-`'`'a'bS-d'f'pQ/p*bS0o+e+fQ2[,}S2h-a-bQ2o-iQ4Y/tQ4r0pQ6V2bQ6Y2iQ6_2pR7Z4^S$wi<YR*t%VU%Ui%V<YR0W*rQ$viS(o#u+`Q(s#wS)`$c$dQ*U$xQ*^${Q*m%OQ*n%QQ*w%[Q*x%]Q*|%aQ.a:|Q.b;OQ.d;SQ.e;UQ.f;WQ/S)uS/X){/ZQ/])}Q/_*PQ/a*RQ/i*YQ/n*`Q0U*pQ0V*qh0f+].Z1^3O5c6g7y8j9[9n:O:WQ1Q+wQ1S+zQ3R;_Q3S;aQ3T;cQ3W.iS3l:y:zQ4P/jQ4Q/kQ4U/mQ4b0QQ4d0SQ4j0^Q5R1RQ5T1UQ6k;gQ6l;iQ6m;kQ6n;mQ6s:}Q6t;PQ6v;TQ6w;VQ6x;XQ6}3xQ7U4SQ7Y4[Q7`4fQ7b4nQ7d4pQ8o;dQ8p;`Q8q;bQ8{7TQ9P7^Q9p;hQ9q;jQ9r;lQ9s;nQ9t8wQ:X;qQ:b;rQ;z<YQ<W<bQ<X<cQ<d<fR<e<gnpOXst!Z#c%j&m&o&p&r,h,m1w1zQ!fPS#eZ#nQ&w!`U'c!o5Y7wQ'y#RQ(|#{Q)m$mS,a&f&iQ,f&jQ,s&vQ,x'OQ-[']Q.p(zQ/Q)nQ0b+SQ0i+^Q1s,eQ2f-^Q2|.[Q3s.{Q4h0[Q5a1_Q5r1oQ5s1pQ5w1rQ5y1tQ6O1|Q6f3PQ6{3pQ7{5dQ8X5tQ8Y5uQ8[5xQ8l6jQ9]7|R9g8]#WcOPXZst!Z!`!o#c#n#{%j&f&i&j&m&o&p&r&v'O'](z+S+^,e,h,m-^.[0[1_1o1p1r1t1w1z1|3P5Y5d5t5u5x6j7w7|8]Q#XWQ#dYQ%nuQ%ovS%qw!gS'|#V(PQ(S#YQ(n#tQ(u#xQ(}$OQ)O$PQ)P$QQ)Q$RQ)R$SQ)S$TQ)T$UQ)U$VQ)V$WQ)W$XQ)X$YQ)Z$[Q)^$aQ)b$eW)l$m)n.{3pQ+Z%pQ+o%}S-O'S2]Q-m'mS-r'}-tQ-w(VQ-y(^Q.h(rQ.n(vQ.r:cQ.t:fQ.u:gQ.v:jQ/V)yQ0_+OQ2W,yQ2Z,|Q2k-fQ2r-zQ3Y.lQ3_:kQ3`:lQ3a:mQ3b:nQ3c:oQ3d:pQ3e:qQ3f:rQ3g:sQ3h:tQ3i:uQ3j:vQ3k.sQ3n:{Q3o;YQ3t:wQ4k0aQ4s0qQ6U;ZQ6[2mQ6a2sQ6o3ZQ6p;[Q6y;^Q6z;eQ7r5WQ8a6SQ8e6]Q8n;fQ8t;oQ8u;pQ9k8gQ9{9WQ:S9iQ:e#RR<P<]R#ZWR'U!eY!tQ'Z-Y1[5]S'Q!e-QQ'f!rS'p!u!xS'r!y5_S,}'R'YS-i'g'hQ-k'iQ2b-WR2p-jR(t#wR(w#xQ!fQT-X'Z-Y]!qQ!r'Z-Y1[5]Q#o]R'd:dT#jZ%bS#iZ%bS%hm,dU(a#g#h#kS-}(b(cQ.R(dQ0c+TQ2u.OU2v.P.Q.SS6c2w2xR8h6d`#]W#V#Y%e'}(W+Q-xr#fZm#g#h#k%b(b(c(d+T.O.P.Q.S2w2x6dQ1q,dQ2X,zQ6Q2PQ8`6RT;w'S+RT#`W%eS#_W%eS(O#V(WS(T#Y+QS-P'S+RT-s'}-xT'X!e%fQ$kfR)s$pT)h$k)iR3r.zT*X$x*ZR*a${Q0g+]Q2z.ZQ5`1^Q6h3OQ7z5cQ8k6gQ9Y7yQ9l8jQ9}9[Q:V9nQ:[:OR:_:WnqOXst!Z#c%j&m&o&p&r,h,m1w1zQ&g!VR,]&dtmOXst!U!V!Z#c%j&d&m&o&p&r,h,m1w1zR,d&jT%im,dR1W+|R,[&bQ&Q|R+t&RR+j%{T&k!W&nT&l!W&nT1y,m1z\",\n  nodeNames: \" ArithOp ArithOp JSXStartTag LineComment BlockComment Script Hashbang ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > < TypeParamList TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . ?. PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewExpression new TypeArgList CompareOp < ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem\",\n  maxTerm: 371,\n  context: B3,\n  nodeProps: [\n    [\"isolate\", -8, 4, 5, 13, 33, 35, 48, 50, 52, \"\"],\n    [\"group\", -26, 8, 16, 18, 65, 201, 205, 209, 210, 212, 215, 218, 228, 230, 236, 238, 240, 242, 245, 251, 257, 259, 261, 263, 265, 267, 268, \"Statement\", -32, 12, 13, 28, 31, 32, 38, 48, 51, 52, 54, 59, 67, 75, 79, 81, 83, 84, 106, 107, 116, 117, 134, 137, 139, 140, 141, 142, 144, 145, 164, 165, 167, \"Expression\", -23, 27, 29, 33, 37, 39, 41, 168, 170, 172, 173, 175, 176, 177, 179, 180, 181, 183, 184, 185, 195, 197, 199, 200, \"Type\", -3, 87, 99, 105, \"ClassItem\"],\n    [\"openedBy\", 22, \"<\", 34, \"InterpolationStart\", 53, \"[\", 57, \"{\", 72, \"(\", 157, \"JSXStartCloseTag\"],\n    [\"closedBy\", 23, \">\", 36, \"InterpolationEnd\", 47, \"]\", 58, \"}\", 73, \")\", 162, \"JSXEndTag\"]\n  ],\n  propSources: [z3],\n  skippedNodes: [0, 4, 5, 271],\n  repeatNodeCount: 37,\n  tokenData: \"$Fj(CSR!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tuEruvJSvwLkwx! Yxy!'iyz!(sz{!)}{|!,q|}!.O}!O!,q!O!P!/Y!P!Q!9j!Q!R#8g!R![#:v![!]#Gv!]!^#IS!^!_#J^!_!`#Ns!`!a$#_!a!b$(l!b!c$,k!c!}Er!}#O$-u#O#P$/P#P#Q$4h#Q#R$5r#R#SEr#S#T$7P#T#o$8Z#o#p$<k#p#q$=a#q#r$>q#r#s$?}#s$f%Z$f$g+g$g#BYEr#BY#BZ$AX#BZ$ISEr$IS$I_$AX$I_$I|Er$I|$I}$Dd$I}$JO$Dd$JO$JTEr$JT$JU$AX$JU$KVEr$KV$KW$AX$KW&FUEr&FU&FV$AX&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$AX?HUOEr(n%d_$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$f&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$f&j(R!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU(R!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$f&j(OpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU(OpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z(CS+rq$f&j(Op(R!b't(;dOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z(CS.ST(P#S$f&j'u(;dO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c(CS.n_$f&j(Op(R!b'u(;dOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`/x`$f&j!o$Ip(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S1V`#t$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S2d_#t$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/|3l_'}$(n$f&j(R!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k(^4r_$f&j(R!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k&z5vX$f&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q&z6jT$a`$f&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c`6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y`7bO$a``7eP;=`<%l6y&z7kP;=`<%l5q(^7w]$a`$f&j(R!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!r8uZ(R!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p!r9oU$a`(R!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!r:UP;=`<%l8p(^:[P;=`<%l4k#%|:hh$f&j(Op(R!bOY%ZYZ&cZq%Zqr<Srs&}st%ZtuCruw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr(r<__VS$f&j(Op(R!bOY<SYZ&cZr<Srs=^sw<Swx@nx!^<S!^!_Bm!_#O<S#O#P>`#P#o<S#o#pBm#p;'S<S;'S;=`Cl<%lO<S(Q=g]VS$f&j(R!bOY=^YZ&cZw=^wx>`x!^=^!^!_?q!_#O=^#O#P>`#P#o=^#o#p?q#p;'S=^;'S;=`@h<%lO=^&n>gXVS$f&jOY>`YZ&cZ!^>`!^!_?S!_#o>`#o#p?S#p;'S>`;'S;=`?k<%lO>`S?XSVSOY?SZ;'S?S;'S;=`?e<%lO?SS?hP;=`<%l?S&n?nP;=`<%l>`!f?xWVS(R!bOY?qZw?qwx?Sx#O?q#O#P?S#P;'S?q;'S;=`@b<%lO?q!f@eP;=`<%l?q(Q@kP;=`<%l=^'`@w]VS$f&j(OpOY@nYZ&cZr@nrs>`s!^@n!^!_Ap!_#O@n#O#P>`#P#o@n#o#pAp#p;'S@n;'S;=`Bg<%lO@ntAwWVS(OpOYApZrAprs?Ss#OAp#O#P?S#P;'SAp;'S;=`Ba<%lOAptBdP;=`<%lAp'`BjP;=`<%l@n#WBvYVS(Op(R!bOYBmZrBmrs?qswBmwxApx#OBm#O#P?S#P;'SBm;'S;=`Cf<%lOBm#WCiP;=`<%lBm(rCoP;=`<%l<S#%|C}i$f&j(g!L^(Op(R!bOY%ZYZ&cZr%Zrs&}st%ZtuCruw%Zwx(rx!Q%Z!Q![Cr![!^%Z!^!_*g!_!c%Z!c!}Cr!}#O%Z#O#P&c#P#R%Z#R#SCr#S#T%Z#T#oCr#o#p*g#p$g%Z$g;'SCr;'S;=`El<%lOCr#%|EoP;=`<%lCr(CSFRk$f&j(Op(R!b$Y#t'{&;d([!LYOY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr+dHRk$f&j(Op(R!b$Y#tOY%ZYZ&cZr%Zrs&}st%ZtuGvuw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Gv![!^%Z!^!_*g!_!c%Z!c!}Gv!}#O%Z#O#P&c#P#R%Z#R#SGv#S#T%Z#T#oGv#o#p*g#p$g%Z$g;'SGv;'S;=`Iv<%lOGv+dIyP;=`<%lGv(CSJPP;=`<%lEr%#SJ_`$f&j(Op(R!b#l$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SKl_$f&j$O$Id(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&COLva(p&;`$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sv%ZvwM{wx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SNW`$f&j#x$Id(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/|! c_(Q$)`$f&j(OpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b'l!!i_$f&j(OpOY!!bYZ!#hZr!!brs!#hsw!!bwx!$xx!^!!b!^!_!%z!_#O!!b#O#P!#h#P#o!!b#o#p!%z#p;'S!!b;'S;=`!'c<%lO!!b&z!#mX$f&jOw!#hwx6cx!^!#h!^!_!$Y!_#o!#h#o#p!$Y#p;'S!#h;'S;=`!$r<%lO!#h`!$]TOw!$Ywx7]x;'S!$Y;'S;=`!$l<%lO!$Y`!$oP;=`<%l!$Y&z!$uP;=`<%l!#h'l!%R]$a`$f&j(OpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r!Q!&PZ(OpOY!%zYZ!$YZr!%zrs!$Ysw!%zwx!&rx#O!%z#O#P!$Y#P;'S!%z;'S;=`!']<%lO!%z!Q!&yU$a`(OpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r!Q!'`P;=`<%l!%z'l!'fP;=`<%l!!b(*Q!'t_!k(!b$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'l!)O_!jM|$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h!*[b$f&j(Op(R!b'|#)d#m$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!+d{!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S!+o`$f&j(Op(R!b#j$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&-O!,|`$f&j(Op(R!bn&%`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&C[!.Z_!Y&;l$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!/ec$f&j(Op(R!b|'<nOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!0p!P!Q%Z!Q![!3Y![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!0ya$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!2O!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!2Z_!XMt$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!3eg$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!3Y![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S!3Y#S#X%Z#X#Y!4|#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!5Vg$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!6n|}%Z}!O!6n!O!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!6wc$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!8_c$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!8S![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!8S#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!9uf$f&j(Op(R!b#k$IdOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpxz!;Zz{#,f{!P!;Z!P!Q#-{!Q!^!;Z!^!_#'Z!_!`#5k!`!a#7Q!a!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(r!;fb$f&j(Op(R!b!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(Q!<w`$f&j(R!b!USOY!<nYZ&cZw!<nwx!=yx!P!<n!P!Q!Eb!Q!^!<n!^!_!GY!_!}!<n!}#O!Ja#O#P!Dj#P#o!<n#o#p!GY#p;'S!<n;'S;=`!Kj<%lO!<n&n!>Q^$f&j!USOY!=yYZ&cZ!P!=y!P!Q!>|!Q!^!=y!^!_!@Y!_!}!=y!}#O!Bw#O#P!Dj#P#o!=y#o#p!@Y#p;'S!=y;'S;=`!E[<%lO!=y&n!?Ta$f&j!USO!^&c!_#Z&c#Z#[!>|#[#]&c#]#^!>|#^#a&c#a#b!>|#b#g&c#g#h!>|#h#i&c#i#j!>|#j#m&c#m#n!>|#n#o&c#p;'S&c;'S;=`&w<%lO&cS!@_X!USOY!@YZ!P!@Y!P!Q!@z!Q!}!@Y!}#O!Ac#O#P!Bb#P;'S!@Y;'S;=`!Bq<%lO!@YS!APU!US#Z#[!@z#]#^!@z#a#b!@z#g#h!@z#i#j!@z#m#n!@zS!AfVOY!AcZ#O!Ac#O#P!A{#P#Q!@Y#Q;'S!Ac;'S;=`!B[<%lO!AcS!BOSOY!AcZ;'S!Ac;'S;=`!B[<%lO!AcS!B_P;=`<%l!AcS!BeSOY!@YZ;'S!@Y;'S;=`!Bq<%lO!@YS!BtP;=`<%l!@Y&n!B|[$f&jOY!BwYZ&cZ!^!Bw!^!_!Ac!_#O!Bw#O#P!Cr#P#Q!=y#Q#o!Bw#o#p!Ac#p;'S!Bw;'S;=`!Dd<%lO!Bw&n!CwX$f&jOY!BwYZ&cZ!^!Bw!^!_!Ac!_#o!Bw#o#p!Ac#p;'S!Bw;'S;=`!Dd<%lO!Bw&n!DgP;=`<%l!Bw&n!DoX$f&jOY!=yYZ&cZ!^!=y!^!_!@Y!_#o!=y#o#p!@Y#p;'S!=y;'S;=`!E[<%lO!=y&n!E_P;=`<%l!=y(Q!Eki$f&j(R!b!USOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#Z&}#Z#[!Eb#[#]&}#]#^!Eb#^#a&}#a#b!Eb#b#g&}#g#h!Eb#h#i&}#i#j!Eb#j#m&}#m#n!Eb#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!f!GaZ(R!b!USOY!GYZw!GYwx!@Yx!P!GY!P!Q!HS!Q!}!GY!}#O!Ic#O#P!Bb#P;'S!GY;'S;=`!JZ<%lO!GY!f!HZb(R!b!USOY'}Zw'}x#O'}#P#Z'}#Z#[!HS#[#]'}#]#^!HS#^#a'}#a#b!HS#b#g'}#g#h!HS#h#i'}#i#j!HS#j#m'}#m#n!HS#n;'S'};'S;=`(f<%lO'}!f!IhX(R!bOY!IcZw!Icwx!Acx#O!Ic#O#P!A{#P#Q!GY#Q;'S!Ic;'S;=`!JT<%lO!Ic!f!JWP;=`<%l!Ic!f!J^P;=`<%l!GY(Q!Jh^$f&j(R!bOY!JaYZ&cZw!Jawx!Bwx!^!Ja!^!_!Ic!_#O!Ja#O#P!Cr#P#Q!<n#Q#o!Ja#o#p!Ic#p;'S!Ja;'S;=`!Kd<%lO!Ja(Q!KgP;=`<%l!Ja(Q!KmP;=`<%l!<n'`!Ky`$f&j(Op!USOY!KpYZ&cZr!Kprs!=ys!P!Kp!P!Q!L{!Q!^!Kp!^!_!Ns!_!}!Kp!}#O##z#O#P!Dj#P#o!Kp#o#p!Ns#p;'S!Kp;'S;=`#%T<%lO!Kp'`!MUi$f&j(Op!USOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#Z(r#Z#[!L{#[#](r#]#^!L{#^#a(r#a#b!L{#b#g(r#g#h!L{#h#i(r#i#j!L{#j#m(r#m#n!L{#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rt!NzZ(Op!USOY!NsZr!Nsrs!@Ys!P!Ns!P!Q# m!Q!}!Ns!}#O#!|#O#P!Bb#P;'S!Ns;'S;=`##t<%lO!Nst# tb(Op!USOY)rZr)rs#O)r#P#Z)r#Z#[# m#[#])r#]#^# m#^#a)r#a#b# m#b#g)r#g#h# m#h#i)r#i#j# m#j#m)r#m#n# m#n;'S)r;'S;=`*Z<%lO)rt##RX(OpOY#!|Zr#!|rs!Acs#O#!|#O#P!A{#P#Q!Ns#Q;'S#!|;'S;=`##n<%lO#!|t##qP;=`<%l#!|t##wP;=`<%l!Ns'`#$R^$f&j(OpOY##zYZ&cZr##zrs!Bws!^##z!^!_#!|!_#O##z#O#P!Cr#P#Q!Kp#Q#o##z#o#p#!|#p;'S##z;'S;=`#$}<%lO##z'`#%QP;=`<%l##z'`#%WP;=`<%l!Kp(r#%fk$f&j(Op(R!b!USOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#Z%Z#Z#[#%Z#[#]%Z#]#^#%Z#^#a%Z#a#b#%Z#b#g%Z#g#h#%Z#h#i%Z#i#j#%Z#j#m%Z#m#n#%Z#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#W#'d](Op(R!b!USOY#'ZZr#'Zrs!GYsw#'Zwx!Nsx!P#'Z!P!Q#(]!Q!}#'Z!}#O#)w#O#P!Bb#P;'S#'Z;'S;=`#*w<%lO#'Z#W#(fe(Op(R!b!USOY*gZr*grs'}sw*gwx)rx#O*g#P#Z*g#Z#[#(]#[#]*g#]#^#(]#^#a*g#a#b#(]#b#g*g#g#h#(]#h#i*g#i#j#(]#j#m*g#m#n#(]#n;'S*g;'S;=`+Z<%lO*g#W#*OZ(Op(R!bOY#)wZr#)wrs!Icsw#)wwx#!|x#O#)w#O#P!A{#P#Q#'Z#Q;'S#)w;'S;=`#*q<%lO#)w#W#*tP;=`<%l#)w#W#*zP;=`<%l#'Z(r#+W`$f&j(Op(R!bOY#*}YZ&cZr#*}rs!Jasw#*}wx##zx!^#*}!^!_#)w!_#O#*}#O#P!Cr#P#Q!;Z#Q#o#*}#o#p#)w#p;'S#*};'S;=`#,Y<%lO#*}(r#,]P;=`<%l#*}(r#,cP;=`<%l!;Z(CS#,sb$f&j(Op(R!b'v(;d!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z(CS#.W_$f&j(Op(R!bS(;dOY#-{YZ&cZr#-{rs#/Vsw#-{wx#2gx!^#-{!^!_#4f!_#O#-{#O#P#0X#P#o#-{#o#p#4f#p;'S#-{;'S;=`#5e<%lO#-{(Bb#/`]$f&j(R!bS(;dOY#/VYZ&cZw#/Vwx#0Xx!^#/V!^!_#1j!_#O#/V#O#P#0X#P#o#/V#o#p#1j#p;'S#/V;'S;=`#2a<%lO#/V(AO#0`X$f&jS(;dOY#0XYZ&cZ!^#0X!^!_#0{!_#o#0X#o#p#0{#p;'S#0X;'S;=`#1d<%lO#0X(;d#1QSS(;dOY#0{Z;'S#0{;'S;=`#1^<%lO#0{(;d#1aP;=`<%l#0{(AO#1gP;=`<%l#0X(<v#1qW(R!bS(;dOY#1jZw#1jwx#0{x#O#1j#O#P#0{#P;'S#1j;'S;=`#2Z<%lO#1j(<v#2^P;=`<%l#1j(Bb#2dP;=`<%l#/V(Ap#2p]$f&j(OpS(;dOY#2gYZ&cZr#2grs#0Xs!^#2g!^!_#3i!_#O#2g#O#P#0X#P#o#2g#o#p#3i#p;'S#2g;'S;=`#4`<%lO#2g(<U#3pW(OpS(;dOY#3iZr#3irs#0{s#O#3i#O#P#0{#P;'S#3i;'S;=`#4Y<%lO#3i(<U#4]P;=`<%l#3i(Ap#4cP;=`<%l#2g(=h#4oY(Op(R!bS(;dOY#4fZr#4frs#1jsw#4fwx#3ix#O#4f#O#P#0{#P;'S#4f;'S;=`#5_<%lO#4f(=h#5bP;=`<%l#4f(CS#5hP;=`<%l#-{%#W#5xb$f&j$O$Id(Op(R!b!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z+h#7_b$W#t$f&j(Op(R!b!USOY!;ZYZ&cZr!;Zrs!<nsw!;Zwx!Kpx!P!;Z!P!Q#%Z!Q!^!;Z!^!_#'Z!_!}!;Z!}#O#*}#O#P!Dj#P#o!;Z#o#p#'Z#p;'S!;Z;'S;=`#,`<%lO!;Z$/l#8rp$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#:v![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#:v#S#U%Z#U#V#>Q#V#X%Z#X#Y!4|#Y#b%Z#b#c#<v#c#d#AY#d#l%Z#l#m#D[#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#;Rk$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!3Y!P!Q%Z!Q![#:v![!^%Z!^!_*g!_!g%Z!g!h!4|!h#O%Z#O#P&c#P#R%Z#R#S#:v#S#X%Z#X#Y!4|#Y#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#=R_$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#>Zd$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#?i!R!S#?i!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#?i#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#?tf$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#?i!R!S#?i!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#?i#S#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Acc$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#Bn!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#Bn#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Bye$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#Bn!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#Bn#S#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#Deg$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#E|![!^%Z!^!_*g!_!c%Z!c!i#E|!i#O%Z#O#P&c#P#R%Z#R#S#E|#S#T%Z#T#Z#E|#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#FXi$f&j(Op(R!bo$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#E|![!^%Z!^!_*g!_!c%Z!c!i#E|!i#O%Z#O#P&c#P#R%Z#R#S#E|#S#T%Z#T#Z#E|#Z#b%Z#b#c#<v#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh#HT_!d$b$f&j#|%<f(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#I__`l$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(@^#Jk^g!*v!h'.r(Op(R!b(tSOY*gZr*grs'}sw*gwx)rx!P*g!P!Q#Kg!Q!^*g!^!_#L]!_!`#M}!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#KpX$h&j(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#LfZ#n$Id(Op(R!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#MX!`#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#MbX$O$Id(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#NWX#o$Id(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g%Gh$ Oa#[%?x$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a$!T!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#W$!`_#g$Ih$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh$#nafBf#o$Id$c#|$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`$$s!`!a$%}!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$%O_#o$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$&Ya#n$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`!a$'_!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$'j`#n$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h$(wc(h$Ip$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P$*S!P!^%Z!^!_*g!_!a%Z!a!b$+^!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+`$*__}'#p$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$+i`$f&j#y$Id(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&^$,v_!{!Ln$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(@^$.Q_!P(8n$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$/UZ$f&jO!^$/w!^!_$0_!_#i$/w#i#j$0d#j#l$/w#l#m$2V#m#o$/w#o#p$0_#p;'S$/w;'S;=`$4b<%lO$/w(n$0OT^#S$f&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$0dO^#S(n$0i[$f&jO!Q&c!Q![$1_![!^&c!_!c&c!c!i$1_!i#T&c#T#Z$1_#Z#o&c#o#p$3u#p;'S&c;'S;=`&w<%lO&c(n$1dZ$f&jO!Q&c!Q![$2V![!^&c!_!c&c!c!i$2V!i#T&c#T#Z$2V#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$2[Z$f&jO!Q&c!Q![$2}![!^&c!_!c&c!c!i$2}!i#T&c#T#Z$2}#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$3SZ$f&jO!Q&c!Q![$/w![!^&c!_!c&c!c!i$/w!i#T&c#T#Z$/w#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$3xR!Q![$4R!c!i$4R#T#Z$4R#S$4US!Q![$4R!c!i$4R#T#Z$4R#q#r$0_(n$4eP;=`<%l$/w!2r$4s_!V!+S$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$5}`#v$Id$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&,v$7[_$f&j(Op(R!b(X&%WOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$8jk$f&j(Op(R!b'{&;d$[#t([!LYOY%ZYZ&cZr%Zrs&}st%Ztu$8Zuw%Zwx(rx}%Z}!O$:_!O!Q%Z!Q![$8Z![!^%Z!^!_*g!_!c%Z!c!}$8Z!}#O%Z#O#P&c#P#R%Z#R#S$8Z#S#T%Z#T#o$8Z#o#p*g#p$g%Z$g;'S$8Z;'S;=`$<e<%lO$8Z+d$:jk$f&j(Op(R!b$[#tOY%ZYZ&cZr%Zrs&}st%Ztu$:_uw%Zwx(rx}%Z}!O$:_!O!Q%Z!Q![$:_![!^%Z!^!_*g!_!c%Z!c!}$:_!}#O%Z#O#P&c#P#R%Z#R#S$:_#S#T%Z#T#o$:_#o#p*g#p$g%Z$g;'S$:_;'S;=`$<_<%lO$:_+d$<bP;=`<%l$:_(CS$<hP;=`<%l$8Z!5p$<tX![!3l(Op(R!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g&CO$=la(o&;`$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Ka!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$+^#q;'S%Z;'S;=`+a<%lO%Z%#`$?O_!Z$I`r`$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(r$@Y_!pS$f&j(Op(R!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$Aj|$f&j(Op(R!b't(;d$Y#t'{&;d([!LYOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$f%Z$f$g+g$g#BYEr#BY#BZ$AX#BZ$ISEr$IS$I_$AX$I_$JTEr$JT$JU$AX$JU$KVEr$KV$KW$AX$KW&FUEr&FU&FV$AX&FV;'SEr;'S;=`I|<%l?HTEr?HT?HU$AX?HUOEr(CS$Duk$f&j(Op(R!b'u(;d$Y#t'{&;d([!LYOY%ZYZ&cZr%Zrs&}st%ZtuEruw%Zwx(rx}%Z}!OGv!O!Q%Z!Q![Er![!^%Z!^!_*g!_!c%Z!c!}Er!}#O%Z#O#P&c#P#R%Z#R#SEr#S#T%Z#T#oEr#o#p*g#p$g%Z$g;'SEr;'S;=`I|<%lOEr\",\n  tokenizers: [U3, q3, Y3, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, L3, new Hu(\"$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOt~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!R~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(Z~~\", 141, 332), new Hu(\"j~RQYZXz{^~^O'x~~aP!P!Qd~iO'y~~\", 25, 315)],\n  topRules: { Script: [0, 6], SingleExpression: [1, 269], SingleClassItem: [2, 270] },\n  dialects: { jsx: 0, ts: 14614 },\n  dynamicPrecedences: { 69: 1, 79: 1, 81: 1, 165: 1, 193: 1 },\n  specialized: [{ term: 319, get: (t) => H3[t] || -1 }, { term: 334, get: (t) => F3[t] || -1 }, { term: 70, get: (t) => G3[t] || -1 }],\n  tokenPrec: 14638\n}), Gx = [\n  /* @__PURE__ */ vn(\"function ${name}(${params}) {\\n\t${}\\n}\", {\n    label: \"function\",\n    detail: \"definition\",\n    type: \"keyword\"\n  }),\n  /* @__PURE__ */ vn(\"for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\\n\t${}\\n}\", {\n    label: \"for\",\n    detail: \"loop\",\n    type: \"keyword\"\n  }),\n  /* @__PURE__ */ vn(\"for (let ${name} of ${collection}) {\\n\t${}\\n}\", {\n    label: \"for\",\n    detail: \"of loop\",\n    type: \"keyword\"\n  }),\n  /* @__PURE__ */ vn(\"do {\\n\t${}\\n} while (${})\", {\n    label: \"do\",\n    detail: \"loop\",\n    type: \"keyword\"\n  }),\n  /* @__PURE__ */ vn(\"while (${}) {\\n\t${}\\n}\", {\n    label: \"while\",\n    detail: \"loop\",\n    type: \"keyword\"\n  }),\n  /* @__PURE__ */ vn(`try {\n\t\\${}\n} catch (\\${error}) {\n\t\\${}\n}`, {\n    label: \"try\",\n    detail: \"/ catch block\",\n    type: \"keyword\"\n  }),\n  /* @__PURE__ */ vn(\"if (${}) {\\n\t${}\\n}\", {\n    label: \"if\",\n    detail: \"block\",\n    type: \"keyword\"\n  }),\n  /* @__PURE__ */ vn(`if (\\${}) {\n\t\\${}\n} else {\n\t\\${}\n}`, {\n    label: \"if\",\n    detail: \"/ else block\",\n    type: \"keyword\"\n  }),\n  /* @__PURE__ */ vn(`class \\${name} {\n\tconstructor(\\${params}) {\n\t\t\\${}\n\t}\n}`, {\n    label: \"class\",\n    detail: \"definition\",\n    type: \"keyword\"\n  }),\n  /* @__PURE__ */ vn('import {${names}} from \"${module}\"\\n${}', {\n    label: \"import\",\n    detail: \"named\",\n    type: \"keyword\"\n  }),\n  /* @__PURE__ */ vn('import ${name} from \"${module}\"\\n${}', {\n    label: \"import\",\n    detail: \"default\",\n    type: \"keyword\"\n  })\n], J3 = /* @__PURE__ */ Gx.concat([\n  /* @__PURE__ */ vn(\"interface ${name} {\\n\t${}\\n}\", {\n    label: \"interface\",\n    detail: \"definition\",\n    type: \"keyword\"\n  }),\n  /* @__PURE__ */ vn(\"type ${name} = ${type}\", {\n    label: \"type\",\n    detail: \"definition\",\n    type: \"keyword\"\n  }),\n  /* @__PURE__ */ vn(\"enum ${name} {\\n\t${}\\n}\", {\n    label: \"enum\",\n    detail: \"definition\",\n    type: \"keyword\"\n  })\n]), w0 = /* @__PURE__ */ new ex(), Kx = /* @__PURE__ */ new Set([\n  \"Script\",\n  \"Block\",\n  \"FunctionExpression\",\n  \"FunctionDeclaration\",\n  \"ArrowFunction\",\n  \"MethodDeclaration\",\n  \"ForStatement\"\n]);\nfunction ka(t) {\n  return (e, n) => {\n    let r = e.node.getChild(\"VariableDefinition\");\n    return r && n(r, t), !0;\n  };\n}\nconst eI = [\"FunctionDeclaration\"], tI = {\n  FunctionDeclaration: /* @__PURE__ */ ka(\"function\"),\n  ClassDeclaration: /* @__PURE__ */ ka(\"class\"),\n  ClassExpression: () => !0,\n  EnumDeclaration: /* @__PURE__ */ ka(\"constant\"),\n  TypeAliasDeclaration: /* @__PURE__ */ ka(\"type\"),\n  NamespaceDeclaration: /* @__PURE__ */ ka(\"namespace\"),\n  VariableDefinition(t, e) {\n    t.matchContext(eI) || e(t, \"variable\");\n  },\n  TypeDefinition(t, e) {\n    e(t, \"type\");\n  },\n  __proto__: null\n};\nfunction Jx(t, e) {\n  let n = w0.get(e);\n  if (n)\n    return n;\n  let r = [], i = !0;\n  function s(o, a) {\n    let l = t.sliceString(o.from, o.to);\n    r.push({ label: l, type: a });\n  }\n  return e.cursor(lt.IncludeAnonymous).iterate((o) => {\n    if (i)\n      i = !1;\n    else if (o.name) {\n      let a = tI[o.name];\n      if (a && a(o, s) || Kx.has(o.name))\n        return !1;\n    } else if (o.to - o.from > 8192) {\n      for (let a of Jx(t, o.node))\n        r.push(a);\n      return !1;\n    }\n  }), w0.set(e, r), r;\n}\nconst k0 = /^[\\w$\\xa1-\\uffff][\\w$\\d\\xa1-\\uffff]*$/, eP = [\n  \"TemplateString\",\n  \"String\",\n  \"RegExp\",\n  \"LineComment\",\n  \"BlockComment\",\n  \"VariableDefinition\",\n  \"TypeDefinition\",\n  \"Label\",\n  \"PropertyDefinition\",\n  \"PropertyName\",\n  \"PrivatePropertyDefinition\",\n  \"PrivatePropertyName\",\n  \".\",\n  \"?.\"\n];\nfunction nI(t) {\n  let e = un(t.state).resolveInner(t.pos, -1);\n  if (eP.indexOf(e.name) > -1)\n    return null;\n  let n = e.name == \"VariableName\" || e.to - e.from < 20 && k0.test(t.state.sliceDoc(e.from, e.to));\n  if (!n && !t.explicit)\n    return null;\n  let r = [];\n  for (let i = e; i; i = i.parent)\n    Kx.has(i.name) && (r = r.concat(Jx(t.state.doc, i)));\n  return {\n    options: r,\n    from: n ? e.from : t.pos,\n    validFor: k0\n  };\n}\nconst Ir = /* @__PURE__ */ cs.define({\n  name: \"javascript\",\n  parser: /* @__PURE__ */ K3.configure({\n    props: [\n      /* @__PURE__ */ sa.add({\n        IfStatement: /* @__PURE__ */ $o({ except: /^\\s*({|else\\b)/ }),\n        TryStatement: /* @__PURE__ */ $o({ except: /^\\s*({|catch\\b|finally\\b)/ }),\n        LabeledStatement: FD,\n        SwitchBody: (t) => {\n          let e = t.textAfter, n = /^\\s*\\}/.test(e), r = /^\\s*(case|default)\\b/.test(e);\n          return t.baseIndent + (n ? 0 : r ? 1 : 2) * t.unit;\n        },\n        Block: /* @__PURE__ */ xp({ closing: \"}\" }),\n        ArrowFunction: (t) => t.baseIndent + t.unit,\n        \"TemplateString BlockComment\": () => null,\n        \"Statement Property\": /* @__PURE__ */ $o({ except: /^{/ }),\n        JSXElement(t) {\n          let e = /^\\s*<\\//.test(t.textAfter);\n          return t.lineIndent(t.node.from) + (e ? 0 : t.unit);\n        },\n        JSXEscape(t) {\n          let e = /\\s*\\}/.test(t.textAfter);\n          return t.lineIndent(t.node.from) + (e ? 0 : t.unit);\n        },\n        \"JSXOpenTag JSXSelfClosingTag\"(t) {\n          return t.column(t.node.from) + t.unit;\n        }\n      }),\n      /* @__PURE__ */ Kl.add({\n        \"Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression ObjectType\": Hd,\n        BlockComment(t) {\n          return { from: t.from + 2, to: t.to - 2 };\n        }\n      })\n    ]\n  }),\n  languageData: {\n    closeBrackets: { brackets: [\"(\", \"[\", \"{\", \"'\", '\"', \"`\"] },\n    commentTokens: { line: \"//\", block: { open: \"/*\", close: \"*/\" } },\n    indentOnInput: /^\\s*(?:case |default:|\\{|\\}|<\\/)$/,\n    wordChars: \"$\"\n  }\n}), tP = {\n  test: (t) => /^JSX/.test(t.name),\n  facet: /* @__PURE__ */ sx({ commentTokens: { block: { open: \"{/*\", close: \"*/}\" } } })\n}, nP = /* @__PURE__ */ Ir.configure({ dialect: \"ts\" }, \"typescript\"), rP = /* @__PURE__ */ Ir.configure({\n  dialect: \"jsx\",\n  props: [/* @__PURE__ */ gg.add((t) => t.isTop ? [tP] : void 0)]\n}), iP = /* @__PURE__ */ Ir.configure({\n  dialect: \"jsx ts\",\n  props: [/* @__PURE__ */ gg.add((t) => t.isTop ? [tP] : void 0)]\n}, \"typescript\");\nlet sP = (t) => ({ label: t, type: \"keyword\" });\nconst oP = /* @__PURE__ */ \"break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield\".split(\" \").map(sP), rI = /* @__PURE__ */ oP.concat(/* @__PURE__ */ [\"declare\", \"implements\", \"private\", \"protected\", \"public\"].map(sP));\nfunction iI(t = {}) {\n  let e = t.jsx ? t.typescript ? iP : rP : t.typescript ? nP : Ir, n = t.typescript ? J3.concat(rI) : Gx.concat(oP);\n  return new Gl(e, [\n    Ir.data.of({\n      autocomplete: OZ(eP, vx(n))\n    }),\n    Ir.data.of({\n      autocomplete: nI\n    }),\n    t.jsx ? aI : []\n  ]);\n}\nfunction sI(t) {\n  for (; ; ) {\n    if (t.name == \"JSXOpenTag\" || t.name == \"JSXSelfClosingTag\" || t.name == \"JSXFragmentTag\")\n      return t;\n    if (t.name == \"JSXEscape\" || !t.parent)\n      return null;\n    t = t.parent;\n  }\n}\nfunction x0(t, e, n = t.length) {\n  for (let r = e == null ? void 0 : e.firstChild; r; r = r.nextSibling)\n    if (r.name == \"JSXIdentifier\" || r.name == \"JSXBuiltin\" || r.name == \"JSXNamespacedName\" || r.name == \"JSXMemberExpression\")\n      return t.sliceString(r.from, Math.min(r.to, n));\n  return \"\";\n}\nconst oI = typeof navigator == \"object\" && /* @__PURE__ */ /Android\\b/.test(navigator.userAgent), aI = /* @__PURE__ */ Se.inputHandler.of((t, e, n, r, i) => {\n  if ((oI ? t.composing : t.compositionStarted) || t.state.readOnly || e != n || r != \">\" && r != \"/\" || !Ir.isActiveAt(t.state, e, -1))\n    return !1;\n  let s = i(), { state: o } = s, a = o.changeByRange((l) => {\n    var c;\n    let { head: u } = l, d = un(o).resolveInner(u - 1, -1), f;\n    if (d.name == \"JSXStartTag\" && (d = d.parent), !(o.doc.sliceString(u - 1, u) != r || d.name == \"JSXAttributeValue\" && d.to > u)) {\n      if (r == \">\" && d.name == \"JSXFragmentTag\")\n        return { range: l, changes: { from: u, insert: \"</>\" } };\n      if (r == \"/\" && d.name == \"JSXStartCloseTag\") {\n        let h = d.parent, p = h.parent;\n        if (p && h.from == u - 2 && ((f = x0(o.doc, p.firstChild, u)) || ((c = p.firstChild) === null || c === void 0 ? void 0 : c.name) == \"JSXFragmentTag\")) {\n          let O = `${f}>`;\n          return { range: ae.cursor(u + O.length, -1), changes: { from: u, insert: O } };\n        }\n      } else if (r == \">\") {\n        let h = sI(d);\n        if (h && h.name == \"JSXOpenTag\" && !/^\\/?>|^<\\//.test(o.doc.sliceString(u, u + 2)) && (f = x0(o.doc, h, u)))\n          return { range: l, changes: { from: u, insert: `</${f}>` } };\n      }\n    }\n    return { range: l };\n  });\n  return a.changes.empty ? !1 : (t.dispatch([\n    s,\n    o.update(a, { userEvent: \"input.complete\", scrollIntoView: !0 })\n  ]), !0);\n}), xa = [\"_blank\", \"_self\", \"_top\", \"_parent\"], Hf = [\"ascii\", \"utf-8\", \"utf-16\", \"latin1\", \"latin1\"], Ff = [\"get\", \"post\", \"put\", \"delete\"], Gf = [\"application/x-www-form-urlencoded\", \"multipart/form-data\", \"text/plain\"], Cn = [\"true\", \"false\"], fe = {}, lI = {\n  a: {\n    attrs: {\n      href: null,\n      ping: null,\n      type: null,\n      media: null,\n      target: xa,\n      hreflang: null\n    }\n  },\n  abbr: fe,\n  address: fe,\n  area: {\n    attrs: {\n      alt: null,\n      coords: null,\n      href: null,\n      target: null,\n      ping: null,\n      media: null,\n      hreflang: null,\n      type: null,\n      shape: [\"default\", \"rect\", \"circle\", \"poly\"]\n    }\n  },\n  article: fe,\n  aside: fe,\n  audio: {\n    attrs: {\n      src: null,\n      mediagroup: null,\n      crossorigin: [\"anonymous\", \"use-credentials\"],\n      preload: [\"none\", \"metadata\", \"auto\"],\n      autoplay: [\"autoplay\"],\n      loop: [\"loop\"],\n      controls: [\"controls\"]\n    }\n  },\n  b: fe,\n  base: { attrs: { href: null, target: xa } },\n  bdi: fe,\n  bdo: fe,\n  blockquote: { attrs: { cite: null } },\n  body: fe,\n  br: fe,\n  button: {\n    attrs: {\n      form: null,\n      formaction: null,\n      name: null,\n      value: null,\n      autofocus: [\"autofocus\"],\n      disabled: [\"autofocus\"],\n      formenctype: Gf,\n      formmethod: Ff,\n      formnovalidate: [\"novalidate\"],\n      formtarget: xa,\n      type: [\"submit\", \"reset\", \"button\"]\n    }\n  },\n  canvas: { attrs: { width: null, height: null } },\n  caption: fe,\n  center: fe,\n  cite: fe,\n  code: fe,\n  col: { attrs: { span: null } },\n  colgroup: { attrs: { span: null } },\n  command: {\n    attrs: {\n      type: [\"command\", \"checkbox\", \"radio\"],\n      label: null,\n      icon: null,\n      radiogroup: null,\n      command: null,\n      title: null,\n      disabled: [\"disabled\"],\n      checked: [\"checked\"]\n    }\n  },\n  data: { attrs: { value: null } },\n  datagrid: { attrs: { disabled: [\"disabled\"], multiple: [\"multiple\"] } },\n  datalist: { attrs: { data: null } },\n  dd: fe,\n  del: { attrs: { cite: null, datetime: null } },\n  details: { attrs: { open: [\"open\"] } },\n  dfn: fe,\n  div: fe,\n  dl: fe,\n  dt: fe,\n  em: fe,\n  embed: { attrs: { src: null, type: null, width: null, height: null } },\n  eventsource: { attrs: { src: null } },\n  fieldset: { attrs: { disabled: [\"disabled\"], form: null, name: null } },\n  figcaption: fe,\n  figure: fe,\n  footer: fe,\n  form: {\n    attrs: {\n      action: null,\n      name: null,\n      \"accept-charset\": Hf,\n      autocomplete: [\"on\", \"off\"],\n      enctype: Gf,\n      method: Ff,\n      novalidate: [\"novalidate\"],\n      target: xa\n    }\n  },\n  h1: fe,\n  h2: fe,\n  h3: fe,\n  h4: fe,\n  h5: fe,\n  h6: fe,\n  head: {\n    children: [\"title\", \"base\", \"link\", \"style\", \"meta\", \"script\", \"noscript\", \"command\"]\n  },\n  header: fe,\n  hgroup: fe,\n  hr: fe,\n  html: {\n    attrs: { manifest: null }\n  },\n  i: fe,\n  iframe: {\n    attrs: {\n      src: null,\n      srcdoc: null,\n      name: null,\n      width: null,\n      height: null,\n      sandbox: [\"allow-top-navigation\", \"allow-same-origin\", \"allow-forms\", \"allow-scripts\"],\n      seamless: [\"seamless\"]\n    }\n  },\n  img: {\n    attrs: {\n      alt: null,\n      src: null,\n      ismap: null,\n      usemap: null,\n      width: null,\n      height: null,\n      crossorigin: [\"anonymous\", \"use-credentials\"]\n    }\n  },\n  input: {\n    attrs: {\n      alt: null,\n      dirname: null,\n      form: null,\n      formaction: null,\n      height: null,\n      list: null,\n      max: null,\n      maxlength: null,\n      min: null,\n      name: null,\n      pattern: null,\n      placeholder: null,\n      size: null,\n      src: null,\n      step: null,\n      value: null,\n      width: null,\n      accept: [\"audio/*\", \"video/*\", \"image/*\"],\n      autocomplete: [\"on\", \"off\"],\n      autofocus: [\"autofocus\"],\n      checked: [\"checked\"],\n      disabled: [\"disabled\"],\n      formenctype: Gf,\n      formmethod: Ff,\n      formnovalidate: [\"novalidate\"],\n      formtarget: xa,\n      multiple: [\"multiple\"],\n      readonly: [\"readonly\"],\n      required: [\"required\"],\n      type: [\n        \"hidden\",\n        \"text\",\n        \"search\",\n        \"tel\",\n        \"url\",\n        \"email\",\n        \"password\",\n        \"datetime\",\n        \"date\",\n        \"month\",\n        \"week\",\n        \"time\",\n        \"datetime-local\",\n        \"number\",\n        \"range\",\n        \"color\",\n        \"checkbox\",\n        \"radio\",\n        \"file\",\n        \"submit\",\n        \"image\",\n        \"reset\",\n        \"button\"\n      ]\n    }\n  },\n  ins: { attrs: { cite: null, datetime: null } },\n  kbd: fe,\n  keygen: {\n    attrs: {\n      challenge: null,\n      form: null,\n      name: null,\n      autofocus: [\"autofocus\"],\n      disabled: [\"disabled\"],\n      keytype: [\"RSA\"]\n    }\n  },\n  label: { attrs: { for: null, form: null } },\n  legend: fe,\n  li: { attrs: { value: null } },\n  link: {\n    attrs: {\n      href: null,\n      type: null,\n      hreflang: null,\n      media: null,\n      sizes: [\"all\", \"16x16\", \"16x16 32x32\", \"16x16 32x32 64x64\"]\n    }\n  },\n  map: { attrs: { name: null } },\n  mark: fe,\n  menu: { attrs: { label: null, type: [\"list\", \"context\", \"toolbar\"] } },\n  meta: {\n    attrs: {\n      content: null,\n      charset: Hf,\n      name: [\"viewport\", \"application-name\", \"author\", \"description\", \"generator\", \"keywords\"],\n      \"http-equiv\": [\"content-language\", \"content-type\", \"default-style\", \"refresh\"]\n    }\n  },\n  meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },\n  nav: fe,\n  noscript: fe,\n  object: {\n    attrs: {\n      data: null,\n      type: null,\n      name: null,\n      usemap: null,\n      form: null,\n      width: null,\n      height: null,\n      typemustmatch: [\"typemustmatch\"]\n    }\n  },\n  ol: {\n    attrs: { reversed: [\"reversed\"], start: null, type: [\"1\", \"a\", \"A\", \"i\", \"I\"] },\n    children: [\"li\", \"script\", \"template\", \"ul\", \"ol\"]\n  },\n  optgroup: { attrs: { disabled: [\"disabled\"], label: null } },\n  option: { attrs: { disabled: [\"disabled\"], label: null, selected: [\"selected\"], value: null } },\n  output: { attrs: { for: null, form: null, name: null } },\n  p: fe,\n  param: { attrs: { name: null, value: null } },\n  pre: fe,\n  progress: { attrs: { value: null, max: null } },\n  q: { attrs: { cite: null } },\n  rp: fe,\n  rt: fe,\n  ruby: fe,\n  samp: fe,\n  script: {\n    attrs: {\n      type: [\"text/javascript\"],\n      src: null,\n      async: [\"async\"],\n      defer: [\"defer\"],\n      charset: Hf\n    }\n  },\n  section: fe,\n  select: {\n    attrs: {\n      form: null,\n      name: null,\n      size: null,\n      autofocus: [\"autofocus\"],\n      disabled: [\"disabled\"],\n      multiple: [\"multiple\"]\n    }\n  },\n  slot: { attrs: { name: null } },\n  small: fe,\n  source: { attrs: { src: null, type: null, media: null } },\n  span: fe,\n  strong: fe,\n  style: {\n    attrs: {\n      type: [\"text/css\"],\n      media: null,\n      scoped: null\n    }\n  },\n  sub: fe,\n  summary: fe,\n  sup: fe,\n  table: fe,\n  tbody: fe,\n  td: { attrs: { colspan: null, rowspan: null, headers: null } },\n  template: fe,\n  textarea: {\n    attrs: {\n      dirname: null,\n      form: null,\n      maxlength: null,\n      name: null,\n      placeholder: null,\n      rows: null,\n      cols: null,\n      autofocus: [\"autofocus\"],\n      disabled: [\"disabled\"],\n      readonly: [\"readonly\"],\n      required: [\"required\"],\n      wrap: [\"soft\", \"hard\"]\n    }\n  },\n  tfoot: fe,\n  th: { attrs: { colspan: null, rowspan: null, headers: null, scope: [\"row\", \"col\", \"rowgroup\", \"colgroup\"] } },\n  thead: fe,\n  time: { attrs: { datetime: null } },\n  title: fe,\n  tr: fe,\n  track: {\n    attrs: {\n      src: null,\n      label: null,\n      default: null,\n      kind: [\"subtitles\", \"captions\", \"descriptions\", \"chapters\", \"metadata\"],\n      srclang: null\n    }\n  },\n  ul: { children: [\"li\", \"script\", \"template\", \"ul\", \"ol\"] },\n  var: fe,\n  video: {\n    attrs: {\n      src: null,\n      poster: null,\n      width: null,\n      height: null,\n      crossorigin: [\"anonymous\", \"use-credentials\"],\n      preload: [\"auto\", \"metadata\", \"none\"],\n      autoplay: [\"autoplay\"],\n      mediagroup: [\"movie\"],\n      muted: [\"muted\"],\n      controls: [\"controls\"]\n    }\n  },\n  wbr: fe\n}, aP = {\n  accesskey: null,\n  class: null,\n  contenteditable: Cn,\n  contextmenu: null,\n  dir: [\"ltr\", \"rtl\", \"auto\"],\n  draggable: [\"true\", \"false\", \"auto\"],\n  dropzone: [\"copy\", \"move\", \"link\", \"string:\", \"file:\"],\n  hidden: [\"hidden\"],\n  id: null,\n  inert: [\"inert\"],\n  itemid: null,\n  itemprop: null,\n  itemref: null,\n  itemscope: [\"itemscope\"],\n  itemtype: null,\n  lang: [\"ar\", \"bn\", \"de\", \"en-GB\", \"en-US\", \"es\", \"fr\", \"hi\", \"id\", \"ja\", \"pa\", \"pt\", \"ru\", \"tr\", \"zh\"],\n  spellcheck: Cn,\n  autocorrect: Cn,\n  autocapitalize: Cn,\n  style: null,\n  tabindex: null,\n  title: null,\n  translate: [\"yes\", \"no\"],\n  rel: [\"stylesheet\", \"alternate\", \"author\", \"bookmark\", \"help\", \"license\", \"next\", \"nofollow\", \"noreferrer\", \"prefetch\", \"prev\", \"search\", \"tag\"],\n  role: /* @__PURE__ */ \"alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer\".split(\" \"),\n  \"aria-activedescendant\": null,\n  \"aria-atomic\": Cn,\n  \"aria-autocomplete\": [\"inline\", \"list\", \"both\", \"none\"],\n  \"aria-busy\": Cn,\n  \"aria-checked\": [\"true\", \"false\", \"mixed\", \"undefined\"],\n  \"aria-controls\": null,\n  \"aria-describedby\": null,\n  \"aria-disabled\": Cn,\n  \"aria-dropeffect\": null,\n  \"aria-expanded\": [\"true\", \"false\", \"undefined\"],\n  \"aria-flowto\": null,\n  \"aria-grabbed\": [\"true\", \"false\", \"undefined\"],\n  \"aria-haspopup\": Cn,\n  \"aria-hidden\": Cn,\n  \"aria-invalid\": [\"true\", \"false\", \"grammar\", \"spelling\"],\n  \"aria-label\": null,\n  \"aria-labelledby\": null,\n  \"aria-level\": null,\n  \"aria-live\": [\"off\", \"polite\", \"assertive\"],\n  \"aria-multiline\": Cn,\n  \"aria-multiselectable\": Cn,\n  \"aria-owns\": null,\n  \"aria-posinset\": null,\n  \"aria-pressed\": [\"true\", \"false\", \"mixed\", \"undefined\"],\n  \"aria-readonly\": Cn,\n  \"aria-relevant\": null,\n  \"aria-required\": Cn,\n  \"aria-selected\": [\"true\", \"false\", \"undefined\"],\n  \"aria-setsize\": null,\n  \"aria-sort\": [\"ascending\", \"descending\", \"none\", \"other\"],\n  \"aria-valuemax\": null,\n  \"aria-valuemin\": null,\n  \"aria-valuenow\": null,\n  \"aria-valuetext\": null\n}, lP = /* @__PURE__ */ \"beforeunload copy cut dragstart dragover dragleave dragenter dragend drag paste focus blur change click load mousedown mouseenter mouseleave mouseup keydown keyup resize scroll unload\".split(\" \").map((t) => \"on\" + t);\nfor (let t of lP)\n  aP[t] = null;\nclass Ju {\n  constructor(e, n) {\n    this.tags = Object.assign(Object.assign({}, lI), e), this.globalAttrs = Object.assign(Object.assign({}, aP), n), this.allTags = Object.keys(this.tags), this.globalAttrNames = Object.keys(this.globalAttrs);\n  }\n}\nJu.default = /* @__PURE__ */ new Ju();\nfunction qo(t, e, n = t.length) {\n  if (!e)\n    return \"\";\n  let r = e.firstChild, i = r && r.getChild(\"TagName\");\n  return i ? t.sliceString(i.from, Math.min(i.to, n)) : \"\";\n}\nfunction Yo(t, e = !1) {\n  for (; t; t = t.parent)\n    if (t.name == \"Element\")\n      if (e)\n        e = !1;\n      else\n        return t;\n  return null;\n}\nfunction cP(t, e, n) {\n  let r = n.tags[qo(t, Yo(e))];\n  return (r == null ? void 0 : r.children) || n.allTags;\n}\nfunction Pg(t, e) {\n  let n = [];\n  for (let r = Yo(e); r && !r.type.isTop; r = Yo(r.parent)) {\n    let i = qo(t, r);\n    if (i && r.lastChild.name == \"CloseTag\")\n      break;\n    i && n.indexOf(i) < 0 && (e.name == \"EndTag\" || e.from >= r.firstChild.to) && n.push(i);\n  }\n  return n;\n}\nconst uP = /^[:\\-\\.\\w\\u00b7-\\uffff]*$/;\nfunction P0(t, e, n, r, i) {\n  let s = /\\s*>/.test(t.sliceDoc(i, i + 5)) ? \"\" : \">\", o = Yo(n, !0);\n  return {\n    from: r,\n    to: i,\n    options: cP(t.doc, o, e).map((a) => ({ label: a, type: \"type\" })).concat(Pg(t.doc, n).map((a, l) => ({\n      label: \"/\" + a,\n      apply: \"/\" + a + s,\n      type: \"type\",\n      boost: 99 - l\n    }))),\n    validFor: /^\\/?[:\\-\\.\\w\\u00b7-\\uffff]*$/\n  };\n}\nfunction _0(t, e, n, r) {\n  let i = /\\s*>/.test(t.sliceDoc(r, r + 5)) ? \"\" : \">\";\n  return {\n    from: n,\n    to: r,\n    options: Pg(t.doc, e).map((s, o) => ({ label: s, apply: s + i, type: \"type\", boost: 99 - o })),\n    validFor: uP\n  };\n}\nfunction cI(t, e, n, r) {\n  let i = [], s = 0;\n  for (let o of cP(t.doc, n, e))\n    i.push({ label: \"<\" + o, type: \"type\" });\n  for (let o of Pg(t.doc, n))\n    i.push({ label: \"</\" + o + \">\", type: \"type\", boost: 99 - s++ });\n  return { from: r, to: r, options: i, validFor: /^<\\/?[:\\-\\.\\w\\u00b7-\\uffff]*$/ };\n}\nfunction uI(t, e, n, r, i) {\n  let s = Yo(n), o = s ? e.tags[qo(t.doc, s)] : null, a = o && o.attrs ? Object.keys(o.attrs) : [], l = o && o.globalAttrs === !1 ? a : a.length ? a.concat(e.globalAttrNames) : e.globalAttrNames;\n  return {\n    from: r,\n    to: i,\n    options: l.map((c) => ({ label: c, type: \"property\" })),\n    validFor: uP\n  };\n}\nfunction dI(t, e, n, r, i) {\n  var s;\n  let o = (s = n.parent) === null || s === void 0 ? void 0 : s.getChild(\"AttributeName\"), a = [], l;\n  if (o) {\n    let c = t.sliceDoc(o.from, o.to), u = e.globalAttrs[c];\n    if (!u) {\n      let d = Yo(n), f = d ? e.tags[qo(t.doc, d)] : null;\n      u = (f == null ? void 0 : f.attrs) && f.attrs[c];\n    }\n    if (u) {\n      let d = t.sliceDoc(r, i).toLowerCase(), f = '\"', h = '\"';\n      /^['\"]/.test(d) ? (l = d[0] == '\"' ? /^[^\"]*$/ : /^[^']*$/, f = \"\", h = t.sliceDoc(i, i + 1) == d[0] ? \"\" : d[0], d = d.slice(1), r++) : l = /^[^\\s<>='\"]*$/;\n      for (let p of u)\n        a.push({ label: p, apply: f + p + h, type: \"constant\" });\n    }\n  }\n  return { from: r, to: i, options: a, validFor: l };\n}\nfunction fI(t, e) {\n  let { state: n, pos: r } = e, i = un(n).resolveInner(r, -1), s = i.resolve(r);\n  for (let o = r, a; s == i && (a = i.childBefore(o)); ) {\n    let l = a.lastChild;\n    if (!l || !l.type.isError || l.from < l.to)\n      break;\n    s = i = a, o = l.from;\n  }\n  return i.name == \"TagName\" ? i.parent && /CloseTag$/.test(i.parent.name) ? _0(n, i, i.from, r) : P0(n, t, i, i.from, r) : i.name == \"StartTag\" ? P0(n, t, i, r, r) : i.name == \"StartCloseTag\" || i.name == \"IncompleteCloseTag\" ? _0(n, i, r, r) : i.name == \"OpenTag\" || i.name == \"SelfClosingTag\" || i.name == \"AttributeName\" ? uI(n, t, i, i.name == \"AttributeName\" ? i.from : r, r) : i.name == \"Is\" || i.name == \"AttributeValue\" || i.name == \"UnquotedAttributeValue\" ? dI(n, t, i, i.name == \"Is\" ? r : i.from, r) : e.explicit && (s.name == \"Element\" || s.name == \"Text\" || s.name == \"Document\") ? cI(n, t, i, r) : null;\n}\nfunction hI(t) {\n  let { extraTags: e, extraGlobalAttributes: n } = t, r = n || e ? new Ju(e, n) : Ju.default;\n  return (i) => fI(r, i);\n}\nconst pI = /* @__PURE__ */ Ir.parser.configure({ top: \"SingleExpression\" }), dP = [\n  {\n    tag: \"script\",\n    attrs: (t) => t.type == \"text/typescript\" || t.lang == \"ts\",\n    parser: nP.parser\n  },\n  {\n    tag: \"script\",\n    attrs: (t) => t.type == \"text/babel\" || t.type == \"text/jsx\",\n    parser: rP.parser\n  },\n  {\n    tag: \"script\",\n    attrs: (t) => t.type == \"text/typescript-jsx\",\n    parser: iP.parser\n  },\n  {\n    tag: \"script\",\n    attrs(t) {\n      return /^(importmap|speculationrules|application\\/(.+\\+)?json)$/i.test(t.type);\n    },\n    parser: pI\n  },\n  {\n    tag: \"script\",\n    attrs(t) {\n      return !t.type || /^(?:text|application)\\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(t.type);\n    },\n    parser: Ir.parser\n  },\n  {\n    tag: \"style\",\n    attrs(t) {\n      return (!t.lang || t.lang == \"css\") && (!t.type || /^(text\\/)?(x-)?(stylesheet|css)$/i.test(t.type));\n    },\n    parser: Fu.parser\n  }\n], fP = /* @__PURE__ */ [\n  {\n    name: \"style\",\n    parser: /* @__PURE__ */ Fu.parser.configure({ top: \"Styles\" })\n  }\n].concat(/* @__PURE__ */ lP.map((t) => ({ name: t, parser: Ir.parser }))), hP = /* @__PURE__ */ cs.define({\n  name: \"html\",\n  parser: /* @__PURE__ */ T3.configure({\n    props: [\n      /* @__PURE__ */ sa.add({\n        Element(t) {\n          let e = /^(\\s*)(<\\/)?/.exec(t.textAfter);\n          return t.node.to <= t.pos + e[0].length ? t.continue() : t.lineIndent(t.node.from) + (e[2] ? 0 : t.unit);\n        },\n        \"OpenTag CloseTag SelfClosingTag\"(t) {\n          return t.column(t.node.from) + t.unit;\n        },\n        Document(t) {\n          if (t.pos + /\\s*/.exec(t.textAfter)[0].length < t.node.to)\n            return t.continue();\n          let e = null, n;\n          for (let r = t.node; ; ) {\n            let i = r.lastChild;\n            if (!i || i.name != \"Element\" || i.to != r.to)\n              break;\n            e = r = i;\n          }\n          return e && !((n = e.lastChild) && (n.name == \"CloseTag\" || n.name == \"SelfClosingTag\")) ? t.lineIndent(e.from) + t.unit : null;\n        }\n      }),\n      /* @__PURE__ */ Kl.add({\n        Element(t) {\n          let e = t.firstChild, n = t.lastChild;\n          return !e || e.name != \"OpenTag\" ? null : { from: e.to, to: n.name == \"CloseTag\" ? n.from : t.to };\n        }\n      }),\n      /* @__PURE__ */ mx.add({\n        \"OpenTag CloseTag\": (t) => t.getChild(\"TagName\")\n      })\n    ]\n  }),\n  languageData: {\n    commentTokens: { block: { open: \"<!--\", close: \"-->\" } },\n    indentOnInput: /^\\s*<\\/\\w+\\W$/,\n    wordChars: \"-._\"\n  }\n}), du = /* @__PURE__ */ hP.configure({\n  wrap: /* @__PURE__ */ Hx(dP, fP)\n});\nfunction OI(t = {}) {\n  let e = \"\", n;\n  t.matchClosingTags === !1 && (e = \"noMatch\"), t.selfClosingTags === !0 && (e = (e ? e + \" \" : \"\") + \"selfClosing\"), (t.nestedLanguages && t.nestedLanguages.length || t.nestedAttributes && t.nestedAttributes.length) && (n = Hx((t.nestedLanguages || []).concat(dP), (t.nestedAttributes || []).concat(fP)));\n  let r = n ? hP.configure({ wrap: n, dialect: e }) : e ? du.configure({ dialect: e }) : du;\n  return new Gl(r, [\n    du.data.of({ autocomplete: hI(t) }),\n    t.autoCloseTags !== !1 ? gI : [],\n    iI().support,\n    Ix().support\n  ]);\n}\nconst T0 = /* @__PURE__ */ new Set(/* @__PURE__ */ \"area base br col command embed frame hr img input keygen link meta param source track wbr menuitem\".split(\" \")), gI = /* @__PURE__ */ Se.inputHandler.of((t, e, n, r, i) => {\n  if (t.composing || t.state.readOnly || e != n || r != \">\" && r != \"/\" || !du.isActiveAt(t.state, e, -1))\n    return !1;\n  let s = i(), { state: o } = s, a = o.changeByRange((l) => {\n    var c, u, d;\n    let f = o.doc.sliceString(l.from - 1, l.to) == r, { head: h } = l, p = un(o).resolveInner(h - 1, -1), O;\n    if ((p.name == \"TagName\" || p.name == \"StartTag\") && (p = p.parent), f && r == \">\" && p.name == \"OpenTag\") {\n      if (((u = (c = p.parent) === null || c === void 0 ? void 0 : c.lastChild) === null || u === void 0 ? void 0 : u.name) != \"CloseTag\" && (O = qo(o.doc, p.parent, h)) && !T0.has(O)) {\n        let m = h + (o.doc.sliceString(h, h + 1) === \">\" ? 1 : 0), y = `</${O}>`;\n        return { range: l, changes: { from: h, to: m, insert: y } };\n      }\n    } else if (f && r == \"/\" && p.name == \"IncompleteCloseTag\") {\n      let m = p.parent;\n      if (p.from == h - 2 && ((d = m.lastChild) === null || d === void 0 ? void 0 : d.name) != \"CloseTag\" && (O = qo(o.doc, m, h)) && !T0.has(O)) {\n        let y = h + (o.doc.sliceString(h, h + 1) === \">\" ? 1 : 0), b = `${O}>`;\n        return {\n          range: ae.cursor(h + b.length, -1),\n          changes: { from: h, to: y, insert: b }\n        };\n      }\n    }\n    return { range: l };\n  });\n  return a.changes.empty ? !1 : (t.dispatch([\n    s,\n    o.update(a, {\n      userEvent: \"input.complete\",\n      scrollIntoView: !0\n    })\n  ]), !0);\n}), mI = ia({\n  String: P.string,\n  Number: P.number,\n  \"True False\": P.bool,\n  PropertyName: P.propertyName,\n  Null: P.null,\n  \",\": P.separator,\n  \"[ ]\": P.squareBracket,\n  \"{ }\": P.brace\n}), bI = us.deserialize({\n  version: 14,\n  states: \"$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#CjOOQO'#Cp'#CpQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CrOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59U,59UO!iQPO,59UOVQPO,59QOqQPO'#CkO!nQPO,59^OOQO1G.k1G.kOVQPO'#ClO!vQPO,59aOOQO1G.p1G.pOOQO1G.l1G.lOOQO,59V,59VOOQO-E6i-E6iOOQO,59W,59WOOQO-E6j-E6j\",\n  stateData: \"#O~OcOS~OQSORSOSSOTSOWQO]ROePO~OVXOeUO~O[[O~PVOg^O~Oh_OVfX~OVaO~OhbO[iX~O[dO~Oh_OVfa~OhbO[ia~O\",\n  goto: \"!kjPPPPPPkPPkqwPPk{!RPPP!XP!ePP!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R\",\n  nodeNames: \" JsonText True False Null Number String } { Object Property PropertyName ] [ Array\",\n  maxTerm: 25,\n  nodeProps: [\n    [\"isolate\", -2, 6, 11, \"\"],\n    [\"openedBy\", 7, \"{\", 12, \"[\"],\n    [\"closedBy\", 8, \"}\", 13, \"]\"]\n  ],\n  propSources: [mI],\n  skippedNodes: [0],\n  repeatNodeCount: 2,\n  tokenData: \"(|~RaXY!WYZ!W]^!Wpq!Wrs!]|}$u}!O$z!Q!R%T!R![&c![!]&t!}#O&y#P#Q'O#Y#Z'T#b#c'r#h#i(Z#o#p(r#q#r(w~!]Oc~~!`Wpq!]qr!]rs!xs#O!]#O#P!}#P;'S!];'S;=`$o<%lO!]~!}Oe~~#QXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#m~#pR!Q![#y!c!i#y#T#Z#y~#|R!Q![$V!c!i$V#T#Z$V~$YR!Q![$c!c!i$c#T#Z$c~$fR!Q![!]!c!i!]#T#Z!]~$rP;=`<%l!]~$zOh~~$}Q!Q!R%T!R![&c~%YRT~!O!P%c!g!h%w#X#Y%w~%fP!Q![%i~%nRT~!Q![%i!g!h%w#X#Y%w~%zR{|&T}!O&T!Q![&Z~&WP!Q![&Z~&`PT~!Q![&Z~&hST~!O!P%c!Q![&c!g!h%w#X#Y%w~&yOg~~'OO]~~'TO[~~'WP#T#U'Z~'^P#`#a'a~'dP#g#h'g~'jP#X#Y'm~'rOR~~'uP#i#j'x~'{P#`#a(O~(RP#`#a(U~(ZOS~~(^P#f#g(a~(dP#i#j(g~(jP#X#Y(m~(rOQ~~(wOW~~(|OV~\",\n  tokenizers: [0],\n  topRules: { JsonText: [0, 1] },\n  tokenPrec: 0\n}), vI = /* @__PURE__ */ cs.define({\n  name: \"json\",\n  parser: /* @__PURE__ */ bI.configure({\n    props: [\n      /* @__PURE__ */ sa.add({\n        Object: /* @__PURE__ */ $o({ except: /^\\s*\\}/ }),\n        Array: /* @__PURE__ */ $o({ except: /^\\s*\\]/ })\n      }),\n      /* @__PURE__ */ Kl.add({\n        \"Object Array\": Hd\n      })\n    ]\n  }),\n  languageData: {\n    closeBrackets: { brackets: [\"[\", \"{\", '\"'] },\n    indentOnInput: /^\\s*[\\}\\]]$/\n  }\n});\nfunction yI() {\n  return new Gl(vI);\n}\nconst fo = 63, E0 = 64, SI = 1, wI = 2, pP = 3, kI = 4, OP = 5, xI = 6, PI = 7, gP = 65, _I = 66, TI = 8, EI = 9, $I = 10, QI = 11, CI = 12, mP = 13, AI = 19, RI = 20, NI = 29, DI = 33, ZI = 34, VI = 47, II = 0, _g = 1, Rp = 2, Pl = 3, Np = 4, Dp = class {\n  constructor(e, n, r) {\n    this.parent = e, this.depth = n, this.type = r, this.hash = (e ? e.hash + e.hash << 8 : 0) + n + (n << 4) + r;\n  }\n};\n_w(Dp, \"top\", new Dp(null, -1, II));\nlet Pa = Dp;\nfunction Fa(t, e) {\n  for (let n = 0, r = e - t.pos - 1; ; r--, n++) {\n    let i = t.peek(r);\n    if (Oi(i) || i == -1)\n      return n;\n  }\n}\nfunction Zp(t) {\n  return t == 32 || t == 9;\n}\nfunction Oi(t) {\n  return t == 10 || t == 13;\n}\nfunction bP(t) {\n  return Zp(t) || Oi(t);\n}\nfunction Ts(t) {\n  return t < 0 || bP(t);\n}\nconst WI = new wg({\n  start: Pa.top,\n  reduce(t, e) {\n    return t.type == Pl && (e == RI || e == ZI) ? t.parent : t;\n  },\n  shift(t, e, n, r) {\n    if (e == pP)\n      return new Pa(t, Fa(r, r.pos), _g);\n    if (e == gP || e == OP)\n      return new Pa(t, Fa(r, r.pos), Rp);\n    if (e == fo)\n      return t.parent;\n    if (e == AI || e == DI)\n      return new Pa(t, 0, Pl);\n    if (e == mP && t.type == Np)\n      return t.parent;\n    if (e == VI) {\n      let i = /[1-9]/.exec(r.read(r.pos, n.pos));\n      if (i)\n        return new Pa(t, t.depth + +i[0], Np);\n    }\n    return t;\n  },\n  hash(t) {\n    return t.hash;\n  }\n});\nfunction zo(t, e, n = 0) {\n  return t.peek(n) == e && t.peek(n + 1) == e && t.peek(n + 2) == e && Ts(t.peek(n + 3));\n}\nconst MI = new gn((t, e) => {\n  if (t.next == -1 && e.canShift(E0))\n    return t.acceptToken(E0);\n  let n = t.peek(-1);\n  if ((Oi(n) || n < 0) && e.context.type != Pl) {\n    if (zo(\n      t,\n      45\n      /* '-' */\n    ))\n      if (e.canShift(fo))\n        t.acceptToken(fo);\n      else\n        return t.acceptToken(SI, 3);\n    if (zo(\n      t,\n      46\n      /* '.' */\n    ))\n      if (e.canShift(fo))\n        t.acceptToken(fo);\n      else\n        return t.acceptToken(wI, 3);\n    let r = 0;\n    for (; t.next == 32; )\n      r++, t.advance();\n    (r < e.context.depth || r == e.context.depth && e.context.type == _g && (t.next != 45 || !Ts(t.peek(1)))) && // Not blank\n    t.next != -1 && !Oi(t.next) && t.next != 35 && t.acceptToken(fo, -r);\n  }\n}, { contextual: !0 }), XI = new gn((t, e) => {\n  if (e.context.type == Pl) {\n    t.next == 63 && (t.advance(), Ts(t.next) && t.acceptToken(PI));\n    return;\n  }\n  if (t.next == 45)\n    t.advance(), Ts(t.next) && t.acceptToken(e.context.type == _g && e.context.depth == Fa(t, t.pos - 1) ? kI : pP);\n  else if (t.next == 63)\n    t.advance(), Ts(t.next) && t.acceptToken(e.context.type == Rp && e.context.depth == Fa(t, t.pos - 1) ? xI : OP);\n  else {\n    let n = t.pos;\n    for (; ; )\n      if (Zp(t.next)) {\n        if (t.pos == n)\n          return;\n        t.advance();\n      } else if (t.next == 33)\n        vP(t);\n      else if (t.next == 38)\n        Vp(t);\n      else if (t.next == 42) {\n        Vp(t);\n        break;\n      } else if (t.next == 39 || t.next == 34) {\n        if (Tg(t, !0))\n          break;\n        return;\n      } else if (t.next == 91 || t.next == 123) {\n        if (!BI(t))\n          return;\n        break;\n      } else {\n        yP(t, !0, !1, 0);\n        break;\n      }\n    for (; Zp(t.next); )\n      t.advance();\n    if (t.next == 58) {\n      if (t.pos == n && e.canShift(NI))\n        return;\n      let r = t.peek(1);\n      Ts(r) && t.acceptTokenTo(e.context.type == Rp && e.context.depth == Fa(t, n) ? _I : gP, n);\n    }\n  }\n}, { contextual: !0 });\nfunction jI(t) {\n  return t > 32 && t < 127 && t != 34 && t != 37 && t != 44 && t != 60 && t != 62 && t != 92 && t != 94 && t != 96 && t != 123 && t != 124 && t != 125;\n}\nfunction $0(t) {\n  return t >= 48 && t <= 57 || t >= 97 && t <= 102 || t >= 65 && t <= 70;\n}\nfunction Q0(t, e) {\n  return t.next == 37 ? (t.advance(), $0(t.next) && t.advance(), $0(t.next) && t.advance(), !0) : jI(t.next) || e && t.next == 44 ? (t.advance(), !0) : !1;\n}\nfunction vP(t) {\n  if (t.advance(), t.next == 60) {\n    for (t.advance(); ; )\n      if (!Q0(t, !0)) {\n        t.next == 62 && t.advance();\n        break;\n      }\n  } else\n    for (; Q0(t, !1); )\n      ;\n}\nfunction Vp(t) {\n  for (t.advance(); !Ts(t.next) && ed(t.tag) != \"f\"; )\n    t.advance();\n}\nfunction Tg(t, e) {\n  let n = t.next, r = !1, i = t.pos;\n  for (t.advance(); ; ) {\n    let s = t.next;\n    if (s < 0)\n      break;\n    if (t.advance(), s == n)\n      if (s == 39)\n        if (t.next == 39)\n          t.advance();\n        else\n          break;\n      else\n        break;\n    else if (s == 92 && n == 34)\n      t.next >= 0 && t.advance();\n    else if (Oi(s)) {\n      if (e)\n        return !1;\n      r = !0;\n    } else if (e && t.pos >= i + 1024)\n      return !1;\n  }\n  return !r;\n}\nfunction BI(t) {\n  for (let e = [], n = t.pos + 1024; ; )\n    if (t.next == 91 || t.next == 123)\n      e.push(t.next), t.advance();\n    else if (t.next == 39 || t.next == 34) {\n      if (!Tg(t, !0))\n        return !1;\n    } else if (t.next == 93 || t.next == 125) {\n      if (e[e.length - 1] != t.next - 2)\n        return !1;\n      if (e.pop(), t.advance(), !e.length)\n        return !0;\n    } else {\n      if (t.next < 0 || t.pos > n || Oi(t.next))\n        return !1;\n      t.advance();\n    }\n}\nconst LI = \"iiisiiissisfissssssssssssisssiiissssssssssssssssssssssssssfsfssissssssssssssssssssssssssssfif\";\nfunction ed(t) {\n  return t < 33 ? \"u\" : t > 125 ? \"s\" : LI[t - 33];\n}\nfunction Kf(t, e) {\n  let n = ed(t);\n  return n != \"u\" && !(e && n == \"f\");\n}\nfunction yP(t, e, n, r) {\n  if (ed(t.next) == \"s\" || (t.next == 63 || t.next == 58 || t.next == 45) && Kf(t.peek(1), n))\n    t.advance();\n  else\n    return !1;\n  let i = t.pos;\n  for (; ; ) {\n    let s = t.next, o = 0, a = r + 1;\n    for (; bP(s); ) {\n      if (Oi(s)) {\n        if (e)\n          return !1;\n        a = 0;\n      } else\n        a++;\n      s = t.peek(++o);\n    }\n    if (!(s >= 0 && (s == 58 ? Kf(t.peek(o + 1), n) : s == 35 ? t.peek(o - 1) != 32 : Kf(s, n))) || !n && a <= r || a == 0 && !n && (zo(t, 45, o) || zo(t, 46, o)))\n      break;\n    if (e && ed(s) == \"f\")\n      return !1;\n    for (let c = o; c >= 0; c--)\n      t.advance();\n    if (e && t.pos > i + 1024)\n      return !1;\n  }\n  return !0;\n}\nconst UI = new gn((t, e) => {\n  if (t.next == 33)\n    vP(t), t.acceptToken(CI);\n  else if (t.next == 38 || t.next == 42) {\n    let n = t.next == 38 ? $I : QI;\n    Vp(t), t.acceptToken(n);\n  } else\n    t.next == 39 || t.next == 34 ? (Tg(t, !1), t.acceptToken(EI)) : yP(t, !1, e.context.type == Pl, e.context.depth) && t.acceptToken(TI);\n}), qI = new gn((t, e) => {\n  let n = e.context.type == Np ? e.context.depth : -1, r = t.pos;\n  e:\n    for (; ; ) {\n      let i = 0, s = t.next;\n      for (; s == 32; )\n        s = t.peek(++i);\n      if (!i && (zo(t, 45, i) || zo(t, 46, i)) || !Oi(s) && (n < 0 && (n = Math.max(e.context.depth + 1, i)), i < n))\n        break;\n      for (; ; ) {\n        if (t.next < 0)\n          break e;\n        let o = Oi(t.next);\n        if (t.advance(), o)\n          continue e;\n        r = t.pos;\n      }\n    }\n  t.acceptTokenTo(mP, r);\n}), YI = ia({\n  DirectiveName: P.keyword,\n  DirectiveContent: P.attributeValue,\n  \"DirectiveEnd DocEnd\": P.meta,\n  QuotedLiteral: P.string,\n  BlockLiteralHeader: P.special(P.string),\n  BlockLiteralContent: P.content,\n  Literal: P.content,\n  \"Key/Literal Key/QuotedLiteral\": P.definition(P.propertyName),\n  \"Anchor Alias\": P.labelName,\n  Tag: P.typeName,\n  Comment: P.lineComment,\n  \": , -\": P.separator,\n  \"?\": P.punctuation,\n  \"[ ]\": P.squareBracket,\n  \"{ }\": P.brace\n}), zI = us.deserialize({\n  version: 14,\n  states: \"5lQ!ZQgOOO#PQfO'#CpO#uQfO'#DOOOQR'#Dv'#DvO$qQgO'#DRO%gQdO'#DUO%nQgO'#DUO&ROaO'#D[OOQR'#Du'#DuO&{QgO'#D^O'rQgO'#D`OOQR'#Dt'#DtO(iOqO'#DbOOQP'#Dj'#DjO(zQaO'#CmO)YQgO'#CmOOQP'#Cm'#CmQ)jQaOOQ)uQgOOQ]QgOOO*PQdO'#CrO*nQdO'#CtOOQO'#Dw'#DwO+]Q`O'#CxO+hQdO'#CwO+rQ`O'#CwOOQO'#Cv'#CvO+wQdO'#CvOOQO'#Cq'#CqO,UQ`O,59[O,^QfO,59[OOQR,59[,59[OOQO'#Cx'#CxO,eQ`O'#DPO,pQdO'#DPOOQO'#Dx'#DxO,zQdO'#DxO-XQ`O,59jO-aQfO,59jOOQR,59j,59jOOQR'#DS'#DSO-hQcO,59mO-sQgO'#DVO.TQ`O'#DVO.YQcO,59pOOQR'#DX'#DXO#|QfO'#DWO.hQcO'#DWOOQR,59v,59vO.yOWO,59vO/OOaO,59vO/WOaO,59vO/cQgO'#D_OOQR,59x,59xO0VQgO'#DaOOQR,59z,59zOOQP,59|,59|O0yOaO,59|O1ROaO,59|O1aOqO,59|OOQP-E7h-E7hO1oQgO,59XOOQP,59X,59XO2PQaO'#DeO2_QgO'#DeO2oQgO'#DkOOQP'#Dk'#DkQ)jQaOOO3PQdO'#CsOOQO,59^,59^O3kQdO'#CuOOQO,59`,59`OOQO,59c,59cO4VQdO,59cO4aQdO'#CzO4kQ`O'#CzOOQO,59b,59bOOQU,5:Q,5:QOOQR1G.v1G.vO4pQ`O1G.vOOQU-E7d-E7dO4xQdO,59kOOQO,59k,59kO5SQdO'#DQO5^Q`O'#DQOOQO,5:d,5:dOOQU,5:R,5:ROOQR1G/U1G/UO5cQ`O1G/UOOQU-E7e-E7eO5kQgO'#DhO5xQcO1G/XOOQR1G/X1G/XOOQR,59q,59qO6TQgO,59qO6eQdO'#DiO6lQgO'#DiO7PQcO1G/[OOQR1G/[1G/[OOQR,59r,59rO#|QfO,59rOOQR1G/b1G/bO7_OWO1G/bO7dOaO1G/bOOQR,59y,59yOOQR,59{,59{OOQP1G/h1G/hO7lOaO1G/hO7tOaO1G/hO8POaO1G/hOOQP1G.s1G.sO8_QgO,5:POOQP,5:P,5:POOQP,5:V,5:VOOQP-E7i-E7iOOQO,59_,59_OOQO,59a,59aOOQO1G.}1G.}OOQO,59f,59fO8oQdO,59fOOQR7+$b7+$bP,XQ`O'#DfOOQO1G/V1G/VOOQO,59l,59lO8yQdO,59lOOQR7+$p7+$pP9TQ`O'#DgOOQR'#DT'#DTOOQR,5:S,5:SOOQR-E7f-E7fOOQR7+$s7+$sOOQR1G/]1G/]O9YQgO'#DYO9jQ`O'#DYOOQR,5:T,5:TO#|QfO'#DZO9oQcO'#DZOOQR-E7g-E7gOOQR7+$v7+$vOOQR1G/^1G/^OOQR7+$|7+$|O:QOWO7+$|OOQP7+%S7+%SO:VOaO7+%SO:_OaO7+%SOOQP1G/k1G/kOOQO1G/Q1G/QOOQO1G/W1G/WOOQR,59t,59tO:jQgO,59tOOQR,59u,59uO#|QfO,59uOOQR<<Hh<<HhOOQP<<Hn<<HnO:zOaO<<HnOOQR1G/`1G/`OOQR1G/a1G/aOOQPAN>YAN>Y\",\n  stateData: \";S~O!fOS!gOS^OS~OP_OQbORSOTUOWROXROYYOZZO[XOcPOqQO!PVO!V[O!cTO~O`cO~P]OVkOWROXROYeOZfO[dOcPOmhOqQO~OboO~P!bOVtOWROXROYeOZfO[dOcPOmrOqQO~OpwO~P#WORSOTUOWROXROYYOZZO[XOcPOqQO!PVO!cTO~OSvP!avP!bvP~P#|OWROXROYeOZfO[dOcPOqQO~OmzO~P%OOm!OOUzP!azP!bzP!dzP~P#|O^!SO!b!QO!f!TO!g!RO~ORSOTUOWROXROcPOqQO!PVO!cTO~OY!UOP!QXQ!QX!V!QX!`!QXS!QX!a!QX!b!QXU!QXm!QX!d!QX~P&aO[!WOP!SXQ!SX!V!SX!`!SXS!SX!a!SX!b!SXU!SXm!SX!d!SX~P&aO^!ZO!W![O!b!YO!f!]O!g!YO~OP!_O!V[OQaX!`aX~OPaXQaX!VaX!`aX~P#|OP!bOQ!cO!V[O~OP_O!V[O~P#|OWROXROY!fOcPOqQObfXmfXofXpfX~OWROXRO[!hOcPOqQObhXmhXohXphX~ObeXmlXoeX~ObkXokX~P%OOm!kO~Om!lObnPonP~P%OOb!pOo!oO~Ob!pO~P!bOm!sOosXpsX~OosXpsX~P%OOm!uOotPptP~P%OOo!xOp!yO~Op!yO~P#WOS!|O!a#OO!b#OO~OUyX!ayX!byX!dyX~P#|Om#QO~OU#SO!a#UO!b#UO!d#RO~Om#WOUzX!azX!bzX!dzX~O]#XO~O!b#XO!g#YO~O^#ZO!b#XO!g#YO~OP!RXQ!RX!V!RX!`!RXS!RX!a!RX!b!RXU!RXm!RX!d!RX~P&aOP!TXQ!TX!V!TX!`!TXS!TX!a!TX!b!TXU!TXm!TX!d!TX~P&aO!b#^O!g#^O~O^#_O!b#^O!f#`O!g#^O~O^#_O!W#aO!b#^O!g#^O~OPaaQaa!Vaa!`aa~P#|OP#cO!V[OQ!XX!`!XX~OP!XXQ!XX!V!XX!`!XX~P#|OP_O!V[OQ!_X!`!_X~P#|OWROXROcPOqQObgXmgXogXpgX~OWROXROcPOqQObiXmiXoiXpiX~Obkaoka~P%OObnXonX~P%OOm#kO~Ob#lOo!oO~Oosapsa~P%OOotXptX~P%OOm#pO~Oo!xOp#qO~OSwP!awP!bwP~P#|OS!|O!a#vO!b#vO~OUya!aya!bya!dya~P#|Om#xO~P%OOm#{OU}P!a}P!b}P!d}P~P#|OU#SO!a$OO!b$OO!d#RO~O]$QO~O!b$QO!g$RO~O!b$SO!g$SO~O^$TO!b$SO!g$SO~O^$TO!b$SO!f$UO!g$SO~OP!XaQ!Xa!V!Xa!`!Xa~P#|Obnaona~P%OOotapta~P%OOo!xO~OU|X!a|X!b|X!d|X~P#|Om$ZO~Om$]OU}X!a}X!b}X!d}X~O]$^O~O!b$_O!g$_O~O^$`O!b$_O!g$_O~OU|a!a|a!b|a!d|a~P#|O!b$cO!g$cO~O\",\n  goto: \",]!mPPPPPPPPPPPPPPPPP!nPP!v#v#|$`#|$c$f$j$nP%VPPP!v%Y%^%a%{&O%a&R&U&X&_&b%aP&e&{&e'O'RPP']'a'g'm's'y(XPPPPPPPP(_)e*X+c,VUaObcR#e!c!{ROPQSTUXY_bcdehknrtvz!O!U!W!_!b!c!f!h!k!l!s!u!|#Q#R#S#W#c#k#p#x#{$Z$]QmPR!qnqfPQThknrtv!k!l!s!u#R#k#pR!gdR!ieTlPnTjPnSiPnSqQvQ{TQ!mkQ!trQ!vtR#y#RR!nkTsQvR!wt!RWOSUXY_bcz!O!U!W!_!b!c!|#Q#S#W#c#x#{$Z$]RySR#t!|R|TR|UQ!PUR#|#SR#z#RR#z#SyZOSU_bcz!O!_!b!c!|#Q#S#W#c#x#{$Z$]R!VXR!XYa]O^abc!a!c!eT!da!eQnPR!rnQvQR!{vQ!}yR#u!}Q#T|R#}#TW^Obc!cS!^^!aT!aa!eQ!eaR#f!eW`Obc!cQxSS}U#SQ!`_Q#PzQ#V!OQ#b!_Q#d!bQ#s!|Q#w#QQ$P#WQ$V#cQ$Y#xQ$[#{Q$a$ZR$b$]xZOSU_bcz!O!_!b!c!|#Q#S#W#c#x#{$Z$]Q!VXQ!XYQ#[!UR#]!W!QWOSUXY_bcz!O!U!W!_!b!c!|#Q#S#W#c#x#{$Z$]pfPQThknrtv!k!l!s!u#R#k#pQ!gdQ!ieQ#g!fR#h!hSgPn^pQTkrtv#RQ!jhQ#i!kQ#j!lQ#n!sQ#o!uQ$W#kR$X#pQuQR!zv\",\n  nodeNames: \" DirectiveEnd DocEnd - - ? ? ? Literal QuotedLiteral Anchor Alias Tag BlockLiteralContent Comment Stream BOM Document ] [ FlowSequence Item Tagged Anchored Anchored Tagged FlowMapping Pair Key : Pair , } { FlowMapping Pair Pair BlockSequence Item Item BlockMapping Pair Pair Key Pair Pair BlockLiteral BlockLiteralHeader Tagged Anchored Anchored Tagged Directive DirectiveName DirectiveContent Document\",\n  maxTerm: 74,\n  context: WI,\n  nodeProps: [\n    [\"isolate\", -3, 8, 9, 14, \"\"],\n    [\"openedBy\", 18, \"[\", 32, \"{\"],\n    [\"closedBy\", 19, \"]\", 33, \"}\"]\n  ],\n  propSources: [YI],\n  skippedNodes: [0],\n  repeatNodeCount: 6,\n  tokenData: \"-Y~RnOX#PXY$QYZ$]Z]#P]^$]^p#Ppq$Qqs#Pst$btu#Puv$yv|#P|}&e}![#P![!]'O!]!`#P!`!a'i!a!}#P!}#O*g#O#P#P#P#Q+Q#Q#o#P#o#p+k#p#q'i#q#r,U#r;'S#P;'S;=`#z<%l?HT#P?HT?HU,o?HUO#PQ#UU!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PQ#kTOY#PZs#Pt;'S#P;'S;=`#z<%lO#PQ#}P;=`<%l#P~$VQ!f~XY$Qpq$Q~$bO!g~~$gS^~OY$bZ;'S$b;'S;=`$s<%lO$b~$vP;=`<%l$bR%OX!WQOX%kXY#PZ]%k]^#P^p%kpq#hq;'S%k;'S;=`&_<%lO%kR%rX!WQ!VPOX%kXY#PZ]%k]^#P^p%kpq#hq;'S%k;'S;=`&_<%lO%kR&bP;=`<%l%kR&lUoP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR'VUmP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR'p[!PP!WQOY#PZp#Ppq#hq{#P{|(f|}#P}!O(f!O!R#P!R![)p![;'S#P;'S;=`#z<%lO#PR(mW!PP!WQOY#PZp#Ppq#hq!R#P!R![)V![;'S#P;'S;=`#z<%lO#PR)^U!PP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR)wY!PP!WQOY#PZp#Ppq#hq{#P{|)V|}#P}!O)V!O;'S#P;'S;=`#z<%lO#PR*nUcP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR+XUbP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR+rUqP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR,]UpP!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#PR,vU`P!WQOY#PZp#Ppq#hq;'S#P;'S;=`#z<%lO#P\",\n  tokenizers: [MI, XI, UI, qI, 0, 1],\n  topRules: { Stream: [0, 15] },\n  tokenPrec: 0\n}), HI = /* @__PURE__ */ cs.define({\n  name: \"yaml\",\n  parser: /* @__PURE__ */ zI.configure({\n    props: [\n      /* @__PURE__ */ sa.add({\n        Stream: (t) => {\n          for (let e = t.node.resolve(t.pos, -1); e && e.to >= t.pos; e = e.parent) {\n            if (e.name == \"BlockLiteralContent\" && e.from < e.to)\n              return t.baseIndentFor(e);\n            if (e.name == \"BlockLiteral\")\n              return t.baseIndentFor(e) + t.unit;\n            if (e.name == \"BlockSequence\" || e.name == \"BlockMapping\")\n              return t.column(e.from, 1);\n            if (e.name == \"QuotedLiteral\")\n              return null;\n            if (e.name == \"Literal\") {\n              let n = t.column(e.from, 1);\n              if (n == t.lineIndent(e.from, 1))\n                return n;\n              if (e.to > t.pos)\n                return null;\n            }\n          }\n          return null;\n        },\n        FlowMapping: /* @__PURE__ */ xp({ closing: \"}\" }),\n        FlowSequence: /* @__PURE__ */ xp({ closing: \"]\" })\n      }),\n      /* @__PURE__ */ Kl.add({\n        \"FlowMapping FlowSequence\": Hd,\n        \"BlockSequence BlockMapping BlockLiteral\": (t, e) => ({ from: e.doc.lineAt(t.from).to, to: t.to })\n      })\n    ]\n  }),\n  languageData: {\n    commentTokens: { line: \"#\" },\n    indentOnInput: /^\\s*[\\]\\}]$/\n  }\n});\nfunction FI() {\n  return new Gl(HI);\n}\nvar GI = (t) => {\n  var {\n    theme: e,\n    settings: n = {},\n    styles: r = []\n  } = t, i = {\n    \".cm-gutters\": {}\n  }, s = {};\n  n.background && (s.backgroundColor = n.background), n.backgroundImage && (s.backgroundImage = n.backgroundImage), n.foreground && (s.color = n.foreground), (n.background || n.foreground) && (i[\"&\"] = s), n.fontFamily && (i[\"&.cm-editor .cm-scroller\"] = {\n    fontFamily: n.fontFamily\n  }), n.gutterBackground && (i[\".cm-gutters\"].backgroundColor = n.gutterBackground), n.gutterForeground && (i[\".cm-gutters\"].color = n.gutterForeground), n.gutterBorder && (i[\".cm-gutters\"].borderRightColor = n.gutterBorder), n.caret && (i[\".cm-content\"] = {\n    caretColor: n.caret\n  }, i[\".cm-cursor, .cm-dropCursor\"] = {\n    borderLeftColor: n.caret\n  });\n  var o = {};\n  n.gutterActiveForeground && (o.color = n.gutterActiveForeground), n.lineHighlight && (i[\".cm-activeLine\"] = {\n    backgroundColor: n.lineHighlight\n  }, o.backgroundColor = n.lineHighlight), i[\".cm-activeLineGutter\"] = o, n.selection && (i[\"&.cm-focused .cm-selectionBackground, & .cm-line::selection, & .cm-selectionLayer .cm-selectionBackground, .cm-content ::selection\"] = {\n    background: n.selection + \" !important\"\n  }), n.selectionMatch && (i[\"& .cm-selectionMatch\"] = {\n    backgroundColor: n.selectionMatch\n  });\n  var a = Se.theme(i, {\n    dark: e === \"dark\"\n  }), l = Jl.define(r), c = [a, hx(l)];\n  return c;\n};\nconst KI = GI({\n  theme: \"light\",\n  settings: {\n    background: \"var(--scalar-background-2)\",\n    foreground: \"var(--scalar-color-1)\",\n    caret: \"var(--scalar-color-1)\",\n    // Selection likely needs a hardcoded color due to it not accepting variables\n    selection: \"rgba(151, 183, 205, 0.2)\",\n    selectionMatch: \"#e3dcce\",\n    gutterBackground: \"var(--scalar-background-2)\",\n    gutterForeground: \"var(--scalar-color-3)\",\n    gutterBorder: \"transparent\",\n    lineHighlight: \"var(--scalar-background-3)\",\n    fontFamily: \"var(--scalar-font-code)\"\n  },\n  styles: [\n    {\n      tag: [P.standard(P.tagName), P.tagName],\n      color: \"var(--scalar-color-purple)\"\n    },\n    {\n      tag: [P.comment],\n      color: \"var(--scalar-color-3)\"\n    },\n    {\n      tag: [P.className],\n      color: \"var(--scalar-color-orange)\"\n    },\n    {\n      tag: [P.variableName, P.propertyName, P.attributeName],\n      color: \"var(--scalar-color-1)\"\n    },\n    {\n      tag: [P.operator],\n      color: \"var(--scalar-color-2)\"\n    },\n    {\n      tag: [P.keyword, P.typeName, P.typeOperator],\n      color: \"var(--scalar-color-green)\"\n    },\n    {\n      tag: [P.string],\n      color: \"var(--scalar-color-blue)\"\n    },\n    {\n      tag: [P.bracket, P.regexp, P.meta],\n      color: \"var(--scalar-color-3)\"\n    },\n    {\n      tag: [P.number],\n      color: \"var(--scalar-color-blue)\"\n    },\n    {\n      tag: [P.name, P.quote],\n      color: \"var(--scalar-color-3)\"\n    },\n    {\n      tag: [P.heading],\n      color: \"var(--scalar-color-3)\",\n      fontWeight: \"bold\"\n    },\n    {\n      tag: [P.emphasis],\n      color: \"var(--scalar-color-3)\",\n      fontStyle: \"italic\"\n    },\n    {\n      tag: [P.deleted],\n      color: \"var(--scalar-color-3)\",\n      backgroundColor: \"transparent\"\n    },\n    {\n      tag: [P.atom, P.bool, P.special(P.variableName)],\n      color: \"var(--scalar-color-3)\"\n    },\n    {\n      tag: [P.url, P.escape, P.regexp, P.link],\n      color: \"var(--scalar-color-1)\"\n    },\n    { tag: P.link, textDecoration: \"underline\" },\n    { tag: P.strikethrough, textDecoration: \"line-through\" },\n    {\n      tag: P.invalid,\n      color: \"var(--scalar-color-3)\"\n    }\n  ]\n}), C0 = new Uk({\n  regexp: /(\\{[^}]+\\})/g,\n  decoration: () => Je.mark({\n    attributes: {\n      class: \"api-client-url-variable\"\n    }\n  })\n}), JI = () => rr.fromClass(\n  class {\n    constructor(t) {\n      _w(this, \"variables\"), this.variables = C0.createDeco(t);\n    }\n    update(t) {\n      this.variables = C0.updateDeco(\n        t,\n        this.variables\n      );\n    }\n  },\n  {\n    decorations: (t) => t.variables,\n    provide: (t) => Se.atomicRanges.of(\n      (e) => {\n        var n;\n        return ((n = e.plugin(t)) == null ? void 0 : n.variables) || Je.none;\n      }\n    )\n  }\n), ao = (t) => \"provider\" in t && !!Jt(t.provider), eW = {\n  key: \"Mod-a\",\n  run: (t) => (t.dispatch({\n    selection: { anchor: 0, head: t.state.doc.length },\n    scrollIntoView: !1\n  }), !0)\n}, tW = (t) => {\n  const e = G(null);\n  ht(\n    t.codeMirrorRef,\n    () => {\n      var s;\n      (s = e.value) == null || s.destroy(), n();\n    },\n    { immediate: !0 }\n  ), Il(() => {\n    var s;\n    return (s = e.value) == null ? void 0 : s.destroy();\n  });\n  function n() {\n    if (t.codeMirrorRef.value) {\n      const s = ao(t) ? Jt(t.provider) : null, o = R0({\n        ...r.value,\n        provider: s\n      });\n      e.value = new Se({\n        parent: t.codeMirrorRef.value,\n        extensions: o\n      }), ao(t) || i(Jt(t.content));\n    }\n  }\n  const r = j(() => ({\n    onChange: t.onChange,\n    onBlur: t.onBlur,\n    onFocus: t.onFocus,\n    language: Jt(t.language),\n    classes: Jt(t.classes),\n    readOnly: Jt(t.readOnly),\n    lineNumbers: Jt(t.lineNumbers),\n    withVariables: Jt(t.withVariables),\n    disableEnter: Jt(t.withVariables),\n    withoutTheme: Jt(t.withoutTheme),\n    additionalExtensions: Jt(t.extensions)\n  }));\n  ht(\n    () => ao(t) ? Jt(t.provider) : null,\n    () => {\n      var s;\n      ao(t) && ((s = e.value) == null || s.destroy(), n());\n    }\n  ), ht(\n    r,\n    () => {\n      if (e.value) {\n        const s = ao(t) ? Jt(t.provider) : null, o = R0({\n          ...r.value,\n          provider: s\n        });\n        e.value.dispatch({\n          effects: ot.reconfigure.of(o)\n        });\n      } else\n        return;\n    },\n    { immediate: !0 }\n  );\n  const i = (s = \"\") => {\n    e.value && e.value.state.doc.toString() !== s && e.value.dispatch({\n      changes: {\n        from: 0,\n        to: e.value.state.doc.length,\n        insert: s\n      },\n      selection: {\n        anchor: Math.min(\n          e.value.state.selection.main.anchor,\n          s.length\n        )\n      }\n    });\n  };\n  return ht(\n    () => Jt(t.content),\n    () => {\n      ao(t) || i(Jt(t.content));\n    },\n    { immediate: !0 }\n  ), {\n    /** Replaces the current content with the given value. */\n    setCodeMirrorContent: i,\n    /** Codemirror instance */\n    codeMirror: e\n  };\n}, A0 = {\n  html: OI,\n  json: yI,\n  yaml: FI,\n  css: Ix\n};\nfunction R0({\n  onChange: t,\n  onBlur: e,\n  onFocus: n,\n  provider: r,\n  language: i,\n  classes: s = [],\n  readOnly: o = !1,\n  lineNumbers: a = !1,\n  withVariables: l = !1,\n  disableEnter: c = !1,\n  withoutTheme: u = !1,\n  additionalExtensions: d = []\n}) {\n  const f = [\n    tD(),\n    hx(tZ, { fallback: !0 }),\n    Se.theme({\n      \".cm-line\": {\n        lineHeight: \"20px\"\n      },\n      \".cm-gutterElement\": {\n        lineHeight: \"20px\"\n      }\n    }),\n    // Listen to updates\n    Se.updateListener.of((h) => {\n      h.docChanged && (t == null || t(h.state.doc.toString()));\n    }),\n    Se.domEventHandlers({\n      blur: (h, p) => {\n        e == null || e(p.state.doc.toString());\n      },\n      focus: (h, p) => {\n        n == null || n(p.state.doc.toString());\n      }\n    }),\n    // Add Classes\n    Se.editorAttributes.of({ class: s.join(\" \") }),\n    ...d\n  ];\n  return r && f.push(r), u || f.push(KI), o ? f.push(Se.editable.of(!1)) : f.push(\n    KD(),\n    lZ(),\n    sV(),\n    zZ(),\n    bl.of([\n      ...Cx,\n      ...KZ,\n      cV,\n      eW\n    ])\n  ), i && A0[i] && f.push(A0[i]()), a && f.push(mD()), l && f.push(JI()), c && f.push(\n    bl.of([\n      {\n        key: \"Enter\",\n        run: () => !0\n      },\n      {\n        key: \"Ctrl-Enter\",\n        mac: \"Cmd-Enter\",\n        run: () => !0\n      },\n      {\n        key: \"Shift-Enter\",\n        run: () => !0\n      }\n    ])\n  ), f;\n}\nconst nW = /* @__PURE__ */ le({\n  __name: \"CodeMirror\",\n  props: {\n    content: {},\n    readOnly: { type: Boolean },\n    language: {},\n    withVariables: { type: Boolean },\n    lineNumbers: { type: Boolean },\n    withoutTheme: { type: Boolean },\n    disableEnter: { type: Boolean, default: !1 }\n  },\n  emits: [\"change\"],\n  setup(t, { emit: e }) {\n    const n = t, r = e, i = G(null);\n    return tW({\n      content: Ei(() => n.content),\n      readOnly: Ei(() => n.readOnly),\n      language: Ei(() => n.language),\n      withVariables: Ei(() => n.withVariables),\n      lineNumbers: Ei(() => n.lineNumbers),\n      withoutTheme: Ei(() => n.withoutTheme),\n      disableEnter: Ei(() => n.disableEnter),\n      onChange: (s) => r(\"change\", s || \"\"),\n      codeMirrorRef: i,\n      classes: [\"codemirror\"]\n    }), (s, o) => (Z(), ne(\"div\", {\n      ref_key: \"codeMirrorRef\",\n      ref: i,\n      class: \"codemirror-container\"\n    }, null, 512));\n  }\n}), SP = /* @__PURE__ */ ct(nW, [[\"__scopeId\", \"data-v-0abaf2d9\"]]), rW = { class: \"scalar-modal-layout modal-layout\" }, iW = /* @__PURE__ */ le({\n  __name: \"FlowModal\",\n  props: {\n    state: {},\n    title: {},\n    bodyClass: {},\n    maxWidth: {},\n    variant: { default: \"normal\" }\n  },\n  setup(t) {\n    return (e, n) => (Z(), ke(R(fC), {\n      open: e.state.open,\n      onClose: n[0] || (n[0] = (r) => e.state.hide())\n    }, {\n      default: ce(() => [\n        D(\"div\", rW, [\n          J(R(hC), {\n            class: Ke([\"modal\", {\n              \"modal-content-large\": e.variant === \"large\",\n              \"modal-content-normal\": e.variant === \"normal\",\n              \"modal-content-small\": e.variant === \"small\",\n              \"modal-content-search\": e.variant === \"search\",\n              \"modal-content-history\": e.variant === \"history\"\n            }]),\n            style: Br({ maxWidth: e.maxWidth })\n          }, {\n            default: ce(() => [\n              e.title ? (Z(), ke(R(pC), {\n                key: 0,\n                class: \"modal-header\"\n              }, {\n                default: ce(() => [\n                  He(De(e.title), 1)\n                ]),\n                _: 1\n              })) : st(\"\", !0),\n              J(R(OC), {\n                class: Ke([\"modal-body custom-scroll\", [e.bodyClass]])\n              }, {\n                default: ce(() => [\n                  pt(e.$slots, \"default\", {}, void 0, !0)\n                ]),\n                _: 3\n              }, 8, [\"class\"])\n            ]),\n            _: 3\n          }, 8, [\"class\", \"style\"])\n        ])\n      ]),\n      _: 3\n    }, 8, [\"open\"]));\n  }\n}), sW = /* @__PURE__ */ ct(iW, [[\"__scopeId\", \"data-v-4aafbf68\"]]), oW = () => Xn({\n  open: !1,\n  show() {\n    this.open = !0;\n  },\n  hide() {\n    this.open = !1;\n  }\n});\nfunction aW() {\n  return typeof navigator < \"u\" ? /Mac/.test(navigator.platform) : !1;\n}\nconst lW = (t, e) => {\n  if (typeof e != \"string\" || !e.length)\n    return t;\n  const n = t.endsWith(\"/\") ? t : `${t}/`, r = e.startsWith(\"/\") ? e.slice(1) : e;\n  return [n, r].join(\"\");\n};\nfunction cW(t) {\n  return typeof window > \"u\" ? Buffer.from(t).toString(\"base64\") : btoa(t);\n}\nfunction uW(t) {\n  return !(!t || Array.isArray(t) && !t.length || (t ?? []).some(\n    (e) => !Object.keys(e).length\n  ));\n}\nfunction wP(t, e) {\n  var n, r;\n  const i = [], s = [], o = [];\n  if (!t.customSecurity && (!t.preferredSecurityScheme || !uW(e)))\n    return { headers: i, queryString: s, cookies: o };\n  const l = (e == null ? void 0 : e.some(\n    (u) => t.preferredSecurityScheme && Object.keys(u).includes(\n      t.preferredSecurityScheme\n    )\n  )) || t.customSecurity ? t.preferredSecurityScheme : Object.keys((e == null ? void 0 : e[0]) ?? {}).pop(), c = (n = t.securitySchemes) == null ? void 0 : n[l ?? \"\"];\n  if (c) {\n    if (\"type\" in c && c.type === \"apiKey\") {\n      if (\"in\" in c && c.in === \"header\") {\n        const u = (r = t.apiKey.token) != null && r.length ? t.apiKey.token : \"YOUR_TOKEN\";\n        i.push({\n          name: \"name\" in c ? c.name : \"\",\n          value: u\n        });\n      } else if (\"in\" in c && c.in === \"cookie\") {\n        const u = t.apiKey.token.length ? t.apiKey.token : \"YOUR_TOKEN\";\n        o.push({\n          name: c.name,\n          value: u\n        });\n      } else if (\"in\" in c && c.in === \"query\") {\n        const u = t.apiKey.token.length ? t.apiKey.token : \"YOUR_TOKEN\";\n        s.push({\n          name: c.name,\n          value: u\n        });\n      }\n    } else if (\"type\" in c && // @ts-ignore\n    (c.type === \"http\" || c.type === \"basic\")) {\n      if (\"type\" in c && // @ts-ignore\n      (c.type === \"basic\" || c.type === \"http\" && c.scheme === \"basic\")) {\n        const { username: u, password: d } = t.http.basic, f = dW(u, d);\n        i.push({\n          name: \"Authorization\",\n          value: `Basic ${f}`.trim()\n        });\n      } else if (\"type\" in c && c.type === \"http\" && c.scheme === \"bearer\") {\n        const u = t.http.bearer.token.length ? t.http.bearer.token : \"YOUR_SECRET_TOKEN\";\n        i.push({\n          name: \"Authorization\",\n          value: `Bearer ${u}`\n        });\n      }\n    } else if (\"type\" in c && c.type.toLowerCase() === \"oauth2\") {\n      const u = t.oAuth2.accessToken || \"YOUR_SECRET_TOKEN\";\n      i.push({\n        name: \"Authorization\",\n        value: `Bearer ${u}`\n      });\n    }\n  }\n  return { headers: i, queryString: s, cookies: o };\n}\nfunction dW(t, e) {\n  return t != null && t.length || e != null && e.length ? cW(`${t}:${e}`) : \"\";\n}\nfunction fW(t) {\n  const e = Math.floor(((/* @__PURE__ */ new Date()).getTime() - t) / 1e3);\n  if (e < 45)\n    return \"just now\";\n  if (e < 60)\n    return `${e} seconds ago`;\n  const n = Math.floor(e / 60);\n  if (n < 60)\n    return `${n} minute${n === 1 ? \"\" : \"s\"} ago`;\n  const r = Math.floor(n / 60);\n  if (r < 24)\n    return `${r} hour${r === 1 ? \"\" : \"s\"} ago`;\n  const i = Math.floor(r / 24);\n  if (i < 30)\n    return `${i} day${i === 1 ? \"\" : \"s\"} ago`;\n  const s = Math.floor(i / 30);\n  return s < 12 ? `${s} month${s === 1 ? \"\" : \"s\"} ago` : \"more than a year ago\";\n}\nfunction Mc(t, e, n) {\n  const r = {};\n  return t.forEach((i) => {\n    r[i[e]] = i[n];\n  }), r;\n}\nconst hW = (t) => {\n  if (typeof t != \"string\")\n    return \"\";\n  let e = t.trim();\n  return e.length > 1 && e.startsWith(\"/\") && (e = e.slice(1)), e;\n}, Xc = \"GET\", pW = (t) => {\n  if (typeof t != \"string\")\n    return console.warn(\n      `[sendRequest] Request method is not a string. Using ${Xc} as the default.`\n    ), Xc;\n  const e = t.trim().toUpperCase();\n  return jh(e) ? e : (console.warn(\n    `[sendRequest] ${t} is not a valid request method. Using ${Xc} as the default.`\n  ), Xc);\n}, OW = (t) => {\n  if (typeof t != \"string\")\n    return console.warn(\n      \"[sendRequest] URL is not a string. Using an empty string as the default.\"\n    ), \"\";\n  let e = t;\n  e.startsWith(\"http\") || (console.warn(\n    \"[sendRequest] URL does not start with http. Adding http:// as the default prefix.\"\n  ), e = `http://${e}`);\n  const n = new URL(e);\n  return n.hostname = n.hostname.trim().toLowerCase(), n.toString();\n};\nfunction jc(t) {\n  return (t ?? []).map((e) => ({ ...e, enabled: !0 }));\n}\nconst gW = (t) => {\n  var e, n;\n  const { request: r } = t, { authentication: i } = Yl(), {\n    openApi: { operation: s, globalSecurity: o }\n  } = Cw(), a = wP(\n    i,\n    ((e = s == null ? void 0 : s.information) == null ? void 0 : e.security) ?? o\n  );\n  return r.headers = [\n    ...r.headers ?? [],\n    ...jc(a.headers)\n  ], r.cookies = [\n    ...r.cookies ?? [],\n    ...jc(a.cookies)\n  ], r.query = [\n    ...r.query ?? [],\n    ...jc(a.queryString)\n  ], r.body && Xh(r.body) && ((n = r.headers) != null && n.some(\n    (c) => c.name.toLowerCase() === \"content-type\"\n  ) || (r.headers = [\n    ...r.headers ?? [],\n    ...jc([\n      {\n        name: \"Content-Type\",\n        value: \"application/json; charset=utf-8\"\n      }\n    ])\n  ]), r.body = JSON.parse(r.body)), {\n    ...r\n  };\n}, mW = (t, e) => Object.entries(e).reduce((n, [r, i]) => n.replace(`{${r}}`, i.toString()), t);\nasync function bW(t, e) {\n  var n;\n  const r = pW(t.type), i = Mc(\n    (t.headers ?? []).filter((b) => b.enabled),\n    \"name\",\n    \"value\"\n  ), s = OW(t.url), o = hW(t.path), [a, ...l] = lW(\n    s,\n    o\n  ).split(\"?\"), c = mW(\n    a,\n    Mc(\n      (t.variables ?? []).filter((b) => b.enabled),\n      \"name\",\n      \"value\"\n    )\n  ), u = [];\n  l.forEach((b) => {\n    new URLSearchParams(b ?? \"\").forEach((g, v) => {\n      u.push({\n        name: v,\n        value: g,\n        enabled: !0\n      });\n    });\n  });\n  const d = new URLSearchParams(\n    // TODO: No type-casting\n    Mc(\n      [\n        ...(t.query ?? []).filter((b) => b.enabled),\n        ...u\n      ],\n      \"name\",\n      \"value\"\n    )\n  ).toString(), f = `${c}${d ? \"?\" + d : \"\"}`, h = {\n    type: \"none\"\n  }, p = Date.now();\n  if (t.cookies && ((n = t.cookies) == null ? void 0 : n.length) > 0) {\n    const b = Mc(\n      (t.cookies ?? []).filter((g) => g.enabled),\n      \"name\",\n      \"value\"\n    );\n    i.Cookie = Object.keys(b).map((g) => `${g}=${b[g]}`).join(\"; \");\n  }\n  const O = {\n    method: r,\n    url: f,\n    auth: h,\n    headers: i,\n    data: t.body\n  }, m = e ? {\n    method: \"POST\",\n    url: e,\n    data: O\n  } : {\n    method: O.method,\n    url: O.url,\n    headers: O.headers,\n    data: O.data\n  };\n  i.cookies && (m.withCredentials = !0), console.info(e ? `${O.method} ${e}  ${O.url}` : `${O.method} ${O.url}`);\n  const y = await At(m).then((b) => e ? {\n    ...b.data,\n    error: !1\n  } : {\n    ...b,\n    statusCode: b.status,\n    data: JSON.stringify(b.data),\n    error: !1\n  }).catch((b) => {\n    const { response: g } = b;\n    return {\n      headers: {\n        \"content-type\": \"application/json; charset=utf-8\"\n      },\n      ...g,\n      statusCode: (g == null ? void 0 : g.status) ?? 0,\n      data: JSON.stringify((g == null ? void 0 : g.data) ?? { error: b.code })\n    };\n  });\n  return {\n    sentTime: Date.now(),\n    request: {\n      ...t,\n      type: r,\n      url: s,\n      path: o\n    },\n    response: {\n      ...y,\n      duration: Date.now() - p\n    },\n    responseId: u2()\n  };\n}\nconst vW = { class: \"navtable-item-40 navtable-item-request\" }, yW = { class: \"navtable-item-40 navtable-item-response\" }, SW = { class: \"navtable-item-20 navtable-item-time\" }, wW = /* @__PURE__ */ le({\n  __name: \"RequestHistoryItem\",\n  props: {\n    history: {}\n  },\n  setup(t) {\n    const { requestHistory: e, activeRequestId: n, setActiveResponse: r } = sr(), i = (s) => {\n      var o;\n      return (o = s == null ? void 0 : s.headers) != null && o[\"X-API-Client-Content-Length\"] ? Cu(\n        parseFloat(s.headers[\"X-API-Client-Content-Length\"])\n      ) : Cu(0);\n    };\n    return (s, o) => (Z(), ne(\"div\", {\n      class: Ke([\"navtable-item\", { \"navtable-item__active\": R(n) === s.history }]),\n      onClick: o[0] || (o[0] = (a) => R(r)(s.history))\n    }, [\n      D(\"div\", vW, [\n        D(\"button\", {\n          class: Ke([\"radio\", R(e)[s.history].request.type.toLowerCase()]),\n          type: \"button\"\n        }, null, 2),\n        D(\"span\", null, [\n          D(\"em\", null, De(R(e)[s.history].request.type), 1),\n          He(\" \" + De(R(e)[s.history].request.url), 1)\n        ])\n      ]),\n      D(\"div\", yW, [\n        D(\"span\", null, De(R(dw)(R(e)[s.history].response.duration)), 1),\n        D(\"span\", {\n          class: Ke(`scalar-api-client__status--${String(\n            R(e)[s.history].response.statusCode\n          ).charAt(0)}xx`)\n        }, De(R(e)[s.history].response.statusCode), 3),\n        D(\"span\", null, De(i(R(e)[s.history].response)), 1)\n      ]),\n      D(\"div\", SW, [\n        D(\"span\", null, De(R(fW)(R(e)[s.history].sentTime)), 1)\n      ])\n    ], 2));\n  }\n}), kW = /* @__PURE__ */ ct(wW, [[\"__scopeId\", \"data-v-353c6d86\"]]), xW = { class: \"navigation-content-item\" }, PW = { class: \"navtable\" }, _W = { class: \"navtable-table\" }, TW = /* @__PURE__ */ Wl('<div class=\"navtable-item navtable-item__top\"><div class=\"navtable-item-40\"><label for=\"\">Request</label></div><div class=\"navtable-item-40\"><label for=\"\">Response</label></div><div class=\"navtable-item-20\"><label for=\"\">TIME</label></div></div>', 1), EW = { class: \"navtable-radios\" }, $W = /* @__PURE__ */ Wl('<div class=\"navtable-mock\"><div class=\"navtable-item\"><div class=\"navtable-item-40\"></div><div class=\"navtable-item-40\"></div><div class=\"navtable-item-20\"></div></div></div>', 1), QW = /* @__PURE__ */ le({\n  __name: \"RequestHistory\",\n  emits: [\"toggle\"],\n  setup(t) {\n    const { requestHistoryOrder: e } = sr();\n    return (n, r) => (Z(), ne(\"div\", xW, [\n      D(\"div\", PW, [\n        D(\"div\", _W, [\n          TW,\n          D(\"div\", EW, [\n            (Z(!0), ne(Pe, null, Xr(R(e), (i) => (Z(), ke(kW, {\n              key: i,\n              history: i\n            }, null, 8, [\"history\"]))), 128))\n          ]),\n          $W\n        ])\n      ])\n    ]));\n  }\n}), CW = { class: \"request-method-select\" }, AW = [\"disabled\", \"value\"], RW = [\"value\"], NW = /* @__PURE__ */ le({\n  __name: \"RequestMethodSelect\",\n  props: {\n    requestMethod: {},\n    readOnly: { type: Boolean, default: !0 }\n  },\n  emits: [\"change\"],\n  setup(t) {\n    const e = [\n      \"GET\",\n      \"POST\",\n      \"PUT\",\n      // 'HEAD',\n      \"DELETE\",\n      \"PATCH\"\n      // 'OPTIONS',\n      // 'CONNECT',\n      // 'TRACE',\n    ];\n    return (n, r) => (Z(), ne(\"div\", CW, [\n      D(\"span\", {\n        class: Ke([\"request-method\", { \"request-method--disabled\": n.readOnly }])\n      }, [\n        D(\"span\", null, De(n.requestMethod), 1)\n      ], 2),\n      D(\"select\", {\n        disabled: n.readOnly,\n        value: n.requestMethod.toLowerCase(),\n        onInput: r[0] || (r[0] = (i) => n.$emit(\"change\", i.target.value))\n      }, [\n        (Z(), ne(Pe, null, Xr(e, (i) => D(\"option\", {\n          key: i,\n          value: i.toLocaleLowerCase()\n        }, De(i), 9, RW)), 64))\n      ], 40, AW)\n    ]));\n  }\n}), DW = /* @__PURE__ */ ct(NW, [[\"__scopeId\", \"data-v-0f1e5bdc\"]]), tc = (t) => (Ks(\"data-v-2967e07a\"), t = t(), Js(), t), ZW = {\n  key: 0,\n  class: \"loader\"\n}, VW = { class: \"url-form\" }, IW = { class: \"url-form-field\" }, WW = { class: \"url-form-input-wrapper cm-scroller\" }, MW = /* @__PURE__ */ tc(() => /* @__PURE__ */ D(\"div\", { class: \"url-form-input-fade__left\" }, null, -1)), XW = /* @__PURE__ */ tc(() => /* @__PURE__ */ D(\"div\", { class: \"url-form-input-fade__right\" }, null, -1)), jW = {\n  key: 0,\n  class: \"history\"\n}, BW = /* @__PURE__ */ tc(() => /* @__PURE__ */ D(\"svg\", {\n  fill: \"none\",\n  height: \"48\",\n  viewBox: \"0 0 14 14\",\n  width: \"48\",\n  xmlns: \"http://www.w3.org/2000/svg\"\n}, [\n  /* @__PURE__ */ D(\"g\", { id: \"rewind-clock--back-return-clock-timer-countdown\" }, [\n    /* @__PURE__ */ D(\"path\", {\n      id: \"Vector 1561 (Stroke)\",\n      \"clip-rule\": \"evenodd\",\n      d: \"M6.99999 2.75C7.4142 2.75 7.74999 3.08579 7.74999 3.5V7.5C7.74999 7.76345 7.61177 8.00758 7.38586 8.14312L4.88586 9.64312C4.53068 9.85623 4.06998 9.74106 3.85687 9.38587C3.64376 9.03069 3.75893 8.56999 4.11412 8.35688L6.24999 7.07536V3.5C6.24999 3.08579 6.58578 2.75 6.99999 2.75Z\",\n      fill: \"currentColor\",\n      \"fill-rule\": \"evenodd\"\n    }),\n    /* @__PURE__ */ D(\"path\", {\n      id: \"Union\",\n      \"clip-rule\": \"evenodd\",\n      d: \"M12.5 7C12.5 3.96243 10.0376 1.5 7 1.5C5.24916 1.5 3.68853 2.31796 2.68066 3.59456L3.64645 4.56034C3.96143 4.87533 3.73835 5.4139 3.29289 5.4139H0.5C0.223857 5.4139 0 5.19004 0 4.9139V2.121C0 1.67555 0.53857 1.45247 0.853553 1.76745L1.61439 2.52829C2.89781 0.984301 4.83356 0 7 0C10.866 0 14 3.13401 14 7C14 10.866 10.866 14 7 14C3.68902 14 0.916591 11.702 0.187329 8.61473C0.0921059 8.21161 0.341704 7.80762 0.744824 7.7124C1.14794 7.61717 1.55193 7.86677 1.64715 8.26989C2.22013 10.6955 4.40025 12.5 7 12.5C10.0376 12.5 12.5 10.0376 12.5 7Z\",\n      fill: \"currentColor\",\n      \"fill-rule\": \"evenodd\"\n    })\n  ])\n], -1)), LW = [\n  BW\n], UW = [\"disabled\"], qW = /* @__PURE__ */ tc(() => /* @__PURE__ */ D(\"svg\", {\n  fill: \"none\",\n  height: \"48\",\n  viewBox: \"0 0 14 14\",\n  width: \"48\",\n  xmlns: \"http://www.w3.org/2000/svg\"\n}, [\n  /* @__PURE__ */ D(\"g\", { id: \"send-email--mail-send-email-paper-airplane\" }, [\n    /* @__PURE__ */ D(\"path\", {\n      id: \"Subtract\",\n      \"clip-rule\": \"evenodd\",\n      d: \"M11.8215 0.0977331C12.1097 -0.0075178 12.422 -0.0287134 12.7219 0.0367172C13.0248 0.102803 13.3024 0.254481 13.5216 0.473719C13.7409 0.692957 13.8926 0.970537 13.9586 1.27346C14.0241 1.57338 14.0029 1.88566 13.8976 2.17389L10.3236 12.8859L10.3234 12.8866C10.2363 13.15 10.083 13.3867 9.87813 13.5739C9.67383 13.7606 9.42512 13.8917 9.15575 13.9549C8.88633 14.0206 8.60444 14.015 8.33777 13.9388C8.07134 13.8627 7.82929 13.7187 7.63532 13.5209L5.71798 11.6123L3.70392 12.6538C3.54687 12.735 3.3586 12.7272 3.20877 12.6333C3.05895 12.5395 2.96984 12.3734 2.97443 12.1967L3.057 9.01294L10.102 3.89553C10.3812 3.69267 10.4432 3.30182 10.2403 3.02255C10.0375 2.74327 9.64662 2.68133 9.36734 2.88419L2.20286 8.0884L0.473156 6.35869L0.473098 6.35864L0.472971 6.35851C0.285648 6.17132 0.147746 5.94054 0.0716498 5.68688C-0.00390565 5.43503 -0.016181 5.16847 0.0358684 4.91079C0.087985 4.62928 0.213827 4.36658 0.400607 4.14951C0.588668 3.93095 0.831681 3.76658 1.10453 3.67339L1.1079 3.67224L1.1079 3.67225L11.8215 0.0977331Z\",\n      fill: \"currentColor\",\n      \"fill-rule\": \"evenodd\"\n    })\n  ])\n], -1)), YW = /* @__PURE__ */ tc(() => /* @__PURE__ */ D(\"span\", null, \"Send\", -1)), zW = [\n  qW,\n  YW\n], HW = { class: \"address-bar-content\" }, FW = /* @__PURE__ */ le({\n  __name: \"AddressBar\",\n  props: {\n    proxyUrl: {}\n  },\n  emits: [\"onSend\"],\n  setup(t, { emit: e }) {\n    const n = t, r = e, i = BS();\n    Nh(aW() ? i.meta_enter : i.ctrl_enter, b);\n    const s = G(!1), o = G(!1), {\n      activeRequest: a,\n      addRequestToHistory: l,\n      requestHistory: c,\n      requestHistoryOrder: u,\n      readOnly: d,\n      setActiveRequest: f\n    } = sr(), h = oW(), p = j(() => a.url), O = j(() => a.type), m = j(() => a.path), y = j(() => `${p.value}${m.value}`);\n    async function b() {\n      const S = gW({\n        request: { ...a }\n      });\n      o.value = !0, r(\"onSend\");\n      const w = await bW(S, n.proxyUrl);\n      w && l(w), o.value = !1;\n    }\n    const g = (S) => {\n      d.value || a.url + a.path !== S && f({ ...a, url: S, path: \"\" });\n    }, v = (S) => {\n      S && f({\n        ...a,\n        type: S.toLocaleLowerCase()\n      });\n    };\n    return (S, w) => (Z(), ne(Pe, null, [\n      o.value ? (Z(), ne(\"div\", ZW)) : st(\"\", !0),\n      D(\"div\", {\n        class: Ke([\"address-bar\", { \"address-bar--with-history\": s.value }])\n      }, [\n        D(\"div\", VW, [\n          D(\"div\", IW, [\n            J(DW, {\n              readOnly: R(d),\n              requestMethod: O.value,\n              onChange: v\n            }, null, 8, [\"readOnly\", \"requestMethod\"]),\n            D(\"div\", WW, [\n              MW,\n              J(R(SP), {\n                class: \"url-form-input\",\n                content: y.value,\n                disableEnter: \"\",\n                readOnly: R(d),\n                withoutTheme: \"\",\n                withVariables: \"\",\n                onChange: g\n              }, null, 8, [\"content\", \"readOnly\"]),\n              XW\n            ]),\n            R(u).length ? (Z(), ne(\"div\", jW, [\n              D(\"div\", {\n                class: \"history-toggle\",\n                onClick: w[0] || (w[0] = (k) => R(h).show())\n              }, LW)\n            ])) : st(\"\", !0),\n            D(\"button\", {\n              class: \"send-button\",\n              disabled: !y.value.trim().length,\n              type: \"submit\",\n              onClick: b\n            }, zW, 8, UW)\n          ])\n        ]),\n        D(\"div\", {\n          class: \"address-bar-close\",\n          onClick: w[1] || (w[1] = (k) => s.value = !1)\n        }),\n        D(\"div\", HW, [\n          J(R(sW), {\n            state: R(h),\n            title: \"Request History\",\n            variant: \"history\"\n          }, {\n            default: ce(() => [\n              J(QW, {\n                showHistory: s.value,\n                onToggle: w[2] || (w[2] = (k) => s.value = !s.value)\n              }, null, 8, [\"showHistory\"])\n            ]),\n            _: 1\n          }, 8, [\"state\"])\n        ])\n      ], 2)\n    ], 64));\n  }\n}), GW = /* @__PURE__ */ ct(FW, [[\"__scopeId\", \"data-v-2967e07a\"]]), kP = UC(Symbol()), KW = { class: \"scalar-api-client__toggle-container\" }, JW = { class: \"scalar-api-client__item__title\" }, eM = {\n  key: 0,\n  class: \"scalar-api-client__item__options\"\n}, tM = /* @__PURE__ */ D(\"svg\", {\n  class: \"scalar-api-client__toggle__icon\",\n  xmlns: \"http://www.w3.org/2000/svg\",\n  fill: \"none\",\n  viewBox: \"0 0 12 12\"\n}, [\n  /* @__PURE__ */ D(\"path\", {\n    stroke: \"currentColor\",\n    \"stroke-linecap\": \"round\",\n    \"stroke-linejoin\": \"round\",\n    d: \"M2.2 4.1 6 7.9l3.8-3.8\"\n  })\n], -1), nM = { class: \"scalar-api-client__item__content\" }, bi = /* @__PURE__ */ le({\n  __name: \"CollapsibleSection\",\n  props: {\n    title: {},\n    defaultOpen: { type: Boolean, default: !0 }\n  },\n  setup(t) {\n    const e = t, n = G(null), r = G(null), i = G(e.defaultOpen);\n    return ht(\n      () => e.defaultOpen,\n      (s, o) => {\n        var a;\n        s !== o && s !== i.value && ((a = n.value) == null || a.el.click());\n      }\n    ), (s, o) => (Z(), ke(R(bC), {\n      ref_key: \"disclosureButton\",\n      ref: r,\n      defaultOpen: s.defaultOpen\n    }, {\n      default: ce(({ open: a }) => [\n        D(\"div\", {\n          class: Ke([\"scalar-api-client__item\", { \"scalar-api-client__item--open\": a }])\n        }, [\n          J(R(vC), {\n            ref_key: \"collapseButton\",\n            ref: n,\n            class: \"scalar-api-client__toggle\",\n            onClick: o[0] || (o[0] = (l) => i.value = !i.value)\n          }, {\n            default: ce(() => [\n              D(\"div\", KW, [\n                D(\"span\", JW, De(s.title), 1),\n                s.$slots.options && a ? (Z(), ne(\"div\", eM, [\n                  pt(s.$slots, \"options\")\n                ])) : st(\"\", !0)\n              ]),\n              tM\n            ]),\n            _: 2\n          }, 1536),\n          J(R(yC), null, {\n            default: ce(() => [\n              D(\"div\", nM, [\n                pt(s.$slots, \"default\")\n              ])\n            ]),\n            _: 3\n          })\n        ], 2)\n      ]),\n      _: 3\n    }, 8, [\"defaultOpen\"]));\n  }\n}), rM = {}, iM = { class: \"card-form\" };\nfunction sM(t, e) {\n  return Z(), ne(\"form\", iM, [\n    pt(t.$slots, \"default\", {}, void 0, !0)\n  ]);\n}\nconst oM = /* @__PURE__ */ ct(rM, [[\"render\", sM], [\"__scopeId\", \"data-v-bc8cea71\"]]), aM = /* @__PURE__ */ le({\n  __name: \"CardFormButton\",\n  setup(t, { expose: e }) {\n    const n = G();\n    return e({ el: n }), (r, i) => (Z(), ne(\"button\", {\n      ref_key: \"el\",\n      ref: n,\n      class: \"card-form-button\",\n      type: \"button\"\n    }, [\n      pt(r.$slots, \"default\", {}, void 0, !0)\n    ], 512));\n  }\n}), xP = /* @__PURE__ */ ct(aM, [[\"__scopeId\", \"data-v-6ae053e9\"]]), lM = {}, cM = { class: \"card-form-group\" };\nfunction uM(t, e) {\n  return Z(), ne(\"div\", cM, [\n    pt(t.$slots, \"default\", {}, void 0, !0)\n  ]);\n}\nconst N0 = /* @__PURE__ */ ct(lM, [[\"render\", uM], [\"__scopeId\", \"data-v-6b5d2194\"]]);\nfunction PP(t) {\n  var e, n, r = \"\";\n  if (typeof t == \"string\" || typeof t == \"number\")\n    r += t;\n  else if (typeof t == \"object\")\n    if (Array.isArray(t))\n      for (e = 0; e < t.length; e++)\n        t[e] && (n = PP(t[e])) && (r && (r += \" \"), r += n);\n    else\n      for (e in t)\n        t[e] && (r && (r += \" \"), r += e);\n  return r;\n}\nfunction Jf() {\n  for (var t, e, n = 0, r = \"\"; n < arguments.length; )\n    (t = arguments[n++]) && (e = PP(t)) && (r && (r += \" \"), r += e);\n  return r;\n}\nconst D0 = (t) => typeof t == \"boolean\" ? \"\".concat(t) : t === 0 ? \"0\" : t, dM = (t) => {\n  const e = function() {\n    for (var i = arguments.length, s = new Array(i), o = 0; o < i; o++)\n      s[o] = arguments[o];\n    var a, l;\n    return typeof (t == null || (a = t.hooks) === null || a === void 0 ? void 0 : a[\"cx:done\"]) < \"u\" ? t == null ? void 0 : t.hooks[\"cx:done\"](Jf(s)) : typeof (t == null || (l = t.hooks) === null || l === void 0 ? void 0 : l.onComplete) < \"u\" ? t == null ? void 0 : t.hooks.onComplete(Jf(s)) : Jf(s);\n  };\n  return { compose: function() {\n    for (var i = arguments.length, s = new Array(i), o = 0; o < i; o++)\n      s[o] = arguments[o];\n    return (a) => {\n      const l = Object.fromEntries(Object.entries(a || {}).filter((c) => {\n        let [u] = c;\n        return ![\"class\", \"className\"].includes(u);\n      }));\n      return e(s.map((c) => c(l)), a == null ? void 0 : a.class, a == null ? void 0 : a.className);\n    };\n  }, cva: (i) => (s) => {\n    var o;\n    if ((i == null ? void 0 : i.variants) == null)\n      return e(i == null ? void 0 : i.base, s == null ? void 0 : s.class, s == null ? void 0 : s.className);\n    const { variants: a, defaultVariants: l } = i, c = Object.keys(a).map((f) => {\n      const h = s == null ? void 0 : s[f], p = l == null ? void 0 : l[f], O = D0(h) || D0(p);\n      return a[f][O];\n    }), u = { ...l, ...s && Object.entries(s).reduce((f, h) => {\n      let [p, O] = h;\n      return typeof O > \"u\" ? f : { ...f, [p]: O };\n    }, {}) }, d = i == null || (o = i.compoundVariants) === null || o === void 0 ? void 0 : o.reduce((f, h) => {\n      let { class: p, className: O, ...m } = h;\n      return Object.entries(m).every((y) => {\n        let [b, g] = y;\n        const v = u[b];\n        return Array.isArray(g) ? g.includes(v) : v === g;\n      }) ? [...f, p, O] : f;\n    }, []);\n    return e(i == null ? void 0 : i.base, c, d, s == null ? void 0 : s.class, s == null ? void 0 : s.className);\n  }, cx: e };\n}, Eg = \"-\";\nfunction fM(t) {\n  const e = pM(t), {\n    conflictingClassGroups: n,\n    conflictingClassGroupModifiers: r\n  } = t;\n  function i(o) {\n    const a = o.split(Eg);\n    return a[0] === \"\" && a.length !== 1 && a.shift(), _P(a, e) || hM(o);\n  }\n  function s(o, a) {\n    const l = n[o] || [];\n    return a && r[o] ? [...l, ...r[o]] : l;\n  }\n  return {\n    getClassGroupId: i,\n    getConflictingClassGroupIds: s\n  };\n}\nfunction _P(t, e) {\n  var n;\n  if (t.length === 0)\n    return e.classGroupId;\n  const r = t[0], i = e.nextPart.get(r), s = i ? _P(t.slice(1), i) : void 0;\n  if (s)\n    return s;\n  if (e.validators.length === 0)\n    return;\n  const o = t.join(Eg);\n  return (n = e.validators.find(({\n    validator: a\n  }) => a(o))) == null ? void 0 : n.classGroupId;\n}\nconst Z0 = /^\\[(.+)\\]$/;\nfunction hM(t) {\n  if (Z0.test(t)) {\n    const e = Z0.exec(t)[1], n = e == null ? void 0 : e.substring(0, e.indexOf(\":\"));\n    if (n)\n      return \"arbitrary..\" + n;\n  }\n}\nfunction pM(t) {\n  const {\n    theme: e,\n    prefix: n\n  } = t, r = {\n    nextPart: /* @__PURE__ */ new Map(),\n    validators: []\n  };\n  return gM(Object.entries(t.classGroups), n).forEach(([s, o]) => {\n    Ip(o, r, s, e);\n  }), r;\n}\nfunction Ip(t, e, n, r) {\n  t.forEach((i) => {\n    if (typeof i == \"string\") {\n      const s = i === \"\" ? e : V0(e, i);\n      s.classGroupId = n;\n      return;\n    }\n    if (typeof i == \"function\") {\n      if (OM(i)) {\n        Ip(i(r), e, n, r);\n        return;\n      }\n      e.validators.push({\n        validator: i,\n        classGroupId: n\n      });\n      return;\n    }\n    Object.entries(i).forEach(([s, o]) => {\n      Ip(o, V0(e, s), n, r);\n    });\n  });\n}\nfunction V0(t, e) {\n  let n = t;\n  return e.split(Eg).forEach((r) => {\n    n.nextPart.has(r) || n.nextPart.set(r, {\n      nextPart: /* @__PURE__ */ new Map(),\n      validators: []\n    }), n = n.nextPart.get(r);\n  }), n;\n}\nfunction OM(t) {\n  return t.isThemeGetter;\n}\nfunction gM(t, e) {\n  return e ? t.map(([n, r]) => {\n    const i = r.map((s) => typeof s == \"string\" ? e + s : typeof s == \"object\" ? Object.fromEntries(Object.entries(s).map(([o, a]) => [e + o, a])) : s);\n    return [n, i];\n  }) : t;\n}\nfunction mM(t) {\n  if (t < 1)\n    return {\n      get: () => {\n      },\n      set: () => {\n      }\n    };\n  let e = 0, n = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map();\n  function i(s, o) {\n    n.set(s, o), e++, e > t && (e = 0, r = n, n = /* @__PURE__ */ new Map());\n  }\n  return {\n    get(s) {\n      let o = n.get(s);\n      if (o !== void 0)\n        return o;\n      if ((o = r.get(s)) !== void 0)\n        return i(s, o), o;\n    },\n    set(s, o) {\n      n.has(s) ? n.set(s, o) : i(s, o);\n    }\n  };\n}\nconst TP = \"!\";\nfunction bM(t) {\n  const e = t.separator, n = e.length === 1, r = e[0], i = e.length;\n  return function(o) {\n    const a = [];\n    let l = 0, c = 0, u;\n    for (let O = 0; O < o.length; O++) {\n      let m = o[O];\n      if (l === 0) {\n        if (m === r && (n || o.slice(O, O + i) === e)) {\n          a.push(o.slice(c, O)), c = O + i;\n          continue;\n        }\n        if (m === \"/\") {\n          u = O;\n          continue;\n        }\n      }\n      m === \"[\" ? l++ : m === \"]\" && l--;\n    }\n    const d = a.length === 0 ? o : o.substring(c), f = d.startsWith(TP), h = f ? d.substring(1) : d, p = u && u > c ? u - c : void 0;\n    return {\n      modifiers: a,\n      hasImportantModifier: f,\n      baseClassName: h,\n      maybePostfixModifierPosition: p\n    };\n  };\n}\nfunction vM(t) {\n  if (t.length <= 1)\n    return t;\n  const e = [];\n  let n = [];\n  return t.forEach((r) => {\n    r[0] === \"[\" ? (e.push(...n.sort(), r), n = []) : n.push(r);\n  }), e.push(...n.sort()), e;\n}\nfunction yM(t) {\n  return {\n    cache: mM(t.cacheSize),\n    splitModifiers: bM(t),\n    ...fM(t)\n  };\n}\nconst SM = /\\s+/;\nfunction wM(t, e) {\n  const {\n    splitModifiers: n,\n    getClassGroupId: r,\n    getConflictingClassGroupIds: i\n  } = e, s = /* @__PURE__ */ new Set();\n  return t.trim().split(SM).map((o) => {\n    const {\n      modifiers: a,\n      hasImportantModifier: l,\n      baseClassName: c,\n      maybePostfixModifierPosition: u\n    } = n(o);\n    let d = r(u ? c.substring(0, u) : c), f = !!u;\n    if (!d) {\n      if (!u)\n        return {\n          isTailwindClass: !1,\n          originalClassName: o\n        };\n      if (d = r(c), !d)\n        return {\n          isTailwindClass: !1,\n          originalClassName: o\n        };\n      f = !1;\n    }\n    const h = vM(a).join(\":\");\n    return {\n      isTailwindClass: !0,\n      modifierId: l ? h + TP : h,\n      classGroupId: d,\n      originalClassName: o,\n      hasPostfixModifier: f\n    };\n  }).reverse().filter((o) => {\n    if (!o.isTailwindClass)\n      return !0;\n    const {\n      modifierId: a,\n      classGroupId: l,\n      hasPostfixModifier: c\n    } = o, u = a + l;\n    return s.has(u) ? !1 : (s.add(u), i(l, c).forEach((d) => s.add(a + d)), !0);\n  }).reverse().map((o) => o.originalClassName).join(\" \");\n}\nfunction kM() {\n  let t = 0, e, n, r = \"\";\n  for (; t < arguments.length; )\n    (e = arguments[t++]) && (n = EP(e)) && (r && (r += \" \"), r += n);\n  return r;\n}\nfunction EP(t) {\n  if (typeof t == \"string\")\n    return t;\n  let e, n = \"\";\n  for (let r = 0; r < t.length; r++)\n    t[r] && (e = EP(t[r])) && (n && (n += \" \"), n += e);\n  return n;\n}\nfunction I0(t, ...e) {\n  let n, r, i, s = o;\n  function o(l) {\n    const c = e.reduce((u, d) => d(u), t());\n    return n = yM(c), r = n.cache.get, i = n.cache.set, s = a, a(l);\n  }\n  function a(l) {\n    const c = r(l);\n    if (c)\n      return c;\n    const u = wM(l, n);\n    return i(l, u), u;\n  }\n  return function() {\n    return s(kM.apply(null, arguments));\n  };\n}\nfunction ut(t) {\n  const e = (n) => n[t] || [];\n  return e.isThemeGetter = !0, e;\n}\nconst $P = /^\\[(?:([a-z-]+):)?(.+)\\]$/i, xM = /^\\d+\\/\\d+$/, PM = /* @__PURE__ */ new Set([\"px\", \"full\", \"screen\"]), _M = /^(\\d+(\\.\\d+)?)?(xs|sm|md|lg|xl)$/, TM = /\\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\\b(calc|min|max|clamp)\\(.+\\)|^0$/, EM = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\\(.+\\)$/, $M = /^(inset_)?-?((\\d+)?\\.?(\\d+)[a-z]+|0)_-?((\\d+)?\\.?(\\d+)[a-z]+|0)/, QM = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\\(.+\\)$/;\nfunction zr(t) {\n  return Es(t) || PM.has(t) || xM.test(t);\n}\nfunction Pi(t) {\n  return aa(t, \"length\", IM);\n}\nfunction Es(t) {\n  return !!t && !Number.isNaN(Number(t));\n}\nfunction Bc(t) {\n  return aa(t, \"number\", Es);\n}\nfunction _a(t) {\n  return !!t && Number.isInteger(Number(t));\n}\nfunction CM(t) {\n  return t.endsWith(\"%\") && Es(t.slice(0, -1));\n}\nfunction Te(t) {\n  return $P.test(t);\n}\nfunction _i(t) {\n  return _M.test(t);\n}\nconst AM = /* @__PURE__ */ new Set([\"length\", \"size\", \"percentage\"]);\nfunction RM(t) {\n  return aa(t, AM, QP);\n}\nfunction NM(t) {\n  return aa(t, \"position\", QP);\n}\nconst DM = /* @__PURE__ */ new Set([\"image\", \"url\"]);\nfunction ZM(t) {\n  return aa(t, DM, MM);\n}\nfunction VM(t) {\n  return aa(t, \"\", WM);\n}\nfunction Ta() {\n  return !0;\n}\nfunction aa(t, e, n) {\n  const r = $P.exec(t);\n  return r ? r[1] ? typeof e == \"string\" ? r[1] === e : e.has(r[1]) : n(r[2]) : !1;\n}\nfunction IM(t) {\n  return TM.test(t) && !EM.test(t);\n}\nfunction QP() {\n  return !1;\n}\nfunction WM(t) {\n  return $M.test(t);\n}\nfunction MM(t) {\n  return QM.test(t);\n}\nfunction W0() {\n  const t = ut(\"colors\"), e = ut(\"spacing\"), n = ut(\"blur\"), r = ut(\"brightness\"), i = ut(\"borderColor\"), s = ut(\"borderRadius\"), o = ut(\"borderSpacing\"), a = ut(\"borderWidth\"), l = ut(\"contrast\"), c = ut(\"grayscale\"), u = ut(\"hueRotate\"), d = ut(\"invert\"), f = ut(\"gap\"), h = ut(\"gradientColorStops\"), p = ut(\"gradientColorStopPositions\"), O = ut(\"inset\"), m = ut(\"margin\"), y = ut(\"opacity\"), b = ut(\"padding\"), g = ut(\"saturate\"), v = ut(\"scale\"), S = ut(\"sepia\"), w = ut(\"skew\"), k = ut(\"space\"), _ = ut(\"translate\"), T = () => [\"auto\", \"contain\", \"none\"], C = () => [\"auto\", \"hidden\", \"clip\", \"visible\", \"scroll\"], A = () => [\"auto\", Te, e], Q = () => [Te, e], W = () => [\"\", zr, Pi], L = () => [\"auto\", Es, Te], re = () => [\"bottom\", \"center\", \"left\", \"left-bottom\", \"left-top\", \"right\", \"right-bottom\", \"right-top\", \"top\"], Y = () => [\"solid\", \"dashed\", \"dotted\", \"double\", \"none\"], K = () => [\"normal\", \"multiply\", \"screen\", \"overlay\", \"darken\", \"lighten\", \"color-dodge\", \"color-burn\", \"hard-light\", \"soft-light\", \"difference\", \"exclusion\", \"hue\", \"saturation\", \"color\", \"luminosity\"], B = () => [\"start\", \"end\", \"center\", \"between\", \"around\", \"evenly\", \"stretch\"], _e = () => [\"\", \"0\", Te], Ce = () => [\"auto\", \"avoid\", \"all\", \"avoid-page\", \"page\", \"left\", \"right\", \"column\"], ue = () => [Es, Bc], ge = () => [Es, Te];\n  return {\n    cacheSize: 500,\n    separator: \":\",\n    theme: {\n      colors: [Ta],\n      spacing: [zr, Pi],\n      blur: [\"none\", \"\", _i, Te],\n      brightness: ue(),\n      borderColor: [t],\n      borderRadius: [\"none\", \"\", \"full\", _i, Te],\n      borderSpacing: Q(),\n      borderWidth: W(),\n      contrast: ue(),\n      grayscale: _e(),\n      hueRotate: ge(),\n      invert: _e(),\n      gap: Q(),\n      gradientColorStops: [t],\n      gradientColorStopPositions: [CM, Pi],\n      inset: A(),\n      margin: A(),\n      opacity: ue(),\n      padding: Q(),\n      saturate: ue(),\n      scale: ue(),\n      sepia: _e(),\n      skew: ge(),\n      space: Q(),\n      translate: Q()\n    },\n    classGroups: {\n      // Layout\n      /**\n       * Aspect Ratio\n       * @see https://tailwindcss.com/docs/aspect-ratio\n       */\n      aspect: [{\n        aspect: [\"auto\", \"square\", \"video\", Te]\n      }],\n      /**\n       * Container\n       * @see https://tailwindcss.com/docs/container\n       */\n      container: [\"container\"],\n      /**\n       * Columns\n       * @see https://tailwindcss.com/docs/columns\n       */\n      columns: [{\n        columns: [_i]\n      }],\n      /**\n       * Break After\n       * @see https://tailwindcss.com/docs/break-after\n       */\n      \"break-after\": [{\n        \"break-after\": Ce()\n      }],\n      /**\n       * Break Before\n       * @see https://tailwindcss.com/docs/break-before\n       */\n      \"break-before\": [{\n        \"break-before\": Ce()\n      }],\n      /**\n       * Break Inside\n       * @see https://tailwindcss.com/docs/break-inside\n       */\n      \"break-inside\": [{\n        \"break-inside\": [\"auto\", \"avoid\", \"avoid-page\", \"avoid-column\"]\n      }],\n      /**\n       * Box Decoration Break\n       * @see https://tailwindcss.com/docs/box-decoration-break\n       */\n      \"box-decoration\": [{\n        \"box-decoration\": [\"slice\", \"clone\"]\n      }],\n      /**\n       * Box Sizing\n       * @see https://tailwindcss.com/docs/box-sizing\n       */\n      box: [{\n        box: [\"border\", \"content\"]\n      }],\n      /**\n       * Display\n       * @see https://tailwindcss.com/docs/display\n       */\n      display: [\"block\", \"inline-block\", \"inline\", \"flex\", \"inline-flex\", \"table\", \"inline-table\", \"table-caption\", \"table-cell\", \"table-column\", \"table-column-group\", \"table-footer-group\", \"table-header-group\", \"table-row-group\", \"table-row\", \"flow-root\", \"grid\", \"inline-grid\", \"contents\", \"list-item\", \"hidden\"],\n      /**\n       * Floats\n       * @see https://tailwindcss.com/docs/float\n       */\n      float: [{\n        float: [\"right\", \"left\", \"none\", \"start\", \"end\"]\n      }],\n      /**\n       * Clear\n       * @see https://tailwindcss.com/docs/clear\n       */\n      clear: [{\n        clear: [\"left\", \"right\", \"both\", \"none\", \"start\", \"end\"]\n      }],\n      /**\n       * Isolation\n       * @see https://tailwindcss.com/docs/isolation\n       */\n      isolation: [\"isolate\", \"isolation-auto\"],\n      /**\n       * Object Fit\n       * @see https://tailwindcss.com/docs/object-fit\n       */\n      \"object-fit\": [{\n        object: [\"contain\", \"cover\", \"fill\", \"none\", \"scale-down\"]\n      }],\n      /**\n       * Object Position\n       * @see https://tailwindcss.com/docs/object-position\n       */\n      \"object-position\": [{\n        object: [...re(), Te]\n      }],\n      /**\n       * Overflow\n       * @see https://tailwindcss.com/docs/overflow\n       */\n      overflow: [{\n        overflow: C()\n      }],\n      /**\n       * Overflow X\n       * @see https://tailwindcss.com/docs/overflow\n       */\n      \"overflow-x\": [{\n        \"overflow-x\": C()\n      }],\n      /**\n       * Overflow Y\n       * @see https://tailwindcss.com/docs/overflow\n       */\n      \"overflow-y\": [{\n        \"overflow-y\": C()\n      }],\n      /**\n       * Overscroll Behavior\n       * @see https://tailwindcss.com/docs/overscroll-behavior\n       */\n      overscroll: [{\n        overscroll: T()\n      }],\n      /**\n       * Overscroll Behavior X\n       * @see https://tailwindcss.com/docs/overscroll-behavior\n       */\n      \"overscroll-x\": [{\n        \"overscroll-x\": T()\n      }],\n      /**\n       * Overscroll Behavior Y\n       * @see https://tailwindcss.com/docs/overscroll-behavior\n       */\n      \"overscroll-y\": [{\n        \"overscroll-y\": T()\n      }],\n      /**\n       * Position\n       * @see https://tailwindcss.com/docs/position\n       */\n      position: [\"static\", \"fixed\", \"absolute\", \"relative\", \"sticky\"],\n      /**\n       * Top / Right / Bottom / Left\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      inset: [{\n        inset: [O]\n      }],\n      /**\n       * Right / Left\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      \"inset-x\": [{\n        \"inset-x\": [O]\n      }],\n      /**\n       * Top / Bottom\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      \"inset-y\": [{\n        \"inset-y\": [O]\n      }],\n      /**\n       * Start\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      start: [{\n        start: [O]\n      }],\n      /**\n       * End\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      end: [{\n        end: [O]\n      }],\n      /**\n       * Top\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      top: [{\n        top: [O]\n      }],\n      /**\n       * Right\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      right: [{\n        right: [O]\n      }],\n      /**\n       * Bottom\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      bottom: [{\n        bottom: [O]\n      }],\n      /**\n       * Left\n       * @see https://tailwindcss.com/docs/top-right-bottom-left\n       */\n      left: [{\n        left: [O]\n      }],\n      /**\n       * Visibility\n       * @see https://tailwindcss.com/docs/visibility\n       */\n      visibility: [\"visible\", \"invisible\", \"collapse\"],\n      /**\n       * Z-Index\n       * @see https://tailwindcss.com/docs/z-index\n       */\n      z: [{\n        z: [\"auto\", _a, Te]\n      }],\n      // Flexbox and Grid\n      /**\n       * Flex Basis\n       * @see https://tailwindcss.com/docs/flex-basis\n       */\n      basis: [{\n        basis: A()\n      }],\n      /**\n       * Flex Direction\n       * @see https://tailwindcss.com/docs/flex-direction\n       */\n      \"flex-direction\": [{\n        flex: [\"row\", \"row-reverse\", \"col\", \"col-reverse\"]\n      }],\n      /**\n       * Flex Wrap\n       * @see https://tailwindcss.com/docs/flex-wrap\n       */\n      \"flex-wrap\": [{\n        flex: [\"wrap\", \"wrap-reverse\", \"nowrap\"]\n      }],\n      /**\n       * Flex\n       * @see https://tailwindcss.com/docs/flex\n       */\n      flex: [{\n        flex: [\"1\", \"auto\", \"initial\", \"none\", Te]\n      }],\n      /**\n       * Flex Grow\n       * @see https://tailwindcss.com/docs/flex-grow\n       */\n      grow: [{\n        grow: _e()\n      }],\n      /**\n       * Flex Shrink\n       * @see https://tailwindcss.com/docs/flex-shrink\n       */\n      shrink: [{\n        shrink: _e()\n      }],\n      /**\n       * Order\n       * @see https://tailwindcss.com/docs/order\n       */\n      order: [{\n        order: [\"first\", \"last\", \"none\", _a, Te]\n      }],\n      /**\n       * Grid Template Columns\n       * @see https://tailwindcss.com/docs/grid-template-columns\n       */\n      \"grid-cols\": [{\n        \"grid-cols\": [Ta]\n      }],\n      /**\n       * Grid Column Start / End\n       * @see https://tailwindcss.com/docs/grid-column\n       */\n      \"col-start-end\": [{\n        col: [\"auto\", {\n          span: [\"full\", _a, Te]\n        }, Te]\n      }],\n      /**\n       * Grid Column Start\n       * @see https://tailwindcss.com/docs/grid-column\n       */\n      \"col-start\": [{\n        \"col-start\": L()\n      }],\n      /**\n       * Grid Column End\n       * @see https://tailwindcss.com/docs/grid-column\n       */\n      \"col-end\": [{\n        \"col-end\": L()\n      }],\n      /**\n       * Grid Template Rows\n       * @see https://tailwindcss.com/docs/grid-template-rows\n       */\n      \"grid-rows\": [{\n        \"grid-rows\": [Ta]\n      }],\n      /**\n       * Grid Row Start / End\n       * @see https://tailwindcss.com/docs/grid-row\n       */\n      \"row-start-end\": [{\n        row: [\"auto\", {\n          span: [_a, Te]\n        }, Te]\n      }],\n      /**\n       * Grid Row Start\n       * @see https://tailwindcss.com/docs/grid-row\n       */\n      \"row-start\": [{\n        \"row-start\": L()\n      }],\n      /**\n       * Grid Row End\n       * @see https://tailwindcss.com/docs/grid-row\n       */\n      \"row-end\": [{\n        \"row-end\": L()\n      }],\n      /**\n       * Grid Auto Flow\n       * @see https://tailwindcss.com/docs/grid-auto-flow\n       */\n      \"grid-flow\": [{\n        \"grid-flow\": [\"row\", \"col\", \"dense\", \"row-dense\", \"col-dense\"]\n      }],\n      /**\n       * Grid Auto Columns\n       * @see https://tailwindcss.com/docs/grid-auto-columns\n       */\n      \"auto-cols\": [{\n        \"auto-cols\": [\"auto\", \"min\", \"max\", \"fr\", Te]\n      }],\n      /**\n       * Grid Auto Rows\n       * @see https://tailwindcss.com/docs/grid-auto-rows\n       */\n      \"auto-rows\": [{\n        \"auto-rows\": [\"auto\", \"min\", \"max\", \"fr\", Te]\n      }],\n      /**\n       * Gap\n       * @see https://tailwindcss.com/docs/gap\n       */\n      gap: [{\n        gap: [f]\n      }],\n      /**\n       * Gap X\n       * @see https://tailwindcss.com/docs/gap\n       */\n      \"gap-x\": [{\n        \"gap-x\": [f]\n      }],\n      /**\n       * Gap Y\n       * @see https://tailwindcss.com/docs/gap\n       */\n      \"gap-y\": [{\n        \"gap-y\": [f]\n      }],\n      /**\n       * Justify Content\n       * @see https://tailwindcss.com/docs/justify-content\n       */\n      \"justify-content\": [{\n        justify: [\"normal\", ...B()]\n      }],\n      /**\n       * Justify Items\n       * @see https://tailwindcss.com/docs/justify-items\n       */\n      \"justify-items\": [{\n        \"justify-items\": [\"start\", \"end\", \"center\", \"stretch\"]\n      }],\n      /**\n       * Justify Self\n       * @see https://tailwindcss.com/docs/justify-self\n       */\n      \"justify-self\": [{\n        \"justify-self\": [\"auto\", \"start\", \"end\", \"center\", \"stretch\"]\n      }],\n      /**\n       * Align Content\n       * @see https://tailwindcss.com/docs/align-content\n       */\n      \"align-content\": [{\n        content: [\"normal\", ...B(), \"baseline\"]\n      }],\n      /**\n       * Align Items\n       * @see https://tailwindcss.com/docs/align-items\n       */\n      \"align-items\": [{\n        items: [\"start\", \"end\", \"center\", \"baseline\", \"stretch\"]\n      }],\n      /**\n       * Align Self\n       * @see https://tailwindcss.com/docs/align-self\n       */\n      \"align-self\": [{\n        self: [\"auto\", \"start\", \"end\", \"center\", \"stretch\", \"baseline\"]\n      }],\n      /**\n       * Place Content\n       * @see https://tailwindcss.com/docs/place-content\n       */\n      \"place-content\": [{\n        \"place-content\": [...B(), \"baseline\"]\n      }],\n      /**\n       * Place Items\n       * @see https://tailwindcss.com/docs/place-items\n       */\n      \"place-items\": [{\n        \"place-items\": [\"start\", \"end\", \"center\", \"baseline\", \"stretch\"]\n      }],\n      /**\n       * Place Self\n       * @see https://tailwindcss.com/docs/place-self\n       */\n      \"place-self\": [{\n        \"place-self\": [\"auto\", \"start\", \"end\", \"center\", \"stretch\"]\n      }],\n      // Spacing\n      /**\n       * Padding\n       * @see https://tailwindcss.com/docs/padding\n       */\n      p: [{\n        p: [b]\n      }],\n      /**\n       * Padding X\n       * @see https://tailwindcss.com/docs/padding\n       */\n      px: [{\n        px: [b]\n      }],\n      /**\n       * Padding Y\n       * @see https://tailwindcss.com/docs/padding\n       */\n      py: [{\n        py: [b]\n      }],\n      /**\n       * Padding Start\n       * @see https://tailwindcss.com/docs/padding\n       */\n      ps: [{\n        ps: [b]\n      }],\n      /**\n       * Padding End\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pe: [{\n        pe: [b]\n      }],\n      /**\n       * Padding Top\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pt: [{\n        pt: [b]\n      }],\n      /**\n       * Padding Right\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pr: [{\n        pr: [b]\n      }],\n      /**\n       * Padding Bottom\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pb: [{\n        pb: [b]\n      }],\n      /**\n       * Padding Left\n       * @see https://tailwindcss.com/docs/padding\n       */\n      pl: [{\n        pl: [b]\n      }],\n      /**\n       * Margin\n       * @see https://tailwindcss.com/docs/margin\n       */\n      m: [{\n        m: [m]\n      }],\n      /**\n       * Margin X\n       * @see https://tailwindcss.com/docs/margin\n       */\n      mx: [{\n        mx: [m]\n      }],\n      /**\n       * Margin Y\n       * @see https://tailwindcss.com/docs/margin\n       */\n      my: [{\n        my: [m]\n      }],\n      /**\n       * Margin Start\n       * @see https://tailwindcss.com/docs/margin\n       */\n      ms: [{\n        ms: [m]\n      }],\n      /**\n       * Margin End\n       * @see https://tailwindcss.com/docs/margin\n       */\n      me: [{\n        me: [m]\n      }],\n      /**\n       * Margin Top\n       * @see https://tailwindcss.com/docs/margin\n       */\n      mt: [{\n        mt: [m]\n      }],\n      /**\n       * Margin Right\n       * @see https://tailwindcss.com/docs/margin\n       */\n      mr: [{\n        mr: [m]\n      }],\n      /**\n       * Margin Bottom\n       * @see https://tailwindcss.com/docs/margin\n       */\n      mb: [{\n        mb: [m]\n      }],\n      /**\n       * Margin Left\n       * @see https://tailwindcss.com/docs/margin\n       */\n      ml: [{\n        ml: [m]\n      }],\n      /**\n       * Space Between X\n       * @see https://tailwindcss.com/docs/space\n       */\n      \"space-x\": [{\n        \"space-x\": [k]\n      }],\n      /**\n       * Space Between X Reverse\n       * @see https://tailwindcss.com/docs/space\n       */\n      \"space-x-reverse\": [\"space-x-reverse\"],\n      /**\n       * Space Between Y\n       * @see https://tailwindcss.com/docs/space\n       */\n      \"space-y\": [{\n        \"space-y\": [k]\n      }],\n      /**\n       * Space Between Y Reverse\n       * @see https://tailwindcss.com/docs/space\n       */\n      \"space-y-reverse\": [\"space-y-reverse\"],\n      // Sizing\n      /**\n       * Width\n       * @see https://tailwindcss.com/docs/width\n       */\n      w: [{\n        w: [\"auto\", \"min\", \"max\", \"fit\", \"svw\", \"lvw\", \"dvw\", Te, e]\n      }],\n      /**\n       * Min-Width\n       * @see https://tailwindcss.com/docs/min-width\n       */\n      \"min-w\": [{\n        \"min-w\": [Te, e, \"min\", \"max\", \"fit\"]\n      }],\n      /**\n       * Max-Width\n       * @see https://tailwindcss.com/docs/max-width\n       */\n      \"max-w\": [{\n        \"max-w\": [Te, e, \"none\", \"full\", \"min\", \"max\", \"fit\", \"prose\", {\n          screen: [_i]\n        }, _i]\n      }],\n      /**\n       * Height\n       * @see https://tailwindcss.com/docs/height\n       */\n      h: [{\n        h: [Te, e, \"auto\", \"min\", \"max\", \"fit\", \"svh\", \"lvh\", \"dvh\"]\n      }],\n      /**\n       * Min-Height\n       * @see https://tailwindcss.com/docs/min-height\n       */\n      \"min-h\": [{\n        \"min-h\": [Te, e, \"min\", \"max\", \"fit\", \"svh\", \"lvh\", \"dvh\"]\n      }],\n      /**\n       * Max-Height\n       * @see https://tailwindcss.com/docs/max-height\n       */\n      \"max-h\": [{\n        \"max-h\": [Te, e, \"min\", \"max\", \"fit\", \"svh\", \"lvh\", \"dvh\"]\n      }],\n      /**\n       * Size\n       * @see https://tailwindcss.com/docs/size\n       */\n      size: [{\n        size: [Te, e, \"auto\", \"min\", \"max\", \"fit\"]\n      }],\n      // Typography\n      /**\n       * Font Size\n       * @see https://tailwindcss.com/docs/font-size\n       */\n      \"font-size\": [{\n        text: [\"base\", _i, Pi]\n      }],\n      /**\n       * Font Smoothing\n       * @see https://tailwindcss.com/docs/font-smoothing\n       */\n      \"font-smoothing\": [\"antialiased\", \"subpixel-antialiased\"],\n      /**\n       * Font Style\n       * @see https://tailwindcss.com/docs/font-style\n       */\n      \"font-style\": [\"italic\", \"not-italic\"],\n      /**\n       * Font Weight\n       * @see https://tailwindcss.com/docs/font-weight\n       */\n      \"font-weight\": [{\n        font: [\"thin\", \"extralight\", \"light\", \"normal\", \"medium\", \"semibold\", \"bold\", \"extrabold\", \"black\", Bc]\n      }],\n      /**\n       * Font Family\n       * @see https://tailwindcss.com/docs/font-family\n       */\n      \"font-family\": [{\n        font: [Ta]\n      }],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      \"fvn-normal\": [\"normal-nums\"],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      \"fvn-ordinal\": [\"ordinal\"],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      \"fvn-slashed-zero\": [\"slashed-zero\"],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      \"fvn-figure\": [\"lining-nums\", \"oldstyle-nums\"],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      \"fvn-spacing\": [\"proportional-nums\", \"tabular-nums\"],\n      /**\n       * Font Variant Numeric\n       * @see https://tailwindcss.com/docs/font-variant-numeric\n       */\n      \"fvn-fraction\": [\"diagonal-fractions\", \"stacked-fractons\"],\n      /**\n       * Letter Spacing\n       * @see https://tailwindcss.com/docs/letter-spacing\n       */\n      tracking: [{\n        tracking: [\"tighter\", \"tight\", \"normal\", \"wide\", \"wider\", \"widest\", Te]\n      }],\n      /**\n       * Line Clamp\n       * @see https://tailwindcss.com/docs/line-clamp\n       */\n      \"line-clamp\": [{\n        \"line-clamp\": [\"none\", Es, Bc]\n      }],\n      /**\n       * Line Height\n       * @see https://tailwindcss.com/docs/line-height\n       */\n      leading: [{\n        leading: [\"none\", \"tight\", \"snug\", \"normal\", \"relaxed\", \"loose\", zr, Te]\n      }],\n      /**\n       * List Style Image\n       * @see https://tailwindcss.com/docs/list-style-image\n       */\n      \"list-image\": [{\n        \"list-image\": [\"none\", Te]\n      }],\n      /**\n       * List Style Type\n       * @see https://tailwindcss.com/docs/list-style-type\n       */\n      \"list-style-type\": [{\n        list: [\"none\", \"disc\", \"decimal\", Te]\n      }],\n      /**\n       * List Style Position\n       * @see https://tailwindcss.com/docs/list-style-position\n       */\n      \"list-style-position\": [{\n        list: [\"inside\", \"outside\"]\n      }],\n      /**\n       * Placeholder Color\n       * @deprecated since Tailwind CSS v3.0.0\n       * @see https://tailwindcss.com/docs/placeholder-color\n       */\n      \"placeholder-color\": [{\n        placeholder: [t]\n      }],\n      /**\n       * Placeholder Opacity\n       * @see https://tailwindcss.com/docs/placeholder-opacity\n       */\n      \"placeholder-opacity\": [{\n        \"placeholder-opacity\": [y]\n      }],\n      /**\n       * Text Alignment\n       * @see https://tailwindcss.com/docs/text-align\n       */\n      \"text-alignment\": [{\n        text: [\"left\", \"center\", \"right\", \"justify\", \"start\", \"end\"]\n      }],\n      /**\n       * Text Color\n       * @see https://tailwindcss.com/docs/text-color\n       */\n      \"text-color\": [{\n        text: [t]\n      }],\n      /**\n       * Text Opacity\n       * @see https://tailwindcss.com/docs/text-opacity\n       */\n      \"text-opacity\": [{\n        \"text-opacity\": [y]\n      }],\n      /**\n       * Text Decoration\n       * @see https://tailwindcss.com/docs/text-decoration\n       */\n      \"text-decoration\": [\"underline\", \"overline\", \"line-through\", \"no-underline\"],\n      /**\n       * Text Decoration Style\n       * @see https://tailwindcss.com/docs/text-decoration-style\n       */\n      \"text-decoration-style\": [{\n        decoration: [...Y(), \"wavy\"]\n      }],\n      /**\n       * Text Decoration Thickness\n       * @see https://tailwindcss.com/docs/text-decoration-thickness\n       */\n      \"text-decoration-thickness\": [{\n        decoration: [\"auto\", \"from-font\", zr, Pi]\n      }],\n      /**\n       * Text Underline Offset\n       * @see https://tailwindcss.com/docs/text-underline-offset\n       */\n      \"underline-offset\": [{\n        \"underline-offset\": [\"auto\", zr, Te]\n      }],\n      /**\n       * Text Decoration Color\n       * @see https://tailwindcss.com/docs/text-decoration-color\n       */\n      \"text-decoration-color\": [{\n        decoration: [t]\n      }],\n      /**\n       * Text Transform\n       * @see https://tailwindcss.com/docs/text-transform\n       */\n      \"text-transform\": [\"uppercase\", \"lowercase\", \"capitalize\", \"normal-case\"],\n      /**\n       * Text Overflow\n       * @see https://tailwindcss.com/docs/text-overflow\n       */\n      \"text-overflow\": [\"truncate\", \"text-ellipsis\", \"text-clip\"],\n      /**\n       * Text Wrap\n       * @see https://tailwindcss.com/docs/text-wrap\n       */\n      \"text-wrap\": [{\n        text: [\"wrap\", \"nowrap\", \"balance\", \"pretty\"]\n      }],\n      /**\n       * Text Indent\n       * @see https://tailwindcss.com/docs/text-indent\n       */\n      indent: [{\n        indent: Q()\n      }],\n      /**\n       * Vertical Alignment\n       * @see https://tailwindcss.com/docs/vertical-align\n       */\n      \"vertical-align\": [{\n        align: [\"baseline\", \"top\", \"middle\", \"bottom\", \"text-top\", \"text-bottom\", \"sub\", \"super\", Te]\n      }],\n      /**\n       * Whitespace\n       * @see https://tailwindcss.com/docs/whitespace\n       */\n      whitespace: [{\n        whitespace: [\"normal\", \"nowrap\", \"pre\", \"pre-line\", \"pre-wrap\", \"break-spaces\"]\n      }],\n      /**\n       * Word Break\n       * @see https://tailwindcss.com/docs/word-break\n       */\n      break: [{\n        break: [\"normal\", \"words\", \"all\", \"keep\"]\n      }],\n      /**\n       * Hyphens\n       * @see https://tailwindcss.com/docs/hyphens\n       */\n      hyphens: [{\n        hyphens: [\"none\", \"manual\", \"auto\"]\n      }],\n      /**\n       * Content\n       * @see https://tailwindcss.com/docs/content\n       */\n      content: [{\n        content: [\"none\", Te]\n      }],\n      // Backgrounds\n      /**\n       * Background Attachment\n       * @see https://tailwindcss.com/docs/background-attachment\n       */\n      \"bg-attachment\": [{\n        bg: [\"fixed\", \"local\", \"scroll\"]\n      }],\n      /**\n       * Background Clip\n       * @see https://tailwindcss.com/docs/background-clip\n       */\n      \"bg-clip\": [{\n        \"bg-clip\": [\"border\", \"padding\", \"content\", \"text\"]\n      }],\n      /**\n       * Background Opacity\n       * @deprecated since Tailwind CSS v3.0.0\n       * @see https://tailwindcss.com/docs/background-opacity\n       */\n      \"bg-opacity\": [{\n        \"bg-opacity\": [y]\n      }],\n      /**\n       * Background Origin\n       * @see https://tailwindcss.com/docs/background-origin\n       */\n      \"bg-origin\": [{\n        \"bg-origin\": [\"border\", \"padding\", \"content\"]\n      }],\n      /**\n       * Background Position\n       * @see https://tailwindcss.com/docs/background-position\n       */\n      \"bg-position\": [{\n        bg: [...re(), NM]\n      }],\n      /**\n       * Background Repeat\n       * @see https://tailwindcss.com/docs/background-repeat\n       */\n      \"bg-repeat\": [{\n        bg: [\"no-repeat\", {\n          repeat: [\"\", \"x\", \"y\", \"round\", \"space\"]\n        }]\n      }],\n      /**\n       * Background Size\n       * @see https://tailwindcss.com/docs/background-size\n       */\n      \"bg-size\": [{\n        bg: [\"auto\", \"cover\", \"contain\", RM]\n      }],\n      /**\n       * Background Image\n       * @see https://tailwindcss.com/docs/background-image\n       */\n      \"bg-image\": [{\n        bg: [\"none\", {\n          \"gradient-to\": [\"t\", \"tr\", \"r\", \"br\", \"b\", \"bl\", \"l\", \"tl\"]\n        }, ZM]\n      }],\n      /**\n       * Background Color\n       * @see https://tailwindcss.com/docs/background-color\n       */\n      \"bg-color\": [{\n        bg: [t]\n      }],\n      /**\n       * Gradient Color Stops From Position\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      \"gradient-from-pos\": [{\n        from: [p]\n      }],\n      /**\n       * Gradient Color Stops Via Position\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      \"gradient-via-pos\": [{\n        via: [p]\n      }],\n      /**\n       * Gradient Color Stops To Position\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      \"gradient-to-pos\": [{\n        to: [p]\n      }],\n      /**\n       * Gradient Color Stops From\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      \"gradient-from\": [{\n        from: [h]\n      }],\n      /**\n       * Gradient Color Stops Via\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      \"gradient-via\": [{\n        via: [h]\n      }],\n      /**\n       * Gradient Color Stops To\n       * @see https://tailwindcss.com/docs/gradient-color-stops\n       */\n      \"gradient-to\": [{\n        to: [h]\n      }],\n      // Borders\n      /**\n       * Border Radius\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      rounded: [{\n        rounded: [s]\n      }],\n      /**\n       * Border Radius Start\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-s\": [{\n        \"rounded-s\": [s]\n      }],\n      /**\n       * Border Radius End\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-e\": [{\n        \"rounded-e\": [s]\n      }],\n      /**\n       * Border Radius Top\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-t\": [{\n        \"rounded-t\": [s]\n      }],\n      /**\n       * Border Radius Right\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-r\": [{\n        \"rounded-r\": [s]\n      }],\n      /**\n       * Border Radius Bottom\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-b\": [{\n        \"rounded-b\": [s]\n      }],\n      /**\n       * Border Radius Left\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-l\": [{\n        \"rounded-l\": [s]\n      }],\n      /**\n       * Border Radius Start Start\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-ss\": [{\n        \"rounded-ss\": [s]\n      }],\n      /**\n       * Border Radius Start End\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-se\": [{\n        \"rounded-se\": [s]\n      }],\n      /**\n       * Border Radius End End\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-ee\": [{\n        \"rounded-ee\": [s]\n      }],\n      /**\n       * Border Radius End Start\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-es\": [{\n        \"rounded-es\": [s]\n      }],\n      /**\n       * Border Radius Top Left\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-tl\": [{\n        \"rounded-tl\": [s]\n      }],\n      /**\n       * Border Radius Top Right\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-tr\": [{\n        \"rounded-tr\": [s]\n      }],\n      /**\n       * Border Radius Bottom Right\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-br\": [{\n        \"rounded-br\": [s]\n      }],\n      /**\n       * Border Radius Bottom Left\n       * @see https://tailwindcss.com/docs/border-radius\n       */\n      \"rounded-bl\": [{\n        \"rounded-bl\": [s]\n      }],\n      /**\n       * Border Width\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      \"border-w\": [{\n        border: [a]\n      }],\n      /**\n       * Border Width X\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      \"border-w-x\": [{\n        \"border-x\": [a]\n      }],\n      /**\n       * Border Width Y\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      \"border-w-y\": [{\n        \"border-y\": [a]\n      }],\n      /**\n       * Border Width Start\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      \"border-w-s\": [{\n        \"border-s\": [a]\n      }],\n      /**\n       * Border Width End\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      \"border-w-e\": [{\n        \"border-e\": [a]\n      }],\n      /**\n       * Border Width Top\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      \"border-w-t\": [{\n        \"border-t\": [a]\n      }],\n      /**\n       * Border Width Right\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      \"border-w-r\": [{\n        \"border-r\": [a]\n      }],\n      /**\n       * Border Width Bottom\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      \"border-w-b\": [{\n        \"border-b\": [a]\n      }],\n      /**\n       * Border Width Left\n       * @see https://tailwindcss.com/docs/border-width\n       */\n      \"border-w-l\": [{\n        \"border-l\": [a]\n      }],\n      /**\n       * Border Opacity\n       * @see https://tailwindcss.com/docs/border-opacity\n       */\n      \"border-opacity\": [{\n        \"border-opacity\": [y]\n      }],\n      /**\n       * Border Style\n       * @see https://tailwindcss.com/docs/border-style\n       */\n      \"border-style\": [{\n        border: [...Y(), \"hidden\"]\n      }],\n      /**\n       * Divide Width X\n       * @see https://tailwindcss.com/docs/divide-width\n       */\n      \"divide-x\": [{\n        \"divide-x\": [a]\n      }],\n      /**\n       * Divide Width X Reverse\n       * @see https://tailwindcss.com/docs/divide-width\n       */\n      \"divide-x-reverse\": [\"divide-x-reverse\"],\n      /**\n       * Divide Width Y\n       * @see https://tailwindcss.com/docs/divide-width\n       */\n      \"divide-y\": [{\n        \"divide-y\": [a]\n      }],\n      /**\n       * Divide Width Y Reverse\n       * @see https://tailwindcss.com/docs/divide-width\n       */\n      \"divide-y-reverse\": [\"divide-y-reverse\"],\n      /**\n       * Divide Opacity\n       * @see https://tailwindcss.com/docs/divide-opacity\n       */\n      \"divide-opacity\": [{\n        \"divide-opacity\": [y]\n      }],\n      /**\n       * Divide Style\n       * @see https://tailwindcss.com/docs/divide-style\n       */\n      \"divide-style\": [{\n        divide: Y()\n      }],\n      /**\n       * Border Color\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      \"border-color\": [{\n        border: [i]\n      }],\n      /**\n       * Border Color X\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      \"border-color-x\": [{\n        \"border-x\": [i]\n      }],\n      /**\n       * Border Color Y\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      \"border-color-y\": [{\n        \"border-y\": [i]\n      }],\n      /**\n       * Border Color Top\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      \"border-color-t\": [{\n        \"border-t\": [i]\n      }],\n      /**\n       * Border Color Right\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      \"border-color-r\": [{\n        \"border-r\": [i]\n      }],\n      /**\n       * Border Color Bottom\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      \"border-color-b\": [{\n        \"border-b\": [i]\n      }],\n      /**\n       * Border Color Left\n       * @see https://tailwindcss.com/docs/border-color\n       */\n      \"border-color-l\": [{\n        \"border-l\": [i]\n      }],\n      /**\n       * Divide Color\n       * @see https://tailwindcss.com/docs/divide-color\n       */\n      \"divide-color\": [{\n        divide: [i]\n      }],\n      /**\n       * Outline Style\n       * @see https://tailwindcss.com/docs/outline-style\n       */\n      \"outline-style\": [{\n        outline: [\"\", ...Y()]\n      }],\n      /**\n       * Outline Offset\n       * @see https://tailwindcss.com/docs/outline-offset\n       */\n      \"outline-offset\": [{\n        \"outline-offset\": [zr, Te]\n      }],\n      /**\n       * Outline Width\n       * @see https://tailwindcss.com/docs/outline-width\n       */\n      \"outline-w\": [{\n        outline: [zr, Pi]\n      }],\n      /**\n       * Outline Color\n       * @see https://tailwindcss.com/docs/outline-color\n       */\n      \"outline-color\": [{\n        outline: [t]\n      }],\n      /**\n       * Ring Width\n       * @see https://tailwindcss.com/docs/ring-width\n       */\n      \"ring-w\": [{\n        ring: W()\n      }],\n      /**\n       * Ring Width Inset\n       * @see https://tailwindcss.com/docs/ring-width\n       */\n      \"ring-w-inset\": [\"ring-inset\"],\n      /**\n       * Ring Color\n       * @see https://tailwindcss.com/docs/ring-color\n       */\n      \"ring-color\": [{\n        ring: [t]\n      }],\n      /**\n       * Ring Opacity\n       * @see https://tailwindcss.com/docs/ring-opacity\n       */\n      \"ring-opacity\": [{\n        \"ring-opacity\": [y]\n      }],\n      /**\n       * Ring Offset Width\n       * @see https://tailwindcss.com/docs/ring-offset-width\n       */\n      \"ring-offset-w\": [{\n        \"ring-offset\": [zr, Pi]\n      }],\n      /**\n       * Ring Offset Color\n       * @see https://tailwindcss.com/docs/ring-offset-color\n       */\n      \"ring-offset-color\": [{\n        \"ring-offset\": [t]\n      }],\n      // Effects\n      /**\n       * Box Shadow\n       * @see https://tailwindcss.com/docs/box-shadow\n       */\n      shadow: [{\n        shadow: [\"\", \"inner\", \"none\", _i, VM]\n      }],\n      /**\n       * Box Shadow Color\n       * @see https://tailwindcss.com/docs/box-shadow-color\n       */\n      \"shadow-color\": [{\n        shadow: [Ta]\n      }],\n      /**\n       * Opacity\n       * @see https://tailwindcss.com/docs/opacity\n       */\n      opacity: [{\n        opacity: [y]\n      }],\n      /**\n       * Mix Blend Mode\n       * @see https://tailwindcss.com/docs/mix-blend-mode\n       */\n      \"mix-blend\": [{\n        \"mix-blend\": [...K(), \"plus-lighter\", \"plus-darker\"]\n      }],\n      /**\n       * Background Blend Mode\n       * @see https://tailwindcss.com/docs/background-blend-mode\n       */\n      \"bg-blend\": [{\n        \"bg-blend\": K()\n      }],\n      // Filters\n      /**\n       * Filter\n       * @deprecated since Tailwind CSS v3.0.0\n       * @see https://tailwindcss.com/docs/filter\n       */\n      filter: [{\n        filter: [\"\", \"none\"]\n      }],\n      /**\n       * Blur\n       * @see https://tailwindcss.com/docs/blur\n       */\n      blur: [{\n        blur: [n]\n      }],\n      /**\n       * Brightness\n       * @see https://tailwindcss.com/docs/brightness\n       */\n      brightness: [{\n        brightness: [r]\n      }],\n      /**\n       * Contrast\n       * @see https://tailwindcss.com/docs/contrast\n       */\n      contrast: [{\n        contrast: [l]\n      }],\n      /**\n       * Drop Shadow\n       * @see https://tailwindcss.com/docs/drop-shadow\n       */\n      \"drop-shadow\": [{\n        \"drop-shadow\": [\"\", \"none\", _i, Te]\n      }],\n      /**\n       * Grayscale\n       * @see https://tailwindcss.com/docs/grayscale\n       */\n      grayscale: [{\n        grayscale: [c]\n      }],\n      /**\n       * Hue Rotate\n       * @see https://tailwindcss.com/docs/hue-rotate\n       */\n      \"hue-rotate\": [{\n        \"hue-rotate\": [u]\n      }],\n      /**\n       * Invert\n       * @see https://tailwindcss.com/docs/invert\n       */\n      invert: [{\n        invert: [d]\n      }],\n      /**\n       * Saturate\n       * @see https://tailwindcss.com/docs/saturate\n       */\n      saturate: [{\n        saturate: [g]\n      }],\n      /**\n       * Sepia\n       * @see https://tailwindcss.com/docs/sepia\n       */\n      sepia: [{\n        sepia: [S]\n      }],\n      /**\n       * Backdrop Filter\n       * @deprecated since Tailwind CSS v3.0.0\n       * @see https://tailwindcss.com/docs/backdrop-filter\n       */\n      \"backdrop-filter\": [{\n        \"backdrop-filter\": [\"\", \"none\"]\n      }],\n      /**\n       * Backdrop Blur\n       * @see https://tailwindcss.com/docs/backdrop-blur\n       */\n      \"backdrop-blur\": [{\n        \"backdrop-blur\": [n]\n      }],\n      /**\n       * Backdrop Brightness\n       * @see https://tailwindcss.com/docs/backdrop-brightness\n       */\n      \"backdrop-brightness\": [{\n        \"backdrop-brightness\": [r]\n      }],\n      /**\n       * Backdrop Contrast\n       * @see https://tailwindcss.com/docs/backdrop-contrast\n       */\n      \"backdrop-contrast\": [{\n        \"backdrop-contrast\": [l]\n      }],\n      /**\n       * Backdrop Grayscale\n       * @see https://tailwindcss.com/docs/backdrop-grayscale\n       */\n      \"backdrop-grayscale\": [{\n        \"backdrop-grayscale\": [c]\n      }],\n      /**\n       * Backdrop Hue Rotate\n       * @see https://tailwindcss.com/docs/backdrop-hue-rotate\n       */\n      \"backdrop-hue-rotate\": [{\n        \"backdrop-hue-rotate\": [u]\n      }],\n      /**\n       * Backdrop Invert\n       * @see https://tailwindcss.com/docs/backdrop-invert\n       */\n      \"backdrop-invert\": [{\n        \"backdrop-invert\": [d]\n      }],\n      /**\n       * Backdrop Opacity\n       * @see https://tailwindcss.com/docs/backdrop-opacity\n       */\n      \"backdrop-opacity\": [{\n        \"backdrop-opacity\": [y]\n      }],\n      /**\n       * Backdrop Saturate\n       * @see https://tailwindcss.com/docs/backdrop-saturate\n       */\n      \"backdrop-saturate\": [{\n        \"backdrop-saturate\": [g]\n      }],\n      /**\n       * Backdrop Sepia\n       * @see https://tailwindcss.com/docs/backdrop-sepia\n       */\n      \"backdrop-sepia\": [{\n        \"backdrop-sepia\": [S]\n      }],\n      // Tables\n      /**\n       * Border Collapse\n       * @see https://tailwindcss.com/docs/border-collapse\n       */\n      \"border-collapse\": [{\n        border: [\"collapse\", \"separate\"]\n      }],\n      /**\n       * Border Spacing\n       * @see https://tailwindcss.com/docs/border-spacing\n       */\n      \"border-spacing\": [{\n        \"border-spacing\": [o]\n      }],\n      /**\n       * Border Spacing X\n       * @see https://tailwindcss.com/docs/border-spacing\n       */\n      \"border-spacing-x\": [{\n        \"border-spacing-x\": [o]\n      }],\n      /**\n       * Border Spacing Y\n       * @see https://tailwindcss.com/docs/border-spacing\n       */\n      \"border-spacing-y\": [{\n        \"border-spacing-y\": [o]\n      }],\n      /**\n       * Table Layout\n       * @see https://tailwindcss.com/docs/table-layout\n       */\n      \"table-layout\": [{\n        table: [\"auto\", \"fixed\"]\n      }],\n      /**\n       * Caption Side\n       * @see https://tailwindcss.com/docs/caption-side\n       */\n      caption: [{\n        caption: [\"top\", \"bottom\"]\n      }],\n      // Transitions and Animation\n      /**\n       * Tranisition Property\n       * @see https://tailwindcss.com/docs/transition-property\n       */\n      transition: [{\n        transition: [\"none\", \"all\", \"\", \"colors\", \"opacity\", \"shadow\", \"transform\", Te]\n      }],\n      /**\n       * Transition Duration\n       * @see https://tailwindcss.com/docs/transition-duration\n       */\n      duration: [{\n        duration: ge()\n      }],\n      /**\n       * Transition Timing Function\n       * @see https://tailwindcss.com/docs/transition-timing-function\n       */\n      ease: [{\n        ease: [\"linear\", \"in\", \"out\", \"in-out\", Te]\n      }],\n      /**\n       * Transition Delay\n       * @see https://tailwindcss.com/docs/transition-delay\n       */\n      delay: [{\n        delay: ge()\n      }],\n      /**\n       * Animation\n       * @see https://tailwindcss.com/docs/animation\n       */\n      animate: [{\n        animate: [\"none\", \"spin\", \"ping\", \"pulse\", \"bounce\", Te]\n      }],\n      // Transforms\n      /**\n       * Transform\n       * @see https://tailwindcss.com/docs/transform\n       */\n      transform: [{\n        transform: [\"\", \"gpu\", \"none\"]\n      }],\n      /**\n       * Scale\n       * @see https://tailwindcss.com/docs/scale\n       */\n      scale: [{\n        scale: [v]\n      }],\n      /**\n       * Scale X\n       * @see https://tailwindcss.com/docs/scale\n       */\n      \"scale-x\": [{\n        \"scale-x\": [v]\n      }],\n      /**\n       * Scale Y\n       * @see https://tailwindcss.com/docs/scale\n       */\n      \"scale-y\": [{\n        \"scale-y\": [v]\n      }],\n      /**\n       * Rotate\n       * @see https://tailwindcss.com/docs/rotate\n       */\n      rotate: [{\n        rotate: [_a, Te]\n      }],\n      /**\n       * Translate X\n       * @see https://tailwindcss.com/docs/translate\n       */\n      \"translate-x\": [{\n        \"translate-x\": [_]\n      }],\n      /**\n       * Translate Y\n       * @see https://tailwindcss.com/docs/translate\n       */\n      \"translate-y\": [{\n        \"translate-y\": [_]\n      }],\n      /**\n       * Skew X\n       * @see https://tailwindcss.com/docs/skew\n       */\n      \"skew-x\": [{\n        \"skew-x\": [w]\n      }],\n      /**\n       * Skew Y\n       * @see https://tailwindcss.com/docs/skew\n       */\n      \"skew-y\": [{\n        \"skew-y\": [w]\n      }],\n      /**\n       * Transform Origin\n       * @see https://tailwindcss.com/docs/transform-origin\n       */\n      \"transform-origin\": [{\n        origin: [\"center\", \"top\", \"top-right\", \"right\", \"bottom-right\", \"bottom\", \"bottom-left\", \"left\", \"top-left\", Te]\n      }],\n      // Interactivity\n      /**\n       * Accent Color\n       * @see https://tailwindcss.com/docs/accent-color\n       */\n      accent: [{\n        accent: [\"auto\", t]\n      }],\n      /**\n       * Appearance\n       * @see https://tailwindcss.com/docs/appearance\n       */\n      appearance: [{\n        appearance: [\"none\", \"auto\"]\n      }],\n      /**\n       * Cursor\n       * @see https://tailwindcss.com/docs/cursor\n       */\n      cursor: [{\n        cursor: [\"auto\", \"default\", \"pointer\", \"wait\", \"text\", \"move\", \"help\", \"not-allowed\", \"none\", \"context-menu\", \"progress\", \"cell\", \"crosshair\", \"vertical-text\", \"alias\", \"copy\", \"no-drop\", \"grab\", \"grabbing\", \"all-scroll\", \"col-resize\", \"row-resize\", \"n-resize\", \"e-resize\", \"s-resize\", \"w-resize\", \"ne-resize\", \"nw-resize\", \"se-resize\", \"sw-resize\", \"ew-resize\", \"ns-resize\", \"nesw-resize\", \"nwse-resize\", \"zoom-in\", \"zoom-out\", Te]\n      }],\n      /**\n       * Caret Color\n       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities\n       */\n      \"caret-color\": [{\n        caret: [t]\n      }],\n      /**\n       * Pointer Events\n       * @see https://tailwindcss.com/docs/pointer-events\n       */\n      \"pointer-events\": [{\n        \"pointer-events\": [\"none\", \"auto\"]\n      }],\n      /**\n       * Resize\n       * @see https://tailwindcss.com/docs/resize\n       */\n      resize: [{\n        resize: [\"none\", \"y\", \"x\", \"\"]\n      }],\n      /**\n       * Scroll Behavior\n       * @see https://tailwindcss.com/docs/scroll-behavior\n       */\n      \"scroll-behavior\": [{\n        scroll: [\"auto\", \"smooth\"]\n      }],\n      /**\n       * Scroll Margin\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      \"scroll-m\": [{\n        \"scroll-m\": Q()\n      }],\n      /**\n       * Scroll Margin X\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      \"scroll-mx\": [{\n        \"scroll-mx\": Q()\n      }],\n      /**\n       * Scroll Margin Y\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      \"scroll-my\": [{\n        \"scroll-my\": Q()\n      }],\n      /**\n       * Scroll Margin Start\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      \"scroll-ms\": [{\n        \"scroll-ms\": Q()\n      }],\n      /**\n       * Scroll Margin End\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      \"scroll-me\": [{\n        \"scroll-me\": Q()\n      }],\n      /**\n       * Scroll Margin Top\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      \"scroll-mt\": [{\n        \"scroll-mt\": Q()\n      }],\n      /**\n       * Scroll Margin Right\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      \"scroll-mr\": [{\n        \"scroll-mr\": Q()\n      }],\n      /**\n       * Scroll Margin Bottom\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      \"scroll-mb\": [{\n        \"scroll-mb\": Q()\n      }],\n      /**\n       * Scroll Margin Left\n       * @see https://tailwindcss.com/docs/scroll-margin\n       */\n      \"scroll-ml\": [{\n        \"scroll-ml\": Q()\n      }],\n      /**\n       * Scroll Padding\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      \"scroll-p\": [{\n        \"scroll-p\": Q()\n      }],\n      /**\n       * Scroll Padding X\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      \"scroll-px\": [{\n        \"scroll-px\": Q()\n      }],\n      /**\n       * Scroll Padding Y\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      \"scroll-py\": [{\n        \"scroll-py\": Q()\n      }],\n      /**\n       * Scroll Padding Start\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      \"scroll-ps\": [{\n        \"scroll-ps\": Q()\n      }],\n      /**\n       * Scroll Padding End\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      \"scroll-pe\": [{\n        \"scroll-pe\": Q()\n      }],\n      /**\n       * Scroll Padding Top\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      \"scroll-pt\": [{\n        \"scroll-pt\": Q()\n      }],\n      /**\n       * Scroll Padding Right\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      \"scroll-pr\": [{\n        \"scroll-pr\": Q()\n      }],\n      /**\n       * Scroll Padding Bottom\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      \"scroll-pb\": [{\n        \"scroll-pb\": Q()\n      }],\n      /**\n       * Scroll Padding Left\n       * @see https://tailwindcss.com/docs/scroll-padding\n       */\n      \"scroll-pl\": [{\n        \"scroll-pl\": Q()\n      }],\n      /**\n       * Scroll Snap Align\n       * @see https://tailwindcss.com/docs/scroll-snap-align\n       */\n      \"snap-align\": [{\n        snap: [\"start\", \"end\", \"center\", \"align-none\"]\n      }],\n      /**\n       * Scroll Snap Stop\n       * @see https://tailwindcss.com/docs/scroll-snap-stop\n       */\n      \"snap-stop\": [{\n        snap: [\"normal\", \"always\"]\n      }],\n      /**\n       * Scroll Snap Type\n       * @see https://tailwindcss.com/docs/scroll-snap-type\n       */\n      \"snap-type\": [{\n        snap: [\"none\", \"x\", \"y\", \"both\"]\n      }],\n      /**\n       * Scroll Snap Type Strictness\n       * @see https://tailwindcss.com/docs/scroll-snap-type\n       */\n      \"snap-strictness\": [{\n        snap: [\"mandatory\", \"proximity\"]\n      }],\n      /**\n       * Touch Action\n       * @see https://tailwindcss.com/docs/touch-action\n       */\n      touch: [{\n        touch: [\"auto\", \"none\", \"manipulation\"]\n      }],\n      /**\n       * Touch Action X\n       * @see https://tailwindcss.com/docs/touch-action\n       */\n      \"touch-x\": [{\n        \"touch-pan\": [\"x\", \"left\", \"right\"]\n      }],\n      /**\n       * Touch Action Y\n       * @see https://tailwindcss.com/docs/touch-action\n       */\n      \"touch-y\": [{\n        \"touch-pan\": [\"y\", \"up\", \"down\"]\n      }],\n      /**\n       * Touch Action Pinch Zoom\n       * @see https://tailwindcss.com/docs/touch-action\n       */\n      \"touch-pz\": [\"touch-pinch-zoom\"],\n      /**\n       * User Select\n       * @see https://tailwindcss.com/docs/user-select\n       */\n      select: [{\n        select: [\"none\", \"text\", \"all\", \"auto\"]\n      }],\n      /**\n       * Will Change\n       * @see https://tailwindcss.com/docs/will-change\n       */\n      \"will-change\": [{\n        \"will-change\": [\"auto\", \"scroll\", \"contents\", \"transform\", Te]\n      }],\n      // SVG\n      /**\n       * Fill\n       * @see https://tailwindcss.com/docs/fill\n       */\n      fill: [{\n        fill: [t, \"none\"]\n      }],\n      /**\n       * Stroke Width\n       * @see https://tailwindcss.com/docs/stroke-width\n       */\n      \"stroke-w\": [{\n        stroke: [zr, Pi, Bc]\n      }],\n      /**\n       * Stroke\n       * @see https://tailwindcss.com/docs/stroke\n       */\n      stroke: [{\n        stroke: [t, \"none\"]\n      }],\n      // Accessibility\n      /**\n       * Screen Readers\n       * @see https://tailwindcss.com/docs/screen-readers\n       */\n      sr: [\"sr-only\", \"not-sr-only\"],\n      /**\n       * Forced Color Adjust\n       * @see https://tailwindcss.com/docs/forced-color-adjust\n       */\n      \"forced-color-adjust\": [{\n        \"forced-color-adjust\": [\"auto\", \"none\"]\n      }]\n    },\n    conflictingClassGroups: {\n      overflow: [\"overflow-x\", \"overflow-y\"],\n      overscroll: [\"overscroll-x\", \"overscroll-y\"],\n      inset: [\"inset-x\", \"inset-y\", \"start\", \"end\", \"top\", \"right\", \"bottom\", \"left\"],\n      \"inset-x\": [\"right\", \"left\"],\n      \"inset-y\": [\"top\", \"bottom\"],\n      flex: [\"basis\", \"grow\", \"shrink\"],\n      gap: [\"gap-x\", \"gap-y\"],\n      p: [\"px\", \"py\", \"ps\", \"pe\", \"pt\", \"pr\", \"pb\", \"pl\"],\n      px: [\"pr\", \"pl\"],\n      py: [\"pt\", \"pb\"],\n      m: [\"mx\", \"my\", \"ms\", \"me\", \"mt\", \"mr\", \"mb\", \"ml\"],\n      mx: [\"mr\", \"ml\"],\n      my: [\"mt\", \"mb\"],\n      size: [\"w\", \"h\"],\n      \"font-size\": [\"leading\"],\n      \"fvn-normal\": [\"fvn-ordinal\", \"fvn-slashed-zero\", \"fvn-figure\", \"fvn-spacing\", \"fvn-fraction\"],\n      \"fvn-ordinal\": [\"fvn-normal\"],\n      \"fvn-slashed-zero\": [\"fvn-normal\"],\n      \"fvn-figure\": [\"fvn-normal\"],\n      \"fvn-spacing\": [\"fvn-normal\"],\n      \"fvn-fraction\": [\"fvn-normal\"],\n      \"line-clamp\": [\"display\", \"overflow\"],\n      rounded: [\"rounded-s\", \"rounded-e\", \"rounded-t\", \"rounded-r\", \"rounded-b\", \"rounded-l\", \"rounded-ss\", \"rounded-se\", \"rounded-ee\", \"rounded-es\", \"rounded-tl\", \"rounded-tr\", \"rounded-br\", \"rounded-bl\"],\n      \"rounded-s\": [\"rounded-ss\", \"rounded-es\"],\n      \"rounded-e\": [\"rounded-se\", \"rounded-ee\"],\n      \"rounded-t\": [\"rounded-tl\", \"rounded-tr\"],\n      \"rounded-r\": [\"rounded-tr\", \"rounded-br\"],\n      \"rounded-b\": [\"rounded-br\", \"rounded-bl\"],\n      \"rounded-l\": [\"rounded-tl\", \"rounded-bl\"],\n      \"border-spacing\": [\"border-spacing-x\", \"border-spacing-y\"],\n      \"border-w\": [\"border-w-s\", \"border-w-e\", \"border-w-t\", \"border-w-r\", \"border-w-b\", \"border-w-l\"],\n      \"border-w-x\": [\"border-w-r\", \"border-w-l\"],\n      \"border-w-y\": [\"border-w-t\", \"border-w-b\"],\n      \"border-color\": [\"border-color-t\", \"border-color-r\", \"border-color-b\", \"border-color-l\"],\n      \"border-color-x\": [\"border-color-r\", \"border-color-l\"],\n      \"border-color-y\": [\"border-color-t\", \"border-color-b\"],\n      \"scroll-m\": [\"scroll-mx\", \"scroll-my\", \"scroll-ms\", \"scroll-me\", \"scroll-mt\", \"scroll-mr\", \"scroll-mb\", \"scroll-ml\"],\n      \"scroll-mx\": [\"scroll-mr\", \"scroll-ml\"],\n      \"scroll-my\": [\"scroll-mt\", \"scroll-mb\"],\n      \"scroll-p\": [\"scroll-px\", \"scroll-py\", \"scroll-ps\", \"scroll-pe\", \"scroll-pt\", \"scroll-pr\", \"scroll-pb\", \"scroll-pl\"],\n      \"scroll-px\": [\"scroll-pr\", \"scroll-pl\"],\n      \"scroll-py\": [\"scroll-pt\", \"scroll-pb\"],\n      touch: [\"touch-x\", \"touch-y\", \"touch-pz\"],\n      \"touch-x\": [\"touch\"],\n      \"touch-y\": [\"touch\"],\n      \"touch-pz\": [\"touch\"]\n    },\n    conflictingClassGroupModifiers: {\n      \"font-size\": [\"leading\"]\n    }\n  };\n}\nfunction XM(t, {\n  cacheSize: e,\n  prefix: n,\n  separator: r,\n  extend: i = {},\n  override: s = {}\n}) {\n  fu(t, \"cacheSize\", e), fu(t, \"prefix\", n), fu(t, \"separator\", r);\n  for (const o in s)\n    jM(t[o], s[o]);\n  for (const o in i)\n    BM(t[o], i[o]);\n  return t;\n}\nfunction fu(t, e, n) {\n  n !== void 0 && (t[e] = n);\n}\nfunction jM(t, e) {\n  if (e)\n    for (const n in e)\n      fu(t, n, e[n]);\n}\nfunction BM(t, e) {\n  if (e)\n    for (const n in e) {\n      const r = e[n];\n      r !== void 0 && (t[n] = (t[n] || []).concat(r));\n    }\n}\nfunction LM(t, ...e) {\n  return typeof t == \"function\" ? I0(W0, t, ...e) : I0(() => XM(W0(), t), ...e);\n}\nvar M0 = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof global < \"u\" ? global : typeof self < \"u\" ? self : {};\nfunction UM(t) {\n  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, \"default\") ? t.default : t;\n}\nvar CP = { exports: {} };\n(function(t) {\n  var e = typeof window < \"u\" ? window : typeof WorkerGlobalScope < \"u\" && self instanceof WorkerGlobalScope ? self : {};\n  /**\n   * Prism: Lightweight, robust, elegant syntax highlighting\n   *\n   * @license MIT <https://opensource.org/licenses/MIT>\n   * @author Lea Verou <https://lea.verou.me>\n   * @namespace\n   * @public\n   */\n  var n = function(r) {\n    var i = /(?:^|\\s)lang(?:uage)?-([\\w-]+)(?=\\s|$)/i, s = 0, o = {}, a = {\n      /**\n       * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the\n       * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load\n       * additional languages or plugins yourself.\n       *\n       * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.\n       *\n       * You obviously have to change this value before the automatic highlighting started. To do this, you can add an\n       * empty Prism object into the global scope before loading the Prism script like this:\n       *\n       * ```js\n       * window.Prism = window.Prism || {};\n       * Prism.manual = true;\n       * // add a new <script> to load Prism's script\n       * ```\n       *\n       * @default false\n       * @type {boolean}\n       * @memberof Prism\n       * @public\n       */\n      manual: r.Prism && r.Prism.manual,\n      /**\n       * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses\n       * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your\n       * own worker, you don't want it to do this.\n       *\n       * By setting this value to `true`, Prism will not add its own listeners to the worker.\n       *\n       * You obviously have to change this value before Prism executes. To do this, you can add an\n       * empty Prism object into the global scope before loading the Prism script like this:\n       *\n       * ```js\n       * window.Prism = window.Prism || {};\n       * Prism.disableWorkerMessageHandler = true;\n       * // Load Prism's script\n       * ```\n       *\n       * @default false\n       * @type {boolean}\n       * @memberof Prism\n       * @public\n       */\n      disableWorkerMessageHandler: r.Prism && r.Prism.disableWorkerMessageHandler,\n      /**\n       * A namespace for utility methods.\n       *\n       * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may\n       * change or disappear at any time.\n       *\n       * @namespace\n       * @memberof Prism\n       */\n      util: {\n        encode: function b(g) {\n          return g instanceof l ? new l(g.type, b(g.content), g.alias) : Array.isArray(g) ? g.map(b) : g.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/\\u00a0/g, \" \");\n        },\n        /**\n         * Returns the name of the type of the given value.\n         *\n         * @param {any} o\n         * @returns {string}\n         * @example\n         * type(null)      === 'Null'\n         * type(undefined) === 'Undefined'\n         * type(123)       === 'Number'\n         * type('foo')     === 'String'\n         * type(true)      === 'Boolean'\n         * type([1, 2])    === 'Array'\n         * type({})        === 'Object'\n         * type(String)    === 'Function'\n         * type(/abc+/)    === 'RegExp'\n         */\n        type: function(b) {\n          return Object.prototype.toString.call(b).slice(8, -1);\n        },\n        /**\n         * Returns a unique number for the given object. Later calls will still return the same number.\n         *\n         * @param {Object} obj\n         * @returns {number}\n         */\n        objId: function(b) {\n          return b.__id || Object.defineProperty(b, \"__id\", { value: ++s }), b.__id;\n        },\n        /**\n         * Creates a deep clone of the given object.\n         *\n         * The main intended use of this function is to clone language definitions.\n         *\n         * @param {T} o\n         * @param {Record<number, any>} [visited]\n         * @returns {T}\n         * @template T\n         */\n        clone: function b(g, v) {\n          v = v || {};\n          var S, w;\n          switch (a.util.type(g)) {\n            case \"Object\":\n              if (w = a.util.objId(g), v[w])\n                return v[w];\n              S = /** @type {Record<string, any>} */\n              {}, v[w] = S;\n              for (var k in g)\n                g.hasOwnProperty(k) && (S[k] = b(g[k], v));\n              return (\n                /** @type {any} */\n                S\n              );\n            case \"Array\":\n              return w = a.util.objId(g), v[w] ? v[w] : (S = [], v[w] = S, g.forEach(function(_, T) {\n                S[T] = b(_, v);\n              }), /** @type {any} */\n              S);\n            default:\n              return g;\n          }\n        },\n        /**\n         * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.\n         *\n         * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.\n         *\n         * @param {Element} element\n         * @returns {string}\n         */\n        getLanguage: function(b) {\n          for (; b; ) {\n            var g = i.exec(b.className);\n            if (g)\n              return g[1].toLowerCase();\n            b = b.parentElement;\n          }\n          return \"none\";\n        },\n        /**\n         * Sets the Prism `language-xxxx` class of the given element.\n         *\n         * @param {Element} element\n         * @param {string} language\n         * @returns {void}\n         */\n        setLanguage: function(b, g) {\n          b.className = b.className.replace(RegExp(i, \"gi\"), \"\"), b.classList.add(\"language-\" + g);\n        },\n        /**\n         * Returns the script element that is currently executing.\n         *\n         * This does __not__ work for line script element.\n         *\n         * @returns {HTMLScriptElement | null}\n         */\n        currentScript: function() {\n          if (typeof document > \"u\")\n            return null;\n          if (\"currentScript\" in document)\n            return (\n              /** @type {any} */\n              document.currentScript\n            );\n          try {\n            throw new Error();\n          } catch (S) {\n            var b = (/at [^(\\r\\n]*\\((.*):[^:]+:[^:]+\\)$/i.exec(S.stack) || [])[1];\n            if (b) {\n              var g = document.getElementsByTagName(\"script\");\n              for (var v in g)\n                if (g[v].src == b)\n                  return g[v];\n            }\n            return null;\n          }\n        },\n        /**\n         * Returns whether a given class is active for `element`.\n         *\n         * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated\n         * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the\n         * given class is just the given class with a `no-` prefix.\n         *\n         * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is\n         * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its\n         * ancestors have the given class or the negated version of it, then the default activation will be returned.\n         *\n         * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated\n         * version of it, the class is considered active.\n         *\n         * @param {Element} element\n         * @param {string} className\n         * @param {boolean} [defaultActivation=false]\n         * @returns {boolean}\n         */\n        isActive: function(b, g, v) {\n          for (var S = \"no-\" + g; b; ) {\n            var w = b.classList;\n            if (w.contains(g))\n              return !0;\n            if (w.contains(S))\n              return !1;\n            b = b.parentElement;\n          }\n          return !!v;\n        }\n      },\n      /**\n       * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.\n       *\n       * @namespace\n       * @memberof Prism\n       * @public\n       */\n      languages: {\n        /**\n         * The grammar for plain, unformatted text.\n         */\n        plain: o,\n        plaintext: o,\n        text: o,\n        txt: o,\n        /**\n         * Creates a deep copy of the language with the given id and appends the given tokens.\n         *\n         * If a token in `redef` also appears in the copied language, then the existing token in the copied language\n         * will be overwritten at its original position.\n         *\n         * ## Best practices\n         *\n         * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)\n         * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to\n         * understand the language definition because, normally, the order of tokens matters in Prism grammars.\n         *\n         * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.\n         * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.\n         *\n         * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.\n         * @param {Grammar} redef The new tokens to append.\n         * @returns {Grammar} The new language created.\n         * @public\n         * @example\n         * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {\n         *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token\n         *     // at its original position\n         *     'comment': { ... },\n         *     // CSS doesn't have a 'color' token, so this token will be appended\n         *     'color': /\\b(?:red|green|blue)\\b/\n         * });\n         */\n        extend: function(b, g) {\n          var v = a.util.clone(a.languages[b]);\n          for (var S in g)\n            v[S] = g[S];\n          return v;\n        },\n        /**\n         * Inserts tokens _before_ another token in a language definition or any other grammar.\n         *\n         * ## Usage\n         *\n         * This helper method makes it easy to modify existing languages. For example, the CSS language definition\n         * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded\n         * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the\n         * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do\n         * this:\n         *\n         * ```js\n         * Prism.languages.markup.style = {\n         *     // token\n         * };\n         * ```\n         *\n         * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens\n         * before existing tokens. For the CSS example above, you would use it like this:\n         *\n         * ```js\n         * Prism.languages.insertBefore('markup', 'cdata', {\n         *     'style': {\n         *         // token\n         *     }\n         * });\n         * ```\n         *\n         * ## Special cases\n         *\n         * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar\n         * will be ignored.\n         *\n         * This behavior can be used to insert tokens after `before`:\n         *\n         * ```js\n         * Prism.languages.insertBefore('markup', 'comment', {\n         *     'comment': Prism.languages.markup.comment,\n         *     // tokens after 'comment'\n         * });\n         * ```\n         *\n         * ## Limitations\n         *\n         * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object\n         * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave\n         * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily\n         * deleting properties which is necessary to insert at arbitrary positions.\n         *\n         * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.\n         * Instead, it will create a new object and replace all references to the target object with the new one. This\n         * can be done without temporarily deleting properties, so the iteration order is well-defined.\n         *\n         * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if\n         * you hold the target object in a variable, then the value of the variable will not change.\n         *\n         * ```js\n         * var oldMarkup = Prism.languages.markup;\n         * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });\n         *\n         * assert(oldMarkup !== Prism.languages.markup);\n         * assert(newMarkup === Prism.languages.markup);\n         * ```\n         *\n         * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the\n         * object to be modified.\n         * @param {string} before The key to insert before.\n         * @param {Grammar} insert An object containing the key-value pairs to be inserted.\n         * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the\n         * object to be modified.\n         *\n         * Defaults to `Prism.languages`.\n         * @returns {Grammar} The new grammar object.\n         * @public\n         */\n        insertBefore: function(b, g, v, S) {\n          S = S || /** @type {any} */\n          a.languages;\n          var w = S[b], k = {};\n          for (var _ in w)\n            if (w.hasOwnProperty(_)) {\n              if (_ == g)\n                for (var T in v)\n                  v.hasOwnProperty(T) && (k[T] = v[T]);\n              v.hasOwnProperty(_) || (k[_] = w[_]);\n            }\n          var C = S[b];\n          return S[b] = k, a.languages.DFS(a.languages, function(A, Q) {\n            Q === C && A != b && (this[A] = k);\n          }), k;\n        },\n        // Traverse a language definition with Depth First Search\n        DFS: function b(g, v, S, w) {\n          w = w || {};\n          var k = a.util.objId;\n          for (var _ in g)\n            if (g.hasOwnProperty(_)) {\n              v.call(g, _, g[_], S || _);\n              var T = g[_], C = a.util.type(T);\n              C === \"Object\" && !w[k(T)] ? (w[k(T)] = !0, b(T, v, null, w)) : C === \"Array\" && !w[k(T)] && (w[k(T)] = !0, b(T, v, _, w));\n            }\n        }\n      },\n      plugins: {},\n      /**\n       * This is the most high-level function in Prisms API.\n       * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on\n       * each one of them.\n       *\n       * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.\n       *\n       * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.\n       * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.\n       * @memberof Prism\n       * @public\n       */\n      highlightAll: function(b, g) {\n        a.highlightAllUnder(document, b, g);\n      },\n      /**\n       * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls\n       * {@link Prism.highlightElement} on each one of them.\n       *\n       * The following hooks will be run:\n       * 1. `before-highlightall`\n       * 2. `before-all-elements-highlight`\n       * 3. All hooks of {@link Prism.highlightElement} for each element.\n       *\n       * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.\n       * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.\n       * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.\n       * @memberof Prism\n       * @public\n       */\n      highlightAllUnder: function(b, g, v) {\n        var S = {\n          callback: v,\n          container: b,\n          selector: 'code[class*=\"language-\"], [class*=\"language-\"] code, code[class*=\"lang-\"], [class*=\"lang-\"] code'\n        };\n        a.hooks.run(\"before-highlightall\", S), S.elements = Array.prototype.slice.apply(S.container.querySelectorAll(S.selector)), a.hooks.run(\"before-all-elements-highlight\", S);\n        for (var w = 0, k; k = S.elements[w++]; )\n          a.highlightElement(k, g === !0, S.callback);\n      },\n      /**\n       * Highlights the code inside a single element.\n       *\n       * The following hooks will be run:\n       * 1. `before-sanity-check`\n       * 2. `before-highlight`\n       * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.\n       * 4. `before-insert`\n       * 5. `after-highlight`\n       * 6. `complete`\n       *\n       * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for\n       * the element's language.\n       *\n       * @param {Element} element The element containing the code.\n       * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.\n       * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers\n       * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is\n       * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).\n       *\n       * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for\n       * asynchronous highlighting to work. You can build your own bundle on the\n       * [Download page](https://prismjs.com/download.html).\n       * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.\n       * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.\n       * @memberof Prism\n       * @public\n       */\n      highlightElement: function(b, g, v) {\n        var S = a.util.getLanguage(b), w = a.languages[S];\n        a.util.setLanguage(b, S);\n        var k = b.parentElement;\n        k && k.nodeName.toLowerCase() === \"pre\" && a.util.setLanguage(k, S);\n        var _ = b.textContent, T = {\n          element: b,\n          language: S,\n          grammar: w,\n          code: _\n        };\n        function C(Q) {\n          T.highlightedCode = Q, a.hooks.run(\"before-insert\", T), T.element.innerHTML = T.highlightedCode, a.hooks.run(\"after-highlight\", T), a.hooks.run(\"complete\", T), v && v.call(T.element);\n        }\n        if (a.hooks.run(\"before-sanity-check\", T), k = T.element.parentElement, k && k.nodeName.toLowerCase() === \"pre\" && !k.hasAttribute(\"tabindex\") && k.setAttribute(\"tabindex\", \"0\"), !T.code) {\n          a.hooks.run(\"complete\", T), v && v.call(T.element);\n          return;\n        }\n        if (a.hooks.run(\"before-highlight\", T), !T.grammar) {\n          C(a.util.encode(T.code));\n          return;\n        }\n        if (g && r.Worker) {\n          var A = new Worker(a.filename);\n          A.onmessage = function(Q) {\n            C(Q.data);\n          }, A.postMessage(JSON.stringify({\n            language: T.language,\n            code: T.code,\n            immediateClose: !0\n          }));\n        } else\n          C(a.highlight(T.code, T.grammar, T.language));\n      },\n      /**\n       * Low-level function, only use if you know what youre doing. It accepts a string of text as input\n       * and the language definitions to use, and returns a string with the HTML produced.\n       *\n       * The following hooks will be run:\n       * 1. `before-tokenize`\n       * 2. `after-tokenize`\n       * 3. `wrap`: On each {@link Token}.\n       *\n       * @param {string} text A string with the code to be highlighted.\n       * @param {Grammar} grammar An object containing the tokens to use.\n       *\n       * Usually a language definition like `Prism.languages.markup`.\n       * @param {string} language The name of the language definition passed to `grammar`.\n       * @returns {string} The highlighted HTML.\n       * @memberof Prism\n       * @public\n       * @example\n       * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');\n       */\n      highlight: function(b, g, v) {\n        var S = {\n          code: b,\n          grammar: g,\n          language: v\n        };\n        if (a.hooks.run(\"before-tokenize\", S), !S.grammar)\n          throw new Error('The language \"' + S.language + '\" has no grammar.');\n        return S.tokens = a.tokenize(S.code, S.grammar), a.hooks.run(\"after-tokenize\", S), l.stringify(a.util.encode(S.tokens), S.language);\n      },\n      /**\n       * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input\n       * and the language definitions to use, and returns an array with the tokenized code.\n       *\n       * When the language definition includes nested tokens, the function is called recursively on each of these tokens.\n       *\n       * This method could be useful in other contexts as well, as a very crude parser.\n       *\n       * @param {string} text A string with the code to be highlighted.\n       * @param {Grammar} grammar An object containing the tokens to use.\n       *\n       * Usually a language definition like `Prism.languages.markup`.\n       * @returns {TokenStream} An array of strings and tokens, a token stream.\n       * @memberof Prism\n       * @public\n       * @example\n       * let code = `var foo = 0;`;\n       * let tokens = Prism.tokenize(code, Prism.languages.javascript);\n       * tokens.forEach(token => {\n       *     if (token instanceof Prism.Token && token.type === 'number') {\n       *         console.log(`Found numeric literal: ${token.content}`);\n       *     }\n       * });\n       */\n      tokenize: function(b, g) {\n        var v = g.rest;\n        if (v) {\n          for (var S in v)\n            g[S] = v[S];\n          delete g.rest;\n        }\n        var w = new d();\n        return f(w, w.head, b), u(b, w, g, w.head, 0), p(w);\n      },\n      /**\n       * @namespace\n       * @memberof Prism\n       * @public\n       */\n      hooks: {\n        all: {},\n        /**\n         * Adds the given callback to the list of callbacks for the given hook.\n         *\n         * The callback will be invoked when the hook it is registered for is run.\n         * Hooks are usually directly run by a highlight function but you can also run hooks yourself.\n         *\n         * One callback function can be registered to multiple hooks and the same hook multiple times.\n         *\n         * @param {string} name The name of the hook.\n         * @param {HookCallback} callback The callback function which is given environment variables.\n         * @public\n         */\n        add: function(b, g) {\n          var v = a.hooks.all;\n          v[b] = v[b] || [], v[b].push(g);\n        },\n        /**\n         * Runs a hook invoking all registered callbacks with the given environment variables.\n         *\n         * Callbacks will be invoked synchronously and in the order in which they were registered.\n         *\n         * @param {string} name The name of the hook.\n         * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.\n         * @public\n         */\n        run: function(b, g) {\n          var v = a.hooks.all[b];\n          if (!(!v || !v.length))\n            for (var S = 0, w; w = v[S++]; )\n              w(g);\n        }\n      },\n      Token: l\n    };\n    r.Prism = a;\n    function l(b, g, v, S) {\n      this.type = b, this.content = g, this.alias = v, this.length = (S || \"\").length | 0;\n    }\n    l.stringify = function b(g, v) {\n      if (typeof g == \"string\")\n        return g;\n      if (Array.isArray(g)) {\n        var S = \"\";\n        return g.forEach(function(C) {\n          S += b(C, v);\n        }), S;\n      }\n      var w = {\n        type: g.type,\n        content: b(g.content, v),\n        tag: \"span\",\n        classes: [\"token\", g.type],\n        attributes: {},\n        language: v\n      }, k = g.alias;\n      k && (Array.isArray(k) ? Array.prototype.push.apply(w.classes, k) : w.classes.push(k)), a.hooks.run(\"wrap\", w);\n      var _ = \"\";\n      for (var T in w.attributes)\n        _ += \" \" + T + '=\"' + (w.attributes[T] || \"\").replace(/\"/g, \"&quot;\") + '\"';\n      return \"<\" + w.tag + ' class=\"' + w.classes.join(\" \") + '\"' + _ + \">\" + w.content + \"</\" + w.tag + \">\";\n    };\n    function c(b, g, v, S) {\n      b.lastIndex = g;\n      var w = b.exec(v);\n      if (w && S && w[1]) {\n        var k = w[1].length;\n        w.index += k, w[0] = w[0].slice(k);\n      }\n      return w;\n    }\n    function u(b, g, v, S, w, k) {\n      for (var _ in v)\n        if (!(!v.hasOwnProperty(_) || !v[_])) {\n          var T = v[_];\n          T = Array.isArray(T) ? T : [T];\n          for (var C = 0; C < T.length; ++C) {\n            if (k && k.cause == _ + \",\" + C)\n              return;\n            var A = T[C], Q = A.inside, W = !!A.lookbehind, L = !!A.greedy, re = A.alias;\n            if (L && !A.pattern.global) {\n              var Y = A.pattern.toString().match(/[imsuy]*$/)[0];\n              A.pattern = RegExp(A.pattern.source, Y + \"g\");\n            }\n            for (var K = A.pattern || A, B = S.next, _e = w; B !== g.tail && !(k && _e >= k.reach); _e += B.value.length, B = B.next) {\n              var Ce = B.value;\n              if (g.length > b.length)\n                return;\n              if (!(Ce instanceof l)) {\n                var ue = 1, ge;\n                if (L) {\n                  if (ge = c(K, _e, b, W), !ge || ge.index >= b.length)\n                    break;\n                  var Vt = ge.index, Be = ge.index + ge[0].length, Le = _e;\n                  for (Le += B.value.length; Vt >= Le; )\n                    B = B.next, Le += B.value.length;\n                  if (Le -= B.value.length, _e = Le, B.value instanceof l)\n                    continue;\n                  for (var Zt = B; Zt !== g.tail && (Le < Be || typeof Zt.value == \"string\"); Zt = Zt.next)\n                    ue++, Le += Zt.value.length;\n                  ue--, Ce = b.slice(_e, Le), ge.index -= _e;\n                } else if (ge = c(K, 0, Ce, W), !ge)\n                  continue;\n                var Vt = ge.index, It = ge[0], Tn = Ce.slice(0, Vt), Sr = Ce.slice(Vt + It.length), or = _e + Ce.length;\n                k && or > k.reach && (k.reach = or);\n                var En = B.prev;\n                Tn && (En = f(g, En, Tn), _e += Tn.length), h(g, En, ue);\n                var vi = new l(_, Q ? a.tokenize(It, Q) : It, re, It);\n                if (B = f(g, En, vi), Sr && f(g, B, Sr), ue > 1) {\n                  var Ur = {\n                    cause: _ + \",\" + C,\n                    reach: or\n                  };\n                  u(b, g, v, B.prev, _e, Ur), k && Ur.reach > k.reach && (k.reach = Ur.reach);\n                }\n              }\n            }\n          }\n        }\n    }\n    function d() {\n      var b = { value: null, prev: null, next: null }, g = { value: null, prev: b, next: null };\n      b.next = g, this.head = b, this.tail = g, this.length = 0;\n    }\n    function f(b, g, v) {\n      var S = g.next, w = { value: v, prev: g, next: S };\n      return g.next = w, S.prev = w, b.length++, w;\n    }\n    function h(b, g, v) {\n      for (var S = g.next, w = 0; w < v && S !== b.tail; w++)\n        S = S.next;\n      g.next = S, S.prev = g, b.length -= w;\n    }\n    function p(b) {\n      for (var g = [], v = b.head.next; v !== b.tail; )\n        g.push(v.value), v = v.next;\n      return g;\n    }\n    if (!r.document)\n      return r.addEventListener && (a.disableWorkerMessageHandler || r.addEventListener(\"message\", function(b) {\n        var g = JSON.parse(b.data), v = g.language, S = g.code, w = g.immediateClose;\n        r.postMessage(a.highlight(S, a.languages[v], v)), w && r.close();\n      }, !1)), a;\n    var O = a.util.currentScript();\n    O && (a.filename = O.src, O.hasAttribute(\"data-manual\") && (a.manual = !0));\n    function m() {\n      a.manual || a.highlightAll();\n    }\n    if (!a.manual) {\n      var y = document.readyState;\n      y === \"loading\" || y === \"interactive\" && O && O.defer ? document.addEventListener(\"DOMContentLoaded\", m) : window.requestAnimationFrame ? window.requestAnimationFrame(m) : window.setTimeout(m, 16);\n    }\n    return a;\n  }(e);\n  t.exports && (t.exports = n), typeof M0 < \"u\" && (M0.Prism = n), n.languages.markup = {\n    comment: {\n      pattern: /<!--(?:(?!<!--)[\\s\\S])*?-->/,\n      greedy: !0\n    },\n    prolog: {\n      pattern: /<\\?[\\s\\S]+?\\?>/,\n      greedy: !0\n    },\n    doctype: {\n      // https://www.w3.org/TR/xml/#NT-doctypedecl\n      pattern: /<!DOCTYPE(?:[^>\"'[\\]]|\"[^\"]*\"|'[^']*')+(?:\\[(?:[^<\"'\\]]|\"[^\"]*\"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\\]\\s*)?>/i,\n      greedy: !0,\n      inside: {\n        \"internal-subset\": {\n          pattern: /(^[^\\[]*\\[)[\\s\\S]+(?=\\]>$)/,\n          lookbehind: !0,\n          greedy: !0,\n          inside: null\n          // see below\n        },\n        string: {\n          pattern: /\"[^\"]*\"|'[^']*'/,\n          greedy: !0\n        },\n        punctuation: /^<!|>$|[[\\]]/,\n        \"doctype-tag\": /^DOCTYPE/i,\n        name: /[^\\s<>'\"]+/\n      }\n    },\n    cdata: {\n      pattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n      greedy: !0\n    },\n    tag: {\n      pattern: /<\\/?(?!\\d)[^\\s>\\/=$<%]+(?:\\s(?:\\s*[^\\s>\\/=]+(?:\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))|(?=[\\s/>])))+)?\\s*\\/?>/,\n      greedy: !0,\n      inside: {\n        tag: {\n          pattern: /^<\\/?[^\\s>\\/]+/,\n          inside: {\n            punctuation: /^<\\/?/,\n            namespace: /^[^\\s>\\/:]+:/\n          }\n        },\n        \"special-attr\": [],\n        \"attr-value\": {\n          pattern: /=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+)/,\n          inside: {\n            punctuation: [\n              {\n                pattern: /^=/,\n                alias: \"attr-equals\"\n              },\n              {\n                pattern: /^(\\s*)[\"']|[\"']$/,\n                lookbehind: !0\n              }\n            ]\n          }\n        },\n        punctuation: /\\/?>/,\n        \"attr-name\": {\n          pattern: /[^\\s>\\/]+/,\n          inside: {\n            namespace: /^[^\\s>\\/:]+:/\n          }\n        }\n      }\n    },\n    entity: [\n      {\n        pattern: /&[\\da-z]{1,8};/i,\n        alias: \"named-entity\"\n      },\n      /&#x?[\\da-f]{1,8};/i\n    ]\n  }, n.languages.markup.tag.inside[\"attr-value\"].inside.entity = n.languages.markup.entity, n.languages.markup.doctype.inside[\"internal-subset\"].inside = n.languages.markup, n.hooks.add(\"wrap\", function(r) {\n    r.type === \"entity\" && (r.attributes.title = r.content.replace(/&amp;/, \"&\"));\n  }), Object.defineProperty(n.languages.markup.tag, \"addInlined\", {\n    /**\n     * Adds an inlined language to markup.\n     *\n     * An example of an inlined language is CSS with `<style>` tags.\n     *\n     * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as\n     * case insensitive.\n     * @param {string} lang The language key.\n     * @example\n     * addInlined('style', 'css');\n     */\n    value: function(i, s) {\n      var o = {};\n      o[\"language-\" + s] = {\n        pattern: /(^<!\\[CDATA\\[)[\\s\\S]+?(?=\\]\\]>$)/i,\n        lookbehind: !0,\n        inside: n.languages[s]\n      }, o.cdata = /^<!\\[CDATA\\[|\\]\\]>$/i;\n      var a = {\n        \"included-cdata\": {\n          pattern: /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/i,\n          inside: o\n        }\n      };\n      a[\"language-\" + s] = {\n        pattern: /[\\s\\S]+/,\n        inside: n.languages[s]\n      };\n      var l = {};\n      l[i] = {\n        pattern: RegExp(/(<__[^>]*>)(?:<!\\[CDATA\\[(?:[^\\]]|\\](?!\\]>))*\\]\\]>|(?!<!\\[CDATA\\[)[\\s\\S])*?(?=<\\/__>)/.source.replace(/__/g, function() {\n          return i;\n        }), \"i\"),\n        lookbehind: !0,\n        greedy: !0,\n        inside: a\n      }, n.languages.insertBefore(\"markup\", \"cdata\", l);\n    }\n  }), Object.defineProperty(n.languages.markup.tag, \"addAttribute\", {\n    /**\n     * Adds an pattern to highlight languages embedded in HTML attributes.\n     *\n     * An example of an inlined language is CSS with `style` attributes.\n     *\n     * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as\n     * case insensitive.\n     * @param {string} lang The language key.\n     * @example\n     * addAttribute('style', 'css');\n     */\n    value: function(r, i) {\n      n.languages.markup.tag.inside[\"special-attr\"].push({\n        pattern: RegExp(\n          /(^|[\"'\\s])/.source + \"(?:\" + r + \")\" + /\\s*=\\s*(?:\"[^\"]*\"|'[^']*'|[^\\s'\">=]+(?=[\\s>]))/.source,\n          \"i\"\n        ),\n        lookbehind: !0,\n        inside: {\n          \"attr-name\": /^[^\\s=]+/,\n          \"attr-value\": {\n            pattern: /=[\\s\\S]+/,\n            inside: {\n              value: {\n                pattern: /(^=\\s*([\"']|(?![\"'])))\\S[\\s\\S]*(?=\\2$)/,\n                lookbehind: !0,\n                alias: [i, \"language-\" + i],\n                inside: n.languages[i]\n              },\n              punctuation: [\n                {\n                  pattern: /^=/,\n                  alias: \"attr-equals\"\n                },\n                /\"|'/\n              ]\n            }\n          }\n        }\n      });\n    }\n  }), n.languages.html = n.languages.markup, n.languages.mathml = n.languages.markup, n.languages.svg = n.languages.markup, n.languages.xml = n.languages.extend(\"markup\", {}), n.languages.ssml = n.languages.xml, n.languages.atom = n.languages.xml, n.languages.rss = n.languages.xml, function(r) {\n    var i = /(?:\"(?:\\\\(?:\\r\\n|[\\s\\S])|[^\"\\\\\\r\\n])*\"|'(?:\\\\(?:\\r\\n|[\\s\\S])|[^'\\\\\\r\\n])*')/;\n    r.languages.css = {\n      comment: /\\/\\*[\\s\\S]*?\\*\\//,\n      atrule: {\n        pattern: RegExp(\"@[\\\\w-](?:\" + /[^;{\\s\"']|\\s+(?!\\s)/.source + \"|\" + i.source + \")*?\" + /(?:;|(?=\\s*\\{))/.source),\n        inside: {\n          rule: /^@[\\w-]+/,\n          \"selector-function-argument\": {\n            pattern: /(\\bselector\\s*\\(\\s*(?![\\s)]))(?:[^()\\s]|\\s+(?![\\s)])|\\((?:[^()]|\\([^()]*\\))*\\))+(?=\\s*\\))/,\n            lookbehind: !0,\n            alias: \"selector\"\n          },\n          keyword: {\n            pattern: /(^|[^\\w-])(?:and|not|only|or)(?![\\w-])/,\n            lookbehind: !0\n          }\n          // See rest below\n        }\n      },\n      url: {\n        // https://drafts.csswg.org/css-values-3/#urls\n        pattern: RegExp(\"\\\\burl\\\\((?:\" + i.source + \"|\" + /(?:[^\\\\\\r\\n()\"']|\\\\[\\s\\S])*/.source + \")\\\\)\", \"i\"),\n        greedy: !0,\n        inside: {\n          function: /^url/i,\n          punctuation: /^\\(|\\)$/,\n          string: {\n            pattern: RegExp(\"^\" + i.source + \"$\"),\n            alias: \"url\"\n          }\n        }\n      },\n      selector: {\n        pattern: RegExp(`(^|[{}\\\\s])[^{}\\\\s](?:[^{};\"'\\\\s]|\\\\s+(?![\\\\s{])|` + i.source + \")*(?=\\\\s*\\\\{)\"),\n        lookbehind: !0\n      },\n      string: {\n        pattern: i,\n        greedy: !0\n      },\n      property: {\n        pattern: /(^|[^-\\w\\xA0-\\uFFFF])(?!\\s)[-_a-z\\xA0-\\uFFFF](?:(?!\\s)[-\\w\\xA0-\\uFFFF])*(?=\\s*:)/i,\n        lookbehind: !0\n      },\n      important: /!important\\b/i,\n      function: {\n        pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\\()/i,\n        lookbehind: !0\n      },\n      punctuation: /[(){};:,]/\n    }, r.languages.css.atrule.inside.rest = r.languages.css;\n    var s = r.languages.markup;\n    s && (s.tag.addInlined(\"style\", \"css\"), s.tag.addAttribute(\"style\", \"css\"));\n  }(n), n.languages.clike = {\n    comment: [\n      {\n        pattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n        lookbehind: !0,\n        greedy: !0\n      },\n      {\n        pattern: /(^|[^\\\\:])\\/\\/.*/,\n        lookbehind: !0,\n        greedy: !0\n      }\n    ],\n    string: {\n      pattern: /([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\1)[^\\\\\\r\\n])*\\1/,\n      greedy: !0\n    },\n    \"class-name\": {\n      pattern: /(\\b(?:class|extends|implements|instanceof|interface|new|trait)\\s+|\\bcatch\\s+\\()[\\w.\\\\]+/i,\n      lookbehind: !0,\n      inside: {\n        punctuation: /[.\\\\]/\n      }\n    },\n    keyword: /\\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\\b/,\n    boolean: /\\b(?:false|true)\\b/,\n    function: /\\b\\w+(?=\\()/,\n    number: /\\b0x[\\da-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:e[+-]?\\d+)?/i,\n    operator: /[<>]=?|[!=]=?=?|--?|\\+\\+?|&&?|\\|\\|?|[?*/~^%]/,\n    punctuation: /[{}[\\];(),.:]/\n  }, n.languages.javascript = n.languages.extend(\"clike\", {\n    \"class-name\": [\n      n.languages.clike[\"class-name\"],\n      {\n        pattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$A-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\.(?:constructor|prototype))/,\n        lookbehind: !0\n      }\n    ],\n    keyword: [\n      {\n        pattern: /((?:^|\\})\\s*)catch\\b/,\n        lookbehind: !0\n      },\n      {\n        pattern: /(^|[^.]|\\.\\.\\.\\s*)\\b(?:as|assert(?=\\s*\\{)|async(?=\\s*(?:function\\b|\\(|[$\\w\\xA0-\\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\\s*(?:\\{|$))|for|from(?=\\s*(?:['\"]|$))|function|(?:get|set)(?=\\s*(?:[#\\[$\\w\\xA0-\\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\\b/,\n        lookbehind: !0\n      }\n    ],\n    // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)\n    function: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*(?:\\.\\s*(?:apply|bind|call)\\s*)?\\()/,\n    number: {\n      pattern: RegExp(\n        /(^|[^\\w$])/.source + \"(?:\" + // constant\n        (/NaN|Infinity/.source + \"|\" + // binary integer\n        /0[bB][01]+(?:_[01]+)*n?/.source + \"|\" + // octal integer\n        /0[oO][0-7]+(?:_[0-7]+)*n?/.source + \"|\" + // hexadecimal integer\n        /0[xX][\\dA-Fa-f]+(?:_[\\dA-Fa-f]+)*n?/.source + \"|\" + // decimal bigint\n        /\\d+(?:_\\d+)*n/.source + \"|\" + // decimal number (integer or float) but no bigint\n        /(?:\\d+(?:_\\d+)*(?:\\.(?:\\d+(?:_\\d+)*)?)?|\\.\\d+(?:_\\d+)*)(?:[Ee][+-]?\\d+(?:_\\d+)*)?/.source) + \")\" + /(?![\\w$])/.source\n      ),\n      lookbehind: !0\n    },\n    operator: /--|\\+\\+|\\*\\*=?|=>|&&=?|\\|\\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\\.{3}|\\?\\?=?|\\?\\.?|[~:]/\n  }), n.languages.javascript[\"class-name\"][0].pattern = /(\\b(?:class|extends|implements|instanceof|interface|new)\\s+)[\\w.\\\\]+/, n.languages.insertBefore(\"javascript\", \"keyword\", {\n    regex: {\n      pattern: RegExp(\n        // lookbehind\n        // eslint-disable-next-line regexp/no-dupe-characters-character-class\n        /((?:^|[^$\\w\\xA0-\\uFFFF.\"'\\])\\s]|\\b(?:return|yield))\\s*)/.source + // Regex pattern:\n        // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character\n        // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible\n        // with the only syntax, so we have to define 2 different regex patterns.\n        /\\//.source + \"(?:\" + /(?:\\[(?:[^\\]\\\\\\r\\n]|\\\\.)*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}/.source + \"|\" + // `v` flag syntax. This supports 3 levels of nested character classes.\n        /(?:\\[(?:[^[\\]\\\\\\r\\n]|\\\\.|\\[(?:[^[\\]\\\\\\r\\n]|\\\\.|\\[(?:[^[\\]\\\\\\r\\n]|\\\\.)*\\])*\\])*\\]|\\\\.|[^/\\\\\\[\\r\\n])+\\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + \")\" + // lookahead\n        /(?=(?:\\s|\\/\\*(?:[^*]|\\*(?!\\/))*\\*\\/)*(?:$|[\\r\\n,.;:})\\]]|\\/\\/))/.source\n      ),\n      lookbehind: !0,\n      greedy: !0,\n      inside: {\n        \"regex-source\": {\n          pattern: /^(\\/)[\\s\\S]+(?=\\/[a-z]*$)/,\n          lookbehind: !0,\n          alias: \"language-regex\",\n          inside: n.languages.regex\n        },\n        \"regex-delimiter\": /^\\/|\\/$/,\n        \"regex-flags\": /^[a-z]+$/\n      }\n    },\n    // This must be declared before keyword because we use \"function\" inside the look-forward\n    \"function-variable\": {\n      pattern: /#?(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*[=:]\\s*(?:async\\s*)?(?:\\bfunction\\b|(?:\\((?:[^()]|\\([^()]*\\))*\\)|(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)\\s*=>))/,\n      alias: \"function\"\n    },\n    parameter: [\n      {\n        pattern: /(function(?:\\s+(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*)?\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\))/,\n        lookbehind: !0,\n        inside: n.languages.javascript\n      },\n      {\n        pattern: /(^|[^$\\w\\xA0-\\uFFFF])(?!\\s)[_$a-z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*=>)/i,\n        lookbehind: !0,\n        inside: n.languages.javascript\n      },\n      {\n        pattern: /(\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*=>)/,\n        lookbehind: !0,\n        inside: n.languages.javascript\n      },\n      {\n        pattern: /((?:\\b|\\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\\w\\xA0-\\uFFFF]))(?:(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*\\s*)\\(\\s*|\\]\\s*\\(\\s*)(?!\\s)(?:[^()\\s]|\\s+(?![\\s)])|\\([^()]*\\))+(?=\\s*\\)\\s*\\{)/,\n        lookbehind: !0,\n        inside: n.languages.javascript\n      }\n    ],\n    constant: /\\b[A-Z](?:[A-Z_]|\\dx?)*\\b/\n  }), n.languages.insertBefore(\"javascript\", \"string\", {\n    hashbang: {\n      pattern: /^#!.*/,\n      greedy: !0,\n      alias: \"comment\"\n    },\n    \"template-string\": {\n      pattern: /`(?:\\\\[\\s\\S]|\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}|(?!\\$\\{)[^\\\\`])*`/,\n      greedy: !0,\n      inside: {\n        \"template-punctuation\": {\n          pattern: /^`|`$/,\n          alias: \"string\"\n        },\n        interpolation: {\n          pattern: /((?:^|[^\\\\])(?:\\\\{2})*)\\$\\{(?:[^{}]|\\{(?:[^{}]|\\{[^}]*\\})*\\})+\\}/,\n          lookbehind: !0,\n          inside: {\n            \"interpolation-punctuation\": {\n              pattern: /^\\$\\{|\\}$/,\n              alias: \"punctuation\"\n            },\n            rest: n.languages.javascript\n          }\n        },\n        string: /[\\s\\S]+/\n      }\n    },\n    \"string-property\": {\n      pattern: /((?:^|[,{])[ \\t]*)([\"'])(?:\\\\(?:\\r\\n|[\\s\\S])|(?!\\2)[^\\\\\\r\\n])*\\2(?=\\s*:)/m,\n      lookbehind: !0,\n      greedy: !0,\n      alias: \"property\"\n    }\n  }), n.languages.insertBefore(\"javascript\", \"operator\", {\n    \"literal-property\": {\n      pattern: /((?:^|[,{])[ \\t]*)(?!\\s)[_$a-zA-Z\\xA0-\\uFFFF](?:(?!\\s)[$\\w\\xA0-\\uFFFF])*(?=\\s*:)/m,\n      lookbehind: !0,\n      alias: \"property\"\n    }\n  }), n.languages.markup && (n.languages.markup.tag.addInlined(\"script\", \"javascript\"), n.languages.markup.tag.addAttribute(\n    /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,\n    \"javascript\"\n  )), n.languages.js = n.languages.javascript, function() {\n    if (typeof n > \"u\" || typeof document > \"u\")\n      return;\n    Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector);\n    var r = \"Loading\", i = function(O, m) {\n      return \" Error \" + O + \" while fetching file: \" + m;\n    }, s = \" Error: File does not exist or is empty\", o = {\n      js: \"javascript\",\n      py: \"python\",\n      rb: \"ruby\",\n      ps1: \"powershell\",\n      psm1: \"powershell\",\n      sh: \"bash\",\n      bat: \"batch\",\n      h: \"c\",\n      tex: \"latex\"\n    }, a = \"data-src-status\", l = \"loading\", c = \"loaded\", u = \"failed\", d = \"pre[data-src]:not([\" + a + '=\"' + c + '\"]):not([' + a + '=\"' + l + '\"])';\n    function f(O, m, y) {\n      var b = new XMLHttpRequest();\n      b.open(\"GET\", O, !0), b.onreadystatechange = function() {\n        b.readyState == 4 && (b.status < 400 && b.responseText ? m(b.responseText) : b.status >= 400 ? y(i(b.status, b.statusText)) : y(s));\n      }, b.send(null);\n    }\n    function h(O) {\n      var m = /^\\s*(\\d+)\\s*(?:(,)\\s*(?:(\\d+)\\s*)?)?$/.exec(O || \"\");\n      if (m) {\n        var y = Number(m[1]), b = m[2], g = m[3];\n        return b ? g ? [y, Number(g)] : [y, void 0] : [y, y];\n      }\n    }\n    n.hooks.add(\"before-highlightall\", function(O) {\n      O.selector += \", \" + d;\n    }), n.hooks.add(\"before-sanity-check\", function(O) {\n      var m = (\n        /** @type {HTMLPreElement} */\n        O.element\n      );\n      if (m.matches(d)) {\n        O.code = \"\", m.setAttribute(a, l);\n        var y = m.appendChild(document.createElement(\"CODE\"));\n        y.textContent = r;\n        var b = m.getAttribute(\"data-src\"), g = O.language;\n        if (g === \"none\") {\n          var v = (/\\.(\\w+)$/.exec(b) || [, \"none\"])[1];\n          g = o[v] || v;\n        }\n        n.util.setLanguage(y, g), n.util.setLanguage(m, g);\n        var S = n.plugins.autoloader;\n        S && S.loadLanguages(g), f(\n          b,\n          function(w) {\n            m.setAttribute(a, c);\n            var k = h(m.getAttribute(\"data-range\"));\n            if (k) {\n              var _ = w.split(/\\r\\n?|\\n/g), T = k[0], C = k[1] == null ? _.length : k[1];\n              T < 0 && (T += _.length), T = Math.max(0, Math.min(T - 1, _.length)), C < 0 && (C += _.length), C = Math.max(0, Math.min(C, _.length)), w = _.slice(T, C).join(`\n`), m.hasAttribute(\"data-start\") || m.setAttribute(\"data-start\", String(T + 1));\n            }\n            y.textContent = w, n.highlightElement(y);\n          },\n          function(w) {\n            m.setAttribute(a, u), y.textContent = w;\n          }\n        );\n      }\n    }), n.plugins.fileHighlight = {\n      /**\n       * Executes the File Highlight plugin for all matching `pre` elements under the given container.\n       *\n       * Note: Elements which are already loaded or currently loading will not be touched by this method.\n       *\n       * @param {ParentNode} [container=document]\n       */\n      highlight: function(m) {\n        for (var y = (m || document).querySelectorAll(d), b = 0, g; g = y[b++]; )\n          n.highlightElement(g);\n      }\n    };\n    var p = !1;\n    n.fileHighlight = function() {\n      p || (console.warn(\"Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.\"), p = !0), n.plugins.fileHighlight.highlight.apply(this, arguments);\n    };\n  }();\n})(CP);\nvar qM = CP.exports;\nconst Ea = /* @__PURE__ */ UM(qM), Wp = \"scalar-component\", YM = LM({\n  extend: {\n    classGroups: {\n      \"font-size\": [\"text-xxs\"],\n      // Add the scalar class prefix as a custom class to be deduped by tailwind-merge\n      [Wp]: [Wp]\n    }\n  }\n}), { cva: $g, cx: Gd, compose: Vj } = dM({\n  hooks: {\n    onComplete: (t) => `${YM(t, Wp)}`\n  }\n}), zM = /* @__PURE__ */ Wl('<path class=\"svg-path svg-check-mark\" d=\"m 0 60 l 30 30 l 70 -80\" data-v-47faceda></path><path class=\"svg-path svg-x-mark\" d=\"m 50 50 l 40 -40\" data-v-47faceda></path><path class=\"svg-path svg-x-mark\" d=\"m 50 50 l 40 40\" data-v-47faceda></path><path class=\"svg-path svg-x-mark\" d=\"m 50 50 l -40 -40\" data-v-47faceda></path><path class=\"svg-path svg-x-mark\" d=\"m 50 50 l -40 40\" data-v-47faceda></path>', 5), HM = {\n  key: 0,\n  class: \"circular-loader\"\n}, FM = /* @__PURE__ */ le({\n  __name: \"ScalarLoading\",\n  props: {\n    loadingState: {},\n    size: { default: \"24px\" }\n  },\n  setup(t) {\n    return G1((e) => ({\n      d6cae758: e.size\n    })), (e, n) => e.loadingState ? (Z(), ne(\"div\", {\n      key: 0,\n      class: Ke(R(Gd)(\"loader-wrapper\"))\n    }, [\n      (Z(), ne(\"svg\", {\n        class: Ke([\"svg-loader\", {\n          \"icon-is-valid\": e.loadingState.isValid,\n          \"icon-is-invalid\": e.loadingState.isInvalid\n        }]),\n        viewBox: \"0 0 100 100\",\n        xmlns: \"http://www.w3.org/2000/svg\",\n        \"xmlns:xlink\": \"http://www.w3.org/1999/xlink\"\n      }, [\n        zM,\n        e.loadingState.isLoading ? (Z(), ne(\"g\", HM, [\n          D(\"circle\", {\n            class: Ke([\"loader-path\", {\n              \"loader-path-off\": e.loadingState.isValid || e.loadingState.isInvalid\n            }]),\n            cx: \"50\",\n            cy: \"50\",\n            fill: \"none\",\n            r: \"20\",\n            \"stroke-width\": \"2\"\n          }, null, 2)\n        ])) : st(\"\", !0)\n      ], 2))\n    ], 2)) : st(\"\", !0);\n  }\n}), GM = (t, e) => {\n  const n = t.__vccOpts || t;\n  for (const [r, i] of e)\n    n[r] = i;\n  return n;\n}, KM = /* @__PURE__ */ GM(FM, [[\"__scopeId\", \"data-v-47faceda\"]]), AP = {\n  solid: [\n    \"scalar-button-solid\",\n    \"bg-back-btn-1 text-fore-btn-1 shadow-sm active:bg-back-btn-1 active:shadow-none hocus:bg-hover-btn-1\"\n  ],\n  outlined: [\n    \"scalar-button-outlined\",\n    \"active:bg-btn-1 border border-solid border-border bg-transparent text-fore-1 hocus:bg-border\"\n  ],\n  ghost: [\n    \"scalar-button-ghost\",\n    \"bg-transparent text-fore-3 active:text-fore-2 hocus:text-fore-2\"\n  ],\n  danger: [\n    \"scalar-button-danger\",\n    \"bg-error text-white active:brightness-90 hocus:brightness-90\"\n  ]\n}, JM = $g({\n  base: \"scalar-button row cursor-pointer items-center justify-center rounded font-medium\",\n  variants: {\n    disabled: {\n      true: \"bg-background-2 text-color-3 cursor-not-allowed shadow-none\"\n    },\n    fullWidth: { true: \"w-full\" },\n    size: { sm: \"px-2 py-1 text-xs\", md: \"h-10 px-6 text-sm\" },\n    variant: AP\n  },\n  compoundVariants: [\n    {\n      disabled: !0,\n      variant: \"ghost\",\n      class: \"bg-transparent text-ghost\"\n    }\n  ]\n}), eX = [\"ariaDisabled\"], tX = {\n  key: 0,\n  class: \"mr-2 h-4 w-4\"\n}, nX = {\n  key: 1,\n  class: \"ml-2\"\n}, rX = /* @__PURE__ */ le({\n  inheritAttrs: !1,\n  __name: \"ScalarButton\",\n  props: {\n    disabled: { type: Boolean },\n    fullWidth: { type: Boolean, default: !1 },\n    loading: {},\n    size: { default: \"md\" },\n    variant: { default: \"solid\" }\n  },\n  setup(t) {\n    const e = j(() => {\n      const { class: n, ...r } = xO();\n      return { class: n || \"\", rest: r };\n    });\n    return (n, r) => (Z(), ne(\"button\", Ml(e.value.rest, {\n      ariaDisabled: n.disabled || void 0,\n      class: R(Gd)(\n        R(JM)({ fullWidth: n.fullWidth, disabled: n.disabled, size: n.size, variant: n.variant }),\n        { \"pl-9 pr-3\": n.loading },\n        `${e.value.class}`\n      ),\n      type: \"button\"\n    }), [\n      n.$slots.icon ? (Z(), ne(\"div\", tX, [\n        pt(n.$slots, \"icon\")\n      ])) : st(\"\", !0),\n      pt(n.$slots, \"default\"),\n      n.loading ? (Z(), ne(\"div\", nX, [\n        J(R(KM), {\n          loadingState: n.loading,\n          size: \"20px\"\n        }, null, 8, [\"loadingState\"])\n      ])) : st(\"\", !0)\n    ], 16, eX));\n  }\n});\n(function(t) {\n  var e = \"\\\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\\\b\", n = {\n    pattern: /(^([\"']?)\\w+\\2)[ \\t]+\\S.*/,\n    lookbehind: !0,\n    alias: \"punctuation\",\n    // this looks reasonably well in all themes\n    inside: null\n    // see below\n  }, r = {\n    bash: n,\n    environment: {\n      pattern: RegExp(\"\\\\$\" + e),\n      alias: \"constant\"\n    },\n    variable: [\n      // [0]: Arithmetic Environment\n      {\n        pattern: /\\$?\\(\\([\\s\\S]+?\\)\\)/,\n        greedy: !0,\n        inside: {\n          // If there is a $ sign at the beginning highlight $(( and )) as variable\n          variable: [\n            {\n              pattern: /(^\\$\\(\\([\\s\\S]+)\\)\\)/,\n              lookbehind: !0\n            },\n            /^\\$\\(\\(/\n          ],\n          number: /\\b0x[\\dA-Fa-f]+\\b|(?:\\b\\d+(?:\\.\\d*)?|\\B\\.\\d+)(?:[Ee]-?\\d+)?/,\n          // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic\n          operator: /--|\\+\\+|\\*\\*=?|<<=?|>>=?|&&|\\|\\||[=!+\\-*/%<>^&|]=?|[?~:]/,\n          // If there is no $ sign at the beginning highlight (( and )) as punctuation\n          punctuation: /\\(\\(?|\\)\\)?|,|;/\n        }\n      },\n      // [1]: Command Substitution\n      {\n        pattern: /\\$\\((?:\\([^)]+\\)|[^()])+\\)|`[^`]+`/,\n        greedy: !0,\n        inside: {\n          variable: /^\\$\\(|^`|\\)$|`$/\n        }\n      },\n      // [2]: Brace expansion\n      {\n        pattern: /\\$\\{[^}]+\\}/,\n        greedy: !0,\n        inside: {\n          operator: /:[-=?+]?|[!\\/]|##?|%%?|\\^\\^?|,,?/,\n          punctuation: /[\\[\\]]/,\n          environment: {\n            pattern: RegExp(\"(\\\\{)\" + e),\n            lookbehind: !0,\n            alias: \"constant\"\n          }\n        }\n      },\n      /\\$(?:\\w+|[#?*!@$])/\n    ],\n    // Escape sequences from echo and printf's manuals, and escaped quotes.\n    entity: /\\\\(?:[abceEfnrtv\\\\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/\n  };\n  t.languages.bash = {\n    shebang: {\n      pattern: /^#!\\s*\\/.*/,\n      alias: \"important\"\n    },\n    comment: {\n      pattern: /(^|[^\"{\\\\$])#.*/,\n      lookbehind: !0\n    },\n    \"function-name\": [\n      // a) function foo {\n      // b) foo() {\n      // c) function foo() {\n      // but not foo {\n      {\n        // a) and c)\n        pattern: /(\\bfunction\\s+)[\\w-]+(?=(?:\\s*\\(?:\\s*\\))?\\s*\\{)/,\n        lookbehind: !0,\n        alias: \"function\"\n      },\n      {\n        // b)\n        pattern: /\\b[\\w-]+(?=\\s*\\(\\s*\\)\\s*\\{)/,\n        alias: \"function\"\n      }\n    ],\n    // Highlight variable names as variables in for and select beginnings.\n    \"for-or-select\": {\n      pattern: /(\\b(?:for|select)\\s+)\\w+(?=\\s+in\\s)/,\n      alias: \"variable\",\n      lookbehind: !0\n    },\n    // Highlight variable names as variables in the left-hand part\n    // of assignments (= and +=).\n    \"assign-left\": {\n      pattern: /(^|[\\s;|&]|[<>]\\()\\w+(?:\\.\\w+)*(?=\\+?=)/,\n      inside: {\n        environment: {\n          pattern: RegExp(\"(^|[\\\\s;|&]|[<>]\\\\()\" + e),\n          lookbehind: !0,\n          alias: \"constant\"\n        }\n      },\n      alias: \"variable\",\n      lookbehind: !0\n    },\n    // Highlight parameter names as variables\n    parameter: {\n      pattern: /(^|\\s)-{1,2}(?:\\w+:[+-]?)?\\w+(?:\\.\\w+)*(?=[=\\s]|$)/,\n      alias: \"variable\",\n      lookbehind: !0\n    },\n    string: [\n      // Support for Here-documents https://en.wikipedia.org/wiki/Here_document\n      {\n        pattern: /((?:^|[^<])<<-?\\s*)(\\w+)\\s[\\s\\S]*?(?:\\r?\\n|\\r)\\2/,\n        lookbehind: !0,\n        greedy: !0,\n        inside: r\n      },\n      // Here-document with quotes around the tag\n      //  No expansion (so no inside).\n      {\n        pattern: /((?:^|[^<])<<-?\\s*)([\"'])(\\w+)\\2\\s[\\s\\S]*?(?:\\r?\\n|\\r)\\3/,\n        lookbehind: !0,\n        greedy: !0,\n        inside: {\n          bash: n\n        }\n      },\n      // Normal string\n      {\n        // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html\n        pattern: /(^|[^\\\\](?:\\\\\\\\)*)\"(?:\\\\[\\s\\S]|\\$\\([^)]+\\)|\\$(?!\\()|`[^`]+`|[^\"\\\\`$])*\"/,\n        lookbehind: !0,\n        greedy: !0,\n        inside: r\n      },\n      {\n        // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html\n        pattern: /(^|[^$\\\\])'[^']*'/,\n        lookbehind: !0,\n        greedy: !0\n      },\n      {\n        // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html\n        pattern: /\\$'(?:[^'\\\\]|\\\\[\\s\\S])*'/,\n        greedy: !0,\n        inside: {\n          entity: r.entity\n        }\n      }\n    ],\n    environment: {\n      pattern: RegExp(\"\\\\$?\" + e),\n      alias: \"constant\"\n    },\n    variable: r.variable,\n    function: {\n      pattern: /(^|[\\s;|&]|[<>]\\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cargo|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|java|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|sysctl|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\\s;|&])/,\n      lookbehind: !0\n    },\n    keyword: {\n      pattern: /(^|[\\s;|&]|[<>]\\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\\s;|&])/,\n      lookbehind: !0\n    },\n    // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html\n    builtin: {\n      pattern: /(^|[\\s;|&]|[<>]\\()(?:\\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\\s;|&])/,\n      lookbehind: !0,\n      // Alias added to make those easier to distinguish from strings.\n      alias: \"class-name\"\n    },\n    boolean: {\n      pattern: /(^|[\\s;|&]|[<>]\\()(?:false|true)(?=$|[)\\s;|&])/,\n      lookbehind: !0\n    },\n    \"file-descriptor\": {\n      pattern: /\\B&\\d\\b/,\n      alias: \"important\"\n    },\n    operator: {\n      // Lots of redirections here, but not just that.\n      pattern: /\\d?<>|>\\||\\+=|=[=~]?|!=?|<<[<-]?|[&\\d]?>>|\\d[<>]&?|[<>][&=]?|&[>&]?|\\|[&|]?/,\n      inside: {\n        \"file-descriptor\": {\n          pattern: /^\\d/,\n          alias: \"important\"\n        }\n      }\n    },\n    punctuation: /\\$?\\(\\(?|\\)\\)?|\\.\\.|[{}[\\];\\\\]/,\n    number: {\n      pattern: /(^|\\s)(?:[1-9]\\d*|0)(?:[.,]\\d+)?\\b/,\n      lookbehind: !0\n    }\n  }, n.inside = t.languages.bash;\n  for (var i = [\n    \"comment\",\n    \"function-name\",\n    \"for-or-select\",\n    \"assign-left\",\n    \"parameter\",\n    \"string\",\n    \"environment\",\n    \"function\",\n    \"keyword\",\n    \"builtin\",\n    \"boolean\",\n    \"file-descriptor\",\n    \"operator\",\n    \"punctuation\",\n    \"number\"\n  ], s = r.variable[1].inside, o = 0; o < i.length; o++)\n    s[i[o]] = t.languages.bash[i[o]];\n  t.languages.sh = t.languages.bash, t.languages.shell = t.languages.bash;\n})(Prism);\nPrism.languages.json = {\n  property: {\n    pattern: /(^|[^\\\\])\"(?:\\\\.|[^\\\\\"\\r\\n])*\"(?=\\s*:)/,\n    lookbehind: !0,\n    greedy: !0\n  },\n  string: {\n    pattern: /(^|[^\\\\])\"(?:\\\\.|[^\\\\\"\\r\\n])*\"(?!\\s*:)/,\n    lookbehind: !0,\n    greedy: !0\n  },\n  comment: {\n    pattern: /\\/\\/.*|\\/\\*[\\s\\S]*?(?:\\*\\/|$)/,\n    greedy: !0\n  },\n  number: /-?\\b\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?\\b/i,\n  punctuation: /[{}[\\],]/,\n  operator: /:/,\n  boolean: /\\b(?:false|true)\\b/,\n  null: {\n    pattern: /\\bnull\\b/,\n    alias: \"keyword\"\n  }\n};\nPrism.languages.webmanifest = Prism.languages.json;\n(function() {\n  if (typeof Prism > \"u\" || typeof document > \"u\")\n    return;\n  var t = \"line-numbers\", e = /\\n(?!$)/g, n = Prism.plugins.lineNumbers = {\n    /**\n     * Get node for provided line number\n     *\n     * @param {Element} element pre element\n     * @param {number} number line number\n     * @returns {Element|undefined}\n     */\n    getLine: function(o, a) {\n      if (!(o.tagName !== \"PRE\" || !o.classList.contains(t))) {\n        var l = o.querySelector(\".line-numbers-rows\");\n        if (l) {\n          var c = parseInt(o.getAttribute(\"data-start\"), 10) || 1, u = c + (l.children.length - 1);\n          a < c && (a = c), a > u && (a = u);\n          var d = a - c;\n          return l.children[d];\n        }\n      }\n    },\n    /**\n     * Resizes the line numbers of the given element.\n     *\n     * This function will not add line numbers. It will only resize existing ones.\n     *\n     * @param {HTMLElement} element A `<pre>` element with line numbers.\n     * @returns {void}\n     */\n    resize: function(o) {\n      r([o]);\n    },\n    /**\n     * Whether the plugin can assume that the units font sizes and margins are not depended on the size of\n     * the current viewport.\n     *\n     * Setting this to `true` will allow the plugin to do certain optimizations for better performance.\n     *\n     * Set this to `false` if you use any of the following CSS units: `vh`, `vw`, `vmin`, `vmax`.\n     *\n     * @type {boolean}\n     */\n    assumeViewportIndependence: !0\n  };\n  function r(o) {\n    if (o = o.filter(function(l) {\n      var c = i(l), u = c[\"white-space\"];\n      return u === \"pre-wrap\" || u === \"pre-line\";\n    }), o.length != 0) {\n      var a = o.map(function(l) {\n        var c = l.querySelector(\"code\"), u = l.querySelector(\".line-numbers-rows\");\n        if (!(!c || !u)) {\n          var d = l.querySelector(\".line-numbers-sizer\"), f = c.textContent.split(e);\n          d || (d = document.createElement(\"span\"), d.className = \"line-numbers-sizer\", c.appendChild(d)), d.innerHTML = \"0\", d.style.display = \"block\";\n          var h = d.getBoundingClientRect().height;\n          return d.innerHTML = \"\", {\n            element: l,\n            lines: f,\n            lineHeights: [],\n            oneLinerHeight: h,\n            sizer: d\n          };\n        }\n      }).filter(Boolean);\n      a.forEach(function(l) {\n        var c = l.sizer, u = l.lines, d = l.lineHeights, f = l.oneLinerHeight;\n        d[u.length - 1] = void 0, u.forEach(function(h, p) {\n          if (h && h.length > 1) {\n            var O = c.appendChild(document.createElement(\"span\"));\n            O.style.display = \"block\", O.textContent = h;\n          } else\n            d[p] = f;\n        });\n      }), a.forEach(function(l) {\n        for (var c = l.sizer, u = l.lineHeights, d = 0, f = 0; f < u.length; f++)\n          u[f] === void 0 && (u[f] = c.children[d++].getBoundingClientRect().height);\n      }), a.forEach(function(l) {\n        var c = l.sizer, u = l.element.querySelector(\".line-numbers-rows\");\n        c.style.display = \"none\", c.innerHTML = \"\", l.lineHeights.forEach(function(d, f) {\n          u.children[f].style.height = d + \"px\";\n        });\n      });\n    }\n  }\n  function i(o) {\n    return o ? window.getComputedStyle ? getComputedStyle(o) : o.currentStyle || null : null;\n  }\n  var s = void 0;\n  window.addEventListener(\"resize\", function() {\n    n.assumeViewportIndependence && s === window.innerWidth || (s = window.innerWidth, r(Array.prototype.slice.call(document.querySelectorAll(\"pre.\" + t))));\n  }), Prism.hooks.add(\"complete\", function(o) {\n    if (o.code) {\n      var a = (\n        /** @type {Element} */\n        o.element\n      ), l = (\n        /** @type {HTMLElement} */\n        a.parentNode\n      );\n      if (!(!l || !/pre/i.test(l.nodeName)) && !a.querySelector(\".line-numbers-rows\") && Prism.util.isActive(a, t)) {\n        a.classList.remove(t), l.classList.add(t);\n        var c = o.code.match(e), u = c ? c.length + 1 : 1, d, f = new Array(u + 1).join(\"<span></span>\");\n        d = document.createElement(\"span\"), d.setAttribute(\"aria-hidden\", \"true\"), d.className = \"line-numbers-rows\", d.innerHTML = f, l.hasAttribute(\"data-start\") && (l.style.counterReset = \"linenumber \" + (parseInt(l.getAttribute(\"data-start\"), 10) - 1)), o.element.appendChild(d), r([l]), Prism.hooks.run(\"line-numbers\", o);\n      }\n    }\n  }), Prism.hooks.add(\"line-numbers\", function(o) {\n    o.plugins = o.plugins || {}, o.plugins.lineNumbers = !0;\n  });\n})();\nfunction iX(t) {\n  const e = /* @__PURE__ */ new Set();\n  return JSON.stringify(\n    t,\n    (n, r) => {\n      if (typeof r == \"object\" && r !== null) {\n        if (e.has(r))\n          return \"[Circular]\";\n        e.add(r);\n      }\n      return r;\n    },\n    2\n  );\n}\nfunction Lc(t) {\n  if (typeof t == \"string\")\n    return t;\n  if (typeof t == \"object\")\n    try {\n      return JSON.stringify(t, null, 2);\n    } catch {\n      return iX(t);\n    }\n  return t;\n}\nconst sX = [\"innerHTML\"], oX = /* @__PURE__ */ le({\n  __name: \"ScalarCodeBlock\",\n  props: {\n    content: {},\n    lang: { default: \"js\" },\n    lineNumbers: { type: Boolean, default: !1 },\n    hideCredentials: {}\n  },\n  setup(t) {\n    const e = t, n = AR(Lc(e.content)), r = `components-scalar-code-block${n}`, { plugins: i, highlightElement: s } = Ea;\n    e.hideCredentials && Ea.hooks.add(\"wrap\", function(d) {\n      if (!e.hideCredentials)\n        return;\n      let f = !1;\n      typeof e.hideCredentials == \"string\" ? d.content.includes(e.hideCredentials) && (f = !0) : Array.isArray(e.hideCredentials) && (f = e.hideCredentials.some(\n        (h) => d.content.includes(h)\n      )), f && (d.content = d.content.replace(\n        /<span class=\"credentials\">.*?<\\/span>/g,\n        (h) => h.replace(/<span class=\"credentials\">|<\\/span>/g, \"\")\n      ), d.content = d.content.replace(\n        new RegExp(\n          typeof e.hideCredentials == \"string\" ? e.hideCredentials : e.hideCredentials.join(\"|\"),\n          \"g\"\n        ),\n        (h) => `<span class=\"credentials\">${h}</span>`\n      ));\n    });\n    const o = G(null), a = G($w[r] ?? \"\"), l = j(() => e.lang === \"node\" ? \"js\" : e.lang), c = e.lang;\n    ht(\n      [() => e.lang, () => e.content, o],\n      () => {\n        o.value && e.content && (!a.value || e.lang !== c) && (a.value = \"\", Pn(() => s(o.value)));\n      },\n      { immediate: !0 }\n    );\n    const u = /\\n(?!$)/g;\n    return xd(async () => {\n      let d = \"\";\n      e.lineNumbers && Ea.hooks.add(\"after-tokenize\", (h) => {\n        const p = h.code.match(u), O = p ? p.length + 1 : 1;\n        d = `<span aria-hidden=\"true\" class=\"line-numbers-rows\">${new Array(O + 1).join(\"<span></span>\")}</span>`;\n      });\n      const f = Ea.highlight(\n        Lc(e.content),\n        Ea.languages[l.value],\n        l.value\n      );\n      if (a.value = f + d, n !== 0) {\n        const h = yO();\n        h.payload.data[r] = f + d;\n      }\n    }), et(async () => {\n      await __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_prism-autoloader-Dlh8Vzlw-BR-Zk3-5a0cc8\").then(__webpack_require__.bind(__webpack_require__, /*! ./prism-autoloader-Dlh8Vzlw-BR-Zk31i-C2nJnyDy.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/prism-autoloader-Dlh8Vzlw-BR-Zk31i-C2nJnyDy.js\")), i.autoloader.languages_path = \"https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/\";\n    }), (d, f) => (Z(), ne(\"pre\", {\n      class: Ke([\n        `scalar-component scalar-codeblock-pre language-${l.value}`,\n        {\n          \"line-numbers\": d.lineNumbers\n        }\n      ])\n    }, [\n      a.value ? (Z(), ne(\"code\", {\n        key: 0,\n        class: Ke(`scalar-codeblock-code language-${l.value}`),\n        innerHTML: R(Lc)(a.value)\n      }, null, 10, sX)) : (Z(), ne(\"code\", {\n        key: 1,\n        ref_key: \"el\",\n        ref: o,\n        class: Ke(`scalar-codeblock-code language-${l.value}`)\n      }, De(R(Lc)(d.content)), 3))\n    ], 2));\n  }\n}), X0 = /* @__PURE__ */ Object.assign({ \"./Add.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_Add-ngyZgYXx-DzyQwJvS-Dg6m4uBe_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./Add-ngyZgYXx-DzyQwJvS-Dg6m4uBe.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/Add-ngyZgYXx-DzyQwJvS-Dg6m4uBe.js\")), \"./ArrowLeft.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_ArrowLeft-aY17W2aS-DFSAtOMh-stY--31eff6\").then(__webpack_require__.bind(__webpack_require__, /*! ./ArrowLeft-aY17W2aS-DFSAtOMh-stY-2ROs.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/ArrowLeft-aY17W2aS-DFSAtOMh-stY-2ROs.js\")), \"./ArrowRight.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_ArrowRight-DEMtdoE7-D3Vz1S5q-BQd-9272b4\").then(__webpack_require__.bind(__webpack_require__, /*! ./ArrowRight-DEMtdoE7-D3Vz1S5q-BQdfZT8d.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/ArrowRight-DEMtdoE7-D3Vz1S5q-BQdfZT8d.js\")), \"./Background.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_Background-DcRhSHgf-DMULXelH-Bad-247414\").then(__webpack_require__.bind(__webpack_require__, /*! ./Background-DcRhSHgf-DMULXelH-BadxgX0W.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/Background-DcRhSHgf-DMULXelH-BadxgX0W.js\")), \"./Brackets.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_Brackets-4I8OKomf-BdIXlrTs-CWvEbqbD_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./Brackets-4I8OKomf-BdIXlrTs-CWvEbqbD.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/Brackets-4I8OKomf-BdIXlrTs-CWvEbqbD.js\")), \"./Branch.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_Branch-CXwj8YuG-IxKqRWkx-CXQBAf51_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./Branch-CXwj8YuG-IxKqRWkx-CXQBAf51.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/Branch-CXwj8YuG-IxKqRWkx-CXQBAf51.js\")), \"./CallToAction.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_CallToAction-EyQKkvbg-D5UsQ4YH-h-0e0ed3\").then(__webpack_require__.bind(__webpack_require__, /*! ./CallToAction-EyQKkvbg-D5UsQ4YH-haXAiOPT.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/CallToAction-EyQKkvbg-D5UsQ4YH-haXAiOPT.js\")), \"./Checkmark.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_Checkmark-De7nq6cG-CenVOav7-D9Bu-a32faf\").then(__webpack_require__.bind(__webpack_require__, /*! ./Checkmark-De7nq6cG-CenVOav7-D9Bu5fxd.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/Checkmark-De7nq6cG-CenVOav7-D9Bu5fxd.js\")), \"./ChevronDown.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_ChevronDown-Co7EAKAv-DHNwXUbS-CQ-55a8bd\").then(__webpack_require__.bind(__webpack_require__, /*! ./ChevronDown-Co7EAKAv-DHNwXUbS-CQlQw4WY.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/ChevronDown-Co7EAKAv-DHNwXUbS-CQlQw4WY.js\")), \"./ChevronLeft.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_ChevronLeft-DYt0idAu-DAzCtmws-tD-92efe4\").then(__webpack_require__.bind(__webpack_require__, /*! ./ChevronLeft-DYt0idAu-DAzCtmws-tDA-xdvZ.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/ChevronLeft-DYt0idAu-DAzCtmws-tDA-xdvZ.js\")), \"./ChevronRight.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_ChevronRight-ylxToVWl-CDFDuBE1-B-5d6636\").then(__webpack_require__.bind(__webpack_require__, /*! ./ChevronRight-ylxToVWl-CDFDuBE1-B0mYXf5d.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/ChevronRight-ylxToVWl-CDFDuBE1-B0mYXf5d.js\")), \"./ChevronUp.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_ChevronUp-xAnukIfj-CuKFLVD3-DWVS-513a86\").then(__webpack_require__.bind(__webpack_require__, /*! ./ChevronUp-xAnukIfj-CuKFLVD3-DWVSR3Ez.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/ChevronUp-xAnukIfj-CuKFLVD3-DWVSR3Ez.js\")), \"./Clipboard.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_Clipboard-CU_KxGEv-DWrQtWVi-BZDm-8b1f84\").then(__webpack_require__.bind(__webpack_require__, /*! ./Clipboard-CU_KxGEv-DWrQtWVi-BZDm5vfi.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/Clipboard-CU_KxGEv-DWrQtWVi-BZDm5vfi.js\")), \"./Close.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_Close-CW3z42qZ-CeX6s3FA-BJZZp11j_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./Close-CW3z42qZ-CeX6s3FA-BJZZp11j.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/Close-CW3z42qZ-CeX6s3FA-BJZZp11j.js\")), \"./CodeFolder.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_CodeFolder-Cv_igzJE-CoWfaY0Z-BoW-faa948\").then(__webpack_require__.bind(__webpack_require__, /*! ./CodeFolder-Cv_igzJE-CoWfaY0Z-BoWe0LHP.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/CodeFolder-Cv_igzJE-CoWfaY0Z-BoWe0LHP.js\")), \"./Cookie.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_Cookie-CEHvXpqB-D960ImBy-DVHF-7rf_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./Cookie-CEHvXpqB-D960ImBy-DVHF-7rf.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/Cookie-CEHvXpqB-D960ImBy-DVHF-7rf.js\")), \"./DarkMode.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_DarkMode-CBsV8Q_I-DHPfucpm-DyzfSyYR_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./DarkMode-CBsV8Q_I-DHPfucpm-DyzfSyYR.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/DarkMode-CBsV8Q_I-DHPfucpm-DyzfSyYR.js\")), \"./Delete.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_Delete-BCZmxrDD-BHoCf_u4-CZesZajO_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./Delete-BCZmxrDD-BHoCf_u4-CZesZajO.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/Delete-BCZmxrDD-BHoCf_u4-CZesZajO.js\")), \"./Discord.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_Discord-BHYOFBB2-NYBGYy-_-BgUYmbEK_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./Discord-BHYOFBB2-NYBGYy-_-BgUYmbEK.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/Discord-BHYOFBB2-NYBGYy-_-BgUYmbEK.js\")), \"./DocsPage.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_DocsPage-rh2xwxKN-BP1Vagfm-Dpj3kpsI_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./DocsPage-rh2xwxKN-BP1Vagfm-Dpj3kpsI.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/DocsPage-rh2xwxKN-BP1Vagfm-Dpj3kpsI.js\")), \"./Duplicate.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_Duplicate-BPlzNpcf-DbmFK0XC-Bp1A-198470\").then(__webpack_require__.bind(__webpack_require__, /*! ./Duplicate-BPlzNpcf-DbmFK0XC-Bp1AbZYR.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/Duplicate-BPlzNpcf-DbmFK0XC-Bp1AbZYR.js\")), \"./Edit.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_Edit-Br04RNYb-BhCyac4t-DXlzqBnQ_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./Edit-Br04RNYb-BhCyac4t-DXlzqBnQ.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/Edit-Br04RNYb-BhCyac4t-DXlzqBnQ.js\")), \"./Ellipses.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_Ellipses-Bo_X36Hx-CsJmKvlE-oSCkNmOf_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./Ellipses-Bo_X36Hx-CsJmKvlE-oSCkNmOf.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/Ellipses-Bo_X36Hx-CsJmKvlE-oSCkNmOf.js\")), \"./Error.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_Error-B_RGtWJI-D9KV-EvG-at1B0s_M_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./Error-B_RGtWJI-D9KV-EvG-at1B0s_M.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/Error-B_RGtWJI-D9KV-EvG-at1B0s_M.js\")), \"./ExternalLink.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_ExternalLink-DK8L-EH7-ANJEzoHO-C-1ddad8\").then(__webpack_require__.bind(__webpack_require__, /*! ./ExternalLink-DK8L-EH7-ANJEzoHO-CY0vPfof.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/ExternalLink-DK8L-EH7-ANJEzoHO-CY0vPfof.js\")), \"./FilterList.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_FilterList-CsAcE9em-aybThY1V-BK3-5b94f6\").then(__webpack_require__.bind(__webpack_require__, /*! ./FilterList-CsAcE9em-aybThY1V-BK3-DHse.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/FilterList-CsAcE9em-aybThY1V-BK3-DHse.js\")), \"./Folder.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_Folder-Cdcj4evh-B-g7TtzK-YjWkUkgE_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./Folder-Cdcj4evh-B-g7TtzK-YjWkUkgE.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/Folder-Cdcj4evh-B-g7TtzK-YjWkUkgE.js\")), \"./GitHub.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_GitHub-NdE6Zs9k-BAGzgXH_-DTEyWCw8_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./GitHub-NdE6Zs9k-BAGzgXH_-DTEyWCw8.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/GitHub-NdE6Zs9k-BAGzgXH_-DTEyWCw8.js\")), \"./Hide.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_Hide-Q3GPkIKH-40aIsLtN-DnMvHBax_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./Hide-Q3GPkIKH-40aIsLtN-DnMvHBax.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/Hide-Q3GPkIKH-40aIsLtN-DnMvHBax.js\")), \"./History.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_History-D9nmhNIn-BU9mR55a-CbY6899A_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./History-D9nmhNIn-BU9mR55a-CbY6899A.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/History-D9nmhNIn-BU9mR55a-CbY6899A.js\")), \"./JsonObject.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_JsonObject-hGdHUQ4M-Cm1hXgAn-eNa-1aa7f2\").then(__webpack_require__.bind(__webpack_require__, /*! ./JsonObject-hGdHUQ4M-Cm1hXgAn-eNaco2Er.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/JsonObject-hGdHUQ4M-Cm1hXgAn-eNaco2Er.js\")), \"./Key.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_Key-CWXJqX28-DdNUhB11-D43hFYBY_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./Key-CWXJqX28-DdNUhB11-D43hFYBY.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/Key-CWXJqX28-DdNUhB11-D43hFYBY.js\")), \"./Leave.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_Leave-K1J3uwoG-WgTmlwgs-B1G7AUx7_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./Leave-K1J3uwoG-WgTmlwgs-B1G7AUx7.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/Leave-K1J3uwoG-WgTmlwgs-B1G7AUx7.js\")), \"./LightDarkModeToggle.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_LightDarkModeToggle-BkvMimDa-Dk6-c3ab05\").then(__webpack_require__.bind(__webpack_require__, /*! ./LightDarkModeToggle-BkvMimDa-Dk64Z-UE-Did1cpzH.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/LightDarkModeToggle-BkvMimDa-Dk64Z-UE-Did1cpzH.js\")), \"./LightMode.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_LightMode-Btz6vyT_-JpKLPzdT-CYBS-2b1f21\").then(__webpack_require__.bind(__webpack_require__, /*! ./LightMode-Btz6vyT_-JpKLPzdT-CYBSGo5W.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/LightMode-Btz6vyT_-JpKLPzdT-CYBSGo5W.js\")), \"./Link.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_Link-Bzuc__Nc-Bvtx0HZG-BsxoTRLF_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./Link-Bzuc__Nc-Bvtx0HZG-BsxoTRLF.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/Link-Bzuc__Nc-Bvtx0HZG-BsxoTRLF.js\")), \"./Lock.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_Lock-xhiH1mKz-Rrlr3fGv-CHHWJxm8_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./Lock-xhiH1mKz-Rrlr3fGv-CHHWJxm8.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/Lock-xhiH1mKz-Rrlr3fGv-CHHWJxm8.js\")), \"./Logo.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_Logo-mtzeKD8M-LQcor9RM-DUH9106q_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./Logo-mtzeKD8M-LQcor9RM-DUH9106q.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/Logo-mtzeKD8M-LQcor9RM-DUH9106q.js\")), \"./LogoAPI.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_LogoAPI-CaU5E6FK-Bzb5EbnZ-BCO3e5BR_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./LogoAPI-CaU5E6FK-Bzb5EbnZ-BCO3e5BR.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/LogoAPI-CaU5E6FK-Bzb5EbnZ-BCO3e5BR.js\")), \"./LogoClient.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_LogoClient-DdC-t_7P-B_rZ91PC-eaZ-f1be67\").then(__webpack_require__.bind(__webpack_require__, /*! ./LogoClient-DdC-t_7P-B_rZ91PC-eaZ6WmOf.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/LogoClient-DdC-t_7P-B_rZ91PC-eaZ6WmOf.js\")), \"./LogoMarket.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_LogoMarket-DwlApcab-_INRDSLs-Cu9-75d49a\").then(__webpack_require__.bind(__webpack_require__, /*! ./LogoMarket-DwlApcab-_INRDSLs-Cu92Ek1V.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/LogoMarket-DwlApcab-_INRDSLs-Cu92Ek1V.js\")), \"./LogoSwagger.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_LogoSwagger-CH60H5qW-DFEpFXIU-CR-3372fd\").then(__webpack_require__.bind(__webpack_require__, /*! ./LogoSwagger-CH60H5qW-DFEpFXIU-CRLIWk3k.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/LogoSwagger-CH60H5qW-DFEpFXIU-CRLIWk3k.js\")), \"./Magic.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_Magic-Dsi9_bEc-BYN42_eH-DJ7jvqlp_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./Magic-Dsi9_bEc-BYN42_eH-DJ7jvqlp.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/Magic-Dsi9_bEc-BYN42_eH-DJ7jvqlp.js\")), \"./Menu.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_Menu-CFK5cOsm-CqE9Tsgr-DMt-L6ON_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./Menu-CFK5cOsm-CqE9Tsgr-DMt-L6ON.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/Menu-CFK5cOsm-CqE9Tsgr-DMt-L6ON.js\")), \"./Page.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_Page-B7rVuhpl-BUIogUij-BB671Km1_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./Page-B7rVuhpl-BUIogUij-BB671Km1.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/Page-B7rVuhpl-BUIogUij-BB671Km1.js\")), \"./PaperAirplane.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_PaperAirplane-BC-4mGEB-BrV5fX8s--868db8\").then(__webpack_require__.bind(__webpack_require__, /*! ./PaperAirplane-BC-4mGEB-BrV5fX8s-gFDG4LcF.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/PaperAirplane-BC-4mGEB-BrV5fX8s-gFDG4LcF.js\")), \"./Payment.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_Payment-hzcXP1Xb-B2G1p4-i-DqyNxSKF_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./Payment-hzcXP1Xb-B2G1p4-i-DqyNxSKF.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/Payment-hzcXP1Xb-B2G1p4-i-DqyNxSKF.js\")), \"./Play.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_Play-BrVagRQA-DBrajcXb-Bdk-5U3i_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./Play-BrVagRQA-DBrajcXb-Bdk-5U3i.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/Play-BrVagRQA-DBrajcXb-Bdk-5U3i.js\")), \"./Refresh.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_Refresh-Be6vHEEi-C6lRqFiM-C73Hcs1e_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./Refresh-Be6vHEEi-C6lRqFiM-C73Hcs1e.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/Refresh-Be6vHEEi-C6lRqFiM-C73Hcs1e.js\")), \"./Response.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_Response-Dq9pM-ZU-DcYb8u84-D9VGLZcz_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./Response-Dq9pM-ZU-DcYb8u84-D9VGLZcz.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/Response-Dq9pM-ZU-DcYb8u84-D9VGLZcz.js\")), \"./Search.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_Search-DqtlswRG-D-hprEk0-CI4GoK9h_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./Search-DqtlswRG-D-hprEk0-CI4GoK9h.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/Search-DqtlswRG-D-hprEk0-CI4GoK9h.js\")), \"./Show.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_Show-D86hKz5y-CF9Pv7FS-Cdyd48_g_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./Show-D86hKz5y-CF9Pv7FS-Cdyd48_g.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/Show-D86hKz5y-CF9Pv7FS-Cdyd48_g.js\")), \"./SideBarClosed.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_SideBarClosed-CYUNS2XM-CyAn6Mp2--b8fac5\").then(__webpack_require__.bind(__webpack_require__, /*! ./SideBarClosed-CYUNS2XM-CyAn6Mp2-Cqf4vais.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/SideBarClosed-CYUNS2XM-CyAn6Mp2-Cqf4vais.js\")), \"./SideBarOpen.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_SideBarOpen-BOxW49_U-D5IKtkfP-CZ-71dbe1\").then(__webpack_require__.bind(__webpack_require__, /*! ./SideBarOpen-BOxW49_U-D5IKtkfP-CZzPiP8r.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/SideBarOpen-BOxW49_U-D5IKtkfP-CZzPiP8r.js\")), \"./Sort.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_Sort-oTjBhJFQ-yW_ZNUnN-wz3cyKgT_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./Sort-oTjBhJFQ-yW_ZNUnN-wz3cyKgT.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/Sort-oTjBhJFQ-yW_ZNUnN-wz3cyKgT.js\")), \"./Terminal.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_Terminal-CKp--su5-vWaGU4_z-DAMBesXv_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./Terminal-CKp--su5-vWaGU4_z-DAMBesXv.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/Terminal-CKp--su5-vWaGU4_z-DAMBesXv.js\")), \"./ThumbsDown.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_ThumbsDown-BMgnsASL-B2YFxB8i-DAM-96e599\").then(__webpack_require__.bind(__webpack_require__, /*! ./ThumbsDown-BMgnsASL-B2YFxB8i-DAMNXbYe.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/ThumbsDown-BMgnsASL-B2YFxB8i-DAMNXbYe.js\")), \"./ThumbsUp.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_ThumbsUp-C1j6zY2j-DKqh3z1D-B2U8zRVy_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./ThumbsUp-C1j6zY2j-DKqh3z1D-B2U8zRVy.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/ThumbsUp-C1j6zY2j-DKqh3z1D-B2U8zRVy.js\")), \"./Trash.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_Trash-BpA3zWPD-BAjuQdys-52CVss0x_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./Trash-BpA3zWPD-BAjuQdys-52CVss0x.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/Trash-BpA3zWPD-BAjuQdys-52CVss0x.js\")), \"./Unlock.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_Unlock-CY8UqJoE-CrwInjK9-CY8TLnAu_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./Unlock-CY8UqJoE-CrwInjK9-CY8TLnAu.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/Unlock-CY8UqJoE-CrwInjK9-CY8TLnAu.js\")), \"./Upload.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_Upload-REIdL7RI-CsfWPmbV-f02ZddMX_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./Upload-REIdL7RI-CsfWPmbV-f02ZddMX.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/Upload-REIdL7RI-CsfWPmbV-f02ZddMX.js\")), \"./User.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_User-Df5svMQ3-BD7IWPQQ-BkNE0D2v_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./User-Df5svMQ3-BD7IWPQQ-BkNE0D2v.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/User-Df5svMQ3-BD7IWPQQ-BkNE0D2v.js\")), \"./programming-framework-angular.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_programming-framework-angular-DD-5ec3d6\").then(__webpack_require__.bind(__webpack_require__, /*! ./programming-framework-angular-DD4Vjgbk-Bzc9D9am-BfucK3vS.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/programming-framework-angular-DD4Vjgbk-Bzc9D9am-BfucK3vS.js\")), \"./programming-framework-astro.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_programming-framework-astro-CLfr-d57967\").then(__webpack_require__.bind(__webpack_require__, /*! ./programming-framework-astro-CLfrRt19-CfPlyy6T-BU0bW3NV.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/programming-framework-astro-CLfrRt19-CfPlyy6T-BU0bW3NV.js\")), \"./programming-framework-laravel.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_programming-framework-laravel-kA-3d228b\").then(__webpack_require__.bind(__webpack_require__, /*! ./programming-framework-laravel-kAy2wVLy-Cty_4oXq-6X0nmwVS.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/programming-framework-laravel-kAy2wVLy-Cty_4oXq-6X0nmwVS.js\")), \"./programming-framework-nextdotjs.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_programming-framework-nextdotjs--7d7d0c\").then(__webpack_require__.bind(__webpack_require__, /*! ./programming-framework-nextdotjs-BKdd_DY_-DUTv-t1Q-CAy_JLEW.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/programming-framework-nextdotjs-BKdd_DY_-DUTv-t1Q-CAy_JLEW.js\")), \"./programming-framework-react.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_programming-framework-react-PDgm-d29556\").then(__webpack_require__.bind(__webpack_require__, /*! ./programming-framework-react-PDgmtZuN-DdUogL85-ByXgrJSG.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/programming-framework-react-PDgmtZuN-DdUogL85-ByXgrJSG.js\")), \"./programming-framework-vuedotjs.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_programming-framework-vuedotjs-C-41950b\").then(__webpack_require__.bind(__webpack_require__, /*! ./programming-framework-vuedotjs-Cv46W2aB-Dt_I9pcj-D6Gfv_pK.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/programming-framework-vuedotjs-Cv46W2aB-Dt_I9pcj-D6Gfv_pK.js\")), \"./programming-language-c.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_programming-language-c-hPGu2Zvg--5ea200\").then(__webpack_require__.bind(__webpack_require__, /*! ./programming-language-c-hPGu2Zvg-QG1pSdJG-DTfK1BNb.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/programming-language-c-hPGu2Zvg-QG1pSdJG-DTfK1BNb.js\")), \"./programming-language-clojure.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_programming-language-clojure-Cvm-bd7923\").then(__webpack_require__.bind(__webpack_require__, /*! ./programming-language-clojure-Cvmzky8x-D6Gs-6Ol-utvq4WVq.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/programming-language-clojure-Cvmzky8x-D6Gs-6Ol-utvq4WVq.js\")), \"./programming-language-csharp.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_programming-language-csharp-lqX1-9c5822\").then(__webpack_require__.bind(__webpack_require__, /*! ./programming-language-csharp-lqX1oWgb-B1_8fYG9-PBpXEXzJ.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/programming-language-csharp-lqX1oWgb-B1_8fYG9-PBpXEXzJ.js\")), \"./programming-language-css3.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_programming-language-css3-Dpp4Cr-826f01\").then(__webpack_require__.bind(__webpack_require__, /*! ./programming-language-css3-Dpp4Cr6b-Bf5XF7-p-DVlPBQze.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/programming-language-css3-Dpp4Cr6b-Bf5XF7-p-DVlPBQze.js\")), \"./programming-language-go.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_programming-language-go-DoJxWwT6-45fadc\").then(__webpack_require__.bind(__webpack_require__, /*! ./programming-language-go-DoJxWwT6-BUgfSlg1-CRIlBxOd.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/programming-language-go-DoJxWwT6-BUgfSlg1-CRIlBxOd.js\")), \"./programming-language-html5.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_programming-language-html5-DlqJK-c4b8bd\").then(__webpack_require__.bind(__webpack_require__, /*! ./programming-language-html5-DlqJK4EL-Bl9dTA-D-Bm2S1Mxu.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/programming-language-html5-DlqJK4EL-Bl9dTA-D-Bm2S1Mxu.js\")), \"./programming-language-http.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_programming-language-http-wMYwFS-7620e0\").then(__webpack_require__.bind(__webpack_require__, /*! ./programming-language-http-wMYwFS1I-BWQXI44M-iHjdjQXg.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/programming-language-http-wMYwFS1I-BWQXI44M-iHjdjQXg.js\")), \"./programming-language-java.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_programming-language-java-BCxG2T-9eaa53\").then(__webpack_require__.bind(__webpack_require__, /*! ./programming-language-java-BCxG2T_w-CWqBHVz_-CJEKWrCU.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/programming-language-java-BCxG2T_w-CWqBHVz_-CJEKWrCU.js\")), \"./programming-language-javascript.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_programming-language-javascript--f29377\").then(__webpack_require__.bind(__webpack_require__, /*! ./programming-language-javascript-VxLvi1QG-DFjYF_MP-C1wMy3zE.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/programming-language-javascript-VxLvi1QG-DFjYF_MP-C1wMy3zE.js\")), \"./programming-language-json.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_programming-language-json-vEX_g7-81192d\").then(__webpack_require__.bind(__webpack_require__, /*! ./programming-language-json-vEX_g7Zi-BMZrSR1t-cb3fP4sM.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/programming-language-json-vEX_g7Zi-BMZrSR1t-cb3fP4sM.js\")), \"./programming-language-kotlin.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_programming-language-kotlin-DKV8-255b1a\").then(__webpack_require__.bind(__webpack_require__, /*! ./programming-language-kotlin-DKV8vP9h-C1Zi89NZ-BYHnI6tu.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/programming-language-kotlin-DKV8vP9h-C1Zi89NZ-BYHnI6tu.js\")), \"./programming-language-node.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_programming-language-node-Xsgx38-6184c2\").then(__webpack_require__.bind(__webpack_require__, /*! ./programming-language-node-Xsgx38lm-DZhaOPIJ-Djs6vRkK.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/programming-language-node-Xsgx38lm-DZhaOPIJ-Djs6vRkK.js\")), \"./programming-language-objc.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_programming-language-objc-BQXSOB-e8754d\").then(__webpack_require__.bind(__webpack_require__, /*! ./programming-language-objc-BQXSOBsX-BR-B91By-BYHsOgZu.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/programming-language-objc-BQXSOBsX-BR-B91By-BYHsOgZu.js\")), \"./programming-language-ocaml.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_programming-language-ocaml-BEz7g-399e53\").then(__webpack_require__.bind(__webpack_require__, /*! ./programming-language-ocaml-BEz7gGv7-ip3_Zuhb-DiPRv8mq.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/programming-language-ocaml-BEz7gGv7-ip3_Zuhb-DiPRv8mq.js\")), \"./programming-language-php.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_programming-language-php-GY38f8r-018ab6\").then(__webpack_require__.bind(__webpack_require__, /*! ./programming-language-php-GY38f8r4-DQ_8EMFH-DTwDEWc2.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/programming-language-php-GY38f8r4-DQ_8EMFH-DTwDEWc2.js\")), \"./programming-language-powershell.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_programming-language-powershell--ea1142\").then(__webpack_require__.bind(__webpack_require__, /*! ./programming-language-powershell-C9DkSp36-S3xix_dw-Cc-MMQ5C.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/programming-language-powershell-C9DkSp36-S3xix_dw-Cc-MMQ5C.js\")), \"./programming-language-python.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_programming-language-python-Ct-_-82d9d1\").then(__webpack_require__.bind(__webpack_require__, /*! ./programming-language-python-Ct-_kNjo-BCrlyfv0-BNyrCiVV.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/programming-language-python-Ct-_kNjo-BCrlyfv0-BNyrCiVV.js\")), \"./programming-language-r.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_programming-language-r-BGoKwua9--cf886b\").then(__webpack_require__.bind(__webpack_require__, /*! ./programming-language-r-BGoKwua9-BWGOKD9M-CULKUPDn.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/programming-language-r-BGoKwua9-BWGOKD9M-CULKUPDn.js\")), \"./programming-language-ruby.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_programming-language-ruby-DhdM4d-71fcf3\").then(__webpack_require__.bind(__webpack_require__, /*! ./programming-language-ruby-DhdM4d7g-Dd3La6Kn-DZ9-eGad.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/programming-language-ruby-DhdM4d7g-Dd3La6Kn-DZ9-eGad.js\")), \"./programming-language-scala.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_programming-language-scala-BVg0d-f497ff\").then(__webpack_require__.bind(__webpack_require__, /*! ./programming-language-scala-BVg0dToJ-Bz_n-CNw-DGqXnT_Z.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/programming-language-scala-BVg0dToJ-Bz_n-CNw-DGqXnT_Z.js\")), \"./programming-language-shell.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_programming-language-shell-BsTa1-ea3cc2\").then(__webpack_require__.bind(__webpack_require__, /*! ./programming-language-shell-BsTa1xI7-XJbYjh7O-DbTJPwRl.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/programming-language-shell-BsTa1xI7-XJbYjh7O-DbTJPwRl.js\")), \"./programming-language-swift.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_programming-language-swift-Dn72x-93a53c\").then(__webpack_require__.bind(__webpack_require__, /*! ./programming-language-swift-Dn72xPjg-BUvu5_SV-Bb-nGdda.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/programming-language-swift-Dn72xPjg-BUvu5_SV-Bb-nGdda.js\")), \"./programming-language-typescript.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_programming-language-typescript--616bf6\").then(__webpack_require__.bind(__webpack_require__, /*! ./programming-language-typescript-CdF-HuRi-CaDO02MW-BBuO0KlG.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/programming-language-typescript-CdF-HuRi-CaDO02MW-BBuO0KlG.js\")), \"./programming-script-code.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_programming-script-code-DQN1veb2-cf9b51\").then(__webpack_require__.bind(__webpack_require__, /*! ./programming-script-code-DQN1veb2-BPFALXVk-BqO-0d_V.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/programming-script-code-DQN1veb2-BPFALXVk-BqO-0d_V.js\")), \"./programming-tool-git.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_programming-tool-git-DDnQ1zGD-Cz-68e011\").then(__webpack_require__.bind(__webpack_require__, /*! ./programming-tool-git-DDnQ1zGD-Cz6Yj0wj-DqovFqOq.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/programming-tool-git-DDnQ1zGD-Cz6Yj0wj-DqovFqOq.js\")), \"./programming-tool-tailwindcss.svg\": () => __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_scalar_api-client-react_dist_programming-tool-tailwindcss-xjX-a2f87b\").then(__webpack_require__.bind(__webpack_require__, /*! ./programming-tool-tailwindcss-xjXi0E6g-ky2wbsII-DZfSzBnh.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/programming-tool-tailwindcss-xjXi0E6g-ky2wbsII-DZfSzBnh.js\")) }), j0 = (t) => {\n  const e = `./${t}.svg`;\n  return X0[e] ? /* @__PURE__ */ a1(X0[e]) : (console.warn(`Could not find icon: ${t}`), null);\n}, aX = [\"src\"], _l = /* @__PURE__ */ le({\n  __name: \"ScalarIcon\",\n  props: {\n    icon: {},\n    size: {}\n  },\n  setup(t) {\n    const e = t, n = $g({\n      variants: {\n        size: {\n          xs: \"size-3 stroke-[1.4]\",\n          sm: \"size-3.5 stroke-[1.2]\",\n          md: \"size-4 stroke-[1.1]\",\n          lg: \"size-5\",\n          xl: \"size-6 stroke-[0.96]\",\n          \"2xl\": \"size-8 stroke-[0.92]\",\n          \"3xl\": \"size-10 stroke-[0.9]\",\n          full: \"size-full\"\n        }\n      },\n      defaultVariants: {\n        size: \"full\"\n      }\n    }), r = j0(e.icon);\n    return (i, s) => R(r) ? (Z(), ke(Zl(R(j0)(i.icon)), {\n      key: 0,\n      class: Ke(R(Gd)(\"scalar-icon\", R(n)({ size: i.size })))\n    }, null, 8, [\"class\"])) : (Z(), ne(\"img\", {\n      key: 1,\n      src: i.icon\n    }, null, 8, aX));\n  }\n}), lX = [\"ariaDisabled\"], cX = { class: \"sr-only\" }, uX = /* @__PURE__ */ le({\n  __name: \"ScalarIconButton\",\n  props: {\n    label: {},\n    icon: {},\n    disabled: { type: Boolean },\n    variant: { default: \"ghost\" },\n    size: { default: \"md\" }\n  },\n  setup(t) {\n    const e = $g({\n      base: \"scalar-icon-button grid aspect-square cursor-pointer rounded\",\n      variants: {\n        size: {\n          xs: \"size-3.5 p-0.5\",\n          sm: \"size-6 p-1\",\n          md: \"size-10 p-3\",\n          full: \"h-full w-full\"\n        },\n        disabled: {\n          true: \"cursor-not-allowed shadow-none\"\n        },\n        variant: AP\n      }\n    }), n = j(() => {\n      const { class: r, ...i } = xO();\n      return { class: r || \"\", rest: i };\n    });\n    return (r, i) => (Z(), ne(\"button\", Ml(n.value.rest, {\n      ariaDisabled: r.disabled || void 0,\n      class: R(Gd)(R(e)({ size: r.size, variant: r.variant, disabled: r.disabled }), n.value.class),\n      type: \"button\"\n    }), [\n      J(R(_l), { icon: r.icon }, null, 8, [\"icon\"]),\n      D(\"span\", cX, De(r.label), 1)\n    ], 16, lX));\n  }\n}), dX = { class: \"card-form-input\" }, fX = [\"for\"], hX = [\"id\", \"type\"], pX = /* @__PURE__ */ le({\n  inheritAttrs: !1,\n  __name: \"CardFormTextInput\",\n  props: {\n    id: {},\n    type: {}\n  },\n  setup(t) {\n    const e = t, n = G(!0), r = j(\n      () => e.type === \"password\" ? n.value ? \"password\" : \"text\" : e.type ?? \"text\"\n    );\n    return (i, s) => (Z(), ne(\"div\", dX, [\n      D(\"label\", { for: i.id }, [\n        pt(i.$slots, \"default\", {}, void 0, !0)\n      ], 8, fX),\n      D(\"input\", Ml(i.$attrs, {\n        id: i.id,\n        autocomplete: \"off\",\n        \"data-1p-ignore\": \"\",\n        spellcheck: \"false\",\n        type: r.value\n      }), null, 16, hX),\n      i.type === \"password\" ? (Z(), ke(R(uX), {\n        key: 0,\n        class: \"password-mask\",\n        icon: n.value ? \"Show\" : \"Hide\",\n        label: n.value ? \"Show Password\" : \"Hide Password\",\n        onClick: s[0] || (s[0] = (o) => n.value = !n.value)\n      }, null, 8, [\"icon\", \"label\"])) : st(\"\", !0)\n    ]));\n  }\n}), lo = /* @__PURE__ */ ct(pX, [[\"__scopeId\", \"data-v-b36c2dca\"]]), OX = (t) => (Ks(\"data-v-2c0182f1\"), t = t(), Js(), t), gX = { class: \"scopes-label\" }, mX = /* @__PURE__ */ OX(() => /* @__PURE__ */ D(\"em\", null, \"/\", -1)), bX = [\"checked\"], vX = { class: \"dropdown-item-title\" }, yX = { class: \"dropdown-item-description\" }, SX = /* @__PURE__ */ le({\n  __name: \"SecuritySchemeScopes\",\n  props: {\n    scopes: {},\n    selected: {}\n  },\n  emits: [\"update:selected\"],\n  setup(t, { emit: e }) {\n    const n = t, r = e, i = G(), s = G(), { floatingStyles: o } = eR(i, s, {\n      placement: \"bottom-end\",\n      whileElementsMounted: H2,\n      middleware: [$2(5), G2(), F2()]\n    }), a = j({\n      get: () => n.selected,\n      set: (l) => r(\"update:selected\", l)\n    });\n    return (l, c) => (Z(), ke(R(EC), {\n      modelValue: a.value,\n      \"onUpdate:modelValue\": c[0] || (c[0] = (u) => a.value = u),\n      multiple: \"\"\n    }, {\n      default: ce(({ open: u }) => [\n        D(\"div\", {\n          ref_key: \"trigger\",\n          ref: i,\n          class: Ke([\"wrapper\", { \"wrapper-open\": u }])\n        }, [\n          J(R($C), { as: xP }, {\n            default: ce(() => [\n              D(\"div\", gX, [\n                He(\" Scopes \" + De(a.value.length), 1),\n                mX,\n                He(De(Object.entries(l.scopes).length) + \" \", 1),\n                J(R(_l), {\n                  icon: u ? \"ChevronUp\" : \"ChevronDown\",\n                  size: \"sm\"\n                }, null, 8, [\"icon\"])\n              ])\n            ]),\n            _: 2\n          }, 1024)\n        ], 2),\n        (Z(), ke(TO, { to: \"body\" }, [\n          J(R(ER), null, {\n            default: ce(({ styles: d }) => [\n              D(\"div\", {\n                ref_key: \"dropdown\",\n                ref: s,\n                class: Ke([\"floating\", d]),\n                style: Br(R(o))\n              }, [\n                J(R(QC), {\n                  as: \"dl\",\n                  class: \"dropdown\"\n                }, {\n                  default: ce(() => [\n                    (Z(!0), ne(Pe, null, Xr(Object.entries(l.scopes), ([f, h]) => (Z(), ke(R(CC), {\n                      key: f,\n                      as: \"div\",\n                      class: \"dropdown-item\",\n                      value: f\n                    }, {\n                      default: ce(({ selected: p }) => [\n                        D(\"input\", {\n                          checked: p,\n                          class: \"dropdown-item-check\",\n                          tabindex: \"-1\",\n                          type: \"checkbox\"\n                        }, null, 8, bX),\n                        D(\"dt\", vX, De(f), 1),\n                        D(\"dd\", yX, De(h), 1)\n                      ]),\n                      _: 2\n                    }, 1032, [\"value\"]))), 128))\n                  ]),\n                  _: 1\n                })\n              ], 6)\n            ]),\n            _: 1\n          })\n        ]))\n      ]),\n      _: 1\n    }, 8, [\"modelValue\"]));\n  }\n}), wX = /* @__PURE__ */ ct(SX, [[\"__scopeId\", \"data-v-2c0182f1\"]]), kX = /* @__PURE__ */ le({\n  __name: \"SecurityScheme\",\n  props: {\n    value: {}\n  },\n  setup(t) {\n    const { authentication: e, setAuthentication: n } = Yl(), r = (d) => {\n      n({\n        apiKey: {\n          ...e.apiKey,\n          token: d.target.value\n        }\n      });\n    }, i = (d) => {\n      n({\n        http: {\n          ...e.http,\n          basic: {\n            ...e.http.basic,\n            username: d.target.value\n          }\n        }\n      });\n    }, s = (d) => {\n      n({\n        http: {\n          ...e.http,\n          basic: {\n            ...e.http.basic,\n            password: d.target.value\n          }\n        }\n      });\n    }, o = (d) => {\n      n({\n        http: {\n          ...e.http,\n          bearer: {\n            ...e.http.bearer,\n            token: d.target.value\n          }\n        }\n      });\n    }, a = (d) => {\n      n({\n        oAuth2: {\n          ...e.oAuth2,\n          clientId: d.target.value\n        }\n      });\n    }, l = (d) => {\n      const f = e.oAuth2.scopes.join(\" \"), h = (Math.random() + 1).toString(36).substring(7), p = new URL(d.authorizationUrl);\n      return n({\n        oAuth2: { ...e.oAuth2, state: h }\n      }), p.searchParams.set(\"response_type\", \"token\"), p.searchParams.set(\"client_id\", e.oAuth2.clientId), p.searchParams.set(\"redirect_uri\", window.location.href), p.searchParams.set(\"scope\", f), p.searchParams.set(\"state\", h), p.toString();\n    }, c = j({\n      get: () => e.oAuth2.scopes,\n      set: (d) => n({ oAuth2: { ...e.oAuth2, scopes: d } })\n    }), u = (d) => {\n      const h = window.open(d, \"openAuth2Window\", \"left=100,top=100,width=800,height=600\");\n      if (h) {\n        const p = setInterval(function() {\n          var O;\n          try {\n            const y = new URLSearchParams(h.location.href).get(\"access_token\");\n            if (h.closed || y) {\n              clearInterval(p);\n              const b = (O = h.location.href.match(/state=([^&]*)/)) == null ? void 0 : O[1];\n              y && e.oAuth2.state === b && n({\n                oAuth2: { ...e.oAuth2, accessToken: y }\n              }), h.close();\n            }\n          } catch {\n          }\n        }, 200);\n      }\n    };\n    return (d, f) => {\n      var h;\n      return d.value && ((h = d.value) != null && h.type) ? (Z(), ke(oM, { key: 0 }, {\n        default: ce(() => [\n          d.value.type === \"apiKey\" ? (Z(), ke(lo, {\n            key: 0,\n            id: `security-scheme-${d.value.name}`,\n            placeholder: \"Token\",\n            type: \"password\",\n            value: R(e).apiKey.token,\n            onInput: r\n          }, {\n            default: ce(() => [\n              He(De(d.value.in.charAt(0).toUpperCase() + d.value.in.slice(1)) + \" API \", 1)\n            ]),\n            _: 1\n          }, 8, [\"id\", \"value\"])) : d.value.type === \"http\" || d.value.type === \"basic\" ? (Z(), ne(Pe, { key: 1 }, [\n            d.value.type === \"basic\" || d.value.scheme === \"basic\" ? (Z(), ke(N0, { key: 0 }, {\n              default: ce(() => [\n                J(lo, {\n                  id: \"http.basic.username\",\n                  placeholder: \"Username\",\n                  value: R(e).http.basic.username,\n                  onInput: i\n                }, {\n                  default: ce(() => [\n                    He(\" Username \")\n                  ]),\n                  _: 1\n                }, 8, [\"value\"]),\n                J(lo, {\n                  id: \"http.basic.password\",\n                  placeholder: \"Password\",\n                  type: \"password\",\n                  value: R(e).http.basic.password,\n                  onInput: s\n                }, {\n                  default: ce(() => [\n                    He(\" Password \")\n                  ]),\n                  _: 1\n                }, 8, [\"value\"])\n              ]),\n              _: 1\n            })) : d.value.type === \"http\" && d.value.scheme === \"bearer\" ? (Z(), ke(lo, {\n              key: 1,\n              id: \"http.bearer.token\",\n              placeholder: \"Token\",\n              type: \"password\",\n              value: R(e).http.bearer.token,\n              onInput: o\n            }, {\n              default: ce(() => [\n                He(\" Bearer Token \")\n              ]),\n              _: 1\n            }, 8, [\"value\"])) : st(\"\", !0)\n          ], 64)) : d.value.type.toLowerCase() === \"oauth2\" && d.value.flows && d.value.flows.implicit ? (Z(), ke(N0, { key: 2 }, {\n            default: ce(() => [\n              R(e).oAuth2.accessToken ? (Z(), ne(Pe, { key: 0 }, [\n                J(lo, {\n                  id: \"oAuth2.accessToken\",\n                  placeholder: \"xxxxx\",\n                  type: \"password\",\n                  value: R(e).oAuth2.accessToken\n                }, {\n                  default: ce(() => [\n                    He(\" Access Token \")\n                  ]),\n                  _: 1\n                }, 8, [\"value\"]),\n                J(xP, {\n                  onClick: f[0] || (f[0] = () => R(n)({\n                    oAuth2: {\n                      ...R(e).oAuth2,\n                      accessToken: \"\",\n                      state: \"\"\n                    }\n                  }))\n                }, {\n                  default: ce(() => [\n                    He(\" Reset \")\n                  ]),\n                  _: 1\n                })\n              ], 64)) : (Z(), ne(Pe, { key: 1 }, [\n                J(lo, {\n                  id: \"oAuth2.clientId\",\n                  placeholder: \"12345\",\n                  type: \"text\",\n                  value: R(e).oAuth2.clientId,\n                  onInput: a\n                }, {\n                  default: ce(() => [\n                    He(\" Client ID \")\n                  ]),\n                  _: 1\n                }, 8, [\"value\"]),\n                d.value !== void 0 ? (Z(), ke(wX, {\n                  key: 0,\n                  selected: c.value,\n                  \"onUpdate:selected\": f[1] || (f[1] = (p) => c.value = p),\n                  scopes: d.value.flows.implicit.scopes\n                }, null, 8, [\"selected\", \"scopes\"])) : st(\"\", !0),\n                D(\"button\", {\n                  class: \"cardform-auth-button\",\n                  onClick: f[2] || (f[2] = () => {\n                    var p;\n                    return u(\n                      l(\n                        //@ts-ignore\n                        (p = d.value) == null ? void 0 : p.flows.implicit\n                      )\n                    );\n                  })\n                }, \" Authorize \")\n              ], 64))\n            ]),\n            _: 1\n          })) : st(\"\", !0)\n        ]),\n        _: 1\n      })) : st(\"\", !0);\n    };\n  }\n}), xX = /* @__PURE__ */ ct(kX, [[\"__scopeId\", \"data-v-3eb93ac9\"]]), PX = (t) => (Ks(\"data-v-d4d0c979\"), t = t(), Js(), t), _X = {\n  key: 0,\n  class: \"security-scheme-label\"\n}, TX = {\n  key: 1,\n  class: \"security-scheme-selector\"\n}, EX = { class: \"security-scheme-label\" }, $X = [\"value\"], QX = /* @__PURE__ */ PX(() => /* @__PURE__ */ D(\"option\", { value: \"\" }, \"None\", -1)), CX = [\"value\"], AX = /* @__PURE__ */ le({\n  __name: \"SecuritySchemeSelector\",\n  props: {\n    value: {}\n  },\n  emits: [\"input\"],\n  setup(t, { emit: e }) {\n    const n = t, r = e, { authentication: i, setAuthentication: s } = Yl(), o = (m) => {\n      a(m.target.value);\n    };\n    et(() => {\n      i.preferredSecurityScheme || a(Object.keys(n.value ?? {})[0] ?? null);\n    });\n    const a = (m) => {\n      s({\n        preferredSecurityScheme: m\n      }), r(\"input\", m);\n    };\n    xd(\n      () => a(Object.keys(n.value ?? {})[0] ?? null)\n    );\n    const l = (m) => !(m != null && m.type), c = (m) => m.type.toLowerCase() === \"apikey\", u = (m) => m.type === \"http\" && m.scheme.toLowerCase() === \"basic\" || m.type.toLowerCase() === \"basic\", d = (m) => m.type === \"http\" && m.scheme.toLowerCase() === \"bearer\", f = (m) => m.type.toLowerCase() === \"oauth2\", h = (m, y) => `${p(m)} (${y})`, p = (m) => l(m) ? \"No Authentication\" : c(m) ? \"API Key\" : u(m) ? \"Basic Authentication\" : d(m) ? \"Bearer Authentication\" : f(m) ? \"OAuth 2.0\" : `${m.type} (not yet supported)`, O = j(() => Object.keys(n.value ?? {}));\n    return (m, y) => {\n      var b, g;\n      return O.value.length === 1 ? (Z(), ne(\"div\", _X, De(h((b = m.value) == null ? void 0 : b[O.value[0]], O.value[0])), 1)) : O.value.length > 1 ? (Z(), ne(\"div\", TX, [\n        D(\"span\", EX, De(R(i).preferredSecurityScheme ? h(\n          (g = m.value) == null ? void 0 : g[R(i).preferredSecurityScheme],\n          R(i).preferredSecurityScheme\n        ) : \"None\"), 1),\n        J(R(_l), { icon: \"ChevronDown\" }),\n        D(\"select\", {\n          value: R(i).preferredSecurityScheme,\n          onClick: y[0] || (y[0] = aS(() => {\n          }, [\"prevent\"])),\n          onInput: o\n        }, [\n          QX,\n          (Z(!0), ne(Pe, null, Xr(O.value, (v) => {\n            var S;\n            return Z(), ne(\"option\", {\n              key: v,\n              value: v ?? null\n            }, De(h((S = m.value) == null ? void 0 : S[v], v)), 9, CX);\n          }), 128))\n        ], 40, $X)\n      ])) : st(\"\", !0);\n    };\n  }\n}), RX = /* @__PURE__ */ ct(AX, [[\"__scopeId\", \"data-v-d4d0c979\"]]), NX = {\n  key: 0,\n  class: \"preferred-security-scheme\"\n}, DX = {\n  key: 1,\n  class: \"security-scheme-empty-state\"\n}, ZX = /* @__PURE__ */ le({\n  __name: \"RequestAuthentication\",\n  setup(t) {\n    const e = G(null);\n    kP.on(() => {\n      if (!e.value)\n        return;\n      e.value.scrollIntoView({\n        behavior: \"smooth\",\n        block: \"center\"\n      });\n    });\n    const { authentication: n, setAuthentication: r } = Yl(), i = (s) => {\n      r({\n        customSecurity: !0,\n        preferredSecurityScheme: s,\n        securitySchemes: {\n          apiKey: { type: \"apiKey\", name: \"apiKey\", in: \"header\" },\n          httpBasic: { type: \"http\", scheme: \"basic\" },\n          httpBearer: { type: \"http\", scheme: \"bearer\" }\n          // TODO oauth2\n        }\n      });\n    };\n    return (s, o) => (Z(), ne(\"div\", {\n      ref_key: \"requestAuthenticationRef\",\n      ref: e\n    }, [\n      J(R(bi), { title: \"Authentication\" }, {\n        options: ce(() => [\n          J(RX, {\n            value: R(n).securitySchemes\n          }, null, 8, [\"value\"])\n        ]),\n        default: ce(() => {\n          var a;\n          return [\n            R(n).preferredSecurityScheme ? (Z(), ne(\"div\", NX, [\n              J(xX, {\n                value: (a = R(n).securitySchemes) == null ? void 0 : a[R(n).preferredSecurityScheme]\n              }, null, 8, [\"value\"])\n            ])) : st(\"\", !0),\n            R(n).securitySchemes ? st(\"\", !0) : (Z(), ne(\"div\", DX, [\n              D(\"div\", {\n                class: \"scalar-api-client-add\",\n                variant: \"outlined\",\n                onClick: o[0] || (o[0] = (l) => i(\"apiKey\"))\n              }, \" ApiKey \"),\n              D(\"div\", {\n                class: \"scalar-api-client-add\",\n                variant: \"outlined\",\n                onClick: o[1] || (o[1] = (l) => i(\"httpBasic\"))\n              }, \" Basic \"),\n              D(\"div\", {\n                class: \"scalar-api-client-add\",\n                variant: \"outlined\",\n                onClick: o[2] || (o[2] = (l) => i(\"httpBearer\"))\n              }, \" Bearer \")\n            ]))\n          ];\n        }),\n        _: 1\n      })\n    ], 512));\n  }\n}), VX = /* @__PURE__ */ ct(ZX, [[\"__scopeId\", \"data-v-d34c7f0c\"]]), IX = { class: \"table-row\" }, WX = { class: \"table-row-item\" }, MX = { class: \"table-row-item\" }, XX = {\n  key: 0,\n  class: \"table-row-item\"\n}, jX = { class: \"table-row-meta\" }, BX = /* @__PURE__ */ le({\n  __name: \"GridRow\",\n  props: {\n    showDescription: { type: Boolean }\n  },\n  setup(t) {\n    return (e, n) => (Z(), ne(\"div\", IX, [\n      D(\"div\", WX, [\n        pt(e.$slots, \"key\", {}, void 0, !0)\n      ]),\n      D(\"div\", MX, [\n        pt(e.$slots, \"value\", {}, void 0, !0)\n      ]),\n      e.showDescription ? (Z(), ne(\"div\", XX, [\n        pt(e.$slots, \"description\", {}, void 0, !0)\n      ])) : st(\"\", !0),\n      D(\"div\", jX, [\n        pt(e.$slots, \"meta\", {}, void 0, !0)\n      ])\n    ]));\n  }\n}), Qg = /* @__PURE__ */ ct(BX, [[\"__scopeId\", \"data-v-d0f28f6e\"]]), Kd = (t) => (Ks(\"data-v-1fd79202\"), t = t(), Js(), t), LX = /* @__PURE__ */ Kd(() => /* @__PURE__ */ D(\"label\", { class: \"table-column-header\" }, \"Key\", -1)), UX = /* @__PURE__ */ Kd(() => /* @__PURE__ */ D(\"label\", { class: \"table-column-header\" }, \"Value\", -1)), qX = /* @__PURE__ */ Kd(() => /* @__PURE__ */ D(\"label\", { class: \"table-column-header\" }, \"Description\", -1)), YX = /* @__PURE__ */ Kd(() => /* @__PURE__ */ D(\"svg\", {\n  fill: \"currentColor\",\n  height: \"12\",\n  viewBox: \"0 0 18 12\",\n  width: \"18\",\n  xmlns: \"http://www.w3.org/2000/svg\"\n}, [\n  /* @__PURE__ */ D(\"path\", {\n    d: \"M0 12h12v-2H0v2zM0 0v2h18V0H0zm0 7h18V5H0v2z\",\n    \"fill-rule\": \"nonzero\"\n  })\n], -1)), zX = /* @__PURE__ */ le({\n  __name: \"GridHeader\",\n  props: {\n    showDescription: { type: Boolean }\n  },\n  emits: [\"update:showDescription\"],\n  setup(t) {\n    return (e, n) => (Z(), ke(Qg, { showDescription: e.showDescription }, {\n      key: ce(() => [\n        LX\n      ]),\n      value: ce(() => [\n        UX\n      ]),\n      description: ce(() => [\n        qX\n      ]),\n      meta: ce(() => [\n        J(R(rX), {\n          class: \"table-description-toggle\",\n          variant: \"text\",\n          onClick: n[0] || (n[0] = (r) => e.$emit(\"update:showDescription\", !e.showDescription))\n        }, {\n          default: ce(() => [\n            YX\n          ]),\n          _: 1\n        })\n      ]),\n      _: 1\n    }, 8, [\"showDescription\"]));\n  }\n}), HX = /* @__PURE__ */ ct(zX, [[\"__scopeId\", \"data-v-1fd79202\"]]), RP = (t) => (Ks(\"data-v-c042b839\"), t = t(), Js(), t), FX = { class: \"meta-check\" }, GX = /* @__PURE__ */ RP(() => /* @__PURE__ */ D(\"span\", { class: \"meta-checkmark\" }, null, -1)), KX = /* @__PURE__ */ RP(() => /* @__PURE__ */ D(\"svg\", {\n  fill: \"none\",\n  height: \"10\",\n  viewBox: \"-0.5 -0.5 10 10\",\n  width: \"10\",\n  xmlns: \"http://www.w3.org/2000/svg\"\n}, [\n  /* @__PURE__ */ D(\"path\", {\n    d: \"m8.55 0.45 -8.1 8.1\",\n    stroke: \"currentColor\",\n    \"stroke-linecap\": \"round\",\n    \"stroke-linejoin\": \"round\",\n    \"stroke-width\": \"1.5\"\n  }),\n  /* @__PURE__ */ D(\"path\", {\n    d: \"m0.45 0.45 8.1 8.1\",\n    stroke: \"currentColor\",\n    \"stroke-linecap\": \"round\",\n    \"stroke-linejoin\": \"round\",\n    \"stroke-width\": \"1.5\"\n  })\n], -1)), JX = [\n  KX\n], e8 = /* @__PURE__ */ le({\n  __name: \"GridRowEditable\",\n  props: {\n    name: {},\n    description: {},\n    value: {},\n    required: { type: Boolean },\n    enabled: { type: Boolean }\n  },\n  emits: [\"update:name\", \"update:value\", \"update:description\", \"update:enabled\", \"delete\"],\n  setup(t, { emit: e }) {\n    const n = t, r = e, i = j({\n      get: () => n.name,\n      set: (l) => {\n        r(\"update:enabled\", !0), r(\"update:name\", l);\n      }\n    }), s = j({\n      get: () => `${n.value}`,\n      set: (l) => {\n        r(\"update:enabled\", !0), r(\"update:value\", l);\n      }\n    }), o = j({\n      get: () => n.description ?? \"\",\n      set: (l) => r(\"update:description\", l)\n    }), a = j({\n      get: () => n.enabled,\n      set: (l) => r(\"update:enabled\", l)\n    });\n    return (l, c) => (Z(), ke(Qg, {\n      class: Ke([\"table-row-editable\", { \"required-parameter\": l.required }])\n    }, {\n      key: ce(() => [\n        Xi(D(\"input\", {\n          \"onUpdate:modelValue\": c[0] || (c[0] = (u) => i.value = u),\n          placeholder: \"Key\"\n        }, null, 512), [\n          [Gi, i.value]\n        ])\n      ]),\n      value: ce(() => [\n        Xi(D(\"input\", {\n          \"onUpdate:modelValue\": c[1] || (c[1] = (u) => s.value = u),\n          placeholder: \"Value\"\n        }, null, 512), [\n          [Gi, s.value]\n        ])\n      ]),\n      description: ce(() => [\n        Xi(D(\"input\", {\n          \"onUpdate:modelValue\": c[2] || (c[2] = (u) => o.value = u),\n          placeholder: \"Description\"\n        }, null, 512), [\n          [Gi, o.value]\n        ])\n      ]),\n      meta: ce(() => [\n        D(\"label\", FX, [\n          Xi(D(\"input\", {\n            \"onUpdate:modelValue\": c[3] || (c[3] = (u) => a.value = u),\n            type: \"checkbox\"\n          }, null, 512), [\n            [$d, a.value]\n          ]),\n          GX\n        ]),\n        l.required ? st(\"\", !0) : (Z(), ne(\"button\", {\n          key: 0,\n          class: \"meta-delete\",\n          type: \"button\",\n          onClick: c[4] || (c[4] = (u) => l.$emit(\"delete\"))\n        }, JX))\n      ]),\n      _: 1\n    }, 8, [\"class\"]));\n  }\n}), t8 = /* @__PURE__ */ ct(e8, [[\"__scopeId\", \"data-v-c042b839\"]]), n8 = (t) => (Ks(\"data-v-78bcd93d\"), t = t(), Js(), t), r8 = [\"value\"], i8 = [\"value\"], s8 = /* @__PURE__ */ n8(() => /* @__PURE__ */ D(\"input\", {\n  disabled: \"\",\n  value: \"Read-only\"\n}, null, -1)), o8 = /* @__PURE__ */ le({\n  __name: \"GridRowGenerated\",\n  props: {\n    item: {}\n  },\n  setup(t) {\n    return (e, n) => (Z(), ke(Qg, { class: \"table-row-generated\" }, {\n      key: ce(() => [\n        D(\"input\", {\n          disabled: \"\",\n          placeholder: \"key\",\n          value: e.item.name\n        }, null, 8, r8)\n      ]),\n      value: ce(() => [\n        D(\"input\", {\n          disabled: \"\",\n          placeholder: \"value\",\n          type: \"password\",\n          value: e.item.value\n        }, null, 8, i8)\n      ]),\n      description: ce(() => [\n        s8\n      ]),\n      _: 1\n    }));\n  }\n}), a8 = /* @__PURE__ */ ct(o8, [[\"__scopeId\", \"data-v-78bcd93d\"]]), l8 = { class: \"table\" }, c8 = { class: \"meta-actions\" }, u8 = { class: \"meta-actions-item-icon\" }, d8 = { class: \"meta-actions-item-icon\" }, f8 = /* @__PURE__ */ le({\n  __name: \"Grid\",\n  props: {\n    items: {},\n    generatedItems: {},\n    addLabel: {},\n    showMoreFilter: { type: Boolean }\n  },\n  emits: [\"deleteIndex\", \"addAnother\"],\n  setup(t, { emit: e }) {\n    const n = e, r = G(!1), i = G(!1);\n    function s() {\n      n(\"addAnother\"), i.value = !0;\n    }\n    return (o, a) => (Z(), ne(\"div\", l8, [\n      J(HX, {\n        showDescription: r.value,\n        \"onUpdate:showDescription\": a[0] || (a[0] = (l) => r.value = l)\n      }, null, 8, [\"showDescription\"]),\n      (Z(!0), ne(Pe, null, Xr(o.generatedItems, (l) => (Z(), ke(a8, {\n        key: l.name,\n        item: l,\n        showDescription: r.value,\n        onClick: a[1] || (a[1] = (c) => R(kP).emit())\n      }, null, 8, [\"item\", \"showDescription\"]))), 128)),\n      (Z(!0), ne(Pe, null, Xr(o.items, (l, c) => Xi((Z(), ke(t8, {\n        key: c,\n        description: l.description,\n        \"onUpdate:description\": (u) => l.description = u,\n        enabled: l.enabled,\n        \"onUpdate:enabled\": (u) => l.enabled = u,\n        name: l.name,\n        \"onUpdate:name\": (u) => l.name = u,\n        value: l.value,\n        \"onUpdate:value\": (u) => l.value = u,\n        required: l.required,\n        showDescription: r.value,\n        onDelete: (u) => o.$emit(\"deleteIndex\", c)\n      }, null, 8, [\"description\", \"onUpdate:description\", \"enabled\", \"onUpdate:enabled\", \"name\", \"onUpdate:name\", \"value\", \"onUpdate:value\", \"required\", \"showDescription\", \"onDelete\"])), [\n        [jl, !o.showMoreFilter || o.showMoreFilter && c < 5 || i.value]\n      ])), 128)),\n      D(\"div\", c8, [\n        o.addLabel ? (Z(), ne(\"button\", {\n          key: 0,\n          class: \"meta-actions-item\",\n          type: \"button\",\n          onClick: s\n        }, [\n          D(\"i\", u8, [\n            J(R(_l), { icon: \"Add\" })\n          ]),\n          He(\" \" + De(o.addLabel), 1)\n        ])) : st(\"\", !0),\n        o.showMoreFilter && o.items && o.items.length > 5 && !i.value ? (Z(), ne(\"button\", {\n          key: 1,\n          class: \"meta-actions-item\",\n          type: \"button\",\n          onClick: a[2] || (a[2] = (l) => i.value = !0)\n        }, [\n          He(\" Show More \"),\n          D(\"i\", d8, [\n            J(R(_l), { icon: \"ChevronDown\" })\n          ])\n        ])) : st(\"\", !0)\n      ])\n    ]));\n  }\n}), nc = /* @__PURE__ */ ct(f8, [[\"__scopeId\", \"data-v-af1138c8\"]]), h8 = { class: \"navtable simpletable\" }, p8 = { class: \"navtable-table\" }, O8 = /* @__PURE__ */ Wl('<div class=\"navtable-item navtable-item__top\" data-v-5ba40e52><div class=\"navtable-item-33\" data-v-5ba40e52><label for=\"\" data-v-5ba40e52>Name</label></div><div class=\"navtable-item-66\" data-v-5ba40e52><label for=\"\" data-v-5ba40e52>Value</label></div></div>', 1), g8 = { class: \"navtable-item-33\" }, m8 = { class: \"navtable-item-66\" }, b8 = /* @__PURE__ */ le({\n  __name: \"SimpleGrid\",\n  props: {\n    items: {}\n  },\n  setup(t) {\n    return (e, n) => (Z(), ne(\"div\", h8, [\n      D(\"div\", p8, [\n        O8,\n        (Z(!0), ne(Pe, null, Xr(e.items, (r) => (Z(), ne(\"div\", {\n          key: r.id,\n          class: \"navtable-item\"\n        }, [\n          D(\"div\", g8, [\n            D(\"p\", null, De(r.name), 1)\n          ]),\n          D(\"div\", m8, [\n            D(\"p\", null, De(r.value), 1)\n          ])\n        ]))), 128))\n      ])\n    ]));\n  }\n}), v8 = /* @__PURE__ */ ct(b8, [[\"__scopeId\", \"data-v-5ba40e52\"]]), y8 = { key: 0 }, S8 = /* @__PURE__ */ le({\n  __name: \"RequestBody\",\n  props: {\n    body: {},\n    formData: {}\n  },\n  setup(t) {\n    const { activeRequest: e, setActiveRequest: n } = sr(), r = (i) => {\n      e.body !== i && n({\n        ...e,\n        body: i\n      });\n    };\n    return (i, s) => (Z(), ke(R(bi), { title: \"Body\" }, {\n      default: ce(() => [\n        i.body && i.body.length === 0 && i.formData && i.formData.length === 0 ? (Z(), ne(\"span\", y8, \"No Body\")) : i.formData && i.formData.length > 0 ? (Z(), ke(R(nc), {\n          key: 1,\n          items: i.formData\n        }, null, 8, [\"items\"])) : (Z(), ke(R(SP), {\n          key: 2,\n          content: R(e).body,\n          language: \"json\",\n          lineNumbers: \"\",\n          onChange: r\n        }, null, 8, [\"content\"]))\n      ]),\n      _: 1\n    }));\n  }\n}), w8 = {\n  key: 0,\n  class: \"scalar-api-client__empty-state\"\n}, k8 = /* @__PURE__ */ D(\"svg\", {\n  class: \"flow-icon\",\n  \"data-v-aa4fbd2d\": \"\",\n  height: \"100%\",\n  viewBox: \"0 0 48 48\",\n  xmlns: \"http://www.w3.org/2000/svg\"\n}, [\n  /* @__PURE__ */ D(\"path\", {\n    d: \"M24 1.714v44.572M1.714 24h44.572\",\n    fill: \"none\",\n    stroke: \"currentColor\",\n    \"stroke-linecap\": \"round\",\n    \"stroke-linejoin\": \"round\",\n    \"stroke-width\": \"3.429\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  })\n], -1), x8 = /* @__PURE__ */ le({\n  __name: \"RequestCookies\",\n  props: {\n    cookies: {},\n    generatedCookies: {}\n  },\n  setup(t) {\n    const e = t, { activeRequest: n } = sr();\n    function r(o) {\n      var a;\n      (a = n.cookies) == null || a.splice(o, 1);\n    }\n    function i() {\n      var o;\n      n.cookies === void 0 && (n.cookies = []), (o = n.cookies) == null || o.push({ name: \"\", value: \"\", enabled: !0 });\n    }\n    const s = j(() => {\n      var o, a;\n      return !!((o = e.cookies) != null && o.length || (a = e.generatedCookies) != null && a.length);\n    });\n    return (o, a) => (Z(), ke(R(bi), {\n      defaultOpen: s.value,\n      title: \"Cookies\"\n    }, {\n      default: ce(() => [\n        s.value ? (Z(), ke(R(nc), {\n          key: 1,\n          addLabel: \"Cookie\",\n          generatedItems: o.generatedCookies,\n          items: o.cookies,\n          onAddAnother: i,\n          onDeleteIndex: r\n        }, null, 8, [\"generatedItems\", \"items\"])) : (Z(), ne(\"div\", w8, [\n          D(\"button\", {\n            class: \"scalar-api-client-add\",\n            type: \"button\",\n            onClick: i\n          }, [\n            k8,\n            He(\" Cookies \")\n          ])\n        ]))\n      ]),\n      _: 1\n    }, 8, [\"defaultOpen\"]));\n  }\n}), P8 = {\n  key: 0,\n  class: \"scalar-api-client__empty-state\"\n}, _8 = /* @__PURE__ */ D(\"svg\", {\n  class: \"flow-icon\",\n  \"data-v-aa4fbd2d\": \"\",\n  height: \"100%\",\n  viewBox: \"0 0 48 48\",\n  xmlns: \"http://www.w3.org/2000/svg\"\n}, [\n  /* @__PURE__ */ D(\"path\", {\n    d: \"M24 1.714v44.572M1.714 24h44.572\",\n    fill: \"none\",\n    stroke: \"currentColor\",\n    \"stroke-linecap\": \"round\",\n    \"stroke-linejoin\": \"round\",\n    \"stroke-width\": \"3.429\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  })\n], -1), T8 = /* @__PURE__ */ le({\n  __name: \"RequestHeaders\",\n  props: {\n    headers: {},\n    generatedHeaders: {}\n  },\n  setup(t) {\n    const e = t, { activeRequest: n } = sr();\n    function r(o) {\n      var a;\n      (a = n.headers) == null || a.splice(o, 1);\n    }\n    function i() {\n      var o;\n      n.headers === void 0 && (n.headers = []), (o = n.headers) == null || o.push({ name: \"\", value: \"\", enabled: !0 });\n    }\n    const s = j(() => {\n      var o, a;\n      return !!((o = e.headers) != null && o.length || (a = e.generatedHeaders) != null && a.length);\n    });\n    return (o, a) => (Z(), ke(R(bi), {\n      defaultOpen: s.value,\n      title: \"Headers\"\n    }, {\n      default: ce(() => [\n        s.value ? (Z(), ke(R(nc), {\n          key: 1,\n          addLabel: \"Header\",\n          generatedItems: o.generatedHeaders,\n          items: o.headers,\n          onAddAnother: i,\n          onDeleteIndex: r\n        }, null, 8, [\"generatedItems\", \"items\"])) : (Z(), ne(\"div\", P8, [\n          D(\"button\", {\n            class: \"scalar-api-client-add\",\n            type: \"button\",\n            onClick: i\n          }, [\n            _8,\n            He(\" Headers \")\n          ])\n        ]))\n      ]),\n      _: 1\n    }, 8, [\"defaultOpen\"]));\n  }\n}), E8 = {\n  key: 0,\n  class: \"scalar-api-client__empty-state\"\n}, $8 = /* @__PURE__ */ D(\"svg\", {\n  class: \"flow-icon\",\n  \"data-v-aa4fbd2d\": \"\",\n  height: \"100%\",\n  viewBox: \"0 0 48 48\",\n  xmlns: \"http://www.w3.org/2000/svg\"\n}, [\n  /* @__PURE__ */ D(\"path\", {\n    d: \"M24 1.714v44.572M1.714 24h44.572\",\n    fill: \"none\",\n    stroke: \"currentColor\",\n    \"stroke-linecap\": \"round\",\n    \"stroke-linejoin\": \"round\",\n    \"stroke-width\": \"3.429\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  })\n], -1), Q8 = /* @__PURE__ */ le({\n  __name: \"RequestQuery\",\n  props: {\n    queries: {},\n    generatedQueries: {}\n  },\n  setup(t) {\n    const e = t, { activeRequest: n } = sr();\n    function r(o) {\n      var a;\n      (a = n.query) == null || a.splice(o, 1);\n    }\n    function i() {\n      var o;\n      n.query === void 0 && (n.query = []), (o = n.query) == null || o.push({ name: \"\", value: \"\", enabled: !0 });\n    }\n    const s = j(() => {\n      var o, a;\n      return !!((o = e.queries) != null && o.length || (a = e.generatedQueries) != null && a.length);\n    });\n    return (o, a) => (Z(), ke(R(bi), {\n      defaultOpen: s.value,\n      title: \"Query Parameters\"\n    }, {\n      default: ce(() => [\n        s.value ? (Z(), ke(R(nc), {\n          key: 1,\n          addLabel: \"Query Parameter\",\n          generatedItems: o.generatedQueries,\n          items: o.queries,\n          showMoreFilter: !0,\n          onAddAnother: i,\n          onDeleteIndex: r\n        }, null, 8, [\"generatedItems\", \"items\"])) : (Z(), ne(\"div\", E8, [\n          D(\"button\", {\n            class: \"scalar-api-client-add\",\n            type: \"button\",\n            onClick: i\n          }, [\n            $8,\n            He(\" Query Parameter \")\n          ])\n        ]))\n      ]),\n      _: 1\n    }, 8, [\"defaultOpen\"]));\n  }\n}), C8 = {\n  key: 0,\n  class: \"scalar-api-client__empty-state\"\n}, A8 = /* @__PURE__ */ D(\"svg\", {\n  class: \"flow-icon\",\n  \"data-v-aa4fbd2d\": \"\",\n  height: \"100%\",\n  viewBox: \"0 0 48 48\",\n  xmlns: \"http://www.w3.org/2000/svg\"\n}, [\n  /* @__PURE__ */ D(\"path\", {\n    d: \"M24 1.714v44.572M1.714 24h44.572\",\n    fill: \"none\",\n    stroke: \"currentColor\",\n    \"stroke-linecap\": \"round\",\n    \"stroke-linejoin\": \"round\",\n    \"stroke-width\": \"3.429\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  })\n], -1), R8 = /* @__PURE__ */ le({\n  __name: \"RequestVariables\",\n  props: {\n    variables: {}\n  },\n  setup(t) {\n    const { activeRequest: e } = sr();\n    function n(i) {\n      var s;\n      (s = e.variables) == null || s.splice(i, 1);\n    }\n    function r() {\n      var i;\n      e.variables === void 0 && (e.variables = []), (i = e.variables) == null || i.push({ name: \"\", value: \"\", enabled: !0 });\n    }\n    return (i, s) => (Z(), ke(R(bi), {\n      defaultOpen: R(e).variables && R(e).variables.length > 0,\n      title: \"Variables\"\n    }, {\n      default: ce(() => [\n        !i.variables || i.variables.length === 0 ? (Z(), ne(\"div\", C8, [\n          D(\"button\", {\n            class: \"scalar-api-client-add\",\n            type: \"button\",\n            onClick: r\n          }, [\n            A8,\n            He(\" Variable \")\n          ])\n        ])) : (Z(), ke(R(nc), {\n          key: 1,\n          addLabel: \"Variable\",\n          items: i.variables,\n          showMoreFilter: !0,\n          onAddAnother: r,\n          onDeleteIndex: n\n        }, null, 8, [\"items\"]))\n      ]),\n      _: 1\n    }, 8, [\"defaultOpen\"]));\n  }\n}), N8 = { class: \"scalar-api-client__main__left custom-scroll\" }, D8 = { class: \"scalar-api-client__main__content\" }, Z8 = { class: \"scalar-api-client__main__content__header\" }, V8 = /* @__PURE__ */ D(\"label\", null, \"Request\", -1), I8 = { class: \"meta\" }, W8 = { class: \"meta-item meta-item__input\" }, M8 = { class: \"scalar-api-client__main__content__body\" }, X8 = /* @__PURE__ */ D(\"div\", { class: \"scalar-api-client__main__scroll-container\" }, null, -1), j8 = !0, B0 = /* @__PURE__ */ le({\n  __name: \"Request\",\n  setup(t) {\n    const { activeRequest: e } = sr(), { authentication: n } = Yl(), {\n      openApi: { operation: r, globalSecurity: i }\n    } = Cw(), s = j(\n      () => {\n        var a;\n        return wP(\n          n,\n          ((a = r == null ? void 0 : r.information) == null ? void 0 : a.security) ?? i\n        );\n      }\n    ), o = j(() => {\n      const a = e.type.toLowerCase();\n      return a === \"put\" || a === \"post\" || a === \"patch\";\n    });\n    return (a, l) => (Z(), ne(\"div\", N8, [\n      D(\"div\", D8, [\n        D(\"div\", Z8, [\n          V8,\n          D(\"div\", I8, [\n            D(\"div\", W8, [\n              Xi(D(\"input\", {\n                \"onUpdate:modelValue\": l[0] || (l[0] = (c) => R(e).name = c),\n                class: \"scalar-api-client__request-name\",\n                disabled: j8,\n                placeholder: \"Request Name\",\n                type: \"text\"\n              }, null, 512), [\n                [Gi, R(e).name]\n              ])\n            ])\n          ])\n        ]),\n        D(\"div\", M8, [\n          J(R8, {\n            variables: R(e).variables\n          }, null, 8, [\"variables\"]),\n          J(R(VX)),\n          J(x8, {\n            cookies: R(e).cookies,\n            generatedCookies: s.value.cookies\n          }, null, 8, [\"cookies\", \"generatedCookies\"]),\n          J(T8, {\n            generatedHeaders: s.value.headers,\n            headers: R(e).headers\n          }, null, 8, [\"generatedHeaders\", \"headers\"]),\n          J(Q8, {\n            generatedQueries: s.value.queryString,\n            queries: R(e).query\n          }, null, 8, [\"generatedQueries\", \"queries\"]),\n          o.value ? (Z(), ke(S8, {\n            key: 0,\n            body: R(e).body,\n            formData: R(e).formData,\n            requestBody: R(e).body\n          }, null, 8, [\"body\", \"formData\", \"requestBody\"])) : st(\"\", !0),\n          X8\n        ])\n      ])\n    ]));\n  }\n}), B8 = `                         .,,uod8B8bou,,.\n                ..,uod8BBBBBBBBBBBBBBBBRPFT?l!i:.\n           ||||||||||||||!?TFPRBBBBBBBBBBBBBBB8m=,\n           ||||   '\"\"^^!!||||||||||TFPRBBBVT!:...!\n           ||||            '\"\"^^!!|||||?!:.......!\n           ||||                     ||||.........!\n           ||||                     ||||.........!\n           ||||                     ||||.........!\n           ||||                     ||||.........!\n           ||||                     ||||.........!\n           ||||                     ||||.........!\n           ||||,                    ||||.........\\`\n           |||||!!-._               ||||.......;.\n           ':!|||||||||!!-._        ||||.....bBBBBWdou,.\n         bBBBBB86foi!|||||||!!-..:|||!..bBBBBBBBBBBBBBBY!\n         ::!?TFPRBBBBBB86foi!||||||||!!bBBBBBBBBBBBBBBY..!\n         :::::::::!?TFPRBBBBBB86ftiaabBBBBBBBBBBBBBBY....!\n         :::;\\`\"^!:;::::::!?TFPRBBBBBBBBBBBBBBBBBBBY......!\n         ;::::::...''^::::::::::!?TFPRBBBBBBBBBBY........!\n     .ob86foi;::::::::::::::::::::::::!?TFPRBY..........\\`\n    .b888888888886foi;:::::::::::::::::::::::..........\\`\n .b888888888888888888886foi;::::::::::::::::..........\n.b888888888888888888888888888886foi;:::::::::......\\`\n!Tf998888888888888888888888888888888886foi;:::....\\`\n  '\"^!|Tf9988888888888888888888888888888888!::..\\`\n       '\"^!|Tf998888888888888888888888889!! '\\`\n             '\"^!|Tf9988888888888888888!!\\`            iBBbo.\n                  '\"^!|Tf998888888889!\\`             WBBBBbo.\n                        '\"^!|Tf9989!\\`              YBBBP^'\n                              '\"^!\\`               \\`\n`, L8 = { class: \"ascii-art\" }, U8 = { class: \"ascii-art-line\" }, q8 = /* @__PURE__ */ le({\n  __name: \"ScalarAsciiArt\",\n  props: {\n    art: {}\n  },\n  setup(t) {\n    const e = t, n = j(() => e.art.split(`\n`));\n    return (r, i) => (Z(), ne(\"div\", L8, [\n      (Z(!0), ne(Pe, null, Xr(n.value, (s, o) => (Z(), ne(\"span\", {\n        key: o,\n        class: \"ascii-art-line-wrapper\",\n        style: Br({ width: `calc(${s.length + 1}ch)` })\n      }, [\n        D(\"span\", U8, De(s), 1)\n      ], 4))), 128))\n    ]));\n  }\n}), Y8 = /* @__PURE__ */ ct(q8, [[\"__scopeId\", \"data-v-c706348d\"]]), z8 = {\n  key: 1,\n  class: \"scalar-api-client__empty-state\"\n}, H8 = {\n  key: 1,\n  class: \"scalar-api-client__empty-state\"\n}, F8 = /* @__PURE__ */ le({\n  __name: \"ResponseBody\",\n  props: {\n    active: { type: Boolean, default: !1 },\n    data: { default: null },\n    headers: {}\n  },\n  setup(t) {\n    const e = t, n = j(() => {\n      const i = e.headers.find(\n        (s) => s.name.toLowerCase() === \"content-type\"\n      );\n      if (!i)\n        return null;\n      try {\n        return JO.parse(i.value).type;\n      } catch {\n        return null;\n      }\n    }), r = j(() => n.value === \"application/json\" || n.value === \"application/problem+json\" || n.value === \"application/vnd.api+json\" ? \"json\" : n.value === \"text/html\" || n.value === \"text/plain\" ? \"html\" : null);\n    return (i, s) => (Z(), ke(R(bi), { title: \"Body\" }, {\n      default: ce(() => [\n        i.active ? (Z(), ne(Pe, { key: 0 }, [\n          r.value ? (Z(), ke(R(oX), {\n            key: 0,\n            class: \"custom-scroll\",\n            content: i.data,\n            lang: r.value\n          }, null, 8, [\"content\", \"lang\"])) : (Z(), ne(\"div\", z8, [\n            n.value ? (Z(), ne(Pe, { key: 0 }, [\n              He(\" No Preview Available (\" + De(n.value) + \") \", 1)\n            ], 64)) : (Z(), ne(Pe, { key: 1 }, [\n              He(\" Cant render a preview. The Content-Type header is missing or unknown. \")\n            ], 64))\n          ]))\n        ], 64)) : (Z(), ne(\"div\", H8, \" No Response \"))\n      ]),\n      _: 1\n    }));\n  }\n}), G8 = [\"href\"], K8 = /* @__PURE__ */ le({\n  __name: \"HelpfulLink\",\n  props: {\n    href: {}\n  },\n  setup(t) {\n    return (e, n) => (Z(), ne(\"a\", {\n      href: e.href,\n      rel: \"noopener noreferrer\",\n      target: \"_blank\"\n    }, [\n      pt(e.$slots, \"default\", {}, void 0, !0)\n    ], 8, G8));\n  }\n}), NP = /* @__PURE__ */ ct(K8, [[\"__scopeId\", \"data-v-88788c44\"]]), J8 = /* @__PURE__ */ le({\n  __name: \"SimpleCell\",\n  props: {\n    wrap: { type: Boolean, default: !0 },\n    strong: { type: Boolean, default: !1 },\n    href: { default: null }\n  },\n  setup(t) {\n    return (e, n) => (Z(), ne(\"td\", {\n      class: Ke([\"simple-cell\", { wrap: e.wrap, strong: e.strong }])\n    }, [\n      e.href ? (Z(), ke(NP, {\n        key: 0,\n        href: e.href\n      }, {\n        default: ce(() => [\n          pt(e.$slots, \"default\", {}, void 0, !0)\n        ]),\n        _: 3\n      }, 8, [\"href\"])) : pt(e.$slots, \"default\", { key: 1 }, void 0, !0)\n    ], 2));\n  }\n}), Mp = /* @__PURE__ */ ct(J8, [[\"__scopeId\", \"data-v-7e64a8bf\"]]), e4 = /* @__PURE__ */ le({\n  __name: \"SimpleHeader\",\n  setup(t) {\n    return (e, n) => (Z(), ke(Mp, {\n      as: \"th\",\n      class: \"simple-header\"\n    }, {\n      default: ce(() => [\n        pt(e.$slots, \"default\", {}, void 0, !0)\n      ]),\n      _: 3\n    }));\n  }\n}), L0 = /* @__PURE__ */ ct(e4, [[\"__scopeId\", \"data-v-afa8d6ba\"]]), t4 = {}, n4 = { class: \"simple-row\" };\nfunction r4(t, e) {\n  return Z(), ne(\"tr\", n4, [\n    pt(t.$slots, \"default\", {}, void 0, !0)\n  ]);\n}\nconst U0 = /* @__PURE__ */ ct(t4, [[\"render\", r4], [\"__scopeId\", \"data-v-5d742611\"]]), i4 = {}, s4 = { class: \"simple-table-container\" }, o4 = { class: \"simple-table\" };\nfunction a4(t, e) {\n  return Z(), ne(\"div\", s4, [\n    D(\"table\", o4, [\n      pt(t.$slots, \"default\", {}, void 0, !0)\n    ])\n  ]);\n}\nconst l4 = /* @__PURE__ */ ct(i4, [[\"render\", a4], [\"__scopeId\", \"data-v-16749ce2\"]]), c4 = {\n  key: 1,\n  class: \"scalar-api-client__empty-state\"\n}, u4 = /* @__PURE__ */ le({\n  __name: \"ResponseHeaders\",\n  props: {\n    headers: {}\n  },\n  setup(t) {\n    const e = (r) => {\n      var i;\n      return (i = qR.find((s) => s.name.toLowerCase() === r.toLowerCase())) == null ? void 0 : i.url;\n    }, n = (r) => r.split(\"-\").map((i) => i.charAt(0).toUpperCase() + i.slice(1)).join(\"-\");\n    return (r, i) => (Z(), ke(R(bi), { title: \"Headers\" }, {\n      default: ce(() => [\n        r.headers.length > 0 ? (Z(), ke(R(l4), { key: 0 }, {\n          default: ce(() => [\n            J(R(U0), null, {\n              default: ce(() => [\n                J(R(L0), null, {\n                  default: ce(() => [\n                    He(\"Key\")\n                  ]),\n                  _: 1\n                }),\n                J(R(L0), null, {\n                  default: ce(() => [\n                    He(\"Value\")\n                  ]),\n                  _: 1\n                })\n              ]),\n              _: 1\n            }),\n            (Z(!0), ne(Pe, null, Xr(r.headers, (s) => (Z(), ke(R(U0), {\n              key: s.name\n            }, {\n              default: ce(() => [\n                J(R(Mp), {\n                  href: e(s.name),\n                  strong: !0,\n                  wrap: !1\n                }, {\n                  default: ce(() => [\n                    He(De(n(s.name)), 1)\n                  ]),\n                  _: 2\n                }, 1032, [\"href\"]),\n                J(R(Mp), null, {\n                  default: ce(() => [\n                    He(De(s.value), 1)\n                  ]),\n                  _: 2\n                }, 1024)\n              ]),\n              _: 2\n            }, 1024))), 128))\n          ]),\n          _: 1\n        })) : (Z(), ne(\"div\", c4, \"No Headers\"))\n      ]),\n      _: 1\n    }));\n  }\n}), d4 = { class: \"meta-item\" }, f4 = { class: \"meta-item\" }, h4 = { class: \"meta-item\" }, p4 = /* @__PURE__ */ le({\n  __name: \"ResponseMetaInformation\",\n  props: {\n    response: {}\n  },\n  setup(t) {\n    const e = t, n = (i) => {\n      var s;\n      return (s = i == null ? void 0 : i.headers) != null && s[\"X-API-Client-Content-Length\"] ? Cu(\n        parseFloat(i.headers[\"X-API-Client-Content-Length\"])\n      ) : Cu(0);\n    }, r = j(() => {\n      const i = e.response.statusCode;\n      if (i)\n        return RR[i] ?? void 0;\n    });\n    return (i, s) => {\n      var o, a;\n      return Z(), ne(Pe, null, [\n        D(\"div\", d4, [\n          D(\"span\", null, De(R(dw)(i.response.duration)), 1)\n        ]),\n        D(\"div\", f4, [\n          D(\"span\", null, De(n(i.response)), 1)\n        ]),\n        D(\"div\", h4, [\n          D(\"span\", {\n            class: Ke(`scalar-api-client__status scalar-api-client__status--${String(\n              i.response.statusCode\n            ).charAt(0)}xx`)\n          }, [\n            (o = r.value) != null && o.url ? (Z(), ke(NP, {\n              key: 0,\n              href: r.value.url\n            }, {\n              default: ce(() => [\n                He(De(i.response.statusCode) + \" \" + De(r.value.name), 1)\n              ]),\n              _: 1\n            }, 8, [\"href\"])) : (Z(), ne(Pe, { key: 1 }, [\n              He(De(i.response.statusCode) + \" \" + De((a = r.value) == null ? void 0 : a.name), 1)\n            ], 64))\n          ], 2)\n        ])\n      ], 64);\n    };\n  }\n}), O4 = { class: \"scalar-api-client__main__right custom-scroll\" }, g4 = { class: \"scalar-api-client__main__content\" }, m4 = { class: \"scalar-api-client__main__content__header\" }, b4 = /* @__PURE__ */ D(\"label\", null, \"Response\", -1), v4 = {\n  key: 0,\n  class: \"meta\"\n}, y4 = {\n  key: 0,\n  class: \"scalar-api-client__main__content__body\"\n}, S4 = {\n  key: 0,\n  class: \"scalar-api-client__empty-state\"\n}, w4 = /* @__PURE__ */ D(\"div\", { class: \"scalar-api-client__main__scroll-container\" }, null, -1), k4 = {\n  key: 1,\n  class: \"scalar-api-client__main__content empty-state\"\n}, x4 = /* @__PURE__ */ D(\"p\", null, \"Fill the void and send your request\", -1), q0 = /* @__PURE__ */ le({\n  __name: \"Response\",\n  setup(t) {\n    const { activeResponse: e, activeRequestId: n } = sr(), r = j(() => {\n      var o;\n      const a = (o = e.value) == null ? void 0 : o.headers;\n      return a ? Object.keys(a).map((l) => ({ name: l, value: a[l] })).filter(\n        (l) => ![\n          \"rest-api-client-content-length\",\n          \"X-API-Client-Content-Length\"\n        ].includes(l.name)\n      ) : [];\n    }), i = j(() => {\n      var o;\n      const a = (o = e.value) == null ? void 0 : o.cookies;\n      return a ? Object.keys(a).map((l) => ({ name: l, value: a[l] })) : [];\n    }), s = j(() => {\n      var o;\n      const a = (o = e.value) == null ? void 0 : o.data;\n      return a && Xh(a) ? JSON.stringify(JSON.parse(a), null, 2) : a && typeof Oe(a) == \"object\" || a && !Xh(a) ? JSON.stringify(a, null, 2) : a;\n    });\n    return (o, a) => (Z(), ne(\"div\", O4, [\n      D(\"div\", g4, [\n        D(\"div\", m4, [\n          b4,\n          R(n) && R(e) ? (Z(), ne(\"div\", v4, [\n            J(p4, { response: R(e) }, null, 8, [\"response\"])\n          ])) : st(\"\", !0)\n        ]),\n        R(n) && R(e) ? (Z(), ne(\"div\", y4, [\n          J(F8, {\n            active: !!R(e),\n            data: s.value,\n            headers: r.value\n          }, null, 8, [\"active\", \"data\", \"headers\"]),\n          J(u4, { headers: r.value }, null, 8, [\"headers\"]),\n          J(R(bi), { title: \"Cookies\" }, {\n            default: ce(() => [\n              Xi(J(R(v8), { items: i.value }, null, 8, [\"items\"]), [\n                [jl, i.value.length > 0]\n              ]),\n              i.value.length === 0 ? (Z(), ne(\"div\", S4, \"No Cookies\")) : st(\"\", !0)\n            ]),\n            _: 1\n          }),\n          w4\n        ])) : (Z(), ne(\"div\", k4, [\n          J(Y8, { art: R(B8) }, null, 8, [\"art\"]),\n          x4\n        ]))\n      ])\n    ]));\n  }\n}), P4 = { class: \"scalar-api-client__main\" }, _4 = /* @__PURE__ */ le({\n  __name: \"ApiClient\",\n  props: {\n    proxyUrl: {},\n    readOnly: { type: Boolean, default: !1 },\n    theme: {},\n    withDefaultFonts: { type: Boolean, default: !0 },\n    showSideBar: { type: Boolean, default: !1 }\n  },\n  emits: [\"escapeKeyPress\", \"toggleSidebar\"],\n  setup(t, { emit: e }) {\n    const n = t, r = e, i = BS();\n    Nh(i.escape, () => r(\"escapeKeyPress\")), Nh(i.meta_b, () => r(\"toggleSidebar\"));\n    const { activeRequest: s, readOnly: o } = sr(), a = LC(\"(max-width: 820px)\"), l = G(0), c = {\n      Request: 0,\n      Response: 1\n    };\n    function u(d) {\n      l.value = d;\n    }\n    return ht(\n      () => n.readOnly,\n      () => {\n        o.value = n.readOnly;\n      },\n      { immediate: !0 }\n    ), (d, f) => (Z(), ne(Pe, null, [\n      J(R(wR), {\n        id: d.theme,\n        withDefaultFonts: d.withDefaultFonts\n      }, null, 8, [\"id\", \"withDefaultFonts\"]),\n      J(FR, {\n        class: \"scalar-api-client\",\n        method: R(s).type ?? \"get\",\n        property: \"--scalar-api-client-color\",\n        onKeydown: f[1] || (f[1] = lS((h) => r(\"escapeKeyPress\"), [\"esc\"]))\n      }, {\n        default: ce(() => [\n          D(\"div\", null, [\n            pt(d.$slots, \"address-bar-controls\"),\n            J(GW, {\n              proxyUrl: d.proxyUrl,\n              onOnSend: f[0] || (f[0] = (h) => u(c.Response))\n            }, null, 8, [\"proxyUrl\"])\n          ]),\n          D(\"div\", P4, [\n            d.showSideBar ? pt(d.$slots, \"sidebar\", { key: 0 }) : st(\"\", !0),\n            R(a) ? (Z(), ke(R(DC), {\n              key: 2,\n              selectedIndex: l.value,\n              onChange: u\n            }, {\n              default: ce(() => [\n                J(R(ZC), { class: \"scalar-api-client__mobile-navigation\" }, {\n                  default: ce(() => [\n                    J(R(cb), { class: \"scalar-api-client__mobile-navigation__toggle\" }, {\n                      default: ce(({ selected: h }) => [\n                        D(\"span\", {\n                          class: Ke({\n                            \"scalar-api-client__mobile-navigation--active\": h\n                          })\n                        }, \" Request \", 2)\n                      ]),\n                      _: 1\n                    }),\n                    J(R(cb), { class: \"scalar-api-client__mobile-navigation__toggle\" }, {\n                      default: ce(({ selected: h }) => [\n                        D(\"span\", {\n                          class: Ke({\n                            \"scalar-api-client__mobile-navigation--active\": h\n                          })\n                        }, \" Response \", 2)\n                      ]),\n                      _: 1\n                    })\n                  ]),\n                  _: 1\n                }),\n                J(R(VC), { as: \"template\" }, {\n                  default: ce(() => [\n                    J(R(ub), { as: \"template\" }, {\n                      default: ce(() => [\n                        J(R(B0))\n                      ]),\n                      _: 1\n                    }),\n                    J(R(ub), { as: \"template\" }, {\n                      default: ce(() => [\n                        J(R(q0))\n                      ]),\n                      _: 1\n                    })\n                  ]),\n                  _: 1\n                })\n              ]),\n              _: 1\n            }, 8, [\"selectedIndex\"])) : (Z(), ne(Pe, { key: 1 }, [\n              J(R(B0)),\n              J(R(q0))\n            ], 64))\n          ])\n        ]),\n        _: 3\n      }, 8, [\"method\"])\n    ], 64));\n  }\n});\n/**\n* @vue/compiler-core v3.4.21\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\nconst Tl = Symbol( true ? \"Fragment\" : 0), Ga = Symbol( true ? \"Teleport\" : 0), Cg = Symbol( true ? \"Suspense\" : 0), td = Symbol( true ? \"KeepAlive\" : 0), DP = Symbol( true ? \"BaseTransition\" : 0), Fs = Symbol( true ? \"openBlock\" : 0), ZP = Symbol( true ? \"createBlock\" : 0), VP = Symbol( true ? \"createElementBlock\" : 0), Ag = Symbol( true ? \"createVNode\" : 0), Rg = Symbol( true ? \"createElementVNode\" : 0), rc = Symbol( true ? \"createCommentVNode\" : 0), Ng = Symbol( true ? \"createTextVNode\" : 0), IP = Symbol( true ? \"createStaticVNode\" : 0), Dg = Symbol( true ? \"resolveComponent\" : 0), Zg = Symbol(\n   true ? \"resolveDynamicComponent\" : 0\n), Vg = Symbol( true ? \"resolveDirective\" : 0), Ig = Symbol( true ? \"resolveFilter\" : 0), Wg = Symbol( true ? \"withDirectives\" : 0), Mg = Symbol( true ? \"renderList\" : 0), WP = Symbol( true ? \"renderSlot\" : 0), MP = Symbol( true ? \"createSlots\" : 0), Jd = Symbol( true ? \"toDisplayString\" : 0), nd = Symbol( true ? \"mergeProps\" : 0), Xg = Symbol( true ? \"normalizeClass\" : 0), jg = Symbol( true ? \"normalizeStyle\" : 0), El = Symbol( true ? \"normalizeProps\" : 0), ic = Symbol( true ? \"guardReactiveProps\" : 0), Bg = Symbol( true ? \"toHandlers\" : 0), Xp = Symbol( true ? \"camelize\" : 0), T4 = Symbol( true ? \"capitalize\" : 0), jp = Symbol( true ? \"toHandlerKey\" : 0), rd = Symbol( true ? \"setBlockTracking\" : 0), E4 = Symbol( true ? \"pushScopeId\" : 0), $4 = Symbol( true ? \"popScopeId\" : 0), Lg = Symbol( true ? \"withCtx\" : 0), Q4 = Symbol( true ? \"unref\" : 0), C4 = Symbol( true ? \"isRef\" : 0), Ug = Symbol( true ? \"withMemo\" : 0), XP = Symbol( true ? \"isMemoSame\" : 0), Ho = {\n  [Tl]: \"Fragment\",\n  [Ga]: \"Teleport\",\n  [Cg]: \"Suspense\",\n  [td]: \"KeepAlive\",\n  [DP]: \"BaseTransition\",\n  [Fs]: \"openBlock\",\n  [ZP]: \"createBlock\",\n  [VP]: \"createElementBlock\",\n  [Ag]: \"createVNode\",\n  [Rg]: \"createElementVNode\",\n  [rc]: \"createCommentVNode\",\n  [Ng]: \"createTextVNode\",\n  [IP]: \"createStaticVNode\",\n  [Dg]: \"resolveComponent\",\n  [Zg]: \"resolveDynamicComponent\",\n  [Vg]: \"resolveDirective\",\n  [Ig]: \"resolveFilter\",\n  [Wg]: \"withDirectives\",\n  [Mg]: \"renderList\",\n  [WP]: \"renderSlot\",\n  [MP]: \"createSlots\",\n  [Jd]: \"toDisplayString\",\n  [nd]: \"mergeProps\",\n  [Xg]: \"normalizeClass\",\n  [jg]: \"normalizeStyle\",\n  [El]: \"normalizeProps\",\n  [ic]: \"guardReactiveProps\",\n  [Bg]: \"toHandlers\",\n  [Xp]: \"camelize\",\n  [T4]: \"capitalize\",\n  [jp]: \"toHandlerKey\",\n  [rd]: \"setBlockTracking\",\n  [E4]: \"pushScopeId\",\n  [$4]: \"popScopeId\",\n  [Lg]: \"withCtx\",\n  [Q4]: \"unref\",\n  [C4]: \"isRef\",\n  [Ug]: \"withMemo\",\n  [XP]: \"isMemoSame\"\n};\nfunction A4(t) {\n  Object.getOwnPropertySymbols(t).forEach((e) => {\n    Ho[e] = t[e];\n  });\n}\nconst Ln = {\n  start: { line: 1, column: 1, offset: 0 },\n  end: { line: 1, column: 1, offset: 0 },\n  source: \"\"\n};\nfunction R4(t, e = \"\") {\n  return {\n    type: 0,\n    source: e,\n    children: t,\n    helpers: /* @__PURE__ */ new Set(),\n    components: [],\n    directives: [],\n    hoists: [],\n    imports: [],\n    cached: 0,\n    temps: 0,\n    codegenNode: void 0,\n    loc: Ln\n  };\n}\nfunction $l(t, e, n, r, i, s, o, a = !1, l = !1, c = !1, u = Ln) {\n  return t && (a ? (t.helper(Fs), t.helper(Ko(t.inSSR, c))) : t.helper(Go(t.inSSR, c)), o && t.helper(Wg)), {\n    type: 13,\n    tag: e,\n    props: n,\n    children: r,\n    patchFlag: i,\n    dynamicProps: s,\n    directives: o,\n    isBlock: a,\n    disableTracking: l,\n    isComponent: c,\n    loc: u\n  };\n}\nfunction sc(t, e = Ln) {\n  return {\n    type: 17,\n    loc: e,\n    elements: t\n  };\n}\nfunction Gn(t, e = Ln) {\n  return {\n    type: 15,\n    loc: e,\n    properties: t\n  };\n}\nfunction yt(t, e) {\n  return {\n    type: 16,\n    loc: Ln,\n    key: we(t) ? Ee(t, !0) : t,\n    value: e\n  };\n}\nfunction Ee(t, e = !1, n = Ln, r = 0) {\n  return {\n    type: 4,\n    loc: n,\n    content: t,\n    isStatic: e,\n    constType: e ? 3 : r\n  };\n}\nfunction pr(t, e = Ln) {\n  return {\n    type: 8,\n    loc: e,\n    children: t\n  };\n}\nfunction Dt(t, e = [], n = Ln) {\n  return {\n    type: 14,\n    loc: n,\n    callee: t,\n    arguments: e\n  };\n}\nfunction Fo(t, e = void 0, n = !1, r = !1, i = Ln) {\n  return {\n    type: 18,\n    params: t,\n    returns: e,\n    newline: n,\n    isSlot: r,\n    loc: i\n  };\n}\nfunction Bp(t, e, n, r = !0) {\n  return {\n    type: 19,\n    test: t,\n    consequent: e,\n    alternate: n,\n    newline: r,\n    loc: Ln\n  };\n}\nfunction N4(t, e, n = !1) {\n  return {\n    type: 20,\n    index: t,\n    value: e,\n    isVNode: n,\n    loc: Ln\n  };\n}\nfunction D4(t) {\n  return {\n    type: 21,\n    body: t,\n    loc: Ln\n  };\n}\nfunction Go(t, e) {\n  return t || e ? Ag : Rg;\n}\nfunction Ko(t, e) {\n  return t || e ? ZP : VP;\n}\nfunction qg(t, { helper: e, removeHelper: n, inSSR: r }) {\n  t.isBlock || (t.isBlock = !0, n(Go(r, t.isComponent)), e(Fs), e(Ko(r, t.isComponent)));\n}\nconst Y0 = new Uint8Array([123, 123]), z0 = new Uint8Array([125, 125]);\nfunction H0(t) {\n  return t >= 97 && t <= 122 || t >= 65 && t <= 90;\n}\nfunction Nn(t) {\n  return t === 32 || t === 10 || t === 9 || t === 12 || t === 13;\n}\nfunction Ti(t) {\n  return t === 47 || t === 62 || Nn(t);\n}\nfunction id(t) {\n  const e = new Uint8Array(t.length);\n  for (let n = 0; n < t.length; n++)\n    e[n] = t.charCodeAt(n);\n  return e;\n}\nconst Ut = {\n  Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),\n  // CDATA[\n  CdataEnd: new Uint8Array([93, 93, 62]),\n  // ]]>\n  CommentEnd: new Uint8Array([45, 45, 62]),\n  // `-->`\n  ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),\n  // `<\\/script`\n  StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),\n  // `</style`\n  TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101]),\n  // `</title`\n  TextareaEnd: new Uint8Array([\n    60,\n    47,\n    116,\n    101,\n    120,\n    116,\n    97,\n    114,\n    101,\n    97\n  ])\n  // `</textarea\n};\nclass Z4 {\n  constructor(e, n) {\n    this.stack = e, this.cbs = n, this.state = 1, this.buffer = \"\", this.sectionStart = 0, this.index = 0, this.entityStart = 0, this.baseState = 1, this.inRCDATA = !1, this.inXML = !1, this.inVPre = !1, this.newlines = [], this.mode = 0, this.delimiterOpen = Y0, this.delimiterClose = z0, this.delimiterIndex = -1, this.currentSequence = void 0, this.sequenceIndex = 0;\n  }\n  get inSFCRoot() {\n    return this.mode === 2 && this.stack.length === 0;\n  }\n  reset() {\n    this.state = 1, this.mode = 0, this.buffer = \"\", this.sectionStart = 0, this.index = 0, this.baseState = 1, this.inRCDATA = !1, this.currentSequence = void 0, this.newlines.length = 0, this.delimiterOpen = Y0, this.delimiterClose = z0;\n  }\n  /**\n   * Generate Position object with line / column information using recorded\n   * newline positions. We know the index is always going to be an already\n   * processed index, so all the newlines up to this index should have been\n   * recorded.\n   */\n  getPos(e) {\n    let n = 1, r = e + 1;\n    for (let i = this.newlines.length - 1; i >= 0; i--) {\n      const s = this.newlines[i];\n      if (e > s) {\n        n = i + 2, r = e - s;\n        break;\n      }\n    }\n    return {\n      column: r,\n      line: n,\n      offset: e\n    };\n  }\n  peek() {\n    return this.buffer.charCodeAt(this.index + 1);\n  }\n  stateText(e) {\n    e === 60 ? (this.index > this.sectionStart && this.cbs.ontext(this.sectionStart, this.index), this.state = 5, this.sectionStart = this.index) : !this.inVPre && e === this.delimiterOpen[0] && (this.state = 2, this.delimiterIndex = 0, this.stateInterpolationOpen(e));\n  }\n  stateInterpolationOpen(e) {\n    if (e === this.delimiterOpen[this.delimiterIndex])\n      if (this.delimiterIndex === this.delimiterOpen.length - 1) {\n        const n = this.index + 1 - this.delimiterOpen.length;\n        n > this.sectionStart && this.cbs.ontext(this.sectionStart, n), this.state = 3, this.sectionStart = n;\n      } else\n        this.delimiterIndex++;\n    else\n      this.inRCDATA ? (this.state = 32, this.stateInRCDATA(e)) : (this.state = 1, this.stateText(e));\n  }\n  stateInterpolation(e) {\n    e === this.delimiterClose[0] && (this.state = 4, this.delimiterIndex = 0, this.stateInterpolationClose(e));\n  }\n  stateInterpolationClose(e) {\n    e === this.delimiterClose[this.delimiterIndex] ? this.delimiterIndex === this.delimiterClose.length - 1 ? (this.cbs.oninterpolation(this.sectionStart, this.index + 1), this.inRCDATA ? this.state = 32 : this.state = 1, this.sectionStart = this.index + 1) : this.delimiterIndex++ : (this.state = 3, this.stateInterpolation(e));\n  }\n  stateSpecialStartSequence(e) {\n    const n = this.sequenceIndex === this.currentSequence.length;\n    if (!(n ? (\n      // If we are at the end of the sequence, make sure the tag name has ended\n      Ti(e)\n    ) : (\n      // Otherwise, do a case-insensitive comparison\n      (e | 32) === this.currentSequence[this.sequenceIndex]\n    )))\n      this.inRCDATA = !1;\n    else if (!n) {\n      this.sequenceIndex++;\n      return;\n    }\n    this.sequenceIndex = 0, this.state = 6, this.stateInTagName(e);\n  }\n  /** Look for an end tag. For <title> and <textarea>, also decode entities. */\n  stateInRCDATA(e) {\n    if (this.sequenceIndex === this.currentSequence.length) {\n      if (e === 62 || Nn(e)) {\n        const n = this.index - this.currentSequence.length;\n        if (this.sectionStart < n) {\n          const r = this.index;\n          this.index = n, this.cbs.ontext(this.sectionStart, n), this.index = r;\n        }\n        this.sectionStart = n + 2, this.stateInClosingTagName(e), this.inRCDATA = !1;\n        return;\n      }\n      this.sequenceIndex = 0;\n    }\n    (e | 32) === this.currentSequence[this.sequenceIndex] ? this.sequenceIndex += 1 : this.sequenceIndex === 0 ? this.currentSequence === Ut.TitleEnd || this.currentSequence === Ut.TextareaEnd && !this.inSFCRoot ? e === this.delimiterOpen[0] && (this.state = 2, this.delimiterIndex = 0, this.stateInterpolationOpen(e)) : this.fastForwardTo(60) && (this.sequenceIndex = 1) : this.sequenceIndex = +(e === 60);\n  }\n  stateCDATASequence(e) {\n    e === Ut.Cdata[this.sequenceIndex] ? ++this.sequenceIndex === Ut.Cdata.length && (this.state = 28, this.currentSequence = Ut.CdataEnd, this.sequenceIndex = 0, this.sectionStart = this.index + 1) : (this.sequenceIndex = 0, this.state = 23, this.stateInDeclaration(e));\n  }\n  /**\n   * When we wait for one specific character, we can speed things up\n   * by skipping through the buffer until we find it.\n   *\n   * @returns Whether the character was found.\n   */\n  fastForwardTo(e) {\n    for (; ++this.index < this.buffer.length; ) {\n      const n = this.buffer.charCodeAt(this.index);\n      if (n === 10 && this.newlines.push(this.index), n === e)\n        return !0;\n    }\n    return this.index = this.buffer.length - 1, !1;\n  }\n  /**\n   * Comments and CDATA end with `-->` and `]]>`.\n   *\n   * Their common qualities are:\n   * - Their end sequences have a distinct character they start with.\n   * - That character is then repeated, so we have to check multiple repeats.\n   * - All characters but the start character of the sequence can be skipped.\n   */\n  stateInCommentLike(e) {\n    e === this.currentSequence[this.sequenceIndex] ? ++this.sequenceIndex === this.currentSequence.length && (this.currentSequence === Ut.CdataEnd ? this.cbs.oncdata(this.sectionStart, this.index - 2) : this.cbs.oncomment(this.sectionStart, this.index - 2), this.sequenceIndex = 0, this.sectionStart = this.index + 1, this.state = 1) : this.sequenceIndex === 0 ? this.fastForwardTo(this.currentSequence[0]) && (this.sequenceIndex = 1) : e !== this.currentSequence[this.sequenceIndex - 1] && (this.sequenceIndex = 0);\n  }\n  startSpecial(e, n) {\n    this.enterRCDATA(e, n), this.state = 31;\n  }\n  enterRCDATA(e, n) {\n    this.inRCDATA = !0, this.currentSequence = e, this.sequenceIndex = n;\n  }\n  stateBeforeTagName(e) {\n    e === 33 ? (this.state = 22, this.sectionStart = this.index + 1) : e === 63 ? (this.state = 24, this.sectionStart = this.index + 1) : H0(e) ? (this.sectionStart = this.index, this.mode === 0 ? this.state = 6 : this.inSFCRoot ? this.state = 34 : this.inXML ? this.state = 6 : e === 116 ? this.state = 30 : this.state = e === 115 ? 29 : 6) : e === 47 ? this.state = 8 : (this.state = 1, this.stateText(e));\n  }\n  stateInTagName(e) {\n    Ti(e) && this.handleTagName(e);\n  }\n  stateInSFCRootTagName(e) {\n    if (Ti(e)) {\n      const n = this.buffer.slice(this.sectionStart, this.index);\n      n !== \"template\" && this.enterRCDATA(id(\"</\" + n), 0), this.handleTagName(e);\n    }\n  }\n  handleTagName(e) {\n    this.cbs.onopentagname(this.sectionStart, this.index), this.sectionStart = -1, this.state = 11, this.stateBeforeAttrName(e);\n  }\n  stateBeforeClosingTagName(e) {\n    Nn(e) || (e === 62 ? ( true && this.cbs.onerr(14, this.index), this.state = 1, this.sectionStart = this.index + 1) : (this.state = H0(e) ? 9 : 27, this.sectionStart = this.index));\n  }\n  stateInClosingTagName(e) {\n    (e === 62 || Nn(e)) && (this.cbs.onclosetag(this.sectionStart, this.index), this.sectionStart = -1, this.state = 10, this.stateAfterClosingTagName(e));\n  }\n  stateAfterClosingTagName(e) {\n    e === 62 && (this.state = 1, this.sectionStart = this.index + 1);\n  }\n  stateBeforeAttrName(e) {\n    e === 62 ? (this.cbs.onopentagend(this.index), this.inRCDATA ? this.state = 32 : this.state = 1, this.sectionStart = this.index + 1) : e === 47 ? (this.state = 7,  true && this.peek() !== 62 && this.cbs.onerr(22, this.index)) : e === 60 && this.peek() === 47 ? (this.cbs.onopentagend(this.index), this.state = 5, this.sectionStart = this.index) : Nn(e) || ( true && e === 61 && this.cbs.onerr(\n      19,\n      this.index\n    ), this.handleAttrStart(e));\n  }\n  handleAttrStart(e) {\n    e === 118 && this.peek() === 45 ? (this.state = 13, this.sectionStart = this.index) : e === 46 || e === 58 || e === 64 || e === 35 ? (this.cbs.ondirname(this.index, this.index + 1), this.state = 14, this.sectionStart = this.index + 1) : (this.state = 12, this.sectionStart = this.index);\n  }\n  stateInSelfClosingTag(e) {\n    e === 62 ? (this.cbs.onselfclosingtag(this.index), this.state = 1, this.sectionStart = this.index + 1, this.inRCDATA = !1) : Nn(e) || (this.state = 11, this.stateBeforeAttrName(e));\n  }\n  stateInAttrName(e) {\n    e === 61 || Ti(e) ? (this.cbs.onattribname(this.sectionStart, this.index), this.handleAttrNameEnd(e)) :  true && (e === 34 || e === 39 || e === 60) && this.cbs.onerr(\n      17,\n      this.index\n    );\n  }\n  stateInDirName(e) {\n    e === 61 || Ti(e) ? (this.cbs.ondirname(this.sectionStart, this.index), this.handleAttrNameEnd(e)) : e === 58 ? (this.cbs.ondirname(this.sectionStart, this.index), this.state = 14, this.sectionStart = this.index + 1) : e === 46 && (this.cbs.ondirname(this.sectionStart, this.index), this.state = 16, this.sectionStart = this.index + 1);\n  }\n  stateInDirArg(e) {\n    e === 61 || Ti(e) ? (this.cbs.ondirarg(this.sectionStart, this.index), this.handleAttrNameEnd(e)) : e === 91 ? this.state = 15 : e === 46 && (this.cbs.ondirarg(this.sectionStart, this.index), this.state = 16, this.sectionStart = this.index + 1);\n  }\n  stateInDynamicDirArg(e) {\n    e === 93 ? this.state = 14 : (e === 61 || Ti(e)) && (this.cbs.ondirarg(this.sectionStart, this.index + 1), this.handleAttrNameEnd(e),  true && this.cbs.onerr(\n      27,\n      this.index\n    ));\n  }\n  stateInDirModifier(e) {\n    e === 61 || Ti(e) ? (this.cbs.ondirmodifier(this.sectionStart, this.index), this.handleAttrNameEnd(e)) : e === 46 && (this.cbs.ondirmodifier(this.sectionStart, this.index), this.sectionStart = this.index + 1);\n  }\n  handleAttrNameEnd(e) {\n    this.sectionStart = this.index, this.state = 17, this.cbs.onattribnameend(this.index), this.stateAfterAttrName(e);\n  }\n  stateAfterAttrName(e) {\n    e === 61 ? this.state = 18 : e === 47 || e === 62 ? (this.cbs.onattribend(0, this.sectionStart), this.sectionStart = -1, this.state = 11, this.stateBeforeAttrName(e)) : Nn(e) || (this.cbs.onattribend(0, this.sectionStart), this.handleAttrStart(e));\n  }\n  stateBeforeAttrValue(e) {\n    e === 34 ? (this.state = 19, this.sectionStart = this.index + 1) : e === 39 ? (this.state = 20, this.sectionStart = this.index + 1) : Nn(e) || (this.sectionStart = this.index, this.state = 21, this.stateInAttrValueNoQuotes(e));\n  }\n  handleInAttrValue(e, n) {\n    (e === n || this.fastForwardTo(n)) && (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(\n      n === 34 ? 3 : 2,\n      this.index + 1\n    ), this.state = 11);\n  }\n  stateInAttrValueDoubleQuotes(e) {\n    this.handleInAttrValue(e, 34);\n  }\n  stateInAttrValueSingleQuotes(e) {\n    this.handleInAttrValue(e, 39);\n  }\n  stateInAttrValueNoQuotes(e) {\n    Nn(e) || e === 62 ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(1, this.index), this.state = 11, this.stateBeforeAttrName(e)) : ( true && e === 34 || e === 39 || e === 60 || e === 61 || e === 96) && this.cbs.onerr(\n      18,\n      this.index\n    );\n  }\n  stateBeforeDeclaration(e) {\n    e === 91 ? (this.state = 26, this.sequenceIndex = 0) : this.state = e === 45 ? 25 : 23;\n  }\n  stateInDeclaration(e) {\n    (e === 62 || this.fastForwardTo(62)) && (this.state = 1, this.sectionStart = this.index + 1);\n  }\n  stateInProcessingInstruction(e) {\n    (e === 62 || this.fastForwardTo(62)) && (this.cbs.onprocessinginstruction(this.sectionStart, this.index), this.state = 1, this.sectionStart = this.index + 1);\n  }\n  stateBeforeComment(e) {\n    e === 45 ? (this.state = 28, this.currentSequence = Ut.CommentEnd, this.sequenceIndex = 2, this.sectionStart = this.index + 1) : this.state = 23;\n  }\n  stateInSpecialComment(e) {\n    (e === 62 || this.fastForwardTo(62)) && (this.cbs.oncomment(this.sectionStart, this.index), this.state = 1, this.sectionStart = this.index + 1);\n  }\n  stateBeforeSpecialS(e) {\n    e === Ut.ScriptEnd[3] ? this.startSpecial(Ut.ScriptEnd, 4) : e === Ut.StyleEnd[3] ? this.startSpecial(Ut.StyleEnd, 4) : (this.state = 6, this.stateInTagName(e));\n  }\n  stateBeforeSpecialT(e) {\n    e === Ut.TitleEnd[3] ? this.startSpecial(Ut.TitleEnd, 4) : e === Ut.TextareaEnd[3] ? this.startSpecial(Ut.TextareaEnd, 4) : (this.state = 6, this.stateInTagName(e));\n  }\n  startEntity() {\n  }\n  stateInEntity() {\n  }\n  /**\n   * Iterates through the buffer, calling the function corresponding to the current state.\n   *\n   * States that are more likely to be hit are higher up, as a performance improvement.\n   */\n  parse(e) {\n    for (this.buffer = e; this.index < this.buffer.length; ) {\n      const n = this.buffer.charCodeAt(this.index);\n      switch (n === 10 && this.newlines.push(this.index), this.state) {\n        case 1: {\n          this.stateText(n);\n          break;\n        }\n        case 2: {\n          this.stateInterpolationOpen(n);\n          break;\n        }\n        case 3: {\n          this.stateInterpolation(n);\n          break;\n        }\n        case 4: {\n          this.stateInterpolationClose(n);\n          break;\n        }\n        case 31: {\n          this.stateSpecialStartSequence(n);\n          break;\n        }\n        case 32: {\n          this.stateInRCDATA(n);\n          break;\n        }\n        case 26: {\n          this.stateCDATASequence(n);\n          break;\n        }\n        case 19: {\n          this.stateInAttrValueDoubleQuotes(n);\n          break;\n        }\n        case 12: {\n          this.stateInAttrName(n);\n          break;\n        }\n        case 13: {\n          this.stateInDirName(n);\n          break;\n        }\n        case 14: {\n          this.stateInDirArg(n);\n          break;\n        }\n        case 15: {\n          this.stateInDynamicDirArg(n);\n          break;\n        }\n        case 16: {\n          this.stateInDirModifier(n);\n          break;\n        }\n        case 28: {\n          this.stateInCommentLike(n);\n          break;\n        }\n        case 27: {\n          this.stateInSpecialComment(n);\n          break;\n        }\n        case 11: {\n          this.stateBeforeAttrName(n);\n          break;\n        }\n        case 6: {\n          this.stateInTagName(n);\n          break;\n        }\n        case 34: {\n          this.stateInSFCRootTagName(n);\n          break;\n        }\n        case 9: {\n          this.stateInClosingTagName(n);\n          break;\n        }\n        case 5: {\n          this.stateBeforeTagName(n);\n          break;\n        }\n        case 17: {\n          this.stateAfterAttrName(n);\n          break;\n        }\n        case 20: {\n          this.stateInAttrValueSingleQuotes(n);\n          break;\n        }\n        case 18: {\n          this.stateBeforeAttrValue(n);\n          break;\n        }\n        case 8: {\n          this.stateBeforeClosingTagName(n);\n          break;\n        }\n        case 10: {\n          this.stateAfterClosingTagName(n);\n          break;\n        }\n        case 29: {\n          this.stateBeforeSpecialS(n);\n          break;\n        }\n        case 30: {\n          this.stateBeforeSpecialT(n);\n          break;\n        }\n        case 21: {\n          this.stateInAttrValueNoQuotes(n);\n          break;\n        }\n        case 7: {\n          this.stateInSelfClosingTag(n);\n          break;\n        }\n        case 23: {\n          this.stateInDeclaration(n);\n          break;\n        }\n        case 22: {\n          this.stateBeforeDeclaration(n);\n          break;\n        }\n        case 25: {\n          this.stateBeforeComment(n);\n          break;\n        }\n        case 24: {\n          this.stateInProcessingInstruction(n);\n          break;\n        }\n        case 33: {\n          this.stateInEntity();\n          break;\n        }\n      }\n      this.index++;\n    }\n    this.cleanup(), this.finish();\n  }\n  /**\n   * Remove data that has already been consumed from the buffer.\n   */\n  cleanup() {\n    this.sectionStart !== this.index && (this.state === 1 || this.state === 32 && this.sequenceIndex === 0 ? (this.cbs.ontext(this.sectionStart, this.index), this.sectionStart = this.index) : (this.state === 19 || this.state === 20 || this.state === 21) && (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = this.index));\n  }\n  finish() {\n    this.handleTrailingData(), this.cbs.onend();\n  }\n  /** Handle any trailing data. */\n  handleTrailingData() {\n    const e = this.buffer.length;\n    this.sectionStart >= e || (this.state === 28 ? this.currentSequence === Ut.CdataEnd ? this.cbs.oncdata(this.sectionStart, e) : this.cbs.oncomment(this.sectionStart, e) : this.state === 6 || this.state === 11 || this.state === 18 || this.state === 17 || this.state === 12 || this.state === 13 || this.state === 14 || this.state === 15 || this.state === 16 || this.state === 20 || this.state === 19 || this.state === 21 || this.state === 9 || this.cbs.ontext(this.sectionStart, e));\n  }\n  emitCodePoint(e, n) {\n  }\n}\nconst V4 = {\n  COMPILER_IS_ON_ELEMENT: {\n    message: 'Platform-native elements with \"is\" prop will no longer be treated as components in Vue 3 unless the \"is\" value is explicitly prefixed with \"vue:\".',\n    link: \"https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html\"\n  },\n  COMPILER_V_BIND_SYNC: {\n    message: (t) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \\`v-bind:${t}.sync\\` should be changed to \\`v-model:${t}\\`.`,\n    link: \"https://v3-migration.vuejs.org/breaking-changes/v-model.html\"\n  },\n  COMPILER_V_BIND_OBJECT_ORDER: {\n    message: 'v-bind=\"obj\" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.',\n    link: \"https://v3-migration.vuejs.org/breaking-changes/v-bind.html\"\n  },\n  COMPILER_V_ON_NATIVE: {\n    message: \".native modifier for v-on has been removed as is no longer necessary.\",\n    link: \"https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html\"\n  },\n  COMPILER_V_IF_V_FOR_PRECEDENCE: {\n    message: \"v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.\",\n    link: \"https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html\"\n  },\n  COMPILER_NATIVE_TEMPLATE: {\n    message: \"<template> with no special directives will render as a native template element instead of its inner content in Vue 3.\"\n  },\n  COMPILER_INLINE_TEMPLATE: {\n    message: '\"inline-template\" has been removed in Vue 3.',\n    link: \"https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html\"\n  },\n  COMPILER_FILTERS: {\n    message: 'filters have been removed in Vue 3. The \"|\" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.',\n    link: \"https://v3-migration.vuejs.org/breaking-changes/filters.html\"\n  }\n};\nfunction Lp(t, { compatConfig: e }) {\n  const n = e && e[t];\n  return t === \"MODE\" ? n || 3 : n;\n}\nfunction es(t, e) {\n  const n = Lp(\"MODE\", e), r = Lp(t, e);\n  return n === 3 ? r === !0 : r !== !1;\n}\nfunction Jo(t, e, n, ...r) {\n  const i = es(t, e);\n  return  true && i && sd(t, e, n, ...r), i;\n}\nfunction sd(t, e, n, ...r) {\n  if (Lp(t, e) === \"suppress-warning\")\n    return;\n  const { message: s, link: o } = V4[t], a = `(deprecation ${t}) ${typeof s == \"function\" ? s(...r) : s}${o ? `\n  Details: ${o}` : \"\"}`, l = new SyntaxError(a);\n  l.code = t, n && (l.loc = n), e.onWarn(l);\n}\nfunction Yg(t) {\n  throw t;\n}\nfunction jP(t) {\n   true && console.warn(`[Vue warn] ${t.message}`);\n}\nfunction Ge(t, e, n, r) {\n  const i =  true ? (n || I4)[t] + (r || \"\") : 0, s = new SyntaxError(String(i));\n  return s.code = t, s.loc = e, s;\n}\nconst I4 = {\n  // parse errors\n  0: \"Illegal comment.\",\n  1: \"CDATA section is allowed only in XML context.\",\n  2: \"Duplicate attribute.\",\n  3: \"End tag cannot have attributes.\",\n  4: \"Illegal '/' in tags.\",\n  5: \"Unexpected EOF in tag.\",\n  6: \"Unexpected EOF in CDATA section.\",\n  7: \"Unexpected EOF in comment.\",\n  8: \"Unexpected EOF in script.\",\n  9: \"Unexpected EOF in tag.\",\n  10: \"Incorrectly closed comment.\",\n  11: \"Incorrectly opened comment.\",\n  12: \"Illegal tag name. Use '&lt;' to print '<'.\",\n  13: \"Attribute value was expected.\",\n  14: \"End tag name was expected.\",\n  15: \"Whitespace was expected.\",\n  16: \"Unexpected '<!--' in comment.\",\n  17: `Attribute name cannot contain U+0022 (\"), U+0027 ('), and U+003C (<).`,\n  18: \"Unquoted attribute value cannot contain U+0022 (\\\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).\",\n  19: \"Attribute name cannot start with '='.\",\n  21: \"'<?' is allowed only in XML context.\",\n  20: \"Unexpected null character.\",\n  22: \"Illegal '/' in tags.\",\n  // Vue-specific parse errors\n  23: \"Invalid end tag.\",\n  24: \"Element is missing end tag.\",\n  25: \"Interpolation end sign was not found.\",\n  27: \"End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.\",\n  26: \"Legal directive name was expected.\",\n  // transform errors\n  28: \"v-if/v-else-if is missing expression.\",\n  29: \"v-if/else branches must use unique keys.\",\n  30: \"v-else/v-else-if has no adjacent v-if or v-else-if.\",\n  31: \"v-for is missing expression.\",\n  32: \"v-for has invalid expression.\",\n  33: \"<template v-for> key should be placed on the <template> tag.\",\n  34: \"v-bind is missing expression.\",\n  52: \"v-bind with same-name shorthand only allows static argument.\",\n  35: \"v-on is missing expression.\",\n  36: \"Unexpected custom directive on <slot> outlet.\",\n  37: \"Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.\",\n  38: \"Duplicate slot names found. \",\n  39: \"Extraneous children found when component already has explicitly named default slot. These children will be ignored.\",\n  40: \"v-slot can only be used on components or <template> tags.\",\n  41: \"v-model is missing expression.\",\n  42: \"v-model value must be a valid JavaScript member expression.\",\n  43: \"v-model cannot be used on v-for or v-slot scope variables because they are not writable.\",\n  44: `v-model cannot be used on a prop, because local prop bindings are not writable.\nUse a v-bind binding combined with a v-on listener that emits update:x event instead.`,\n  45: \"Error parsing JavaScript expression: \",\n  46: \"<KeepAlive> expects exactly one child component.\",\n  51: \"@vnode-* hooks in templates are no longer supported. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support has been removed in 3.4.\",\n  // generic errors\n  47: '\"prefixIdentifiers\" option is not supported in this build of compiler.',\n  48: \"ES module mode is not supported in this build of compiler.\",\n  49: '\"cacheHandlers\" option is only supported when the \"prefixIdentifiers\" option is enabled.',\n  50: '\"scopeId\" option is only supported in module mode.',\n  // just to fulfill types\n  53: \"\"\n}, xn = (t) => t.type === 4 && t.isStatic;\nfunction BP(t) {\n  switch (t) {\n    case \"Teleport\":\n    case \"teleport\":\n      return Ga;\n    case \"Suspense\":\n    case \"suspense\":\n      return Cg;\n    case \"KeepAlive\":\n    case \"keep-alive\":\n      return td;\n    case \"BaseTransition\":\n    case \"base-transition\":\n      return DP;\n  }\n}\nconst W4 = /^\\d|[^\\$\\w]/, zg = (t) => !W4.test(t), M4 = /[A-Za-z_$\\xA0-\\uFFFF]/, X4 = /[\\.\\?\\w$\\xA0-\\uFFFF]/, j4 = /\\s+[.[]\\s*|\\s*[.[]\\s+/g, B4 = (t) => {\n  t = t.trim().replace(j4, (o) => o.trim());\n  let e = 0, n = [], r = 0, i = 0, s = null;\n  for (let o = 0; o < t.length; o++) {\n    const a = t.charAt(o);\n    switch (e) {\n      case 0:\n        if (a === \"[\")\n          n.push(e), e = 1, r++;\n        else if (a === \"(\")\n          n.push(e), e = 2, i++;\n        else if (!(o === 0 ? M4 : X4).test(a))\n          return !1;\n        break;\n      case 1:\n        a === \"'\" || a === '\"' || a === \"`\" ? (n.push(e), e = 3, s = a) : a === \"[\" ? r++ : a === \"]\" && (--r || (e = n.pop()));\n        break;\n      case 2:\n        if (a === \"'\" || a === '\"' || a === \"`\")\n          n.push(e), e = 3, s = a;\n        else if (a === \"(\")\n          i++;\n        else if (a === \")\") {\n          if (o === t.length - 1)\n            return !1;\n          --i || (e = n.pop());\n        }\n        break;\n      case 3:\n        a === s && (e = n.pop(), s = null);\n        break;\n    }\n  }\n  return !r && !i;\n}, LP = B4;\nfunction F0(t, e) {\n  if (!t)\n    throw new Error(e || \"unexpected compiler condition\");\n}\nfunction zn(t, e, n = !1) {\n  for (let r = 0; r < t.props.length; r++) {\n    const i = t.props[r];\n    if (i.type === 7 && (n || i.exp) && (we(e) ? i.name === e : e.test(i.name)))\n      return i;\n  }\n}\nfunction Ql(t, e, n = !1, r = !1) {\n  for (let i = 0; i < t.props.length; i++) {\n    const s = t.props[i];\n    if (s.type === 6) {\n      if (n)\n        continue;\n      if (s.name === e && (s.value || r))\n        return s;\n    } else if (s.name === \"bind\" && (s.exp || r) && Li(s.arg, e))\n      return s;\n  }\n}\nfunction Li(t, e) {\n  return !!(t && xn(t) && t.content === e);\n}\nfunction L4(t) {\n  return t.props.some(\n    (e) => e.type === 7 && e.name === \"bind\" && (!e.arg || // v-bind=\"obj\"\n    e.arg.type !== 4 || // v-bind:[_ctx.foo]\n    !e.arg.isStatic)\n    // v-bind:[foo]\n  );\n}\nfunction eh(t) {\n  return t.type === 5 || t.type === 2;\n}\nfunction U4(t) {\n  return t.type === 7 && t.name === \"slot\";\n}\nfunction od(t) {\n  return t.type === 1 && t.tagType === 3;\n}\nfunction ad(t) {\n  return t.type === 1 && t.tagType === 2;\n}\nconst q4 = /* @__PURE__ */ new Set([El, ic]);\nfunction UP(t, e = []) {\n  if (t && !we(t) && t.type === 14) {\n    const n = t.callee;\n    if (!we(n) && q4.has(n))\n      return UP(\n        t.arguments[0],\n        e.concat(t)\n      );\n  }\n  return [t, e];\n}\nfunction ld(t, e, n) {\n  let r, i = t.type === 13 ? t.props : t.arguments[2], s = [], o;\n  if (i && !we(i) && i.type === 14) {\n    const a = UP(i);\n    i = a[0], s = a[1], o = s[s.length - 1];\n  }\n  if (i == null || we(i))\n    r = Gn([e]);\n  else if (i.type === 14) {\n    const a = i.arguments[0];\n    !we(a) && a.type === 15 ? G0(e, a) || a.properties.unshift(e) : i.callee === Bg ? r = Dt(n.helper(nd), [\n      Gn([e]),\n      i\n    ]) : i.arguments.unshift(Gn([e])), !r && (r = i);\n  } else\n    i.type === 15 ? (G0(e, i) || i.properties.unshift(e), r = i) : (r = Dt(n.helper(nd), [\n      Gn([e]),\n      i\n    ]), o && o.callee === ic && (o = s[s.length - 2]));\n  t.type === 13 ? o ? o.arguments[0] = r : t.props = r : o ? o.arguments[0] = r : t.arguments[2] = r;\n}\nfunction G0(t, e) {\n  let n = !1;\n  if (t.key.type === 4) {\n    const r = t.key.content;\n    n = e.properties.some(\n      (i) => i.key.type === 4 && i.key.content === r\n    );\n  }\n  return n;\n}\nfunction Cl(t, e) {\n  return `_${e}_${t.replace(/[^\\w]/g, (n, r) => n === \"-\" ? \"_\" : t.charCodeAt(r).toString())}`;\n}\nfunction Y4(t) {\n  return t.type === 14 && t.callee === Ug ? t.arguments[1].returns : t;\n}\nconst z4 = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/, qP = {\n  parseMode: \"base\",\n  ns: 0,\n  delimiters: [\"{{\", \"}}\"],\n  getNamespace: () => 0,\n  isVoidTag: zc,\n  isPreTag: zc,\n  isCustomElement: zc,\n  onError: Yg,\n  onWarn: jP,\n  comments: \"development\" !== \"production\",\n  prefixIdentifiers: !1\n};\nlet Ie = qP, Al = null, Ws = \"\", en = null, Me = null, bn = \"\", Jr = -1, bs = -1, cd = 0, Vi = !1, Up = null;\nconst vt = [], at = new Z4(vt, {\n  onerr: mn,\n  ontext(t, e) {\n    Uc(qt(t, e), t, e);\n  },\n  ontextentity(t, e, n) {\n    Uc(t, e, n);\n  },\n  oninterpolation(t, e) {\n    if (Vi)\n      return Uc(qt(t, e), t, e);\n    let n = t + at.delimiterOpen.length, r = e - at.delimiterClose.length;\n    for (; Nn(Ws.charCodeAt(n)); )\n      n++;\n    for (; Nn(Ws.charCodeAt(r - 1)); )\n      r--;\n    let i = qt(n, r);\n    i.includes(\"&\") && (i = Ie.decodeEntities(i, !1)), qp({\n      type: 5,\n      content: pu(i, !1, Rt(n, r)),\n      loc: Rt(t, e)\n    });\n  },\n  onopentagname(t, e) {\n    const n = qt(t, e);\n    en = {\n      type: 1,\n      tag: n,\n      ns: Ie.getNamespace(n, vt[0], Ie.ns),\n      tagType: 0,\n      // will be refined on tag close\n      props: [],\n      children: [],\n      loc: Rt(t - 1, e),\n      codegenNode: void 0\n    };\n  },\n  onopentagend(t) {\n    J0(t);\n  },\n  onclosetag(t, e) {\n    const n = qt(t, e);\n    if (!Ie.isVoidTag(n)) {\n      let r = !1;\n      for (let i = 0; i < vt.length; i++)\n        if (vt[i].tag.toLowerCase() === n.toLowerCase()) {\n          r = !0, i > 0 && mn(24, vt[0].loc.start.offset);\n          for (let o = 0; o <= i; o++) {\n            const a = vt.shift();\n            hu(a, e, o < i);\n          }\n          break;\n        }\n      r || mn(23, YP(t, 60));\n    }\n  },\n  onselfclosingtag(t) {\n    var e;\n    const n = en.tag;\n    en.isSelfClosing = !0, J0(t), ((e = vt[0]) == null ? void 0 : e.tag) === n && hu(vt.shift(), t);\n  },\n  onattribname(t, e) {\n    Me = {\n      type: 6,\n      name: qt(t, e),\n      nameLoc: Rt(t, e),\n      value: void 0,\n      loc: Rt(t)\n    };\n  },\n  ondirname(t, e) {\n    const n = qt(t, e), r = n === \".\" || n === \":\" ? \"bind\" : n === \"@\" ? \"on\" : n === \"#\" ? \"slot\" : n.slice(2);\n    if (!Vi && r === \"\" && mn(26, t), Vi || r === \"\")\n      Me = {\n        type: 6,\n        name: n,\n        nameLoc: Rt(t, e),\n        value: void 0,\n        loc: Rt(t)\n      };\n    else if (Me = {\n      type: 7,\n      name: r,\n      rawName: n,\n      exp: void 0,\n      arg: void 0,\n      modifiers: n === \".\" ? [\"prop\"] : [],\n      loc: Rt(t)\n    }, r === \"pre\") {\n      Vi = at.inVPre = !0, Up = en;\n      const i = en.props;\n      for (let s = 0; s < i.length; s++)\n        i[s].type === 7 && (i[s] = r7(i[s]));\n    }\n  },\n  ondirarg(t, e) {\n    if (t === e)\n      return;\n    const n = qt(t, e);\n    if (Vi)\n      Me.name += n, $s(Me.nameLoc, e);\n    else {\n      const r = n[0] !== \"[\";\n      Me.arg = pu(\n        r ? n : n.slice(1, -1),\n        r,\n        Rt(t, e),\n        r ? 3 : 0\n      );\n    }\n  },\n  ondirmodifier(t, e) {\n    const n = qt(t, e);\n    if (Vi)\n      Me.name += \".\" + n, $s(Me.nameLoc, e);\n    else if (Me.name === \"slot\") {\n      const r = Me.arg;\n      r && (r.content += \".\" + n, $s(r.loc, e));\n    } else\n      Me.modifiers.push(n);\n  },\n  onattribdata(t, e) {\n    bn += qt(t, e), Jr < 0 && (Jr = t), bs = e;\n  },\n  onattribentity(t, e, n) {\n    bn += t, Jr < 0 && (Jr = e), bs = n;\n  },\n  onattribnameend(t) {\n    const e = Me.loc.start.offset, n = qt(e, t);\n    Me.type === 7 && (Me.rawName = n), en.props.some(\n      (r) => (r.type === 7 ? r.rawName : r.name) === n\n    ) && mn(2, e);\n  },\n  onattribend(t, e) {\n    if (en && Me) {\n      if ($s(Me.loc, e), t !== 0)\n        if (bn.includes(\"&\") && (bn = Ie.decodeEntities(\n          bn,\n          !0\n        )), Me.type === 6)\n          Me.name === \"class\" && (bn = HP(bn).trim()), t === 1 && !bn && mn(13, e), Me.value = {\n            type: 2,\n            content: bn,\n            loc: t === 1 ? Rt(Jr, bs) : Rt(Jr - 1, bs + 1)\n          }, at.inSFCRoot && en.tag === \"template\" && Me.name === \"lang\" && bn && bn !== \"html\" && at.enterRCDATA(id(\"</template\"), 0);\n        else {\n          let n = 0;\n          Me.exp = pu(\n            bn,\n            !1,\n            Rt(Jr, bs),\n            0,\n            n\n          ), Me.name === \"for\" && (Me.forParseResult = F4(Me.exp));\n          let r = -1;\n          Me.name === \"bind\" && (r = Me.modifiers.indexOf(\"sync\")) > -1 && Jo(\n            \"COMPILER_V_BIND_SYNC\",\n            Ie,\n            Me.loc,\n            Me.rawName\n          ) && (Me.name = \"model\", Me.modifiers.splice(r, 1));\n        }\n      (Me.type !== 7 || Me.name !== \"pre\") && en.props.push(Me);\n    }\n    bn = \"\", Jr = bs = -1;\n  },\n  oncomment(t, e) {\n    Ie.comments && qp({\n      type: 3,\n      content: qt(t, e),\n      loc: Rt(t - 4, e + 3)\n    });\n  },\n  onend() {\n    const t = Ws.length;\n    if ( true && at.state !== 1)\n      switch (at.state) {\n        case 5:\n        case 8:\n          mn(5, t);\n          break;\n        case 3:\n        case 4:\n          mn(\n            25,\n            at.sectionStart\n          );\n          break;\n        case 28:\n          at.currentSequence === Ut.CdataEnd ? mn(6, t) : mn(7, t);\n          break;\n        case 6:\n        case 7:\n        case 9:\n        case 11:\n        case 12:\n        case 13:\n        case 14:\n        case 15:\n        case 16:\n        case 17:\n        case 18:\n        case 19:\n        case 20:\n        case 21:\n          mn(9, t);\n          break;\n      }\n    for (let e = 0; e < vt.length; e++)\n      hu(vt[e], t - 1), mn(24, vt[e].loc.start.offset);\n  },\n  oncdata(t, e) {\n    vt[0].ns !== 0 ? Uc(qt(t, e), t, e) : mn(1, t - 9);\n  },\n  onprocessinginstruction(t) {\n    (vt[0] ? vt[0].ns : Ie.ns) === 0 && mn(\n      21,\n      t - 1\n    );\n  }\n}), K0 = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/, H4 = /^\\(|\\)$/g;\nfunction F4(t) {\n  const e = t.loc, n = t.content, r = n.match(z4);\n  if (!r)\n    return;\n  const [, i, s] = r, o = (d, f, h = !1) => {\n    const p = e.start.offset + f, O = p + d.length;\n    return pu(\n      d,\n      !1,\n      Rt(p, O),\n      0,\n      h ? 1 : 0\n      /* Normal */\n    );\n  }, a = {\n    source: o(s.trim(), n.indexOf(s, i.length)),\n    value: void 0,\n    key: void 0,\n    index: void 0,\n    finalized: !1\n  };\n  let l = i.trim().replace(H4, \"\").trim();\n  const c = i.indexOf(l), u = l.match(K0);\n  if (u) {\n    l = l.replace(K0, \"\").trim();\n    const d = u[1].trim();\n    let f;\n    if (d && (f = n.indexOf(d, c + l.length), a.key = o(d, f, !0)), u[2]) {\n      const h = u[2].trim();\n      h && (a.index = o(\n        h,\n        n.indexOf(\n          h,\n          a.key ? f + d.length : c + l.length\n        ),\n        !0\n      ));\n    }\n  }\n  return l && (a.value = o(l, c, !0)), a;\n}\nfunction qt(t, e) {\n  return Ws.slice(t, e);\n}\nfunction J0(t) {\n  at.inSFCRoot && (en.innerLoc = Rt(t + 1, t + 1)), qp(en);\n  const { tag: e, ns: n } = en;\n  n === 0 && Ie.isPreTag(e) && cd++, Ie.isVoidTag(e) ? hu(en, t) : (vt.unshift(en), (n === 1 || n === 2) && (at.inXML = !0)), en = null;\n}\nfunction Uc(t, e, n) {\n  var r;\n  {\n    const o = (r = vt[0]) == null ? void 0 : r.tag;\n    o !== \"script\" && o !== \"style\" && t.includes(\"&\") && (t = Ie.decodeEntities(t, !1));\n  }\n  const i = vt[0] || Al, s = i.children[i.children.length - 1];\n  (s == null ? void 0 : s.type) === 2 ? (s.content += t, $s(s.loc, n)) : i.children.push({\n    type: 2,\n    content: t,\n    loc: Rt(e, n)\n  });\n}\nfunction hu(t, e, n = !1) {\n  n ? $s(t.loc, YP(e, 60)) : $s(t.loc, e + 1), at.inSFCRoot && (t.children.length ? t.innerLoc.end = $e({}, t.children[t.children.length - 1].loc.end) : t.innerLoc.end = $e({}, t.innerLoc.start), t.innerLoc.source = qt(\n    t.innerLoc.start.offset,\n    t.innerLoc.end.offset\n  ));\n  const { tag: r, ns: i } = t;\n  Vi || (r === \"slot\" ? t.tagType = 2 : ey(t) ? t.tagType = 3 : K4(t) && (t.tagType = 1)), at.inRCDATA || (t.children = zP(t.children, t.tag)), i === 0 && Ie.isPreTag(r) && cd--, Up === t && (Vi = at.inVPre = !1, Up = null), at.inXML && (vt[0] ? vt[0].ns : Ie.ns) === 0 && (at.inXML = !1);\n  {\n    const s = t.props;\n    if ( true && es(\n      \"COMPILER_V_IF_V_FOR_PRECEDENCE\",\n      Ie\n    )) {\n      let a = !1, l = !1;\n      for (let c = 0; c < s.length; c++) {\n        const u = s[c];\n        if (u.type === 7 && (u.name === \"if\" ? a = !0 : u.name === \"for\" && (l = !0)), a && l) {\n          sd(\n            \"COMPILER_V_IF_V_FOR_PRECEDENCE\",\n            Ie,\n            t.loc\n          );\n          break;\n        }\n      }\n    }\n    if (!at.inSFCRoot && es(\n      \"COMPILER_NATIVE_TEMPLATE\",\n      Ie\n    ) && t.tag === \"template\" && !ey(t)) {\n       true && sd(\n        \"COMPILER_NATIVE_TEMPLATE\",\n        Ie,\n        t.loc\n      );\n      const a = vt[0] || Al, l = a.children.indexOf(t);\n      a.children.splice(l, 1, ...t.children);\n    }\n    const o = s.find(\n      (a) => a.type === 6 && a.name === \"inline-template\"\n    );\n    o && Jo(\n      \"COMPILER_INLINE_TEMPLATE\",\n      Ie,\n      o.loc\n    ) && t.children.length && (o.value = {\n      type: 2,\n      content: qt(\n        t.children[0].loc.start.offset,\n        t.children[t.children.length - 1].loc.end.offset\n      ),\n      loc: o.loc\n    });\n  }\n}\nfunction YP(t, e) {\n  let n = t;\n  for (; Ws.charCodeAt(n) !== e && n >= 0; )\n    n--;\n  return n;\n}\nconst G4 = /* @__PURE__ */ new Set([\"if\", \"else\", \"else-if\", \"for\", \"slot\"]);\nfunction ey({ tag: t, props: e }) {\n  if (t === \"template\") {\n    for (let n = 0; n < e.length; n++)\n      if (e[n].type === 7 && G4.has(e[n].name))\n        return !0;\n  }\n  return !1;\n}\nfunction K4({ tag: t, props: e }) {\n  var n;\n  if (Ie.isCustomElement(t))\n    return !1;\n  if (t === \"component\" || J4(t.charCodeAt(0)) || BP(t) || (n = Ie.isBuiltInComponent) != null && n.call(Ie, t) || Ie.isNativeTag && !Ie.isNativeTag(t))\n    return !0;\n  for (let r = 0; r < e.length; r++) {\n    const i = e[r];\n    if (i.type === 6) {\n      if (i.name === \"is\" && i.value) {\n        if (i.value.content.startsWith(\"vue:\"))\n          return !0;\n        if (Jo(\n          \"COMPILER_IS_ON_ELEMENT\",\n          Ie,\n          i.loc\n        ))\n          return !0;\n      }\n    } else if (\n      // :is on plain element - only treat as component in compat mode\n      i.name === \"bind\" && Li(i.arg, \"is\") && Jo(\n        \"COMPILER_IS_ON_ELEMENT\",\n        Ie,\n        i.loc\n      )\n    )\n      return !0;\n  }\n  return !1;\n}\nfunction J4(t) {\n  return t > 64 && t < 91;\n}\nconst e7 = /\\r\\n/g;\nfunction zP(t, e) {\n  var n, r;\n  const i = Ie.whitespace !== \"preserve\";\n  let s = !1;\n  for (let o = 0; o < t.length; o++) {\n    const a = t[o];\n    if (a.type === 2)\n      if (cd)\n        a.content = a.content.replace(e7, `\n`);\n      else if (t7(a.content)) {\n        const l = (n = t[o - 1]) == null ? void 0 : n.type, c = (r = t[o + 1]) == null ? void 0 : r.type;\n        !l || !c || i && (l === 3 && (c === 3 || c === 1) || l === 1 && (c === 3 || c === 1 && n7(a.content))) ? (s = !0, t[o] = null) : a.content = \" \";\n      } else\n        i && (a.content = HP(a.content));\n  }\n  if (cd && e && Ie.isPreTag(e)) {\n    const o = t[0];\n    o && o.type === 2 && (o.content = o.content.replace(/^\\r?\\n/, \"\"));\n  }\n  return s ? t.filter(Boolean) : t;\n}\nfunction t7(t) {\n  for (let e = 0; e < t.length; e++)\n    if (!Nn(t.charCodeAt(e)))\n      return !1;\n  return !0;\n}\nfunction n7(t) {\n  for (let e = 0; e < t.length; e++) {\n    const n = t.charCodeAt(e);\n    if (n === 10 || n === 13)\n      return !0;\n  }\n  return !1;\n}\nfunction HP(t) {\n  let e = \"\", n = !1;\n  for (let r = 0; r < t.length; r++)\n    Nn(t.charCodeAt(r)) ? n || (e += \" \", n = !0) : (e += t[r], n = !1);\n  return e;\n}\nfunction qp(t) {\n  (vt[0] || Al).children.push(t);\n}\nfunction Rt(t, e) {\n  return {\n    start: at.getPos(t),\n    // @ts-expect-error allow late attachment\n    end: e == null ? e : at.getPos(e),\n    // @ts-expect-error allow late attachment\n    source: e == null ? e : qt(t, e)\n  };\n}\nfunction $s(t, e) {\n  t.end = at.getPos(e), t.source = qt(t.start.offset, e);\n}\nfunction r7(t) {\n  const e = {\n    type: 6,\n    name: t.rawName,\n    nameLoc: Rt(\n      t.loc.start.offset,\n      t.loc.start.offset + t.rawName.length\n    ),\n    value: void 0,\n    loc: t.loc\n  };\n  if (t.exp) {\n    const n = t.exp.loc;\n    n.end.offset < t.loc.end.offset && (n.start.offset--, n.start.column--, n.end.offset++, n.end.column++), e.value = {\n      type: 2,\n      content: t.exp.content,\n      loc: n\n    };\n  }\n  return e;\n}\nfunction pu(t, e = !1, n, r = 0, i = 0) {\n  return Ee(t, e, n, r);\n}\nfunction mn(t, e, n) {\n  Ie.onError(\n    Ge(t, Rt(e, e), void 0, n)\n  );\n}\nfunction i7() {\n  at.reset(), en = null, Me = null, bn = \"\", Jr = -1, bs = -1, vt.length = 0;\n}\nfunction s7(t, e) {\n  if (i7(), Ws = t, Ie = $e({}, qP), e) {\n    let i;\n    for (i in e)\n      e[i] != null && (Ie[i] = e[i]);\n  }\n  if ( true && !Ie.decodeEntities)\n    throw new Error(\n      \"[@vue/compiler-core] decodeEntities option is required in browser builds.\"\n    );\n  at.mode = Ie.parseMode === \"html\" ? 1 : Ie.parseMode === \"sfc\" ? 2 : 0, at.inXML = Ie.ns === 1 || Ie.ns === 2;\n  const n = e == null ? void 0 : e.delimiters;\n  n && (at.delimiterOpen = id(n[0]), at.delimiterClose = id(n[1]));\n  const r = Al = R4([], t);\n  return at.parse(Ws), r.loc = Rt(0, t.length), r.children = zP(r.children), Al = null, r;\n}\nfunction o7(t, e) {\n  Ou(\n    t,\n    e,\n    // Root node is unfortunately non-hoistable due to potential parent\n    // fallthrough attributes.\n    FP(t, t.children[0])\n  );\n}\nfunction FP(t, e) {\n  const { children: n } = t;\n  return n.length === 1 && e.type === 1 && !ad(e);\n}\nfunction Ou(t, e, n = !1) {\n  const { children: r } = t, i = r.length;\n  let s = 0;\n  for (let o = 0; o < r.length; o++) {\n    const a = r[o];\n    if (a.type === 1 && a.tagType === 0) {\n      const l = n ? 0 : Kn(a, e);\n      if (l > 0) {\n        if (l >= 2) {\n          a.codegenNode.patchFlag = -1 + ( true ? \" /* HOISTED */\" : 0), a.codegenNode = e.hoist(a.codegenNode), s++;\n          continue;\n        }\n      } else {\n        const c = a.codegenNode;\n        if (c.type === 13) {\n          const u = e_(c);\n          if ((!u || u === 512 || u === 1) && KP(a, e) >= 2) {\n            const d = JP(a);\n            d && (c.props = e.hoist(d));\n          }\n          c.dynamicProps && (c.dynamicProps = e.hoist(c.dynamicProps));\n        }\n      }\n    }\n    if (a.type === 1) {\n      const l = a.tagType === 1;\n      l && e.scopes.vSlot++, Ou(a, e), l && e.scopes.vSlot--;\n    } else if (a.type === 11)\n      Ou(a, e, a.children.length === 1);\n    else if (a.type === 9)\n      for (let l = 0; l < a.branches.length; l++)\n        Ou(\n          a.branches[l],\n          e,\n          a.branches[l].children.length === 1\n        );\n  }\n  if (s && e.transformHoist && e.transformHoist(r, e, t), s && s === i && t.type === 1 && t.tagType === 0 && t.codegenNode && t.codegenNode.type === 13 && ie(t.codegenNode.children)) {\n    const o = e.hoist(\n      sc(t.codegenNode.children)\n    );\n    e.hmr && (o.content = `[...${o.content}]`), t.codegenNode.children = o;\n  }\n}\nfunction Kn(t, e) {\n  const { constantCache: n } = e;\n  switch (t.type) {\n    case 1:\n      if (t.tagType !== 0)\n        return 0;\n      const r = n.get(t);\n      if (r !== void 0)\n        return r;\n      const i = t.codegenNode;\n      if (i.type !== 13 || i.isBlock && t.tag !== \"svg\" && t.tag !== \"foreignObject\")\n        return 0;\n      if (e_(i))\n        return n.set(t, 0), 0;\n      {\n        let a = 3;\n        const l = KP(t, e);\n        if (l === 0)\n          return n.set(t, 0), 0;\n        l < a && (a = l);\n        for (let c = 0; c < t.children.length; c++) {\n          const u = Kn(t.children[c], e);\n          if (u === 0)\n            return n.set(t, 0), 0;\n          u < a && (a = u);\n        }\n        if (a > 1)\n          for (let c = 0; c < t.props.length; c++) {\n            const u = t.props[c];\n            if (u.type === 7 && u.name === \"bind\" && u.exp) {\n              const d = Kn(u.exp, e);\n              if (d === 0)\n                return n.set(t, 0), 0;\n              d < a && (a = d);\n            }\n          }\n        if (i.isBlock) {\n          for (let c = 0; c < t.props.length; c++)\n            if (t.props[c].type === 7)\n              return n.set(t, 0), 0;\n          e.removeHelper(Fs), e.removeHelper(\n            Ko(e.inSSR, i.isComponent)\n          ), i.isBlock = !1, e.helper(Go(e.inSSR, i.isComponent));\n        }\n        return n.set(t, a), a;\n      }\n    case 2:\n    case 3:\n      return 3;\n    case 9:\n    case 11:\n    case 10:\n      return 0;\n    case 5:\n    case 12:\n      return Kn(t.content, e);\n    case 4:\n      return t.constType;\n    case 8:\n      let o = 3;\n      for (let a = 0; a < t.children.length; a++) {\n        const l = t.children[a];\n        if (we(l) || Or(l))\n          continue;\n        const c = Kn(l, e);\n        if (c === 0)\n          return 0;\n        c < o && (o = c);\n      }\n      return o;\n    default:\n      return \"development\", 0;\n  }\n}\nconst a7 = /* @__PURE__ */ new Set([\n  Xg,\n  jg,\n  El,\n  ic\n]);\nfunction GP(t, e) {\n  if (t.type === 14 && !we(t.callee) && a7.has(t.callee)) {\n    const n = t.arguments[0];\n    if (n.type === 4)\n      return Kn(n, e);\n    if (n.type === 14)\n      return GP(n, e);\n  }\n  return 0;\n}\nfunction KP(t, e) {\n  let n = 3;\n  const r = JP(t);\n  if (r && r.type === 15) {\n    const { properties: i } = r;\n    for (let s = 0; s < i.length; s++) {\n      const { key: o, value: a } = i[s], l = Kn(o, e);\n      if (l === 0)\n        return l;\n      l < n && (n = l);\n      let c;\n      if (a.type === 4 ? c = Kn(a, e) : a.type === 14 ? c = GP(a, e) : c = 0, c === 0)\n        return c;\n      c < n && (n = c);\n    }\n  }\n  return n;\n}\nfunction JP(t) {\n  const e = t.codegenNode;\n  if (e.type === 13)\n    return e.props;\n}\nfunction e_(t) {\n  const e = t.patchFlag;\n  return e ? parseInt(e, 10) : void 0;\n}\nfunction l7(t, {\n  filename: e = \"\",\n  prefixIdentifiers: n = !1,\n  hoistStatic: r = !1,\n  hmr: i = !1,\n  cacheHandlers: s = !1,\n  nodeTransforms: o = [],\n  directiveTransforms: a = {},\n  transformHoist: l = null,\n  isBuiltInComponent: c = it,\n  isCustomElement: u = it,\n  expressionPlugins: d = [],\n  scopeId: f = null,\n  slotted: h = !0,\n  ssr: p = !1,\n  inSSR: O = !1,\n  ssrCssVars: m = \"\",\n  bindingMetadata: y = Ve,\n  inline: b = !1,\n  isTS: g = !1,\n  onError: v = Yg,\n  onWarn: S = jP,\n  compatConfig: w\n}) {\n  const k = e.replace(/\\?.*$/, \"\").match(/([^/\\\\]+)\\.\\w+$/), _ = {\n    // options\n    filename: e,\n    selfName: k && Wr(mt(k[1])),\n    prefixIdentifiers: n,\n    hoistStatic: r,\n    hmr: i,\n    cacheHandlers: s,\n    nodeTransforms: o,\n    directiveTransforms: a,\n    transformHoist: l,\n    isBuiltInComponent: c,\n    isCustomElement: u,\n    expressionPlugins: d,\n    scopeId: f,\n    slotted: h,\n    ssr: p,\n    inSSR: O,\n    ssrCssVars: m,\n    bindingMetadata: y,\n    inline: b,\n    isTS: g,\n    onError: v,\n    onWarn: S,\n    compatConfig: w,\n    // state\n    root: t,\n    helpers: /* @__PURE__ */ new Map(),\n    components: /* @__PURE__ */ new Set(),\n    directives: /* @__PURE__ */ new Set(),\n    hoists: [],\n    imports: [],\n    constantCache: /* @__PURE__ */ new WeakMap(),\n    temps: 0,\n    cached: 0,\n    identifiers: /* @__PURE__ */ Object.create(null),\n    scopes: {\n      vFor: 0,\n      vSlot: 0,\n      vPre: 0,\n      vOnce: 0\n    },\n    parent: null,\n    currentNode: t,\n    childIndex: 0,\n    inVOnce: !1,\n    // methods\n    helper(T) {\n      const C = _.helpers.get(T) || 0;\n      return _.helpers.set(T, C + 1), T;\n    },\n    removeHelper(T) {\n      const C = _.helpers.get(T);\n      if (C) {\n        const A = C - 1;\n        A ? _.helpers.set(T, A) : _.helpers.delete(T);\n      }\n    },\n    helperString(T) {\n      return `_${Ho[_.helper(T)]}`;\n    },\n    replaceNode(T) {\n      if (true) {\n        if (!_.currentNode)\n          throw new Error(\"Node being replaced is already removed.\");\n        if (!_.parent)\n          throw new Error(\"Cannot replace root node.\");\n      }\n      _.parent.children[_.childIndex] = _.currentNode = T;\n    },\n    removeNode(T) {\n      if ( true && !_.parent)\n        throw new Error(\"Cannot remove root node.\");\n      const C = _.parent.children, A = T ? C.indexOf(T) : _.currentNode ? _.childIndex : -1;\n      if ( true && A < 0)\n        throw new Error(\"node being removed is not a child of current parent\");\n      !T || T === _.currentNode ? (_.currentNode = null, _.onNodeRemoved()) : _.childIndex > A && (_.childIndex--, _.onNodeRemoved()), _.parent.children.splice(A, 1);\n    },\n    onNodeRemoved: it,\n    addIdentifiers(T) {\n    },\n    removeIdentifiers(T) {\n    },\n    hoist(T) {\n      we(T) && (T = Ee(T)), _.hoists.push(T);\n      const C = Ee(\n        `_hoisted_${_.hoists.length}`,\n        !1,\n        T.loc,\n        2\n      );\n      return C.hoisted = T, C;\n    },\n    cache(T, C = !1) {\n      return N4(_.cached++, T, C);\n    }\n  };\n  return _.filters = /* @__PURE__ */ new Set(), _;\n}\nfunction c7(t, e) {\n  const n = l7(t, e);\n  ef(t, n), e.hoistStatic && o7(t, n), e.ssr || u7(t, n), t.helpers = /* @__PURE__ */ new Set([...n.helpers.keys()]), t.components = [...n.components], t.directives = [...n.directives], t.imports = n.imports, t.hoists = n.hoists, t.temps = n.temps, t.cached = n.cached, t.transformed = !0, t.filters = [...n.filters];\n}\nfunction u7(t, e) {\n  const { helper: n } = e, { children: r } = t;\n  if (r.length === 1) {\n    const i = r[0];\n    if (FP(t, i) && i.codegenNode) {\n      const s = i.codegenNode;\n      s.type === 13 && qg(s, e), t.codegenNode = s;\n    } else\n      t.codegenNode = i;\n  } else if (r.length > 1) {\n    let i = 64, s = Dr[64];\n     true && r.filter((o) => o.type !== 3).length === 1 && (i |= 2048, s += `, ${Dr[2048]}`), t.codegenNode = $l(\n      e,\n      n(Tl),\n      void 0,\n      t.children,\n      i + ( true ? ` /* ${s} */` : 0),\n      void 0,\n      void 0,\n      !0,\n      void 0,\n      !1\n    );\n  }\n}\nfunction d7(t, e) {\n  let n = 0;\n  const r = () => {\n    n--;\n  };\n  for (; n < t.children.length; n++) {\n    const i = t.children[n];\n    we(i) || (e.parent = t, e.childIndex = n, e.onNodeRemoved = r, ef(i, e));\n  }\n}\nfunction ef(t, e) {\n  e.currentNode = t;\n  const { nodeTransforms: n } = e, r = [];\n  for (let s = 0; s < n.length; s++) {\n    const o = n[s](t, e);\n    if (o && (ie(o) ? r.push(...o) : r.push(o)), e.currentNode)\n      t = e.currentNode;\n    else\n      return;\n  }\n  switch (t.type) {\n    case 3:\n      e.ssr || e.helper(rc);\n      break;\n    case 5:\n      e.ssr || e.helper(Jd);\n      break;\n    case 9:\n      for (let s = 0; s < t.branches.length; s++)\n        ef(t.branches[s], e);\n      break;\n    case 10:\n    case 11:\n    case 1:\n    case 0:\n      d7(t, e);\n      break;\n  }\n  e.currentNode = t;\n  let i = r.length;\n  for (; i--; )\n    r[i]();\n}\nfunction t_(t, e) {\n  const n = we(t) ? (r) => r === t : (r) => t.test(r);\n  return (r, i) => {\n    if (r.type === 1) {\n      const { props: s } = r;\n      if (r.tagType === 3 && s.some(U4))\n        return;\n      const o = [];\n      for (let a = 0; a < s.length; a++) {\n        const l = s[a];\n        if (l.type === 7 && n(l.name)) {\n          s.splice(a, 1), a--;\n          const c = e(r, l, i);\n          c && o.push(c);\n        }\n      }\n      return o;\n    }\n  };\n}\nconst tf = \"/*#__PURE__*/\", n_ = (t) => `${Ho[t]}: _${Ho[t]}`;\nfunction f7(t, {\n  mode: e = \"function\",\n  prefixIdentifiers: n = e === \"module\",\n  sourceMap: r = !1,\n  filename: i = \"template.vue.html\",\n  scopeId: s = null,\n  optimizeImports: o = !1,\n  runtimeGlobalName: a = \"Vue\",\n  runtimeModuleName: l = \"vue\",\n  ssrRuntimeModuleName: c = \"vue/server-renderer\",\n  ssr: u = !1,\n  isTS: d = !1,\n  inSSR: f = !1\n}) {\n  const h = {\n    mode: e,\n    prefixIdentifiers: n,\n    sourceMap: r,\n    filename: i,\n    scopeId: s,\n    optimizeImports: o,\n    runtimeGlobalName: a,\n    runtimeModuleName: l,\n    ssrRuntimeModuleName: c,\n    ssr: u,\n    isTS: d,\n    inSSR: f,\n    source: t.source,\n    code: \"\",\n    column: 1,\n    line: 1,\n    offset: 0,\n    indentLevel: 0,\n    pure: !1,\n    map: void 0,\n    helper(O) {\n      return `_${Ho[O]}`;\n    },\n    push(O, m = -2, y) {\n      h.code += O;\n    },\n    indent() {\n      p(++h.indentLevel);\n    },\n    deindent(O = !1) {\n      O ? --h.indentLevel : p(--h.indentLevel);\n    },\n    newline() {\n      p(h.indentLevel);\n    }\n  };\n  function p(O) {\n    h.push(\n      `\n` + \"  \".repeat(O),\n      0\n      /* Start */\n    );\n  }\n  return h;\n}\nfunction h7(t, e = {}) {\n  const n = f7(t, e);\n  e.onContextCreated && e.onContextCreated(n);\n  const {\n    mode: r,\n    push: i,\n    prefixIdentifiers: s,\n    indent: o,\n    deindent: a,\n    newline: l,\n    scopeId: c,\n    ssr: u\n  } = n, d = Array.from(t.helpers), f = d.length > 0, h = !s && r !== \"module\";\n  p7(t, n);\n  const O = u ? \"ssrRender\" : \"render\", y = (u ? [\"_ctx\", \"_push\", \"_parent\", \"_attrs\"] : [\"_ctx\", \"_cache\"]).join(\", \");\n  if (i(`function ${O}(${y}) {`), o(), h && (i(\"with (_ctx) {\"), o(), f && (i(\n    `const { ${d.map(n_).join(\", \")} } = _Vue\n`,\n    -1\n    /* End */\n  ), l())), t.components.length && (th(t.components, \"component\", n), (t.directives.length || t.temps > 0) && l()), t.directives.length && (th(t.directives, \"directive\", n), t.temps > 0 && l()), t.filters && t.filters.length && (l(), th(t.filters, \"filter\", n), l()), t.temps > 0) {\n    i(\"let \");\n    for (let b = 0; b < t.temps; b++)\n      i(`${b > 0 ? \", \" : \"\"}_temp${b}`);\n  }\n  return (t.components.length || t.directives.length || t.temps) && (i(\n    `\n`,\n    0\n    /* Start */\n  ), l()), u || i(\"return \"), t.codegenNode ? cn(t.codegenNode, n) : i(\"null\"), h && (a(), i(\"}\")), a(), i(\"}\"), {\n    ast: t,\n    code: n.code,\n    preamble: \"\",\n    map: n.map ? n.map.toJSON() : void 0\n  };\n}\nfunction p7(t, e) {\n  const {\n    ssr: n,\n    prefixIdentifiers: r,\n    push: i,\n    newline: s,\n    runtimeModuleName: o,\n    runtimeGlobalName: a,\n    ssrRuntimeModuleName: l\n  } = e, c = a, u = Array.from(t.helpers);\n  if (u.length > 0 && (i(\n    `const _Vue = ${c}\n`,\n    -1\n    /* End */\n  ), t.hoists.length)) {\n    const d = [\n      Ag,\n      Rg,\n      rc,\n      Ng,\n      IP\n    ].filter((f) => u.includes(f)).map(n_).join(\", \");\n    i(\n      `const { ${d} } = _Vue\n`,\n      -1\n      /* End */\n    );\n  }\n  O7(t.hoists, e), s(), i(\"return \");\n}\nfunction th(t, e, { helper: n, push: r, newline: i, isTS: s }) {\n  const o = n(\n    e === \"filter\" ? Ig : e === \"component\" ? Dg : Vg\n  );\n  for (let a = 0; a < t.length; a++) {\n    let l = t[a];\n    const c = l.endsWith(\"__self\");\n    c && (l = l.slice(0, -6)), r(\n      `const ${Cl(l, e)} = ${o}(${JSON.stringify(l)}${c ? \", true\" : \"\"})${s ? \"!\" : \"\"}`\n    ), a < t.length - 1 && i();\n  }\n}\nfunction O7(t, e) {\n  if (!t.length)\n    return;\n  e.pure = !0;\n  const { push: n, newline: r, helper: i, scopeId: s, mode: o } = e;\n  r();\n  for (let a = 0; a < t.length; a++) {\n    const l = t[a];\n    l && (n(\n      `const _hoisted_${a + 1} = `\n    ), cn(l, e), r());\n  }\n  e.pure = !1;\n}\nfunction g7(t) {\n  return we(t) || t.type === 4 || t.type === 2 || t.type === 5 || t.type === 8;\n}\nfunction Hg(t, e) {\n  const n = t.length > 3 ||  true && t.some((r) => ie(r) || !g7(r));\n  e.push(\"[\"), n && e.indent(), oc(t, e, n), n && e.deindent(), e.push(\"]\");\n}\nfunction oc(t, e, n = !1, r = !0) {\n  const { push: i, newline: s } = e;\n  for (let o = 0; o < t.length; o++) {\n    const a = t[o];\n    we(a) ? i(\n      a,\n      -3\n      /* Unknown */\n    ) : ie(a) ? Hg(a, e) : cn(a, e), o < t.length - 1 && (n ? (r && i(\",\"), s()) : r && i(\", \"));\n  }\n}\nfunction cn(t, e) {\n  if (we(t)) {\n    e.push(\n      t,\n      -3\n      /* Unknown */\n    );\n    return;\n  }\n  if (Or(t)) {\n    e.push(e.helper(t));\n    return;\n  }\n  switch (t.type) {\n    case 1:\n    case 9:\n    case 11:\n       true && F0(\n        t.codegenNode != null,\n        \"Codegen node is missing for element/if/for node. Apply appropriate transforms first.\"\n      ), cn(t.codegenNode, e);\n      break;\n    case 2:\n      m7(t, e);\n      break;\n    case 4:\n      r_(t, e);\n      break;\n    case 5:\n      b7(t, e);\n      break;\n    case 12:\n      cn(t.codegenNode, e);\n      break;\n    case 8:\n      i_(t, e);\n      break;\n    case 3:\n      y7(t, e);\n      break;\n    case 13:\n      S7(t, e);\n      break;\n    case 14:\n      k7(t, e);\n      break;\n    case 15:\n      x7(t, e);\n      break;\n    case 17:\n      P7(t, e);\n      break;\n    case 18:\n      _7(t, e);\n      break;\n    case 19:\n      T7(t, e);\n      break;\n    case 20:\n      E7(t, e);\n      break;\n    case 21:\n      oc(t.body, e, !0, !1);\n      break;\n    case 22:\n      break;\n    case 23:\n      break;\n    case 24:\n      break;\n    case 25:\n      break;\n    case 26:\n      break;\n    case 10:\n      break;\n    default:\n      if (true)\n        return F0(!1, `unhandled codegen node type: ${t.type}`), t;\n  }\n}\nfunction m7(t, e) {\n  e.push(JSON.stringify(t.content), -3, t);\n}\nfunction r_(t, e) {\n  const { content: n, isStatic: r } = t;\n  e.push(\n    r ? JSON.stringify(n) : n,\n    -3,\n    t\n  );\n}\nfunction b7(t, e) {\n  const { push: n, helper: r, pure: i } = e;\n  i && n(tf), n(`${r(Jd)}(`), cn(t.content, e), n(\")\");\n}\nfunction i_(t, e) {\n  for (let n = 0; n < t.children.length; n++) {\n    const r = t.children[n];\n    we(r) ? e.push(\n      r,\n      -3\n      /* Unknown */\n    ) : cn(r, e);\n  }\n}\nfunction v7(t, e) {\n  const { push: n } = e;\n  if (t.type === 8)\n    n(\"[\"), i_(t, e), n(\"]\");\n  else if (t.isStatic) {\n    const r = zg(t.content) ? t.content : JSON.stringify(t.content);\n    n(r, -2, t);\n  } else\n    n(`[${t.content}]`, -3, t);\n}\nfunction y7(t, e) {\n  const { push: n, helper: r, pure: i } = e;\n  i && n(tf), n(\n    `${r(rc)}(${JSON.stringify(t.content)})`,\n    -3,\n    t\n  );\n}\nfunction S7(t, e) {\n  const { push: n, helper: r, pure: i } = e, {\n    tag: s,\n    props: o,\n    children: a,\n    patchFlag: l,\n    dynamicProps: c,\n    directives: u,\n    isBlock: d,\n    disableTracking: f,\n    isComponent: h\n  } = t;\n  u && n(r(Wg) + \"(\"), d && n(`(${r(Fs)}(${f ? \"true\" : \"\"}), `), i && n(tf);\n  const p = d ? Ko(e.inSSR, h) : Go(e.inSSR, h);\n  n(r(p) + \"(\", -2, t), oc(\n    w7([s, o, a, l, c]),\n    e\n  ), n(\")\"), d && n(\")\"), u && (n(\", \"), cn(u, e), n(\")\"));\n}\nfunction w7(t) {\n  let e = t.length;\n  for (; e-- && t[e] == null; )\n    ;\n  return t.slice(0, e + 1).map((n) => n || \"null\");\n}\nfunction k7(t, e) {\n  const { push: n, helper: r, pure: i } = e, s = we(t.callee) ? t.callee : r(t.callee);\n  i && n(tf), n(s + \"(\", -2, t), oc(t.arguments, e), n(\")\");\n}\nfunction x7(t, e) {\n  const { push: n, indent: r, deindent: i, newline: s } = e, { properties: o } = t;\n  if (!o.length) {\n    n(\"{}\", -2, t);\n    return;\n  }\n  const a = o.length > 1 ||  true && o.some((l) => l.value.type !== 4);\n  n(a ? \"{\" : \"{ \"), a && r();\n  for (let l = 0; l < o.length; l++) {\n    const { key: c, value: u } = o[l];\n    v7(c, e), n(\": \"), cn(u, e), l < o.length - 1 && (n(\",\"), s());\n  }\n  a && i(), n(a ? \"}\" : \" }\");\n}\nfunction P7(t, e) {\n  Hg(t.elements, e);\n}\nfunction _7(t, e) {\n  const { push: n, indent: r, deindent: i } = e, { params: s, returns: o, body: a, newline: l, isSlot: c } = t;\n  c && n(`_${Ho[Lg]}(`), n(\"(\", -2, t), ie(s) ? oc(s, e) : s && cn(s, e), n(\") => \"), (l || a) && (n(\"{\"), r()), o ? (l && n(\"return \"), ie(o) ? Hg(o, e) : cn(o, e)) : a && cn(a, e), (l || a) && (i(), n(\"}\")), c && (t.isNonScopedSlot && n(\", undefined, true\"), n(\")\"));\n}\nfunction T7(t, e) {\n  const { test: n, consequent: r, alternate: i, newline: s } = t, { push: o, indent: a, deindent: l, newline: c } = e;\n  if (n.type === 4) {\n    const d = !zg(n.content);\n    d && o(\"(\"), r_(n, e), d && o(\")\");\n  } else\n    o(\"(\"), cn(n, e), o(\")\");\n  s && a(), e.indentLevel++, s || o(\" \"), o(\"? \"), cn(r, e), e.indentLevel--, s && c(), s || o(\" \"), o(\": \");\n  const u = i.type === 19;\n  u || e.indentLevel++, cn(i, e), u || e.indentLevel--, s && l(\n    !0\n    /* without newline */\n  );\n}\nfunction E7(t, e) {\n  const { push: n, helper: r, indent: i, deindent: s, newline: o } = e;\n  n(`_cache[${t.index}] || (`), t.isVNode && (i(), n(`${r(rd)}(-1),`), o()), n(`_cache[${t.index}] = `), cn(t.value, e), t.isVNode && (n(\",\"), o(), n(`${r(rd)}(1),`), o(), n(`_cache[${t.index}]`), s()), n(\")\");\n}\nconst $7 = new RegExp(\n  \"\\\\b\" + \"arguments,await,break,case,catch,class,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,let,new,return,super,switch,throw,try,var,void,while,with,yield\".split(\",\").join(\"\\\\b|\\\\b\") + \"\\\\b\"\n), Q7 = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\nfunction Qs(t, e, n = !1, r = !1) {\n  const i = t.content;\n  if (i.trim())\n    try {\n      new Function(\n        r ? ` ${i} ` : `return ${n ? `(${i}) => {}` : `(${i})`}`\n      );\n    } catch (s) {\n      let o = s.message;\n      const a = i.replace(Q7, \"\").match($7);\n      a && (o = `avoid using JavaScript keyword as property name: \"${a[0]}\"`), e.onError(\n        Ge(\n          45,\n          t.loc,\n          void 0,\n          o\n        )\n      );\n    }\n}\nconst C7 = (t, e) => {\n  if (t.type === 5)\n    t.content = nh(\n      t.content,\n      e\n    );\n  else if (t.type === 1)\n    for (let n = 0; n < t.props.length; n++) {\n      const r = t.props[n];\n      if (r.type === 7 && r.name !== \"for\") {\n        const i = r.exp, s = r.arg;\n        i && i.type === 4 && !(r.name === \"on\" && s) && (r.exp = nh(\n          i,\n          e,\n          // slot args must be processed as function params\n          r.name === \"slot\"\n        )), s && s.type === 4 && !s.isStatic && (r.arg = nh(s, e));\n      }\n    }\n};\nfunction nh(t, e, n = !1, r = !1, i = Object.create(e.identifiers)) {\n  return  true && Qs(t, e, n, r), t;\n}\nconst A7 = t_(\n  /^(if|else|else-if)$/,\n  (t, e, n) => R7(t, e, n, (r, i, s) => {\n    const o = n.parent.children;\n    let a = o.indexOf(r), l = 0;\n    for (; a-- >= 0; ) {\n      const c = o[a];\n      c && c.type === 9 && (l += c.branches.length);\n    }\n    return () => {\n      if (s)\n        r.codegenNode = ny(\n          i,\n          l,\n          n\n        );\n      else {\n        const c = D7(r.codegenNode);\n        c.alternate = ny(\n          i,\n          l + r.branches.length - 1,\n          n\n        );\n      }\n    };\n  })\n);\nfunction R7(t, e, n, r) {\n  if (e.name !== \"else\" && (!e.exp || !e.exp.content.trim())) {\n    const i = e.exp ? e.exp.loc : t.loc;\n    n.onError(\n      Ge(28, e.loc)\n    ), e.exp = Ee(\"true\", !1, i);\n  }\n  if ( true && e.exp && Qs(e.exp, n), e.name === \"if\") {\n    const i = ty(t, e), s = {\n      type: 9,\n      loc: t.loc,\n      branches: [i]\n    };\n    if (n.replaceNode(s), r)\n      return r(s, i, !0);\n  } else {\n    const i = n.parent.children, s = [];\n    let o = i.indexOf(t);\n    for (; o-- >= -1; ) {\n      const a = i[o];\n      if (a && a.type === 3) {\n        n.removeNode(a),  true && s.unshift(a);\n        continue;\n      }\n      if (a && a.type === 2 && !a.content.trim().length) {\n        n.removeNode(a);\n        continue;\n      }\n      if (a && a.type === 9) {\n        e.name === \"else-if\" && a.branches[a.branches.length - 1].condition === void 0 && n.onError(\n          Ge(30, t.loc)\n        ), n.removeNode();\n        const l = ty(t, e);\n        if ( true && s.length && // #3619 ignore comments if the v-if is direct child of <transition>\n        !(n.parent && n.parent.type === 1 && (n.parent.tag === \"transition\" || n.parent.tag === \"Transition\")) && (l.children = [...s, ...l.children]), \"development\" !== \"production\") {\n          const u = l.userKey;\n          u && a.branches.forEach(({ userKey: d }) => {\n            N7(d, u) && n.onError(\n              Ge(\n                29,\n                l.userKey.loc\n              )\n            );\n          });\n        }\n        a.branches.push(l);\n        const c = r && r(a, l, !1);\n        ef(l, n), c && c(), n.currentNode = null;\n      } else\n        n.onError(\n          Ge(30, t.loc)\n        );\n      break;\n    }\n  }\n}\nfunction ty(t, e) {\n  const n = t.tagType === 3;\n  return {\n    type: 10,\n    loc: t.loc,\n    condition: e.name === \"else\" ? void 0 : e.exp,\n    children: n && !zn(t, \"for\") ? t.children : [t],\n    userKey: Ql(t, \"key\"),\n    isTemplateIf: n\n  };\n}\nfunction ny(t, e, n) {\n  return t.condition ? Bp(\n    t.condition,\n    ry(t, e, n),\n    // make sure to pass in asBlock: true so that the comment node call\n    // closes the current block.\n    Dt(n.helper(rc), [\n       true ? '\"v-if\"' : 0,\n      \"true\"\n    ])\n  ) : ry(t, e, n);\n}\nfunction ry(t, e, n) {\n  const { helper: r } = n, i = yt(\n    \"key\",\n    Ee(\n      `${e}`,\n      !1,\n      Ln,\n      2\n    )\n  ), { children: s } = t, o = s[0];\n  if (s.length !== 1 || o.type !== 1)\n    if (s.length === 1 && o.type === 11) {\n      const l = o.codegenNode;\n      return ld(l, i, n), l;\n    } else {\n      let l = 64, c = Dr[64];\n      return  true && !t.isTemplateIf && s.filter((u) => u.type !== 3).length === 1 && (l |= 2048, c += `, ${Dr[2048]}`), $l(\n        n,\n        r(Tl),\n        Gn([i]),\n        s,\n        l + ( true ? ` /* ${c} */` : 0),\n        void 0,\n        void 0,\n        !0,\n        !1,\n        !1,\n        t.loc\n      );\n    }\n  else {\n    const l = o.codegenNode, c = Y4(l);\n    return c.type === 13 && qg(c, n), ld(c, i, n), l;\n  }\n}\nfunction N7(t, e) {\n  if (!t || t.type !== e.type)\n    return !1;\n  if (t.type === 6) {\n    if (t.value.content !== e.value.content)\n      return !1;\n  } else {\n    const n = t.exp, r = e.exp;\n    if (n.type !== r.type || n.type !== 4 || n.isStatic !== r.isStatic || n.content !== r.content)\n      return !1;\n  }\n  return !0;\n}\nfunction D7(t) {\n  for (; ; )\n    if (t.type === 19)\n      if (t.alternate.type === 19)\n        t = t.alternate;\n      else\n        return t;\n    else\n      t.type === 20 && (t = t.value);\n}\nconst Z7 = t_(\n  \"for\",\n  (t, e, n) => {\n    const { helper: r, removeHelper: i } = n;\n    return V7(t, e, n, (s) => {\n      const o = Dt(r(Mg), [\n        s.source\n      ]), a = od(t), l = zn(t, \"memo\"), c = Ql(t, \"key\"), u = c && (c.type === 6 ? Ee(c.value.content, !0) : c.exp), d = c ? yt(\"key\", u) : null, f = s.source.type === 4 && s.source.constType > 0, h = f ? 64 : c ? 128 : 256;\n      return s.codegenNode = $l(\n        n,\n        r(Tl),\n        void 0,\n        o,\n        h + ( true ? ` /* ${Dr[h]} */` : 0),\n        void 0,\n        void 0,\n        !0,\n        !f,\n        !1,\n        t.loc\n      ), () => {\n        let p;\n        const { children: O } = s;\n         true && a && t.children.some((b) => {\n          if (b.type === 1) {\n            const g = Ql(b, \"key\");\n            if (g)\n              return n.onError(\n                Ge(\n                  33,\n                  g.loc\n                )\n              ), !0;\n          }\n        });\n        const m = O.length !== 1 || O[0].type !== 1, y = ad(t) ? t : a && t.children.length === 1 && ad(t.children[0]) ? t.children[0] : null;\n        if (y ? (p = y.codegenNode, a && d && ld(p, d, n)) : m ? p = $l(\n          n,\n          r(Tl),\n          d ? Gn([d]) : void 0,\n          t.children,\n          64 + ( true ? ` /* ${Dr[64]} */` : 0),\n          void 0,\n          void 0,\n          !0,\n          void 0,\n          !1\n        ) : (p = O[0].codegenNode, a && d && ld(p, d, n), p.isBlock !== !f && (p.isBlock ? (i(Fs), i(\n          Ko(n.inSSR, p.isComponent)\n        )) : i(\n          Go(n.inSSR, p.isComponent)\n        )), p.isBlock = !f, p.isBlock ? (r(Fs), r(Ko(n.inSSR, p.isComponent))) : r(Go(n.inSSR, p.isComponent))), l) {\n          const b = Fo(\n            Yp(s.parseResult, [\n              Ee(\"_cached\")\n            ])\n          );\n          b.body = D4([\n            pr([\"const _memo = (\", l.exp, \")\"]),\n            pr([\n              \"if (_cached\",\n              ...u ? [\" && _cached.key === \", u] : [],\n              ` && ${n.helperString(\n                XP\n              )}(_cached, _memo)) return _cached`\n            ]),\n            pr([\"const _item = \", p]),\n            Ee(\"_item.memo = _memo\"),\n            Ee(\"return _item\")\n          ]), o.arguments.push(\n            b,\n            Ee(\"_cache\"),\n            Ee(String(n.cached++))\n          );\n        } else\n          o.arguments.push(\n            Fo(\n              Yp(s.parseResult),\n              p,\n              !0\n            )\n          );\n      };\n    });\n  }\n);\nfunction V7(t, e, n, r) {\n  if (!e.exp) {\n    n.onError(\n      Ge(31, e.loc)\n    );\n    return;\n  }\n  const i = e.forParseResult;\n  if (!i) {\n    n.onError(\n      Ge(32, e.loc)\n    );\n    return;\n  }\n  s_(i, n);\n  const { addIdentifiers: s, removeIdentifiers: o, scopes: a } = n, { source: l, value: c, key: u, index: d } = i, f = {\n    type: 11,\n    loc: e.loc,\n    source: l,\n    valueAlias: c,\n    keyAlias: u,\n    objectIndexAlias: d,\n    parseResult: i,\n    children: od(t) ? t.children : [t]\n  };\n  n.replaceNode(f), a.vFor++;\n  const h = r && r(f);\n  return () => {\n    a.vFor--, h && h();\n  };\n}\nfunction s_(t, e) {\n  t.finalized || ( true && (Qs(t.source, e), t.key && Qs(\n    t.key,\n    e,\n    !0\n  ), t.index && Qs(\n    t.index,\n    e,\n    !0\n  ), t.value && Qs(\n    t.value,\n    e,\n    !0\n  )), t.finalized = !0);\n}\nfunction Yp({ value: t, key: e, index: n }, r = []) {\n  return I7([t, e, n, ...r]);\n}\nfunction I7(t) {\n  let e = t.length;\n  for (; e-- && !t[e]; )\n    ;\n  return t.slice(0, e + 1).map((n, r) => n || Ee(\"_\".repeat(r + 1), !1));\n}\nconst iy = Ee(\"undefined\", !1), W7 = (t, e) => {\n  if (t.type === 1 && (t.tagType === 1 || t.tagType === 3)) {\n    const n = zn(t, \"slot\");\n    if (n)\n      return n.exp, e.scopes.vSlot++, () => {\n        e.scopes.vSlot--;\n      };\n  }\n}, M7 = (t, e, n, r) => Fo(\n  t,\n  n,\n  !1,\n  !0,\n  n.length ? n[0].loc : r\n);\nfunction X7(t, e, n = M7) {\n  e.helper(Lg);\n  const { children: r, loc: i } = t, s = [], o = [];\n  let a = e.scopes.vSlot > 0 || e.scopes.vFor > 0;\n  const l = zn(t, \"slot\", !0);\n  if (l) {\n    const { arg: m, exp: y } = l;\n    m && !xn(m) && (a = !0), s.push(\n      yt(\n        m || Ee(\"default\", !0),\n        n(y, void 0, r, i)\n      )\n    );\n  }\n  let c = !1, u = !1;\n  const d = [], f = /* @__PURE__ */ new Set();\n  let h = 0;\n  for (let m = 0; m < r.length; m++) {\n    const y = r[m];\n    let b;\n    if (!od(y) || !(b = zn(y, \"slot\", !0))) {\n      y.type !== 3 && d.push(y);\n      continue;\n    }\n    if (l) {\n      e.onError(\n        Ge(37, b.loc)\n      );\n      break;\n    }\n    c = !0;\n    const { children: g, loc: v } = y, {\n      arg: S = Ee(\"default\", !0),\n      exp: w,\n      loc: k\n    } = b;\n    let _;\n    xn(S) ? _ = S ? S.content : \"default\" : a = !0;\n    const T = zn(y, \"for\"), C = n(w, T, g, v);\n    let A, Q;\n    if (A = zn(y, \"if\"))\n      a = !0, o.push(\n        Bp(\n          A.exp,\n          qc(S, C, h++),\n          iy\n        )\n      );\n    else if (Q = zn(\n      y,\n      /^else(-if)?$/,\n      !0\n      /* allowEmpty */\n    )) {\n      let W = m, L;\n      for (; W-- && (L = r[W], L.type === 3); )\n        ;\n      if (L && od(L) && zn(L, \"if\")) {\n        r.splice(m, 1), m--;\n        let re = o[o.length - 1];\n        for (; re.alternate.type === 19; )\n          re = re.alternate;\n        re.alternate = Q.exp ? Bp(\n          Q.exp,\n          qc(\n            S,\n            C,\n            h++\n          ),\n          iy\n        ) : qc(S, C, h++);\n      } else\n        e.onError(\n          Ge(30, Q.loc)\n        );\n    } else if (T) {\n      a = !0;\n      const W = T.forParseResult;\n      W ? (s_(W, e), o.push(\n        Dt(e.helper(Mg), [\n          W.source,\n          Fo(\n            Yp(W),\n            qc(S, C),\n            !0\n          )\n        ])\n      )) : e.onError(\n        Ge(\n          32,\n          T.loc\n        )\n      );\n    } else {\n      if (_) {\n        if (f.has(_)) {\n          e.onError(\n            Ge(\n              38,\n              k\n            )\n          );\n          continue;\n        }\n        f.add(_), _ === \"default\" && (u = !0);\n      }\n      s.push(yt(S, C));\n    }\n  }\n  if (!l) {\n    const m = (y, b) => {\n      const g = n(y, void 0, b, i);\n      return e.compatConfig && (g.isNonScopedSlot = !0), yt(\"default\", g);\n    };\n    c ? d.length && // #3766\n    // with whitespace: 'preserve', whitespaces between slots will end up in\n    // implicitDefaultChildren. Ignore if all implicit children are whitespaces.\n    d.some((y) => o_(y)) && (u ? e.onError(\n      Ge(\n        39,\n        d[0].loc\n      )\n    ) : s.push(\n      m(void 0, d)\n    )) : s.push(m(void 0, r));\n  }\n  const p = a ? 2 : gu(t.children) ? 3 : 1;\n  let O = Gn(\n    s.concat(\n      yt(\n        \"_\",\n        // 2 = compiled but dynamic = can skip normalization, but must run diff\n        // 1 = compiled and static = can skip normalization AND diff as optimized\n        Ee(\n          p + ( true ? ` /* ${V_[p]} */` : 0),\n          !1\n        )\n      )\n    ),\n    i\n  );\n  return o.length && (O = Dt(e.helper(MP), [\n    O,\n    sc(o)\n  ])), {\n    slots: O,\n    hasDynamicSlots: a\n  };\n}\nfunction qc(t, e, n) {\n  const r = [\n    yt(\"name\", t),\n    yt(\"fn\", e)\n  ];\n  return n != null && r.push(\n    yt(\"key\", Ee(String(n), !0))\n  ), Gn(r);\n}\nfunction gu(t) {\n  for (let e = 0; e < t.length; e++) {\n    const n = t[e];\n    switch (n.type) {\n      case 1:\n        if (n.tagType === 2 || gu(n.children))\n          return !0;\n        break;\n      case 9:\n        if (gu(n.branches))\n          return !0;\n        break;\n      case 10:\n      case 11:\n        if (gu(n.children))\n          return !0;\n        break;\n    }\n  }\n  return !1;\n}\nfunction o_(t) {\n  return t.type !== 2 && t.type !== 12 ? !0 : t.type === 2 ? !!t.content.trim() : o_(t.content);\n}\nconst a_ = /* @__PURE__ */ new WeakMap(), j7 = (t, e) => function() {\n  if (t = e.currentNode, !(t.type === 1 && (t.tagType === 0 || t.tagType === 1)))\n    return;\n  const { tag: r, props: i } = t, s = t.tagType === 1;\n  let o = s ? B7(t, e) : `\"${r}\"`;\n  const a = Ze(o) && o.callee === Zg;\n  let l, c, u, d = 0, f, h, p, O = (\n    // dynamic component may resolve to plain elements\n    a || o === Ga || o === Cg || !s && // <svg> and <foreignObject> must be forced into blocks so that block\n    // updates inside get proper isSVG flag at runtime. (#639, #643)\n    // This is technically web-specific, but splitting the logic out of core\n    // leads to too much unnecessary complexity.\n    (r === \"svg\" || r === \"foreignObject\")\n  );\n  if (i.length > 0) {\n    const m = l_(\n      t,\n      e,\n      void 0,\n      s,\n      a\n    );\n    l = m.props, d = m.patchFlag, h = m.dynamicPropNames;\n    const y = m.directives;\n    p = y && y.length ? sc(\n      y.map((b) => U7(b, e))\n    ) : void 0, m.shouldUseBlock && (O = !0);\n  }\n  if (t.children.length > 0)\n    if (o === td && (O = !0, d |= 1024,  true && t.children.length > 1 && e.onError(\n      Ge(46, {\n        start: t.children[0].loc.start,\n        end: t.children[t.children.length - 1].loc.end,\n        source: \"\"\n      })\n    )), s && // Teleport is not a real component and has dedicated runtime handling\n    o !== Ga && // explained above.\n    o !== td) {\n      const { slots: y, hasDynamicSlots: b } = X7(t, e);\n      c = y, b && (d |= 1024);\n    } else if (t.children.length === 1 && o !== Ga) {\n      const y = t.children[0], b = y.type, g = b === 5 || b === 8;\n      g && Kn(y, e) === 0 && (d |= 1), g || b === 2 ? c = y : c = t.children;\n    } else\n      c = t.children;\n  if (d !== 0) {\n    if (true)\n      if (d < 0)\n        u = d + ` /* ${Dr[d]} */`;\n      else {\n        const m = Object.keys(Dr).map(Number).filter((y) => y > 0 && d & y).map((y) => Dr[y]).join(\", \");\n        u = d + ` /* ${m} */`;\n      }\n    else\n      {}\n    h && h.length && (f = q7(h));\n  }\n  t.codegenNode = $l(\n    e,\n    o,\n    l,\n    c,\n    u,\n    f,\n    p,\n    !!O,\n    !1,\n    s,\n    t.loc\n  );\n};\nfunction B7(t, e, n = !1) {\n  let { tag: r } = t;\n  const i = zp(r), s = Ql(t, \"is\");\n  if (s)\n    if (i || es(\n      \"COMPILER_IS_ON_ELEMENT\",\n      e\n    )) {\n      const a = s.type === 6 ? s.value && Ee(s.value.content, !0) : s.exp;\n      if (a)\n        return Dt(e.helper(Zg), [\n          a\n        ]);\n    } else\n      s.type === 6 && s.value.content.startsWith(\"vue:\") && (r = s.value.content.slice(4));\n  const o = BP(r) || e.isBuiltInComponent(r);\n  return o ? (n || e.helper(o), o) : (e.helper(Dg), e.components.add(r), Cl(r, \"component\"));\n}\nfunction l_(t, e, n = t.props, r, i, s = !1) {\n  const { tag: o, loc: a, children: l } = t;\n  let c = [];\n  const u = [], d = [], f = l.length > 0;\n  let h = !1, p = 0, O = !1, m = !1, y = !1, b = !1, g = !1, v = !1;\n  const S = [], w = (T) => {\n    c.length && (u.push(\n      Gn(sy(c), a)\n    ), c = []), T && u.push(T);\n  }, k = ({ key: T, value: C }) => {\n    if (xn(T)) {\n      const A = T.content, Q = oi(A);\n      if (Q && (!r || i) && // omit the flag for click handlers because hydration gives click\n      // dedicated fast path.\n      A.toLowerCase() !== \"onclick\" && // omit v-model handlers\n      A !== \"onUpdate:modelValue\" && // omit onVnodeXXX hooks\n      !Ui(A) && (b = !0), Q && Ui(A) && (v = !0), Q && C.type === 14 && (C = C.arguments[0]), C.type === 20 || (C.type === 4 || C.type === 8) && Kn(C, e) > 0)\n        return;\n      A === \"ref\" ? O = !0 : A === \"class\" ? m = !0 : A === \"style\" ? y = !0 : A !== \"key\" && !S.includes(A) && S.push(A), r && (A === \"class\" || A === \"style\") && !S.includes(A) && S.push(A);\n    } else\n      g = !0;\n  };\n  for (let T = 0; T < n.length; T++) {\n    const C = n[T];\n    if (C.type === 6) {\n      const { loc: A, name: Q, nameLoc: W, value: L } = C;\n      let re = !0;\n      if (Q === \"ref\" && (O = !0, e.scopes.vFor > 0 && c.push(\n        yt(\n          Ee(\"ref_for\", !0),\n          Ee(\"true\")\n        )\n      )), Q === \"is\" && (zp(o) || L && L.content.startsWith(\"vue:\") || es(\n        \"COMPILER_IS_ON_ELEMENT\",\n        e\n      )))\n        continue;\n      c.push(\n        yt(\n          Ee(Q, !0, W),\n          Ee(\n            L ? L.content : \"\",\n            re,\n            L ? L.loc : A\n          )\n        )\n      );\n    } else {\n      const { name: A, arg: Q, exp: W, loc: L, modifiers: re } = C, Y = A === \"bind\", K = A === \"on\";\n      if (A === \"slot\") {\n        r || e.onError(\n          Ge(40, L)\n        );\n        continue;\n      }\n      if (A === \"once\" || A === \"memo\" || A === \"is\" || Y && Li(Q, \"is\") && (zp(o) || es(\n        \"COMPILER_IS_ON_ELEMENT\",\n        e\n      )) || K && s)\n        continue;\n      if (\n        // #938: elements with dynamic keys should be forced into blocks\n        (Y && Li(Q, \"key\") || // inline before-update hooks need to force block so that it is invoked\n        // before children\n        K && f && Li(Q, \"vue:before-update\")) && (h = !0), Y && Li(Q, \"ref\") && e.scopes.vFor > 0 && c.push(\n          yt(\n            Ee(\"ref_for\", !0),\n            Ee(\"true\")\n          )\n        ), !Q && (Y || K)\n      ) {\n        if (g = !0, W)\n          if (Y) {\n            if (w(),  true && u.some((Ce) => Ce.type === 15 ? Ce.properties.some(({ key: ue }) => ue.type !== 4 || !ue.isStatic ? !0 : ue.content !== \"class\" && ue.content !== \"style\" && !oi(ue.content)) : !0) && Jo(\n              \"COMPILER_V_BIND_OBJECT_ORDER\",\n              e,\n              L\n            ), es(\n              \"COMPILER_V_BIND_OBJECT_ORDER\",\n              e\n            )) {\n              u.unshift(W);\n              continue;\n            }\n            u.push(W);\n          } else\n            w({\n              type: 14,\n              loc: L,\n              callee: e.helper(Bg),\n              arguments: r ? [W] : [W, \"true\"]\n            });\n        else\n          e.onError(\n            Ge(\n              Y ? 34 : 35,\n              L\n            )\n          );\n        continue;\n      }\n      Y && re.includes(\"prop\") && (p |= 32);\n      const B = e.directiveTransforms[A];\n      if (B) {\n        const { props: _e, needRuntime: Ce } = B(C, t, e);\n        !s && _e.forEach(k), K && Q && !xn(Q) ? w(Gn(_e, a)) : c.push(..._e), Ce && (d.push(C), Or(Ce) && a_.set(C, Ce));\n      } else\n        Oy(A) || (d.push(C), f && (h = !0));\n    }\n  }\n  let _;\n  if (u.length ? (w(), u.length > 1 ? _ = Dt(\n    e.helper(nd),\n    u,\n    a\n  ) : _ = u[0]) : c.length && (_ = Gn(\n    sy(c),\n    a\n  )), g ? p |= 16 : (m && !r && (p |= 2), y && !r && (p |= 4), S.length && (p |= 8), b && (p |= 32)), !h && (p === 0 || p === 32) && (O || v || d.length > 0) && (p |= 512), !e.inSSR && _)\n    switch (_.type) {\n      case 15:\n        let T = -1, C = -1, A = !1;\n        for (let L = 0; L < _.properties.length; L++) {\n          const re = _.properties[L].key;\n          xn(re) ? re.content === \"class\" ? T = L : re.content === \"style\" && (C = L) : re.isHandlerKey || (A = !0);\n        }\n        const Q = _.properties[T], W = _.properties[C];\n        A ? _ = Dt(\n          e.helper(El),\n          [_]\n        ) : (Q && !xn(Q.value) && (Q.value = Dt(\n          e.helper(Xg),\n          [Q.value]\n        )), W && // the static style is compiled into an object,\n        // so use `hasStyleBinding` to ensure that it is a dynamic style binding\n        (y || W.value.type === 4 && W.value.content.trim()[0] === \"[\" || // v-bind:style and style both exist,\n        // v-bind:style with static literal object\n        W.value.type === 17) && (W.value = Dt(\n          e.helper(jg),\n          [W.value]\n        )));\n        break;\n      case 14:\n        break;\n      default:\n        _ = Dt(\n          e.helper(El),\n          [\n            Dt(e.helper(ic), [\n              _\n            ])\n          ]\n        );\n        break;\n    }\n  return {\n    props: _,\n    directives: d,\n    patchFlag: p,\n    dynamicPropNames: S,\n    shouldUseBlock: h\n  };\n}\nfunction sy(t) {\n  const e = /* @__PURE__ */ new Map(), n = [];\n  for (let r = 0; r < t.length; r++) {\n    const i = t[r];\n    if (i.key.type === 8 || !i.key.isStatic) {\n      n.push(i);\n      continue;\n    }\n    const s = i.key.content, o = e.get(s);\n    o ? (s === \"style\" || s === \"class\" || oi(s)) && L7(o, i) : (e.set(s, i), n.push(i));\n  }\n  return n;\n}\nfunction L7(t, e) {\n  t.value.type === 17 ? t.value.elements.push(e.value) : t.value = sc(\n    [t.value, e.value],\n    t.loc\n  );\n}\nfunction U7(t, e) {\n  const n = [], r = a_.get(t);\n  r ? n.push(e.helperString(r)) : (e.helper(Vg), e.directives.add(t.name), n.push(Cl(t.name, \"directive\")));\n  const { loc: i } = t;\n  if (t.exp && n.push(t.exp), t.arg && (t.exp || n.push(\"void 0\"), n.push(t.arg)), Object.keys(t.modifiers).length) {\n    t.arg || (t.exp || n.push(\"void 0\"), n.push(\"void 0\"));\n    const s = Ee(\"true\", !1, i);\n    n.push(\n      Gn(\n        t.modifiers.map(\n          (o) => yt(o, s)\n        ),\n        i\n      )\n    );\n  }\n  return sc(n, t.loc);\n}\nfunction q7(t) {\n  let e = \"[\";\n  for (let n = 0, r = t.length; n < r; n++)\n    e += JSON.stringify(t[n]), n < r - 1 && (e += \", \");\n  return e + \"]\";\n}\nfunction zp(t) {\n  return t === \"component\" || t === \"Component\";\n}\nconst Y7 = (t, e) => {\n  if (ad(t)) {\n    const { children: n, loc: r } = t, { slotName: i, slotProps: s } = z7(t, e), o = [\n      e.prefixIdentifiers ? \"_ctx.$slots\" : \"$slots\",\n      i,\n      \"{}\",\n      \"undefined\",\n      \"true\"\n    ];\n    let a = 2;\n    s && (o[2] = s, a = 3), n.length && (o[3] = Fo([], n, !1, !1, r), a = 4), e.scopeId && !e.slotted && (a = 5), o.splice(a), t.codegenNode = Dt(\n      e.helper(WP),\n      o,\n      r\n    );\n  }\n};\nfunction z7(t, e) {\n  let n = '\"default\"', r;\n  const i = [];\n  for (let s = 0; s < t.props.length; s++) {\n    const o = t.props[s];\n    if (o.type === 6)\n      o.value && (o.name === \"name\" ? n = JSON.stringify(o.value.content) : (o.name = mt(o.name), i.push(o)));\n    else if (o.name === \"bind\" && Li(o.arg, \"name\")) {\n      if (o.exp)\n        n = o.exp;\n      else if (o.arg && o.arg.type === 4) {\n        const a = mt(o.arg.content);\n        n = o.exp = Ee(a, !1, o.arg.loc);\n      }\n    } else\n      o.name === \"bind\" && o.arg && xn(o.arg) && (o.arg.content = mt(o.arg.content)), i.push(o);\n  }\n  if (i.length > 0) {\n    const { props: s, directives: o } = l_(\n      t,\n      e,\n      i,\n      !1,\n      !1\n    );\n    r = s, o.length && e.onError(\n      Ge(\n        36,\n        o[0].loc\n      )\n    );\n  }\n  return {\n    slotName: n,\n    slotProps: r\n  };\n}\nconst H7 = /^\\s*([\\w$_]+|(async\\s*)?\\([^)]*?\\))\\s*(:[^=]+)?=>|^\\s*(async\\s+)?function(?:\\s+[\\w$]+)?\\s*\\(/, c_ = (t, e, n, r) => {\n  const { loc: i, modifiers: s, arg: o } = t;\n  !t.exp && !s.length && n.onError(Ge(35, i));\n  let a;\n  if (o.type === 4)\n    if (o.isStatic) {\n      let d = o.content;\n       true && d.startsWith(\"vnode\") && n.onError(Ge(51, o.loc)), d.startsWith(\"vue:\") && (d = `vnode-${d.slice(4)}`);\n      const f = e.tagType !== 0 || d.startsWith(\"vnode\") || !/[A-Z]/.test(d) ? (\n        // for non-element and vnode lifecycle event listeners, auto convert\n        // it to camelCase. See issue #2249\n        Tr(mt(d))\n      ) : (\n        // preserve case for plain element listeners that have uppercase\n        // letters, as these may be custom elements' custom events\n        `on:${d}`\n      );\n      a = Ee(f, !0, o.loc);\n    } else\n      a = pr([\n        `${n.helperString(jp)}(`,\n        o,\n        \")\"\n      ]);\n  else\n    a = o, a.children.unshift(`${n.helperString(jp)}(`), a.children.push(\")\");\n  let l = t.exp;\n  l && !l.content.trim() && (l = void 0);\n  let c = n.cacheHandlers && !l && !n.inVOnce;\n  if (l) {\n    const d = LP(l.content), f = !(d || H7.test(l.content)), h = l.content.includes(\";\");\n     true && Qs(\n      l,\n      n,\n      !1,\n      h\n    ), (f || c && d) && (l = pr([\n      `${f ? \"$event\" : \"(...args)\"} => ${h ? \"{\" : \"(\"}`,\n      l,\n      h ? \"}\" : \")\"\n    ]));\n  }\n  let u = {\n    props: [\n      yt(\n        a,\n        l || Ee(\"() => {}\", !1, i)\n      )\n    ]\n  };\n  return r && (u = r(u)), c && (u.props[0].value = n.cache(u.props[0].value)), u.props.forEach((d) => d.key.isHandlerKey = !0), u;\n}, F7 = (t, e, n) => {\n  const { modifiers: r, loc: i } = t, s = t.arg;\n  let { exp: o } = t;\n  if (o && o.type === 4 && !o.content.trim() && (o = void 0), !o) {\n    if (s.type !== 4 || !s.isStatic)\n      return n.onError(\n        Ge(\n          52,\n          s.loc\n        )\n      ), {\n        props: [\n          yt(s, Ee(\"\", !0, i))\n        ]\n      };\n    const a = mt(s.content);\n    o = t.exp = Ee(a, !1, s.loc);\n  }\n  return s.type !== 4 ? (s.children.unshift(\"(\"), s.children.push(') || \"\"')) : s.isStatic || (s.content = `${s.content} || \"\"`), r.includes(\"camel\") && (s.type === 4 ? s.isStatic ? s.content = mt(s.content) : s.content = `${n.helperString(Xp)}(${s.content})` : (s.children.unshift(`${n.helperString(Xp)}(`), s.children.push(\")\"))), n.inSSR || (r.includes(\"prop\") && oy(s, \".\"), r.includes(\"attr\") && oy(s, \"^\")), {\n    props: [yt(s, o)]\n  };\n}, oy = (t, e) => {\n  t.type === 4 ? t.isStatic ? t.content = e + t.content : t.content = `\\`${e}\\${${t.content}}\\`` : (t.children.unshift(`'${e}' + (`), t.children.push(\")\"));\n}, G7 = (t, e) => {\n  if (t.type === 0 || t.type === 1 || t.type === 11 || t.type === 10)\n    return () => {\n      const n = t.children;\n      let r, i = !1;\n      for (let s = 0; s < n.length; s++) {\n        const o = n[s];\n        if (eh(o)) {\n          i = !0;\n          for (let a = s + 1; a < n.length; a++) {\n            const l = n[a];\n            if (eh(l))\n              r || (r = n[s] = pr(\n                [o],\n                o.loc\n              )), r.children.push(\" + \", l), n.splice(a, 1), a--;\n            else {\n              r = void 0;\n              break;\n            }\n          }\n        }\n      }\n      if (!(!i || // if this is a plain element with a single text child, leave it\n      // as-is since the runtime has dedicated fast path for this by directly\n      // setting textContent of the element.\n      // for component root it's always normalized anyway.\n      n.length === 1 && (t.type === 0 || t.type === 1 && t.tagType === 0 && // #3756\n      // custom directives can potentially add DOM elements arbitrarily,\n      // we need to avoid setting textContent of the element at runtime\n      // to avoid accidentally overwriting the DOM elements added\n      // by the user through custom directives.\n      !t.props.find(\n        (s) => s.type === 7 && !e.directiveTransforms[s.name]\n      ) && t.tag !== \"template\")))\n        for (let s = 0; s < n.length; s++) {\n          const o = n[s];\n          if (eh(o) || o.type === 8) {\n            const a = [];\n            (o.type !== 2 || o.content !== \" \") && a.push(o), !e.ssr && Kn(o, e) === 0 && a.push(\n              1 + ( true ? ` /* ${Dr[1]} */` : 0)\n            ), n[s] = {\n              type: 12,\n              content: o,\n              loc: o.loc,\n              codegenNode: Dt(\n                e.helper(Ng),\n                a\n              )\n            };\n          }\n        }\n    };\n}, ay = /* @__PURE__ */ new WeakSet(), K7 = (t, e) => {\n  if (t.type === 1 && zn(t, \"once\", !0))\n    return ay.has(t) || e.inVOnce || e.inSSR ? void 0 : (ay.add(t), e.inVOnce = !0, e.helper(rd), () => {\n      e.inVOnce = !1;\n      const n = e.currentNode;\n      n.codegenNode && (n.codegenNode = e.cache(\n        n.codegenNode,\n        !0\n        /* isVNode */\n      ));\n    });\n}, u_ = (t, e, n) => {\n  const { exp: r, arg: i } = t;\n  if (!r)\n    return n.onError(\n      Ge(41, t.loc)\n    ), Yc();\n  const s = r.loc.source, o = r.type === 4 ? r.content : s, a = n.bindingMetadata[s];\n  if (a === \"props\" || a === \"props-aliased\")\n    return n.onError(Ge(44, r.loc)), Yc();\n  if (!o.trim() || !LP(o) && !!1)\n    return n.onError(\n      Ge(42, r.loc)\n    ), Yc();\n  const c = i || Ee(\"modelValue\", !0), u = i ? xn(i) ? `onUpdate:${mt(i.content)}` : pr(['\"onUpdate:\" + ', i]) : \"onUpdate:modelValue\";\n  let d;\n  const f = n.isTS ? \"($event: any)\" : \"$event\";\n  d = pr([\n    `${f} => ((`,\n    r,\n    \") = $event)\"\n  ]);\n  const h = [\n    // modelValue: foo\n    yt(c, t.exp),\n    // \"onUpdate:modelValue\": $event => (foo = $event)\n    yt(u, d)\n  ];\n  if (t.modifiers.length && e.tagType === 1) {\n    const p = t.modifiers.map((m) => (zg(m) ? m : JSON.stringify(m)) + \": true\").join(\", \"), O = i ? xn(i) ? `${i.content}Modifiers` : pr([i, ' + \"Modifiers\"']) : \"modelModifiers\";\n    h.push(\n      yt(\n        O,\n        Ee(\n          `{ ${p} }`,\n          !1,\n          t.loc,\n          2\n        )\n      )\n    );\n  }\n  return Yc(h);\n};\nfunction Yc(t = []) {\n  return { props: t };\n}\nconst J7 = /[\\w).+\\-_$\\]]/, ej = (t, e) => {\n  es(\"COMPILER_FILTERS\", e) && (t.type === 5 && ud(t.content, e), t.type === 1 && t.props.forEach((n) => {\n    n.type === 7 && n.name !== \"for\" && n.exp && ud(n.exp, e);\n  }));\n};\nfunction ud(t, e) {\n  if (t.type === 4)\n    ly(t, e);\n  else\n    for (let n = 0; n < t.children.length; n++) {\n      const r = t.children[n];\n      typeof r == \"object\" && (r.type === 4 ? ly(r, e) : r.type === 8 ? ud(t, e) : r.type === 5 && ud(r.content, e));\n    }\n}\nfunction ly(t, e) {\n  const n = t.content;\n  let r = !1, i = !1, s = !1, o = !1, a = 0, l = 0, c = 0, u = 0, d, f, h, p, O = [];\n  for (h = 0; h < n.length; h++)\n    if (f = d, d = n.charCodeAt(h), r)\n      d === 39 && f !== 92 && (r = !1);\n    else if (i)\n      d === 34 && f !== 92 && (i = !1);\n    else if (s)\n      d === 96 && f !== 92 && (s = !1);\n    else if (o)\n      d === 47 && f !== 92 && (o = !1);\n    else if (d === 124 && // pipe\n    n.charCodeAt(h + 1) !== 124 && n.charCodeAt(h - 1) !== 124 && !a && !l && !c)\n      p === void 0 ? (u = h + 1, p = n.slice(0, h).trim()) : m();\n    else {\n      switch (d) {\n        case 34:\n          i = !0;\n          break;\n        case 39:\n          r = !0;\n          break;\n        case 96:\n          s = !0;\n          break;\n        case 40:\n          c++;\n          break;\n        case 41:\n          c--;\n          break;\n        case 91:\n          l++;\n          break;\n        case 93:\n          l--;\n          break;\n        case 123:\n          a++;\n          break;\n        case 125:\n          a--;\n          break;\n      }\n      if (d === 47) {\n        let y = h - 1, b;\n        for (; y >= 0 && (b = n.charAt(y), b === \" \"); y--)\n          ;\n        (!b || !J7.test(b)) && (o = !0);\n      }\n    }\n  p === void 0 ? p = n.slice(0, h).trim() : u !== 0 && m();\n  function m() {\n    O.push(n.slice(u, h).trim()), u = h + 1;\n  }\n  if (O.length) {\n    for ( true && sd(\n      \"COMPILER_FILTERS\",\n      e,\n      t.loc\n    ), h = 0; h < O.length; h++)\n      p = tj(p, O[h], e);\n    t.content = p;\n  }\n}\nfunction tj(t, e, n) {\n  n.helper(Ig);\n  const r = e.indexOf(\"(\");\n  if (r < 0)\n    return n.filters.add(e), `${Cl(e, \"filter\")}(${t})`;\n  {\n    const i = e.slice(0, r), s = e.slice(r + 1);\n    return n.filters.add(i), `${Cl(i, \"filter\")}(${t}${s !== \")\" ? \",\" + s : s}`;\n  }\n}\nconst cy = /* @__PURE__ */ new WeakSet(), nj = (t, e) => {\n  if (t.type === 1) {\n    const n = zn(t, \"memo\");\n    return !n || cy.has(t) ? void 0 : (cy.add(t), () => {\n      const r = t.codegenNode || e.currentNode.codegenNode;\n      r && r.type === 13 && (t.tagType !== 1 && qg(r, e), t.codegenNode = Dt(e.helper(Ug), [\n        n.exp,\n        Fo(void 0, r),\n        \"_cache\",\n        String(e.cached++)\n      ]));\n    });\n  }\n};\nfunction rj(t) {\n  return [\n    [\n      K7,\n      A7,\n      nj,\n      Z7,\n      ej,\n      ... true ? [C7] : 0,\n      Y7,\n      j7,\n      W7,\n      G7\n    ],\n    {\n      on: c_,\n      bind: F7,\n      model: u_\n    }\n  ];\n}\nfunction ij(t, e = {}) {\n  const n = e.onError || Yg, r = e.mode === \"module\";\n  e.prefixIdentifiers === !0 ? n(Ge(47)) : r && n(Ge(48));\n  const i = !1;\n  e.cacheHandlers && n(Ge(49)), e.scopeId && !r && n(Ge(50));\n  const s = $e({}, e, {\n    prefixIdentifiers: i\n  }), o = we(t) ? s7(t, s) : t, [a, l] = rj();\n  return c7(\n    o,\n    $e({}, s, {\n      nodeTransforms: [\n        ...a,\n        ...e.nodeTransforms || []\n        // user transforms\n      ],\n      directiveTransforms: $e(\n        {},\n        l,\n        e.directiveTransforms || {}\n        // user transforms\n      )\n    })\n  ), h7(o, s);\n}\nconst sj = () => ({ props: [] });\n/**\n* @vue/compiler-dom v3.4.21\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\nconst d_ = Symbol( true ? \"vModelRadio\" : 0), f_ = Symbol( true ? \"vModelCheckbox\" : 0), h_ = Symbol( true ? \"vModelText\" : 0), p_ = Symbol( true ? \"vModelSelect\" : 0), Hp = Symbol( true ? \"vModelDynamic\" : 0), O_ = Symbol( true ? \"vOnModifiersGuard\" : 0), g_ = Symbol( true ? \"vOnKeysGuard\" : 0), m_ = Symbol( true ? \"vShow\" : 0), Fg = Symbol( true ? \"Transition\" : 0), b_ = Symbol( true ? \"TransitionGroup\" : 0);\nA4({\n  [d_]: \"vModelRadio\",\n  [f_]: \"vModelCheckbox\",\n  [h_]: \"vModelText\",\n  [p_]: \"vModelSelect\",\n  [Hp]: \"vModelDynamic\",\n  [O_]: \"withModifiers\",\n  [g_]: \"withKeys\",\n  [m_]: \"vShow\",\n  [Fg]: \"Transition\",\n  [b_]: \"TransitionGroup\"\n});\nlet co;\nfunction oj(t, e = !1) {\n  return co || (co = document.createElement(\"div\")), e ? (co.innerHTML = `<div foo=\"${t.replace(/\"/g, \"&quot;\")}\">`, co.children[0].getAttribute(\"foo\")) : (co.innerHTML = t, co.textContent);\n}\nconst aj = {\n  parseMode: \"html\",\n  isVoidTag: H_,\n  isNativeTag: (t) => by(t) || vy(t) || yy(t),\n  isPreTag: (t) => t === \"pre\",\n  decodeEntities: oj,\n  isBuiltInComponent: (t) => {\n    if (t === \"Transition\" || t === \"transition\")\n      return Fg;\n    if (t === \"TransitionGroup\" || t === \"transition-group\")\n      return b_;\n  },\n  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher\n  getNamespace(t, e, n) {\n    let r = e ? e.ns : n;\n    if (e && r === 2)\n      if (e.tag === \"annotation-xml\") {\n        if (t === \"svg\")\n          return 1;\n        e.props.some(\n          (i) => i.type === 6 && i.name === \"encoding\" && i.value != null && (i.value.content === \"text/html\" || i.value.content === \"application/xhtml+xml\")\n        ) && (r = 0);\n      } else\n        /^m(?:[ions]|text)$/.test(e.tag) && t !== \"mglyph\" && t !== \"malignmark\" && (r = 0);\n    else\n      e && r === 1 && (e.tag === \"foreignObject\" || e.tag === \"desc\" || e.tag === \"title\") && (r = 0);\n    if (r === 0) {\n      if (t === \"svg\")\n        return 1;\n      if (t === \"math\")\n        return 2;\n    }\n    return r;\n  }\n}, lj = (t) => {\n  t.type === 1 && t.props.forEach((e, n) => {\n    e.type === 6 && e.name === \"style\" && e.value && (t.props[n] = {\n      type: 7,\n      name: \"bind\",\n      arg: Ee(\"style\", !0, e.loc),\n      exp: cj(e.value.content, e.loc),\n      modifiers: [],\n      loc: e.loc\n    });\n  });\n}, cj = (t, e) => {\n  const n = gy(t);\n  return Ee(\n    JSON.stringify(n),\n    !1,\n    e,\n    3\n  );\n};\nfunction dr(t, e) {\n  return Ge(\n    t,\n    e,\n     true ? uj : 0\n  );\n}\nconst uj = {\n  53: \"v-html is missing expression.\",\n  54: \"v-html will override element children.\",\n  55: \"v-text is missing expression.\",\n  56: \"v-text will override element children.\",\n  57: \"v-model can only be used on <input>, <textarea> and <select> elements.\",\n  58: \"v-model argument is not supported on plain elements.\",\n  59: \"v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.\",\n  60: \"Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.\",\n  61: \"v-show is missing expression.\",\n  62: \"<Transition> expects exactly one child element or component.\",\n  63: \"Tags with side effect (<script> and <style>) are ignored in client component templates.\"\n}, dj = (t, e, n) => {\n  const { exp: r, loc: i } = t;\n  return r || n.onError(\n    dr(53, i)\n  ), e.children.length && (n.onError(\n    dr(54, i)\n  ), e.children.length = 0), {\n    props: [\n      yt(\n        Ee(\"innerHTML\", !0, i),\n        r || Ee(\"\", !0)\n      )\n    ]\n  };\n}, fj = (t, e, n) => {\n  const { exp: r, loc: i } = t;\n  return r || n.onError(\n    dr(55, i)\n  ), e.children.length && (n.onError(\n    dr(56, i)\n  ), e.children.length = 0), {\n    props: [\n      yt(\n        Ee(\"textContent\", !0),\n        r ? Kn(r, n) > 0 ? r : Dt(\n          n.helperString(Jd),\n          [r],\n          i\n        ) : Ee(\"\", !0)\n      )\n    ]\n  };\n}, hj = (t, e, n) => {\n  const r = u_(t, e, n);\n  if (!r.props.length || e.tagType === 1)\n    return r;\n  t.arg && n.onError(\n    dr(\n      58,\n      t.arg.loc\n    )\n  );\n  function i() {\n    const a = zn(e, \"bind\");\n    a && Li(a.arg, \"value\") && n.onError(\n      dr(\n        60,\n        a.loc\n      )\n    );\n  }\n  const { tag: s } = e, o = n.isCustomElement(s);\n  if (s === \"input\" || s === \"textarea\" || s === \"select\" || o) {\n    let a = h_, l = !1;\n    if (s === \"input\" || o) {\n      const c = Ql(e, \"type\");\n      if (c) {\n        if (c.type === 7)\n          a = Hp;\n        else if (c.value)\n          switch (c.value.content) {\n            case \"radio\":\n              a = d_;\n              break;\n            case \"checkbox\":\n              a = f_;\n              break;\n            case \"file\":\n              l = !0, n.onError(\n                dr(\n                  59,\n                  t.loc\n                )\n              );\n              break;\n            default:\n               true && i();\n              break;\n          }\n      } else\n        L4(e) ? a = Hp :  true && i();\n    } else\n      s === \"select\" ? a = p_ :  true && i();\n    l || (r.needRuntime = n.helper(a));\n  } else\n    n.onError(\n      dr(\n        57,\n        t.loc\n      )\n    );\n  return r.props = r.props.filter(\n    (a) => !(a.key.type === 4 && a.key.content === \"modelValue\")\n  ), r;\n}, pj = /* @__PURE__ */ Bt(\"passive,once,capture\"), Oj = /* @__PURE__ */ Bt(\n  // event propagation management\n  \"stop,prevent,self,ctrl,shift,alt,meta,exact,middle\"\n), gj = /* @__PURE__ */ Bt(\"left,right\"), v_ = /* @__PURE__ */ Bt(\n  \"onkeyup,onkeydown,onkeypress\",\n  !0\n), mj = (t, e, n, r) => {\n  const i = [], s = [], o = [];\n  for (let a = 0; a < e.length; a++) {\n    const l = e[a];\n    l === \"native\" && Jo(\n      \"COMPILER_V_ON_NATIVE\",\n      n,\n      r\n    ) || pj(l) ? o.push(l) : gj(l) ? xn(t) ? v_(t.content) ? i.push(l) : s.push(l) : (i.push(l), s.push(l)) : Oj(l) ? s.push(l) : i.push(l);\n  }\n  return {\n    keyModifiers: i,\n    nonKeyModifiers: s,\n    eventOptionModifiers: o\n  };\n}, uy = (t, e) => xn(t) && t.content.toLowerCase() === \"onclick\" ? Ee(e, !0) : t.type !== 4 ? pr([\n  \"(\",\n  t,\n  `) === \"onClick\" ? \"${e}\" : (`,\n  t,\n  \")\"\n]) : t, bj = (t, e, n) => c_(t, e, n, (r) => {\n  const { modifiers: i } = t;\n  if (!i.length)\n    return r;\n  let { key: s, value: o } = r.props[0];\n  const { keyModifiers: a, nonKeyModifiers: l, eventOptionModifiers: c } = mj(s, i, n, t.loc);\n  if (l.includes(\"right\") && (s = uy(s, \"onContextmenu\")), l.includes(\"middle\") && (s = uy(s, \"onMouseup\")), l.length && (o = Dt(n.helper(O_), [\n    o,\n    JSON.stringify(l)\n  ])), a.length && // if event name is dynamic, always wrap with keys guard\n  (!xn(s) || v_(s.content)) && (o = Dt(n.helper(g_), [\n    o,\n    JSON.stringify(a)\n  ])), c.length) {\n    const u = c.map(Wr).join(\"\");\n    s = xn(s) ? Ee(`${s.content}${u}`, !0) : pr([\"(\", s, `) + \"${u}\"`]);\n  }\n  return {\n    props: [yt(s, o)]\n  };\n}), vj = (t, e, n) => {\n  const { exp: r, loc: i } = t;\n  return r || n.onError(\n    dr(61, i)\n  ), {\n    props: [],\n    needRuntime: n.helper(m_)\n  };\n}, yj = (t, e) => {\n  if (t.type === 1 && t.tagType === 1 && e.isBuiltInComponent(t.tag) === Fg)\n    return () => {\n      if (!t.children.length)\n        return;\n      y_(t) && e.onError(\n        dr(\n          62,\n          {\n            start: t.children[0].loc.start,\n            end: t.children[t.children.length - 1].loc.end,\n            source: \"\"\n          }\n        )\n      );\n      const r = t.children[0];\n      if (r.type === 1)\n        for (const i of r.props)\n          i.type === 7 && i.name === \"show\" && t.props.push({\n            type: 6,\n            name: \"persisted\",\n            nameLoc: t.loc,\n            value: void 0,\n            loc: t.loc\n          });\n    };\n};\nfunction y_(t) {\n  const e = t.children = t.children.filter(\n    (r) => r.type !== 3 && !(r.type === 2 && !r.content.trim())\n  ), n = e[0];\n  return e.length !== 1 || n.type === 11 || n.type === 9 && n.branches.some(y_);\n}\nconst Sj = (t, e) => {\n  t.type === 1 && t.tagType === 0 && (t.tag === \"script\" || t.tag === \"style\") && ( true && e.onError(\n    dr(\n      63,\n      t.loc\n    )\n  ), e.removeNode());\n}, wj = [\n  lj,\n  ... true ? [yj] : 0\n], kj = {\n  cloak: sj,\n  html: dj,\n  text: fj,\n  model: hj,\n  // override compiler-core\n  on: bj,\n  // override compiler-core\n  show: vj\n};\nfunction xj(t, e = {}) {\n  return ij(\n    t,\n    $e({}, aj, e, {\n      nodeTransforms: [\n        // ignore <script> and <tag>\n        // this is not put inside DOMNodeTransforms because that list is used\n        // by compiler-ssr to generate vnode fallback branches\n        Sj,\n        ...wj,\n        ...e.nodeTransforms || []\n      ],\n      directiveTransforms: $e(\n        {},\n        kj,\n        e.directiveTransforms || {}\n      ),\n      transformHoist: null\n    })\n  );\n}\n/**\n* vue v3.4.21\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/\nfunction Pj() {\n  CO();\n}\n true && Pj();\nconst dy = /* @__PURE__ */ new WeakMap();\nfunction _j(t) {\n  let e = dy.get(t ?? Ve);\n  return e || (e = /* @__PURE__ */ Object.create(null), dy.set(t ?? Ve, e)), e;\n}\nfunction Tj(t, e) {\n  if (!we(t))\n    if (t.nodeType)\n      t = t.innerHTML;\n    else\n      return  true && Xt(\"invalid template option: \", t), it;\n  const n = t, r = _j(e), i = r[n];\n  if (i)\n    return i;\n  if (t[0] === \"#\") {\n    const c = document.querySelector(t);\n     true && !c && Xt(`Template element not found or is empty: ${t}`), t = c ? c.innerHTML : \"\";\n  }\n  const s = $e(\n    {\n      hoistStatic: !0,\n      onError:  true ? a : 0,\n      onWarn:  true ? (c) => a(c, !0) : 0\n    },\n    e\n  );\n  !s.isCustomElement && typeof customElements < \"u\" && (s.isCustomElement = (c) => !!customElements.get(c));\n  const { code: o } = xj(t, s);\n  function a(c, u = !1) {\n    const d = u ? c.message : `Template compilation error: ${c.message}`, f = c.loc && M_(\n      t,\n      c.loc.start.offset,\n      c.loc.end.offset\n    );\n    Xt(f ? `${d}\n${f}` : d);\n  }\n  const l = new Function(\"Vue\", o)(yQ);\n  return l._rc = !0, r[n] = l;\n}\nM1(Tj);\nglobalThis.__VUE_OPTIONS_API__ = !0;\nglobalThis.__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ = !0;\nglobalThis.__VUE_PROD_DEVTOOLS__ = !1;\nconst Ej = (t) => {\n  const e = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    if (!e.current)\n      return;\n    const n = hS(_4, {\n      proxyUrl: t.proxy\n    });\n    return n.mount(e.current), () => n.unmount();\n  }, [e]), /* @__PURE__ */ Hr.jsx(\"div\", { ref: e });\n}, { resetActiveResponse: $j, setActiveRequest: Qj } = sr(), Ij = ({\n  proxy: t = \"\",\n  close: e,\n  isOpen: n = !1,\n  request: r\n}) => {\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    $j(), r && Qj(r);\n  }, [n, r]);\n  const [i, s] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n  return (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => s(window.location.host), []), /* @__PURE__ */ Hr.jsx(\n    \"div\",\n    {\n      className: \"scalar\",\n      style: { display: n ? \"block\" : \"none\" },\n      children: /* @__PURE__ */ Hr.jsxs(\"div\", { className: \"scalar-container\", children: [\n        /* @__PURE__ */ Hr.jsxs(\"div\", { className: \"scalar-app\", children: [\n          /* @__PURE__ */ Hr.jsxs(\"div\", { className: \"scalar-app-header\", children: [\n            /* @__PURE__ */ Hr.jsx(\"span\", { children: \"API Client\" }),\n            /* @__PURE__ */ Hr.jsx(\n              \"a\",\n              {\n                href: `https://www.scalar.com?utm_campaign=${i}`,\n                target: \"_blank\",\n                children: \"Powered by scalar.com\"\n              }\n            )\n          ] }),\n          /* @__PURE__ */ Hr.jsx(Ej, { proxy: t })\n        ] }),\n        /* @__PURE__ */ Hr.jsx(\n          \"div\",\n          {\n            onClick: e,\n            className: \"scalar-app-exit\"\n          }\n        )\n      ] })\n    }\n  );\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2NhbGFyL2FwaS1jbGllbnQtcmVhY3QvZGlzdC9pbmRleC1ERzA4NkZaVC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQXFCO0FBQ3FEO0FBQzFFLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxrQ0FBRSw0TEFBNEw7QUFDeE07QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixLQUFxQztBQUM3RCxZQUFZLGtDQUFFO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLFFBQVE7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiLHNCQUFzQjtBQUN0QjtBQUNBLGFBQWE7QUFDYixzQkFBc0I7QUFDdEI7QUFDQSxhQUFhO0FBQ2IsdUJBQXVCO0FBQ3ZCO0FBQ0EsYUFBYTtBQUNiLHVCQUF1QjtBQUN2QjtBQUNBLGFBQWE7QUFDYixnQ0FBZ0M7QUFDaEM7QUFDQSxhQUFhO0FBQ2IsMEJBQTBCO0FBQzFCO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMseUNBQXlDO0FBQ3JGO0FBQ0EsaUJBQWlCLG9CQUFvQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUdBQW1HO0FBQ25HO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EscUdBQXFHO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FB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QSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEdBQUcsZ0VBQWdFLDhCQUE4QjtBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFxQyx5Q0FBeUMsVUFBVTtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQXFDO0FBQ2hELHFEQUFxRCxFQUFFO0FBQ3ZEO0FBQ0E7QUFDQSxTQUFTLEtBQXFDO0FBQzlDLHFDQUFxQyxlQUFlO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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WSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELGNBQWM7QUFDZDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLFVBQVUsWUFBWTtBQUN0QixTQUFTLEtBQUs7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1osQ0FBQztBQUNEO0FBQ0EsNENBQTRDLFdBQVc7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRyxNQUFNO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixlQUFlO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxtQkFBbUI7QUFDaEY7QUFDQSxTQUFTLGVBQWU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsVUFBVTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK01BQStNO0FBQy9NLEtBQUs7QUFDTDtBQUNBLHNEQUFzRCxxQkFBcUI7QUFDM0U7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHNCQUFzQixLQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGdCQUFnQiwwQkFBMEIsZ0JBQWdCO0FBQ2xHO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsS0FBSztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFNBQVMsSUFBSSxFQUFFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsRUFBRSxFQUFFLEtBQUs7QUFDekI7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGdEQUFnRCxnREFBZ0Qsc0RBQXNEO0FBQ3pNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLEVBQUU7QUFDeEMscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJLDRCQUE0QjtBQUNoQyxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixzSEFBc0g7QUFDdEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGlCQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGlCQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDJDQUEyQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUcsb0hBQW9IO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSwwREFBMEQ7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxrQkFBa0I7QUFDL0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLFVBQVU7QUFDVix3QkFBd0I7QUFDeEIsR0FBRztBQUNIO0FBQ0E7QUFDQSwwQ0FBMEMsUUFBUTtBQUNsRCxnREFBZ0QsUUFBUTtBQUN4RDtBQUNBLDhCQUE4Qix1QkFBdUI7QUFDckQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QixpRkFBaUYsY0FBYztBQUMvRjtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsRUFBRSxHQUFHO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxjQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdCQUFnQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGFBQWE7QUFDZDtBQUNBLENBQUM7QUFDRDtBQUNBLFVBQVUsYUFBYTtBQUN2QjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsVUFBVTtBQUNWLGdCQUFnQjtBQUNoQixhQUFhLGVBQWU7QUFDNUI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtDQUFrQztBQUNwRCxLQUFLO0FBQ0w7QUFDQSx3Q0FBd0MsMkRBQTJEO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxHQUFHLHdCQUF3QixZQUFZO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELEdBQUcsS0FBSyxXQUFXO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnQ0FBZ0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsR0FBRywwQ0FBMEMsRUFBRTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9DQUFvQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxZQUFZO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3QkFBd0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpQ0FBaUM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSkFBMEosdUNBQXVDO0FBQ2pNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLEVBQUU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZUFBZTtBQUNoQjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVyxJQUFJLE9BQU87QUFDOUQsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQ0FBcUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMkJBQTJCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1DQUFtQztBQUNwRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxxRUFBcUU7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQ0FBaUM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBLFdBQVcsMkNBQTJDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2Qyw0QkFBNEIsVUFBVSxrQkFBa0I7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOEJBQThCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVCQUF1QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwyQkFBMkI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZUFBZTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxtQkFBbUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHFDQUFxQztBQUM3QywyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQSxjQUFjLGtDQUFrQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGVBQWU7QUFDaEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGVBQWU7QUFDakM7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG9CQUFvQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsa0JBQWtCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQSxVQUFVLFVBQVU7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLEdBQUc7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGlCQUFpQjtBQUNqRTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBVSw4QkFBOEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMseUNBQXlDO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMkNBQTJDLGlGQUFpRjtBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQSxzRUFBc0UsV0FBVztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQ0FBaUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBOEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLFVBQVUsWUFBWTtBQUN2QjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHdCQUF3QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQkFBZ0I7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixJQUFJO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixZQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxHQUFHO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLEdBQUc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxzQkFBc0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUNBQW1DO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsV0FBVztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQyxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMEJBQTBCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSwwQkFBMEI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQSxpQkFBaUIsNEhBQTRIO0FBQzdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4Q0FBOEM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQ0FBZ0M7QUFDcEMsSUFBSSxzQ0FBc0M7QUFDMUMsSUFBSSx3Q0FBd0M7QUFDNUMsSUFBSSxvQ0FBb0M7QUFDeEMsSUFBSSxzQ0FBc0M7QUFDMUMsSUFBSSxnQ0FBZ0M7QUFDcEMsSUFBSSxnQ0FBZ0M7QUFDcEMsSUFBSSw4QkFBOEI7QUFDbEMsSUFBSSwwQ0FBMEM7QUFDOUMsSUFBSSx3Q0FBd0M7QUFDNUMsSUFBSSxzQ0FBc0M7QUFDMUMsSUFBSSxzQ0FBc0M7QUFDMUMsSUFBSSxvQ0FBb0M7QUFDeEMsSUFBSSxvQ0FBb0M7QUFDeEMsSUFBSSxzRUFBc0U7QUFDMUUsSUFBSSxnREFBZ0Q7QUFDcEQsSUFBSSxtRUFBbUU7QUFDdkUsSUFBSSw2RUFBNkU7QUFDakYsSUFBSSw0REFBNEQ7QUFDaEUsSUFBSSw2RUFBNkU7QUFDakYsSUFBSSx3Q0FBd0M7QUFDNUMsSUFBSSwwQ0FBMEM7QUFDOUMsSUFBSSwwQ0FBMEM7QUFDOUMsSUFBSSwwQ0FBMEM7QUFDOUMsSUFBSSxnREFBZ0Q7QUFDcEQsSUFBSSx3Q0FBd0M7QUFDNUMsSUFBSSxzQ0FBc0M7QUFDMUMsSUFBSSxnQ0FBZ0M7QUFDcEMsSUFBSSxzQ0FBc0M7QUFDMUMsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUhBQXVIO0FBQ3ZIO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwyQkFBMkI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdDQUFnQztBQUN2RDtBQUNBLHFCQUFxQiwyQkFBMkI7QUFDaEQ7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLEdBQUc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJMQUEyTDtBQUMzTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDZCQUE2QjtBQUMxQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNEJBQTRCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw2REFBNkQ7QUFDdkU7QUFDQTtBQUNBLHVEQUF1RCxvQ0FBb0MsMERBQTBELG1EQUFtRDtBQUN4TTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QyxZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG9DQUFvQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsZ0JBQWdCO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsV0FBVztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsc0JBQXNCLFVBQVU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0hBQW9ILDRDQUE0QztBQUNoSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMEJBQTBCO0FBQ3ZELEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywyQ0FBMkM7QUFDbkYsbUVBQW1FLG9CQUFvQiwrQkFBK0IsMENBQTBDLElBQUksa0RBQWtEO0FBQ3ROO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1CQUFtQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1CQUFtQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsbUJBQW1CO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0EsK0JBQStCLFFBQVE7QUFDdkMsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEdBQUc7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYSxxQ0FBcUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsR0FBRztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMseUNBQXlDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywwQkFBMEIsSUFBSTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixVQUFVO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFdBQVc7QUFDckIsZUFBZSxVQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0RBQWdEO0FBQ3pFO0FBQ0EsNEJBQTRCLDRCQUE0QjtBQUN4RCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsaURBQWlEO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPLFdBQVc7QUFDNUQsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLGNBQWM7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQSx3RUFBd0UsVUFBVTtBQUNsRixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsOEJBQThCO0FBQ3RFLDJDQUEyQztBQUMzQyxDQUFDLHlCQUF5QjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDLGtDQUFrQyw2QkFBNkIsa0NBQWtDLGdDQUFnQztBQUNsSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxrQkFBa0IsR0FBRztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3QkFBd0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUIseUJBQXlCO0FBQ2pFLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMseUJBQXlCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdEQUFnRDtBQUM1RCxrQkFBa0IsMEJBQTBCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxRQUFRO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUIsNEJBQTRCO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsR0FBRyxpREFBaUQsR0FBRyx3RkFBd0YsRUFBRTtBQUNoTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0QkFBNEI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGVBQWUsRUFBRSw4QkFBOEI7QUFDN0Y7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFdBQVc7QUFDM0Q7QUFDQTtBQUNBLCtCQUErQixvREFBb0Q7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsR0FBRztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFlBQVk7QUFDcEIsc0NBQXNDLGFBQWEsS0FBSyxFQUFFLEdBQUcsYUFBYTtBQUMxRTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFVBQVU7QUFDbEIsdUNBQXVDLHdHQUF3RyxXQUFXO0FBQzFKLGVBQWUsa0VBQWtFO0FBQ2pGO0FBQ0EsR0FBRyxNQUFNLGlEQUFpRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUscURBQXFEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsZ0JBQWdCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGdCQUFnQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEVBQUUsSUFBSSxNQUFNLElBQUksYUFBYSxNQUFNO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsZ0NBQWdDLDBCQUEwQjtBQUMxRDtBQUNBLFlBQVksYUFBYTtBQUN6QixnQ0FBZ0Msb0JBQW9CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EseUdBQXlHLHNCQUFzQjtBQUMvSCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUNBQXVDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQiwyQkFBMkIsVUFBVTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELEdBQUc7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsVUFBVTtBQUNuQyxZQUFZLDBCQUEwQixVQUFVLGFBQWE7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsYUFBYTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsVUFBVTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDBFQUEwRSxtQkFBbUIsaUNBQWlDO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxXQUFXO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLFdBQVcsaUNBQWlDO0FBQzVDO0FBQ0EsV0FBVyxpQ0FBaUM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sV0FBVztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxNQUFNO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVEsZ0JBQWdCO0FBQ3BFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0EsNkNBQTZDLCtCQUErQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QSxnQ0FBZ0MsNEJBQTRCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJCQUEyQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0QkFBNEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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aEMsNkJBQTZCO0FBQzdCO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsTUFBTSwwQ0FBMEM7QUFDaEQsTUFBTSxzREFBc0Q7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxjQUFjLEdBQUcsSUFBSTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFH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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxTQUFTLHNCQUFzQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0NBQXNDO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQ0FBbUM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLEtBQXFDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1S0FBdUssS0FBcUMsNkxBQTZMLEtBQXFDO0FBQzlhO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0R0FBNEcsS0FBcUM7QUFDako7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBJQUEwSSxLQUFxQztBQUMvSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkxBQTZMLEtBQXFDO0FBQ2xPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUNBQWlDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7QUFDakM7QUFDQSxXQUFXLDBCQUEwQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0EsMEJBQTBCLFFBQVE7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsUUFBUSxLQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdCQUFnQixlQUFlO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMEdBQTBHLHFFQUFxRTtBQUMvSztBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQXFDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGtDQUFrQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxzRkFBc0YsdUJBQXVCLEdBQUc7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksS0FBcUMsUUFBUSxDQUFNO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsVUFBVSxpQkFBaUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELFVBQVUsaUJBQWlCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFRRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNjYWxhci9hcGktY2xpZW50LXJlYWN0L2Rpc3QvaW5kZXgtREcwODZGWlQuanM/YWExMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJy4vaW5kZXguY3NzJztcbmltcG9ydCBmeSwgeyB1c2VSZWYgYXMgJF8sIHVzZUVmZmVjdCBhcyByaCwgdXNlU3RhdGUgYXMgUV8gfSBmcm9tIFwicmVhY3RcIjtcbnZhciBpaCA9IHsgZXhwb3J0czoge30gfSwgbGEgPSB7fTtcbi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbnZhciBpbTtcbmZ1bmN0aW9uIENfKCkge1xuICBpZiAoaW0pXG4gICAgcmV0dXJuIGxhO1xuICBpbSA9IDE7XG4gIHZhciB0ID0gZnksIGUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKSwgbiA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKSwgciA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksIGkgPSB0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVELlJlYWN0Q3VycmVudE93bmVyLCBzID0geyBrZXk6ICEwLCByZWY6ICEwLCBfX3NlbGY6ICEwLCBfX3NvdXJjZTogITAgfTtcbiAgZnVuY3Rpb24gbyhhLCBsLCBjKSB7XG4gICAgdmFyIHUsIGQgPSB7fSwgZiA9IG51bGwsIGggPSBudWxsO1xuICAgIGMgIT09IHZvaWQgMCAmJiAoZiA9IFwiXCIgKyBjKSwgbC5rZXkgIT09IHZvaWQgMCAmJiAoZiA9IFwiXCIgKyBsLmtleSksIGwucmVmICE9PSB2b2lkIDAgJiYgKGggPSBsLnJlZik7XG4gICAgZm9yICh1IGluIGwpXG4gICAgICByLmNhbGwobCwgdSkgJiYgIXMuaGFzT3duUHJvcGVydHkodSkgJiYgKGRbdV0gPSBsW3VdKTtcbiAgICBpZiAoYSAmJiBhLmRlZmF1bHRQcm9wcylcbiAgICAgIGZvciAodSBpbiBsID0gYS5kZWZhdWx0UHJvcHMsIGwpXG4gICAgICAgIGRbdV0gPT09IHZvaWQgMCAmJiAoZFt1XSA9IGxbdV0pO1xuICAgIHJldHVybiB7ICQkdHlwZW9mOiBlLCB0eXBlOiBhLCBrZXk6IGYsIHJlZjogaCwgcHJvcHM6IGQsIF9vd25lcjogaS5jdXJyZW50IH07XG4gIH1cbiAgcmV0dXJuIGxhLkZyYWdtZW50ID0gbiwgbGEuanN4ID0gbywgbGEuanN4cyA9IG8sIGxhO1xufVxudmFyIGNhID0ge307XG4vKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG52YXIgc207XG5mdW5jdGlvbiBBXygpIHtcbiAgcmV0dXJuIHNtIHx8IChzbSA9IDEsIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IGZ5LCBlID0gU3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIiksIG4gPSBTeW1ib2wuZm9yKFwicmVhY3QucG9ydGFsXCIpLCByID0gU3ltYm9sLmZvcihcInJlYWN0LmZyYWdtZW50XCIpLCBpID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLCBzID0gU3ltYm9sLmZvcihcInJlYWN0LnByb2ZpbGVyXCIpLCBvID0gU3ltYm9sLmZvcihcInJlYWN0LnByb3ZpZGVyXCIpLCBhID0gU3ltYm9sLmZvcihcInJlYWN0LmNvbnRleHRcIiksIGwgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksIGMgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIiksIHUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VfbGlzdFwiKSwgZCA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tZW1vXCIpLCBmID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIiksIGggPSBTeW1ib2wuZm9yKFwicmVhY3Qub2Zmc2NyZWVuXCIpLCBwID0gU3ltYm9sLml0ZXJhdG9yLCBPID0gXCJAQGl0ZXJhdG9yXCI7XG4gICAgZnVuY3Rpb24gbShFKSB7XG4gICAgICBpZiAoRSA9PT0gbnVsbCB8fCB0eXBlb2YgRSAhPSBcIm9iamVjdFwiKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIHZhciBxID0gcCAmJiBFW3BdIHx8IEVbT107XG4gICAgICByZXR1cm4gdHlwZW9mIHEgPT0gXCJmdW5jdGlvblwiID8gcSA6IG51bGw7XG4gICAgfVxuICAgIHZhciB5ID0gdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcbiAgICBmdW5jdGlvbiBiKEUpIHtcbiAgICAgIHtcbiAgICAgICAgZm9yICh2YXIgcSA9IGFyZ3VtZW50cy5sZW5ndGgsIG9lID0gbmV3IEFycmF5KHEgPiAxID8gcSAtIDEgOiAwKSwgeGUgPSAxOyB4ZSA8IHE7IHhlKyspXG4gICAgICAgICAgb2VbeGUgLSAxXSA9IGFyZ3VtZW50c1t4ZV07XG4gICAgICAgIGcoXCJlcnJvclwiLCBFLCBvZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGcoRSwgcSwgb2UpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIHhlID0geS5SZWFjdERlYnVnQ3VycmVudEZyYW1lLCBxZSA9IHhlLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgICAgICAgcWUgIT09IFwiXCIgJiYgKHEgKz0gXCIlc1wiLCBvZSA9IG9lLmNvbmNhdChbcWVdKSk7XG4gICAgICAgIHZhciBudCA9IG9lLm1hcChmdW5jdGlvbihXZSkge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcoV2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgbnQudW5zaGlmdChcIldhcm5pbmc6IFwiICsgcSksIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbRV0sIGNvbnNvbGUsIG50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHYgPSAhMSwgUyA9ICExLCB3ID0gITEsIGsgPSAhMSwgXyA9ICExLCBUO1xuICAgIFQgPSBTeW1ib2wuZm9yKFwicmVhY3QubW9kdWxlLnJlZmVyZW5jZVwiKTtcbiAgICBmdW5jdGlvbiBDKEUpIHtcbiAgICAgIHJldHVybiAhISh0eXBlb2YgRSA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBFID09IFwiZnVuY3Rpb25cIiB8fCBFID09PSByIHx8IEUgPT09IHMgfHwgXyB8fCBFID09PSBpIHx8IEUgPT09IGMgfHwgRSA9PT0gdSB8fCBrIHx8IEUgPT09IGggfHwgdiB8fCBTIHx8IHcgfHwgdHlwZW9mIEUgPT0gXCJvYmplY3RcIiAmJiBFICE9PSBudWxsICYmIChFLiQkdHlwZW9mID09PSBmIHx8IEUuJCR0eXBlb2YgPT09IGQgfHwgRS4kJHR5cGVvZiA9PT0gbyB8fCBFLiQkdHlwZW9mID09PSBhIHx8IEUuJCR0eXBlb2YgPT09IGwgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgICAgLy8gdHlwZXMgc3VwcG9ydGVkIGJ5IGFueSBGbGlnaHQgY29uZmlndXJhdGlvbiBhbnl3aGVyZSBzaW5jZVxuICAgICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgICAvLyB3aXRoLlxuICAgICAgRS4kJHR5cGVvZiA9PT0gVCB8fCBFLmdldE1vZHVsZUlkICE9PSB2b2lkIDApKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQShFLCBxLCBvZSkge1xuICAgICAgdmFyIHhlID0gRS5kaXNwbGF5TmFtZTtcbiAgICAgIGlmICh4ZSlcbiAgICAgICAgcmV0dXJuIHhlO1xuICAgICAgdmFyIHFlID0gcS5kaXNwbGF5TmFtZSB8fCBxLm5hbWUgfHwgXCJcIjtcbiAgICAgIHJldHVybiBxZSAhPT0gXCJcIiA/IG9lICsgXCIoXCIgKyBxZSArIFwiKVwiIDogb2U7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFEoRSkge1xuICAgICAgcmV0dXJuIEUuZGlzcGxheU5hbWUgfHwgXCJDb250ZXh0XCI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFcoRSkge1xuICAgICAgaWYgKEUgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBpZiAodHlwZW9mIEUudGFnID09IFwibnVtYmVyXCIgJiYgYihcIlJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIpLCB0eXBlb2YgRSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJldHVybiBFLmRpc3BsYXlOYW1lIHx8IEUubmFtZSB8fCBudWxsO1xuICAgICAgaWYgKHR5cGVvZiBFID09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBFO1xuICAgICAgc3dpdGNoIChFKSB7XG4gICAgICAgIGNhc2UgcjpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIG46XG4gICAgICAgICAgcmV0dXJuIFwiUG9ydGFsXCI7XG4gICAgICAgIGNhc2UgczpcbiAgICAgICAgICByZXR1cm4gXCJQcm9maWxlclwiO1xuICAgICAgICBjYXNlIGk6XG4gICAgICAgICAgcmV0dXJuIFwiU3RyaWN0TW9kZVwiO1xuICAgICAgICBjYXNlIGM6XG4gICAgICAgICAgcmV0dXJuIFwiU3VzcGVuc2VcIjtcbiAgICAgICAgY2FzZSB1OlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBFID09IFwib2JqZWN0XCIpXG4gICAgICAgIHN3aXRjaCAoRS4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgYTpcbiAgICAgICAgICAgIHZhciBxID0gRTtcbiAgICAgICAgICAgIHJldHVybiBRKHEpICsgXCIuQ29uc3VtZXJcIjtcbiAgICAgICAgICBjYXNlIG86XG4gICAgICAgICAgICB2YXIgb2UgPSBFO1xuICAgICAgICAgICAgcmV0dXJuIFEob2UuX2NvbnRleHQpICsgXCIuUHJvdmlkZXJcIjtcbiAgICAgICAgICBjYXNlIGw6XG4gICAgICAgICAgICByZXR1cm4gQShFLCBFLnJlbmRlciwgXCJGb3J3YXJkUmVmXCIpO1xuICAgICAgICAgIGNhc2UgZDpcbiAgICAgICAgICAgIHZhciB4ZSA9IEUuZGlzcGxheU5hbWUgfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB4ZSAhPT0gbnVsbCA/IHhlIDogVyhFLnR5cGUpIHx8IFwiTWVtb1wiO1xuICAgICAgICAgIGNhc2UgZjoge1xuICAgICAgICAgICAgdmFyIHFlID0gRSwgbnQgPSBxZS5fcGF5bG9hZCwgV2UgPSBxZS5faW5pdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBXKFdlKG50KSk7XG4gICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIEwgPSBPYmplY3QuYXNzaWduLCByZSA9IDAsIFksIEssIEIsIF9lLCBDZSwgdWUsIGdlO1xuICAgIGZ1bmN0aW9uIEJlKCkge1xuICAgIH1cbiAgICBCZS5fX3JlYWN0RGlzYWJsZWRMb2cgPSAhMDtcbiAgICBmdW5jdGlvbiBMZSgpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKHJlID09PSAwKSB7XG4gICAgICAgICAgWSA9IGNvbnNvbGUubG9nLCBLID0gY29uc29sZS5pbmZvLCBCID0gY29uc29sZS53YXJuLCBfZSA9IGNvbnNvbGUuZXJyb3IsIENlID0gY29uc29sZS5ncm91cCwgdWUgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkLCBnZSA9IGNvbnNvbGUuZ3JvdXBFbmQ7XG4gICAgICAgICAgdmFyIEUgPSB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICB2YWx1ZTogQmUsXG4gICAgICAgICAgICB3cml0YWJsZTogITBcbiAgICAgICAgICB9O1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICAgIGluZm86IEUsXG4gICAgICAgICAgICBsb2c6IEUsXG4gICAgICAgICAgICB3YXJuOiBFLFxuICAgICAgICAgICAgZXJyb3I6IEUsXG4gICAgICAgICAgICBncm91cDogRSxcbiAgICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBFLFxuICAgICAgICAgICAgZ3JvdXBFbmQ6IEVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZSsrO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBadCgpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKHJlLS0sIHJlID09PSAwKSB7XG4gICAgICAgICAgdmFyIEUgPSB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgICB3cml0YWJsZTogITBcbiAgICAgICAgICB9O1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICAgIGxvZzogTCh7fSwgRSwge1xuICAgICAgICAgICAgICB2YWx1ZTogWVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBpbmZvOiBMKHt9LCBFLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBLXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHdhcm46IEwoe30sIEUsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IEJcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZXJyb3I6IEwoe30sIEUsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IF9lXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGdyb3VwOiBMKHt9LCBFLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBDZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBncm91cENvbGxhcHNlZDogTCh7fSwgRSwge1xuICAgICAgICAgICAgICB2YWx1ZTogdWVcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgZ3JvdXBFbmQ6IEwoe30sIEUsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGdlXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJlIDwgMCAmJiBiKFwiZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIFZ0ID0geS5SZWFjdEN1cnJlbnREaXNwYXRjaGVyLCBJdDtcbiAgICBmdW5jdGlvbiBUbihFLCBxLCBvZSkge1xuICAgICAge1xuICAgICAgICBpZiAoSXQgPT09IHZvaWQgMClcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICB9IGNhdGNoIChxZSkge1xuICAgICAgICAgICAgdmFyIHhlID0gcWUuc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgICAgICBJdCA9IHhlICYmIHhlWzFdIHx8IFwiXCI7XG4gICAgICAgICAgfVxuICAgICAgICByZXR1cm4gYFxuYCArIEl0ICsgRTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIFNyID0gITEsIG9yO1xuICAgIHtcbiAgICAgIHZhciBFbiA9IHR5cGVvZiBXZWFrTWFwID09IFwiZnVuY3Rpb25cIiA/IFdlYWtNYXAgOiBNYXA7XG4gICAgICBvciA9IG5ldyBFbigpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2aShFLCBxKSB7XG4gICAgICBpZiAoIUUgfHwgU3IpXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAge1xuICAgICAgICB2YXIgb2UgPSBvci5nZXQoRSk7XG4gICAgICAgIGlmIChvZSAhPT0gdm9pZCAwKVxuICAgICAgICAgIHJldHVybiBvZTtcbiAgICAgIH1cbiAgICAgIHZhciB4ZTtcbiAgICAgIFNyID0gITA7XG4gICAgICB2YXIgcWUgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTtcbiAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdm9pZCAwO1xuICAgICAgdmFyIG50O1xuICAgICAgbnQgPSBWdC5jdXJyZW50LCBWdC5jdXJyZW50ID0gbnVsbCwgTGUoKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChxKSB7XG4gICAgICAgICAgdmFyIFdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZS5wcm90b3R5cGUsIFwicHJvcHNcIiwge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgdHlwZW9mIFJlZmxlY3QgPT0gXCJvYmplY3RcIiAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoV2UsIFtdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHFyKSB7XG4gICAgICAgICAgICAgIHhlID0gcXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChFLCBbXSwgV2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBXZS5jYWxsKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChxcikge1xuICAgICAgICAgICAgICB4ZSA9IHFyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgRS5jYWxsKFdlLnByb3RvdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKHFyKSB7XG4gICAgICAgICAgICB4ZSA9IHFyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBFKCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKHFyKSB7XG4gICAgICAgIGlmIChxciAmJiB4ZSAmJiB0eXBlb2YgcXIuc3RhY2sgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGZvciAodmFyIE5lID0gcXIuc3RhY2suc3BsaXQoYFxuYCksIGRuID0geGUuc3RhY2suc3BsaXQoYFxuYCksIFN0ID0gTmUubGVuZ3RoIC0gMSwgJHQgPSBkbi5sZW5ndGggLSAxOyBTdCA+PSAxICYmICR0ID49IDAgJiYgTmVbU3RdICE9PSBkblskdF07IClcbiAgICAgICAgICAgICR0LS07XG4gICAgICAgICAgZm9yICg7IFN0ID49IDEgJiYgJHQgPj0gMDsgU3QtLSwgJHQtLSlcbiAgICAgICAgICAgIGlmIChOZVtTdF0gIT09IGRuWyR0XSkge1xuICAgICAgICAgICAgICBpZiAoU3QgIT09IDEgfHwgJHQgIT09IDEpXG4gICAgICAgICAgICAgICAgZG9cbiAgICAgICAgICAgICAgICAgIGlmIChTdC0tLCAkdC0tLCAkdCA8IDAgfHwgTmVbU3RdICE9PSBkblskdF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHFuID0gYFxuYCArIE5lW1N0XS5yZXBsYWNlKFwiIGF0IG5ldyBcIiwgXCIgYXQgXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRS5kaXNwbGF5TmFtZSAmJiBxbi5pbmNsdWRlcyhcIjxhbm9ueW1vdXM+XCIpICYmIChxbiA9IHFuLnJlcGxhY2UoXCI8YW5vbnltb3VzPlwiLCBFLmRpc3BsYXlOYW1lKSksIHR5cGVvZiBFID09IFwiZnVuY3Rpb25cIiAmJiBvci5zZXQoRSwgcW4pLCBxbjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoU3QgPj0gMSAmJiAkdCA+PSAwKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFNyID0gITEsIFZ0LmN1cnJlbnQgPSBudCwgWnQoKSwgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBxZTtcbiAgICAgIH1cbiAgICAgIHZhciBzbyA9IEUgPyBFLmRpc3BsYXlOYW1lIHx8IEUubmFtZSA6IFwiXCIsIHJtID0gc28gPyBUbihzbykgOiBcIlwiO1xuICAgICAgcmV0dXJuIHR5cGVvZiBFID09IFwiZnVuY3Rpb25cIiAmJiBvci5zZXQoRSwgcm0pLCBybTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVXIoRSwgcSwgb2UpIHtcbiAgICAgIHJldHVybiB2aShFLCAhMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHgoRSkge1xuICAgICAgdmFyIHEgPSBFLnByb3RvdHlwZTtcbiAgICAgIHJldHVybiAhIShxICYmIHEuaXNSZWFjdENvbXBvbmVudCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uICQoRSwgcSwgb2UpIHtcbiAgICAgIGlmIChFID09IG51bGwpXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgaWYgKHR5cGVvZiBFID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuIHZpKEUsIHgoRSkpO1xuICAgICAgaWYgKHR5cGVvZiBFID09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBUbihFKTtcbiAgICAgIHN3aXRjaCAoRSkge1xuICAgICAgICBjYXNlIGM6XG4gICAgICAgICAgcmV0dXJuIFRuKFwiU3VzcGVuc2VcIik7XG4gICAgICAgIGNhc2UgdTpcbiAgICAgICAgICByZXR1cm4gVG4oXCJTdXNwZW5zZUxpc3RcIik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIEUgPT0gXCJvYmplY3RcIilcbiAgICAgICAgc3dpdGNoIChFLiQkdHlwZW9mKSB7XG4gICAgICAgICAgY2FzZSBsOlxuICAgICAgICAgICAgcmV0dXJuIFVyKEUucmVuZGVyKTtcbiAgICAgICAgICBjYXNlIGQ6XG4gICAgICAgICAgICByZXR1cm4gJChFLnR5cGUsIHEsIG9lKTtcbiAgICAgICAgICBjYXNlIGY6IHtcbiAgICAgICAgICAgIHZhciB4ZSA9IEUsIHFlID0geGUuX3BheWxvYWQsIG50ID0geGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gJChudChxZSksIHEsIG9lKTtcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHZhciBOID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgTSA9IHt9LCBYID0geS5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIGZ1bmN0aW9uIHooRSkge1xuICAgICAgaWYgKEUpIHtcbiAgICAgICAgdmFyIHEgPSBFLl9vd25lciwgb2UgPSAkKEUudHlwZSwgRS5fc291cmNlLCBxID8gcS50eXBlIDogbnVsbCk7XG4gICAgICAgIFguc2V0RXh0cmFTdGFja0ZyYW1lKG9lKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBYLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZWUoRSwgcSwgb2UsIHhlLCBxZSkge1xuICAgICAge1xuICAgICAgICB2YXIgbnQgPSBGdW5jdGlvbi5jYWxsLmJpbmQoTik7XG4gICAgICAgIGZvciAodmFyIFdlIGluIEUpXG4gICAgICAgICAgaWYgKG50KEUsIFdlKSkge1xuICAgICAgICAgICAgdmFyIE5lID0gdm9pZCAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBFW1dlXSAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG4gPSBFcnJvcigoeGUgfHwgXCJSZWFjdCBjbGFzc1wiKSArIFwiOiBcIiArIG9lICsgXCIgdHlwZSBgXCIgKyBXZSArIFwiYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgXCIgKyB0eXBlb2YgRVtXZV0gKyBcImAuVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuXCIpO1xuICAgICAgICAgICAgICAgIHRocm93IGRuLm5hbWUgPSBcIkludmFyaWFudCBWaW9sYXRpb25cIiwgZG47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgTmUgPSBFW1dlXShxLCBXZSwgeGUsIG9lLCBudWxsLCBcIlNFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEXCIpO1xuICAgICAgICAgICAgfSBjYXRjaCAoU3QpIHtcbiAgICAgICAgICAgICAgTmUgPSBTdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE5lICYmICEoTmUgaW5zdGFuY2VvZiBFcnJvcikgJiYgKHoocWUpLCBiKFwiJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuIFlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyIGNyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLlwiLCB4ZSB8fCBcIlJlYWN0IGNsYXNzXCIsIG9lLCBXZSwgdHlwZW9mIE5lKSwgeihudWxsKSksIE5lIGluc3RhbmNlb2YgRXJyb3IgJiYgIShOZS5tZXNzYWdlIGluIE0pICYmIChNW05lLm1lc3NhZ2VdID0gITAsIHoocWUpLCBiKFwiRmFpbGVkICVzIHR5cGU6ICVzXCIsIG9lLCBOZS5tZXNzYWdlKSwgeihudWxsKSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgSCA9IEFycmF5LmlzQXJyYXk7XG4gICAgZnVuY3Rpb24gRihFKSB7XG4gICAgICByZXR1cm4gSChFKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gVShFKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBxID0gdHlwZW9mIFN5bWJvbCA9PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLnRvU3RyaW5nVGFnLCBvZSA9IHEgJiYgRVtTeW1ib2wudG9TdHJpbmdUYWddIHx8IEUuY29uc3RydWN0b3IubmFtZSB8fCBcIk9iamVjdFwiO1xuICAgICAgICByZXR1cm4gb2U7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNlKEUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtZShFKSwgITE7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBtZShFKSB7XG4gICAgICByZXR1cm4gXCJcIiArIEU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhlKEUpIHtcbiAgICAgIGlmIChzZShFKSlcbiAgICAgICAgcmV0dXJuIGIoXCJUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS5cIiwgVShFKSksIG1lKEUpO1xuICAgIH1cbiAgICB2YXIgeWUgPSB5LlJlYWN0Q3VycmVudE93bmVyLCBRZSA9IHtcbiAgICAgIGtleTogITAsXG4gICAgICByZWY6ICEwLFxuICAgICAgX19zZWxmOiAhMCxcbiAgICAgIF9fc291cmNlOiAhMFxuICAgIH0sIFVlLCB0dCwgYnQ7XG4gICAgYnQgPSB7fTtcbiAgICBmdW5jdGlvbiAkbihFKSB7XG4gICAgICBpZiAoTi5jYWxsKEUsIFwicmVmXCIpKSB7XG4gICAgICAgIHZhciBxID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihFLCBcInJlZlwiKS5nZXQ7XG4gICAgICAgIGlmIChxICYmIHEuaXNSZWFjdFdhcm5pbmcpXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEUucmVmICE9PSB2b2lkIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHlpKEUpIHtcbiAgICAgIGlmIChOLmNhbGwoRSwgXCJrZXlcIikpIHtcbiAgICAgICAgdmFyIHEgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEUsIFwia2V5XCIpLmdldDtcbiAgICAgICAgaWYgKHEgJiYgcS5pc1JlYWN0V2FybmluZylcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9XG4gICAgICByZXR1cm4gRS5rZXkgIT09IHZvaWQgMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWMoRSwgcSkge1xuICAgICAgaWYgKHR5cGVvZiBFLnJlZiA9PSBcInN0cmluZ1wiICYmIHllLmN1cnJlbnQgJiYgcSAmJiB5ZS5jdXJyZW50LnN0YXRlTm9kZSAhPT0gcSkge1xuICAgICAgICB2YXIgb2UgPSBXKHllLmN1cnJlbnQudHlwZSk7XG4gICAgICAgIGJ0W29lXSB8fCAoYignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuIFN1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiBUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiBXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiBodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIFcoeWUuY3VycmVudC50eXBlKSwgRS5yZWYpLCBidFtvZV0gPSAhMCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBzKEUsIHEpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIG9lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgVWUgfHwgKFVlID0gITAsIGIoXCIlczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lIHZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgcHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKVwiLCBxKSk7XG4gICAgICAgIH07XG4gICAgICAgIG9lLmlzUmVhY3RXYXJuaW5nID0gITAsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFLCBcImtleVwiLCB7XG4gICAgICAgICAgZ2V0OiBvZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBsYyhFLCBxKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBvZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHR0IHx8ICh0dCA9ICEwLCBiKFwiJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSB2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50IHByb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcylcIiwgcSkpO1xuICAgICAgICB9O1xuICAgICAgICBvZS5pc1JlYWN0V2FybmluZyA9ICEwLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoRSwgXCJyZWZcIiwge1xuICAgICAgICAgIGdldDogb2UsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIEx0ID0gZnVuY3Rpb24oRSwgcSwgb2UsIHhlLCBxZSwgbnQsIFdlKSB7XG4gICAgICB2YXIgTmUgPSB7XG4gICAgICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICAgICAkJHR5cGVvZjogZSxcbiAgICAgICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgICAgICB0eXBlOiBFLFxuICAgICAgICBrZXk6IHEsXG4gICAgICAgIHJlZjogb2UsXG4gICAgICAgIHByb3BzOiBXZSxcbiAgICAgICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICAgICAgX293bmVyOiBudFxuICAgICAgfTtcbiAgICAgIHJldHVybiBOZS5fc3RvcmUgPSB7fSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KE5lLl9zdG9yZSwgXCJ2YWxpZGF0ZWRcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogITFcbiAgICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmUsIFwiX3NlbGZcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICExLFxuICAgICAgICB2YWx1ZTogeGVcbiAgICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoTmUsIFwiX3NvdXJjZVwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITEsXG4gICAgICAgIHZhbHVlOiBxZVxuICAgICAgfSksIE9iamVjdC5mcmVlemUgJiYgKE9iamVjdC5mcmVlemUoTmUucHJvcHMpLCBPYmplY3QuZnJlZXplKE5lKSksIE5lO1xuICAgIH07XG4gICAgZnVuY3Rpb24gVW4oRSwgcSwgb2UsIHhlLCBxZSkge1xuICAgICAge1xuICAgICAgICB2YXIgbnQsIFdlID0ge30sIE5lID0gbnVsbCwgZG4gPSBudWxsO1xuICAgICAgICBvZSAhPT0gdm9pZCAwICYmIChoZShvZSksIE5lID0gXCJcIiArIG9lKSwgeWkocSkgJiYgKGhlKHEua2V5KSwgTmUgPSBcIlwiICsgcS5rZXkpLCAkbihxKSAmJiAoZG4gPSBxLnJlZiwgYWMocSwgcWUpKTtcbiAgICAgICAgZm9yIChudCBpbiBxKVxuICAgICAgICAgIE4uY2FsbChxLCBudCkgJiYgIVFlLmhhc093blByb3BlcnR5KG50KSAmJiAoV2VbbnRdID0gcVtudF0pO1xuICAgICAgICBpZiAoRSAmJiBFLmRlZmF1bHRQcm9wcykge1xuICAgICAgICAgIHZhciBTdCA9IEUuZGVmYXVsdFByb3BzO1xuICAgICAgICAgIGZvciAobnQgaW4gU3QpXG4gICAgICAgICAgICBXZVtudF0gPT09IHZvaWQgMCAmJiAoV2VbbnRdID0gU3RbbnRdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTmUgfHwgZG4pIHtcbiAgICAgICAgICB2YXIgJHQgPSB0eXBlb2YgRSA9PSBcImZ1bmN0aW9uXCIgPyBFLmRpc3BsYXlOYW1lIHx8IEUubmFtZSB8fCBcIlVua25vd25cIiA6IEU7XG4gICAgICAgICAgTmUgJiYgcHMoV2UsICR0KSwgZG4gJiYgbGMoV2UsICR0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTHQoRSwgTmUsIGRuLCBxZSwgeGUsIHllLmN1cnJlbnQsIFdlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJvID0geS5SZWFjdEN1cnJlbnRPd25lciwgR2cgPSB5LlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgZnVuY3Rpb24gaW8oRSkge1xuICAgICAgaWYgKEUpIHtcbiAgICAgICAgdmFyIHEgPSBFLl9vd25lciwgb2UgPSAkKEUudHlwZSwgRS5fc291cmNlLCBxID8gcS50eXBlIDogbnVsbCk7XG4gICAgICAgIEdnLnNldEV4dHJhU3RhY2tGcmFtZShvZSk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgR2cuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgICB2YXIgbmY7XG4gICAgbmYgPSAhMTtcbiAgICBmdW5jdGlvbiByZihFKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIEUgPT0gXCJvYmplY3RcIiAmJiBFICE9PSBudWxsICYmIEUuJCR0eXBlb2YgPT09IGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEtnKCkge1xuICAgICAge1xuICAgICAgICBpZiAocm8uY3VycmVudCkge1xuICAgICAgICAgIHZhciBFID0gVyhyby5jdXJyZW50LnR5cGUpO1xuICAgICAgICAgIGlmIChFKVxuICAgICAgICAgICAgcmV0dXJuIGBcblxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgXFxgYCArIEUgKyBcImAuXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFNfKEUpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKEUgIT09IHZvaWQgMCkge1xuICAgICAgICAgIHZhciBxID0gRS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCBcIlwiKSwgb2UgPSBFLmxpbmVOdW1iZXI7XG4gICAgICAgICAgcmV0dXJuIGBcblxuQ2hlY2sgeW91ciBjb2RlIGF0IGAgKyBxICsgXCI6XCIgKyBvZSArIFwiLlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgSmcgPSB7fTtcbiAgICBmdW5jdGlvbiB3XyhFKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBxID0gS2coKTtcbiAgICAgICAgaWYgKCFxKSB7XG4gICAgICAgICAgdmFyIG9lID0gdHlwZW9mIEUgPT0gXCJzdHJpbmdcIiA/IEUgOiBFLmRpc3BsYXlOYW1lIHx8IEUubmFtZTtcbiAgICAgICAgICBvZSAmJiAocSA9IGBcblxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8YCArIG9lICsgXCI+LlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZW0oRSwgcSkge1xuICAgICAge1xuICAgICAgICBpZiAoIUUuX3N0b3JlIHx8IEUuX3N0b3JlLnZhbGlkYXRlZCB8fCBFLmtleSAhPSBudWxsKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgRS5fc3RvcmUudmFsaWRhdGVkID0gITA7XG4gICAgICAgIHZhciBvZSA9IHdfKHEpO1xuICAgICAgICBpZiAoSmdbb2VdKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgSmdbb2VdID0gITA7XG4gICAgICAgIHZhciB4ZSA9IFwiXCI7XG4gICAgICAgIEUgJiYgRS5fb3duZXIgJiYgRS5fb3duZXIgIT09IHJvLmN1cnJlbnQgJiYgKHhlID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBXKEUuX293bmVyLnR5cGUpICsgXCIuXCIpLCBpbyhFKSwgYignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLiVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgb2UsIHhlKSwgaW8obnVsbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRtKEUsIHEpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiBFICE9IFwib2JqZWN0XCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoRihFKSlcbiAgICAgICAgICBmb3IgKHZhciBvZSA9IDA7IG9lIDwgRS5sZW5ndGg7IG9lKyspIHtcbiAgICAgICAgICAgIHZhciB4ZSA9IEVbb2VdO1xuICAgICAgICAgICAgcmYoeGUpICYmIGVtKHhlLCBxKTtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJmKEUpKVxuICAgICAgICAgIEUuX3N0b3JlICYmIChFLl9zdG9yZS52YWxpZGF0ZWQgPSAhMCk7XG4gICAgICAgIGVsc2UgaWYgKEUpIHtcbiAgICAgICAgICB2YXIgcWUgPSBtKEUpO1xuICAgICAgICAgIGlmICh0eXBlb2YgcWUgPT0gXCJmdW5jdGlvblwiICYmIHFlICE9PSBFLmVudHJpZXMpXG4gICAgICAgICAgICBmb3IgKHZhciBudCA9IHFlLmNhbGwoRSksIFdlOyAhKFdlID0gbnQubmV4dCgpKS5kb25lOyApXG4gICAgICAgICAgICAgIHJmKFdlLnZhbHVlKSAmJiBlbShXZS52YWx1ZSwgcSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24ga18oRSkge1xuICAgICAge1xuICAgICAgICB2YXIgcSA9IEUudHlwZTtcbiAgICAgICAgaWYgKHEgPT0gbnVsbCB8fCB0eXBlb2YgcSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIG9lO1xuICAgICAgICBpZiAodHlwZW9mIHEgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIG9lID0gcS5wcm9wVHlwZXM7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBxID09IFwib2JqZWN0XCIgJiYgKHEuJCR0eXBlb2YgPT09IGwgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgICAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cbiAgICAgICAgcS4kJHR5cGVvZiA9PT0gZCkpXG4gICAgICAgICAgb2UgPSBxLnByb3BUeXBlcztcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKG9lKSB7XG4gICAgICAgICAgdmFyIHhlID0gVyhxKTtcbiAgICAgICAgICBlZShvZSwgRS5wcm9wcywgXCJwcm9wXCIsIHhlLCBFKTtcbiAgICAgICAgfSBlbHNlIGlmIChxLlByb3BUeXBlcyAhPT0gdm9pZCAwICYmICFuZikge1xuICAgICAgICAgIG5mID0gITA7XG4gICAgICAgICAgdmFyIHFlID0gVyhxKTtcbiAgICAgICAgICBiKFwiQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/XCIsIHFlIHx8IFwiVW5rbm93blwiKTtcbiAgICAgICAgfVxuICAgICAgICB0eXBlb2YgcS5nZXREZWZhdWx0UHJvcHMgPT0gXCJmdW5jdGlvblwiICYmICFxLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCAmJiBiKFwiZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzIGRlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC5cIik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHhfKEUpIHtcbiAgICAgIHtcbiAgICAgICAgZm9yICh2YXIgcSA9IE9iamVjdC5rZXlzKEUucHJvcHMpLCBvZSA9IDA7IG9lIDwgcS5sZW5ndGg7IG9lKyspIHtcbiAgICAgICAgICB2YXIgeGUgPSBxW29lXTtcbiAgICAgICAgICBpZiAoeGUgIT09IFwiY2hpbGRyZW5cIiAmJiB4ZSAhPT0gXCJrZXlcIikge1xuICAgICAgICAgICAgaW8oRSksIGIoXCJJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiBSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLlwiLCB4ZSksIGlvKG51bGwpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEUucmVmICE9PSBudWxsICYmIChpbyhFKSwgYihcIkludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuXCIpLCBpbyhudWxsKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5tKEUsIHEsIG9lLCB4ZSwgcWUsIG50KSB7XG4gICAgICB7XG4gICAgICAgIHZhciBXZSA9IEMoRSk7XG4gICAgICAgIGlmICghV2UpIHtcbiAgICAgICAgICB2YXIgTmUgPSBcIlwiO1xuICAgICAgICAgIChFID09PSB2b2lkIDAgfHwgdHlwZW9mIEUgPT0gXCJvYmplY3RcIiAmJiBFICE9PSBudWxsICYmIE9iamVjdC5rZXlzKEUpLmxlbmd0aCA9PT0gMCkgJiYgKE5lICs9IFwiIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlIGl0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIik7XG4gICAgICAgICAgdmFyIGRuID0gU18ocWUpO1xuICAgICAgICAgIGRuID8gTmUgKz0gZG4gOiBOZSArPSBLZygpO1xuICAgICAgICAgIHZhciBTdDtcbiAgICAgICAgICBFID09PSBudWxsID8gU3QgPSBcIm51bGxcIiA6IEYoRSkgPyBTdCA9IFwiYXJyYXlcIiA6IEUgIT09IHZvaWQgMCAmJiBFLiQkdHlwZW9mID09PSBlID8gKFN0ID0gXCI8XCIgKyAoVyhFLnR5cGUpIHx8IFwiVW5rbm93blwiKSArIFwiIC8+XCIsIE5lID0gXCIgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD9cIikgOiBTdCA9IHR5cGVvZiBFLCBiKFwiUmVhY3QuanN4OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciBidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzXCIsIFN0LCBOZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyICR0ID0gVW4oRSwgcSwgb2UsIHFlLCBudCk7XG4gICAgICAgIGlmICgkdCA9PSBudWxsKVxuICAgICAgICAgIHJldHVybiAkdDtcbiAgICAgICAgaWYgKFdlKSB7XG4gICAgICAgICAgdmFyIHFuID0gcS5jaGlsZHJlbjtcbiAgICAgICAgICBpZiAocW4gIT09IHZvaWQgMClcbiAgICAgICAgICAgIGlmICh4ZSlcbiAgICAgICAgICAgICAgaWYgKEYocW4pKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgc28gPSAwOyBzbyA8IHFuLmxlbmd0aDsgc28rKylcbiAgICAgICAgICAgICAgICAgIHRtKHFuW3NvXSwgRSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QuZnJlZXplKHFuKTtcbiAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgYihcIlJlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuIFlvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC5cIik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHRtKHFuLCBFKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRSA9PT0gciA/IHhfKCR0KSA6IGtfKCR0KSwgJHQ7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIFBfKEUsIHEsIG9lKSB7XG4gICAgICByZXR1cm4gbm0oRSwgcSwgb2UsICEwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gX18oRSwgcSwgb2UpIHtcbiAgICAgIHJldHVybiBubShFLCBxLCBvZSwgITEpO1xuICAgIH1cbiAgICB2YXIgVF8gPSBfXywgRV8gPSBQXztcbiAgICBjYS5GcmFnbWVudCA9IHIsIGNhLmpzeCA9IFRfLCBjYS5qc3hzID0gRV87XG4gIH0oKSksIGNhO1xufVxucHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiID8gaWguZXhwb3J0cyA9IENfKCkgOiBpaC5leHBvcnRzID0gQV8oKTtcbnZhciBIciA9IGloLmV4cG9ydHM7XG4vKipcbiogQHZ1ZS9zaGFyZWQgdjMuNC4yMVxuKiAoYykgMjAxOC1wcmVzZW50IFl1eGkgKEV2YW4pIFlvdSBhbmQgVnVlIGNvbnRyaWJ1dG9yc1xuKiBAbGljZW5zZSBNSVRcbioqL1xuZnVuY3Rpb24gQnQodCwgZSkge1xuICBjb25zdCBuID0gbmV3IFNldCh0LnNwbGl0KFwiLFwiKSk7XG4gIHJldHVybiBlID8gKHIpID0+IG4uaGFzKHIudG9Mb3dlckNhc2UoKSkgOiAocikgPT4gbi5oYXMocik7XG59XG5jb25zdCBWZSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IE9iamVjdC5mcmVlemUoe30pIDoge30sIG1vID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gT2JqZWN0LmZyZWV6ZShbXSkgOiBbXSwgaXQgPSAoKSA9PiB7XG59LCB6YyA9ICgpID0+ICExLCBvaSA9ICh0KSA9PiB0LmNoYXJDb2RlQXQoMCkgPT09IDExMSAmJiB0LmNoYXJDb2RlQXQoMSkgPT09IDExMCAmJiAvLyB1cHBlcmNhc2UgbGV0dGVyXG4odC5jaGFyQ29kZUF0KDIpID4gMTIyIHx8IHQuY2hhckNvZGVBdCgyKSA8IDk3KSwgbXUgPSAodCkgPT4gdC5zdGFydHNXaXRoKFwib25VcGRhdGU6XCIpLCAkZSA9IE9iamVjdC5hc3NpZ24sIEZwID0gKHQsIGUpID0+IHtcbiAgY29uc3QgbiA9IHQuaW5kZXhPZihlKTtcbiAgbiA+IC0xICYmIHQuc3BsaWNlKG4sIDEpO1xufSwgUl8gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBBZSA9ICh0LCBlKSA9PiBSXy5jYWxsKHQsIGUpLCBpZSA9IEFycmF5LmlzQXJyYXksIENzID0gKHQpID0+IGVhKHQpID09PSBcIltvYmplY3QgTWFwXVwiLCBHcyA9ICh0KSA9PiBlYSh0KSA9PT0gXCJbb2JqZWN0IFNldF1cIiwgb20gPSAodCkgPT4gZWEodCkgPT09IFwiW29iamVjdCBEYXRlXVwiLCBOXyA9ICh0KSA9PiBlYSh0KSA9PT0gXCJbb2JqZWN0IFJlZ0V4cF1cIiwgYmUgPSAodCkgPT4gdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiLCB3ZSA9ICh0KSA9PiB0eXBlb2YgdCA9PSBcInN0cmluZ1wiLCBPciA9ICh0KSA9PiB0eXBlb2YgdCA9PSBcInN5bWJvbFwiLCBaZSA9ICh0KSA9PiB0ICE9PSBudWxsICYmIHR5cGVvZiB0ID09IFwib2JqZWN0XCIsIGRkID0gKHQpID0+IChaZSh0KSB8fCBiZSh0KSkgJiYgYmUodC50aGVuKSAmJiBiZSh0LmNhdGNoKSwgaHkgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLCBlYSA9ICh0KSA9PiBoeS5jYWxsKHQpLCBHcCA9ICh0KSA9PiBlYSh0KS5zbGljZSg4LCAtMSksIHB5ID0gKHQpID0+IGVhKHQpID09PSBcIltvYmplY3QgT2JqZWN0XVwiLCBLcCA9ICh0KSA9PiB3ZSh0KSAmJiB0ICE9PSBcIk5hTlwiICYmIHRbMF0gIT09IFwiLVwiICYmIFwiXCIgKyBwYXJzZUludCh0LCAxMCkgPT09IHQsIFVpID0gLyogQF9fUFVSRV9fICovIEJ0KFxuICAvLyB0aGUgbGVhZGluZyBjb21tYSBpcyBpbnRlbnRpb25hbCBzbyBlbXB0eSBzdHJpbmcgXCJcIiBpcyBhbHNvIGluY2x1ZGVkXG4gIFwiLGtleSxyZWYscmVmX2ZvcixyZWZfa2V5LG9uVm5vZGVCZWZvcmVNb3VudCxvblZub2RlTW91bnRlZCxvblZub2RlQmVmb3JlVXBkYXRlLG9uVm5vZGVVcGRhdGVkLG9uVm5vZGVCZWZvcmVVbm1vdW50LG9uVm5vZGVVbm1vdW50ZWRcIlxuKSwgT3kgPSAvKiBAX19QVVJFX18gKi8gQnQoXG4gIFwiYmluZCxjbG9hayxlbHNlLWlmLGVsc2UsZm9yLGh0bWwsaWYsbW9kZWwsb24sb25jZSxwcmUsc2hvdyxzbG90LHRleHQsbWVtb1wiXG4pLCBmZCA9ICh0KSA9PiB7XG4gIGNvbnN0IGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIChuKSA9PiBlW25dIHx8IChlW25dID0gdChuKSk7XG59LCBEXyA9IC8tKFxcdykvZywgbXQgPSBmZCgodCkgPT4gdC5yZXBsYWNlKERfLCAoZSwgbikgPT4gbiA/IG4udG9VcHBlckNhc2UoKSA6IFwiXCIpKSwgWl8gPSAvXFxCKFtBLVpdKS9nLCBybiA9IGZkKFxuICAodCkgPT4gdC5yZXBsYWNlKFpfLCBcIi0kMVwiKS50b0xvd2VyQ2FzZSgpXG4pLCBXciA9IGZkKCh0KSA9PiB0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdC5zbGljZSgxKSksIFRyID0gZmQoKHQpID0+IHQgPyBgb24ke1dyKHQpfWAgOiBcIlwiKSwgZ3IgPSAodCwgZSkgPT4gIU9iamVjdC5pcyh0LCBlKSwgSWkgPSAodCwgZSkgPT4ge1xuICBmb3IgKGxldCBuID0gMDsgbiA8IHQubGVuZ3RoOyBuKyspXG4gICAgdFtuXShlKTtcbn0sIGJ1ID0gKHQsIGUsIG4pID0+IHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIGUsIHtcbiAgICBjb25maWd1cmFibGU6ICEwLFxuICAgIGVudW1lcmFibGU6ICExLFxuICAgIHZhbHVlOiBuXG4gIH0pO1xufSwgS2EgPSAodCkgPT4ge1xuICBjb25zdCBlID0gcGFyc2VGbG9hdCh0KTtcbiAgcmV0dXJuIGlzTmFOKGUpID8gdCA6IGU7XG59LCB2dSA9ICh0KSA9PiB7XG4gIGNvbnN0IGUgPSB3ZSh0KSA/IE51bWJlcih0KSA6IE5hTjtcbiAgcmV0dXJuIGlzTmFOKGUpID8gdCA6IGU7XG59O1xubGV0IGFtO1xuY29uc3QgYm8gPSAoKSA9PiBhbSB8fCAoYW0gPSB0eXBlb2YgZ2xvYmFsVGhpcyA8IFwidVwiID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiBzZWxmIDwgXCJ1XCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyA8IFwidVwiID8gd2luZG93IDogdHlwZW9mIGdsb2JhbCA8IFwidVwiID8gZ2xvYmFsIDoge30pLCBEciA9IHtcbiAgMTogXCJURVhUXCIsXG4gIDI6IFwiQ0xBU1NcIixcbiAgNDogXCJTVFlMRVwiLFxuICA4OiBcIlBST1BTXCIsXG4gIDE2OiBcIkZVTExfUFJPUFNcIixcbiAgMzI6IFwiTkVFRF9IWURSQVRJT05cIixcbiAgNjQ6IFwiU1RBQkxFX0ZSQUdNRU5UXCIsXG4gIDEyODogXCJLRVlFRF9GUkFHTUVOVFwiLFxuICAyNTY6IFwiVU5LRVlFRF9GUkFHTUVOVFwiLFxuICA1MTI6IFwiTkVFRF9QQVRDSFwiLFxuICAxMDI0OiBcIkRZTkFNSUNfU0xPVFNcIixcbiAgMjA0ODogXCJERVZfUk9PVF9GUkFHTUVOVFwiLFxuICBbLTFdOiBcIkhPSVNURURcIixcbiAgWy0yXTogXCJCQUlMXCJcbn0sIFZfID0ge1xuICAxOiBcIlNUQUJMRVwiLFxuICAyOiBcIkRZTkFNSUNcIixcbiAgMzogXCJGT1JXQVJERURcIlxufSwgSV8gPSBcIkluZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4scGFyc2VGbG9hdCxwYXJzZUludCxkZWNvZGVVUkksZGVjb2RlVVJJQ29tcG9uZW50LGVuY29kZVVSSSxlbmNvZGVVUklDb21wb25lbnQsTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLEJpZ0ludCxjb25zb2xlLEVycm9yXCIsIFdfID0gLyogQF9fUFVSRV9fICovIEJ0KElfKSwgbG0gPSAyO1xuZnVuY3Rpb24gTV8odCwgZSA9IDAsIG4gPSB0Lmxlbmd0aCkge1xuICBsZXQgciA9IHQuc3BsaXQoLyhcXHI/XFxuKS8pO1xuICBjb25zdCBpID0gci5maWx0ZXIoKGEsIGwpID0+IGwgJSAyID09PSAxKTtcbiAgciA9IHIuZmlsdGVyKChhLCBsKSA9PiBsICUgMiA9PT0gMCk7XG4gIGxldCBzID0gMDtcbiAgY29uc3QgbyA9IFtdO1xuICBmb3IgKGxldCBhID0gMDsgYSA8IHIubGVuZ3RoOyBhKyspXG4gICAgaWYgKHMgKz0gclthXS5sZW5ndGggKyAoaVthXSAmJiBpW2FdLmxlbmd0aCB8fCAwKSwgcyA+PSBlKSB7XG4gICAgICBmb3IgKGxldCBsID0gYSAtIGxtOyBsIDw9IGEgKyBsbSB8fCBuID4gczsgbCsrKSB7XG4gICAgICAgIGlmIChsIDwgMCB8fCBsID49IHIubGVuZ3RoKVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBjb25zdCBjID0gbCArIDE7XG4gICAgICAgIG8ucHVzaChcbiAgICAgICAgICBgJHtjfSR7XCIgXCIucmVwZWF0KE1hdGgubWF4KDMgLSBTdHJpbmcoYykubGVuZ3RoLCAwKSl9fCAgJHtyW2xdfWBcbiAgICAgICAgKTtcbiAgICAgICAgY29uc3QgdSA9IHJbbF0ubGVuZ3RoLCBkID0gaVtsXSAmJiBpW2xdLmxlbmd0aCB8fCAwO1xuICAgICAgICBpZiAobCA9PT0gYSkge1xuICAgICAgICAgIGNvbnN0IGYgPSBlIC0gKHMgLSAodSArIGQpKSwgaCA9IE1hdGgubWF4KFxuICAgICAgICAgICAgMSxcbiAgICAgICAgICAgIG4gPiBzID8gdSAtIGYgOiBuIC0gZVxuICAgICAgICAgICk7XG4gICAgICAgICAgby5wdXNoKFwiICAgfCAgXCIgKyBcIiBcIi5yZXBlYXQoZikgKyBcIl5cIi5yZXBlYXQoaCkpO1xuICAgICAgICB9IGVsc2UgaWYgKGwgPiBhKSB7XG4gICAgICAgICAgaWYgKG4gPiBzKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gTWF0aC5tYXgoTWF0aC5taW4obiAtIHMsIHUpLCAxKTtcbiAgICAgICAgICAgIG8ucHVzaChcIiAgIHwgIFwiICsgXCJeXCIucmVwZWF0KGYpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcyArPSB1ICsgZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICByZXR1cm4gby5qb2luKGBcbmApO1xufVxuZnVuY3Rpb24gQnIodCkge1xuICBpZiAoaWUodCkpIHtcbiAgICBjb25zdCBlID0ge307XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCB0Lmxlbmd0aDsgbisrKSB7XG4gICAgICBjb25zdCByID0gdFtuXSwgaSA9IHdlKHIpID8gZ3kocikgOiBCcihyKTtcbiAgICAgIGlmIChpKVxuICAgICAgICBmb3IgKGNvbnN0IHMgaW4gaSlcbiAgICAgICAgICBlW3NdID0gaVtzXTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH0gZWxzZSBpZiAod2UodCkgfHwgWmUodCkpXG4gICAgcmV0dXJuIHQ7XG59XG5jb25zdCBYXyA9IC87KD8hW14oXSpcXCkpL2csIGpfID0gLzooW15dKykvLCBCXyA9IC9cXC9cXCpbXl0qP1xcKlxcLy9nO1xuZnVuY3Rpb24gZ3kodCkge1xuICBjb25zdCBlID0ge307XG4gIHJldHVybiB0LnJlcGxhY2UoQl8sIFwiXCIpLnNwbGl0KFhfKS5mb3JFYWNoKChuKSA9PiB7XG4gICAgaWYgKG4pIHtcbiAgICAgIGNvbnN0IHIgPSBuLnNwbGl0KGpfKTtcbiAgICAgIHIubGVuZ3RoID4gMSAmJiAoZVtyWzBdLnRyaW0oKV0gPSByWzFdLnRyaW0oKSk7XG4gICAgfVxuICB9KSwgZTtcbn1cbmZ1bmN0aW9uIExfKHQpIHtcbiAgbGV0IGUgPSBcIlwiO1xuICBpZiAoIXQgfHwgd2UodCkpXG4gICAgcmV0dXJuIGU7XG4gIGZvciAoY29uc3QgbiBpbiB0KSB7XG4gICAgY29uc3QgciA9IHRbbl0sIGkgPSBuLnN0YXJ0c1dpdGgoXCItLVwiKSA/IG4gOiBybihuKTtcbiAgICAod2UocikgfHwgdHlwZW9mIHIgPT0gXCJudW1iZXJcIikgJiYgKGUgKz0gYCR7aX06JHtyfTtgKTtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIEtlKHQpIHtcbiAgbGV0IGUgPSBcIlwiO1xuICBpZiAod2UodCkpXG4gICAgZSA9IHQ7XG4gIGVsc2UgaWYgKGllKHQpKVxuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgdC5sZW5ndGg7IG4rKykge1xuICAgICAgY29uc3QgciA9IEtlKHRbbl0pO1xuICAgICAgciAmJiAoZSArPSByICsgXCIgXCIpO1xuICAgIH1cbiAgZWxzZSBpZiAoWmUodCkpXG4gICAgZm9yIChjb25zdCBuIGluIHQpXG4gICAgICB0W25dICYmIChlICs9IG4gKyBcIiBcIik7XG4gIHJldHVybiBlLnRyaW0oKTtcbn1cbmZ1bmN0aW9uIG15KHQpIHtcbiAgaWYgKCF0KVxuICAgIHJldHVybiBudWxsO1xuICBsZXQgeyBjbGFzczogZSwgc3R5bGU6IG4gfSA9IHQ7XG4gIHJldHVybiBlICYmICF3ZShlKSAmJiAodC5jbGFzcyA9IEtlKGUpKSwgbiAmJiAodC5zdHlsZSA9IEJyKG4pKSwgdDtcbn1cbmNvbnN0IFVfID0gXCJodG1sLGJvZHksYmFzZSxoZWFkLGxpbmssbWV0YSxzdHlsZSx0aXRsZSxhZGRyZXNzLGFydGljbGUsYXNpZGUsZm9vdGVyLGhlYWRlcixoZ3JvdXAsaDEsaDIsaDMsaDQsaDUsaDYsbmF2LHNlY3Rpb24sZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ1YnkscyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sZW1iZWQsb2JqZWN0LHBhcmFtLHNvdXJjZSxjYW52YXMsc2NyaXB0LG5vc2NyaXB0LGRlbCxpbnMsY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsdGgsdHIsYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbixvdXRwdXQscHJvZ3Jlc3Msc2VsZWN0LHRleHRhcmVhLGRldGFpbHMsZGlhbG9nLG1lbnUsc3VtbWFyeSx0ZW1wbGF0ZSxibG9ja3F1b3RlLGlmcmFtZSx0Zm9vdFwiLCBxXyA9IFwic3ZnLGFuaW1hdGUsYW5pbWF0ZU1vdGlvbixhbmltYXRlVHJhbnNmb3JtLGNpcmNsZSxjbGlwUGF0aCxjb2xvci1wcm9maWxlLGRlZnMsZGVzYyxkaXNjYXJkLGVsbGlwc2UsZmVCbGVuZCxmZUNvbG9yTWF0cml4LGZlQ29tcG9uZW50VHJhbnNmZXIsZmVDb21wb3NpdGUsZmVDb252b2x2ZU1hdHJpeCxmZURpZmZ1c2VMaWdodGluZyxmZURpc3BsYWNlbWVudE1hcCxmZURpc3RhbnRMaWdodCxmZURyb3BTaGFkb3csZmVGbG9vZCxmZUZ1bmNBLGZlRnVuY0IsZmVGdW5jRyxmZUZ1bmNSLGZlR2F1c3NpYW5CbHVyLGZlSW1hZ2UsZmVNZXJnZSxmZU1lcmdlTm9kZSxmZU1vcnBob2xvZ3ksZmVPZmZzZXQsZmVQb2ludExpZ2h0LGZlU3BlY3VsYXJMaWdodGluZyxmZVNwb3RMaWdodCxmZVRpbGUsZmVUdXJidWxlbmNlLGZpbHRlcixmb3JlaWduT2JqZWN0LGcsaGF0Y2gsaGF0Y2hwYXRoLGltYWdlLGxpbmUsbGluZWFyR3JhZGllbnQsbWFya2VyLG1hc2ssbWVzaCxtZXNoZ3JhZGllbnQsbWVzaHBhdGNoLG1lc2hyb3csbWV0YWRhdGEsbXBhdGgscGF0aCxwYXR0ZXJuLHBvbHlnb24scG9seWxpbmUscmFkaWFsR3JhZGllbnQscmVjdCxzZXQsc29saWRjb2xvcixzdG9wLHN3aXRjaCxzeW1ib2wsdGV4dCx0ZXh0UGF0aCx0aXRsZSx0c3Bhbix1bmtub3duLHVzZSx2aWV3XCIsIFlfID0gXCJhbm5vdGF0aW9uLGFubm90YXRpb24teG1sLG1hY3Rpb24sbWFsaWduZ3JvdXAsbWFsaWdubWFyayxtYXRoLG1lbmNsb3NlLG1lcnJvcixtZmVuY2VkLG1mcmFjLG1mcmFjdGlvbixtZ2x5cGgsbWksbWxhYmVsZWR0cixtbG9uZ2RpdixtbXVsdGlzY3JpcHRzLG1uLG1vLG1vdmVyLG1wYWRkZWQsbXBoYW50b20sbXByZXNjcmlwdHMsbXJvb3QsbXJvdyxtcyxtc2NhcnJpZXMsbXNjYXJyeSxtc2dyb3VwLG1zbGluZSxtc3BhY2UsbXNxcnQsbXNyb3csbXN0YWNrLG1zdHlsZSxtc3ViLG1zdWJzdXAsbXN1cCxtdGFibGUsbXRkLG10ZXh0LG10cixtdW5kZXIsbXVuZGVyb3Zlcixub25lLHNlbWFudGljc1wiLCB6XyA9IFwiYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxocixpbWcsaW5wdXQsbGluayxtZXRhLHBhcmFtLHNvdXJjZSx0cmFjayx3YnJcIiwgYnkgPSAvKiBAX19QVVJFX18gKi8gQnQoVV8pLCB2eSA9IC8qIEBfX1BVUkVfXyAqLyBCdChxXyksIHl5ID0gLyogQF9fUFVSRV9fICovIEJ0KFlfKSwgSF8gPSAvKiBAX19QVVJFX18gKi8gQnQoel8pLCBTeSA9IFwiaXRlbXNjb3BlLGFsbG93ZnVsbHNjcmVlbixmb3Jtbm92YWxpZGF0ZSxpc21hcCxub21vZHVsZSxub3ZhbGlkYXRlLHJlYWRvbmx5XCIsIEZfID0gLyogQF9fUFVSRV9fICovIEJ0KFN5KSwgY20gPSAvKiBAX19QVVJFX18gKi8gQnQoXG4gIFN5ICsgXCIsYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNvbnRyb2xzLGRlZmF1bHQsZGVmZXIsZGlzYWJsZWQsaGlkZGVuLGluZXJ0LGxvb3Asb3BlbixyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3MsY2hlY2tlZCxtdXRlZCxtdWx0aXBsZSxzZWxlY3RlZFwiXG4pO1xuZnVuY3Rpb24gSnAodCkge1xuICByZXR1cm4gISF0IHx8IHQgPT09IFwiXCI7XG59XG5jb25zdCBHXyA9IC8qIEBfX1BVUkVfXyAqLyBCdChcbiAgXCJhY2NlcHQsYWNjZXB0LWNoYXJzZXQsYWNjZXNza2V5LGFjdGlvbixhbGlnbixhbGxvdyxhbHQsYXN5bmMsYXV0b2NhcGl0YWxpemUsYXV0b2NvbXBsZXRlLGF1dG9mb2N1cyxhdXRvcGxheSxiYWNrZ3JvdW5kLGJnY29sb3IsYm9yZGVyLGJ1ZmZlcmVkLGNhcHR1cmUsY2hhbGxlbmdlLGNoYXJzZXQsY2hlY2tlZCxjaXRlLGNsYXNzLGNvZGUsY29kZWJhc2UsY29sb3IsY29scyxjb2xzcGFuLGNvbnRlbnQsY29udGVudGVkaXRhYmxlLGNvbnRleHRtZW51LGNvbnRyb2xzLGNvb3Jkcyxjcm9zc29yaWdpbixjc3AsZGF0YSxkYXRldGltZSxkZWNvZGluZyxkZWZhdWx0LGRlZmVyLGRpcixkaXJuYW1lLGRpc2FibGVkLGRvd25sb2FkLGRyYWdnYWJsZSxkcm9wem9uZSxlbmN0eXBlLGVudGVya2V5aGludCxmb3IsZm9ybSxmb3JtYWN0aW9uLGZvcm1lbmN0eXBlLGZvcm1tZXRob2QsZm9ybW5vdmFsaWRhdGUsZm9ybXRhcmdldCxoZWFkZXJzLGhlaWdodCxoaWRkZW4saGlnaCxocmVmLGhyZWZsYW5nLGh0dHAtZXF1aXYsaWNvbixpZCxpbXBvcnRhbmNlLGluZXJ0LGludGVncml0eSxpc21hcCxpdGVtcHJvcCxrZXl0eXBlLGtpbmQsbGFiZWwsbGFuZyxsYW5ndWFnZSxsb2FkaW5nLGxpc3QsbG9vcCxsb3csbWFuaWZlc3QsbWF4LG1heGxlbmd0aCxtaW5sZW5ndGgsbWVkaWEsbWluLG11bHRpcGxlLG11dGVkLG5hbWUsbm92YWxpZGF0ZSxvcGVuLG9wdGltdW0scGF0dGVybixwaW5nLHBsYWNlaG9sZGVyLHBvc3RlcixwcmVsb2FkLHJhZGlvZ3JvdXAscmVhZG9ubHkscmVmZXJyZXJwb2xpY3kscmVsLHJlcXVpcmVkLHJldmVyc2VkLHJvd3Mscm93c3BhbixzYW5kYm94LHNjb3BlLHNjb3BlZCxzZWxlY3RlZCxzaGFwZSxzaXplLHNpemVzLHNsb3Qsc3BhbixzcGVsbGNoZWNrLHNyYyxzcmNkb2Msc3JjbGFuZyxzcmNzZXQsc3RhcnQsc3RlcCxzdHlsZSxzdW1tYXJ5LHRhYmluZGV4LHRhcmdldCx0aXRsZSx0cmFuc2xhdGUsdHlwZSx1c2VtYXAsdmFsdWUsd2lkdGgsd3JhcFwiXG4pLCBLXyA9IC8qIEBfX1BVUkVfXyAqLyBCdChcbiAgXCJ4bWxucyxhY2NlbnQtaGVpZ2h0LGFjY3VtdWxhdGUsYWRkaXRpdmUsYWxpZ25tZW50LWJhc2VsaW5lLGFscGhhYmV0aWMsYW1wbGl0dWRlLGFyYWJpYy1mb3JtLGFzY2VudCxhdHRyaWJ1dGVOYW1lLGF0dHJpYnV0ZVR5cGUsYXppbXV0aCxiYXNlRnJlcXVlbmN5LGJhc2VsaW5lLXNoaWZ0LGJhc2VQcm9maWxlLGJib3gsYmVnaW4sYmlhcyxieSxjYWxjTW9kZSxjYXAtaGVpZ2h0LGNsYXNzLGNsaXAsY2xpcFBhdGhVbml0cyxjbGlwLXBhdGgsY2xpcC1ydWxlLGNvbG9yLGNvbG9yLWludGVycG9sYXRpb24sY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzLGNvbG9yLXByb2ZpbGUsY29sb3ItcmVuZGVyaW5nLGNvbnRlbnRTY3JpcHRUeXBlLGNvbnRlbnRTdHlsZVR5cGUsY3Jvc3NvcmlnaW4sY3Vyc29yLGN4LGN5LGQsZGVjZWxlcmF0ZSxkZXNjZW50LGRpZmZ1c2VDb25zdGFudCxkaXJlY3Rpb24sZGlzcGxheSxkaXZpc29yLGRvbWluYW50LWJhc2VsaW5lLGR1cixkeCxkeSxlZGdlTW9kZSxlbGV2YXRpb24sZW5hYmxlLWJhY2tncm91bmQsZW5kLGV4cG9uZW50LGZpbGwsZmlsbC1vcGFjaXR5LGZpbGwtcnVsZSxmaWx0ZXIsZmlsdGVyUmVzLGZpbHRlclVuaXRzLGZsb29kLWNvbG9yLGZsb29kLW9wYWNpdHksZm9udC1mYW1pbHksZm9udC1zaXplLGZvbnQtc2l6ZS1hZGp1c3QsZm9udC1zdHJldGNoLGZvbnQtc3R5bGUsZm9udC12YXJpYW50LGZvbnQtd2VpZ2h0LGZvcm1hdCxmcm9tLGZyLGZ4LGZ5LGcxLGcyLGdseXBoLW5hbWUsZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCxnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCxnbHlwaFJlZixncmFkaWVudFRyYW5zZm9ybSxncmFkaWVudFVuaXRzLGhhbmdpbmcsaGVpZ2h0LGhyZWYsaHJlZmxhbmcsaG9yaXotYWR2LXgsaG9yaXotb3JpZ2luLXgsaWQsaWRlb2dyYXBoaWMsaW1hZ2UtcmVuZGVyaW5nLGluLGluMixpbnRlcmNlcHQsayxrMSxrMixrMyxrNCxrZXJuZWxNYXRyaXgsa2VybmVsVW5pdExlbmd0aCxrZXJuaW5nLGtleVBvaW50cyxrZXlTcGxpbmVzLGtleVRpbWVzLGxhbmcsbGVuZ3RoQWRqdXN0LGxldHRlci1zcGFjaW5nLGxpZ2h0aW5nLWNvbG9yLGxpbWl0aW5nQ29uZUFuZ2xlLGxvY2FsLG1hcmtlci1lbmQsbWFya2VyLW1pZCxtYXJrZXItc3RhcnQsbWFya2VySGVpZ2h0LG1hcmtlclVuaXRzLG1hcmtlcldpZHRoLG1hc2ssbWFza0NvbnRlbnRVbml0cyxtYXNrVW5pdHMsbWF0aGVtYXRpY2FsLG1heCxtZWRpYSxtZXRob2QsbWluLG1vZGUsbmFtZSxudW1PY3RhdmVzLG9mZnNldCxvcGFjaXR5LG9wZXJhdG9yLG9yZGVyLG9yaWVudCxvcmllbnRhdGlvbixvcmlnaW4sb3ZlcmZsb3csb3ZlcmxpbmUtcG9zaXRpb24sb3ZlcmxpbmUtdGhpY2tuZXNzLHBhbm9zZS0xLHBhaW50LW9yZGVyLHBhdGgscGF0aExlbmd0aCxwYXR0ZXJuQ29udGVudFVuaXRzLHBhdHRlcm5UcmFuc2Zvcm0scGF0dGVyblVuaXRzLHBpbmcscG9pbnRlci1ldmVudHMscG9pbnRzLHBvaW50c0F0WCxwb2ludHNBdFkscG9pbnRzQXRaLHByZXNlcnZlQWxwaGEscHJlc2VydmVBc3BlY3RSYXRpbyxwcmltaXRpdmVVbml0cyxyLHJhZGl1cyxyZWZlcnJlclBvbGljeSxyZWZYLHJlZlkscmVsLHJlbmRlcmluZy1pbnRlbnQscmVwZWF0Q291bnQscmVwZWF0RHVyLHJlcXVpcmVkRXh0ZW5zaW9ucyxyZXF1aXJlZEZlYXR1cmVzLHJlc3RhcnQscmVzdWx0LHJvdGF0ZSxyeCxyeSxzY2FsZSxzZWVkLHNoYXBlLXJlbmRlcmluZyxzbG9wZSxzcGFjaW5nLHNwZWN1bGFyQ29uc3RhbnQsc3BlY3VsYXJFeHBvbmVudCxzcGVlZCxzcHJlYWRNZXRob2Qsc3RhcnRPZmZzZXQsc3RkRGV2aWF0aW9uLHN0ZW1oLHN0ZW12LHN0aXRjaFRpbGVzLHN0b3AtY29sb3Isc3RvcC1vcGFjaXR5LHN0cmlrZXRocm91Z2gtcG9zaXRpb24sc3RyaWtldGhyb3VnaC10aGlja25lc3Msc3RyaW5nLHN0cm9rZSxzdHJva2UtZGFzaGFycmF5LHN0cm9rZS1kYXNob2Zmc2V0LHN0cm9rZS1saW5lY2FwLHN0cm9rZS1saW5lam9pbixzdHJva2UtbWl0ZXJsaW1pdCxzdHJva2Utb3BhY2l0eSxzdHJva2Utd2lkdGgsc3R5bGUsc3VyZmFjZVNjYWxlLHN5c3RlbUxhbmd1YWdlLHRhYmluZGV4LHRhYmxlVmFsdWVzLHRhcmdldCx0YXJnZXRYLHRhcmdldFksdGV4dC1hbmNob3IsdGV4dC1kZWNvcmF0aW9uLHRleHQtcmVuZGVyaW5nLHRleHRMZW5ndGgsdG8sdHJhbnNmb3JtLHRyYW5zZm9ybS1vcmlnaW4sdHlwZSx1MSx1Mix1bmRlcmxpbmUtcG9zaXRpb24sdW5kZXJsaW5lLXRoaWNrbmVzcyx1bmljb2RlLHVuaWNvZGUtYmlkaSx1bmljb2RlLXJhbmdlLHVuaXRzLXBlci1lbSx2LWFscGhhYmV0aWMsdi1oYW5naW5nLHYtaWRlb2dyYXBoaWMsdi1tYXRoZW1hdGljYWwsdmFsdWVzLHZlY3Rvci1lZmZlY3QsdmVyc2lvbix2ZXJ0LWFkdi15LHZlcnQtb3JpZ2luLXgsdmVydC1vcmlnaW4teSx2aWV3Qm94LHZpZXdUYXJnZXQsdmlzaWJpbGl0eSx3aWR0aCx3aWR0aHMsd29yZC1zcGFjaW5nLHdyaXRpbmctbW9kZSx4LHgtaGVpZ2h0LHgxLHgyLHhDaGFubmVsU2VsZWN0b3IseGxpbms6YWN0dWF0ZSx4bGluazphcmNyb2xlLHhsaW5rOmhyZWYseGxpbms6cm9sZSx4bGluazpzaG93LHhsaW5rOnRpdGxlLHhsaW5rOnR5cGUseG1sbnM6eGxpbmsseG1sOmJhc2UseG1sOmxhbmcseG1sOnNwYWNlLHkseTEseTIseUNoYW5uZWxTZWxlY3Rvcix6LHpvb21BbmRQYW5cIlxuKTtcbmZ1bmN0aW9uIEpfKHQpIHtcbiAgaWYgKHQgPT0gbnVsbClcbiAgICByZXR1cm4gITE7XG4gIGNvbnN0IGUgPSB0eXBlb2YgdDtcbiAgcmV0dXJuIGUgPT09IFwic3RyaW5nXCIgfHwgZSA9PT0gXCJudW1iZXJcIiB8fCBlID09PSBcImJvb2xlYW5cIjtcbn1cbmZ1bmN0aW9uIGVUKHQsIGUpIHtcbiAgaWYgKHQubGVuZ3RoICE9PSBlLmxlbmd0aClcbiAgICByZXR1cm4gITE7XG4gIGxldCBuID0gITA7XG4gIGZvciAobGV0IHIgPSAwOyBuICYmIHIgPCB0Lmxlbmd0aDsgcisrKVxuICAgIG4gPSB0cyh0W3JdLCBlW3JdKTtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiB0cyh0LCBlKSB7XG4gIGlmICh0ID09PSBlKVxuICAgIHJldHVybiAhMDtcbiAgbGV0IG4gPSBvbSh0KSwgciA9IG9tKGUpO1xuICBpZiAobiB8fCByKVxuICAgIHJldHVybiBuICYmIHIgPyB0LmdldFRpbWUoKSA9PT0gZS5nZXRUaW1lKCkgOiAhMTtcbiAgaWYgKG4gPSBPcih0KSwgciA9IE9yKGUpLCBuIHx8IHIpXG4gICAgcmV0dXJuIHQgPT09IGU7XG4gIGlmIChuID0gaWUodCksIHIgPSBpZShlKSwgbiB8fCByKVxuICAgIHJldHVybiBuICYmIHIgPyBlVCh0LCBlKSA6ICExO1xuICBpZiAobiA9IFplKHQpLCByID0gWmUoZSksIG4gfHwgcikge1xuICAgIGlmICghbiB8fCAhcilcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBpID0gT2JqZWN0LmtleXModCkubGVuZ3RoLCBzID0gT2JqZWN0LmtleXMoZSkubGVuZ3RoO1xuICAgIGlmIChpICE9PSBzKVxuICAgICAgcmV0dXJuICExO1xuICAgIGZvciAoY29uc3QgbyBpbiB0KSB7XG4gICAgICBjb25zdCBhID0gdC5oYXNPd25Qcm9wZXJ0eShvKSwgbCA9IGUuaGFzT3duUHJvcGVydHkobyk7XG4gICAgICBpZiAoYSAmJiAhbCB8fCAhYSAmJiBsIHx8ICF0cyh0W29dLCBlW29dKSlcbiAgICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgfVxuICByZXR1cm4gU3RyaW5nKHQpID09PSBTdHJpbmcoZSk7XG59XG5mdW5jdGlvbiBoZCh0LCBlKSB7XG4gIHJldHVybiB0LmZpbmRJbmRleCgobikgPT4gdHMobiwgZSkpO1xufVxuY29uc3QgRGUgPSAodCkgPT4gd2UodCkgPyB0IDogdCA9PSBudWxsID8gXCJcIiA6IGllKHQpIHx8IFplKHQpICYmICh0LnRvU3RyaW5nID09PSBoeSB8fCAhYmUodC50b1N0cmluZykpID8gSlNPTi5zdHJpbmdpZnkodCwgd3ksIDIpIDogU3RyaW5nKHQpLCB3eSA9ICh0LCBlKSA9PiBlICYmIGUuX192X2lzUmVmID8gd3kodCwgZS52YWx1ZSkgOiBDcyhlKSA/IHtcbiAgW2BNYXAoJHtlLnNpemV9KWBdOiBbLi4uZS5lbnRyaWVzKCldLnJlZHVjZShcbiAgICAobiwgW3IsIGldLCBzKSA9PiAobltzZihyLCBzKSArIFwiID0+XCJdID0gaSwgbiksXG4gICAge31cbiAgKVxufSA6IEdzKGUpID8ge1xuICBbYFNldCgke2Uuc2l6ZX0pYF06IFsuLi5lLnZhbHVlcygpXS5tYXAoKG4pID0+IHNmKG4pKVxufSA6IE9yKGUpID8gc2YoZSkgOiBaZShlKSAmJiAhaWUoZSkgJiYgIXB5KGUpID8gU3RyaW5nKGUpIDogZSwgc2YgPSAodCwgZSA9IFwiXCIpID0+IHtcbiAgdmFyIG47XG4gIHJldHVybiBPcih0KSA/IGBTeW1ib2woJHsobiA9IHQuZGVzY3JpcHRpb24pICE9IG51bGwgPyBuIDogZX0pYCA6IHQ7XG59O1xuLyoqXG4qIEB2dWUvcmVhY3Rpdml0eSB2My40LjIxXG4qIChjKSAyMDE4LXByZXNlbnQgWXV4aSAoRXZhbikgWW91IGFuZCBWdWUgY29udHJpYnV0b3JzXG4qIEBsaWNlbnNlIE1JVFxuKiovXG5mdW5jdGlvbiBNcih0LCAuLi5lKSB7XG4gIGNvbnNvbGUud2FybihgW1Z1ZSB3YXJuXSAke3R9YCwgLi4uZSk7XG59XG5sZXQgQW47XG5jbGFzcyBlTyB7XG4gIGNvbnN0cnVjdG9yKGUgPSAhMSkge1xuICAgIHRoaXMuZGV0YWNoZWQgPSBlLCB0aGlzLl9hY3RpdmUgPSAhMCwgdGhpcy5lZmZlY3RzID0gW10sIHRoaXMuY2xlYW51cHMgPSBbXSwgdGhpcy5wYXJlbnQgPSBBbiwgIWUgJiYgQW4gJiYgKHRoaXMuaW5kZXggPSAoQW4uc2NvcGVzIHx8IChBbi5zY29wZXMgPSBbXSkpLnB1c2goXG4gICAgICB0aGlzXG4gICAgKSAtIDEpO1xuICB9XG4gIGdldCBhY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FjdGl2ZTtcbiAgfVxuICBydW4oZSkge1xuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIGNvbnN0IG4gPSBBbjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBBbiA9IHRoaXMsIGUoKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIEFuID0gbjtcbiAgICAgIH1cbiAgICB9IGVsc2VcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBNcihcImNhbm5vdCBydW4gYW4gaW5hY3RpdmUgZWZmZWN0IHNjb3BlLlwiKTtcbiAgfVxuICAvKipcbiAgICogVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gbm9uLWRldGFjaGVkIHNjb3Blc1xuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG9uKCkge1xuICAgIEFuID0gdGhpcztcbiAgfVxuICAvKipcbiAgICogVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgb24gbm9uLWRldGFjaGVkIHNjb3Blc1xuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG9mZigpIHtcbiAgICBBbiA9IHRoaXMucGFyZW50O1xuICB9XG4gIHN0b3AoZSkge1xuICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgIGxldCBuLCByO1xuICAgICAgZm9yIChuID0gMCwgciA9IHRoaXMuZWZmZWN0cy5sZW5ndGg7IG4gPCByOyBuKyspXG4gICAgICAgIHRoaXMuZWZmZWN0c1tuXS5zdG9wKCk7XG4gICAgICBmb3IgKG4gPSAwLCByID0gdGhpcy5jbGVhbnVwcy5sZW5ndGg7IG4gPCByOyBuKyspXG4gICAgICAgIHRoaXMuY2xlYW51cHNbbl0oKTtcbiAgICAgIGlmICh0aGlzLnNjb3BlcylcbiAgICAgICAgZm9yIChuID0gMCwgciA9IHRoaXMuc2NvcGVzLmxlbmd0aDsgbiA8IHI7IG4rKylcbiAgICAgICAgICB0aGlzLnNjb3Blc1tuXS5zdG9wKCEwKTtcbiAgICAgIGlmICghdGhpcy5kZXRhY2hlZCAmJiB0aGlzLnBhcmVudCAmJiAhZSkge1xuICAgICAgICBjb25zdCBpID0gdGhpcy5wYXJlbnQuc2NvcGVzLnBvcCgpO1xuICAgICAgICBpICYmIGkgIT09IHRoaXMgJiYgKHRoaXMucGFyZW50LnNjb3Blc1t0aGlzLmluZGV4XSA9IGksIGkuaW5kZXggPSB0aGlzLmluZGV4KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGFyZW50ID0gdm9pZCAwLCB0aGlzLl9hY3RpdmUgPSAhMTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHRUKHQpIHtcbiAgcmV0dXJuIG5ldyBlTyh0KTtcbn1cbmZ1bmN0aW9uIGt5KHQsIGUgPSBBbikge1xuICBlICYmIGUuYWN0aXZlICYmIGUuZWZmZWN0cy5wdXNoKHQpO1xufVxuZnVuY3Rpb24gUmwoKSB7XG4gIHJldHVybiBBbjtcbn1cbmZ1bmN0aW9uIHRPKHQpIHtcbiAgQW4gPyBBbi5jbGVhbnVwcy5wdXNoKHQpIDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIE1yKFxuICAgIFwib25TY29wZURpc3Bvc2UoKSBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBubyBhY3RpdmUgZWZmZWN0IHNjb3BlIHRvIGJlIGFzc29jaWF0ZWQgd2l0aC5cIlxuICApO1xufVxubGV0IEFzO1xuY2xhc3MgQW8ge1xuICBjb25zdHJ1Y3RvcihlLCBuLCByLCBpKSB7XG4gICAgdGhpcy5mbiA9IGUsIHRoaXMudHJpZ2dlciA9IG4sIHRoaXMuc2NoZWR1bGVyID0gciwgdGhpcy5hY3RpdmUgPSAhMCwgdGhpcy5kZXBzID0gW10sIHRoaXMuX2RpcnR5TGV2ZWwgPSA0LCB0aGlzLl90cmFja0lkID0gMCwgdGhpcy5fcnVubmluZ3MgPSAwLCB0aGlzLl9zaG91bGRTY2hlZHVsZSA9ICExLCB0aGlzLl9kZXBzTGVuZ3RoID0gMCwga3kodGhpcywgaSk7XG4gIH1cbiAgZ2V0IGRpcnR5KCkge1xuICAgIGlmICh0aGlzLl9kaXJ0eUxldmVsID09PSAyIHx8IHRoaXMuX2RpcnR5TGV2ZWwgPT09IDMpIHtcbiAgICAgIHRoaXMuX2RpcnR5TGV2ZWwgPSAxLCBkcygpO1xuICAgICAgZm9yIChsZXQgZSA9IDA7IGUgPCB0aGlzLl9kZXBzTGVuZ3RoOyBlKyspIHtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuZGVwc1tlXTtcbiAgICAgICAgaWYgKG4uY29tcHV0ZWQgJiYgKG5UKG4uY29tcHV0ZWQpLCB0aGlzLl9kaXJ0eUxldmVsID49IDQpKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdGhpcy5fZGlydHlMZXZlbCA9PT0gMSAmJiAodGhpcy5fZGlydHlMZXZlbCA9IDApLCBmcygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZGlydHlMZXZlbCA+PSA0O1xuICB9XG4gIHNldCBkaXJ0eShlKSB7XG4gICAgdGhpcy5fZGlydHlMZXZlbCA9IGUgPyA0IDogMDtcbiAgfVxuICBydW4oKSB7XG4gICAgaWYgKHRoaXMuX2RpcnR5TGV2ZWwgPSAwLCAhdGhpcy5hY3RpdmUpXG4gICAgICByZXR1cm4gdGhpcy5mbigpO1xuICAgIGxldCBlID0gcWksIG4gPSBBcztcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHFpID0gITAsIEFzID0gdGhpcywgdGhpcy5fcnVubmluZ3MrKywgdW0odGhpcyksIHRoaXMuZm4oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZG0odGhpcyksIHRoaXMuX3J1bm5pbmdzLS0sIEFzID0gbiwgcWkgPSBlO1xuICAgIH1cbiAgfVxuICBzdG9wKCkge1xuICAgIHZhciBlO1xuICAgIHRoaXMuYWN0aXZlICYmICh1bSh0aGlzKSwgZG0odGhpcyksIChlID0gdGhpcy5vblN0b3ApID09IG51bGwgfHwgZS5jYWxsKHRoaXMpLCB0aGlzLmFjdGl2ZSA9ICExKTtcbiAgfVxufVxuZnVuY3Rpb24gblQodCkge1xuICByZXR1cm4gdC52YWx1ZTtcbn1cbmZ1bmN0aW9uIHVtKHQpIHtcbiAgdC5fdHJhY2tJZCsrLCB0Ll9kZXBzTGVuZ3RoID0gMDtcbn1cbmZ1bmN0aW9uIGRtKHQpIHtcbiAgaWYgKHQuZGVwcy5sZW5ndGggPiB0Ll9kZXBzTGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgZSA9IHQuX2RlcHNMZW5ndGg7IGUgPCB0LmRlcHMubGVuZ3RoOyBlKyspXG4gICAgICB4eSh0LmRlcHNbZV0sIHQpO1xuICAgIHQuZGVwcy5sZW5ndGggPSB0Ll9kZXBzTGVuZ3RoO1xuICB9XG59XG5mdW5jdGlvbiB4eSh0LCBlKSB7XG4gIGNvbnN0IG4gPSB0LmdldChlKTtcbiAgbiAhPT0gdm9pZCAwICYmIGUuX3RyYWNrSWQgIT09IG4gJiYgKHQuZGVsZXRlKGUpLCB0LnNpemUgPT09IDAgJiYgdC5jbGVhbnVwKCkpO1xufVxuZnVuY3Rpb24gclQodCwgZSkge1xuICB0LmVmZmVjdCBpbnN0YW5jZW9mIEFvICYmICh0ID0gdC5lZmZlY3QuZm4pO1xuICBjb25zdCBuID0gbmV3IEFvKHQsIGl0LCAoKSA9PiB7XG4gICAgbi5kaXJ0eSAmJiBuLnJ1bigpO1xuICB9KTtcbiAgZSAmJiAoJGUobiwgZSksIGUuc2NvcGUgJiYga3kobiwgZS5zY29wZSkpLCAoIWUgfHwgIWUubGF6eSkgJiYgbi5ydW4oKTtcbiAgY29uc3QgciA9IG4ucnVuLmJpbmQobik7XG4gIHJldHVybiByLmVmZmVjdCA9IG4sIHI7XG59XG5mdW5jdGlvbiBpVCh0KSB7XG4gIHQuZWZmZWN0LnN0b3AoKTtcbn1cbmxldCBxaSA9ICEwLCBzaCA9IDA7XG5jb25zdCBQeSA9IFtdO1xuZnVuY3Rpb24gZHMoKSB7XG4gIFB5LnB1c2gocWkpLCBxaSA9ICExO1xufVxuZnVuY3Rpb24gZnMoKSB7XG4gIGNvbnN0IHQgPSBQeS5wb3AoKTtcbiAgcWkgPSB0ID09PSB2b2lkIDAgPyAhMCA6IHQ7XG59XG5mdW5jdGlvbiBuTygpIHtcbiAgc2grKztcbn1cbmZ1bmN0aW9uIHJPKCkge1xuICBmb3IgKHNoLS07ICFzaCAmJiBvaC5sZW5ndGg7IClcbiAgICBvaC5zaGlmdCgpKCk7XG59XG5mdW5jdGlvbiBfeSh0LCBlLCBuKSB7XG4gIHZhciByO1xuICBpZiAoZS5nZXQodCkgIT09IHQuX3RyYWNrSWQpIHtcbiAgICBlLnNldCh0LCB0Ll90cmFja0lkKTtcbiAgICBjb25zdCBpID0gdC5kZXBzW3QuX2RlcHNMZW5ndGhdO1xuICAgIGkgIT09IGUgPyAoaSAmJiB4eShpLCB0KSwgdC5kZXBzW3QuX2RlcHNMZW5ndGgrK10gPSBlKSA6IHQuX2RlcHNMZW5ndGgrKywgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICgociA9IHQub25UcmFjaykgPT0gbnVsbCB8fCByLmNhbGwodCwgJGUoeyBlZmZlY3Q6IHQgfSwgbikpKTtcbiAgfVxufVxuY29uc3Qgb2ggPSBbXTtcbmZ1bmN0aW9uIFR5KHQsIGUsIG4pIHtcbiAgdmFyIHI7XG4gIG5PKCk7XG4gIGZvciAoY29uc3QgaSBvZiB0LmtleXMoKSkge1xuICAgIGxldCBzO1xuICAgIGkuX2RpcnR5TGV2ZWwgPCBlICYmIChzID8/IChzID0gdC5nZXQoaSkgPT09IGkuX3RyYWNrSWQpKSAmJiAoaS5fc2hvdWxkU2NoZWR1bGUgfHwgKGkuX3Nob3VsZFNjaGVkdWxlID0gaS5fZGlydHlMZXZlbCA9PT0gMCksIGkuX2RpcnR5TGV2ZWwgPSBlKSwgaS5fc2hvdWxkU2NoZWR1bGUgJiYgKHMgPz8gKHMgPSB0LmdldChpKSA9PT0gaS5fdHJhY2tJZCkpICYmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKChyID0gaS5vblRyaWdnZXIpID09IG51bGwgfHwgci5jYWxsKGksICRlKHsgZWZmZWN0OiBpIH0sIG4pKSksIGkudHJpZ2dlcigpLCAoIWkuX3J1bm5pbmdzIHx8IGkuYWxsb3dSZWN1cnNlKSAmJiBpLl9kaXJ0eUxldmVsICE9PSAyICYmIChpLl9zaG91bGRTY2hlZHVsZSA9ICExLCBpLnNjaGVkdWxlciAmJiBvaC5wdXNoKGkuc2NoZWR1bGVyKSkpO1xuICB9XG4gIHJPKCk7XG59XG5jb25zdCBFeSA9ICh0LCBlKSA9PiB7XG4gIGNvbnN0IG4gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICByZXR1cm4gbi5jbGVhbnVwID0gdCwgbi5jb21wdXRlZCA9IGUsIG47XG59LCB5dSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBScyA9IFN5bWJvbChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIml0ZXJhdGVcIiA6IFwiXCIpLCBhaCA9IFN5bWJvbChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIk1hcCBrZXkgaXRlcmF0ZVwiIDogXCJcIik7XG5mdW5jdGlvbiBLdCh0LCBlLCBuKSB7XG4gIGlmIChxaSAmJiBBcykge1xuICAgIGxldCByID0geXUuZ2V0KHQpO1xuICAgIHIgfHwgeXUuc2V0KHQsIHIgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgICBsZXQgaSA9IHIuZ2V0KG4pO1xuICAgIGkgfHwgci5zZXQobiwgaSA9IEV5KCgpID0+IHIuZGVsZXRlKG4pKSksIF95KFxuICAgICAgQXMsXG4gICAgICBpLFxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8ge1xuICAgICAgICB0YXJnZXQ6IHQsXG4gICAgICAgIHR5cGU6IGUsXG4gICAgICAgIGtleTogblxuICAgICAgfSA6IHZvaWQgMFxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIFpyKHQsIGUsIG4sIHIsIGksIHMpIHtcbiAgY29uc3QgbyA9IHl1LmdldCh0KTtcbiAgaWYgKCFvKVxuICAgIHJldHVybjtcbiAgbGV0IGEgPSBbXTtcbiAgaWYgKGUgPT09IFwiY2xlYXJcIilcbiAgICBhID0gWy4uLm8udmFsdWVzKCldO1xuICBlbHNlIGlmIChuID09PSBcImxlbmd0aFwiICYmIGllKHQpKSB7XG4gICAgY29uc3QgbCA9IE51bWJlcihyKTtcbiAgICBvLmZvckVhY2goKGMsIHUpID0+IHtcbiAgICAgICh1ID09PSBcImxlbmd0aFwiIHx8ICFPcih1KSAmJiB1ID49IGwpICYmIGEucHVzaChjKTtcbiAgICB9KTtcbiAgfSBlbHNlXG4gICAgc3dpdGNoIChuICE9PSB2b2lkIDAgJiYgYS5wdXNoKG8uZ2V0KG4pKSwgZSkge1xuICAgICAgY2FzZSBcImFkZFwiOlxuICAgICAgICBpZSh0KSA/IEtwKG4pICYmIGEucHVzaChvLmdldChcImxlbmd0aFwiKSkgOiAoYS5wdXNoKG8uZ2V0KFJzKSksIENzKHQpICYmIGEucHVzaChvLmdldChhaCkpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZGVsZXRlXCI6XG4gICAgICAgIGllKHQpIHx8IChhLnB1c2goby5nZXQoUnMpKSwgQ3ModCkgJiYgYS5wdXNoKG8uZ2V0KGFoKSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzZXRcIjpcbiAgICAgICAgQ3ModCkgJiYgYS5wdXNoKG8uZ2V0KFJzKSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgbk8oKTtcbiAgZm9yIChjb25zdCBsIG9mIGEpXG4gICAgbCAmJiBUeShcbiAgICAgIGwsXG4gICAgICA0LFxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8ge1xuICAgICAgICB0YXJnZXQ6IHQsXG4gICAgICAgIHR5cGU6IGUsXG4gICAgICAgIGtleTogbixcbiAgICAgICAgbmV3VmFsdWU6IHIsXG4gICAgICAgIG9sZFZhbHVlOiBpLFxuICAgICAgICBvbGRUYXJnZXQ6IHNcbiAgICAgIH0gOiB2b2lkIDBcbiAgICApO1xuICByTygpO1xufVxuZnVuY3Rpb24gc1QodCwgZSkge1xuICB2YXIgbjtcbiAgcmV0dXJuIChuID0geXUuZ2V0KHQpKSA9PSBudWxsID8gdm9pZCAwIDogbi5nZXQoZSk7XG59XG5jb25zdCBvVCA9IC8qIEBfX1BVUkVfXyAqLyBCdChcIl9fcHJvdG9fXyxfX3ZfaXNSZWYsX19pc1Z1ZVwiKSwgJHkgPSBuZXcgU2V0KFxuICAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoU3ltYm9sKS5maWx0ZXIoKHQpID0+IHQgIT09IFwiYXJndW1lbnRzXCIgJiYgdCAhPT0gXCJjYWxsZXJcIikubWFwKCh0KSA9PiBTeW1ib2xbdF0pLmZpbHRlcihPcilcbiksIGZtID0gLyogQF9fUFVSRV9fICovIGFUKCk7XG5mdW5jdGlvbiBhVCgpIHtcbiAgY29uc3QgdCA9IHt9O1xuICByZXR1cm4gW1wiaW5jbHVkZXNcIiwgXCJpbmRleE9mXCIsIFwibGFzdEluZGV4T2ZcIl0uZm9yRWFjaCgoZSkgPT4ge1xuICAgIHRbZV0gPSBmdW5jdGlvbiguLi5uKSB7XG4gICAgICBjb25zdCByID0gT2UodGhpcyk7XG4gICAgICBmb3IgKGxldCBzID0gMCwgbyA9IHRoaXMubGVuZ3RoOyBzIDwgbzsgcysrKVxuICAgICAgICBLdChyLCBcImdldFwiLCBzICsgXCJcIik7XG4gICAgICBjb25zdCBpID0gcltlXSguLi5uKTtcbiAgICAgIHJldHVybiBpID09PSAtMSB8fCBpID09PSAhMSA/IHJbZV0oLi4ubi5tYXAoT2UpKSA6IGk7XG4gICAgfTtcbiAgfSksIFtcInB1c2hcIiwgXCJwb3BcIiwgXCJzaGlmdFwiLCBcInVuc2hpZnRcIiwgXCJzcGxpY2VcIl0uZm9yRWFjaCgoZSkgPT4ge1xuICAgIHRbZV0gPSBmdW5jdGlvbiguLi5uKSB7XG4gICAgICBkcygpLCBuTygpO1xuICAgICAgY29uc3QgciA9IE9lKHRoaXMpW2VdLmFwcGx5KHRoaXMsIG4pO1xuICAgICAgcmV0dXJuIHJPKCksIGZzKCksIHI7XG4gICAgfTtcbiAgfSksIHQ7XG59XG5mdW5jdGlvbiBsVCh0KSB7XG4gIGNvbnN0IGUgPSBPZSh0aGlzKTtcbiAgcmV0dXJuIEt0KGUsIFwiaGFzXCIsIHQpLCBlLmhhc093blByb3BlcnR5KHQpO1xufVxuY2xhc3MgUXkge1xuICBjb25zdHJ1Y3RvcihlID0gITEsIG4gPSAhMSkge1xuICAgIHRoaXMuX2lzUmVhZG9ubHkgPSBlLCB0aGlzLl9pc1NoYWxsb3cgPSBuO1xuICB9XG4gIGdldChlLCBuLCByKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuX2lzUmVhZG9ubHksIHMgPSB0aGlzLl9pc1NoYWxsb3c7XG4gICAgaWYgKG4gPT09IFwiX192X2lzUmVhY3RpdmVcIilcbiAgICAgIHJldHVybiAhaTtcbiAgICBpZiAobiA9PT0gXCJfX3ZfaXNSZWFkb25seVwiKVxuICAgICAgcmV0dXJuIGk7XG4gICAgaWYgKG4gPT09IFwiX192X2lzU2hhbGxvd1wiKVxuICAgICAgcmV0dXJuIHM7XG4gICAgaWYgKG4gPT09IFwiX192X3Jhd1wiKVxuICAgICAgcmV0dXJuIHIgPT09IChpID8gcyA/IFZ5IDogWnkgOiBzID8gRHkgOiBOeSkuZ2V0KGUpIHx8IC8vIHJlY2VpdmVyIGlzIG5vdCB0aGUgcmVhY3RpdmUgcHJveHksIGJ1dCBoYXMgdGhlIHNhbWUgcHJvdG90eXBlXG4gICAgICAvLyB0aGlzIG1lYW5zIHRoZSByZWNpZXZlciBpcyBhIHVzZXIgcHJveHkgb2YgdGhlIHJlYWN0aXZlIHByb3h5XG4gICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSkgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZihyKSA/IGUgOiB2b2lkIDA7XG4gICAgY29uc3QgbyA9IGllKGUpO1xuICAgIGlmICghaSkge1xuICAgICAgaWYgKG8gJiYgQWUoZm0sIG4pKVxuICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQoZm0sIG4sIHIpO1xuICAgICAgaWYgKG4gPT09IFwiaGFzT3duUHJvcGVydHlcIilcbiAgICAgICAgcmV0dXJuIGxUO1xuICAgIH1cbiAgICBjb25zdCBhID0gUmVmbGVjdC5nZXQoZSwgbiwgcik7XG4gICAgcmV0dXJuIChPcihuKSA/ICR5LmhhcyhuKSA6IG9UKG4pKSB8fCAoaSB8fCBLdChlLCBcImdldFwiLCBuKSwgcykgPyBhIDogQ3QoYSkgPyBvICYmIEtwKG4pID8gYSA6IGEudmFsdWUgOiBaZShhKSA/IGkgPyBzTyhhKSA6IFhuKGEpIDogYTtcbiAgfVxufVxuY2xhc3MgQ3kgZXh0ZW5kcyBReSB7XG4gIGNvbnN0cnVjdG9yKGUgPSAhMSkge1xuICAgIHN1cGVyKCExLCBlKTtcbiAgfVxuICBzZXQoZSwgbiwgciwgaSkge1xuICAgIGxldCBzID0gZVtuXTtcbiAgICBpZiAoIXRoaXMuX2lzU2hhbGxvdykge1xuICAgICAgY29uc3QgbCA9IGFpKHMpO1xuICAgICAgaWYgKCF6aShyKSAmJiAhYWkocikgJiYgKHMgPSBPZShzKSwgciA9IE9lKHIpKSwgIWllKGUpICYmIEN0KHMpICYmICFDdChyKSlcbiAgICAgICAgcmV0dXJuIGwgPyAhMSA6IChzLnZhbHVlID0gciwgITApO1xuICAgIH1cbiAgICBjb25zdCBvID0gaWUoZSkgJiYgS3AobikgPyBOdW1iZXIobikgPCBlLmxlbmd0aCA6IEFlKGUsIG4pLCBhID0gUmVmbGVjdC5zZXQoZSwgbiwgciwgaSk7XG4gICAgcmV0dXJuIGUgPT09IE9lKGkpICYmIChvID8gZ3IociwgcykgJiYgWnIoZSwgXCJzZXRcIiwgbiwgciwgcykgOiBacihlLCBcImFkZFwiLCBuLCByKSksIGE7XG4gIH1cbiAgZGVsZXRlUHJvcGVydHkoZSwgbikge1xuICAgIGNvbnN0IHIgPSBBZShlLCBuKSwgaSA9IGVbbl0sIHMgPSBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KGUsIG4pO1xuICAgIHJldHVybiBzICYmIHIgJiYgWnIoZSwgXCJkZWxldGVcIiwgbiwgdm9pZCAwLCBpKSwgcztcbiAgfVxuICBoYXMoZSwgbikge1xuICAgIGNvbnN0IHIgPSBSZWZsZWN0LmhhcyhlLCBuKTtcbiAgICByZXR1cm4gKCFPcihuKSB8fCAhJHkuaGFzKG4pKSAmJiBLdChlLCBcImhhc1wiLCBuKSwgcjtcbiAgfVxuICBvd25LZXlzKGUpIHtcbiAgICByZXR1cm4gS3QoXG4gICAgICBlLFxuICAgICAgXCJpdGVyYXRlXCIsXG4gICAgICBpZShlKSA/IFwibGVuZ3RoXCIgOiBSc1xuICAgICksIFJlZmxlY3Qub3duS2V5cyhlKTtcbiAgfVxufVxuY2xhc3MgQXkgZXh0ZW5kcyBReSB7XG4gIGNvbnN0cnVjdG9yKGUgPSAhMSkge1xuICAgIHN1cGVyKCEwLCBlKTtcbiAgfVxuICBzZXQoZSwgbikge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgTXIoXG4gICAgICBgU2V0IG9wZXJhdGlvbiBvbiBrZXkgXCIke1N0cmluZyhuKX1cIiBmYWlsZWQ6IHRhcmdldCBpcyByZWFkb25seS5gLFxuICAgICAgZVxuICAgICksICEwO1xuICB9XG4gIGRlbGV0ZVByb3BlcnR5KGUsIG4pIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIE1yKFxuICAgICAgYERlbGV0ZSBvcGVyYXRpb24gb24ga2V5IFwiJHtTdHJpbmcobil9XCIgZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCxcbiAgICAgIGVcbiAgICApLCAhMDtcbiAgfVxufVxuY29uc3QgY1QgPSAvKiBAX19QVVJFX18gKi8gbmV3IEN5KCksIHVUID0gLyogQF9fUFVSRV9fICovIG5ldyBBeSgpLCBkVCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgQ3koXG4gICEwXG4pLCBmVCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgQXkoITApLCBpTyA9ICh0KSA9PiB0LCBwZCA9ICh0KSA9PiBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHQpO1xuZnVuY3Rpb24gY2ModCwgZSwgbiA9ICExLCByID0gITEpIHtcbiAgdCA9IHQuX192X3JhdztcbiAgY29uc3QgaSA9IE9lKHQpLCBzID0gT2UoZSk7XG4gIG4gfHwgKGdyKGUsIHMpICYmIEt0KGksIFwiZ2V0XCIsIGUpLCBLdChpLCBcImdldFwiLCBzKSk7XG4gIGNvbnN0IHsgaGFzOiBvIH0gPSBwZChpKSwgYSA9IHIgPyBpTyA6IG4gPyBhTyA6IGVsO1xuICBpZiAoby5jYWxsKGksIGUpKVxuICAgIHJldHVybiBhKHQuZ2V0KGUpKTtcbiAgaWYgKG8uY2FsbChpLCBzKSlcbiAgICByZXR1cm4gYSh0LmdldChzKSk7XG4gIHQgIT09IGkgJiYgdC5nZXQoZSk7XG59XG5mdW5jdGlvbiB1Yyh0LCBlID0gITEpIHtcbiAgY29uc3QgbiA9IHRoaXMuX192X3JhdywgciA9IE9lKG4pLCBpID0gT2UodCk7XG4gIHJldHVybiBlIHx8IChncih0LCBpKSAmJiBLdChyLCBcImhhc1wiLCB0KSwgS3QociwgXCJoYXNcIiwgaSkpLCB0ID09PSBpID8gbi5oYXModCkgOiBuLmhhcyh0KSB8fCBuLmhhcyhpKTtcbn1cbmZ1bmN0aW9uIGRjKHQsIGUgPSAhMSkge1xuICByZXR1cm4gdCA9IHQuX192X3JhdywgIWUgJiYgS3QoT2UodCksIFwiaXRlcmF0ZVwiLCBScyksIFJlZmxlY3QuZ2V0KHQsIFwic2l6ZVwiLCB0KTtcbn1cbmZ1bmN0aW9uIGhtKHQpIHtcbiAgdCA9IE9lKHQpO1xuICBjb25zdCBlID0gT2UodGhpcyk7XG4gIHJldHVybiBwZChlKS5oYXMuY2FsbChlLCB0KSB8fCAoZS5hZGQodCksIFpyKGUsIFwiYWRkXCIsIHQsIHQpKSwgdGhpcztcbn1cbmZ1bmN0aW9uIHBtKHQsIGUpIHtcbiAgZSA9IE9lKGUpO1xuICBjb25zdCBuID0gT2UodGhpcyksIHsgaGFzOiByLCBnZXQ6IGkgfSA9IHBkKG4pO1xuICBsZXQgcyA9IHIuY2FsbChuLCB0KTtcbiAgcyA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBSeShuLCByLCB0KSA6ICh0ID0gT2UodCksIHMgPSByLmNhbGwobiwgdCkpO1xuICBjb25zdCBvID0gaS5jYWxsKG4sIHQpO1xuICByZXR1cm4gbi5zZXQodCwgZSksIHMgPyBncihlLCBvKSAmJiBacihuLCBcInNldFwiLCB0LCBlLCBvKSA6IFpyKG4sIFwiYWRkXCIsIHQsIGUpLCB0aGlzO1xufVxuZnVuY3Rpb24gT20odCkge1xuICBjb25zdCBlID0gT2UodGhpcyksIHsgaGFzOiBuLCBnZXQ6IHIgfSA9IHBkKGUpO1xuICBsZXQgaSA9IG4uY2FsbChlLCB0KTtcbiAgaSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBSeShlLCBuLCB0KSA6ICh0ID0gT2UodCksIGkgPSBuLmNhbGwoZSwgdCkpO1xuICBjb25zdCBzID0gciA/IHIuY2FsbChlLCB0KSA6IHZvaWQgMCwgbyA9IGUuZGVsZXRlKHQpO1xuICByZXR1cm4gaSAmJiBacihlLCBcImRlbGV0ZVwiLCB0LCB2b2lkIDAsIHMpLCBvO1xufVxuZnVuY3Rpb24gZ20oKSB7XG4gIGNvbnN0IHQgPSBPZSh0aGlzKSwgZSA9IHQuc2l6ZSAhPT0gMCwgbiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IENzKHQpID8gbmV3IE1hcCh0KSA6IG5ldyBTZXQodCkgOiB2b2lkIDAsIHIgPSB0LmNsZWFyKCk7XG4gIHJldHVybiBlICYmIFpyKHQsIFwiY2xlYXJcIiwgdm9pZCAwLCB2b2lkIDAsIG4pLCByO1xufVxuZnVuY3Rpb24gZmModCwgZSkge1xuICByZXR1cm4gZnVuY3Rpb24ociwgaSkge1xuICAgIGNvbnN0IHMgPSB0aGlzLCBvID0gcy5fX3ZfcmF3LCBhID0gT2UobyksIGwgPSBlID8gaU8gOiB0ID8gYU8gOiBlbDtcbiAgICByZXR1cm4gIXQgJiYgS3QoYSwgXCJpdGVyYXRlXCIsIFJzKSwgby5mb3JFYWNoKChjLCB1KSA9PiByLmNhbGwoaSwgbChjKSwgbCh1KSwgcykpO1xuICB9O1xufVxuZnVuY3Rpb24gaGModCwgZSwgbikge1xuICByZXR1cm4gZnVuY3Rpb24oLi4ucikge1xuICAgIGNvbnN0IGkgPSB0aGlzLl9fdl9yYXcsIHMgPSBPZShpKSwgbyA9IENzKHMpLCBhID0gdCA9PT0gXCJlbnRyaWVzXCIgfHwgdCA9PT0gU3ltYm9sLml0ZXJhdG9yICYmIG8sIGwgPSB0ID09PSBcImtleXNcIiAmJiBvLCBjID0gaVt0XSguLi5yKSwgdSA9IG4gPyBpTyA6IGUgPyBhTyA6IGVsO1xuICAgIHJldHVybiAhZSAmJiBLdChcbiAgICAgIHMsXG4gICAgICBcIml0ZXJhdGVcIixcbiAgICAgIGwgPyBhaCA6IFJzXG4gICAgKSwge1xuICAgICAgLy8gaXRlcmF0b3IgcHJvdG9jb2xcbiAgICAgIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWU6IGQsIGRvbmU6IGYgfSA9IGMubmV4dCgpO1xuICAgICAgICByZXR1cm4gZiA/IHsgdmFsdWU6IGQsIGRvbmU6IGYgfSA6IHtcbiAgICAgICAgICB2YWx1ZTogYSA/IFt1KGRbMF0pLCB1KGRbMV0pXSA6IHUoZCksXG4gICAgICAgICAgZG9uZTogZlxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIC8vIGl0ZXJhYmxlIHByb3RvY29sXG4gICAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn1cbmZ1bmN0aW9uIFNpKHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKC4uLmUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBjb25zdCBuID0gZVswXSA/IGBvbiBrZXkgXCIke2VbMF19XCIgYCA6IFwiXCI7XG4gICAgICBNcihcbiAgICAgICAgYCR7V3IodCl9IG9wZXJhdGlvbiAke259ZmFpbGVkOiB0YXJnZXQgaXMgcmVhZG9ubHkuYCxcbiAgICAgICAgT2UodGhpcylcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB0ID09PSBcImRlbGV0ZVwiID8gITEgOiB0ID09PSBcImNsZWFyXCIgPyB2b2lkIDAgOiB0aGlzO1xuICB9O1xufVxuZnVuY3Rpb24gaFQoKSB7XG4gIGNvbnN0IHQgPSB7XG4gICAgZ2V0KHMpIHtcbiAgICAgIHJldHVybiBjYyh0aGlzLCBzKTtcbiAgICB9LFxuICAgIGdldCBzaXplKCkge1xuICAgICAgcmV0dXJuIGRjKHRoaXMpO1xuICAgIH0sXG4gICAgaGFzOiB1YyxcbiAgICBhZGQ6IGhtLFxuICAgIHNldDogcG0sXG4gICAgZGVsZXRlOiBPbSxcbiAgICBjbGVhcjogZ20sXG4gICAgZm9yRWFjaDogZmMoITEsICExKVxuICB9LCBlID0ge1xuICAgIGdldChzKSB7XG4gICAgICByZXR1cm4gY2ModGhpcywgcywgITEsICEwKTtcbiAgICB9LFxuICAgIGdldCBzaXplKCkge1xuICAgICAgcmV0dXJuIGRjKHRoaXMpO1xuICAgIH0sXG4gICAgaGFzOiB1YyxcbiAgICBhZGQ6IGhtLFxuICAgIHNldDogcG0sXG4gICAgZGVsZXRlOiBPbSxcbiAgICBjbGVhcjogZ20sXG4gICAgZm9yRWFjaDogZmMoITEsICEwKVxuICB9LCBuID0ge1xuICAgIGdldChzKSB7XG4gICAgICByZXR1cm4gY2ModGhpcywgcywgITApO1xuICAgIH0sXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICByZXR1cm4gZGModGhpcywgITApO1xuICAgIH0sXG4gICAgaGFzKHMpIHtcbiAgICAgIHJldHVybiB1Yy5jYWxsKHRoaXMsIHMsICEwKTtcbiAgICB9LFxuICAgIGFkZDogU2koXCJhZGRcIiksXG4gICAgc2V0OiBTaShcInNldFwiKSxcbiAgICBkZWxldGU6IFNpKFwiZGVsZXRlXCIpLFxuICAgIGNsZWFyOiBTaShcImNsZWFyXCIpLFxuICAgIGZvckVhY2g6IGZjKCEwLCAhMSlcbiAgfSwgciA9IHtcbiAgICBnZXQocykge1xuICAgICAgcmV0dXJuIGNjKHRoaXMsIHMsICEwLCAhMCk7XG4gICAgfSxcbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgIHJldHVybiBkYyh0aGlzLCAhMCk7XG4gICAgfSxcbiAgICBoYXMocykge1xuICAgICAgcmV0dXJuIHVjLmNhbGwodGhpcywgcywgITApO1xuICAgIH0sXG4gICAgYWRkOiBTaShcImFkZFwiKSxcbiAgICBzZXQ6IFNpKFwic2V0XCIpLFxuICAgIGRlbGV0ZTogU2koXCJkZWxldGVcIiksXG4gICAgY2xlYXI6IFNpKFwiY2xlYXJcIiksXG4gICAgZm9yRWFjaDogZmMoITAsICEwKVxuICB9O1xuICByZXR1cm4gW1wia2V5c1wiLCBcInZhbHVlc1wiLCBcImVudHJpZXNcIiwgU3ltYm9sLml0ZXJhdG9yXS5mb3JFYWNoKChzKSA9PiB7XG4gICAgdFtzXSA9IGhjKFxuICAgICAgcyxcbiAgICAgICExLFxuICAgICAgITFcbiAgICApLCBuW3NdID0gaGMoXG4gICAgICBzLFxuICAgICAgITAsXG4gICAgICAhMVxuICAgICksIGVbc10gPSBoYyhcbiAgICAgIHMsXG4gICAgICAhMSxcbiAgICAgICEwXG4gICAgKSwgcltzXSA9IGhjKFxuICAgICAgcyxcbiAgICAgICEwLFxuICAgICAgITBcbiAgICApO1xuICB9KSwgW1xuICAgIHQsXG4gICAgbixcbiAgICBlLFxuICAgIHJcbiAgXTtcbn1cbmNvbnN0IFtcbiAgcFQsXG4gIE9ULFxuICBnVCxcbiAgbVRcbl0gPSAvKiBAX19QVVJFX18gKi8gaFQoKTtcbmZ1bmN0aW9uIE9kKHQsIGUpIHtcbiAgY29uc3QgbiA9IGUgPyB0ID8gbVQgOiBnVCA6IHQgPyBPVCA6IHBUO1xuICByZXR1cm4gKHIsIGksIHMpID0+IGkgPT09IFwiX192X2lzUmVhY3RpdmVcIiA/ICF0IDogaSA9PT0gXCJfX3ZfaXNSZWFkb25seVwiID8gdCA6IGkgPT09IFwiX192X3Jhd1wiID8gciA6IFJlZmxlY3QuZ2V0KFxuICAgIEFlKG4sIGkpICYmIGkgaW4gciA/IG4gOiByLFxuICAgIGksXG4gICAgc1xuICApO1xufVxuY29uc3QgYlQgPSB7XG4gIGdldDogLyogQF9fUFVSRV9fICovIE9kKCExLCAhMSlcbn0sIHZUID0ge1xuICBnZXQ6IC8qIEBfX1BVUkVfXyAqLyBPZCghMSwgITApXG59LCB5VCA9IHtcbiAgZ2V0OiAvKiBAX19QVVJFX18gKi8gT2QoITAsICExKVxufSwgU1QgPSB7XG4gIGdldDogLyogQF9fUFVSRV9fICovIE9kKCEwLCAhMClcbn07XG5mdW5jdGlvbiBSeSh0LCBlLCBuKSB7XG4gIGNvbnN0IHIgPSBPZShuKTtcbiAgaWYgKHIgIT09IG4gJiYgZS5jYWxsKHQsIHIpKSB7XG4gICAgY29uc3QgaSA9IEdwKHQpO1xuICAgIE1yKFxuICAgICAgYFJlYWN0aXZlICR7aX0gY29udGFpbnMgYm90aCB0aGUgcmF3IGFuZCByZWFjdGl2ZSB2ZXJzaW9ucyBvZiB0aGUgc2FtZSBvYmplY3Qke2kgPT09IFwiTWFwXCIgPyBcIiBhcyBrZXlzXCIgOiBcIlwifSwgd2hpY2ggY2FuIGxlYWQgdG8gaW5jb25zaXN0ZW5jaWVzLiBBdm9pZCBkaWZmZXJlbnRpYXRpbmcgYmV0d2VlbiB0aGUgcmF3IGFuZCByZWFjdGl2ZSB2ZXJzaW9ucyBvZiBhbiBvYmplY3QgYW5kIG9ubHkgdXNlIHRoZSByZWFjdGl2ZSB2ZXJzaW9uIGlmIHBvc3NpYmxlLmBcbiAgICApO1xuICB9XG59XG5jb25zdCBOeSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBEeSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBaeSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBWeSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gd1QodCkge1xuICBzd2l0Y2ggKHQpIHtcbiAgICBjYXNlIFwiT2JqZWN0XCI6XG4gICAgY2FzZSBcIkFycmF5XCI6XG4gICAgICByZXR1cm4gMTtcbiAgICBjYXNlIFwiTWFwXCI6XG4gICAgY2FzZSBcIlNldFwiOlxuICAgIGNhc2UgXCJXZWFrTWFwXCI6XG4gICAgY2FzZSBcIldlYWtTZXRcIjpcbiAgICAgIHJldHVybiAyO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gMDtcbiAgfVxufVxuZnVuY3Rpb24ga1QodCkge1xuICByZXR1cm4gdC5fX3Zfc2tpcCB8fCAhT2JqZWN0LmlzRXh0ZW5zaWJsZSh0KSA/IDAgOiB3VChHcCh0KSk7XG59XG5mdW5jdGlvbiBYbih0KSB7XG4gIHJldHVybiBhaSh0KSA/IHQgOiBnZChcbiAgICB0LFxuICAgICExLFxuICAgIGNULFxuICAgIGJULFxuICAgIE55XG4gICk7XG59XG5mdW5jdGlvbiBJeSh0KSB7XG4gIHJldHVybiBnZChcbiAgICB0LFxuICAgICExLFxuICAgIGRULFxuICAgIHZULFxuICAgIER5XG4gICk7XG59XG5mdW5jdGlvbiBzTyh0KSB7XG4gIHJldHVybiBnZChcbiAgICB0LFxuICAgICEwLFxuICAgIHVULFxuICAgIHlULFxuICAgIFp5XG4gICk7XG59XG5mdW5jdGlvbiBEbih0KSB7XG4gIHJldHVybiBnZChcbiAgICB0LFxuICAgICEwLFxuICAgIGZULFxuICAgIFNULFxuICAgIFZ5XG4gICk7XG59XG5mdW5jdGlvbiBnZCh0LCBlLCBuLCByLCBpKSB7XG4gIGlmICghWmUodCkpXG4gICAgcmV0dXJuIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBNcihgdmFsdWUgY2Fubm90IGJlIG1hZGUgcmVhY3RpdmU6ICR7U3RyaW5nKHQpfWApLCB0O1xuICBpZiAodC5fX3ZfcmF3ICYmICEoZSAmJiB0Ll9fdl9pc1JlYWN0aXZlKSlcbiAgICByZXR1cm4gdDtcbiAgY29uc3QgcyA9IGkuZ2V0KHQpO1xuICBpZiAocylcbiAgICByZXR1cm4gcztcbiAgY29uc3QgbyA9IGtUKHQpO1xuICBpZiAobyA9PT0gMClcbiAgICByZXR1cm4gdDtcbiAgY29uc3QgYSA9IG5ldyBQcm94eShcbiAgICB0LFxuICAgIG8gPT09IDIgPyByIDogblxuICApO1xuICByZXR1cm4gaS5zZXQodCwgYSksIGE7XG59XG5mdW5jdGlvbiBZaSh0KSB7XG4gIHJldHVybiBhaSh0KSA/IFlpKHQuX192X3JhdykgOiAhISh0ICYmIHQuX192X2lzUmVhY3RpdmUpO1xufVxuZnVuY3Rpb24gYWkodCkge1xuICByZXR1cm4gISEodCAmJiB0Ll9fdl9pc1JlYWRvbmx5KTtcbn1cbmZ1bmN0aW9uIHppKHQpIHtcbiAgcmV0dXJuICEhKHQgJiYgdC5fX3ZfaXNTaGFsbG93KTtcbn1cbmZ1bmN0aW9uIEphKHQpIHtcbiAgcmV0dXJuIFlpKHQpIHx8IGFpKHQpO1xufVxuZnVuY3Rpb24gT2UodCkge1xuICBjb25zdCBlID0gdCAmJiB0Ll9fdl9yYXc7XG4gIHJldHVybiBlID8gT2UoZSkgOiB0O1xufVxuZnVuY3Rpb24gb08odCkge1xuICByZXR1cm4gT2JqZWN0LmlzRXh0ZW5zaWJsZSh0KSAmJiBidSh0LCBcIl9fdl9za2lwXCIsICEwKSwgdDtcbn1cbmNvbnN0IGVsID0gKHQpID0+IFplKHQpID8gWG4odCkgOiB0LCBhTyA9ICh0KSA9PiBaZSh0KSA/IHNPKHQpIDogdCwgeFQgPSBcIkNvbXB1dGVkIGlzIHN0aWxsIGRpcnR5IGFmdGVyIGdldHRlciBldmFsdWF0aW9uLCBsaWtlbHkgYmVjYXVzZSBhIGNvbXB1dGVkIGlzIG11dGF0aW5nIGl0cyBvd24gZGVwZW5kZW5jeSBpbiBpdHMgZ2V0dGVyLiBTdGF0ZSBtdXRhdGlvbnMgaW4gY29tcHV0ZWQgZ2V0dGVycyBzaG91bGQgYmUgYXZvaWRlZC4gIENoZWNrIHRoZSBkb2NzIGZvciBtb3JlIGRldGFpbHM6IGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2Vzc2VudGlhbHMvY29tcHV0ZWQuaHRtbCNnZXR0ZXJzLXNob3VsZC1iZS1zaWRlLWVmZmVjdC1mcmVlXCI7XG5jbGFzcyBXeSB7XG4gIGNvbnN0cnVjdG9yKGUsIG4sIHIsIGkpIHtcbiAgICB0aGlzLmdldHRlciA9IGUsIHRoaXMuX3NldHRlciA9IG4sIHRoaXMuZGVwID0gdm9pZCAwLCB0aGlzLl9fdl9pc1JlZiA9ICEwLCB0aGlzLl9fdl9pc1JlYWRvbmx5ID0gITEsIHRoaXMuZWZmZWN0ID0gbmV3IEFvKFxuICAgICAgKCkgPT4gZSh0aGlzLl92YWx1ZSksXG4gICAgICAoKSA9PiB2byhcbiAgICAgICAgdGhpcyxcbiAgICAgICAgdGhpcy5lZmZlY3QuX2RpcnR5TGV2ZWwgPT09IDIgPyAyIDogM1xuICAgICAgKVxuICAgICksIHRoaXMuZWZmZWN0LmNvbXB1dGVkID0gdGhpcywgdGhpcy5lZmZlY3QuYWN0aXZlID0gdGhpcy5fY2FjaGVhYmxlID0gIWksIHRoaXMuX192X2lzUmVhZG9ubHkgPSByO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICBjb25zdCBlID0gT2UodGhpcyk7XG4gICAgcmV0dXJuICghZS5fY2FjaGVhYmxlIHx8IGUuZWZmZWN0LmRpcnR5KSAmJiBncihlLl92YWx1ZSwgZS5fdmFsdWUgPSBlLmVmZmVjdC5ydW4oKSkgJiYgdm8oZSwgNCksIGxPKGUpLCBlLmVmZmVjdC5fZGlydHlMZXZlbCA+PSAyICYmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgdGhpcy5fd2FyblJlY3Vyc2l2ZSAmJiBNcih4VCwgYFxuXG5nZXR0ZXI6IGAsIHRoaXMuZ2V0dGVyKSwgdm8oZSwgMikpLCBlLl92YWx1ZTtcbiAgfVxuICBzZXQgdmFsdWUoZSkge1xuICAgIHRoaXMuX3NldHRlcihlKTtcbiAgfVxuICAvLyAjcmVnaW9uIHBvbHlmaWxsIF9kaXJ0eSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB0aGlyZCBwYXJ0eSBjb2RlIGZvciBWdWUgPD0gMy4zLnhcbiAgZ2V0IF9kaXJ0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5lZmZlY3QuZGlydHk7XG4gIH1cbiAgc2V0IF9kaXJ0eShlKSB7XG4gICAgdGhpcy5lZmZlY3QuZGlydHkgPSBlO1xuICB9XG4gIC8vICNlbmRyZWdpb25cbn1cbmZ1bmN0aW9uIFBUKHQsIGUsIG4gPSAhMSkge1xuICBsZXQgciwgaTtcbiAgY29uc3QgcyA9IGJlKHQpO1xuICBzID8gKHIgPSB0LCBpID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gKCkgPT4ge1xuICAgIE1yKFwiV3JpdGUgb3BlcmF0aW9uIGZhaWxlZDogY29tcHV0ZWQgdmFsdWUgaXMgcmVhZG9ubHlcIik7XG4gIH0gOiBpdCkgOiAociA9IHQuZ2V0LCBpID0gdC5zZXQpO1xuICBjb25zdCBvID0gbmV3IFd5KHIsIGksIHMgfHwgIWksIG4pO1xuICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGUgJiYgIW4gJiYgKG8uZWZmZWN0Lm9uVHJhY2sgPSBlLm9uVHJhY2ssIG8uZWZmZWN0Lm9uVHJpZ2dlciA9IGUub25UcmlnZ2VyKSwgbztcbn1cbmZ1bmN0aW9uIGxPKHQpIHtcbiAgdmFyIGU7XG4gIHFpICYmIEFzICYmICh0ID0gT2UodCksIF95KFxuICAgIEFzLFxuICAgIChlID0gdC5kZXApICE9IG51bGwgPyBlIDogdC5kZXAgPSBFeShcbiAgICAgICgpID0+IHQuZGVwID0gdm9pZCAwLFxuICAgICAgdCBpbnN0YW5jZW9mIFd5ID8gdCA6IHZvaWQgMFxuICAgICksXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8ge1xuICAgICAgdGFyZ2V0OiB0LFxuICAgICAgdHlwZTogXCJnZXRcIixcbiAgICAgIGtleTogXCJ2YWx1ZVwiXG4gICAgfSA6IHZvaWQgMFxuICApKTtcbn1cbmZ1bmN0aW9uIHZvKHQsIGUgPSA0LCBuKSB7XG4gIHQgPSBPZSh0KTtcbiAgY29uc3QgciA9IHQuZGVwO1xuICByICYmIFR5KFxuICAgIHIsXG4gICAgZSxcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB7XG4gICAgICB0YXJnZXQ6IHQsXG4gICAgICB0eXBlOiBcInNldFwiLFxuICAgICAga2V5OiBcInZhbHVlXCIsXG4gICAgICBuZXdWYWx1ZTogblxuICAgIH0gOiB2b2lkIDBcbiAgKTtcbn1cbmZ1bmN0aW9uIEN0KHQpIHtcbiAgcmV0dXJuICEhKHQgJiYgdC5fX3ZfaXNSZWYgPT09ICEwKTtcbn1cbmZ1bmN0aW9uIEcodCkge1xuICByZXR1cm4gTXkodCwgITEpO1xufVxuZnVuY3Rpb24gY08odCkge1xuICByZXR1cm4gTXkodCwgITApO1xufVxuZnVuY3Rpb24gTXkodCwgZSkge1xuICByZXR1cm4gQ3QodCkgPyB0IDogbmV3IF9UKHQsIGUpO1xufVxuY2xhc3MgX1Qge1xuICBjb25zdHJ1Y3RvcihlLCBuKSB7XG4gICAgdGhpcy5fX3ZfaXNTaGFsbG93ID0gbiwgdGhpcy5kZXAgPSB2b2lkIDAsIHRoaXMuX192X2lzUmVmID0gITAsIHRoaXMuX3Jhd1ZhbHVlID0gbiA/IGUgOiBPZShlKSwgdGhpcy5fdmFsdWUgPSBuID8gZSA6IGVsKGUpO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gbE8odGhpcyksIHRoaXMuX3ZhbHVlO1xuICB9XG4gIHNldCB2YWx1ZShlKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuX192X2lzU2hhbGxvdyB8fCB6aShlKSB8fCBhaShlKTtcbiAgICBlID0gbiA/IGUgOiBPZShlKSwgZ3IoZSwgdGhpcy5fcmF3VmFsdWUpICYmICh0aGlzLl9yYXdWYWx1ZSA9IGUsIHRoaXMuX3ZhbHVlID0gbiA/IGUgOiBlbChlKSwgdm8odGhpcywgNCwgZSkpO1xuICB9XG59XG5mdW5jdGlvbiBUVCh0KSB7XG4gIHZvKHQsIDQsIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHQudmFsdWUgOiB2b2lkIDApO1xufVxuZnVuY3Rpb24gUih0KSB7XG4gIHJldHVybiBDdCh0KSA/IHQudmFsdWUgOiB0O1xufVxuZnVuY3Rpb24gSnQodCkge1xuICByZXR1cm4gYmUodCkgPyB0KCkgOiBSKHQpO1xufVxuY29uc3QgRVQgPSB7XG4gIGdldDogKHQsIGUsIG4pID0+IFIoUmVmbGVjdC5nZXQodCwgZSwgbikpLFxuICBzZXQ6ICh0LCBlLCBuLCByKSA9PiB7XG4gICAgY29uc3QgaSA9IHRbZV07XG4gICAgcmV0dXJuIEN0KGkpICYmICFDdChuKSA/IChpLnZhbHVlID0gbiwgITApIDogUmVmbGVjdC5zZXQodCwgZSwgbiwgcik7XG4gIH1cbn07XG5mdW5jdGlvbiB1Tyh0KSB7XG4gIHJldHVybiBZaSh0KSA/IHQgOiBuZXcgUHJveHkodCwgRVQpO1xufVxuY2xhc3MgJFQge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5kZXAgPSB2b2lkIDAsIHRoaXMuX192X2lzUmVmID0gITA7XG4gICAgY29uc3QgeyBnZXQ6IG4sIHNldDogciB9ID0gZShcbiAgICAgICgpID0+IGxPKHRoaXMpLFxuICAgICAgKCkgPT4gdm8odGhpcylcbiAgICApO1xuICAgIHRoaXMuX2dldCA9IG4sIHRoaXMuX3NldCA9IHI7XG4gIH1cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXQoKTtcbiAgfVxuICBzZXQgdmFsdWUoZSkge1xuICAgIHRoaXMuX3NldChlKTtcbiAgfVxufVxuZnVuY3Rpb24gWHkodCkge1xuICByZXR1cm4gbmV3ICRUKHQpO1xufVxuZnVuY3Rpb24gUVQodCkge1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIUphKHQpICYmIE1yKFwidG9SZWZzKCkgZXhwZWN0cyBhIHJlYWN0aXZlIG9iamVjdCBidXQgcmVjZWl2ZWQgYSBwbGFpbiBvbmUuXCIpO1xuICBjb25zdCBlID0gaWUodCkgPyBuZXcgQXJyYXkodC5sZW5ndGgpIDoge307XG4gIGZvciAoY29uc3QgbiBpbiB0KVxuICAgIGVbbl0gPSBqeSh0LCBuKTtcbiAgcmV0dXJuIGU7XG59XG5jbGFzcyBDVCB7XG4gIGNvbnN0cnVjdG9yKGUsIG4sIHIpIHtcbiAgICB0aGlzLl9vYmplY3QgPSBlLCB0aGlzLl9rZXkgPSBuLCB0aGlzLl9kZWZhdWx0VmFsdWUgPSByLCB0aGlzLl9fdl9pc1JlZiA9ICEwO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fb2JqZWN0W3RoaXMuX2tleV07XG4gICAgcmV0dXJuIGUgPT09IHZvaWQgMCA/IHRoaXMuX2RlZmF1bHRWYWx1ZSA6IGU7XG4gIH1cbiAgc2V0IHZhbHVlKGUpIHtcbiAgICB0aGlzLl9vYmplY3RbdGhpcy5fa2V5XSA9IGU7XG4gIH1cbiAgZ2V0IGRlcCgpIHtcbiAgICByZXR1cm4gc1QoT2UodGhpcy5fb2JqZWN0KSwgdGhpcy5fa2V5KTtcbiAgfVxufVxuY2xhc3MgQVQge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5fZ2V0dGVyID0gZSwgdGhpcy5fX3ZfaXNSZWYgPSAhMCwgdGhpcy5fX3ZfaXNSZWFkb25seSA9ICEwO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0dGVyKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIEVpKHQsIGUsIG4pIHtcbiAgcmV0dXJuIEN0KHQpID8gdCA6IGJlKHQpID8gbmV3IEFUKHQpIDogWmUodCkgJiYgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBqeSh0LCBlLCBuKSA6IEcodCk7XG59XG5mdW5jdGlvbiBqeSh0LCBlLCBuKSB7XG4gIGNvbnN0IHIgPSB0W2VdO1xuICByZXR1cm4gQ3QocikgPyByIDogbmV3IENUKHQsIGUsIG4pO1xufVxuY29uc3QgUlQgPSB7XG4gIEdFVDogXCJnZXRcIixcbiAgSEFTOiBcImhhc1wiLFxuICBJVEVSQVRFOiBcIml0ZXJhdGVcIlxufSwgTlQgPSB7XG4gIFNFVDogXCJzZXRcIixcbiAgQUREOiBcImFkZFwiLFxuICBERUxFVEU6IFwiZGVsZXRlXCIsXG4gIENMRUFSOiBcImNsZWFyXCJcbn07XG4vKipcbiogQHZ1ZS9ydW50aW1lLWNvcmUgdjMuNC4yMVxuKiAoYykgMjAxOC1wcmVzZW50IFl1eGkgKEV2YW4pIFlvdSBhbmQgVnVlIGNvbnRyaWJ1dG9yc1xuKiBAbGljZW5zZSBNSVRcbioqL1xuY29uc3QgTnMgPSBbXTtcbmZ1bmN0aW9uIElhKHQpIHtcbiAgTnMucHVzaCh0KTtcbn1cbmZ1bmN0aW9uIFdhKCkge1xuICBOcy5wb3AoKTtcbn1cbmZ1bmN0aW9uIEkodCwgLi4uZSkge1xuICBkcygpO1xuICBjb25zdCBuID0gTnMubGVuZ3RoID8gTnNbTnMubGVuZ3RoIC0gMV0uY29tcG9uZW50IDogbnVsbCwgciA9IG4gJiYgbi5hcHBDb250ZXh0LmNvbmZpZy53YXJuSGFuZGxlciwgaSA9IERUKCk7XG4gIGlmIChyKVxuICAgIFZyKFxuICAgICAgcixcbiAgICAgIG4sXG4gICAgICAxMSxcbiAgICAgIFtcbiAgICAgICAgdCArIGUubWFwKChzKSA9PiB7XG4gICAgICAgICAgdmFyIG8sIGE7XG4gICAgICAgICAgcmV0dXJuIChhID0gKG8gPSBzLnRvU3RyaW5nKSA9PSBudWxsID8gdm9pZCAwIDogby5jYWxsKHMpKSAhPSBudWxsID8gYSA6IEpTT04uc3RyaW5naWZ5KHMpO1xuICAgICAgICB9KS5qb2luKFwiXCIpLFxuICAgICAgICBuICYmIG4ucHJveHksXG4gICAgICAgIGkubWFwKFxuICAgICAgICAgICh7IHZub2RlOiBzIH0pID0+IGBhdCA8JHtUZChuLCBzLnR5cGUpfT5gXG4gICAgICAgICkuam9pbihgXG5gKSxcbiAgICAgICAgaVxuICAgICAgXVxuICAgICk7XG4gIGVsc2Uge1xuICAgIGNvbnN0IHMgPSBbYFtWdWUgd2Fybl06ICR7dH1gLCAuLi5lXTtcbiAgICBpLmxlbmd0aCAmJiBzLnB1c2goYFxuYCwgLi4uWlQoaSkpLCBjb25zb2xlLndhcm4oLi4ucyk7XG4gIH1cbiAgZnMoKTtcbn1cbmZ1bmN0aW9uIERUKCkge1xuICBsZXQgdCA9IE5zW05zLmxlbmd0aCAtIDFdO1xuICBpZiAoIXQpXG4gICAgcmV0dXJuIFtdO1xuICBjb25zdCBlID0gW107XG4gIGZvciAoOyB0OyApIHtcbiAgICBjb25zdCBuID0gZVswXTtcbiAgICBuICYmIG4udm5vZGUgPT09IHQgPyBuLnJlY3Vyc2VDb3VudCsrIDogZS5wdXNoKHtcbiAgICAgIHZub2RlOiB0LFxuICAgICAgcmVjdXJzZUNvdW50OiAwXG4gICAgfSk7XG4gICAgY29uc3QgciA9IHQuY29tcG9uZW50ICYmIHQuY29tcG9uZW50LnBhcmVudDtcbiAgICB0ID0gciAmJiByLnZub2RlO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gWlQodCkge1xuICBjb25zdCBlID0gW107XG4gIHJldHVybiB0LmZvckVhY2goKG4sIHIpID0+IHtcbiAgICBlLnB1c2goLi4uciA9PT0gMCA/IFtdIDogW2BcbmBdLCAuLi5WVChuKSk7XG4gIH0pLCBlO1xufVxuZnVuY3Rpb24gVlQoeyB2bm9kZTogdCwgcmVjdXJzZUNvdW50OiBlIH0pIHtcbiAgY29uc3QgbiA9IGUgPiAwID8gYC4uLiAoJHtlfSByZWN1cnNpdmUgY2FsbHMpYCA6IFwiXCIsIHIgPSB0LmNvbXBvbmVudCA/IHQuY29tcG9uZW50LnBhcmVudCA9PSBudWxsIDogITEsIGkgPSBgIGF0IDwke1RkKFxuICAgIHQuY29tcG9uZW50LFxuICAgIHQudHlwZSxcbiAgICByXG4gICl9YCwgcyA9IFwiPlwiICsgbjtcbiAgcmV0dXJuIHQucHJvcHMgPyBbaSwgLi4uSVQodC5wcm9wcyksIHNdIDogW2kgKyBzXTtcbn1cbmZ1bmN0aW9uIElUKHQpIHtcbiAgY29uc3QgZSA9IFtdLCBuID0gT2JqZWN0LmtleXModCk7XG4gIHJldHVybiBuLnNsaWNlKDAsIDMpLmZvckVhY2goKHIpID0+IHtcbiAgICBlLnB1c2goLi4uQnkociwgdFtyXSkpO1xuICB9KSwgbi5sZW5ndGggPiAzICYmIGUucHVzaChcIiAuLi5cIiksIGU7XG59XG5mdW5jdGlvbiBCeSh0LCBlLCBuKSB7XG4gIHJldHVybiB3ZShlKSA/IChlID0gSlNPTi5zdHJpbmdpZnkoZSksIG4gPyBlIDogW2Ake3R9PSR7ZX1gXSkgOiB0eXBlb2YgZSA9PSBcIm51bWJlclwiIHx8IHR5cGVvZiBlID09IFwiYm9vbGVhblwiIHx8IGUgPT0gbnVsbCA/IG4gPyBlIDogW2Ake3R9PSR7ZX1gXSA6IEN0KGUpID8gKGUgPSBCeSh0LCBPZShlLnZhbHVlKSwgITApLCBuID8gZSA6IFtgJHt0fT1SZWY8YCwgZSwgXCI+XCJdKSA6IGJlKGUpID8gW2Ake3R9PWZuJHtlLm5hbWUgPyBgPCR7ZS5uYW1lfT5gIDogXCJcIn1gXSA6IChlID0gT2UoZSksIG4gPyBlIDogW2Ake3R9PWAsIGVdKTtcbn1cbmZ1bmN0aW9uIGRPKHQsIGUpIHtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHQgIT09IHZvaWQgMCAmJiAodHlwZW9mIHQgIT0gXCJudW1iZXJcIiA/IEkoYCR7ZX0gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gZ290ICR7SlNPTi5zdHJpbmdpZnkodCl9LmApIDogaXNOYU4odCkgJiYgSShgJHtlfSBpcyBOYU4gLSB0aGUgZHVyYXRpb24gZXhwcmVzc2lvbiBtaWdodCBiZSBpbmNvcnJlY3QuYCkpO1xufVxuY29uc3QgV1QgPSB7XG4gIFNFVFVQX0ZVTkNUSU9OOiAwLFxuICAwOiBcIlNFVFVQX0ZVTkNUSU9OXCIsXG4gIFJFTkRFUl9GVU5DVElPTjogMSxcbiAgMTogXCJSRU5ERVJfRlVOQ1RJT05cIixcbiAgV0FUQ0hfR0VUVEVSOiAyLFxuICAyOiBcIldBVENIX0dFVFRFUlwiLFxuICBXQVRDSF9DQUxMQkFDSzogMyxcbiAgMzogXCJXQVRDSF9DQUxMQkFDS1wiLFxuICBXQVRDSF9DTEVBTlVQOiA0LFxuICA0OiBcIldBVENIX0NMRUFOVVBcIixcbiAgTkFUSVZFX0VWRU5UX0hBTkRMRVI6IDUsXG4gIDU6IFwiTkFUSVZFX0VWRU5UX0hBTkRMRVJcIixcbiAgQ09NUE9ORU5UX0VWRU5UX0hBTkRMRVI6IDYsXG4gIDY6IFwiQ09NUE9ORU5UX0VWRU5UX0hBTkRMRVJcIixcbiAgVk5PREVfSE9PSzogNyxcbiAgNzogXCJWTk9ERV9IT09LXCIsXG4gIERJUkVDVElWRV9IT09LOiA4LFxuICA4OiBcIkRJUkVDVElWRV9IT09LXCIsXG4gIFRSQU5TSVRJT05fSE9PSzogOSxcbiAgOTogXCJUUkFOU0lUSU9OX0hPT0tcIixcbiAgQVBQX0VSUk9SX0hBTkRMRVI6IDEwLFxuICAxMDogXCJBUFBfRVJST1JfSEFORExFUlwiLFxuICBBUFBfV0FSTl9IQU5ETEVSOiAxMSxcbiAgMTE6IFwiQVBQX1dBUk5fSEFORExFUlwiLFxuICBGVU5DVElPTl9SRUY6IDEyLFxuICAxMjogXCJGVU5DVElPTl9SRUZcIixcbiAgQVNZTkNfQ09NUE9ORU5UX0xPQURFUjogMTMsXG4gIDEzOiBcIkFTWU5DX0NPTVBPTkVOVF9MT0FERVJcIixcbiAgU0NIRURVTEVSOiAxNCxcbiAgMTQ6IFwiU0NIRURVTEVSXCJcbn0sIG1kID0ge1xuICBzcDogXCJzZXJ2ZXJQcmVmZXRjaCBob29rXCIsXG4gIGJjOiBcImJlZm9yZUNyZWF0ZSBob29rXCIsXG4gIGM6IFwiY3JlYXRlZCBob29rXCIsXG4gIGJtOiBcImJlZm9yZU1vdW50IGhvb2tcIixcbiAgbTogXCJtb3VudGVkIGhvb2tcIixcbiAgYnU6IFwiYmVmb3JlVXBkYXRlIGhvb2tcIixcbiAgdTogXCJ1cGRhdGVkXCIsXG4gIGJ1bTogXCJiZWZvcmVVbm1vdW50IGhvb2tcIixcbiAgdW06IFwidW5tb3VudGVkIGhvb2tcIixcbiAgYTogXCJhY3RpdmF0ZWQgaG9va1wiLFxuICBkYTogXCJkZWFjdGl2YXRlZCBob29rXCIsXG4gIGVjOiBcImVycm9yQ2FwdHVyZWQgaG9va1wiLFxuICBydGM6IFwicmVuZGVyVHJhY2tlZCBob29rXCIsXG4gIHJ0ZzogXCJyZW5kZXJUcmlnZ2VyZWQgaG9va1wiLFxuICAwOiBcInNldHVwIGZ1bmN0aW9uXCIsXG4gIDE6IFwicmVuZGVyIGZ1bmN0aW9uXCIsXG4gIDI6IFwid2F0Y2hlciBnZXR0ZXJcIixcbiAgMzogXCJ3YXRjaGVyIGNhbGxiYWNrXCIsXG4gIDQ6IFwid2F0Y2hlciBjbGVhbnVwIGZ1bmN0aW9uXCIsXG4gIDU6IFwibmF0aXZlIGV2ZW50IGhhbmRsZXJcIixcbiAgNjogXCJjb21wb25lbnQgZXZlbnQgaGFuZGxlclwiLFxuICA3OiBcInZub2RlIGhvb2tcIixcbiAgODogXCJkaXJlY3RpdmUgaG9va1wiLFxuICA5OiBcInRyYW5zaXRpb24gaG9va1wiLFxuICAxMDogXCJhcHAgZXJyb3JIYW5kbGVyXCIsXG4gIDExOiBcImFwcCB3YXJuSGFuZGxlclwiLFxuICAxMjogXCJyZWYgZnVuY3Rpb25cIixcbiAgMTM6IFwiYXN5bmMgY29tcG9uZW50IGxvYWRlclwiLFxuICAxNDogXCJzY2hlZHVsZXIgZmx1c2guIFRoaXMgaXMgbGlrZWx5IGEgVnVlIGludGVybmFscyBidWcuIFBsZWFzZSBvcGVuIGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS92dWVqcy9jb3JlIC5cIlxufTtcbmZ1bmN0aW9uIFZyKHQsIGUsIG4sIHIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gciA/IHQoLi4ucikgOiB0KCk7XG4gIH0gY2F0Y2ggKGkpIHtcbiAgICBocyhpLCBlLCBuKTtcbiAgfVxufVxuZnVuY3Rpb24gV24odCwgZSwgbiwgcikge1xuICBpZiAoYmUodCkpIHtcbiAgICBjb25zdCBzID0gVnIodCwgZSwgbiwgcik7XG4gICAgcmV0dXJuIHMgJiYgZGQocykgJiYgcy5jYXRjaCgobykgPT4ge1xuICAgICAgaHMobywgZSwgbik7XG4gICAgfSksIHM7XG4gIH1cbiAgY29uc3QgaSA9IFtdO1xuICBmb3IgKGxldCBzID0gMDsgcyA8IHQubGVuZ3RoOyBzKyspXG4gICAgaS5wdXNoKFduKHRbc10sIGUsIG4sIHIpKTtcbiAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiBocyh0LCBlLCBuLCByID0gITApIHtcbiAgY29uc3QgaSA9IGUgPyBlLnZub2RlIDogbnVsbDtcbiAgaWYgKGUpIHtcbiAgICBsZXQgcyA9IGUucGFyZW50O1xuICAgIGNvbnN0IG8gPSBlLnByb3h5LCBhID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gbWRbbl0gOiBgaHR0cHM6Ly92dWVqcy5vcmcvZXJyb3ItcmVmZXJlbmNlLyNydW50aW1lLSR7bn1gO1xuICAgIGZvciAoOyBzOyApIHtcbiAgICAgIGNvbnN0IGMgPSBzLmVjO1xuICAgICAgaWYgKGMpIHtcbiAgICAgICAgZm9yIChsZXQgdSA9IDA7IHUgPCBjLmxlbmd0aDsgdSsrKVxuICAgICAgICAgIGlmIChjW3VdKHQsIG8sIGEpID09PSAhMSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHMgPSBzLnBhcmVudDtcbiAgICB9XG4gICAgY29uc3QgbCA9IGUuYXBwQ29udGV4dC5jb25maWcuZXJyb3JIYW5kbGVyO1xuICAgIGlmIChsKSB7XG4gICAgICBWcihcbiAgICAgICAgbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgMTAsXG4gICAgICAgIFt0LCBvLCBhXVxuICAgICAgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgTVQodCwgbiwgaSwgcik7XG59XG5mdW5jdGlvbiBNVCh0LCBlLCBuLCByID0gITApIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnN0IGkgPSBtZFtlXTtcbiAgICBpZiAobiAmJiBJYShuKSwgSShgVW5oYW5kbGVkIGVycm9yJHtpID8gYCBkdXJpbmcgZXhlY3V0aW9uIG9mICR7aX1gIDogXCJcIn1gKSwgbiAmJiBXYSgpLCByKVxuICAgICAgdGhyb3cgdDtcbiAgICBjb25zb2xlLmVycm9yKHQpO1xuICB9IGVsc2VcbiAgICBjb25zb2xlLmVycm9yKHQpO1xufVxubGV0IHRsID0gITEsIGxoID0gITE7XG5jb25zdCBzbiA9IFtdO1xubGV0ICRyID0gMDtcbmNvbnN0IHlvID0gW107XG5sZXQgZWkgPSBudWxsLCBRaSA9IDA7XG5jb25zdCBMeSA9IC8qIEBfX1BVUkVfXyAqLyBQcm9taXNlLnJlc29sdmUoKTtcbmxldCBmTyA9IG51bGw7XG5jb25zdCBYVCA9IDEwMDtcbmZ1bmN0aW9uIFBuKHQpIHtcbiAgY29uc3QgZSA9IGZPIHx8IEx5O1xuICByZXR1cm4gdCA/IGUudGhlbih0aGlzID8gdC5iaW5kKHRoaXMpIDogdCkgOiBlO1xufVxuZnVuY3Rpb24galQodCkge1xuICBsZXQgZSA9ICRyICsgMSwgbiA9IHNuLmxlbmd0aDtcbiAgZm9yICg7IGUgPCBuOyApIHtcbiAgICBjb25zdCByID0gZSArIG4gPj4+IDEsIGkgPSBzbltyXSwgcyA9IHJsKGkpO1xuICAgIHMgPCB0IHx8IHMgPT09IHQgJiYgaS5wcmUgPyBlID0gciArIDEgOiBuID0gcjtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIE5sKHQpIHtcbiAgKCFzbi5sZW5ndGggfHwgIXNuLmluY2x1ZGVzKFxuICAgIHQsXG4gICAgdGwgJiYgdC5hbGxvd1JlY3Vyc2UgPyAkciArIDEgOiAkclxuICApKSAmJiAodC5pZCA9PSBudWxsID8gc24ucHVzaCh0KSA6IHNuLnNwbGljZShqVCh0LmlkKSwgMCwgdCksIFV5KCkpO1xufVxuZnVuY3Rpb24gVXkoKSB7XG4gICF0bCAmJiAhbGggJiYgKGxoID0gITAsIGZPID0gTHkudGhlbihxeSkpO1xufVxuZnVuY3Rpb24gQlQodCkge1xuICBjb25zdCBlID0gc24uaW5kZXhPZih0KTtcbiAgZSA+ICRyICYmIHNuLnNwbGljZShlLCAxKTtcbn1cbmZ1bmN0aW9uIG5sKHQpIHtcbiAgaWUodCkgPyB5by5wdXNoKC4uLnQpIDogKCFlaSB8fCAhZWkuaW5jbHVkZXMoXG4gICAgdCxcbiAgICB0LmFsbG93UmVjdXJzZSA/IFFpICsgMSA6IFFpXG4gICkpICYmIHlvLnB1c2godCksIFV5KCk7XG59XG5mdW5jdGlvbiBtbSh0LCBlLCBuID0gdGwgPyAkciArIDEgOiAwKSB7XG4gIGZvciAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChlID0gZSB8fCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTsgbiA8IHNuLmxlbmd0aDsgbisrKSB7XG4gICAgY29uc3QgciA9IHNuW25dO1xuICAgIGlmIChyICYmIHIucHJlKSB7XG4gICAgICBpZiAodCAmJiByLmlkICE9PSB0LnVpZCB8fCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgaE8oZSwgcikpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgc24uc3BsaWNlKG4sIDEpLCBuLS0sIHIoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIFN1KHQpIHtcbiAgaWYgKHlvLmxlbmd0aCkge1xuICAgIGNvbnN0IGUgPSBbLi4ubmV3IFNldCh5byldLnNvcnQoXG4gICAgICAobiwgcikgPT4gcmwobikgLSBybChyKVxuICAgICk7XG4gICAgaWYgKHlvLmxlbmd0aCA9IDAsIGVpKSB7XG4gICAgICBlaS5wdXNoKC4uLmUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGVpID0gZSwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICh0ID0gdCB8fCAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKSwgUWkgPSAwOyBRaSA8IGVpLmxlbmd0aDsgUWkrKylcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBoTyh0LCBlaVtRaV0pIHx8IGVpW1FpXSgpO1xuICAgIGVpID0gbnVsbCwgUWkgPSAwO1xuICB9XG59XG5jb25zdCBybCA9ICh0KSA9PiB0LmlkID09IG51bGwgPyAxIC8gMCA6IHQuaWQsIExUID0gKHQsIGUpID0+IHtcbiAgY29uc3QgbiA9IHJsKHQpIC0gcmwoZSk7XG4gIGlmIChuID09PSAwKSB7XG4gICAgaWYgKHQucHJlICYmICFlLnByZSlcbiAgICAgIHJldHVybiAtMTtcbiAgICBpZiAoZS5wcmUgJiYgIXQucHJlKVxuICAgICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIG47XG59O1xuZnVuY3Rpb24gcXkodCkge1xuICBsaCA9ICExLCB0bCA9ICEwLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKHQgPSB0IHx8IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpLCBzbi5zb3J0KExUKTtcbiAgY29uc3QgZSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IChuKSA9PiBoTyh0LCBuKSA6IGl0O1xuICB0cnkge1xuICAgIGZvciAoJHIgPSAwOyAkciA8IHNuLmxlbmd0aDsgJHIrKykge1xuICAgICAgY29uc3QgbiA9IHNuWyRyXTtcbiAgICAgIGlmIChuICYmIG4uYWN0aXZlICE9PSAhMSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGUobikpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIFZyKG4sIG51bGwsIDE0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgJHIgPSAwLCBzbi5sZW5ndGggPSAwLCBTdSh0KSwgdGwgPSAhMSwgZk8gPSBudWxsLCAoc24ubGVuZ3RoIHx8IHlvLmxlbmd0aCkgJiYgcXkodCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGhPKHQsIGUpIHtcbiAgaWYgKCF0LmhhcyhlKSlcbiAgICB0LnNldChlLCAxKTtcbiAgZWxzZSB7XG4gICAgY29uc3QgbiA9IHQuZ2V0KGUpO1xuICAgIGlmIChuID4gWFQpIHtcbiAgICAgIGNvbnN0IHIgPSBlLm93bmVySW5zdGFuY2UsIGkgPSByICYmIGFsKHIudHlwZSk7XG4gICAgICByZXR1cm4gaHMoXG4gICAgICAgIGBNYXhpbXVtIHJlY3Vyc2l2ZSB1cGRhdGVzIGV4Y2VlZGVkJHtpID8gYCBpbiBjb21wb25lbnQgPCR7aX0+YCA6IFwiXCJ9LiBUaGlzIG1lYW5zIHlvdSBoYXZlIGEgcmVhY3RpdmUgZWZmZWN0IHRoYXQgaXMgbXV0YXRpbmcgaXRzIG93biBkZXBlbmRlbmNpZXMgYW5kIHRodXMgcmVjdXJzaXZlbHkgdHJpZ2dlcmluZyBpdHNlbGYuIFBvc3NpYmxlIHNvdXJjZXMgaW5jbHVkZSBjb21wb25lbnQgdGVtcGxhdGUsIHJlbmRlciBmdW5jdGlvbiwgdXBkYXRlZCBob29rIG9yIHdhdGNoZXIgc291cmNlIGZ1bmN0aW9uLmAsXG4gICAgICAgIG51bGwsXG4gICAgICAgIDEwXG4gICAgICApLCAhMDtcbiAgICB9IGVsc2VcbiAgICAgIHQuc2V0KGUsIG4gKyAxKTtcbiAgfVxufVxubGV0IEhpID0gITE7XG5jb25zdCB1byA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKGJvKCkuX19WVUVfSE1SX1JVTlRJTUVfXyA9IHtcbiAgY3JlYXRlUmVjb3JkOiBvZihZeSksXG4gIHJlcmVuZGVyOiBvZihZVCksXG4gIHJlbG9hZDogb2YoelQpXG59KTtcbmNvbnN0IE1zID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmZ1bmN0aW9uIFVUKHQpIHtcbiAgY29uc3QgZSA9IHQudHlwZS5fX2htcklkO1xuICBsZXQgbiA9IE1zLmdldChlKTtcbiAgbiB8fCAoWXkoZSwgdC50eXBlKSwgbiA9IE1zLmdldChlKSksIG4uaW5zdGFuY2VzLmFkZCh0KTtcbn1cbmZ1bmN0aW9uIHFUKHQpIHtcbiAgTXMuZ2V0KHQudHlwZS5fX2htcklkKS5pbnN0YW5jZXMuZGVsZXRlKHQpO1xufVxuZnVuY3Rpb24gWXkodCwgZSkge1xuICByZXR1cm4gTXMuaGFzKHQpID8gITEgOiAoTXMuc2V0KHQsIHtcbiAgICBpbml0aWFsRGVmOiBNYShlKSxcbiAgICBpbnN0YW5jZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KClcbiAgfSksICEwKTtcbn1cbmZ1bmN0aW9uIE1hKHQpIHtcbiAgcmV0dXJuIEIxKHQpID8gdC5fX3ZjY09wdHMgOiB0O1xufVxuZnVuY3Rpb24gWVQodCwgZSkge1xuICBjb25zdCBuID0gTXMuZ2V0KHQpO1xuICBuICYmIChuLmluaXRpYWxEZWYucmVuZGVyID0gZSwgWy4uLm4uaW5zdGFuY2VzXS5mb3JFYWNoKChyKSA9PiB7XG4gICAgZSAmJiAoci5yZW5kZXIgPSBlLCBNYShyLnR5cGUpLnJlbmRlciA9IGUpLCByLnJlbmRlckNhY2hlID0gW10sIEhpID0gITAsIHIuZWZmZWN0LmRpcnR5ID0gITAsIHIudXBkYXRlKCksIEhpID0gITE7XG4gIH0pKTtcbn1cbmZ1bmN0aW9uIHpUKHQsIGUpIHtcbiAgY29uc3QgbiA9IE1zLmdldCh0KTtcbiAgaWYgKCFuKVxuICAgIHJldHVybjtcbiAgZSA9IE1hKGUpLCBibShuLmluaXRpYWxEZWYsIGUpO1xuICBjb25zdCByID0gWy4uLm4uaW5zdGFuY2VzXTtcbiAgZm9yIChjb25zdCBpIG9mIHIpIHtcbiAgICBjb25zdCBzID0gTWEoaS50eXBlKTtcbiAgICB1by5oYXMocykgfHwgKHMgIT09IG4uaW5pdGlhbERlZiAmJiBibShzLCBlKSwgdW8uYWRkKHMpKSwgaS5hcHBDb250ZXh0LnByb3BzQ2FjaGUuZGVsZXRlKGkudHlwZSksIGkuYXBwQ29udGV4dC5lbWl0c0NhY2hlLmRlbGV0ZShpLnR5cGUpLCBpLmFwcENvbnRleHQub3B0aW9uc0NhY2hlLmRlbGV0ZShpLnR5cGUpLCBpLmNlUmVsb2FkID8gKHVvLmFkZChzKSwgaS5jZVJlbG9hZChlLnN0eWxlcyksIHVvLmRlbGV0ZShzKSkgOiBpLnBhcmVudCA/IChpLnBhcmVudC5lZmZlY3QuZGlydHkgPSAhMCwgTmwoaS5wYXJlbnQudXBkYXRlKSkgOiBpLmFwcENvbnRleHQucmVsb2FkID8gaS5hcHBDb250ZXh0LnJlbG9hZCgpIDogdHlwZW9mIHdpbmRvdyA8IFwidVwiID8gd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpIDogY29uc29sZS53YXJuKFxuICAgICAgXCJbSE1SXSBSb290IG9yIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UgbW9kaWZpZWQuIEZ1bGwgcmVsb2FkIHJlcXVpcmVkLlwiXG4gICAgKTtcbiAgfVxuICBubCgoKSA9PiB7XG4gICAgZm9yIChjb25zdCBpIG9mIHIpXG4gICAgICB1by5kZWxldGUoXG4gICAgICAgIE1hKGkudHlwZSlcbiAgICAgICk7XG4gIH0pO1xufVxuZnVuY3Rpb24gYm0odCwgZSkge1xuICAkZSh0LCBlKTtcbiAgZm9yIChjb25zdCBuIGluIHQpXG4gICAgbiAhPT0gXCJfX2ZpbGVcIiAmJiAhKG4gaW4gZSkgJiYgZGVsZXRlIHRbbl07XG59XG5mdW5jdGlvbiBvZih0KSB7XG4gIHJldHVybiAoZSwgbikgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdChlLCBuKTtcbiAgICB9IGNhdGNoIChyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKHIpLCBjb25zb2xlLndhcm4oXG4gICAgICAgIFwiW0hNUl0gU29tZXRoaW5nIHdlbnQgd3JvbmcgZHVyaW5nIFZ1ZSBjb21wb25lbnQgaG90LXJlbG9hZC4gRnVsbCByZWxvYWQgcmVxdWlyZWQuXCJcbiAgICAgICk7XG4gICAgfVxuICB9O1xufVxubGV0IGFyLCAkYSA9IFtdLCBjaCA9ICExO1xuZnVuY3Rpb24gRGwodCwgLi4uZSkge1xuICBhciA/IGFyLmVtaXQodCwgLi4uZSkgOiBjaCB8fCAkYS5wdXNoKHsgZXZlbnQ6IHQsIGFyZ3M6IGUgfSk7XG59XG5mdW5jdGlvbiBwTyh0LCBlKSB7XG4gIHZhciBuLCByO1xuICBhciA9IHQsIGFyID8gKGFyLmVuYWJsZWQgPSAhMCwgJGEuZm9yRWFjaCgoeyBldmVudDogaSwgYXJnczogcyB9KSA9PiBhci5lbWl0KGksIC4uLnMpKSwgJGEgPSBbXSkgOiAvKiBoYW5kbGUgbGF0ZSBkZXZ0b29scyBpbmplY3Rpb24gLSBvbmx5IGRvIHRoaXMgaWYgd2UgYXJlIGluIGFuIGFjdHVhbCAqLyAvKiBicm93c2VyIGVudmlyb25tZW50IHRvIGF2b2lkIHRoZSB0aW1lciBoYW5kbGUgc3RhbGxpbmcgdGVzdCBydW5uZXIgZXhpdCAqLyAvKiAoIzQ4MTUpICovIHR5cGVvZiB3aW5kb3cgPCBcInVcIiAmJiAvLyBzb21lIGVudnMgbW9jayB3aW5kb3cgYnV0IG5vdCBmdWxseVxuICB3aW5kb3cuSFRNTEVsZW1lbnQgJiYgLy8gYWxzbyBleGNsdWRlIGpzZG9tXG4gICEoKHIgPSAobiA9IHdpbmRvdy5uYXZpZ2F0b3IpID09IG51bGwgPyB2b2lkIDAgOiBuLnVzZXJBZ2VudCkgIT0gbnVsbCAmJiByLmluY2x1ZGVzKFwianNkb21cIikpID8gKChlLl9fVlVFX0RFVlRPT0xTX0hPT0tfUkVQTEFZX18gPSBlLl9fVlVFX0RFVlRPT0xTX0hPT0tfUkVQTEFZX18gfHwgW10pLnB1c2goKHMpID0+IHtcbiAgICBwTyhzLCBlKTtcbiAgfSksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIGFyIHx8IChlLl9fVlVFX0RFVlRPT0xTX0hPT0tfUkVQTEFZX18gPSBudWxsLCBjaCA9ICEwLCAkYSA9IFtdKTtcbiAgfSwgM2UzKSkgOiAoY2ggPSAhMCwgJGEgPSBbXSk7XG59XG5mdW5jdGlvbiBIVCh0LCBlKSB7XG4gIERsKFwiYXBwOmluaXRcIiwgdCwgZSwge1xuICAgIEZyYWdtZW50OiBQZSxcbiAgICBUZXh0OiBucyxcbiAgICBDb21tZW50OiBfdCxcbiAgICBTdGF0aWM6IEZpXG4gIH0pO1xufVxuZnVuY3Rpb24gRlQodCkge1xuICBEbChcImFwcDp1bm1vdW50XCIsIHQpO1xufVxuY29uc3QgdWggPSAvKiBAX19QVVJFX18gKi8gT08oXG4gIFwiY29tcG9uZW50OmFkZGVkXCJcbiAgLyogQ09NUE9ORU5UX0FEREVEICovXG4pLCB6eSA9IC8qIEBfX1BVUkVfXyAqLyBPTyhcbiAgXCJjb21wb25lbnQ6dXBkYXRlZFwiXG4gIC8qIENPTVBPTkVOVF9VUERBVEVEICovXG4pLCBHVCA9IC8qIEBfX1BVUkVfXyAqLyBPTyhcbiAgXCJjb21wb25lbnQ6cmVtb3ZlZFwiXG4gIC8qIENPTVBPTkVOVF9SRU1PVkVEICovXG4pLCBLVCA9ICh0KSA9PiB7XG4gIGFyICYmIHR5cGVvZiBhci5jbGVhbnVwQnVmZmVyID09IFwiZnVuY3Rpb25cIiAmJiAvLyByZW1vdmUgdGhlIGNvbXBvbmVudCBpZiBpdCB3YXNuJ3QgYnVmZmVyZWRcbiAgIWFyLmNsZWFudXBCdWZmZXIodCkgJiYgR1QodCk7XG59O1xuZnVuY3Rpb24gT08odCkge1xuICByZXR1cm4gKGUpID0+IHtcbiAgICBEbChcbiAgICAgIHQsXG4gICAgICBlLmFwcENvbnRleHQuYXBwLFxuICAgICAgZS51aWQsXG4gICAgICBlLnBhcmVudCA/IGUucGFyZW50LnVpZCA6IHZvaWQgMCxcbiAgICAgIGVcbiAgICApO1xuICB9O1xufVxuY29uc3QgSlQgPSAvKiBAX19QVVJFX18gKi8gSHkoXG4gIFwicGVyZjpzdGFydFwiXG4gIC8qIFBFUkZPUk1BTkNFX1NUQVJUICovXG4pLCBlRSA9IC8qIEBfX1BVUkVfXyAqLyBIeShcbiAgXCJwZXJmOmVuZFwiXG4gIC8qIFBFUkZPUk1BTkNFX0VORCAqL1xuKTtcbmZ1bmN0aW9uIEh5KHQpIHtcbiAgcmV0dXJuIChlLCBuLCByKSA9PiB7XG4gICAgRGwodCwgZS5hcHBDb250ZXh0LmFwcCwgZS51aWQsIGUsIG4sIHIpO1xuICB9O1xufVxuZnVuY3Rpb24gdEUodCwgZSwgbikge1xuICBEbChcbiAgICBcImNvbXBvbmVudDplbWl0XCIsXG4gICAgdC5hcHBDb250ZXh0LmFwcCxcbiAgICB0LFxuICAgIGUsXG4gICAgblxuICApO1xufVxuZnVuY3Rpb24gbkUodCwgZSwgLi4ubikge1xuICBpZiAodC5pc1VubW91bnRlZClcbiAgICByZXR1cm47XG4gIGNvbnN0IHIgPSB0LnZub2RlLnByb3BzIHx8IFZlO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc3Qge1xuICAgICAgZW1pdHNPcHRpb25zOiB1LFxuICAgICAgcHJvcHNPcHRpb25zOiBbZF1cbiAgICB9ID0gdDtcbiAgICBpZiAodSlcbiAgICAgIGlmICghKGUgaW4gdSkpXG4gICAgICAgICghZCB8fCAhKFRyKGUpIGluIGQpKSAmJiBJKFxuICAgICAgICAgIGBDb21wb25lbnQgZW1pdHRlZCBldmVudCBcIiR7ZX1cIiBidXQgaXQgaXMgbmVpdGhlciBkZWNsYXJlZCBpbiB0aGUgZW1pdHMgb3B0aW9uIG5vciBhcyBhbiBcIiR7VHIoZSl9XCIgcHJvcC5gXG4gICAgICAgICk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgZiA9IHVbZV07XG4gICAgICAgIGJlKGYpICYmIChmKC4uLm4pIHx8IEkoXG4gICAgICAgICAgYEludmFsaWQgZXZlbnQgYXJndW1lbnRzOiBldmVudCB2YWxpZGF0aW9uIGZhaWxlZCBmb3IgZXZlbnQgXCIke2V9XCIuYFxuICAgICAgICApKTtcbiAgICAgIH1cbiAgfVxuICBsZXQgaSA9IG47XG4gIGNvbnN0IHMgPSBlLnN0YXJ0c1dpdGgoXCJ1cGRhdGU6XCIpLCBvID0gcyAmJiBlLnNsaWNlKDcpO1xuICBpZiAobyAmJiBvIGluIHIpIHtcbiAgICBjb25zdCB1ID0gYCR7byA9PT0gXCJtb2RlbFZhbHVlXCIgPyBcIm1vZGVsXCIgOiBvfU1vZGlmaWVyc2AsIHsgbnVtYmVyOiBkLCB0cmltOiBmIH0gPSByW3VdIHx8IFZlO1xuICAgIGYgJiYgKGkgPSBuLm1hcCgoaCkgPT4gd2UoaCkgPyBoLnRyaW0oKSA6IGgpKSwgZCAmJiAoaSA9IG4ubWFwKEthKSk7XG4gIH1cbiAgaWYgKChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSAmJiB0RSh0LCBlLCBpKSwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc3QgdSA9IGUudG9Mb3dlckNhc2UoKTtcbiAgICB1ICE9PSBlICYmIHJbVHIodSldICYmIEkoXG4gICAgICBgRXZlbnQgXCIke3V9XCIgaXMgZW1pdHRlZCBpbiBjb21wb25lbnQgJHtUZChcbiAgICAgICAgdCxcbiAgICAgICAgdC50eXBlXG4gICAgICApfSBidXQgdGhlIGhhbmRsZXIgaXMgcmVnaXN0ZXJlZCBmb3IgXCIke2V9XCIuIE5vdGUgdGhhdCBIVE1MIGF0dHJpYnV0ZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmUgYW5kIHlvdSBjYW5ub3QgdXNlIHYtb24gdG8gbGlzdGVuIHRvIGNhbWVsQ2FzZSBldmVudHMgd2hlbiB1c2luZyBpbi1ET00gdGVtcGxhdGVzLiBZb3Ugc2hvdWxkIHByb2JhYmx5IHVzZSBcIiR7cm4oXG4gICAgICAgIGVcbiAgICAgICl9XCIgaW5zdGVhZCBvZiBcIiR7ZX1cIi5gXG4gICAgKTtcbiAgfVxuICBsZXQgYSwgbCA9IHJbYSA9IFRyKGUpXSB8fCAvLyBhbHNvIHRyeSBjYW1lbENhc2UgZXZlbnQgaGFuZGxlciAoIzIyNDkpXG4gIHJbYSA9IFRyKG10KGUpKV07XG4gICFsICYmIHMgJiYgKGwgPSByW2EgPSBUcihybihlKSldKSwgbCAmJiBXbihcbiAgICBsLFxuICAgIHQsXG4gICAgNixcbiAgICBpXG4gICk7XG4gIGNvbnN0IGMgPSByW2EgKyBcIk9uY2VcIl07XG4gIGlmIChjKSB7XG4gICAgaWYgKCF0LmVtaXR0ZWQpXG4gICAgICB0LmVtaXR0ZWQgPSB7fTtcbiAgICBlbHNlIGlmICh0LmVtaXR0ZWRbYV0pXG4gICAgICByZXR1cm47XG4gICAgdC5lbWl0dGVkW2FdID0gITAsIFduKFxuICAgICAgYyxcbiAgICAgIHQsXG4gICAgICA2LFxuICAgICAgaVxuICAgICk7XG4gIH1cbn1cbmZ1bmN0aW9uIEZ5KHQsIGUsIG4gPSAhMSkge1xuICBjb25zdCByID0gZS5lbWl0c0NhY2hlLCBpID0gci5nZXQodCk7XG4gIGlmIChpICE9PSB2b2lkIDApXG4gICAgcmV0dXJuIGk7XG4gIGNvbnN0IHMgPSB0LmVtaXRzO1xuICBsZXQgbyA9IHt9LCBhID0gITE7XG4gIGlmIChfX1ZVRV9PUFRJT05TX0FQSV9fICYmICFiZSh0KSkge1xuICAgIGNvbnN0IGwgPSAoYykgPT4ge1xuICAgICAgY29uc3QgdSA9IEZ5KGMsIGUsICEwKTtcbiAgICAgIHUgJiYgKGEgPSAhMCwgJGUobywgdSkpO1xuICAgIH07XG4gICAgIW4gJiYgZS5taXhpbnMubGVuZ3RoICYmIGUubWl4aW5zLmZvckVhY2gobCksIHQuZXh0ZW5kcyAmJiBsKHQuZXh0ZW5kcyksIHQubWl4aW5zICYmIHQubWl4aW5zLmZvckVhY2gobCk7XG4gIH1cbiAgcmV0dXJuICFzICYmICFhID8gKFplKHQpICYmIHIuc2V0KHQsIG51bGwpLCBudWxsKSA6IChpZShzKSA/IHMuZm9yRWFjaCgobCkgPT4gb1tsXSA9IG51bGwpIDogJGUobywgcyksIFplKHQpICYmIHIuc2V0KHQsIG8pLCBvKTtcbn1cbmZ1bmN0aW9uIGJkKHQsIGUpIHtcbiAgcmV0dXJuICF0IHx8ICFvaShlKSA/ICExIDogKGUgPSBlLnNsaWNlKDIpLnJlcGxhY2UoL09uY2UkLywgXCJcIiksIEFlKHQsIGVbMF0udG9Mb3dlckNhc2UoKSArIGUuc2xpY2UoMSkpIHx8IEFlKHQsIHJuKGUpKSB8fCBBZSh0LCBlKSk7XG59XG5sZXQgT3QgPSBudWxsLCB2ZCA9IG51bGw7XG5mdW5jdGlvbiBpbCh0KSB7XG4gIGNvbnN0IGUgPSBPdDtcbiAgcmV0dXJuIE90ID0gdCwgdmQgPSB0ICYmIHQudHlwZS5fX3Njb3BlSWQgfHwgbnVsbCwgZTtcbn1cbmZ1bmN0aW9uIEtzKHQpIHtcbiAgdmQgPSB0O1xufVxuZnVuY3Rpb24gSnMoKSB7XG4gIHZkID0gbnVsbDtcbn1cbmNvbnN0IHJFID0gKHQpID0+IGNlO1xuZnVuY3Rpb24gY2UodCwgZSA9IE90LCBuKSB7XG4gIGlmICghZSB8fCB0Ll9uKVxuICAgIHJldHVybiB0O1xuICBjb25zdCByID0gKC4uLmkpID0+IHtcbiAgICByLl9kICYmIHZoKC0xKTtcbiAgICBjb25zdCBzID0gaWwoZSk7XG4gICAgbGV0IG87XG4gICAgdHJ5IHtcbiAgICAgIG8gPSB0KC4uLmkpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpbChzKSwgci5fZCAmJiB2aCgxKTtcbiAgICB9XG4gICAgcmV0dXJuIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSAmJiB6eShlKSwgbztcbiAgfTtcbiAgcmV0dXJuIHIuX24gPSAhMCwgci5fYyA9ICEwLCByLl9kID0gITAsIHI7XG59XG5sZXQgZGggPSAhMTtcbmZ1bmN0aW9uIHd1KCkge1xuICBkaCA9ICEwO1xufVxuZnVuY3Rpb24gSGModCkge1xuICBjb25zdCB7XG4gICAgdHlwZTogZSxcbiAgICB2bm9kZTogbixcbiAgICBwcm94eTogcixcbiAgICB3aXRoUHJveHk6IGksXG4gICAgcHJvcHM6IHMsXG4gICAgcHJvcHNPcHRpb25zOiBbb10sXG4gICAgc2xvdHM6IGEsXG4gICAgYXR0cnM6IGwsXG4gICAgZW1pdDogYyxcbiAgICByZW5kZXI6IHUsXG4gICAgcmVuZGVyQ2FjaGU6IGQsXG4gICAgZGF0YTogZixcbiAgICBzZXR1cFN0YXRlOiBoLFxuICAgIGN0eDogcCxcbiAgICBpbmhlcml0QXR0cnM6IE9cbiAgfSA9IHQ7XG4gIGxldCBtLCB5O1xuICBjb25zdCBiID0gaWwodCk7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAoZGggPSAhMSk7XG4gIHRyeSB7XG4gICAgaWYgKG4uc2hhcGVGbGFnICYgNCkge1xuICAgICAgY29uc3QgUyA9IGkgfHwgciwgdyA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBoLl9faXNTY3JpcHRTZXR1cCA/IG5ldyBQcm94eShTLCB7XG4gICAgICAgIGdldChrLCBfLCBUKSB7XG4gICAgICAgICAgcmV0dXJuIEkoXG4gICAgICAgICAgICBgUHJvcGVydHkgJyR7U3RyaW5nKFxuICAgICAgICAgICAgICBfXG4gICAgICAgICAgICApfScgd2FzIGFjY2Vzc2VkIHZpYSAndGhpcycuIEF2b2lkIHVzaW5nICd0aGlzJyBpbiB0ZW1wbGF0ZXMuYFxuICAgICAgICAgICksIFJlZmxlY3QuZ2V0KGssIF8sIFQpO1xuICAgICAgICB9XG4gICAgICB9KSA6IFM7XG4gICAgICBtID0gU24oXG4gICAgICAgIHUuY2FsbChcbiAgICAgICAgICB3LFxuICAgICAgICAgIFMsXG4gICAgICAgICAgZCxcbiAgICAgICAgICBzLFxuICAgICAgICAgIGgsXG4gICAgICAgICAgZixcbiAgICAgICAgICBwXG4gICAgICAgIClcbiAgICAgICksIHkgPSBsO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBTID0gZTtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBsID09PSBzICYmIHd1KCksIG0gPSBTbihcbiAgICAgICAgUy5sZW5ndGggPiAxID8gUyhcbiAgICAgICAgICBzLFxuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHtcbiAgICAgICAgICAgIGdldCBhdHRycygpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHd1KCksIGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2xvdHM6IGEsXG4gICAgICAgICAgICBlbWl0OiBjXG4gICAgICAgICAgfSA6IHsgYXR0cnM6IGwsIHNsb3RzOiBhLCBlbWl0OiBjIH1cbiAgICAgICAgKSA6IFMoXG4gICAgICAgICAgcyxcbiAgICAgICAgICBudWxsXG4gICAgICAgICAgLyogd2Uga25vdyBpdCBkb2Vzbid0IG5lZWQgaXQgKi9cbiAgICAgICAgKVxuICAgICAgKSwgeSA9IGUucHJvcHMgPyBsIDogaUUobCk7XG4gICAgfVxuICB9IGNhdGNoIChTKSB7XG4gICAgQmEubGVuZ3RoID0gMCwgaHMoUywgdCwgMSksIG0gPSBKKF90KTtcbiAgfVxuICBsZXQgZyA9IG0sIHY7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbS5wYXRjaEZsYWcgPiAwICYmIG0ucGF0Y2hGbGFnICYgMjA0OCAmJiAoW2csIHZdID0gR3kobSkpLCB5ICYmIE8gIT09ICExKSB7XG4gICAgY29uc3QgUyA9IE9iamVjdC5rZXlzKHkpLCB7IHNoYXBlRmxhZzogdyB9ID0gZztcbiAgICBpZiAoUy5sZW5ndGgpIHtcbiAgICAgIGlmICh3ICYgNylcbiAgICAgICAgbyAmJiBTLnNvbWUobXUpICYmICh5ID0gc0UoXG4gICAgICAgICAgeSxcbiAgICAgICAgICBvXG4gICAgICAgICkpLCBnID0gam4oZywgeSk7XG4gICAgICBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIWRoICYmIGcudHlwZSAhPT0gX3QpIHtcbiAgICAgICAgY29uc3QgayA9IE9iamVjdC5rZXlzKGwpLCBfID0gW10sIFQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgQyA9IDAsIEEgPSBrLmxlbmd0aDsgQyA8IEE7IEMrKykge1xuICAgICAgICAgIGNvbnN0IFEgPSBrW0NdO1xuICAgICAgICAgIG9pKFEpID8gbXUoUSkgfHwgXy5wdXNoKFFbMl0udG9Mb3dlckNhc2UoKSArIFEuc2xpY2UoMykpIDogVC5wdXNoKFEpO1xuICAgICAgICB9XG4gICAgICAgIFQubGVuZ3RoICYmIEkoXG4gICAgICAgICAgYEV4dHJhbmVvdXMgbm9uLXByb3BzIGF0dHJpYnV0ZXMgKCR7VC5qb2luKFwiLCBcIil9KSB3ZXJlIHBhc3NlZCB0byBjb21wb25lbnQgYnV0IGNvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGluaGVyaXRlZCBiZWNhdXNlIGNvbXBvbmVudCByZW5kZXJzIGZyYWdtZW50IG9yIHRleHQgcm9vdCBub2Rlcy5gXG4gICAgICAgICksIF8ubGVuZ3RoICYmIEkoXG4gICAgICAgICAgYEV4dHJhbmVvdXMgbm9uLWVtaXRzIGV2ZW50IGxpc3RlbmVycyAoJHtfLmpvaW4oXCIsIFwiKX0pIHdlcmUgcGFzc2VkIHRvIGNvbXBvbmVudCBidXQgY291bGQgbm90IGJlIGF1dG9tYXRpY2FsbHkgaW5oZXJpdGVkIGJlY2F1c2UgY29tcG9uZW50IHJlbmRlcnMgZnJhZ21lbnQgb3IgdGV4dCByb290IG5vZGVzLiBJZiB0aGUgbGlzdGVuZXIgaXMgaW50ZW5kZWQgdG8gYmUgYSBjb21wb25lbnQgY3VzdG9tIGV2ZW50IGxpc3RlbmVyIG9ubHksIGRlY2xhcmUgaXQgdXNpbmcgdGhlIFwiZW1pdHNcIiBvcHRpb24uYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbi5kaXJzICYmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIXZtKGcpICYmIEkoXG4gICAgXCJSdW50aW1lIGRpcmVjdGl2ZSB1c2VkIG9uIGNvbXBvbmVudCB3aXRoIG5vbi1lbGVtZW50IHJvb3Qgbm9kZS4gVGhlIGRpcmVjdGl2ZXMgd2lsbCBub3QgZnVuY3Rpb24gYXMgaW50ZW5kZWQuXCJcbiAgKSwgZyA9IGpuKGcpLCBnLmRpcnMgPSBnLmRpcnMgPyBnLmRpcnMuY29uY2F0KG4uZGlycykgOiBuLmRpcnMpLCBuLnRyYW5zaXRpb24gJiYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhdm0oZykgJiYgSShcbiAgICBcIkNvbXBvbmVudCBpbnNpZGUgPFRyYW5zaXRpb24+IHJlbmRlcnMgbm9uLWVsZW1lbnQgcm9vdCBub2RlIHRoYXQgY2Fubm90IGJlIGFuaW1hdGVkLlwiXG4gICksIGcudHJhbnNpdGlvbiA9IG4udHJhbnNpdGlvbiksIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB2ID8gdihnKSA6IG0gPSBnLCBpbChiKSwgbTtcbn1cbmNvbnN0IEd5ID0gKHQpID0+IHtcbiAgY29uc3QgZSA9IHQuY2hpbGRyZW4sIG4gPSB0LmR5bmFtaWNDaGlsZHJlbiwgciA9IHlkKGUsICExKTtcbiAgaWYgKHIpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHIucGF0Y2hGbGFnID4gMCAmJiByLnBhdGNoRmxhZyAmIDIwNDgpXG4gICAgICByZXR1cm4gR3kocik7XG4gIH0gZWxzZVxuICAgIHJldHVybiBbdCwgdm9pZCAwXTtcbiAgY29uc3QgaSA9IGUuaW5kZXhPZihyKSwgcyA9IG4gPyBuLmluZGV4T2YocikgOiAtMSwgbyA9IChhKSA9PiB7XG4gICAgZVtpXSA9IGEsIG4gJiYgKHMgPiAtMSA/IG5bc10gPSBhIDogYS5wYXRjaEZsYWcgPiAwICYmICh0LmR5bmFtaWNDaGlsZHJlbiA9IFsuLi5uLCBhXSkpO1xuICB9O1xuICByZXR1cm4gW1NuKHIpLCBvXTtcbn07XG5mdW5jdGlvbiB5ZCh0LCBlID0gITApIHtcbiAgbGV0IG47XG4gIGZvciAobGV0IHIgPSAwOyByIDwgdC5sZW5ndGg7IHIrKykge1xuICAgIGNvbnN0IGkgPSB0W3JdO1xuICAgIGlmIChsaShpKSkge1xuICAgICAgaWYgKGkudHlwZSAhPT0gX3QgfHwgaS5jaGlsZHJlbiA9PT0gXCJ2LWlmXCIpIHtcbiAgICAgICAgaWYgKG4pXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAobiA9IGksIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBlICYmIG4ucGF0Y2hGbGFnID4gMCAmJiBuLnBhdGNoRmxhZyAmIDIwNDgpXG4gICAgICAgICAgcmV0dXJuIHlkKG4uY2hpbGRyZW4pO1xuICAgICAgfVxuICAgIH0gZWxzZVxuICAgICAgcmV0dXJuO1xuICB9XG4gIHJldHVybiBuO1xufVxuY29uc3QgaUUgPSAodCkgPT4ge1xuICBsZXQgZTtcbiAgZm9yIChjb25zdCBuIGluIHQpXG4gICAgKG4gPT09IFwiY2xhc3NcIiB8fCBuID09PSBcInN0eWxlXCIgfHwgb2kobikpICYmICgoZSB8fCAoZSA9IHt9KSlbbl0gPSB0W25dKTtcbiAgcmV0dXJuIGU7XG59LCBzRSA9ICh0LCBlKSA9PiB7XG4gIGNvbnN0IG4gPSB7fTtcbiAgZm9yIChjb25zdCByIGluIHQpXG4gICAgKCFtdShyKSB8fCAhKHIuc2xpY2UoOSkgaW4gZSkpICYmIChuW3JdID0gdFtyXSk7XG4gIHJldHVybiBuO1xufSwgdm0gPSAodCkgPT4gdC5zaGFwZUZsYWcgJiA3IHx8IHQudHlwZSA9PT0gX3Q7XG5mdW5jdGlvbiBvRSh0LCBlLCBuKSB7XG4gIGNvbnN0IHsgcHJvcHM6IHIsIGNoaWxkcmVuOiBpLCBjb21wb25lbnQ6IHMgfSA9IHQsIHsgcHJvcHM6IG8sIGNoaWxkcmVuOiBhLCBwYXRjaEZsYWc6IGwgfSA9IGUsIGMgPSBzLmVtaXRzT3B0aW9ucztcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAoaSB8fCBhKSAmJiBIaSB8fCBlLmRpcnMgfHwgZS50cmFuc2l0aW9uKVxuICAgIHJldHVybiAhMDtcbiAgaWYgKG4gJiYgbCA+PSAwKSB7XG4gICAgaWYgKGwgJiAxMDI0KVxuICAgICAgcmV0dXJuICEwO1xuICAgIGlmIChsICYgMTYpXG4gICAgICByZXR1cm4gciA/IHltKHIsIG8sIGMpIDogISFvO1xuICAgIGlmIChsICYgOCkge1xuICAgICAgY29uc3QgdSA9IGUuZHluYW1pY1Byb3BzO1xuICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCB1Lmxlbmd0aDsgZCsrKSB7XG4gICAgICAgIGNvbnN0IGYgPSB1W2RdO1xuICAgICAgICBpZiAob1tmXSAhPT0gcltmXSAmJiAhYmQoYywgZikpXG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlXG4gICAgcmV0dXJuIChpIHx8IGEpICYmICghYSB8fCAhYS4kc3RhYmxlKSA/ICEwIDogciA9PT0gbyA/ICExIDogciA/IG8gPyB5bShyLCBvLCBjKSA6ICEwIDogISFvO1xuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiB5bSh0LCBlLCBuKSB7XG4gIGNvbnN0IHIgPSBPYmplY3Qua2V5cyhlKTtcbiAgaWYgKHIubGVuZ3RoICE9PSBPYmplY3Qua2V5cyh0KS5sZW5ndGgpXG4gICAgcmV0dXJuICEwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzID0gcltpXTtcbiAgICBpZiAoZVtzXSAhPT0gdFtzXSAmJiAhYmQobiwgcykpXG4gICAgICByZXR1cm4gITA7XG4gIH1cbiAgcmV0dXJuICExO1xufVxuZnVuY3Rpb24gZ08oeyB2bm9kZTogdCwgcGFyZW50OiBlIH0sIG4pIHtcbiAgZm9yICg7IGU7ICkge1xuICAgIGNvbnN0IHIgPSBlLnN1YlRyZWU7XG4gICAgaWYgKHIuc3VzcGVuc2UgJiYgci5zdXNwZW5zZS5hY3RpdmVCcmFuY2ggPT09IHQgJiYgKHIuZWwgPSB0LmVsKSwgciA9PT0gdClcbiAgICAgICh0ID0gZS52bm9kZSkuZWwgPSBuLCBlID0gZS5wYXJlbnQ7XG4gICAgZWxzZVxuICAgICAgYnJlYWs7XG4gIH1cbn1cbmNvbnN0IGt1ID0gXCJjb21wb25lbnRzXCIsIGFFID0gXCJkaXJlY3RpdmVzXCI7XG5mdW5jdGlvbiBsRSh0LCBlKSB7XG4gIHJldHVybiBiTyhrdSwgdCwgITAsIGUpIHx8IHQ7XG59XG5jb25zdCBtTyA9IFN5bWJvbC5mb3IoXCJ2LW5kY1wiKTtcbmZ1bmN0aW9uIFpsKHQpIHtcbiAgcmV0dXJuIHdlKHQpID8gYk8oa3UsIHQsICExKSB8fCB0IDogdCB8fCBtTztcbn1cbmZ1bmN0aW9uIGNFKHQpIHtcbiAgcmV0dXJuIGJPKGFFLCB0KTtcbn1cbmZ1bmN0aW9uIGJPKHQsIGUsIG4gPSAhMCwgciA9ICExKSB7XG4gIGNvbnN0IGkgPSBPdCB8fCB4dDtcbiAgaWYgKGkpIHtcbiAgICBjb25zdCBzID0gaS50eXBlO1xuICAgIGlmICh0ID09PSBrdSkge1xuICAgICAgY29uc3QgYSA9IGFsKFxuICAgICAgICBzLFxuICAgICAgICAhMVxuICAgICAgKTtcbiAgICAgIGlmIChhICYmIChhID09PSBlIHx8IGEgPT09IG10KGUpIHx8IGEgPT09IFdyKG10KGUpKSkpXG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgICBjb25zdCBvID0gKFxuICAgICAgLy8gbG9jYWwgcmVnaXN0cmF0aW9uXG4gICAgICAvLyBjaGVjayBpbnN0YW5jZVt0eXBlXSBmaXJzdCB3aGljaCBpcyByZXNvbHZlZCBmb3Igb3B0aW9ucyBBUElcbiAgICAgIFNtKGlbdF0gfHwgc1t0XSwgZSkgfHwgLy8gZ2xvYmFsIHJlZ2lzdHJhdGlvblxuICAgICAgU20oaS5hcHBDb250ZXh0W3RdLCBlKVxuICAgICk7XG4gICAgaWYgKCFvICYmIHIpXG4gICAgICByZXR1cm4gcztcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG4gJiYgIW8pIHtcbiAgICAgIGNvbnN0IGEgPSB0ID09PSBrdSA/IGBcbklmIHRoaXMgaXMgYSBuYXRpdmUgY3VzdG9tIGVsZW1lbnQsIG1ha2Ugc3VyZSB0byBleGNsdWRlIGl0IGZyb20gY29tcG9uZW50IHJlc29sdXRpb24gdmlhIGNvbXBpbGVyT3B0aW9ucy5pc0N1c3RvbUVsZW1lbnQuYCA6IFwiXCI7XG4gICAgICBJKGBGYWlsZWQgdG8gcmVzb2x2ZSAke3Quc2xpY2UoMCwgLTEpfTogJHtlfSR7YX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG87XG4gIH0gZWxzZVxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBJKFxuICAgICAgYHJlc29sdmUke1dyKHQuc2xpY2UoMCwgLTEpKX0gY2FuIG9ubHkgYmUgdXNlZCBpbiByZW5kZXIoKSBvciBzZXR1cCgpLmBcbiAgICApO1xufVxuZnVuY3Rpb24gU20odCwgZSkge1xuICByZXR1cm4gdCAmJiAodFtlXSB8fCB0W210KGUpXSB8fCB0W1dyKG10KGUpKV0pO1xufVxuY29uc3QgS3kgPSAodCkgPT4gdC5fX2lzU3VzcGVuc2U7XG5sZXQgZmggPSAwO1xuY29uc3QgdUUgPSB7XG4gIG5hbWU6IFwiU3VzcGVuc2VcIixcbiAgLy8gSW4gb3JkZXIgdG8gbWFrZSBTdXNwZW5zZSB0cmVlLXNoYWthYmxlLCB3ZSBuZWVkIHRvIGF2b2lkIGltcG9ydGluZyBpdFxuICAvLyBkaXJlY3RseSBpbiB0aGUgcmVuZGVyZXIuIFRoZSByZW5kZXJlciBjaGVja3MgZm9yIHRoZSBfX2lzU3VzcGVuc2UgZmxhZ1xuICAvLyBvbiBhIHZub2RlJ3MgdHlwZSBhbmQgY2FsbHMgdGhlIGBwcm9jZXNzYCBtZXRob2QsIHBhc3NpbmcgaW4gcmVuZGVyZXJcbiAgLy8gaW50ZXJuYWxzLlxuICBfX2lzU3VzcGVuc2U6ICEwLFxuICBwcm9jZXNzKHQsIGUsIG4sIHIsIGksIHMsIG8sIGEsIGwsIGMpIHtcbiAgICBpZiAodCA9PSBudWxsKVxuICAgICAgZkUoXG4gICAgICAgIGUsXG4gICAgICAgIG4sXG4gICAgICAgIHIsXG4gICAgICAgIGksXG4gICAgICAgIHMsXG4gICAgICAgIG8sXG4gICAgICAgIGEsXG4gICAgICAgIGwsXG4gICAgICAgIGNcbiAgICAgICk7XG4gICAgZWxzZSB7XG4gICAgICBpZiAocyAmJiBzLmRlcHMgPiAwICYmICF0LnN1c3BlbnNlLmlzSW5GYWxsYmFjaykge1xuICAgICAgICBlLnN1c3BlbnNlID0gdC5zdXNwZW5zZSwgZS5zdXNwZW5zZS52bm9kZSA9IGUsIGUuZWwgPSB0LmVsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBoRShcbiAgICAgICAgdCxcbiAgICAgICAgZSxcbiAgICAgICAgbixcbiAgICAgICAgcixcbiAgICAgICAgaSxcbiAgICAgICAgbyxcbiAgICAgICAgYSxcbiAgICAgICAgbCxcbiAgICAgICAgY1xuICAgICAgKTtcbiAgICB9XG4gIH0sXG4gIGh5ZHJhdGU6IHBFLFxuICBjcmVhdGU6IHZPLFxuICBub3JtYWxpemU6IE9FXG59LCBkRSA9IHVFO1xuZnVuY3Rpb24gc2wodCwgZSkge1xuICBjb25zdCBuID0gdC5wcm9wcyAmJiB0LnByb3BzW2VdO1xuICBiZShuKSAmJiBuKCk7XG59XG5mdW5jdGlvbiBmRSh0LCBlLCBuLCByLCBpLCBzLCBvLCBhLCBsKSB7XG4gIGNvbnN0IHtcbiAgICBwOiBjLFxuICAgIG86IHsgY3JlYXRlRWxlbWVudDogdSB9XG4gIH0gPSBsLCBkID0gdShcImRpdlwiKSwgZiA9IHQuc3VzcGVuc2UgPSB2TyhcbiAgICB0LFxuICAgIGksXG4gICAgcixcbiAgICBlLFxuICAgIGQsXG4gICAgbixcbiAgICBzLFxuICAgIG8sXG4gICAgYSxcbiAgICBsXG4gICk7XG4gIGMoXG4gICAgbnVsbCxcbiAgICBmLnBlbmRpbmdCcmFuY2ggPSB0LnNzQ29udGVudCxcbiAgICBkLFxuICAgIG51bGwsXG4gICAgcixcbiAgICBmLFxuICAgIHMsXG4gICAgb1xuICApLCBmLmRlcHMgPiAwID8gKHNsKHQsIFwib25QZW5kaW5nXCIpLCBzbCh0LCBcIm9uRmFsbGJhY2tcIiksIGMoXG4gICAgbnVsbCxcbiAgICB0LnNzRmFsbGJhY2ssXG4gICAgZSxcbiAgICBuLFxuICAgIHIsXG4gICAgbnVsbCxcbiAgICAvLyBmYWxsYmFjayB0cmVlIHdpbGwgbm90IGhhdmUgc3VzcGVuc2UgY29udGV4dFxuICAgIHMsXG4gICAgb1xuICApLCBTbyhmLCB0LnNzRmFsbGJhY2spKSA6IGYucmVzb2x2ZSghMSwgITApO1xufVxuZnVuY3Rpb24gaEUodCwgZSwgbiwgciwgaSwgcywgbywgYSwgeyBwOiBsLCB1bTogYywgbzogeyBjcmVhdGVFbGVtZW50OiB1IH0gfSkge1xuICBjb25zdCBkID0gZS5zdXNwZW5zZSA9IHQuc3VzcGVuc2U7XG4gIGQudm5vZGUgPSBlLCBlLmVsID0gdC5lbDtcbiAgY29uc3QgZiA9IGUuc3NDb250ZW50LCBoID0gZS5zc0ZhbGxiYWNrLCB7IGFjdGl2ZUJyYW5jaDogcCwgcGVuZGluZ0JyYW5jaDogTywgaXNJbkZhbGxiYWNrOiBtLCBpc0h5ZHJhdGluZzogeSB9ID0gZDtcbiAgaWYgKE8pXG4gICAgZC5wZW5kaW5nQnJhbmNoID0gZiwgbHIoZiwgTykgPyAobChcbiAgICAgIE8sXG4gICAgICBmLFxuICAgICAgZC5oaWRkZW5Db250YWluZXIsXG4gICAgICBudWxsLFxuICAgICAgaSxcbiAgICAgIGQsXG4gICAgICBzLFxuICAgICAgbyxcbiAgICAgIGFcbiAgICApLCBkLmRlcHMgPD0gMCA/IGQucmVzb2x2ZSgpIDogbSAmJiAoeSB8fCAobChcbiAgICAgIHAsXG4gICAgICBoLFxuICAgICAgbixcbiAgICAgIHIsXG4gICAgICBpLFxuICAgICAgbnVsbCxcbiAgICAgIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XG4gICAgICBzLFxuICAgICAgbyxcbiAgICAgIGFcbiAgICApLCBTbyhkLCBoKSkpKSA6IChkLnBlbmRpbmdJZCA9IGZoKyssIHkgPyAoZC5pc0h5ZHJhdGluZyA9ICExLCBkLmFjdGl2ZUJyYW5jaCA9IE8pIDogYyhPLCBpLCBkKSwgZC5kZXBzID0gMCwgZC5lZmZlY3RzLmxlbmd0aCA9IDAsIGQuaGlkZGVuQ29udGFpbmVyID0gdShcImRpdlwiKSwgbSA/IChsKFxuICAgICAgbnVsbCxcbiAgICAgIGYsXG4gICAgICBkLmhpZGRlbkNvbnRhaW5lcixcbiAgICAgIG51bGwsXG4gICAgICBpLFxuICAgICAgZCxcbiAgICAgIHMsXG4gICAgICBvLFxuICAgICAgYVxuICAgICksIGQuZGVwcyA8PSAwID8gZC5yZXNvbHZlKCkgOiAobChcbiAgICAgIHAsXG4gICAgICBoLFxuICAgICAgbixcbiAgICAgIHIsXG4gICAgICBpLFxuICAgICAgbnVsbCxcbiAgICAgIC8vIGZhbGxiYWNrIHRyZWUgd2lsbCBub3QgaGF2ZSBzdXNwZW5zZSBjb250ZXh0XG4gICAgICBzLFxuICAgICAgbyxcbiAgICAgIGFcbiAgICApLCBTbyhkLCBoKSkpIDogcCAmJiBscihmLCBwKSA/IChsKFxuICAgICAgcCxcbiAgICAgIGYsXG4gICAgICBuLFxuICAgICAgcixcbiAgICAgIGksXG4gICAgICBkLFxuICAgICAgcyxcbiAgICAgIG8sXG4gICAgICBhXG4gICAgKSwgZC5yZXNvbHZlKCEwKSkgOiAobChcbiAgICAgIG51bGwsXG4gICAgICBmLFxuICAgICAgZC5oaWRkZW5Db250YWluZXIsXG4gICAgICBudWxsLFxuICAgICAgaSxcbiAgICAgIGQsXG4gICAgICBzLFxuICAgICAgbyxcbiAgICAgIGFcbiAgICApLCBkLmRlcHMgPD0gMCAmJiBkLnJlc29sdmUoKSkpO1xuICBlbHNlIGlmIChwICYmIGxyKGYsIHApKVxuICAgIGwoXG4gICAgICBwLFxuICAgICAgZixcbiAgICAgIG4sXG4gICAgICByLFxuICAgICAgaSxcbiAgICAgIGQsXG4gICAgICBzLFxuICAgICAgbyxcbiAgICAgIGFcbiAgICApLCBTbyhkLCBmKTtcbiAgZWxzZSBpZiAoc2woZSwgXCJvblBlbmRpbmdcIiksIGQucGVuZGluZ0JyYW5jaCA9IGYsIGYuc2hhcGVGbGFnICYgNTEyID8gZC5wZW5kaW5nSWQgPSBmLmNvbXBvbmVudC5zdXNwZW5zZUlkIDogZC5wZW5kaW5nSWQgPSBmaCsrLCBsKFxuICAgIG51bGwsXG4gICAgZixcbiAgICBkLmhpZGRlbkNvbnRhaW5lcixcbiAgICBudWxsLFxuICAgIGksXG4gICAgZCxcbiAgICBzLFxuICAgIG8sXG4gICAgYVxuICApLCBkLmRlcHMgPD0gMClcbiAgICBkLnJlc29sdmUoKTtcbiAgZWxzZSB7XG4gICAgY29uc3QgeyB0aW1lb3V0OiBiLCBwZW5kaW5nSWQ6IGcgfSA9IGQ7XG4gICAgYiA+IDAgPyBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGQucGVuZGluZ0lkID09PSBnICYmIGQuZmFsbGJhY2soaCk7XG4gICAgfSwgYikgOiBiID09PSAwICYmIGQuZmFsbGJhY2soaCk7XG4gIH1cbn1cbmxldCB3bSA9ICExO1xuZnVuY3Rpb24gdk8odCwgZSwgbiwgciwgaSwgcywgbywgYSwgbCwgYywgdSA9ICExKSB7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhd20gJiYgKHdtID0gITAsIGNvbnNvbGVbY29uc29sZS5pbmZvID8gXCJpbmZvXCIgOiBcImxvZ1wiXShcbiAgICBcIjxTdXNwZW5zZT4gaXMgYW4gZXhwZXJpbWVudGFsIGZlYXR1cmUgYW5kIGl0cyBBUEkgd2lsbCBsaWtlbHkgY2hhbmdlLlwiXG4gICkpO1xuICBjb25zdCB7XG4gICAgcDogZCxcbiAgICBtOiBmLFxuICAgIHVtOiBoLFxuICAgIG46IHAsXG4gICAgbzogeyBwYXJlbnROb2RlOiBPLCByZW1vdmU6IG0gfVxuICB9ID0gYztcbiAgbGV0IHk7XG4gIGNvbnN0IGIgPSBnRSh0KTtcbiAgYiAmJiBlICE9IG51bGwgJiYgZS5wZW5kaW5nQnJhbmNoICYmICh5ID0gZS5wZW5kaW5nSWQsIGUuZGVwcysrKTtcbiAgY29uc3QgZyA9IHQucHJvcHMgPyB2dSh0LnByb3BzLnRpbWVvdXQpIDogdm9pZCAwO1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZE8oZywgXCJTdXNwZW5zZSB0aW1lb3V0XCIpO1xuICBjb25zdCB2ID0gcywgUyA9IHtcbiAgICB2bm9kZTogdCxcbiAgICBwYXJlbnQ6IGUsXG4gICAgcGFyZW50Q29tcG9uZW50OiBuLFxuICAgIG5hbWVzcGFjZTogbyxcbiAgICBjb250YWluZXI6IHIsXG4gICAgaGlkZGVuQ29udGFpbmVyOiBpLFxuICAgIGRlcHM6IDAsXG4gICAgcGVuZGluZ0lkOiBmaCsrLFxuICAgIHRpbWVvdXQ6IHR5cGVvZiBnID09IFwibnVtYmVyXCIgPyBnIDogLTEsXG4gICAgYWN0aXZlQnJhbmNoOiBudWxsLFxuICAgIHBlbmRpbmdCcmFuY2g6IG51bGwsXG4gICAgaXNJbkZhbGxiYWNrOiAhdSxcbiAgICBpc0h5ZHJhdGluZzogdSxcbiAgICBpc1VubW91bnRlZDogITEsXG4gICAgZWZmZWN0czogW10sXG4gICAgcmVzb2x2ZSh3ID0gITEsIGsgPSAhMSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBpZiAoIXcgJiYgIVMucGVuZGluZ0JyYW5jaClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcInN1c3BlbnNlLnJlc29sdmUoKSBpcyBjYWxsZWQgd2l0aG91dCBhIHBlbmRpbmcgYnJhbmNoLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgaWYgKFMuaXNVbm1vdW50ZWQpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJzdXNwZW5zZS5yZXNvbHZlKCkgaXMgY2FsbGVkIG9uIGFuIGFscmVhZHkgdW5tb3VudGVkIHN1c3BlbnNlIGJvdW5kYXJ5LlwiXG4gICAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdm5vZGU6IF8sXG4gICAgICAgIGFjdGl2ZUJyYW5jaDogVCxcbiAgICAgICAgcGVuZGluZ0JyYW5jaDogQyxcbiAgICAgICAgcGVuZGluZ0lkOiBBLFxuICAgICAgICBlZmZlY3RzOiBRLFxuICAgICAgICBwYXJlbnRDb21wb25lbnQ6IFcsXG4gICAgICAgIGNvbnRhaW5lcjogTFxuICAgICAgfSA9IFM7XG4gICAgICBsZXQgcmUgPSAhMTtcbiAgICAgIFMuaXNIeWRyYXRpbmcgPyBTLmlzSHlkcmF0aW5nID0gITEgOiB3IHx8IChyZSA9IFQgJiYgQy50cmFuc2l0aW9uICYmIEMudHJhbnNpdGlvbi5tb2RlID09PSBcIm91dC1pblwiLCByZSAmJiAoVC50cmFuc2l0aW9uLmFmdGVyTGVhdmUgPSAoKSA9PiB7XG4gICAgICAgIEEgPT09IFMucGVuZGluZ0lkICYmIChmKFxuICAgICAgICAgIEMsXG4gICAgICAgICAgTCxcbiAgICAgICAgICBzID09PSB2ID8gcChUKSA6IHMsXG4gICAgICAgICAgMFxuICAgICAgICApLCBubChRKSk7XG4gICAgICB9KSwgVCAmJiAoTyhULmVsKSAhPT0gUy5oaWRkZW5Db250YWluZXIgJiYgKHMgPSBwKFQpKSwgaChULCBXLCBTLCAhMCkpLCByZSB8fCBmKEMsIEwsIHMsIDApKSwgU28oUywgQyksIFMucGVuZGluZ0JyYW5jaCA9IG51bGwsIFMuaXNJbkZhbGxiYWNrID0gITE7XG4gICAgICBsZXQgWSA9IFMucGFyZW50LCBLID0gITE7XG4gICAgICBmb3IgKDsgWTsgKSB7XG4gICAgICAgIGlmIChZLnBlbmRpbmdCcmFuY2gpIHtcbiAgICAgICAgICBZLmVmZmVjdHMucHVzaCguLi5RKSwgSyA9ICEwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIFkgPSBZLnBhcmVudDtcbiAgICAgIH1cbiAgICAgICFLICYmICFyZSAmJiBubChRKSwgUy5lZmZlY3RzID0gW10sIGIgJiYgZSAmJiBlLnBlbmRpbmdCcmFuY2ggJiYgeSA9PT0gZS5wZW5kaW5nSWQgJiYgKGUuZGVwcy0tLCBlLmRlcHMgPT09IDAgJiYgIWsgJiYgZS5yZXNvbHZlKCkpLCBzbChfLCBcIm9uUmVzb2x2ZVwiKTtcbiAgICB9LFxuICAgIGZhbGxiYWNrKHcpIHtcbiAgICAgIGlmICghUy5wZW5kaW5nQnJhbmNoKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCB7IHZub2RlOiBrLCBhY3RpdmVCcmFuY2g6IF8sIHBhcmVudENvbXBvbmVudDogVCwgY29udGFpbmVyOiBDLCBuYW1lc3BhY2U6IEEgfSA9IFM7XG4gICAgICBzbChrLCBcIm9uRmFsbGJhY2tcIik7XG4gICAgICBjb25zdCBRID0gcChfKSwgVyA9ICgpID0+IHtcbiAgICAgICAgUy5pc0luRmFsbGJhY2sgJiYgKGQoXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICB3LFxuICAgICAgICAgIEMsXG4gICAgICAgICAgUSxcbiAgICAgICAgICBULFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgLy8gZmFsbGJhY2sgdHJlZSB3aWxsIG5vdCBoYXZlIHN1c3BlbnNlIGNvbnRleHRcbiAgICAgICAgICBBLFxuICAgICAgICAgIGEsXG4gICAgICAgICAgbFxuICAgICAgICApLCBTbyhTLCB3KSk7XG4gICAgICB9LCBMID0gdy50cmFuc2l0aW9uICYmIHcudHJhbnNpdGlvbi5tb2RlID09PSBcIm91dC1pblwiO1xuICAgICAgTCAmJiAoXy50cmFuc2l0aW9uLmFmdGVyTGVhdmUgPSBXKSwgUy5pc0luRmFsbGJhY2sgPSAhMCwgaChcbiAgICAgICAgXyxcbiAgICAgICAgVCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgLy8gbm8gc3VzcGVuc2Ugc28gdW5tb3VudCBob29rcyBmaXJlIG5vd1xuICAgICAgICAhMFxuICAgICAgICAvLyBzaG91bGRSZW1vdmVcbiAgICAgICksIEwgfHwgVygpO1xuICAgIH0sXG4gICAgbW92ZSh3LCBrLCBfKSB7XG4gICAgICBTLmFjdGl2ZUJyYW5jaCAmJiBmKFMuYWN0aXZlQnJhbmNoLCB3LCBrLCBfKSwgUy5jb250YWluZXIgPSB3O1xuICAgIH0sXG4gICAgbmV4dCgpIHtcbiAgICAgIHJldHVybiBTLmFjdGl2ZUJyYW5jaCAmJiBwKFMuYWN0aXZlQnJhbmNoKTtcbiAgICB9LFxuICAgIHJlZ2lzdGVyRGVwKHcsIGspIHtcbiAgICAgIGNvbnN0IF8gPSAhIVMucGVuZGluZ0JyYW5jaDtcbiAgICAgIF8gJiYgUy5kZXBzKys7XG4gICAgICBjb25zdCBUID0gdy52bm9kZS5lbDtcbiAgICAgIHcuYXN5bmNEZXAuY2F0Y2goKEMpID0+IHtcbiAgICAgICAgaHMoQywgdywgMCk7XG4gICAgICB9KS50aGVuKChDKSA9PiB7XG4gICAgICAgIGlmICh3LmlzVW5tb3VudGVkIHx8IFMuaXNVbm1vdW50ZWQgfHwgUy5wZW5kaW5nSWQgIT09IHcuc3VzcGVuc2VJZClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHcuYXN5bmNSZXNvbHZlZCA9ICEwO1xuICAgICAgICBjb25zdCB7IHZub2RlOiBBIH0gPSB3O1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgSWEoQSksIHhoKHcsIEMsICExKSwgVCAmJiAoQS5lbCA9IFQpO1xuICAgICAgICBjb25zdCBRID0gIVQgJiYgdy5zdWJUcmVlLmVsO1xuICAgICAgICBrKFxuICAgICAgICAgIHcsXG4gICAgICAgICAgQSxcbiAgICAgICAgICAvLyBjb21wb25lbnQgbWF5IGhhdmUgYmVlbiBtb3ZlZCBiZWZvcmUgcmVzb2x2ZS5cbiAgICAgICAgICAvLyBpZiB0aGlzIGlzIG5vdCBhIGh5ZHJhdGlvbiwgaW5zdGFuY2Uuc3ViVHJlZSB3aWxsIGJlIHRoZSBjb21tZW50XG4gICAgICAgICAgLy8gcGxhY2Vob2xkZXIuXG4gICAgICAgICAgTyhUIHx8IHcuc3ViVHJlZS5lbCksXG4gICAgICAgICAgLy8gYW5jaG9yIHdpbGwgbm90IGJlIHVzZWQgaWYgdGhpcyBpcyBoeWRyYXRpb24sIHNvIG9ubHkgbmVlZCB0b1xuICAgICAgICAgIC8vIGNvbnNpZGVyIHRoZSBjb21tZW50IHBsYWNlaG9sZGVyIGNhc2UuXG4gICAgICAgICAgVCA/IG51bGwgOiBwKHcuc3ViVHJlZSksXG4gICAgICAgICAgUyxcbiAgICAgICAgICBvLFxuICAgICAgICAgIGxcbiAgICAgICAgKSwgUSAmJiBtKFEpLCBnTyh3LCBBLmVsKSwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIFdhKCksIF8gJiYgLS1TLmRlcHMgPT09IDAgJiYgUy5yZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHVubW91bnQodywgaykge1xuICAgICAgUy5pc1VubW91bnRlZCA9ICEwLCBTLmFjdGl2ZUJyYW5jaCAmJiBoKFxuICAgICAgICBTLmFjdGl2ZUJyYW5jaCxcbiAgICAgICAgbixcbiAgICAgICAgdyxcbiAgICAgICAga1xuICAgICAgKSwgUy5wZW5kaW5nQnJhbmNoICYmIGgoXG4gICAgICAgIFMucGVuZGluZ0JyYW5jaCxcbiAgICAgICAgbixcbiAgICAgICAgdyxcbiAgICAgICAga1xuICAgICAgKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBTO1xufVxuZnVuY3Rpb24gcEUodCwgZSwgbiwgciwgaSwgcywgbywgYSwgbCkge1xuICBjb25zdCBjID0gZS5zdXNwZW5zZSA9IHZPKFxuICAgIGUsXG4gICAgcixcbiAgICBuLFxuICAgIHQucGFyZW50Tm9kZSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzXG4gICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICBudWxsLFxuICAgIGksXG4gICAgcyxcbiAgICBvLFxuICAgIGEsXG4gICAgITBcbiAgKSwgdSA9IGwoXG4gICAgdCxcbiAgICBjLnBlbmRpbmdCcmFuY2ggPSBlLnNzQ29udGVudCxcbiAgICBuLFxuICAgIGMsXG4gICAgcyxcbiAgICBvXG4gICk7XG4gIHJldHVybiBjLmRlcHMgPT09IDAgJiYgYy5yZXNvbHZlKCExLCAhMCksIHU7XG59XG5mdW5jdGlvbiBPRSh0KSB7XG4gIGNvbnN0IHsgc2hhcGVGbGFnOiBlLCBjaGlsZHJlbjogbiB9ID0gdCwgciA9IGUgJiAzMjtcbiAgdC5zc0NvbnRlbnQgPSBrbShcbiAgICByID8gbi5kZWZhdWx0IDogblxuICApLCB0LnNzRmFsbGJhY2sgPSByID8ga20obi5mYWxsYmFjaykgOiBKKF90KTtcbn1cbmZ1bmN0aW9uIGttKHQpIHtcbiAgbGV0IGU7XG4gIGlmIChiZSh0KSkge1xuICAgIGNvbnN0IG4gPSBqcyAmJiB0Ll9jO1xuICAgIG4gJiYgKHQuX2QgPSAhMSwgWigpKSwgdCA9IHQoKSwgbiAmJiAodC5fZCA9ICEwLCBlID0ga24sIEExKCkpO1xuICB9XG4gIGlmIChpZSh0KSkge1xuICAgIGNvbnN0IG4gPSB5ZCh0KTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIW4gJiYgdC5maWx0ZXIoKHIpID0+IHIgIT09IG1PKS5sZW5ndGggPiAwICYmIEkoXCI8U3VzcGVuc2U+IHNsb3RzIGV4cGVjdCBhIHNpbmdsZSByb290IG5vZGUuXCIpLCB0ID0gbjtcbiAgfVxuICByZXR1cm4gdCA9IFNuKHQpLCBlICYmICF0LmR5bmFtaWNDaGlsZHJlbiAmJiAodC5keW5hbWljQ2hpbGRyZW4gPSBlLmZpbHRlcigobikgPT4gbiAhPT0gdCkpLCB0O1xufVxuZnVuY3Rpb24gSnkodCwgZSkge1xuICBlICYmIGUucGVuZGluZ0JyYW5jaCA/IGllKHQpID8gZS5lZmZlY3RzLnB1c2goLi4udCkgOiBlLmVmZmVjdHMucHVzaCh0KSA6IG5sKHQpO1xufVxuZnVuY3Rpb24gU28odCwgZSkge1xuICB0LmFjdGl2ZUJyYW5jaCA9IGU7XG4gIGNvbnN0IHsgdm5vZGU6IG4sIHBhcmVudENvbXBvbmVudDogciB9ID0gdDtcbiAgbGV0IGkgPSBlLmVsO1xuICBmb3IgKDsgIWkgJiYgZS5jb21wb25lbnQ7IClcbiAgICBlID0gZS5jb21wb25lbnQuc3ViVHJlZSwgaSA9IGUuZWw7XG4gIG4uZWwgPSBpLCByICYmIHIuc3ViVHJlZSA9PT0gbiAmJiAoci52bm9kZS5lbCA9IGksIGdPKHIsIGkpKTtcbn1cbmZ1bmN0aW9uIGdFKHQpIHtcbiAgdmFyIGU7XG4gIHJldHVybiAoKGUgPSB0LnByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogZS5zdXNwZW5zaWJsZSkgIT0gbnVsbCAmJiB0LnByb3BzLnN1c3BlbnNpYmxlICE9PSAhMTtcbn1cbmNvbnN0IGUxID0gU3ltYm9sLmZvcihcInYtc2N4XCIpLCB5TyA9ICgpID0+IHtcbiAge1xuICAgIGNvbnN0IHQgPSBQdChlMSk7XG4gICAgcmV0dXJuIHQgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIEkoXG4gICAgICBcIlNlcnZlciByZW5kZXJpbmcgY29udGV4dCBub3QgcHJvdmlkZWQuIE1ha2Ugc3VyZSB0byBvbmx5IGNhbGwgdXNlU1NSQ29udGV4dCgpIGNvbmRpdGlvbmFsbHkgaW4gdGhlIHNlcnZlciBidWlsZC5cIlxuICAgICksIHQ7XG4gIH1cbn07XG5mdW5jdGlvbiBCbih0LCBlKSB7XG4gIHJldHVybiBWbCh0LCBudWxsLCBlKTtcbn1cbmZ1bmN0aW9uIHQxKHQsIGUpIHtcbiAgcmV0dXJuIFZsKFxuICAgIHQsXG4gICAgbnVsbCxcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyAkZSh7fSwgZSwgeyBmbHVzaDogXCJwb3N0XCIgfSkgOiB7IGZsdXNoOiBcInBvc3RcIiB9XG4gICk7XG59XG5mdW5jdGlvbiBuMSh0LCBlKSB7XG4gIHJldHVybiBWbChcbiAgICB0LFxuICAgIG51bGwsXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gJGUoe30sIGUsIHsgZmx1c2g6IFwic3luY1wiIH0pIDogeyBmbHVzaDogXCJzeW5jXCIgfVxuICApO1xufVxuY29uc3QgcGMgPSB7fTtcbmZ1bmN0aW9uIGh0KHQsIGUsIG4pIHtcbiAgcmV0dXJuIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhYmUoZSkgJiYgSShcbiAgICBcImB3YXRjaChmbiwgb3B0aW9ucz8pYCBzaWduYXR1cmUgaGFzIGJlZW4gbW92ZWQgdG8gYSBzZXBhcmF0ZSBBUEkuIFVzZSBgd2F0Y2hFZmZlY3QoZm4sIG9wdGlvbnM/KWAgaW5zdGVhZC4gYHdhdGNoYCBub3cgb25seSBzdXBwb3J0cyBgd2F0Y2goc291cmNlLCBjYiwgb3B0aW9ucz8pIHNpZ25hdHVyZS5cIlxuICApLCBWbCh0LCBlLCBuKTtcbn1cbmZ1bmN0aW9uIFZsKHQsIGUsIHtcbiAgaW1tZWRpYXRlOiBuLFxuICBkZWVwOiByLFxuICBmbHVzaDogaSxcbiAgb25jZTogcyxcbiAgb25UcmFjazogbyxcbiAgb25UcmlnZ2VyOiBhXG59ID0gVmUpIHtcbiAgaWYgKGUgJiYgcykge1xuICAgIGNvbnN0IGsgPSBlO1xuICAgIGUgPSAoLi4uXykgPT4ge1xuICAgICAgayguLi5fKSwgdygpO1xuICAgIH07XG4gIH1cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHIgIT09IHZvaWQgMCAmJiB0eXBlb2YgciA9PSBcIm51bWJlclwiICYmIEkoXG4gICAgJ3dhdGNoKCkgXCJkZWVwXCIgb3B0aW9uIHdpdGggbnVtYmVyIHZhbHVlIHdpbGwgYmUgdXNlZCBhcyB3YXRjaCBkZXB0aCBpbiBmdXR1cmUgdmVyc2lvbnMuIFBsZWFzZSB1c2UgYSBib29sZWFuIGluc3RlYWQgdG8gYXZvaWQgcG90ZW50aWFsIGJyZWFrYWdlLidcbiAgKSwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFlICYmIChuICE9PSB2b2lkIDAgJiYgSShcbiAgICAnd2F0Y2goKSBcImltbWVkaWF0ZVwiIG9wdGlvbiBpcyBvbmx5IHJlc3BlY3RlZCB3aGVuIHVzaW5nIHRoZSB3YXRjaChzb3VyY2UsIGNhbGxiYWNrLCBvcHRpb25zPykgc2lnbmF0dXJlLidcbiAgKSwgciAhPT0gdm9pZCAwICYmIEkoXG4gICAgJ3dhdGNoKCkgXCJkZWVwXCIgb3B0aW9uIGlzIG9ubHkgcmVzcGVjdGVkIHdoZW4gdXNpbmcgdGhlIHdhdGNoKHNvdXJjZSwgY2FsbGJhY2ssIG9wdGlvbnM/KSBzaWduYXR1cmUuJ1xuICApLCBzICE9PSB2b2lkIDAgJiYgSShcbiAgICAnd2F0Y2goKSBcIm9uY2VcIiBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyB0aGUgd2F0Y2goc291cmNlLCBjYWxsYmFjaywgb3B0aW9ucz8pIHNpZ25hdHVyZS4nXG4gICkpO1xuICBjb25zdCBsID0gKGspID0+IHtcbiAgICBJKFxuICAgICAgXCJJbnZhbGlkIHdhdGNoIHNvdXJjZTogXCIsXG4gICAgICBrLFxuICAgICAgXCJBIHdhdGNoIHNvdXJjZSBjYW4gb25seSBiZSBhIGdldHRlci9lZmZlY3QgZnVuY3Rpb24sIGEgcmVmLCBhIHJlYWN0aXZlIG9iamVjdCwgb3IgYW4gYXJyYXkgb2YgdGhlc2UgdHlwZXMuXCJcbiAgICApO1xuICB9LCBjID0geHQsIHUgPSAoaykgPT4gciA9PT0gITAgPyBrIDogKFxuICAgIC8vIGZvciBkZWVwOiBmYWxzZSwgb25seSB0cmF2ZXJzZSByb290LWxldmVsIHByb3BlcnRpZXNcbiAgICB3cyhrLCByID09PSAhMSA/IDEgOiB2b2lkIDApXG4gICk7XG4gIGxldCBkLCBmID0gITEsIGggPSAhMTtcbiAgaWYgKEN0KHQpID8gKGQgPSAoKSA9PiB0LnZhbHVlLCBmID0gemkodCkpIDogWWkodCkgPyAoZCA9ICgpID0+IHUodCksIGYgPSAhMCkgOiBpZSh0KSA/IChoID0gITAsIGYgPSB0LnNvbWUoKGspID0+IFlpKGspIHx8IHppKGspKSwgZCA9ICgpID0+IHQubWFwKChrKSA9PiB7XG4gICAgaWYgKEN0KGspKVxuICAgICAgcmV0dXJuIGsudmFsdWU7XG4gICAgaWYgKFlpKGspKVxuICAgICAgcmV0dXJuIHUoayk7XG4gICAgaWYgKGJlKGspKVxuICAgICAgcmV0dXJuIFZyKGssIGMsIDIpO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBsKGspO1xuICB9KSkgOiBiZSh0KSA/IGUgPyBkID0gKCkgPT4gVnIodCwgYywgMikgOiBkID0gKCkgPT4gKHAgJiYgcCgpLCBXbihcbiAgICB0LFxuICAgIGMsXG4gICAgMyxcbiAgICBbT11cbiAgKSkgOiAoZCA9IGl0LCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbCh0KSksIGUgJiYgcikge1xuICAgIGNvbnN0IGsgPSBkO1xuICAgIGQgPSAoKSA9PiB3cyhrKCkpO1xuICB9XG4gIGxldCBwLCBPID0gKGspID0+IHtcbiAgICBwID0gdi5vblN0b3AgPSAoKSA9PiB7XG4gICAgICBWcihrLCBjLCA0KSwgcCA9IHYub25TdG9wID0gdm9pZCAwO1xuICAgIH07XG4gIH0sIG07XG4gIGlmIChYbClcbiAgICBpZiAoTyA9IGl0LCBlID8gbiAmJiBXbihlLCBjLCAzLCBbXG4gICAgICBkKCksXG4gICAgICBoID8gW10gOiB2b2lkIDAsXG4gICAgICBPXG4gICAgXSkgOiBkKCksIGkgPT09IFwic3luY1wiKSB7XG4gICAgICBjb25zdCBrID0geU8oKTtcbiAgICAgIG0gPSBrLl9fd2F0Y2hlckhhbmRsZXMgfHwgKGsuX193YXRjaGVySGFuZGxlcyA9IFtdKTtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybiBpdDtcbiAgbGV0IHkgPSBoID8gbmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKHBjKSA6IHBjO1xuICBjb25zdCBiID0gKCkgPT4ge1xuICAgIGlmICghKCF2LmFjdGl2ZSB8fCAhdi5kaXJ0eSkpXG4gICAgICBpZiAoZSkge1xuICAgICAgICBjb25zdCBrID0gdi5ydW4oKTtcbiAgICAgICAgKHIgfHwgZiB8fCAoaCA/IGsuc29tZSgoXywgVCkgPT4gZ3IoXywgeVtUXSkpIDogZ3IoaywgeSkpKSAmJiAocCAmJiBwKCksIFduKGUsIGMsIDMsIFtcbiAgICAgICAgICBrLFxuICAgICAgICAgIC8vIHBhc3MgdW5kZWZpbmVkIGFzIHRoZSBvbGQgdmFsdWUgd2hlbiBpdCdzIGNoYW5nZWQgZm9yIHRoZSBmaXJzdCB0aW1lXG4gICAgICAgICAgeSA9PT0gcGMgPyB2b2lkIDAgOiBoICYmIHlbMF0gPT09IHBjID8gW10gOiB5LFxuICAgICAgICAgIE9cbiAgICAgICAgXSksIHkgPSBrKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICB2LnJ1bigpO1xuICB9O1xuICBiLmFsbG93UmVjdXJzZSA9ICEhZTtcbiAgbGV0IGc7XG4gIGkgPT09IFwic3luY1wiID8gZyA9IGIgOiBpID09PSBcInBvc3RcIiA/IGcgPSAoKSA9PiBZdChiLCBjICYmIGMuc3VzcGVuc2UpIDogKGIucHJlID0gITAsIGMgJiYgKGIuaWQgPSBjLnVpZCksIGcgPSAoKSA9PiBObChiKSk7XG4gIGNvbnN0IHYgPSBuZXcgQW8oZCwgaXQsIGcpLCBTID0gUmwoKSwgdyA9ICgpID0+IHtcbiAgICB2LnN0b3AoKSwgUyAmJiBGcChTLmVmZmVjdHMsIHYpO1xuICB9O1xuICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICh2Lm9uVHJhY2sgPSBvLCB2Lm9uVHJpZ2dlciA9IGEpLCBlID8gbiA/IGIoKSA6IHkgPSB2LnJ1bigpIDogaSA9PT0gXCJwb3N0XCIgPyBZdChcbiAgICB2LnJ1bi5iaW5kKHYpLFxuICAgIGMgJiYgYy5zdXNwZW5zZVxuICApIDogdi5ydW4oKSwgbSAmJiBtLnB1c2godyksIHc7XG59XG5mdW5jdGlvbiBtRSh0LCBlLCBuKSB7XG4gIGNvbnN0IHIgPSB0aGlzLnByb3h5LCBpID0gd2UodCkgPyB0LmluY2x1ZGVzKFwiLlwiKSA/IHIxKHIsIHQpIDogKCkgPT4gclt0XSA6IHQuYmluZChyLCByKTtcbiAgbGV0IHM7XG4gIGJlKGUpID8gcyA9IGUgOiAocyA9IGUuaGFuZGxlciwgbiA9IGUpO1xuICBjb25zdCBvID0gQnModGhpcyksIGEgPSBWbChpLCBzLmJpbmQociksIG4pO1xuICByZXR1cm4gbygpLCBhO1xufVxuZnVuY3Rpb24gcjEodCwgZSkge1xuICBjb25zdCBuID0gZS5zcGxpdChcIi5cIik7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbGV0IHIgPSB0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbi5sZW5ndGggJiYgcjsgaSsrKVxuICAgICAgciA9IHJbbltpXV07XG4gICAgcmV0dXJuIHI7XG4gIH07XG59XG5mdW5jdGlvbiB3cyh0LCBlLCBuID0gMCwgcikge1xuICBpZiAoIVplKHQpIHx8IHQuX192X3NraXApXG4gICAgcmV0dXJuIHQ7XG4gIGlmIChlICYmIGUgPiAwKSB7XG4gICAgaWYgKG4gPj0gZSlcbiAgICAgIHJldHVybiB0O1xuICAgIG4rKztcbiAgfVxuICBpZiAociA9IHIgfHwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSwgci5oYXModCkpXG4gICAgcmV0dXJuIHQ7XG4gIGlmIChyLmFkZCh0KSwgQ3QodCkpXG4gICAgd3ModC52YWx1ZSwgZSwgbiwgcik7XG4gIGVsc2UgaWYgKGllKHQpKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdC5sZW5ndGg7IGkrKylcbiAgICAgIHdzKHRbaV0sIGUsIG4sIHIpO1xuICBlbHNlIGlmIChHcyh0KSB8fCBDcyh0KSlcbiAgICB0LmZvckVhY2goKGkpID0+IHtcbiAgICAgIHdzKGksIGUsIG4sIHIpO1xuICAgIH0pO1xuICBlbHNlIGlmIChweSh0KSlcbiAgICBmb3IgKGNvbnN0IGkgaW4gdClcbiAgICAgIHdzKHRbaV0sIGUsIG4sIHIpO1xuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIGkxKHQpIHtcbiAgT3kodCkgJiYgSShcIkRvIG5vdCB1c2UgYnVpbHQtaW4gZGlyZWN0aXZlIGlkcyBhcyBjdXN0b20gZGlyZWN0aXZlIGlkOiBcIiArIHQpO1xufVxuZnVuY3Rpb24gWGkodCwgZSkge1xuICBpZiAoT3QgPT09IG51bGwpXG4gICAgcmV0dXJuIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBJKFwid2l0aERpcmVjdGl2ZXMgY2FuIG9ubHkgYmUgdXNlZCBpbnNpZGUgcmVuZGVyIGZ1bmN0aW9ucy5cIiksIHQ7XG4gIGNvbnN0IG4gPSBfZChPdCkgfHwgT3QucHJveHksIHIgPSB0LmRpcnMgfHwgKHQuZGlycyA9IFtdKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IFtzLCBvLCBhLCBsID0gVmVdID0gZVtpXTtcbiAgICBzICYmIChiZShzKSAmJiAocyA9IHtcbiAgICAgIG1vdW50ZWQ6IHMsXG4gICAgICB1cGRhdGVkOiBzXG4gICAgfSksIHMuZGVlcCAmJiB3cyhvKSwgci5wdXNoKHtcbiAgICAgIGRpcjogcyxcbiAgICAgIGluc3RhbmNlOiBuLFxuICAgICAgdmFsdWU6IG8sXG4gICAgICBvbGRWYWx1ZTogdm9pZCAwLFxuICAgICAgYXJnOiBhLFxuICAgICAgbW9kaWZpZXJzOiBsXG4gICAgfSkpO1xuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gX3IodCwgZSwgbiwgcikge1xuICBjb25zdCBpID0gdC5kaXJzLCBzID0gZSAmJiBlLmRpcnM7XG4gIGZvciAobGV0IG8gPSAwOyBvIDwgaS5sZW5ndGg7IG8rKykge1xuICAgIGNvbnN0IGEgPSBpW29dO1xuICAgIHMgJiYgKGEub2xkVmFsdWUgPSBzW29dLnZhbHVlKTtcbiAgICBsZXQgbCA9IGEuZGlyW3JdO1xuICAgIGwgJiYgKGRzKCksIFduKGwsIG4sIDgsIFtcbiAgICAgIHQuZWwsXG4gICAgICBhLFxuICAgICAgdCxcbiAgICAgIGVcbiAgICBdKSwgZnMoKSk7XG4gIH1cbn1cbmNvbnN0IENpID0gU3ltYm9sKFwiX2xlYXZlQ2JcIiksIE9jID0gU3ltYm9sKFwiX2VudGVyQ2JcIik7XG5mdW5jdGlvbiBTTygpIHtcbiAgY29uc3QgdCA9IHtcbiAgICBpc01vdW50ZWQ6ICExLFxuICAgIGlzTGVhdmluZzogITEsXG4gICAgaXNVbm1vdW50aW5nOiAhMSxcbiAgICBsZWF2aW5nVk5vZGVzOiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpXG4gIH07XG4gIHJldHVybiBldCgoKSA9PiB7XG4gICAgdC5pc01vdW50ZWQgPSAhMDtcbiAgfSksIElsKCgpID0+IHtcbiAgICB0LmlzVW5tb3VudGluZyA9ICEwO1xuICB9KSwgdDtcbn1cbmNvbnN0IFluID0gW0Z1bmN0aW9uLCBBcnJheV0sIHdPID0ge1xuICBtb2RlOiBTdHJpbmcsXG4gIGFwcGVhcjogQm9vbGVhbixcbiAgcGVyc2lzdGVkOiBCb29sZWFuLFxuICAvLyBlbnRlclxuICBvbkJlZm9yZUVudGVyOiBZbixcbiAgb25FbnRlcjogWW4sXG4gIG9uQWZ0ZXJFbnRlcjogWW4sXG4gIG9uRW50ZXJDYW5jZWxsZWQ6IFluLFxuICAvLyBsZWF2ZVxuICBvbkJlZm9yZUxlYXZlOiBZbixcbiAgb25MZWF2ZTogWW4sXG4gIG9uQWZ0ZXJMZWF2ZTogWW4sXG4gIG9uTGVhdmVDYW5jZWxsZWQ6IFluLFxuICAvLyBhcHBlYXJcbiAgb25CZWZvcmVBcHBlYXI6IFluLFxuICBvbkFwcGVhcjogWW4sXG4gIG9uQWZ0ZXJBcHBlYXI6IFluLFxuICBvbkFwcGVhckNhbmNlbGxlZDogWW5cbn0sIGJFID0ge1xuICBuYW1lOiBcIkJhc2VUcmFuc2l0aW9uXCIsXG4gIHByb3BzOiB3TyxcbiAgc2V0dXAodCwgeyBzbG90czogZSB9KSB7XG4gICAgY29uc3QgbiA9IGlyKCksIHIgPSBTTygpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjb25zdCBpID0gZS5kZWZhdWx0ICYmIFNkKGUuZGVmYXVsdCgpLCAhMCk7XG4gICAgICBpZiAoIWkgfHwgIWkubGVuZ3RoKVxuICAgICAgICByZXR1cm47XG4gICAgICBsZXQgcyA9IGlbMF07XG4gICAgICBpZiAoaS5sZW5ndGggPiAxKSB7XG4gICAgICAgIGxldCBmID0gITE7XG4gICAgICAgIGZvciAoY29uc3QgaCBvZiBpKVxuICAgICAgICAgIGlmIChoLnR5cGUgIT09IF90KSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGYpIHtcbiAgICAgICAgICAgICAgSShcbiAgICAgICAgICAgICAgICBcIjx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQgb3IgY29tcG9uZW50LiBVc2UgPHRyYW5zaXRpb24tZ3JvdXA+IGZvciBsaXN0cy5cIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzID0gaCwgZiA9ICEwLCBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IG8gPSBPZSh0KSwgeyBtb2RlOiBhIH0gPSBvO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBhICYmIGEgIT09IFwiaW4tb3V0XCIgJiYgYSAhPT0gXCJvdXQtaW5cIiAmJiBhICE9PSBcImRlZmF1bHRcIiAmJiBJKGBpbnZhbGlkIDx0cmFuc2l0aW9uPiBtb2RlOiAke2F9YCksIHIuaXNMZWF2aW5nKVxuICAgICAgICByZXR1cm4gYWYocyk7XG4gICAgICBjb25zdCBsID0geG0ocyk7XG4gICAgICBpZiAoIWwpXG4gICAgICAgIHJldHVybiBhZihzKTtcbiAgICAgIGNvbnN0IGMgPSBSbyhcbiAgICAgICAgbCxcbiAgICAgICAgbyxcbiAgICAgICAgcixcbiAgICAgICAgblxuICAgICAgKTtcbiAgICAgIFhzKGwsIGMpO1xuICAgICAgY29uc3QgdSA9IG4uc3ViVHJlZSwgZCA9IHUgJiYgeG0odSk7XG4gICAgICBpZiAoZCAmJiBkLnR5cGUgIT09IF90ICYmICFscihsLCBkKSkge1xuICAgICAgICBjb25zdCBmID0gUm8oXG4gICAgICAgICAgZCxcbiAgICAgICAgICBvLFxuICAgICAgICAgIHIsXG4gICAgICAgICAgblxuICAgICAgICApO1xuICAgICAgICBpZiAoWHMoZCwgZiksIGEgPT09IFwib3V0LWluXCIpXG4gICAgICAgICAgcmV0dXJuIHIuaXNMZWF2aW5nID0gITAsIGYuYWZ0ZXJMZWF2ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHIuaXNMZWF2aW5nID0gITEsIG4udXBkYXRlLmFjdGl2ZSAhPT0gITEgJiYgKG4uZWZmZWN0LmRpcnR5ID0gITAsIG4udXBkYXRlKCkpO1xuICAgICAgICAgIH0sIGFmKHMpO1xuICAgICAgICBhID09PSBcImluLW91dFwiICYmIGwudHlwZSAhPT0gX3QgJiYgKGYuZGVsYXlMZWF2ZSA9IChoLCBwLCBPKSA9PiB7XG4gICAgICAgICAgY29uc3QgbSA9IG8xKFxuICAgICAgICAgICAgcixcbiAgICAgICAgICAgIGRcbiAgICAgICAgICApO1xuICAgICAgICAgIG1bU3RyaW5nKGQua2V5KV0gPSBkLCBoW0NpXSA9ICgpID0+IHtcbiAgICAgICAgICAgIHAoKSwgaFtDaV0gPSB2b2lkIDAsIGRlbGV0ZSBjLmRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgICB9LCBjLmRlbGF5ZWRMZWF2ZSA9IE87XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHM7XG4gICAgfTtcbiAgfVxufSwgczEgPSBiRTtcbmZ1bmN0aW9uIG8xKHQsIGUpIHtcbiAgY29uc3QgeyBsZWF2aW5nVk5vZGVzOiBuIH0gPSB0O1xuICBsZXQgciA9IG4uZ2V0KGUudHlwZSk7XG4gIHJldHVybiByIHx8IChyID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIG4uc2V0KGUudHlwZSwgcikpLCByO1xufVxuZnVuY3Rpb24gUm8odCwgZSwgbiwgcikge1xuICBjb25zdCB7XG4gICAgYXBwZWFyOiBpLFxuICAgIG1vZGU6IHMsXG4gICAgcGVyc2lzdGVkOiBvID0gITEsXG4gICAgb25CZWZvcmVFbnRlcjogYSxcbiAgICBvbkVudGVyOiBsLFxuICAgIG9uQWZ0ZXJFbnRlcjogYyxcbiAgICBvbkVudGVyQ2FuY2VsbGVkOiB1LFxuICAgIG9uQmVmb3JlTGVhdmU6IGQsXG4gICAgb25MZWF2ZTogZixcbiAgICBvbkFmdGVyTGVhdmU6IGgsXG4gICAgb25MZWF2ZUNhbmNlbGxlZDogcCxcbiAgICBvbkJlZm9yZUFwcGVhcjogTyxcbiAgICBvbkFwcGVhcjogbSxcbiAgICBvbkFmdGVyQXBwZWFyOiB5LFxuICAgIG9uQXBwZWFyQ2FuY2VsbGVkOiBiXG4gIH0gPSBlLCBnID0gU3RyaW5nKHQua2V5KSwgdiA9IG8xKG4sIHQpLCBTID0gKF8sIFQpID0+IHtcbiAgICBfICYmIFduKFxuICAgICAgXyxcbiAgICAgIHIsXG4gICAgICA5LFxuICAgICAgVFxuICAgICk7XG4gIH0sIHcgPSAoXywgVCkgPT4ge1xuICAgIGNvbnN0IEMgPSBUWzFdO1xuICAgIFMoXywgVCksIGllKF8pID8gXy5ldmVyeSgoQSkgPT4gQS5sZW5ndGggPD0gMSkgJiYgQygpIDogXy5sZW5ndGggPD0gMSAmJiBDKCk7XG4gIH0sIGsgPSB7XG4gICAgbW9kZTogcyxcbiAgICBwZXJzaXN0ZWQ6IG8sXG4gICAgYmVmb3JlRW50ZXIoXykge1xuICAgICAgbGV0IFQgPSBhO1xuICAgICAgaWYgKCFuLmlzTW91bnRlZClcbiAgICAgICAgaWYgKGkpXG4gICAgICAgICAgVCA9IE8gfHwgYTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIF9bQ2ldICYmIF9bQ2ldKFxuICAgICAgICAhMFxuICAgICAgICAvKiBjYW5jZWxsZWQgKi9cbiAgICAgICk7XG4gICAgICBjb25zdCBDID0gdltnXTtcbiAgICAgIEMgJiYgbHIodCwgQykgJiYgQy5lbFtDaV0gJiYgQy5lbFtDaV0oKSwgUyhULCBbX10pO1xuICAgIH0sXG4gICAgZW50ZXIoXykge1xuICAgICAgbGV0IFQgPSBsLCBDID0gYywgQSA9IHU7XG4gICAgICBpZiAoIW4uaXNNb3VudGVkKVxuICAgICAgICBpZiAoaSlcbiAgICAgICAgICBUID0gbSB8fCBsLCBDID0geSB8fCBjLCBBID0gYiB8fCB1O1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgbGV0IFEgPSAhMTtcbiAgICAgIGNvbnN0IFcgPSBfW09jXSA9IChMKSA9PiB7XG4gICAgICAgIFEgfHwgKFEgPSAhMCwgTCA/IFMoQSwgW19dKSA6IFMoQywgW19dKSwgay5kZWxheWVkTGVhdmUgJiYgay5kZWxheWVkTGVhdmUoKSwgX1tPY10gPSB2b2lkIDApO1xuICAgICAgfTtcbiAgICAgIFQgPyB3KFQsIFtfLCBXXSkgOiBXKCk7XG4gICAgfSxcbiAgICBsZWF2ZShfLCBUKSB7XG4gICAgICBjb25zdCBDID0gU3RyaW5nKHQua2V5KTtcbiAgICAgIGlmIChfW09jXSAmJiBfW09jXShcbiAgICAgICAgITBcbiAgICAgICAgLyogY2FuY2VsbGVkICovXG4gICAgICApLCBuLmlzVW5tb3VudGluZylcbiAgICAgICAgcmV0dXJuIFQoKTtcbiAgICAgIFMoZCwgW19dKTtcbiAgICAgIGxldCBBID0gITE7XG4gICAgICBjb25zdCBRID0gX1tDaV0gPSAoVykgPT4ge1xuICAgICAgICBBIHx8IChBID0gITAsIFQoKSwgVyA/IFMocCwgW19dKSA6IFMoaCwgW19dKSwgX1tDaV0gPSB2b2lkIDAsIHZbQ10gPT09IHQgJiYgZGVsZXRlIHZbQ10pO1xuICAgICAgfTtcbiAgICAgIHZbQ10gPSB0LCBmID8gdyhmLCBbXywgUV0pIDogUSgpO1xuICAgIH0sXG4gICAgY2xvbmUoXykge1xuICAgICAgcmV0dXJuIFJvKF8sIGUsIG4sIHIpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGs7XG59XG5mdW5jdGlvbiBhZih0KSB7XG4gIGlmICh0YSh0KSlcbiAgICByZXR1cm4gdCA9IGpuKHQpLCB0LmNoaWxkcmVuID0gbnVsbCwgdDtcbn1cbmZ1bmN0aW9uIHhtKHQpIHtcbiAgcmV0dXJuIHRhKHQpID8gKFxuICAgIC8vICM3MTIxIGVuc3VyZSBnZXQgdGhlIGNoaWxkIGNvbXBvbmVudCBzdWJ0cmVlIGluIGNhc2VcbiAgICAvLyBpdCdzIGJlZW4gcmVwbGFjZWQgZHVyaW5nIEhNUlxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB0LmNvbXBvbmVudCA/IHQuY29tcG9uZW50LnN1YlRyZWUgOiB0LmNoaWxkcmVuID8gdC5jaGlsZHJlblswXSA6IHZvaWQgMFxuICApIDogdDtcbn1cbmZ1bmN0aW9uIFhzKHQsIGUpIHtcbiAgdC5zaGFwZUZsYWcgJiA2ICYmIHQuY29tcG9uZW50ID8gWHModC5jb21wb25lbnQuc3ViVHJlZSwgZSkgOiB0LnNoYXBlRmxhZyAmIDEyOCA/ICh0LnNzQ29udGVudC50cmFuc2l0aW9uID0gZS5jbG9uZSh0LnNzQ29udGVudCksIHQuc3NGYWxsYmFjay50cmFuc2l0aW9uID0gZS5jbG9uZSh0LnNzRmFsbGJhY2spKSA6IHQudHJhbnNpdGlvbiA9IGU7XG59XG5mdW5jdGlvbiBTZCh0LCBlID0gITEsIG4pIHtcbiAgbGV0IHIgPSBbXSwgaSA9IDA7XG4gIGZvciAobGV0IHMgPSAwOyBzIDwgdC5sZW5ndGg7IHMrKykge1xuICAgIGxldCBvID0gdFtzXTtcbiAgICBjb25zdCBhID0gbiA9PSBudWxsID8gby5rZXkgOiBTdHJpbmcobikgKyBTdHJpbmcoby5rZXkgIT0gbnVsbCA/IG8ua2V5IDogcyk7XG4gICAgby50eXBlID09PSBQZSA/IChvLnBhdGNoRmxhZyAmIDEyOCAmJiBpKyssIHIgPSByLmNvbmNhdChcbiAgICAgIFNkKG8uY2hpbGRyZW4sIGUsIGEpXG4gICAgKSkgOiAoZSB8fCBvLnR5cGUgIT09IF90KSAmJiByLnB1c2goYSAhPSBudWxsID8gam4obywgeyBrZXk6IGEgfSkgOiBvKTtcbiAgfVxuICBpZiAoaSA+IDEpXG4gICAgZm9yIChsZXQgcyA9IDA7IHMgPCByLmxlbmd0aDsgcysrKVxuICAgICAgcltzXS5wYXRjaEZsYWcgPSAtMjtcbiAgcmV0dXJuIHI7XG59XG4vKiEgI19fTk9fU0lERV9FRkZFQ1RTX18gKi9cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5mdW5jdGlvbiBsZSh0LCBlKSB7XG4gIHJldHVybiBiZSh0KSA/IChcbiAgICAvLyAjODMyNjogZXh0ZW5kIGNhbGwgYW5kIG9wdGlvbnMubmFtZSBhY2Nlc3MgYXJlIGNvbnNpZGVyZWQgc2lkZS1lZmZlY3RzXG4gICAgLy8gYnkgUm9sbHVwLCBzbyB3ZSBoYXZlIHRvIHdyYXAgaXQgaW4gYSBwdXJlLWFubm90YXRlZCBJSUZFLlxuICAgICRlKHsgbmFtZTogdC5uYW1lIH0sIGUsIHsgc2V0dXA6IHQgfSlcbiAgKSA6IHQ7XG59XG5jb25zdCBEcyA9ICh0KSA9PiAhIXQudHlwZS5fX2FzeW5jTG9hZGVyO1xuLyohICNfX05PX1NJREVfRUZGRUNUU19fICovXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZnVuY3Rpb24gYTEodCkge1xuICBiZSh0KSAmJiAodCA9IHsgbG9hZGVyOiB0IH0pO1xuICBjb25zdCB7XG4gICAgbG9hZGVyOiBlLFxuICAgIGxvYWRpbmdDb21wb25lbnQ6IG4sXG4gICAgZXJyb3JDb21wb25lbnQ6IHIsXG4gICAgZGVsYXk6IGkgPSAyMDAsXG4gICAgdGltZW91dDogcyxcbiAgICAvLyB1bmRlZmluZWQgPSBuZXZlciB0aW1lcyBvdXRcbiAgICBzdXNwZW5zaWJsZTogbyA9ICEwLFxuICAgIG9uRXJyb3I6IGFcbiAgfSA9IHQ7XG4gIGxldCBsID0gbnVsbCwgYywgdSA9IDA7XG4gIGNvbnN0IGQgPSAoKSA9PiAodSsrLCBsID0gbnVsbCwgZigpKSwgZiA9ICgpID0+IHtcbiAgICBsZXQgaDtcbiAgICByZXR1cm4gbCB8fCAoaCA9IGwgPSBlKCkuY2F0Y2goKHApID0+IHtcbiAgICAgIGlmIChwID0gcCBpbnN0YW5jZW9mIEVycm9yID8gcCA6IG5ldyBFcnJvcihTdHJpbmcocCkpLCBhKVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKE8sIG0pID0+IHtcbiAgICAgICAgICBhKHAsICgpID0+IE8oZCgpKSwgKCkgPT4gbShwKSwgdSArIDEpO1xuICAgICAgICB9KTtcbiAgICAgIHRocm93IHA7XG4gICAgfSkudGhlbigocCkgPT4ge1xuICAgICAgaWYgKGggIT09IGwgJiYgbClcbiAgICAgICAgcmV0dXJuIGw7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFwICYmIEkoXG4gICAgICAgIFwiQXN5bmMgY29tcG9uZW50IGxvYWRlciByZXNvbHZlZCB0byB1bmRlZmluZWQuIElmIHlvdSBhcmUgdXNpbmcgcmV0cnkoKSwgbWFrZSBzdXJlIHRvIHJldHVybiBpdHMgcmV0dXJuIHZhbHVlLlwiXG4gICAgICApLCBwICYmIChwLl9fZXNNb2R1bGUgfHwgcFtTeW1ib2wudG9TdHJpbmdUYWddID09PSBcIk1vZHVsZVwiKSAmJiAocCA9IHAuZGVmYXVsdCksIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBwICYmICFaZShwKSAmJiAhYmUocCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBhc3luYyBjb21wb25lbnQgbG9hZCByZXN1bHQ6ICR7cH1gKTtcbiAgICAgIHJldHVybiBjID0gcCwgcDtcbiAgICB9KSk7XG4gIH07XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gbGUoe1xuICAgIG5hbWU6IFwiQXN5bmNDb21wb25lbnRXcmFwcGVyXCIsXG4gICAgX19hc3luY0xvYWRlcjogZixcbiAgICBnZXQgX19hc3luY1Jlc29sdmVkKCkge1xuICAgICAgcmV0dXJuIGM7XG4gICAgfSxcbiAgICBzZXR1cCgpIHtcbiAgICAgIGNvbnN0IGggPSB4dDtcbiAgICAgIGlmIChjKVxuICAgICAgICByZXR1cm4gKCkgPT4gbGYoYywgaCk7XG4gICAgICBjb25zdCBwID0gKGIpID0+IHtcbiAgICAgICAgbCA9IG51bGwsIGhzKFxuICAgICAgICAgIGIsXG4gICAgICAgICAgaCxcbiAgICAgICAgICAxMyxcbiAgICAgICAgICAhclxuICAgICAgICApO1xuICAgICAgfTtcbiAgICAgIGlmIChvICYmIGguc3VzcGVuc2UgfHwgWGwpXG4gICAgICAgIHJldHVybiBmKCkudGhlbigoYikgPT4gKCkgPT4gbGYoYiwgaCkpLmNhdGNoKChiKSA9PiAocChiKSwgKCkgPT4gciA/IEoociwge1xuICAgICAgICAgIGVycm9yOiBiXG4gICAgICAgIH0pIDogbnVsbCkpO1xuICAgICAgY29uc3QgTyA9IEcoITEpLCBtID0gRygpLCB5ID0gRyghIWkpO1xuICAgICAgcmV0dXJuIGkgJiYgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHkudmFsdWUgPSAhMTtcbiAgICAgIH0sIGkpLCBzICE9IG51bGwgJiYgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICghTy52YWx1ZSAmJiAhbS52YWx1ZSkge1xuICAgICAgICAgIGNvbnN0IGIgPSBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgQXN5bmMgY29tcG9uZW50IHRpbWVkIG91dCBhZnRlciAke3N9bXMuYFxuICAgICAgICAgICk7XG4gICAgICAgICAgcChiKSwgbS52YWx1ZSA9IGI7XG4gICAgICAgIH1cbiAgICAgIH0sIHMpLCBmKCkudGhlbigoKSA9PiB7XG4gICAgICAgIE8udmFsdWUgPSAhMCwgaC5wYXJlbnQgJiYgdGEoaC5wYXJlbnQudm5vZGUpICYmIChoLnBhcmVudC5lZmZlY3QuZGlydHkgPSAhMCwgTmwoaC5wYXJlbnQudXBkYXRlKSk7XG4gICAgICB9KS5jYXRjaCgoYikgPT4ge1xuICAgICAgICBwKGIpLCBtLnZhbHVlID0gYjtcbiAgICAgIH0pLCAoKSA9PiB7XG4gICAgICAgIGlmIChPLnZhbHVlICYmIGMpXG4gICAgICAgICAgcmV0dXJuIGxmKGMsIGgpO1xuICAgICAgICBpZiAobS52YWx1ZSAmJiByKVxuICAgICAgICAgIHJldHVybiBKKHIsIHtcbiAgICAgICAgICAgIGVycm9yOiBtLnZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIGlmIChuICYmICF5LnZhbHVlKVxuICAgICAgICAgIHJldHVybiBKKG4pO1xuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gbGYodCwgZSkge1xuICBjb25zdCB7IHJlZjogbiwgcHJvcHM6IHIsIGNoaWxkcmVuOiBpLCBjZTogcyB9ID0gZS52bm9kZSwgbyA9IEoodCwgciwgaSk7XG4gIHJldHVybiBvLnJlZiA9IG4sIG8uY2UgPSBzLCBkZWxldGUgZS52bm9kZS5jZSwgbztcbn1cbmNvbnN0IHRhID0gKHQpID0+IHQudHlwZS5fX2lzS2VlcEFsaXZlLCB2RSA9IHtcbiAgbmFtZTogXCJLZWVwQWxpdmVcIixcbiAgLy8gTWFya2VyIGZvciBzcGVjaWFsIGhhbmRsaW5nIGluc2lkZSB0aGUgcmVuZGVyZXIuIFdlIGFyZSBub3QgdXNpbmcgYSA9PT1cbiAgLy8gY2hlY2sgZGlyZWN0bHkgb24gS2VlcEFsaXZlIGluIHRoZSByZW5kZXJlciwgYmVjYXVzZSBpbXBvcnRpbmcgaXQgZGlyZWN0bHlcbiAgLy8gd291bGQgcHJldmVudCBpdCBmcm9tIGJlaW5nIHRyZWUtc2hha2VuLlxuICBfX2lzS2VlcEFsaXZlOiAhMCxcbiAgcHJvcHM6IHtcbiAgICBpbmNsdWRlOiBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XSxcbiAgICBleGNsdWRlOiBbU3RyaW5nLCBSZWdFeHAsIEFycmF5XSxcbiAgICBtYXg6IFtTdHJpbmcsIE51bWJlcl1cbiAgfSxcbiAgc2V0dXAodCwgeyBzbG90czogZSB9KSB7XG4gICAgY29uc3QgbiA9IGlyKCksIHIgPSBuLmN0eDtcbiAgICBpZiAoIXIucmVuZGVyZXIpXG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb25zdCBiID0gZS5kZWZhdWx0ICYmIGUuZGVmYXVsdCgpO1xuICAgICAgICByZXR1cm4gYiAmJiBiLmxlbmd0aCA9PT0gMSA/IGJbMF0gOiBiO1xuICAgICAgfTtcbiAgICBjb25zdCBpID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgbGV0IG8gPSBudWxsO1xuICAgIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSAmJiAobi5fX3ZfY2FjaGUgPSBpKTtcbiAgICBjb25zdCBhID0gbi5zdXNwZW5zZSwge1xuICAgICAgcmVuZGVyZXI6IHtcbiAgICAgICAgcDogbCxcbiAgICAgICAgbTogYyxcbiAgICAgICAgdW06IHUsXG4gICAgICAgIG86IHsgY3JlYXRlRWxlbWVudDogZCB9XG4gICAgICB9XG4gICAgfSA9IHIsIGYgPSBkKFwiZGl2XCIpO1xuICAgIHIuYWN0aXZhdGUgPSAoYiwgZywgdiwgUywgdykgPT4ge1xuICAgICAgY29uc3QgayA9IGIuY29tcG9uZW50O1xuICAgICAgYyhiLCBnLCB2LCAwLCBhKSwgbChcbiAgICAgICAgay52bm9kZSxcbiAgICAgICAgYixcbiAgICAgICAgZyxcbiAgICAgICAgdixcbiAgICAgICAgayxcbiAgICAgICAgYSxcbiAgICAgICAgUyxcbiAgICAgICAgYi5zbG90U2NvcGVJZHMsXG4gICAgICAgIHdcbiAgICAgICksIFl0KCgpID0+IHtcbiAgICAgICAgay5pc0RlYWN0aXZhdGVkID0gITEsIGsuYSAmJiBJaShrLmEpO1xuICAgICAgICBjb25zdCBfID0gYi5wcm9wcyAmJiBiLnByb3BzLm9uVm5vZGVNb3VudGVkO1xuICAgICAgICBfICYmIHluKF8sIGsucGFyZW50LCBiKTtcbiAgICAgIH0sIGEpLCAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykgJiYgdWgoayk7XG4gICAgfSwgci5kZWFjdGl2YXRlID0gKGIpID0+IHtcbiAgICAgIGNvbnN0IGcgPSBiLmNvbXBvbmVudDtcbiAgICAgIGMoYiwgZiwgbnVsbCwgMSwgYSksIFl0KCgpID0+IHtcbiAgICAgICAgZy5kYSAmJiBJaShnLmRhKTtcbiAgICAgICAgY29uc3QgdiA9IGIucHJvcHMgJiYgYi5wcm9wcy5vblZub2RlVW5tb3VudGVkO1xuICAgICAgICB2ICYmIHluKHYsIGcucGFyZW50LCBiKSwgZy5pc0RlYWN0aXZhdGVkID0gITA7XG4gICAgICB9LCBhKSwgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pICYmIHVoKGcpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gaChiKSB7XG4gICAgICBjZihiKSwgdShiLCBuLCBhLCAhMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHAoYikge1xuICAgICAgaS5mb3JFYWNoKChnLCB2KSA9PiB7XG4gICAgICAgIGNvbnN0IFMgPSBhbChnLnR5cGUpO1xuICAgICAgICBTICYmICghYiB8fCAhYihTKSkgJiYgTyh2KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBPKGIpIHtcbiAgICAgIGNvbnN0IGcgPSBpLmdldChiKTtcbiAgICAgICFvIHx8ICFscihnLCBvKSA/IGgoZykgOiBvICYmIGNmKG8pLCBpLmRlbGV0ZShiKSwgcy5kZWxldGUoYik7XG4gICAgfVxuICAgIGh0KFxuICAgICAgKCkgPT4gW3QuaW5jbHVkZSwgdC5leGNsdWRlXSxcbiAgICAgIChbYiwgZ10pID0+IHtcbiAgICAgICAgYiAmJiBwKCh2KSA9PiBRYShiLCB2KSksIGcgJiYgcCgodikgPT4gIVFhKGcsIHYpKTtcbiAgICAgIH0sXG4gICAgICAvLyBwcnVuZSBwb3N0LXJlbmRlciBhZnRlciBgY3VycmVudGAgaGFzIGJlZW4gdXBkYXRlZFxuICAgICAgeyBmbHVzaDogXCJwb3N0XCIsIGRlZXA6ICEwIH1cbiAgICApO1xuICAgIGxldCBtID0gbnVsbDtcbiAgICBjb25zdCB5ID0gKCkgPT4ge1xuICAgICAgbSAhPSBudWxsICYmIGkuc2V0KG0sIHVmKG4uc3ViVHJlZSkpO1xuICAgIH07XG4gICAgcmV0dXJuIGV0KHkpLCBrZCh5KSwgSWwoKCkgPT4ge1xuICAgICAgaS5mb3JFYWNoKChiKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgc3ViVHJlZTogZywgc3VzcGVuc2U6IHYgfSA9IG4sIFMgPSB1ZihnKTtcbiAgICAgICAgaWYgKGIudHlwZSA9PT0gUy50eXBlICYmIGIua2V5ID09PSBTLmtleSkge1xuICAgICAgICAgIGNmKFMpO1xuICAgICAgICAgIGNvbnN0IHcgPSBTLmNvbXBvbmVudC5kYTtcbiAgICAgICAgICB3ICYmIFl0KHcsIHYpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBoKGIpO1xuICAgICAgfSk7XG4gICAgfSksICgpID0+IHtcbiAgICAgIGlmIChtID0gbnVsbCwgIWUuZGVmYXVsdClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjb25zdCBiID0gZS5kZWZhdWx0KCksIGcgPSBiWzBdO1xuICAgICAgaWYgKGIubGVuZ3RoID4gMSlcbiAgICAgICAgcmV0dXJuIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBJKFwiS2VlcEFsaXZlIHNob3VsZCBjb250YWluIGV4YWN0bHkgb25lIGNvbXBvbmVudCBjaGlsZC5cIiksIG8gPSBudWxsLCBiO1xuICAgICAgaWYgKCFsaShnKSB8fCAhKGcuc2hhcGVGbGFnICYgNCkgJiYgIShnLnNoYXBlRmxhZyAmIDEyOCkpXG4gICAgICAgIHJldHVybiBvID0gbnVsbCwgZztcbiAgICAgIGxldCB2ID0gdWYoZyk7XG4gICAgICBjb25zdCBTID0gdi50eXBlLCB3ID0gYWwoXG4gICAgICAgIERzKHYpID8gdi50eXBlLl9fYXN5bmNSZXNvbHZlZCB8fCB7fSA6IFNcbiAgICAgICksIHsgaW5jbHVkZTogaywgZXhjbHVkZTogXywgbWF4OiBUIH0gPSB0O1xuICAgICAgaWYgKGsgJiYgKCF3IHx8ICFRYShrLCB3KSkgfHwgXyAmJiB3ICYmIFFhKF8sIHcpKVxuICAgICAgICByZXR1cm4gbyA9IHYsIGc7XG4gICAgICBjb25zdCBDID0gdi5rZXkgPT0gbnVsbCA/IFMgOiB2LmtleSwgQSA9IGkuZ2V0KEMpO1xuICAgICAgcmV0dXJuIHYuZWwgJiYgKHYgPSBqbih2KSwgZy5zaGFwZUZsYWcgJiAxMjggJiYgKGcuc3NDb250ZW50ID0gdikpLCBtID0gQywgQSA/ICh2LmVsID0gQS5lbCwgdi5jb21wb25lbnQgPSBBLmNvbXBvbmVudCwgdi50cmFuc2l0aW9uICYmIFhzKHYsIHYudHJhbnNpdGlvbiksIHYuc2hhcGVGbGFnIHw9IDUxMiwgcy5kZWxldGUoQyksIHMuYWRkKEMpKSA6IChzLmFkZChDKSwgVCAmJiBzLnNpemUgPiBwYXJzZUludChULCAxMCkgJiYgTyhzLnZhbHVlcygpLm5leHQoKS52YWx1ZSkpLCB2LnNoYXBlRmxhZyB8PSAyNTYsIG8gPSB2LCBLeShnLnR5cGUpID8gZyA6IHY7XG4gICAgfTtcbiAgfVxufSwgeUUgPSB2RTtcbmZ1bmN0aW9uIFFhKHQsIGUpIHtcbiAgcmV0dXJuIGllKHQpID8gdC5zb21lKChuKSA9PiBRYShuLCBlKSkgOiB3ZSh0KSA/IHQuc3BsaXQoXCIsXCIpLmluY2x1ZGVzKGUpIDogTl8odCkgPyB0LnRlc3QoZSkgOiAhMTtcbn1cbmZ1bmN0aW9uIGwxKHQsIGUpIHtcbiAgdTEodCwgXCJhXCIsIGUpO1xufVxuZnVuY3Rpb24gYzEodCwgZSkge1xuICB1MSh0LCBcImRhXCIsIGUpO1xufVxuZnVuY3Rpb24gdTEodCwgZSwgbiA9IHh0KSB7XG4gIGNvbnN0IHIgPSB0Ll9fd2RjIHx8ICh0Ll9fd2RjID0gKCkgPT4ge1xuICAgIGxldCBpID0gbjtcbiAgICBmb3IgKDsgaTsgKSB7XG4gICAgICBpZiAoaS5pc0RlYWN0aXZhdGVkKVxuICAgICAgICByZXR1cm47XG4gICAgICBpID0gaS5wYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiB0KCk7XG4gIH0pO1xuICBpZiAod2QoZSwgciwgbiksIG4pIHtcbiAgICBsZXQgaSA9IG4ucGFyZW50O1xuICAgIGZvciAoOyBpICYmIGkucGFyZW50OyApXG4gICAgICB0YShpLnBhcmVudC52bm9kZSkgJiYgU0UociwgZSwgbiwgaSksIGkgPSBpLnBhcmVudDtcbiAgfVxufVxuZnVuY3Rpb24gU0UodCwgZSwgbiwgcikge1xuICBjb25zdCBpID0gd2QoXG4gICAgZSxcbiAgICB0LFxuICAgIHIsXG4gICAgITBcbiAgICAvKiBwcmVwZW5kICovXG4gICk7XG4gIGp0KCgpID0+IHtcbiAgICBGcChyW2VdLCBpKTtcbiAgfSwgbik7XG59XG5mdW5jdGlvbiBjZih0KSB7XG4gIHQuc2hhcGVGbGFnICY9IC0yNTcsIHQuc2hhcGVGbGFnICY9IC01MTM7XG59XG5mdW5jdGlvbiB1Zih0KSB7XG4gIHJldHVybiB0LnNoYXBlRmxhZyAmIDEyOCA/IHQuc3NDb250ZW50IDogdDtcbn1cbmZ1bmN0aW9uIHdkKHQsIGUsIG4gPSB4dCwgciA9ICExKSB7XG4gIGlmIChuKSB7XG4gICAgY29uc3QgaSA9IG5bdF0gfHwgKG5bdF0gPSBbXSksIHMgPSBlLl9fd2VoIHx8IChlLl9fd2VoID0gKC4uLm8pID0+IHtcbiAgICAgIGlmIChuLmlzVW5tb3VudGVkKVxuICAgICAgICByZXR1cm47XG4gICAgICBkcygpO1xuICAgICAgY29uc3QgYSA9IEJzKG4pLCBsID0gV24oZSwgbiwgdCwgbyk7XG4gICAgICByZXR1cm4gYSgpLCBmcygpLCBsO1xuICAgIH0pO1xuICAgIHJldHVybiByID8gaS51bnNoaWZ0KHMpIDogaS5wdXNoKHMpLCBzO1xuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGNvbnN0IGkgPSBUcihtZFt0XS5yZXBsYWNlKC8gaG9vayQvLCBcIlwiKSk7XG4gICAgSShcbiAgICAgIGAke2l9IGlzIGNhbGxlZCB3aGVuIHRoZXJlIGlzIG5vIGFjdGl2ZSBjb21wb25lbnQgaW5zdGFuY2UgdG8gYmUgYXNzb2NpYXRlZCB3aXRoLiBMaWZlY3ljbGUgaW5qZWN0aW9uIEFQSXMgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgZXhlY3V0aW9uIG9mIHNldHVwKCkuIElmIHlvdSBhcmUgdXNpbmcgYXN5bmMgc2V0dXAoKSwgbWFrZSBzdXJlIHRvIHJlZ2lzdGVyIGxpZmVjeWNsZSBob29rcyBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0IHN0YXRlbWVudC5gXG4gICAgKTtcbiAgfVxufVxuY29uc3QgZ2kgPSAodCkgPT4gKGUsIG4gPSB4dCkgPT4gKFxuICAvLyBwb3N0LWNyZWF0ZSBsaWZlY3ljbGUgcmVnaXN0cmF0aW9ucyBhcmUgbm9vcHMgZHVyaW5nIFNTUiAoZXhjZXB0IGZvciBzZXJ2ZXJQcmVmZXRjaClcbiAgKCFYbCB8fCB0ID09PSBcInNwXCIpICYmIHdkKHQsICguLi5yKSA9PiBlKC4uLnIpLCBuKVxuKSwgZDEgPSBnaShcImJtXCIpLCBldCA9IGdpKFwibVwiKSwgZjEgPSBnaShcImJ1XCIpLCBrZCA9IGdpKFwidVwiKSwgSWwgPSBnaShcImJ1bVwiKSwganQgPSBnaShcInVtXCIpLCB4ZCA9IGdpKFwic3BcIiksIGgxID0gZ2koXG4gIFwicnRnXCJcbiksIHAxID0gZ2koXG4gIFwicnRjXCJcbik7XG5mdW5jdGlvbiBPMSh0LCBlID0geHQpIHtcbiAgd2QoXCJlY1wiLCB0LCBlKTtcbn1cbmZ1bmN0aW9uIFhyKHQsIGUsIG4sIHIpIHtcbiAgbGV0IGk7XG4gIGNvbnN0IHMgPSBuICYmIG5bcl07XG4gIGlmIChpZSh0KSB8fCB3ZSh0KSkge1xuICAgIGkgPSBuZXcgQXJyYXkodC5sZW5ndGgpO1xuICAgIGZvciAobGV0IG8gPSAwLCBhID0gdC5sZW5ndGg7IG8gPCBhOyBvKyspXG4gICAgICBpW29dID0gZSh0W29dLCBvLCB2b2lkIDAsIHMgJiYgc1tvXSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHQgPT0gXCJudW1iZXJcIikge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhTnVtYmVyLmlzSW50ZWdlcih0KSAmJiBJKGBUaGUgdi1mb3IgcmFuZ2UgZXhwZWN0IGFuIGludGVnZXIgdmFsdWUgYnV0IGdvdCAke3R9LmApLCBpID0gbmV3IEFycmF5KHQpO1xuICAgIGZvciAobGV0IG8gPSAwOyBvIDwgdDsgbysrKVxuICAgICAgaVtvXSA9IGUobyArIDEsIG8sIHZvaWQgMCwgcyAmJiBzW29dKTtcbiAgfSBlbHNlIGlmIChaZSh0KSlcbiAgICBpZiAodFtTeW1ib2wuaXRlcmF0b3JdKVxuICAgICAgaSA9IEFycmF5LmZyb20oXG4gICAgICAgIHQsXG4gICAgICAgIChvLCBhKSA9PiBlKG8sIGEsIHZvaWQgMCwgcyAmJiBzW2FdKVxuICAgICAgKTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IG8gPSBPYmplY3Qua2V5cyh0KTtcbiAgICAgIGkgPSBuZXcgQXJyYXkoby5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgYSA9IDAsIGwgPSBvLmxlbmd0aDsgYSA8IGw7IGErKykge1xuICAgICAgICBjb25zdCBjID0gb1thXTtcbiAgICAgICAgaVthXSA9IGUodFtjXSwgYywgYSwgcyAmJiBzW2FdKTtcbiAgICAgIH1cbiAgICB9XG4gIGVsc2VcbiAgICBpID0gW107XG4gIHJldHVybiBuICYmIChuW3JdID0gaSksIGk7XG59XG5mdW5jdGlvbiB3RSh0LCBlKSB7XG4gIGZvciAobGV0IG4gPSAwOyBuIDwgZS5sZW5ndGg7IG4rKykge1xuICAgIGNvbnN0IHIgPSBlW25dO1xuICAgIGlmIChpZShyKSlcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgci5sZW5ndGg7IGkrKylcbiAgICAgICAgdFtyW2ldLm5hbWVdID0gcltpXS5mbjtcbiAgICBlbHNlXG4gICAgICByICYmICh0W3IubmFtZV0gPSByLmtleSA/ICguLi5pKSA9PiB7XG4gICAgICAgIGNvbnN0IHMgPSByLmZuKC4uLmkpO1xuICAgICAgICByZXR1cm4gcyAmJiAocy5rZXkgPSByLmtleSksIHM7XG4gICAgICB9IDogci5mbik7XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBwdCh0LCBlLCBuID0ge30sIHIsIGkpIHtcbiAgaWYgKE90LmlzQ0UgfHwgT3QucGFyZW50ICYmIERzKE90LnBhcmVudCkgJiYgT3QucGFyZW50LmlzQ0UpXG4gICAgcmV0dXJuIGUgIT09IFwiZGVmYXVsdFwiICYmIChuLm5hbWUgPSBlKSwgSihcInNsb3RcIiwgbiwgciAmJiByKCkpO1xuICBsZXQgcyA9IHRbZV07XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBzICYmIHMubGVuZ3RoID4gMSAmJiAoSShcbiAgICBcIlNTUi1vcHRpbWl6ZWQgc2xvdCBmdW5jdGlvbiBkZXRlY3RlZCBpbiBhIG5vbi1TU1Itb3B0aW1pemVkIHJlbmRlciBmdW5jdGlvbi4gWW91IG5lZWQgdG8gbWFyayB0aGlzIGNvbXBvbmVudCB3aXRoICRkeW5hbWljLXNsb3RzIGluIHRoZSBwYXJlbnQgdGVtcGxhdGUuXCJcbiAgKSwgcyA9ICgpID0+IFtdKSwgcyAmJiBzLl9jICYmIChzLl9kID0gITEpLCBaKCk7XG4gIGNvbnN0IG8gPSBzICYmIGcxKHMobikpLCBhID0ga2UoXG4gICAgUGUsXG4gICAge1xuICAgICAga2V5OiBuLmtleSB8fCAvLyBzbG90IGNvbnRlbnQgYXJyYXkgb2YgYSBkeW5hbWljIGNvbmRpdGlvbmFsIHNsb3QgbWF5IGhhdmUgYSBicmFuY2hcbiAgICAgIC8vIGtleSBhdHRhY2hlZCBpbiB0aGUgYGNyZWF0ZVNsb3RzYCBoZWxwZXIsIHJlc3BlY3QgdGhhdFxuICAgICAgbyAmJiBvLmtleSB8fCBgXyR7ZX1gXG4gICAgfSxcbiAgICBvIHx8IChyID8gcigpIDogW10pLFxuICAgIG8gJiYgdC5fID09PSAxID8gNjQgOiAtMlxuICApO1xuICByZXR1cm4gIWkgJiYgYS5zY29wZUlkICYmIChhLnNsb3RTY29wZUlkcyA9IFthLnNjb3BlSWQgKyBcIi1zXCJdKSwgcyAmJiBzLl9jICYmIChzLl9kID0gITApLCBhO1xufVxuZnVuY3Rpb24gZzEodCkge1xuICByZXR1cm4gdC5zb21lKChlKSA9PiBsaShlKSA/ICEoZS50eXBlID09PSBfdCB8fCBlLnR5cGUgPT09IFBlICYmICFnMShlLmNoaWxkcmVuKSkgOiAhMCkgPyB0IDogbnVsbDtcbn1cbmZ1bmN0aW9uIGtFKHQsIGUpIHtcbiAgY29uc3QgbiA9IHt9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFaZSh0KSlcbiAgICByZXR1cm4gSShcInYtb24gd2l0aCBubyBhcmd1bWVudCBleHBlY3RzIGFuIG9iamVjdCB2YWx1ZS5cIiksIG47XG4gIGZvciAoY29uc3QgciBpbiB0KVxuICAgIG5bZSAmJiAvW0EtWl0vLnRlc3QocikgPyBgb246JHtyfWAgOiBUcihyKV0gPSB0W3JdO1xuICByZXR1cm4gbjtcbn1cbmNvbnN0IGhoID0gKHQpID0+IHQgPyBJMSh0KSA/IF9kKHQpIHx8IHQucHJveHkgOiBoaCh0LnBhcmVudCkgOiBudWxsLCBacyA9IChcbiAgLy8gTW92ZSBQVVJFIG1hcmtlciB0byBuZXcgbGluZSB0byB3b3JrYXJvdW5kIGNvbXBpbGVyIGRpc2NhcmRpbmcgaXRcbiAgLy8gZHVlIHRvIHR5cGUgYW5ub3RhdGlvblxuICAvKiBAX19QVVJFX18gKi8gJGUoLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgICAkOiAodCkgPT4gdCxcbiAgICAkZWw6ICh0KSA9PiB0LnZub2RlLmVsLFxuICAgICRkYXRhOiAodCkgPT4gdC5kYXRhLFxuICAgICRwcm9wczogKHQpID0+IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IERuKHQucHJvcHMpIDogdC5wcm9wcyxcbiAgICAkYXR0cnM6ICh0KSA9PiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBEbih0LmF0dHJzKSA6IHQuYXR0cnMsXG4gICAgJHNsb3RzOiAodCkgPT4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gRG4odC5zbG90cykgOiB0LnNsb3RzLFxuICAgICRyZWZzOiAodCkgPT4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gRG4odC5yZWZzKSA6IHQucmVmcyxcbiAgICAkcGFyZW50OiAodCkgPT4gaGgodC5wYXJlbnQpLFxuICAgICRyb290OiAodCkgPT4gaGgodC5yb290KSxcbiAgICAkZW1pdDogKHQpID0+IHQuZW1pdCxcbiAgICAkb3B0aW9uczogKHQpID0+IF9fVlVFX09QVElPTlNfQVBJX18gPyBQTyh0KSA6IHQudHlwZSxcbiAgICAkZm9yY2VVcGRhdGU6ICh0KSA9PiB0LmYgfHwgKHQuZiA9ICgpID0+IHtcbiAgICAgIHQuZWZmZWN0LmRpcnR5ID0gITAsIE5sKHQudXBkYXRlKTtcbiAgICB9KSxcbiAgICAkbmV4dFRpY2s6ICh0KSA9PiB0Lm4gfHwgKHQubiA9IFBuLmJpbmQodC5wcm94eSkpLFxuICAgICR3YXRjaDogKHQpID0+IF9fVlVFX09QVElPTlNfQVBJX18gPyBtRS5iaW5kKHQpIDogaXRcbiAgfSlcbiksIGtPID0gKHQpID0+IHQgPT09IFwiX1wiIHx8IHQgPT09IFwiJFwiLCBkZiA9ICh0LCBlKSA9PiB0ICE9PSBWZSAmJiAhdC5fX2lzU2NyaXB0U2V0dXAgJiYgQWUodCwgZSksIFhhID0ge1xuICBnZXQoeyBfOiB0IH0sIGUpIHtcbiAgICBjb25zdCB7IGN0eDogbiwgc2V0dXBTdGF0ZTogciwgZGF0YTogaSwgcHJvcHM6IHMsIGFjY2Vzc0NhY2hlOiBvLCB0eXBlOiBhLCBhcHBDb250ZXh0OiBsIH0gPSB0O1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZSA9PT0gXCJfX2lzVnVlXCIpXG4gICAgICByZXR1cm4gITA7XG4gICAgbGV0IGM7XG4gICAgaWYgKGVbMF0gIT09IFwiJFwiKSB7XG4gICAgICBjb25zdCBoID0gb1tlXTtcbiAgICAgIGlmIChoICE9PSB2b2lkIDApXG4gICAgICAgIHN3aXRjaCAoaCkge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiByW2VdO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBpW2VdO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJldHVybiBuW2VdO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBzW2VdO1xuICAgICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGRmKHIsIGUpKVxuICAgICAgICAgIHJldHVybiBvW2VdID0gMSwgcltlXTtcbiAgICAgICAgaWYgKGkgIT09IFZlICYmIEFlKGksIGUpKVxuICAgICAgICAgIHJldHVybiBvW2VdID0gMiwgaVtlXTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIC8vIG9ubHkgY2FjaGUgb3RoZXIgcHJvcGVydGllcyB3aGVuIGluc3RhbmNlIGhhcyBkZWNsYXJlZCAodGh1cyBzdGFibGUpXG4gICAgICAgICAgLy8gcHJvcHNcbiAgICAgICAgICAoYyA9IHQucHJvcHNPcHRpb25zWzBdKSAmJiBBZShjLCBlKVxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIG9bZV0gPSAzLCBzW2VdO1xuICAgICAgICBpZiAobiAhPT0gVmUgJiYgQWUobiwgZSkpXG4gICAgICAgICAgcmV0dXJuIG9bZV0gPSA0LCBuW2VdO1xuICAgICAgICAoIV9fVlVFX09QVElPTlNfQVBJX18gfHwgcGgpICYmIChvW2VdID0gMCk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHUgPSBac1tlXTtcbiAgICBsZXQgZCwgZjtcbiAgICBpZiAodSlcbiAgICAgIHJldHVybiBlID09PSBcIiRhdHRyc1wiID8gKEt0KHQsIFwiZ2V0XCIsIGUpLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgd3UoKSkgOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZSA9PT0gXCIkc2xvdHNcIiAmJiBLdCh0LCBcImdldFwiLCBlKSwgdSh0KTtcbiAgICBpZiAoXG4gICAgICAvLyBjc3MgbW9kdWxlIChpbmplY3RlZCBieSB2dWUtbG9hZGVyKVxuICAgICAgKGQgPSBhLl9fY3NzTW9kdWxlcykgJiYgKGQgPSBkW2VdKVxuICAgIClcbiAgICAgIHJldHVybiBkO1xuICAgIGlmIChuICE9PSBWZSAmJiBBZShuLCBlKSlcbiAgICAgIHJldHVybiBvW2VdID0gNCwgbltlXTtcbiAgICBpZiAoXG4gICAgICAvLyBnbG9iYWwgcHJvcGVydGllc1xuICAgICAgZiA9IGwuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMsIEFlKGYsIGUpXG4gICAgKVxuICAgICAgcmV0dXJuIGZbZV07XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIE90ICYmICghd2UoZSkgfHwgLy8gIzEwOTEgYXZvaWQgaW50ZXJuYWwgaXNSZWYvaXNWTm9kZSBjaGVja3Mgb24gY29tcG9uZW50IGluc3RhbmNlIGxlYWRpbmdcbiAgICAvLyB0byBpbmZpbml0ZSB3YXJuaW5nIGxvb3BcbiAgICBlLmluZGV4T2YoXCJfX3ZcIikgIT09IDApICYmIChpICE9PSBWZSAmJiBrTyhlWzBdKSAmJiBBZShpLCBlKSA/IEkoXG4gICAgICBgUHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgZVxuICAgICAgKX0gbXVzdCBiZSBhY2Nlc3NlZCB2aWEgJGRhdGEgYmVjYXVzZSBpdCBzdGFydHMgd2l0aCBhIHJlc2VydmVkIGNoYXJhY3RlciAoXCIkXCIgb3IgXCJfXCIpIGFuZCBpcyBub3QgcHJveGllZCBvbiB0aGUgcmVuZGVyIGNvbnRleHQuYFxuICAgICkgOiB0ID09PSBPdCAmJiBJKFxuICAgICAgYFByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoZSl9IHdhcyBhY2Nlc3NlZCBkdXJpbmcgcmVuZGVyIGJ1dCBpcyBub3QgZGVmaW5lZCBvbiBpbnN0YW5jZS5gXG4gICAgKSk7XG4gIH0sXG4gIHNldCh7IF86IHQgfSwgZSwgbikge1xuICAgIGNvbnN0IHsgZGF0YTogciwgc2V0dXBTdGF0ZTogaSwgY3R4OiBzIH0gPSB0O1xuICAgIHJldHVybiBkZihpLCBlKSA/IChpW2VdID0gbiwgITApIDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGkuX19pc1NjcmlwdFNldHVwICYmIEFlKGksIGUpID8gKEkoYENhbm5vdCBtdXRhdGUgPHNjcmlwdCBzZXR1cD4gYmluZGluZyBcIiR7ZX1cIiBmcm9tIE9wdGlvbnMgQVBJLmApLCAhMSkgOiByICE9PSBWZSAmJiBBZShyLCBlKSA/IChyW2VdID0gbiwgITApIDogQWUodC5wcm9wcywgZSkgPyAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIEkoYEF0dGVtcHRpbmcgdG8gbXV0YXRlIHByb3AgXCIke2V9XCIuIFByb3BzIGFyZSByZWFkb25seS5gKSwgITEpIDogZVswXSA9PT0gXCIkXCIgJiYgZS5zbGljZSgxKSBpbiB0ID8gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBJKFxuICAgICAgYEF0dGVtcHRpbmcgdG8gbXV0YXRlIHB1YmxpYyBwcm9wZXJ0eSBcIiR7ZX1cIi4gUHJvcGVydGllcyBzdGFydGluZyB3aXRoICQgYXJlIHJlc2VydmVkIGFuZCByZWFkb25seS5gXG4gICAgKSwgITEpIDogKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBlIGluIHQuYXBwQ29udGV4dC5jb25maWcuZ2xvYmFsUHJvcGVydGllcyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzLCBlLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB2YWx1ZTogblxuICAgIH0pIDogc1tlXSA9IG4sICEwKTtcbiAgfSxcbiAgaGFzKHtcbiAgICBfOiB7IGRhdGE6IHQsIHNldHVwU3RhdGU6IGUsIGFjY2Vzc0NhY2hlOiBuLCBjdHg6IHIsIGFwcENvbnRleHQ6IGksIHByb3BzT3B0aW9uczogcyB9XG4gIH0sIG8pIHtcbiAgICBsZXQgYTtcbiAgICByZXR1cm4gISFuW29dIHx8IHQgIT09IFZlICYmIEFlKHQsIG8pIHx8IGRmKGUsIG8pIHx8IChhID0gc1swXSkgJiYgQWUoYSwgbykgfHwgQWUociwgbykgfHwgQWUoWnMsIG8pIHx8IEFlKGkuY29uZmlnLmdsb2JhbFByb3BlcnRpZXMsIG8pO1xuICB9LFxuICBkZWZpbmVQcm9wZXJ0eSh0LCBlLCBuKSB7XG4gICAgcmV0dXJuIG4uZ2V0ICE9IG51bGwgPyB0Ll8uYWNjZXNzQ2FjaGVbZV0gPSAwIDogQWUobiwgXCJ2YWx1ZVwiKSAmJiB0aGlzLnNldCh0LCBlLCBuLnZhbHVlLCBudWxsKSwgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBlLCBuKTtcbiAgfVxufTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAoWGEub3duS2V5cyA9ICh0KSA9PiAoSShcbiAgXCJBdm9pZCBhcHAgbG9naWMgdGhhdCByZWxpZXMgb24gZW51bWVyYXRpbmcga2V5cyBvbiBhIGNvbXBvbmVudCBpbnN0YW5jZS4gVGhlIGtleXMgd2lsbCBiZSBlbXB0eSBpbiBwcm9kdWN0aW9uIG1vZGUgdG8gYXZvaWQgcGVyZm9ybWFuY2Ugb3ZlcmhlYWQuXCJcbiksIFJlZmxlY3Qub3duS2V5cyh0KSkpO1xuY29uc3QgeEUgPSAvKiBAX19QVVJFX18gKi8gJGUoXG4gIHt9LFxuICBYYSxcbiAge1xuICAgIGdldCh0LCBlKSB7XG4gICAgICBpZiAoZSAhPT0gU3ltYm9sLnVuc2NvcGFibGVzKVxuICAgICAgICByZXR1cm4gWGEuZ2V0KHQsIGUsIHQpO1xuICAgIH0sXG4gICAgaGFzKHQsIGUpIHtcbiAgICAgIGNvbnN0IG4gPSBlWzBdICE9PSBcIl9cIiAmJiAhV18oZSk7XG4gICAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFuICYmIFhhLmhhcyh0LCBlKSAmJiBJKFxuICAgICAgICBgUHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICBlXG4gICAgICAgICl9IHNob3VsZCBub3Qgc3RhcnQgd2l0aCBfIHdoaWNoIGlzIGEgcmVzZXJ2ZWQgcHJlZml4IGZvciBWdWUgaW50ZXJuYWxzLmBcbiAgICAgICksIG47XG4gICAgfVxuICB9XG4pO1xuZnVuY3Rpb24gUEUodCkge1xuICBjb25zdCBlID0ge307XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJfXCIsIHtcbiAgICBjb25maWd1cmFibGU6ICEwLFxuICAgIGVudW1lcmFibGU6ICExLFxuICAgIGdldDogKCkgPT4gdFxuICB9KSwgT2JqZWN0LmtleXMoWnMpLmZvckVhY2goKG4pID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgbiwge1xuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgZ2V0OiAoKSA9PiBac1tuXSh0KSxcbiAgICAgIC8vIGludGVyY2VwdGVkIGJ5IHRoZSBwcm94eSBzbyBubyBuZWVkIGZvciBpbXBsZW1lbnRhdGlvbixcbiAgICAgIC8vIGJ1dCBuZWVkZWQgdG8gcHJldmVudCBzZXQgZXJyb3JzXG4gICAgICBzZXQ6IGl0XG4gICAgfSk7XG4gIH0pLCBlO1xufVxuZnVuY3Rpb24gX0UodCkge1xuICBjb25zdCB7XG4gICAgY3R4OiBlLFxuICAgIHByb3BzT3B0aW9uczogW25dXG4gIH0gPSB0O1xuICBuICYmIE9iamVjdC5rZXlzKG4pLmZvckVhY2goKHIpID0+IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwge1xuICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgZ2V0OiAoKSA9PiB0LnByb3BzW3JdLFxuICAgICAgc2V0OiBpdFxuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIFRFKHQpIHtcbiAgY29uc3QgeyBjdHg6IGUsIHNldHVwU3RhdGU6IG4gfSA9IHQ7XG4gIE9iamVjdC5rZXlzKE9lKG4pKS5mb3JFYWNoKChyKSA9PiB7XG4gICAgaWYgKCFuLl9faXNTY3JpcHRTZXR1cCkge1xuICAgICAgaWYgKGtPKHJbMF0pKSB7XG4gICAgICAgIEkoXG4gICAgICAgICAgYHNldHVwKCkgcmV0dXJuIHByb3BlcnR5ICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICByXG4gICAgICAgICAgKX0gc2hvdWxkIG5vdCBzdGFydCB3aXRoIFwiJFwiIG9yIFwiX1wiIHdoaWNoIGFyZSByZXNlcnZlZCBwcmVmaXhlcyBmb3IgVnVlIGludGVybmFscy5gXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7XG4gICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICBnZXQ6ICgpID0+IG5bcl0sXG4gICAgICAgIHNldDogaXRcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG5jb25zdCBlbyA9ICh0KSA9PiBJKFxuICBgJHt0fSgpIGlzIGEgY29tcGlsZXItaGludCBoZWxwZXIgdGhhdCBpcyBvbmx5IHVzYWJsZSBpbnNpZGUgPHNjcmlwdCBzZXR1cD4gb2YgYSBzaW5nbGUgZmlsZSBjb21wb25lbnQuIEl0cyBhcmd1bWVudHMgc2hvdWxkIGJlIGNvbXBpbGVkIGF3YXkgYW5kIHBhc3NpbmcgaXQgYXQgcnVudGltZSBoYXMgbm8gZWZmZWN0LmBcbik7XG5mdW5jdGlvbiBFRSgpIHtcbiAgcmV0dXJuIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBlbyhcImRlZmluZVByb3BzXCIpLCBudWxsO1xufVxuZnVuY3Rpb24gJEUoKSB7XG4gIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZW8oXCJkZWZpbmVFbWl0c1wiKSwgbnVsbDtcbn1cbmZ1bmN0aW9uIFFFKHQpIHtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGVvKFwiZGVmaW5lRXhwb3NlXCIpO1xufVxuZnVuY3Rpb24gQ0UodCkge1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZW8oXCJkZWZpbmVPcHRpb25zXCIpO1xufVxuZnVuY3Rpb24gQUUoKSB7XG4gIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZW8oXCJkZWZpbmVTbG90c1wiKSwgbnVsbDtcbn1cbmZ1bmN0aW9uIFJFKCkge1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZW8oXCJkZWZpbmVNb2RlbFwiKTtcbn1cbmZ1bmN0aW9uIE5FKHQsIGUpIHtcbiAgcmV0dXJuIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBlbyhcIndpdGhEZWZhdWx0c1wiKSwgbnVsbDtcbn1cbmZ1bmN0aW9uIERFKCkge1xuICByZXR1cm4gbTEoKS5zbG90cztcbn1cbmZ1bmN0aW9uIHhPKCkge1xuICByZXR1cm4gbTEoKS5hdHRycztcbn1cbmZ1bmN0aW9uIG0xKCkge1xuICBjb25zdCB0ID0gaXIoKTtcbiAgcmV0dXJuIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhdCAmJiBJKFwidXNlQ29udGV4dCgpIGNhbGxlZCB3aXRob3V0IGFjdGl2ZSBpbnN0YW5jZS5cIiksIHQuc2V0dXBDb250ZXh0IHx8ICh0LnNldHVwQ29udGV4dCA9IGoxKHQpKTtcbn1cbmZ1bmN0aW9uIG9sKHQpIHtcbiAgcmV0dXJuIGllKHQpID8gdC5yZWR1Y2UoXG4gICAgKGUsIG4pID0+IChlW25dID0gbnVsbCwgZSksXG4gICAge31cbiAgKSA6IHQ7XG59XG5mdW5jdGlvbiBaRSh0LCBlKSB7XG4gIGNvbnN0IG4gPSBvbCh0KTtcbiAgZm9yIChjb25zdCByIGluIGUpIHtcbiAgICBpZiAoci5zdGFydHNXaXRoKFwiX19za2lwXCIpKVxuICAgICAgY29udGludWU7XG4gICAgbGV0IGkgPSBuW3JdO1xuICAgIGkgPyBpZShpKSB8fCBiZShpKSA/IGkgPSBuW3JdID0geyB0eXBlOiBpLCBkZWZhdWx0OiBlW3JdIH0gOiBpLmRlZmF1bHQgPSBlW3JdIDogaSA9PT0gbnVsbCA/IGkgPSBuW3JdID0geyBkZWZhdWx0OiBlW3JdIH0gOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgSShgcHJvcHMgZGVmYXVsdCBrZXkgXCIke3J9XCIgaGFzIG5vIGNvcnJlc3BvbmRpbmcgZGVjbGFyYXRpb24uYCksIGkgJiYgZVtgX19za2lwXyR7cn1gXSAmJiAoaS5za2lwRmFjdG9yeSA9ICEwKTtcbiAgfVxuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIFZFKHQsIGUpIHtcbiAgcmV0dXJuICF0IHx8ICFlID8gdCB8fCBlIDogaWUodCkgJiYgaWUoZSkgPyB0LmNvbmNhdChlKSA6ICRlKHt9LCBvbCh0KSwgb2woZSkpO1xufVxuZnVuY3Rpb24gSUUodCwgZSkge1xuICBjb25zdCBuID0ge307XG4gIGZvciAoY29uc3QgciBpbiB0KVxuICAgIGUuaW5jbHVkZXMocikgfHwgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIHIsIHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgZ2V0OiAoKSA9PiB0W3JdXG4gICAgfSk7XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gV0UodCkge1xuICBjb25zdCBlID0gaXIoKTtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFlICYmIEkoXG4gICAgXCJ3aXRoQXN5bmNDb250ZXh0IGNhbGxlZCB3aXRob3V0IGFjdGl2ZSBjdXJyZW50IGluc3RhbmNlLiBUaGlzIGlzIGxpa2VseSBhIGJ1Zy5cIlxuICApO1xuICBsZXQgbiA9IHQoKTtcbiAgcmV0dXJuIHdoKCksIGRkKG4pICYmIChuID0gbi5jYXRjaCgocikgPT4ge1xuICAgIHRocm93IEJzKGUpLCByO1xuICB9KSksIFtuLCAoKSA9PiBCcyhlKV07XG59XG5mdW5jdGlvbiBNRSgpIHtcbiAgY29uc3QgdCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gKGUsIG4pID0+IHtcbiAgICB0W25dID8gSShgJHtlfSBwcm9wZXJ0eSBcIiR7bn1cIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gJHt0W25dfS5gKSA6IHRbbl0gPSBlO1xuICB9O1xufVxubGV0IHBoID0gITA7XG5mdW5jdGlvbiBYRSh0KSB7XG4gIGNvbnN0IGUgPSBQTyh0KSwgbiA9IHQucHJveHksIHIgPSB0LmN0eDtcbiAgcGggPSAhMSwgZS5iZWZvcmVDcmVhdGUgJiYgUG0oZS5iZWZvcmVDcmVhdGUsIHQsIFwiYmNcIik7XG4gIGNvbnN0IHtcbiAgICAvLyBzdGF0ZVxuICAgIGRhdGE6IGksXG4gICAgY29tcHV0ZWQ6IHMsXG4gICAgbWV0aG9kczogbyxcbiAgICB3YXRjaDogYSxcbiAgICBwcm92aWRlOiBsLFxuICAgIGluamVjdDogYyxcbiAgICAvLyBsaWZlY3ljbGVcbiAgICBjcmVhdGVkOiB1LFxuICAgIGJlZm9yZU1vdW50OiBkLFxuICAgIG1vdW50ZWQ6IGYsXG4gICAgYmVmb3JlVXBkYXRlOiBoLFxuICAgIHVwZGF0ZWQ6IHAsXG4gICAgYWN0aXZhdGVkOiBPLFxuICAgIGRlYWN0aXZhdGVkOiBtLFxuICAgIGJlZm9yZURlc3Ryb3k6IHksXG4gICAgYmVmb3JlVW5tb3VudDogYixcbiAgICBkZXN0cm95ZWQ6IGcsXG4gICAgdW5tb3VudGVkOiB2LFxuICAgIHJlbmRlcjogUyxcbiAgICByZW5kZXJUcmFja2VkOiB3LFxuICAgIHJlbmRlclRyaWdnZXJlZDogayxcbiAgICBlcnJvckNhcHR1cmVkOiBfLFxuICAgIHNlcnZlclByZWZldGNoOiBULFxuICAgIC8vIHB1YmxpYyBBUElcbiAgICBleHBvc2U6IEMsXG4gICAgaW5oZXJpdEF0dHJzOiBBLFxuICAgIC8vIGFzc2V0c1xuICAgIGNvbXBvbmVudHM6IFEsXG4gICAgZGlyZWN0aXZlczogVyxcbiAgICBmaWx0ZXJzOiBMXG4gIH0gPSBlLCByZSA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IE1FKCkgOiBudWxsO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc3QgW0tdID0gdC5wcm9wc09wdGlvbnM7XG4gICAgaWYgKEspXG4gICAgICBmb3IgKGNvbnN0IEIgaW4gSylcbiAgICAgICAgcmUoXCJQcm9wc1wiLCBCKTtcbiAgfVxuICBpZiAoYyAmJiBqRShjLCByLCByZSksIG8pXG4gICAgZm9yIChjb25zdCBLIGluIG8pIHtcbiAgICAgIGNvbnN0IEIgPSBvW0tdO1xuICAgICAgYmUoQikgPyAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KHIsIEssIHtcbiAgICAgICAgdmFsdWU6IEIuYmluZChuKSxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgfSkgOiByW0tdID0gQi5iaW5kKG4pLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgcmUoXCJNZXRob2RzXCIsIEspKSA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBJKFxuICAgICAgICBgTWV0aG9kIFwiJHtLfVwiIGhhcyB0eXBlIFwiJHt0eXBlb2YgQn1cIiBpbiB0aGUgY29tcG9uZW50IGRlZmluaXRpb24uIERpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/YFxuICAgICAgKTtcbiAgICB9XG4gIGlmIChpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFiZShpKSAmJiBJKFxuICAgICAgXCJUaGUgZGF0YSBvcHRpb24gbXVzdCBiZSBhIGZ1bmN0aW9uLiBQbGFpbiBvYmplY3QgdXNhZ2UgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC5cIlxuICAgICk7XG4gICAgY29uc3QgSyA9IGkuY2FsbChuLCBuKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGRkKEspICYmIEkoXG4gICAgICBcImRhdGEoKSByZXR1cm5lZCBhIFByb21pc2UgLSBub3RlIGRhdGEoKSBjYW5ub3QgYmUgYXN5bmM7IElmIHlvdSBpbnRlbmQgdG8gcGVyZm9ybSBkYXRhIGZldGNoaW5nIGJlZm9yZSBjb21wb25lbnQgcmVuZGVycywgdXNlIGFzeW5jIHNldHVwKCkgKyA8U3VzcGVuc2U+LlwiXG4gICAgKSwgIVplKEspKVxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIEkoXCJkYXRhKCkgc2hvdWxkIHJldHVybiBhbiBvYmplY3QuXCIpO1xuICAgIGVsc2UgaWYgKHQuZGF0YSA9IFhuKEspLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpXG4gICAgICBmb3IgKGNvbnN0IEIgaW4gSylcbiAgICAgICAgcmUoXCJEYXRhXCIsIEIpLCBrTyhCWzBdKSB8fCBPYmplY3QuZGVmaW5lUHJvcGVydHkociwgQiwge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgZ2V0OiAoKSA9PiBLW0JdLFxuICAgICAgICAgIHNldDogaXRcbiAgICAgICAgfSk7XG4gIH1cbiAgaWYgKHBoID0gITAsIHMpXG4gICAgZm9yIChjb25zdCBLIGluIHMpIHtcbiAgICAgIGNvbnN0IEIgPSBzW0tdLCBfZSA9IGJlKEIpID8gQi5iaW5kKG4sIG4pIDogYmUoQi5nZXQpID8gQi5nZXQuYmluZChuLCBuKSA6IGl0O1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIF9lID09PSBpdCAmJiBJKGBDb21wdXRlZCBwcm9wZXJ0eSBcIiR7S31cIiBoYXMgbm8gZ2V0dGVyLmApO1xuICAgICAgY29uc3QgQ2UgPSAhYmUoQikgJiYgYmUoQi5zZXQpID8gQi5zZXQuYmluZChuKSA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/ICgpID0+IHtcbiAgICAgICAgSShcbiAgICAgICAgICBgV3JpdGUgb3BlcmF0aW9uIGZhaWxlZDogY29tcHV0ZWQgcHJvcGVydHkgXCIke0t9XCIgaXMgcmVhZG9ubHkuYFxuICAgICAgICApO1xuICAgICAgfSA6IGl0LCB1ZSA9IGooe1xuICAgICAgICBnZXQ6IF9lLFxuICAgICAgICBzZXQ6IENlXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLCBLLCB7XG4gICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgICBnZXQ6ICgpID0+IHVlLnZhbHVlLFxuICAgICAgICBzZXQ6IChnZSkgPT4gdWUudmFsdWUgPSBnZVxuICAgICAgfSksIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiByZShcIkNvbXB1dGVkXCIsIEspO1xuICAgIH1cbiAgaWYgKGEpXG4gICAgZm9yIChjb25zdCBLIGluIGEpXG4gICAgICBiMShhW0tdLCByLCBuLCBLKTtcbiAgaWYgKGwpIHtcbiAgICBjb25zdCBLID0gYmUobCkgPyBsLmNhbGwobikgOiBsO1xuICAgIFJlZmxlY3Qub3duS2V5cyhLKS5mb3JFYWNoKChCKSA9PiB7XG4gICAgICBfbihCLCBLW0JdKTtcbiAgICB9KTtcbiAgfVxuICB1ICYmIFBtKHUsIHQsIFwiY1wiKTtcbiAgZnVuY3Rpb24gWShLLCBCKSB7XG4gICAgaWUoQikgPyBCLmZvckVhY2goKF9lKSA9PiBLKF9lLmJpbmQobikpKSA6IEIgJiYgSyhCLmJpbmQobikpO1xuICB9XG4gIGlmIChZKGQxLCBkKSwgWShldCwgZiksIFkoZjEsIGgpLCBZKGtkLCBwKSwgWShsMSwgTyksIFkoYzEsIG0pLCBZKE8xLCBfKSwgWShwMSwgdyksIFkoaDEsIGspLCBZKElsLCBiKSwgWShqdCwgdiksIFkoeGQsIFQpLCBpZShDKSlcbiAgICBpZiAoQy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IEsgPSB0LmV4cG9zZWQgfHwgKHQuZXhwb3NlZCA9IHt9KTtcbiAgICAgIEMuZm9yRWFjaCgoQikgPT4ge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSywgQiwge1xuICAgICAgICAgIGdldDogKCkgPT4gbltCXSxcbiAgICAgICAgICBzZXQ6IChfZSkgPT4gbltCXSA9IF9lXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlXG4gICAgICB0LmV4cG9zZWQgfHwgKHQuZXhwb3NlZCA9IHt9KTtcbiAgUyAmJiB0LnJlbmRlciA9PT0gaXQgJiYgKHQucmVuZGVyID0gUyksIEEgIT0gbnVsbCAmJiAodC5pbmhlcml0QXR0cnMgPSBBKSwgUSAmJiAodC5jb21wb25lbnRzID0gUSksIFcgJiYgKHQuZGlyZWN0aXZlcyA9IFcpO1xufVxuZnVuY3Rpb24gakUodCwgZSwgbiA9IGl0KSB7XG4gIGllKHQpICYmICh0ID0gT2godCkpO1xuICBmb3IgKGNvbnN0IHIgaW4gdCkge1xuICAgIGNvbnN0IGkgPSB0W3JdO1xuICAgIGxldCBzO1xuICAgIFplKGkpID8gXCJkZWZhdWx0XCIgaW4gaSA/IHMgPSBQdChcbiAgICAgIGkuZnJvbSB8fCByLFxuICAgICAgaS5kZWZhdWx0LFxuICAgICAgITBcbiAgICApIDogcyA9IFB0KGkuZnJvbSB8fCByKSA6IHMgPSBQdChpKSwgQ3QocykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwge1xuICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgZ2V0OiAoKSA9PiBzLnZhbHVlLFxuICAgICAgc2V0OiAobykgPT4gcy52YWx1ZSA9IG9cbiAgICB9KSA6IGVbcl0gPSBzLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbihcIkluamVjdFwiLCByKTtcbiAgfVxufVxuZnVuY3Rpb24gUG0odCwgZSwgbikge1xuICBXbihcbiAgICBpZSh0KSA/IHQubWFwKChyKSA9PiByLmJpbmQoZS5wcm94eSkpIDogdC5iaW5kKGUucHJveHkpLFxuICAgIGUsXG4gICAgblxuICApO1xufVxuZnVuY3Rpb24gYjEodCwgZSwgbiwgcikge1xuICBjb25zdCBpID0gci5pbmNsdWRlcyhcIi5cIikgPyByMShuLCByKSA6ICgpID0+IG5bcl07XG4gIGlmICh3ZSh0KSkge1xuICAgIGNvbnN0IHMgPSBlW3RdO1xuICAgIGJlKHMpID8gaHQoaSwgcykgOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgSShgSW52YWxpZCB3YXRjaCBoYW5kbGVyIHNwZWNpZmllZCBieSBrZXkgXCIke3R9XCJgLCBzKTtcbiAgfSBlbHNlIGlmIChiZSh0KSlcbiAgICBodChpLCB0LmJpbmQobikpO1xuICBlbHNlIGlmIChaZSh0KSlcbiAgICBpZiAoaWUodCkpXG4gICAgICB0LmZvckVhY2goKHMpID0+IGIxKHMsIGUsIG4sIHIpKTtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IHMgPSBiZSh0LmhhbmRsZXIpID8gdC5oYW5kbGVyLmJpbmQobikgOiBlW3QuaGFuZGxlcl07XG4gICAgICBiZShzKSA/IGh0KGksIHMsIHQpIDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIEkoYEludmFsaWQgd2F0Y2ggaGFuZGxlciBzcGVjaWZpZWQgYnkga2V5IFwiJHt0LmhhbmRsZXJ9XCJgLCBzKTtcbiAgICB9XG4gIGVsc2VcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgSShgSW52YWxpZCB3YXRjaCBvcHRpb246IFwiJHtyfVwiYCwgdCk7XG59XG5mdW5jdGlvbiBQTyh0KSB7XG4gIGNvbnN0IGUgPSB0LnR5cGUsIHsgbWl4aW5zOiBuLCBleHRlbmRzOiByIH0gPSBlLCB7XG4gICAgbWl4aW5zOiBpLFxuICAgIG9wdGlvbnNDYWNoZTogcyxcbiAgICBjb25maWc6IHsgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiBvIH1cbiAgfSA9IHQuYXBwQ29udGV4dCwgYSA9IHMuZ2V0KGUpO1xuICBsZXQgbDtcbiAgcmV0dXJuIGEgPyBsID0gYSA6ICFpLmxlbmd0aCAmJiAhbiAmJiAhciA/IGwgPSBlIDogKGwgPSB7fSwgaS5sZW5ndGggJiYgaS5mb3JFYWNoKFxuICAgIChjKSA9PiB4dShsLCBjLCBvLCAhMClcbiAgKSwgeHUobCwgZSwgbykpLCBaZShlKSAmJiBzLnNldChlLCBsKSwgbDtcbn1cbmZ1bmN0aW9uIHh1KHQsIGUsIG4sIHIgPSAhMSkge1xuICBjb25zdCB7IG1peGluczogaSwgZXh0ZW5kczogcyB9ID0gZTtcbiAgcyAmJiB4dSh0LCBzLCBuLCAhMCksIGkgJiYgaS5mb3JFYWNoKFxuICAgIChvKSA9PiB4dSh0LCBvLCBuLCAhMClcbiAgKTtcbiAgZm9yIChjb25zdCBvIGluIGUpXG4gICAgaWYgKHIgJiYgbyA9PT0gXCJleHBvc2VcIilcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBJKFxuICAgICAgICAnXCJleHBvc2VcIiBvcHRpb24gaXMgaWdub3JlZCB3aGVuIGRlY2xhcmVkIGluIG1peGlucyBvciBleHRlbmRzLiBJdCBzaG91bGQgb25seSBiZSBkZWNsYXJlZCBpbiB0aGUgYmFzZSBjb21wb25lbnQgaXRzZWxmLidcbiAgICAgICk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBhID0gQkVbb10gfHwgbiAmJiBuW29dO1xuICAgICAgdFtvXSA9IGEgPyBhKHRbb10sIGVbb10pIDogZVtvXTtcbiAgICB9XG4gIHJldHVybiB0O1xufVxuY29uc3QgQkUgPSB7XG4gIGRhdGE6IF9tLFxuICBwcm9wczogVG0sXG4gIGVtaXRzOiBUbSxcbiAgLy8gb2JqZWN0c1xuICBtZXRob2RzOiBDYSxcbiAgY29tcHV0ZWQ6IENhLFxuICAvLyBsaWZlY3ljbGVcbiAgYmVmb3JlQ3JlYXRlOiBmbixcbiAgY3JlYXRlZDogZm4sXG4gIGJlZm9yZU1vdW50OiBmbixcbiAgbW91bnRlZDogZm4sXG4gIGJlZm9yZVVwZGF0ZTogZm4sXG4gIHVwZGF0ZWQ6IGZuLFxuICBiZWZvcmVEZXN0cm95OiBmbixcbiAgYmVmb3JlVW5tb3VudDogZm4sXG4gIGRlc3Ryb3llZDogZm4sXG4gIHVubW91bnRlZDogZm4sXG4gIGFjdGl2YXRlZDogZm4sXG4gIGRlYWN0aXZhdGVkOiBmbixcbiAgZXJyb3JDYXB0dXJlZDogZm4sXG4gIHNlcnZlclByZWZldGNoOiBmbixcbiAgLy8gYXNzZXRzXG4gIGNvbXBvbmVudHM6IENhLFxuICBkaXJlY3RpdmVzOiBDYSxcbiAgLy8gd2F0Y2hcbiAgd2F0Y2g6IFVFLFxuICAvLyBwcm92aWRlIC8gaW5qZWN0XG4gIHByb3ZpZGU6IF9tLFxuICBpbmplY3Q6IExFXG59O1xuZnVuY3Rpb24gX20odCwgZSkge1xuICByZXR1cm4gZSA/IHQgPyBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gJGUoXG4gICAgICBiZSh0KSA/IHQuY2FsbCh0aGlzLCB0aGlzKSA6IHQsXG4gICAgICBiZShlKSA/IGUuY2FsbCh0aGlzLCB0aGlzKSA6IGVcbiAgICApO1xuICB9IDogZSA6IHQ7XG59XG5mdW5jdGlvbiBMRSh0LCBlKSB7XG4gIHJldHVybiBDYShPaCh0KSwgT2goZSkpO1xufVxuZnVuY3Rpb24gT2godCkge1xuICBpZiAoaWUodCkpIHtcbiAgICBjb25zdCBlID0ge307XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCB0Lmxlbmd0aDsgbisrKVxuICAgICAgZVt0W25dXSA9IHRbbl07XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBmbih0LCBlKSB7XG4gIHJldHVybiB0ID8gWy4uLm5ldyBTZXQoW10uY29uY2F0KHQsIGUpKV0gOiBlO1xufVxuZnVuY3Rpb24gQ2EodCwgZSkge1xuICByZXR1cm4gdCA/ICRlKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCB0LCBlKSA6IGU7XG59XG5mdW5jdGlvbiBUbSh0LCBlKSB7XG4gIHJldHVybiB0ID8gaWUodCkgJiYgaWUoZSkgPyBbLi4uLyogQF9fUFVSRV9fICovIG5ldyBTZXQoWy4uLnQsIC4uLmVdKV0gOiAkZShcbiAgICAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICBvbCh0KSxcbiAgICBvbChlID8/IHt9KVxuICApIDogZTtcbn1cbmZ1bmN0aW9uIFVFKHQsIGUpIHtcbiAgaWYgKCF0KVxuICAgIHJldHVybiBlO1xuICBpZiAoIWUpXG4gICAgcmV0dXJuIHQ7XG4gIGNvbnN0IG4gPSAkZSgvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgdCk7XG4gIGZvciAoY29uc3QgciBpbiBlKVxuICAgIG5bcl0gPSBmbih0W3JdLCBlW3JdKTtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiB2MSgpIHtcbiAgcmV0dXJuIHtcbiAgICBhcHA6IG51bGwsXG4gICAgY29uZmlnOiB7XG4gICAgICBpc05hdGl2ZVRhZzogemMsXG4gICAgICBwZXJmb3JtYW5jZTogITEsXG4gICAgICBnbG9iYWxQcm9wZXJ0aWVzOiB7fSxcbiAgICAgIG9wdGlvbk1lcmdlU3RyYXRlZ2llczoge30sXG4gICAgICBlcnJvckhhbmRsZXI6IHZvaWQgMCxcbiAgICAgIHdhcm5IYW5kbGVyOiB2b2lkIDAsXG4gICAgICBjb21waWxlck9wdGlvbnM6IHt9XG4gICAgfSxcbiAgICBtaXhpbnM6IFtdLFxuICAgIGNvbXBvbmVudHM6IHt9LFxuICAgIGRpcmVjdGl2ZXM6IHt9LFxuICAgIHByb3ZpZGVzOiAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICBvcHRpb25zQ2FjaGU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLFxuICAgIHByb3BzQ2FjaGU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLFxuICAgIGVtaXRzQ2FjaGU6IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpXG4gIH07XG59XG5sZXQgcUUgPSAwO1xuZnVuY3Rpb24gWUUodCwgZSkge1xuICByZXR1cm4gZnVuY3Rpb24ociwgaSA9IG51bGwpIHtcbiAgICBiZShyKSB8fCAociA9ICRlKHt9LCByKSksIGkgIT0gbnVsbCAmJiAhWmUoaSkgJiYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBJKFwicm9vdCBwcm9wcyBwYXNzZWQgdG8gYXBwLm1vdW50KCkgbXVzdCBiZSBhbiBvYmplY3QuXCIpLCBpID0gbnVsbCk7XG4gICAgY29uc3QgcyA9IHYxKCksIG8gPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKTtcbiAgICBsZXQgYSA9ICExO1xuICAgIGNvbnN0IGwgPSBzLmFwcCA9IHtcbiAgICAgIF91aWQ6IHFFKyssXG4gICAgICBfY29tcG9uZW50OiByLFxuICAgICAgX3Byb3BzOiBpLFxuICAgICAgX2NvbnRhaW5lcjogbnVsbCxcbiAgICAgIF9jb250ZXh0OiBzLFxuICAgICAgX2luc3RhbmNlOiBudWxsLFxuICAgICAgdmVyc2lvbjogX2gsXG4gICAgICBnZXQgY29uZmlnKCkge1xuICAgICAgICByZXR1cm4gcy5jb25maWc7XG4gICAgICB9LFxuICAgICAgc2V0IGNvbmZpZyhjKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBJKFxuICAgICAgICAgIFwiYXBwLmNvbmZpZyBjYW5ub3QgYmUgcmVwbGFjZWQuIE1vZGlmeSBpbmRpdmlkdWFsIG9wdGlvbnMgaW5zdGVhZC5cIlxuICAgICAgICApO1xuICAgICAgfSxcbiAgICAgIHVzZShjLCAuLi51KSB7XG4gICAgICAgIHJldHVybiBvLmhhcyhjKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBJKFwiUGx1Z2luIGhhcyBhbHJlYWR5IGJlZW4gYXBwbGllZCB0byB0YXJnZXQgYXBwLlwiKSA6IGMgJiYgYmUoYy5pbnN0YWxsKSA/IChvLmFkZChjKSwgYy5pbnN0YWxsKGwsIC4uLnUpKSA6IGJlKGMpID8gKG8uYWRkKGMpLCBjKGwsIC4uLnUpKSA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBJKFxuICAgICAgICAgICdBIHBsdWdpbiBtdXN0IGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGFuIG9iamVjdCB3aXRoIGFuIFwiaW5zdGFsbFwiIGZ1bmN0aW9uLidcbiAgICAgICAgKSwgbDtcbiAgICAgIH0sXG4gICAgICBtaXhpbihjKSB7XG4gICAgICAgIHJldHVybiBfX1ZVRV9PUFRJT05TX0FQSV9fID8gcy5taXhpbnMuaW5jbHVkZXMoYykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgSShcbiAgICAgICAgICBcIk1peGluIGhhcyBhbHJlYWR5IGJlZW4gYXBwbGllZCB0byB0YXJnZXQgYXBwXCIgKyAoYy5uYW1lID8gYDogJHtjLm5hbWV9YCA6IFwiXCIpXG4gICAgICAgICkgOiBzLm1peGlucy5wdXNoKGMpIDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIEkoXCJNaXhpbnMgYXJlIG9ubHkgYXZhaWxhYmxlIGluIGJ1aWxkcyBzdXBwb3J0aW5nIE9wdGlvbnMgQVBJXCIpLCBsO1xuICAgICAgfSxcbiAgICAgIGNvbXBvbmVudChjLCB1KSB7XG4gICAgICAgIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYga2goYywgcy5jb25maWcpLCB1ID8gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBzLmNvbXBvbmVudHNbY10gJiYgSShgQ29tcG9uZW50IFwiJHtjfVwiIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCBpbiB0YXJnZXQgYXBwLmApLCBzLmNvbXBvbmVudHNbY10gPSB1LCBsKSA6IHMuY29tcG9uZW50c1tjXTtcbiAgICAgIH0sXG4gICAgICBkaXJlY3RpdmUoYywgdSkge1xuICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGkxKGMpLCB1ID8gKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBzLmRpcmVjdGl2ZXNbY10gJiYgSShgRGlyZWN0aXZlIFwiJHtjfVwiIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZCBpbiB0YXJnZXQgYXBwLmApLCBzLmRpcmVjdGl2ZXNbY10gPSB1LCBsKSA6IHMuZGlyZWN0aXZlc1tjXTtcbiAgICAgIH0sXG4gICAgICBtb3VudChjLCB1LCBkKSB7XG4gICAgICAgIGlmIChhKVxuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBJKFxuICAgICAgICAgICAgXCJBcHAgaGFzIGFscmVhZHkgYmVlbiBtb3VudGVkLlxcbklmIHlvdSB3YW50IHRvIHJlbW91bnQgdGhlIHNhbWUgYXBwLCBtb3ZlIHlvdXIgYXBwIGNyZWF0aW9uIGxvZ2ljIGludG8gYSBmYWN0b3J5IGZ1bmN0aW9uIGFuZCBjcmVhdGUgZnJlc2ggYXBwIGluc3RhbmNlcyBmb3IgZWFjaCBtb3VudCAtIGUuZy4gYGNvbnN0IGNyZWF0ZU15QXBwID0gKCkgPT4gY3JlYXRlQXBwKEFwcClgXCJcbiAgICAgICAgICApO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgYy5fX3Z1ZV9hcHBfXyAmJiBJKFxuICAgICAgICAgICAgXCJUaGVyZSBpcyBhbHJlYWR5IGFuIGFwcCBpbnN0YW5jZSBtb3VudGVkIG9uIHRoZSBob3N0IGNvbnRhaW5lci5cXG4gSWYgeW91IHdhbnQgdG8gbW91bnQgYW5vdGhlciBhcHAgb24gdGhlIHNhbWUgaG9zdCBjb250YWluZXIsIHlvdSBuZWVkIHRvIHVubW91bnQgdGhlIHByZXZpb3VzIGFwcCBieSBjYWxsaW5nIGBhcHAudW5tb3VudCgpYCBmaXJzdC5cIlxuICAgICAgICAgICk7XG4gICAgICAgICAgY29uc3QgZiA9IEoociwgaSk7XG4gICAgICAgICAgcmV0dXJuIGYuYXBwQ29udGV4dCA9IHMsIGQgPT09ICEwID8gZCA9IFwic3ZnXCIgOiBkID09PSAhMSAmJiAoZCA9IHZvaWQgMCksIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAocy5yZWxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICB0KFxuICAgICAgICAgICAgICBqbihmKSxcbiAgICAgICAgICAgICAgYyxcbiAgICAgICAgICAgICAgZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KSwgdSAmJiBlID8gZShmLCBjKSA6IHQoZiwgYywgZCksIGEgPSAhMCwgbC5fY29udGFpbmVyID0gYywgYy5fX3Z1ZV9hcHBfXyA9IGwsIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSAmJiAobC5faW5zdGFuY2UgPSBmLmNvbXBvbmVudCwgSFQobCwgX2gpKSwgX2QoZi5jb21wb25lbnQpIHx8IGYuY29tcG9uZW50LnByb3h5O1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdW5tb3VudCgpIHtcbiAgICAgICAgYSA/ICh0KG51bGwsIGwuX2NvbnRhaW5lciksIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSAmJiAobC5faW5zdGFuY2UgPSBudWxsLCBGVChsKSksIGRlbGV0ZSBsLl9jb250YWluZXIuX192dWVfYXBwX18pIDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIEkoXCJDYW5ub3QgdW5tb3VudCBhbiBhcHAgdGhhdCBpcyBub3QgbW91bnRlZC5cIik7XG4gICAgICB9LFxuICAgICAgcHJvdmlkZShjLCB1KSB7XG4gICAgICAgIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgYyBpbiBzLnByb3ZpZGVzICYmIEkoXG4gICAgICAgICAgYEFwcCBhbHJlYWR5IHByb3ZpZGVzIHByb3BlcnR5IHdpdGgga2V5IFwiJHtTdHJpbmcoYyl9XCIuIEl0IHdpbGwgYmUgb3ZlcndyaXR0ZW4gd2l0aCB0aGUgbmV3IHZhbHVlLmBcbiAgICAgICAgKSwgcy5wcm92aWRlc1tjXSA9IHUsIGw7XG4gICAgICB9LFxuICAgICAgcnVuV2l0aENvbnRleHQoYykge1xuICAgICAgICBjb25zdCB1ID0gd287XG4gICAgICAgIHdvID0gbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gYygpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHdvID0gdTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGw7XG4gIH07XG59XG5sZXQgd28gPSBudWxsO1xuZnVuY3Rpb24gX24odCwgZSkge1xuICBpZiAoIXh0KVxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBJKFwicHJvdmlkZSgpIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHNldHVwKCkuXCIpO1xuICBlbHNlIHtcbiAgICBsZXQgbiA9IHh0LnByb3ZpZGVzO1xuICAgIGNvbnN0IHIgPSB4dC5wYXJlbnQgJiYgeHQucGFyZW50LnByb3ZpZGVzO1xuICAgIHIgPT09IG4gJiYgKG4gPSB4dC5wcm92aWRlcyA9IE9iamVjdC5jcmVhdGUocikpLCBuW3RdID0gZTtcbiAgfVxufVxuZnVuY3Rpb24gUHQodCwgZSwgbiA9ICExKSB7XG4gIGNvbnN0IHIgPSB4dCB8fCBPdDtcbiAgaWYgKHIgfHwgd28pIHtcbiAgICBjb25zdCBpID0gciA/IHIucGFyZW50ID09IG51bGwgPyByLnZub2RlLmFwcENvbnRleHQgJiYgci52bm9kZS5hcHBDb250ZXh0LnByb3ZpZGVzIDogci5wYXJlbnQucHJvdmlkZXMgOiB3by5fY29udGV4dC5wcm92aWRlcztcbiAgICBpZiAoaSAmJiB0IGluIGkpXG4gICAgICByZXR1cm4gaVt0XTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpXG4gICAgICByZXR1cm4gbiAmJiBiZShlKSA/IGUuY2FsbChyICYmIHIucHJveHkpIDogZTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgSShgaW5qZWN0aW9uIFwiJHtTdHJpbmcodCl9XCIgbm90IGZvdW5kLmApO1xuICB9IGVsc2VcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgSShcImluamVjdCgpIGNhbiBvbmx5IGJlIHVzZWQgaW5zaWRlIHNldHVwKCkgb3IgZnVuY3Rpb25hbCBjb21wb25lbnRzLlwiKTtcbn1cbmZ1bmN0aW9uIHpFKCkge1xuICByZXR1cm4gISEoeHQgfHwgT3QgfHwgd28pO1xufVxuZnVuY3Rpb24gSEUodCwgZSwgbiwgciA9ICExKSB7XG4gIGNvbnN0IGkgPSB7fSwgcyA9IHt9O1xuICBidShzLCBQZCwgMSksIHQucHJvcHNEZWZhdWx0cyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCB5MSh0LCBlLCBpLCBzKTtcbiAgZm9yIChjb25zdCBvIGluIHQucHJvcHNPcHRpb25zWzBdKVxuICAgIG8gaW4gaSB8fCAoaVtvXSA9IHZvaWQgMCk7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB3MShlIHx8IHt9LCBpLCB0KSwgbiA/IHQucHJvcHMgPSByID8gaSA6IEl5KGkpIDogdC50eXBlLnByb3BzID8gdC5wcm9wcyA9IGkgOiB0LnByb3BzID0gcywgdC5hdHRycyA9IHM7XG59XG5mdW5jdGlvbiBGRSh0KSB7XG4gIGZvciAoOyB0OyApIHtcbiAgICBpZiAodC50eXBlLl9faG1ySWQpXG4gICAgICByZXR1cm4gITA7XG4gICAgdCA9IHQucGFyZW50O1xuICB9XG59XG5mdW5jdGlvbiBHRSh0LCBlLCBuLCByKSB7XG4gIGNvbnN0IHtcbiAgICBwcm9wczogaSxcbiAgICBhdHRyczogcyxcbiAgICB2bm9kZTogeyBwYXRjaEZsYWc6IG8gfVxuICB9ID0gdCwgYSA9IE9lKGkpLCBbbF0gPSB0LnByb3BzT3B0aW9ucztcbiAgbGV0IGMgPSAhMTtcbiAgaWYgKFxuICAgIC8vIGFsd2F5cyBmb3JjZSBmdWxsIGRpZmYgaW4gZGV2XG4gICAgLy8gLSAjMTk0MiBpZiBobXIgaXMgZW5hYmxlZCB3aXRoIHNmYyBjb21wb25lbnRcbiAgICAvLyAtIHZpdGUjODcyIG5vbi1zZmMgY29tcG9uZW50IHVzZWQgYnkgc2ZjIGNvbXBvbmVudFxuICAgICEocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIEZFKHQpKSAmJiAociB8fCBvID4gMCkgJiYgIShvICYgMTYpXG4gICkge1xuICAgIGlmIChvICYgOCkge1xuICAgICAgY29uc3QgdSA9IHQudm5vZGUuZHluYW1pY1Byb3BzO1xuICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCB1Lmxlbmd0aDsgZCsrKSB7XG4gICAgICAgIGxldCBmID0gdVtkXTtcbiAgICAgICAgaWYgKGJkKHQuZW1pdHNPcHRpb25zLCBmKSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgaCA9IGVbZl07XG4gICAgICAgIGlmIChsKVxuICAgICAgICAgIGlmIChBZShzLCBmKSlcbiAgICAgICAgICAgIGggIT09IHNbZl0gJiYgKHNbZl0gPSBoLCBjID0gITApO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcCA9IG10KGYpO1xuICAgICAgICAgICAgaVtwXSA9IGdoKFxuICAgICAgICAgICAgICBsLFxuICAgICAgICAgICAgICBhLFxuICAgICAgICAgICAgICBwLFxuICAgICAgICAgICAgICBoLFxuICAgICAgICAgICAgICB0LFxuICAgICAgICAgICAgICAhMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBoICE9PSBzW2ZdICYmIChzW2ZdID0gaCwgYyA9ICEwKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgeTEodCwgZSwgaSwgcykgJiYgKGMgPSAhMCk7XG4gICAgbGV0IHU7XG4gICAgZm9yIChjb25zdCBkIGluIGEpXG4gICAgICAoIWUgfHwgLy8gZm9yIGNhbWVsQ2FzZVxuICAgICAgIUFlKGUsIGQpICYmIC8vIGl0J3MgcG9zc2libGUgdGhlIG9yaWdpbmFsIHByb3BzIHdhcyBwYXNzZWQgaW4gYXMga2ViYWItY2FzZVxuICAgICAgLy8gYW5kIGNvbnZlcnRlZCB0byBjYW1lbENhc2UgKCM5NTUpXG4gICAgICAoKHUgPSBybihkKSkgPT09IGQgfHwgIUFlKGUsIHUpKSkgJiYgKGwgPyBuICYmIC8vIGZvciBjYW1lbENhc2VcbiAgICAgIChuW2RdICE9PSB2b2lkIDAgfHwgLy8gZm9yIGtlYmFiLWNhc2VcbiAgICAgIG5bdV0gIT09IHZvaWQgMCkgJiYgKGlbZF0gPSBnaChcbiAgICAgICAgbCxcbiAgICAgICAgYSxcbiAgICAgICAgZCxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICB0LFxuICAgICAgICAhMFxuICAgICAgKSkgOiBkZWxldGUgaVtkXSk7XG4gICAgaWYgKHMgIT09IGEpXG4gICAgICBmb3IgKGNvbnN0IGQgaW4gcylcbiAgICAgICAgKCFlIHx8ICFBZShlLCBkKSkgJiYgKGRlbGV0ZSBzW2RdLCBjID0gITApO1xuICB9XG4gIGMgJiYgWnIodCwgXCJzZXRcIiwgXCIkYXR0cnNcIiksIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB3MShlIHx8IHt9LCBpLCB0KTtcbn1cbmZ1bmN0aW9uIHkxKHQsIGUsIG4sIHIpIHtcbiAgY29uc3QgW2ksIHNdID0gdC5wcm9wc09wdGlvbnM7XG4gIGxldCBvID0gITEsIGE7XG4gIGlmIChlKVxuICAgIGZvciAobGV0IGwgaW4gZSkge1xuICAgICAgaWYgKFVpKGwpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNvbnN0IGMgPSBlW2xdO1xuICAgICAgbGV0IHU7XG4gICAgICBpICYmIEFlKGksIHUgPSBtdChsKSkgPyAhcyB8fCAhcy5pbmNsdWRlcyh1KSA/IG5bdV0gPSBjIDogKGEgfHwgKGEgPSB7fSkpW3VdID0gYyA6IGJkKHQuZW1pdHNPcHRpb25zLCBsKSB8fCAoIShsIGluIHIpIHx8IGMgIT09IHJbbF0pICYmIChyW2xdID0gYywgbyA9ICEwKTtcbiAgICB9XG4gIGlmIChzKSB7XG4gICAgY29uc3QgbCA9IE9lKG4pLCBjID0gYSB8fCBWZTtcbiAgICBmb3IgKGxldCB1ID0gMDsgdSA8IHMubGVuZ3RoOyB1KyspIHtcbiAgICAgIGNvbnN0IGQgPSBzW3VdO1xuICAgICAgbltkXSA9IGdoKFxuICAgICAgICBpLFxuICAgICAgICBsLFxuICAgICAgICBkLFxuICAgICAgICBjW2RdLFxuICAgICAgICB0LFxuICAgICAgICAhQWUoYywgZClcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvO1xufVxuZnVuY3Rpb24gZ2godCwgZSwgbiwgciwgaSwgcykge1xuICBjb25zdCBvID0gdFtuXTtcbiAgaWYgKG8gIT0gbnVsbCkge1xuICAgIGNvbnN0IGEgPSBBZShvLCBcImRlZmF1bHRcIik7XG4gICAgaWYgKGEgJiYgciA9PT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBsID0gby5kZWZhdWx0O1xuICAgICAgaWYgKG8udHlwZSAhPT0gRnVuY3Rpb24gJiYgIW8uc2tpcEZhY3RvcnkgJiYgYmUobCkpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wc0RlZmF1bHRzOiBjIH0gPSBpO1xuICAgICAgICBpZiAobiBpbiBjKVxuICAgICAgICAgIHIgPSBjW25dO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb25zdCB1ID0gQnMoaSk7XG4gICAgICAgICAgciA9IGNbbl0gPSBsLmNhbGwoXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgZVxuICAgICAgICAgICksIHUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlXG4gICAgICAgIHIgPSBsO1xuICAgIH1cbiAgICBvW1xuICAgICAgMFxuICAgICAgLyogc2hvdWxkQ2FzdCAqL1xuICAgIF0gJiYgKHMgJiYgIWEgPyByID0gITEgOiBvW1xuICAgICAgMVxuICAgICAgLyogc2hvdWxkQ2FzdFRydWUgKi9cbiAgICBdICYmIChyID09PSBcIlwiIHx8IHIgPT09IHJuKG4pKSAmJiAociA9ICEwKSk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBTMSh0LCBlLCBuID0gITEpIHtcbiAgY29uc3QgciA9IGUucHJvcHNDYWNoZSwgaSA9IHIuZ2V0KHQpO1xuICBpZiAoaSlcbiAgICByZXR1cm4gaTtcbiAgY29uc3QgcyA9IHQucHJvcHMsIG8gPSB7fSwgYSA9IFtdO1xuICBsZXQgbCA9ICExO1xuICBpZiAoX19WVUVfT1BUSU9OU19BUElfXyAmJiAhYmUodCkpIHtcbiAgICBjb25zdCB1ID0gKGQpID0+IHtcbiAgICAgIGwgPSAhMDtcbiAgICAgIGNvbnN0IFtmLCBoXSA9IFMxKGQsIGUsICEwKTtcbiAgICAgICRlKG8sIGYpLCBoICYmIGEucHVzaCguLi5oKTtcbiAgICB9O1xuICAgICFuICYmIGUubWl4aW5zLmxlbmd0aCAmJiBlLm1peGlucy5mb3JFYWNoKHUpLCB0LmV4dGVuZHMgJiYgdSh0LmV4dGVuZHMpLCB0Lm1peGlucyAmJiB0Lm1peGlucy5mb3JFYWNoKHUpO1xuICB9XG4gIGlmICghcyAmJiAhbClcbiAgICByZXR1cm4gWmUodCkgJiYgci5zZXQodCwgbW8pLCBtbztcbiAgaWYgKGllKHMpKVxuICAgIGZvciAobGV0IHUgPSAwOyB1IDwgcy5sZW5ndGg7IHUrKykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICF3ZShzW3VdKSAmJiBJKFwicHJvcHMgbXVzdCBiZSBzdHJpbmdzIHdoZW4gdXNpbmcgYXJyYXkgc3ludGF4LlwiLCBzW3VdKTtcbiAgICAgIGNvbnN0IGQgPSBtdChzW3VdKTtcbiAgICAgIEVtKGQpICYmIChvW2RdID0gVmUpO1xuICAgIH1cbiAgZWxzZSBpZiAocykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhWmUocykgJiYgSShcImludmFsaWQgcHJvcHMgb3B0aW9uc1wiLCBzKTtcbiAgICBmb3IgKGNvbnN0IHUgaW4gcykge1xuICAgICAgY29uc3QgZCA9IG10KHUpO1xuICAgICAgaWYgKEVtKGQpKSB7XG4gICAgICAgIGNvbnN0IGYgPSBzW3VdLCBoID0gb1tkXSA9IGllKGYpIHx8IGJlKGYpID8geyB0eXBlOiBmIH0gOiAkZSh7fSwgZik7XG4gICAgICAgIGlmIChoKSB7XG4gICAgICAgICAgY29uc3QgcCA9IFFtKEJvb2xlYW4sIGgudHlwZSksIE8gPSBRbShTdHJpbmcsIGgudHlwZSk7XG4gICAgICAgICAgaFtcbiAgICAgICAgICAgIDBcbiAgICAgICAgICAgIC8qIHNob3VsZENhc3QgKi9cbiAgICAgICAgICBdID0gcCA+IC0xLCBoW1xuICAgICAgICAgICAgMVxuICAgICAgICAgICAgLyogc2hvdWxkQ2FzdFRydWUgKi9cbiAgICAgICAgICBdID0gTyA8IDAgfHwgcCA8IE8sIChwID4gLTEgfHwgQWUoaCwgXCJkZWZhdWx0XCIpKSAmJiBhLnB1c2goZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgYyA9IFtvLCBhXTtcbiAgcmV0dXJuIFplKHQpICYmIHIuc2V0KHQsIGMpLCBjO1xufVxuZnVuY3Rpb24gRW0odCkge1xuICByZXR1cm4gdFswXSAhPT0gXCIkXCIgJiYgIVVpKHQpID8gITAgOiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIEkoYEludmFsaWQgcHJvcCBuYW1lOiBcIiR7dH1cIiBpcyBhIHJlc2VydmVkIHByb3BlcnR5LmApLCAhMSk7XG59XG5mdW5jdGlvbiBtaCh0KSB7XG4gIHJldHVybiB0ID09PSBudWxsID8gXCJudWxsXCIgOiB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgPyB0Lm5hbWUgfHwgXCJcIiA6IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgJiYgdC5jb25zdHJ1Y3RvciAmJiB0LmNvbnN0cnVjdG9yLm5hbWUgfHwgXCJcIjtcbn1cbmZ1bmN0aW9uICRtKHQsIGUpIHtcbiAgcmV0dXJuIG1oKHQpID09PSBtaChlKTtcbn1cbmZ1bmN0aW9uIFFtKHQsIGUpIHtcbiAgcmV0dXJuIGllKGUpID8gZS5maW5kSW5kZXgoKG4pID0+ICRtKG4sIHQpKSA6IGJlKGUpICYmICRtKGUsIHQpID8gMCA6IC0xO1xufVxuZnVuY3Rpb24gdzEodCwgZSwgbikge1xuICBjb25zdCByID0gT2UoZSksIGkgPSBuLnByb3BzT3B0aW9uc1swXTtcbiAgZm9yIChjb25zdCBzIGluIGkpIHtcbiAgICBsZXQgbyA9IGlbc107XG4gICAgbyAhPSBudWxsICYmIEtFKFxuICAgICAgcyxcbiAgICAgIHJbc10sXG4gICAgICBvLFxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gRG4ocikgOiByLFxuICAgICAgIUFlKHQsIHMpICYmICFBZSh0LCBybihzKSlcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBLRSh0LCBlLCBuLCByLCBpKSB7XG4gIGNvbnN0IHsgdHlwZTogcywgcmVxdWlyZWQ6IG8sIHZhbGlkYXRvcjogYSwgc2tpcENoZWNrOiBsIH0gPSBuO1xuICBpZiAobyAmJiBpKSB7XG4gICAgSSgnTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyB0ICsgJ1wiJyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghKGUgPT0gbnVsbCAmJiAhbykpIHtcbiAgICBpZiAocyAhPSBudWxsICYmIHMgIT09ICEwICYmICFsKSB7XG4gICAgICBsZXQgYyA9ICExO1xuICAgICAgY29uc3QgdSA9IGllKHMpID8gcyA6IFtzXSwgZCA9IFtdO1xuICAgICAgZm9yIChsZXQgZiA9IDA7IGYgPCB1Lmxlbmd0aCAmJiAhYzsgZisrKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsaWQ6IGgsIGV4cGVjdGVkVHlwZTogcCB9ID0gZSQoZSwgdVtmXSk7XG4gICAgICAgIGQucHVzaChwIHx8IFwiXCIpLCBjID0gaDtcbiAgICAgIH1cbiAgICAgIGlmICghYykge1xuICAgICAgICBJKHQkKHQsIGUsIGQpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBhICYmICFhKGUsIHIpICYmIEkoJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgdCArICdcIi4nKTtcbiAgfVxufVxuY29uc3QgSkUgPSAvKiBAX19QVVJFX18gKi8gQnQoXG4gIFwiU3RyaW5nLE51bWJlcixCb29sZWFuLEZ1bmN0aW9uLFN5bWJvbCxCaWdJbnRcIlxuKTtcbmZ1bmN0aW9uIGUkKHQsIGUpIHtcbiAgbGV0IG47XG4gIGNvbnN0IHIgPSBtaChlKTtcbiAgaWYgKEpFKHIpKSB7XG4gICAgY29uc3QgaSA9IHR5cGVvZiB0O1xuICAgIG4gPSBpID09PSByLnRvTG93ZXJDYXNlKCksICFuICYmIGkgPT09IFwib2JqZWN0XCIgJiYgKG4gPSB0IGluc3RhbmNlb2YgZSk7XG4gIH0gZWxzZVxuICAgIHIgPT09IFwiT2JqZWN0XCIgPyBuID0gWmUodCkgOiByID09PSBcIkFycmF5XCIgPyBuID0gaWUodCkgOiByID09PSBcIm51bGxcIiA/IG4gPSB0ID09PSBudWxsIDogbiA9IHQgaW5zdGFuY2VvZiBlO1xuICByZXR1cm4ge1xuICAgIHZhbGlkOiBuLFxuICAgIGV4cGVjdGVkVHlwZTogclxuICB9O1xufVxuZnVuY3Rpb24gdCQodCwgZSwgbikge1xuICBpZiAobi5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIGBQcm9wIHR5cGUgW10gZm9yIHByb3AgXCIke3R9XCIgd29uJ3QgbWF0Y2ggYW55dGhpbmcuIERpZCB5b3UgbWVhbiB0byB1c2UgdHlwZSBBcnJheSBpbnN0ZWFkP2A7XG4gIGxldCByID0gYEludmFsaWQgcHJvcDogdHlwZSBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCIke3R9XCIuIEV4cGVjdGVkICR7bi5tYXAoV3IpLmpvaW4oXCIgfCBcIil9YDtcbiAgY29uc3QgaSA9IG5bMF0sIHMgPSBHcChlKSwgbyA9IENtKGUsIGkpLCBhID0gQ20oZSwgcyk7XG4gIHJldHVybiBuLmxlbmd0aCA9PT0gMSAmJiBBbShpKSAmJiAhbiQoaSwgcykgJiYgKHIgKz0gYCB3aXRoIHZhbHVlICR7b31gKSwgciArPSBgLCBnb3QgJHtzfSBgLCBBbShzKSAmJiAociArPSBgd2l0aCB2YWx1ZSAke2F9LmApLCByO1xufVxuZnVuY3Rpb24gQ20odCwgZSkge1xuICByZXR1cm4gZSA9PT0gXCJTdHJpbmdcIiA/IGBcIiR7dH1cImAgOiBlID09PSBcIk51bWJlclwiID8gYCR7TnVtYmVyKHQpfWAgOiBgJHt0fWA7XG59XG5mdW5jdGlvbiBBbSh0KSB7XG4gIHJldHVybiBbXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJib29sZWFuXCJdLnNvbWUoKG4pID0+IHQudG9Mb3dlckNhc2UoKSA9PT0gbik7XG59XG5mdW5jdGlvbiBuJCguLi50KSB7XG4gIHJldHVybiB0LnNvbWUoKGUpID0+IGUudG9Mb3dlckNhc2UoKSA9PT0gXCJib29sZWFuXCIpO1xufVxuY29uc3QgazEgPSAodCkgPT4gdFswXSA9PT0gXCJfXCIgfHwgdCA9PT0gXCIkc3RhYmxlXCIsIF9PID0gKHQpID0+IGllKHQpID8gdC5tYXAoU24pIDogW1NuKHQpXSwgciQgPSAodCwgZSwgbikgPT4ge1xuICBpZiAoZS5fbilcbiAgICByZXR1cm4gZTtcbiAgY29uc3QgciA9IGNlKCguLi5pKSA9PiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHh0ICYmICghbiB8fCBuLnJvb3QgPT09IHh0LnJvb3QpICYmIEkoXG4gICAgYFNsb3QgXCIke3R9XCIgaW52b2tlZCBvdXRzaWRlIG9mIHRoZSByZW5kZXIgZnVuY3Rpb246IHRoaXMgd2lsbCBub3QgdHJhY2sgZGVwZW5kZW5jaWVzIHVzZWQgaW4gdGhlIHNsb3QuIEludm9rZSB0aGUgc2xvdCBmdW5jdGlvbiBpbnNpZGUgdGhlIHJlbmRlciBmdW5jdGlvbiBpbnN0ZWFkLmBcbiAgKSwgX08oZSguLi5pKSkpLCBuKTtcbiAgcmV0dXJuIHIuX2MgPSAhMSwgcjtcbn0sIHgxID0gKHQsIGUsIG4pID0+IHtcbiAgY29uc3QgciA9IHQuX2N0eDtcbiAgZm9yIChjb25zdCBpIGluIHQpIHtcbiAgICBpZiAoazEoaSkpXG4gICAgICBjb250aW51ZTtcbiAgICBjb25zdCBzID0gdFtpXTtcbiAgICBpZiAoYmUocykpXG4gICAgICBlW2ldID0gciQoaSwgcywgcik7XG4gICAgZWxzZSBpZiAocyAhPSBudWxsKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgSShcbiAgICAgICAgYE5vbi1mdW5jdGlvbiB2YWx1ZSBlbmNvdW50ZXJlZCBmb3Igc2xvdCBcIiR7aX1cIi4gUHJlZmVyIGZ1bmN0aW9uIHNsb3RzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuYFxuICAgICAgKTtcbiAgICAgIGNvbnN0IG8gPSBfTyhzKTtcbiAgICAgIGVbaV0gPSAoKSA9PiBvO1xuICAgIH1cbiAgfVxufSwgUDEgPSAodCwgZSkgPT4ge1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIXRhKHQudm5vZGUpICYmIEkoXG4gICAgXCJOb24tZnVuY3Rpb24gdmFsdWUgZW5jb3VudGVyZWQgZm9yIGRlZmF1bHQgc2xvdC4gUHJlZmVyIGZ1bmN0aW9uIHNsb3RzIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuXCJcbiAgKTtcbiAgY29uc3QgbiA9IF9PKGUpO1xuICB0LnNsb3RzLmRlZmF1bHQgPSAoKSA9PiBuO1xufSwgaSQgPSAodCwgZSkgPT4ge1xuICBpZiAodC52bm9kZS5zaGFwZUZsYWcgJiAzMikge1xuICAgIGNvbnN0IG4gPSBlLl87XG4gICAgbiA/ICh0LnNsb3RzID0gT2UoZSksIGJ1KGUsIFwiX1wiLCBuKSkgOiB4MShcbiAgICAgIGUsXG4gICAgICB0LnNsb3RzID0ge31cbiAgICApO1xuICB9IGVsc2VcbiAgICB0LnNsb3RzID0ge30sIGUgJiYgUDEodCwgZSk7XG4gIGJ1KHQuc2xvdHMsIFBkLCAxKTtcbn0sIHMkID0gKHQsIGUsIG4pID0+IHtcbiAgY29uc3QgeyB2bm9kZTogciwgc2xvdHM6IGkgfSA9IHQ7XG4gIGxldCBzID0gITAsIG8gPSBWZTtcbiAgaWYgKHIuc2hhcGVGbGFnICYgMzIpIHtcbiAgICBjb25zdCBhID0gZS5fO1xuICAgIGEgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgSGkgPyAoJGUoaSwgZSksIFpyKHQsIFwic2V0XCIsIFwiJHNsb3RzXCIpKSA6IG4gJiYgYSA9PT0gMSA/IHMgPSAhMSA6ICgkZShpLCBlKSwgIW4gJiYgYSA9PT0gMSAmJiBkZWxldGUgaS5fKSA6IChzID0gIWUuJHN0YWJsZSwgeDEoZSwgaSkpLCBvID0gZTtcbiAgfSBlbHNlXG4gICAgZSAmJiAoUDEodCwgZSksIG8gPSB7IGRlZmF1bHQ6IDEgfSk7XG4gIGlmIChzKVxuICAgIGZvciAoY29uc3QgYSBpbiBpKVxuICAgICAgIWsxKGEpICYmIG9bYV0gPT0gbnVsbCAmJiBkZWxldGUgaVthXTtcbn07XG5mdW5jdGlvbiBQdSh0LCBlLCBuLCByLCBpID0gITEpIHtcbiAgaWYgKGllKHQpKSB7XG4gICAgdC5mb3JFYWNoKFxuICAgICAgKGYsIGgpID0+IFB1KFxuICAgICAgICBmLFxuICAgICAgICBlICYmIChpZShlKSA/IGVbaF0gOiBlKSxcbiAgICAgICAgbixcbiAgICAgICAgcixcbiAgICAgICAgaVxuICAgICAgKVxuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChEcyhyKSAmJiAhaSlcbiAgICByZXR1cm47XG4gIGNvbnN0IHMgPSByLnNoYXBlRmxhZyAmIDQgPyBfZChyLmNvbXBvbmVudCkgfHwgci5jb21wb25lbnQucHJveHkgOiByLmVsLCBvID0gaSA/IG51bGwgOiBzLCB7IGk6IGEsIHI6IGwgfSA9IHQ7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIWEpIHtcbiAgICBJKFxuICAgICAgXCJNaXNzaW5nIHJlZiBvd25lciBjb250ZXh0LiByZWYgY2Fubm90IGJlIHVzZWQgb24gaG9pc3RlZCB2bm9kZXMuIEEgdm5vZGUgd2l0aCByZWYgbXVzdCBiZSBjcmVhdGVkIGluc2lkZSB0aGUgcmVuZGVyIGZ1bmN0aW9uLlwiXG4gICAgKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgYyA9IGUgJiYgZS5yLCB1ID0gYS5yZWZzID09PSBWZSA/IGEucmVmcyA9IHt9IDogYS5yZWZzLCBkID0gYS5zZXR1cFN0YXRlO1xuICBpZiAoYyAhPSBudWxsICYmIGMgIT09IGwgJiYgKHdlKGMpID8gKHVbY10gPSBudWxsLCBBZShkLCBjKSAmJiAoZFtjXSA9IG51bGwpKSA6IEN0KGMpICYmIChjLnZhbHVlID0gbnVsbCkpLCBiZShsKSlcbiAgICBWcihsLCBhLCAxMiwgW28sIHVdKTtcbiAgZWxzZSB7XG4gICAgY29uc3QgZiA9IHdlKGwpLCBoID0gQ3QobCk7XG4gICAgaWYgKGYgfHwgaCkge1xuICAgICAgY29uc3QgcCA9ICgpID0+IHtcbiAgICAgICAgaWYgKHQuZikge1xuICAgICAgICAgIGNvbnN0IE8gPSBmID8gQWUoZCwgbCkgPyBkW2xdIDogdVtsXSA6IGwudmFsdWU7XG4gICAgICAgICAgaSA/IGllKE8pICYmIEZwKE8sIHMpIDogaWUoTykgPyBPLmluY2x1ZGVzKHMpIHx8IE8ucHVzaChzKSA6IGYgPyAodVtsXSA9IFtzXSwgQWUoZCwgbCkgJiYgKGRbbF0gPSB1W2xdKSkgOiAobC52YWx1ZSA9IFtzXSwgdC5rICYmICh1W3Qua10gPSBsLnZhbHVlKSk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGYgPyAodVtsXSA9IG8sIEFlKGQsIGwpICYmIChkW2xdID0gbykpIDogaCA/IChsLnZhbHVlID0gbywgdC5rICYmICh1W3Qua10gPSBvKSkgOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgSShcIkludmFsaWQgdGVtcGxhdGUgcmVmIHR5cGU6XCIsIGwsIGAoJHt0eXBlb2YgbH0pYCk7XG4gICAgICB9O1xuICAgICAgbyA/IChwLmlkID0gLTEsIFl0KHAsIG4pKSA6IHAoKTtcbiAgICB9IGVsc2VcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBJKFwiSW52YWxpZCB0ZW1wbGF0ZSByZWYgdHlwZTpcIiwgbCwgYCgke3R5cGVvZiBsfSlgKTtcbiAgfVxufVxubGV0IFlyID0gITE7XG5jb25zdCBvJCA9ICh0KSA9PiB0Lm5hbWVzcGFjZVVSSS5pbmNsdWRlcyhcInN2Z1wiKSAmJiB0LnRhZ05hbWUgIT09IFwiZm9yZWlnbk9iamVjdFwiLCBhJCA9ICh0KSA9PiB0Lm5hbWVzcGFjZVVSSS5pbmNsdWRlcyhcIk1hdGhNTFwiKSwgZ2MgPSAodCkgPT4ge1xuICBpZiAobyQodCkpXG4gICAgcmV0dXJuIFwic3ZnXCI7XG4gIGlmIChhJCh0KSlcbiAgICByZXR1cm4gXCJtYXRobWxcIjtcbn0sIHVhID0gKHQpID0+IHQubm9kZVR5cGUgPT09IDg7XG5mdW5jdGlvbiBsJCh0KSB7XG4gIGNvbnN0IHtcbiAgICBtdDogZSxcbiAgICBwOiBuLFxuICAgIG86IHtcbiAgICAgIHBhdGNoUHJvcDogcixcbiAgICAgIGNyZWF0ZVRleHQ6IGksXG4gICAgICBuZXh0U2libGluZzogcyxcbiAgICAgIHBhcmVudE5vZGU6IG8sXG4gICAgICByZW1vdmU6IGEsXG4gICAgICBpbnNlcnQ6IGwsXG4gICAgICBjcmVhdGVDb21tZW50OiBjXG4gICAgfVxuICB9ID0gdCwgdSA9IChnLCB2KSA9PiB7XG4gICAgaWYgKCF2Lmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiB8fCBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18pICYmIEkoXG4gICAgICAgIFwiQXR0ZW1wdGluZyB0byBoeWRyYXRlIGV4aXN0aW5nIG1hcmt1cCBidXQgY29udGFpbmVyIGlzIGVtcHR5LiBQZXJmb3JtaW5nIGZ1bGwgbW91bnQgaW5zdGVhZC5cIlxuICAgICAgKSwgbihudWxsLCBnLCB2KSwgU3UoKSwgdi5fdm5vZGUgPSBnO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBZciA9ICExLCBkKHYuZmlyc3RDaGlsZCwgZywgbnVsbCwgbnVsbCwgbnVsbCksIFN1KCksIHYuX3Zub2RlID0gZywgWXIgJiYgY29uc29sZS5lcnJvcihcIkh5ZHJhdGlvbiBjb21wbGV0ZWQgYnV0IGNvbnRhaW5zIG1pc21hdGNoZXMuXCIpO1xuICB9LCBkID0gKGcsIHYsIFMsIHcsIGssIF8gPSAhMSkgPT4ge1xuICAgIGNvbnN0IFQgPSB1YShnKSAmJiBnLmRhdGEgPT09IFwiW1wiLCBDID0gKCkgPT4gTyhcbiAgICAgIGcsXG4gICAgICB2LFxuICAgICAgUyxcbiAgICAgIHcsXG4gICAgICBrLFxuICAgICAgVFxuICAgICksIHsgdHlwZTogQSwgcmVmOiBRLCBzaGFwZUZsYWc6IFcsIHBhdGNoRmxhZzogTCB9ID0gdjtcbiAgICBsZXQgcmUgPSBnLm5vZGVUeXBlO1xuICAgIHYuZWwgPSBnLCAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykgJiYgKFwiX192bm9kZVwiIGluIGcgfHwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGcsIFwiX192bm9kZVwiLCB7XG4gICAgICB2YWx1ZTogdixcbiAgICAgIGVudW1lcmFibGU6ICExXG4gICAgfSksIFwiX192dWVQYXJlbnRDb21wb25lbnRcIiBpbiBnIHx8IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnLCBcIl9fdnVlUGFyZW50Q29tcG9uZW50XCIsIHtcbiAgICAgIHZhbHVlOiBTLFxuICAgICAgZW51bWVyYWJsZTogITFcbiAgICB9KSksIEwgPT09IC0yICYmIChfID0gITEsIHYuZHluYW1pY0NoaWxkcmVuID0gbnVsbCk7XG4gICAgbGV0IFkgPSBudWxsO1xuICAgIHN3aXRjaCAoQSkge1xuICAgICAgY2FzZSBuczpcbiAgICAgICAgcmUgIT09IDMgPyB2LmNoaWxkcmVuID09PSBcIlwiID8gKGwodi5lbCA9IGkoXCJcIiksIG8oZyksIGcpLCBZID0gZykgOiBZID0gQygpIDogKGcuZGF0YSAhPT0gdi5jaGlsZHJlbiAmJiAoWXIgPSAhMCwgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiB8fCBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18pICYmIEkoXG4gICAgICAgICAgXCJIeWRyYXRpb24gdGV4dCBtaXNtYXRjaCBpblwiLFxuICAgICAgICAgIGcucGFyZW50Tm9kZSxcbiAgICAgICAgICBgXG4gIC0gcmVuZGVyZWQgb24gc2VydmVyOiAke0pTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgZy5kYXRhXG4gICAgICAgICAgKX1cbiAgLSBleHBlY3RlZCBvbiBjbGllbnQ6ICR7SlNPTi5zdHJpbmdpZnkodi5jaGlsZHJlbil9YFxuICAgICAgICApLCBnLmRhdGEgPSB2LmNoaWxkcmVuKSwgWSA9IHMoZykpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX3Q6XG4gICAgICAgIGIoZykgPyAoWSA9IHMoZyksIHkoXG4gICAgICAgICAgdi5lbCA9IGcuY29udGVudC5maXJzdENoaWxkLFxuICAgICAgICAgIGcsXG4gICAgICAgICAgU1xuICAgICAgICApKSA6IHJlICE9PSA4IHx8IFQgPyBZID0gQygpIDogWSA9IHMoZyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBGaTpcbiAgICAgICAgaWYgKFQgJiYgKGcgPSBzKGcpLCByZSA9IGcubm9kZVR5cGUpLCByZSA9PT0gMSB8fCByZSA9PT0gMykge1xuICAgICAgICAgIFkgPSBnO1xuICAgICAgICAgIGNvbnN0IEsgPSAhdi5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgZm9yIChsZXQgQiA9IDA7IEIgPCB2LnN0YXRpY0NvdW50OyBCKyspXG4gICAgICAgICAgICBLICYmICh2LmNoaWxkcmVuICs9IFkubm9kZVR5cGUgPT09IDEgPyBZLm91dGVySFRNTCA6IFkuZGF0YSksIEIgPT09IHYuc3RhdGljQ291bnQgLSAxICYmICh2LmFuY2hvciA9IFkpLCBZID0gcyhZKTtcbiAgICAgICAgICByZXR1cm4gVCA/IHMoWSkgOiBZO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBDKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBQZTpcbiAgICAgICAgVCA/IFkgPSBwKFxuICAgICAgICAgIGcsXG4gICAgICAgICAgdixcbiAgICAgICAgICBTLFxuICAgICAgICAgIHcsXG4gICAgICAgICAgayxcbiAgICAgICAgICBfXG4gICAgICAgICkgOiBZID0gQygpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChXICYgMSlcbiAgICAgICAgICAocmUgIT09IDEgfHwgdi50eXBlLnRvTG93ZXJDYXNlKCkgIT09IGcudGFnTmFtZS50b0xvd2VyQ2FzZSgpKSAmJiAhYihnKSA/IFkgPSBDKCkgOiBZID0gZihcbiAgICAgICAgICAgIGcsXG4gICAgICAgICAgICB2LFxuICAgICAgICAgICAgUyxcbiAgICAgICAgICAgIHcsXG4gICAgICAgICAgICBrLFxuICAgICAgICAgICAgX1xuICAgICAgICAgICk7XG4gICAgICAgIGVsc2UgaWYgKFcgJiA2KSB7XG4gICAgICAgICAgdi5zbG90U2NvcGVJZHMgPSBrO1xuICAgICAgICAgIGNvbnN0IEsgPSBvKGcpO1xuICAgICAgICAgIGlmIChUID8gWSA9IG0oZykgOiB1YShnKSAmJiBnLmRhdGEgPT09IFwidGVsZXBvcnQgc3RhcnRcIiA/IFkgPSBtKGcsIGcuZGF0YSwgXCJ0ZWxlcG9ydCBlbmRcIikgOiBZID0gcyhnKSwgZShcbiAgICAgICAgICAgIHYsXG4gICAgICAgICAgICBLLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIFMsXG4gICAgICAgICAgICB3LFxuICAgICAgICAgICAgZ2MoSyksXG4gICAgICAgICAgICBfXG4gICAgICAgICAgKSwgRHModikpIHtcbiAgICAgICAgICAgIGxldCBCO1xuICAgICAgICAgICAgVCA/IChCID0gSihQZSksIEIuYW5jaG9yID0gWSA/IFkucHJldmlvdXNTaWJsaW5nIDogSy5sYXN0Q2hpbGQpIDogQiA9IGcubm9kZVR5cGUgPT09IDMgPyBIZShcIlwiKSA6IEooXCJkaXZcIiksIEIuZWwgPSBnLCB2LmNvbXBvbmVudC5zdWJUcmVlID0gQjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIFcgJiA2NCA/IHJlICE9PSA4ID8gWSA9IEMoKSA6IFkgPSB2LnR5cGUuaHlkcmF0ZShcbiAgICAgICAgICAgIGcsXG4gICAgICAgICAgICB2LFxuICAgICAgICAgICAgUyxcbiAgICAgICAgICAgIHcsXG4gICAgICAgICAgICBrLFxuICAgICAgICAgICAgXyxcbiAgICAgICAgICAgIHQsXG4gICAgICAgICAgICBoXG4gICAgICAgICAgKSA6IFcgJiAxMjggPyBZID0gdi50eXBlLmh5ZHJhdGUoXG4gICAgICAgICAgICBnLFxuICAgICAgICAgICAgdixcbiAgICAgICAgICAgIFMsXG4gICAgICAgICAgICB3LFxuICAgICAgICAgICAgZ2MobyhnKSksXG4gICAgICAgICAgICBrLFxuICAgICAgICAgICAgXyxcbiAgICAgICAgICAgIHQsXG4gICAgICAgICAgICBkXG4gICAgICAgICAgKSA6IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgfHwgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fKSAmJiBJKFwiSW52YWxpZCBIb3N0Vk5vZGUgdHlwZTpcIiwgQSwgYCgke3R5cGVvZiBBfSlgKTtcbiAgICB9XG4gICAgcmV0dXJuIFEgIT0gbnVsbCAmJiBQdShRLCBudWxsLCB3LCB2KSwgWTtcbiAgfSwgZiA9IChnLCB2LCBTLCB3LCBrLCBfKSA9PiB7XG4gICAgXyA9IF8gfHwgISF2LmR5bmFtaWNDaGlsZHJlbjtcbiAgICBjb25zdCB7IHR5cGU6IFQsIHByb3BzOiBDLCBwYXRjaEZsYWc6IEEsIHNoYXBlRmxhZzogUSwgZGlyczogVywgdHJhbnNpdGlvbjogTCB9ID0gdiwgcmUgPSBUID09PSBcImlucHV0XCIgfHwgVCA9PT0gXCJvcHRpb25cIjtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiIHx8IHJlIHx8IEEgIT09IC0xKSB7XG4gICAgICBXICYmIF9yKHYsIG51bGwsIFMsIFwiY3JlYXRlZFwiKTtcbiAgICAgIGxldCBZID0gITE7XG4gICAgICBpZiAoYihnKSkge1xuICAgICAgICBZID0gJDEodywgTCkgJiYgUyAmJiBTLnZub2RlLnByb3BzICYmIFMudm5vZGUucHJvcHMuYXBwZWFyO1xuICAgICAgICBjb25zdCBCID0gZy5jb250ZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgIFkgJiYgTC5iZWZvcmVFbnRlcihCKSwgeShCLCBnLCBTKSwgdi5lbCA9IGcgPSBCO1xuICAgICAgfVxuICAgICAgaWYgKFEgJiAxNiAmJiAvLyBza2lwIGlmIGVsZW1lbnQgaGFzIGlubmVySFRNTCAvIHRleHRDb250ZW50XG4gICAgICAhKEMgJiYgKEMuaW5uZXJIVE1MIHx8IEMudGV4dENvbnRlbnQpKSkge1xuICAgICAgICBsZXQgQiA9IGgoXG4gICAgICAgICAgZy5maXJzdENoaWxkLFxuICAgICAgICAgIHYsXG4gICAgICAgICAgZyxcbiAgICAgICAgICBTLFxuICAgICAgICAgIHcsXG4gICAgICAgICAgayxcbiAgICAgICAgICBfXG4gICAgICAgICksIF9lID0gITE7XG4gICAgICAgIGZvciAoOyBCOyApIHtcbiAgICAgICAgICBZciA9ICEwLCAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiIHx8IF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXykgJiYgIV9lICYmIChJKFxuICAgICAgICAgICAgXCJIeWRyYXRpb24gY2hpbGRyZW4gbWlzbWF0Y2ggb25cIixcbiAgICAgICAgICAgIGcsXG4gICAgICAgICAgICBgXG5TZXJ2ZXIgcmVuZGVyZWQgZWxlbWVudCBjb250YWlucyBtb3JlIGNoaWxkIG5vZGVzIHRoYW4gY2xpZW50IHZkb20uYFxuICAgICAgICAgICksIF9lID0gITApO1xuICAgICAgICAgIGNvbnN0IENlID0gQjtcbiAgICAgICAgICBCID0gQi5uZXh0U2libGluZywgYShDZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZVxuICAgICAgICBRICYgOCAmJiBnLnRleHRDb250ZW50ICE9PSB2LmNoaWxkcmVuICYmIChZciA9ICEwLCAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiIHx8IF9fVlVFX1BST0RfSFlEUkFUSU9OX01JU01BVENIX0RFVEFJTFNfXykgJiYgSShcbiAgICAgICAgICBcIkh5ZHJhdGlvbiB0ZXh0IGNvbnRlbnQgbWlzbWF0Y2ggb25cIixcbiAgICAgICAgICBnLFxuICAgICAgICAgIGBcbiAgLSByZW5kZXJlZCBvbiBzZXJ2ZXI6ICR7Zy50ZXh0Q29udGVudH1cbiAgLSBleHBlY3RlZCBvbiBjbGllbnQ6ICR7di5jaGlsZHJlbn1gXG4gICAgICAgICksIGcudGV4dENvbnRlbnQgPSB2LmNoaWxkcmVuKTtcbiAgICAgIGlmIChDKVxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiIHx8IHJlIHx8ICFfIHx8IEEgJiA0OClcbiAgICAgICAgICBmb3IgKGNvbnN0IEIgaW4gQylcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBjJChnLCBCLCBDW0JdLCB2LCBTKSAmJiAoWXIgPSAhMCksIChyZSAmJiAoQi5lbmRzV2l0aChcInZhbHVlXCIpIHx8IEIgPT09IFwiaW5kZXRlcm1pbmF0ZVwiKSB8fCBvaShCKSAmJiAhVWkoQikgfHwgLy8gZm9yY2UgaHlkcmF0ZSB2LWJpbmQgd2l0aCAucHJvcCBtb2RpZmllcnNcbiAgICAgICAgICAgIEJbMF0gPT09IFwiLlwiKSAmJiByKFxuICAgICAgICAgICAgICBnLFxuICAgICAgICAgICAgICBCLFxuICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICBDW0JdLFxuICAgICAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgICAgU1xuICAgICAgICAgICAgKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIEMub25DbGljayAmJiByKFxuICAgICAgICAgICAgZyxcbiAgICAgICAgICAgIFwib25DbGlja1wiLFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIEMub25DbGljayxcbiAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICAgIFNcbiAgICAgICAgICApO1xuICAgICAgbGV0IEs7XG4gICAgICAoSyA9IEMgJiYgQy5vblZub2RlQmVmb3JlTW91bnQpICYmIHluKEssIFMsIHYpLCBXICYmIF9yKHYsIG51bGwsIFMsIFwiYmVmb3JlTW91bnRcIiksICgoSyA9IEMgJiYgQy5vblZub2RlTW91bnRlZCkgfHwgVyB8fCBZKSAmJiBKeSgoKSA9PiB7XG4gICAgICAgIEsgJiYgeW4oSywgUywgdiksIFkgJiYgTC5lbnRlcihnKSwgVyAmJiBfcih2LCBudWxsLCBTLCBcIm1vdW50ZWRcIik7XG4gICAgICB9LCB3KTtcbiAgICB9XG4gICAgcmV0dXJuIGcubmV4dFNpYmxpbmc7XG4gIH0sIGggPSAoZywgdiwgUywgdywgaywgXywgVCkgPT4ge1xuICAgIFQgPSBUIHx8ICEhdi5keW5hbWljQ2hpbGRyZW47XG4gICAgY29uc3QgQyA9IHYuY2hpbGRyZW4sIEEgPSBDLmxlbmd0aDtcbiAgICBsZXQgUSA9ICExO1xuICAgIGZvciAobGV0IFcgPSAwOyBXIDwgQTsgVysrKSB7XG4gICAgICBjb25zdCBMID0gVCA/IENbV10gOiBDW1ddID0gU24oQ1tXXSk7XG4gICAgICBpZiAoZylcbiAgICAgICAgZyA9IGQoXG4gICAgICAgICAgZyxcbiAgICAgICAgICBMLFxuICAgICAgICAgIHcsXG4gICAgICAgICAgayxcbiAgICAgICAgICBfLFxuICAgICAgICAgIFRcbiAgICAgICAgKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoTC50eXBlID09PSBucyAmJiAhTC5jaGlsZHJlbilcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgWXIgPSAhMCwgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiB8fCBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18pICYmICFRICYmIChJKFxuICAgICAgICAgIFwiSHlkcmF0aW9uIGNoaWxkcmVuIG1pc21hdGNoIG9uXCIsXG4gICAgICAgICAgUyxcbiAgICAgICAgICBgXG5TZXJ2ZXIgcmVuZGVyZWQgZWxlbWVudCBjb250YWlucyBmZXdlciBjaGlsZCBub2RlcyB0aGFuIGNsaWVudCB2ZG9tLmBcbiAgICAgICAgKSwgUSA9ICEwKSwgbihcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIEwsXG4gICAgICAgICAgUyxcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHcsXG4gICAgICAgICAgayxcbiAgICAgICAgICBnYyhTKSxcbiAgICAgICAgICBfXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBnO1xuICB9LCBwID0gKGcsIHYsIFMsIHcsIGssIF8pID0+IHtcbiAgICBjb25zdCB7IHNsb3RTY29wZUlkczogVCB9ID0gdjtcbiAgICBUICYmIChrID0gayA/IGsuY29uY2F0KFQpIDogVCk7XG4gICAgY29uc3QgQyA9IG8oZyksIEEgPSBoKFxuICAgICAgcyhnKSxcbiAgICAgIHYsXG4gICAgICBDLFxuICAgICAgUyxcbiAgICAgIHcsXG4gICAgICBrLFxuICAgICAgX1xuICAgICk7XG4gICAgcmV0dXJuIEEgJiYgdWEoQSkgJiYgQS5kYXRhID09PSBcIl1cIiA/IHModi5hbmNob3IgPSBBKSA6IChZciA9ICEwLCBsKHYuYW5jaG9yID0gYyhcIl1cIiksIEMsIEEpLCBBKTtcbiAgfSwgTyA9IChnLCB2LCBTLCB3LCBrLCBfKSA9PiB7XG4gICAgaWYgKFlyID0gITAsIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgfHwgX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fKSAmJiBJKFxuICAgICAgYEh5ZHJhdGlvbiBub2RlIG1pc21hdGNoOlxuLSByZW5kZXJlZCBvbiBzZXJ2ZXI6YCxcbiAgICAgIGcsXG4gICAgICBnLm5vZGVUeXBlID09PSAzID8gXCIodGV4dClcIiA6IHVhKGcpICYmIGcuZGF0YSA9PT0gXCJbXCIgPyBcIihzdGFydCBvZiBmcmFnbWVudClcIiA6IFwiXCIsXG4gICAgICBgXG4tIGV4cGVjdGVkIG9uIGNsaWVudDpgLFxuICAgICAgdi50eXBlXG4gICAgKSwgdi5lbCA9IG51bGwsIF8pIHtcbiAgICAgIGNvbnN0IEEgPSBtKGcpO1xuICAgICAgZm9yICg7IDsgKSB7XG4gICAgICAgIGNvbnN0IFEgPSBzKGcpO1xuICAgICAgICBpZiAoUSAmJiBRICE9PSBBKVxuICAgICAgICAgIGEoUSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgVCA9IHMoZyksIEMgPSBvKGcpO1xuICAgIHJldHVybiBhKGcpLCBuKFxuICAgICAgbnVsbCxcbiAgICAgIHYsXG4gICAgICBDLFxuICAgICAgVCxcbiAgICAgIFMsXG4gICAgICB3LFxuICAgICAgZ2MoQyksXG4gICAgICBrXG4gICAgKSwgVDtcbiAgfSwgbSA9IChnLCB2ID0gXCJbXCIsIFMgPSBcIl1cIikgPT4ge1xuICAgIGxldCB3ID0gMDtcbiAgICBmb3IgKDsgZzsgKVxuICAgICAgaWYgKGcgPSBzKGcpLCBnICYmIHVhKGcpICYmIChnLmRhdGEgPT09IHYgJiYgdysrLCBnLmRhdGEgPT09IFMpKSB7XG4gICAgICAgIGlmICh3ID09PSAwKVxuICAgICAgICAgIHJldHVybiBzKGcpO1xuICAgICAgICB3LS07XG4gICAgICB9XG4gICAgcmV0dXJuIGc7XG4gIH0sIHkgPSAoZywgdiwgUykgPT4ge1xuICAgIGNvbnN0IHcgPSB2LnBhcmVudE5vZGU7XG4gICAgdyAmJiB3LnJlcGxhY2VDaGlsZChnLCB2KTtcbiAgICBsZXQgayA9IFM7XG4gICAgZm9yICg7IGs7IClcbiAgICAgIGsudm5vZGUuZWwgPT09IHYgJiYgKGsudm5vZGUuZWwgPSBrLnN1YlRyZWUuZWwgPSBnKSwgayA9IGsucGFyZW50O1xuICB9LCBiID0gKGcpID0+IGcubm9kZVR5cGUgPT09IDEgJiYgZy50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidGVtcGxhdGVcIjtcbiAgcmV0dXJuIFt1LCBkXTtcbn1cbmZ1bmN0aW9uIGMkKHQsIGUsIG4sIHIsIGkpIHtcbiAgdmFyIHM7XG4gIGxldCBvLCBhLCBsLCBjO1xuICBpZiAoZSA9PT0gXCJjbGFzc1wiKVxuICAgIGwgPSB0LmdldEF0dHJpYnV0ZShcImNsYXNzXCIpLCBjID0gS2UobiksIHUkKFJtKGwgfHwgXCJcIiksIFJtKGMpKSB8fCAobyA9IGEgPSBcImNsYXNzXCIpO1xuICBlbHNlIGlmIChlID09PSBcInN0eWxlXCIpIHtcbiAgICBsID0gdC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKSwgYyA9IHdlKG4pID8gbiA6IExfKEJyKG4pKTtcbiAgICBjb25zdCB1ID0gTm0obCksIGQgPSBObShjKTtcbiAgICBpZiAoci5kaXJzKVxuICAgICAgZm9yIChjb25zdCB7IGRpcjogaCwgdmFsdWU6IHAgfSBvZiByLmRpcnMpXG4gICAgICAgIGgubmFtZSA9PT0gXCJzaG93XCIgJiYgIXAgJiYgZC5zZXQoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTtcbiAgICBjb25zdCBmID0gaSA9PSBudWxsID8gdm9pZCAwIDogaS5zdWJUcmVlO1xuICAgIGlmIChyID09PSBmIHx8IChmID09IG51bGwgPyB2b2lkIDAgOiBmLnR5cGUpID09PSBQZSAmJiBmLmNoaWxkcmVuLmluY2x1ZGVzKHIpKSB7XG4gICAgICBjb25zdCBoID0gKHMgPSBpID09IG51bGwgPyB2b2lkIDAgOiBpLmdldENzc1ZhcnMpID09IG51bGwgPyB2b2lkIDAgOiBzLmNhbGwoaSk7XG4gICAgICBmb3IgKGNvbnN0IHAgaW4gaClcbiAgICAgICAgZC5zZXQoYC0tJHtwfWAsIFN0cmluZyhoW3BdKSk7XG4gICAgfVxuICAgIGQkKHUsIGQpIHx8IChvID0gYSA9IFwic3R5bGVcIik7XG4gIH0gZWxzZVxuICAgICh0IGluc3RhbmNlb2YgU1ZHRWxlbWVudCAmJiBLXyhlKSB8fCB0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgKGNtKGUpIHx8IEdfKGUpKSkgJiYgKGNtKGUpID8gKGwgPSB0Lmhhc0F0dHJpYnV0ZShlKSwgYyA9IEpwKG4pKSA6IG4gPT0gbnVsbCA/IChsID0gdC5oYXNBdHRyaWJ1dGUoZSksIGMgPSAhMSkgOiAodC5oYXNBdHRyaWJ1dGUoZSkgPyBsID0gdC5nZXRBdHRyaWJ1dGUoZSkgOiBlID09PSBcInZhbHVlXCIgJiYgdC50YWdOYW1lID09PSBcIlRFWFRBUkVBXCIgPyBsID0gdC52YWx1ZSA6IGwgPSAhMSwgYyA9IEpfKG4pID8gU3RyaW5nKG4pIDogITEpLCBsICE9PSBjICYmIChvID0gXCJhdHRyaWJ1dGVcIiwgYSA9IGUpKTtcbiAgaWYgKG8pIHtcbiAgICBjb25zdCB1ID0gKGgpID0+IGggPT09ICExID8gXCIobm90IHJlbmRlcmVkKVwiIDogYCR7YX09XCIke2h9XCJgLCBkID0gYEh5ZHJhdGlvbiAke299IG1pc21hdGNoIG9uYCwgZiA9IGBcbiAgLSByZW5kZXJlZCBvbiBzZXJ2ZXI6ICR7dShsKX1cbiAgLSBleHBlY3RlZCBvbiBjbGllbnQ6ICR7dShjKX1cbiAgTm90ZTogdGhpcyBtaXNtYXRjaCBpcyBjaGVjay1vbmx5LiBUaGUgRE9NIHdpbGwgbm90IGJlIHJlY3RpZmllZCBpbiBwcm9kdWN0aW9uIGR1ZSB0byBwZXJmb3JtYW5jZSBvdmVyaGVhZC5cbiAgWW91IHNob3VsZCBmaXggdGhlIHNvdXJjZSBvZiB0aGUgbWlzbWF0Y2guYDtcbiAgICByZXR1cm4gSShkLCB0LCBmKSwgITA7XG4gIH1cbiAgcmV0dXJuICExO1xufVxuZnVuY3Rpb24gUm0odCkge1xuICByZXR1cm4gbmV3IFNldCh0LnRyaW0oKS5zcGxpdCgvXFxzKy8pKTtcbn1cbmZ1bmN0aW9uIHUkKHQsIGUpIHtcbiAgaWYgKHQuc2l6ZSAhPT0gZS5zaXplKVxuICAgIHJldHVybiAhMTtcbiAgZm9yIChjb25zdCBuIG9mIHQpXG4gICAgaWYgKCFlLmhhcyhuKSlcbiAgICAgIHJldHVybiAhMTtcbiAgcmV0dXJuICEwO1xufVxuZnVuY3Rpb24gTm0odCkge1xuICBjb25zdCBlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZm9yIChjb25zdCBuIG9mIHQuc3BsaXQoXCI7XCIpKSB7XG4gICAgbGV0IFtyLCBpXSA9IG4uc3BsaXQoXCI6XCIpO1xuICAgIHIgPSByID09IG51bGwgPyB2b2lkIDAgOiByLnRyaW0oKSwgaSA9IGkgPT0gbnVsbCA/IHZvaWQgMCA6IGkudHJpbSgpLCByICYmIGkgJiYgZS5zZXQociwgaSk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBkJCh0LCBlKSB7XG4gIGlmICh0LnNpemUgIT09IGUuc2l6ZSlcbiAgICByZXR1cm4gITE7XG4gIGZvciAoY29uc3QgW24sIHJdIG9mIHQpXG4gICAgaWYgKHIgIT09IGUuZ2V0KG4pKVxuICAgICAgcmV0dXJuICExO1xuICByZXR1cm4gITA7XG59XG5sZXQgZGEsIFdpO1xuZnVuY3Rpb24gRnIodCwgZSkge1xuICB0LmFwcENvbnRleHQuY29uZmlnLnBlcmZvcm1hbmNlICYmIF91KCkgJiYgV2kubWFyayhgdnVlLSR7ZX0tJHt0LnVpZH1gKSwgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pICYmIEpUKHQsIGUsIF91KCkgPyBXaS5ub3coKSA6IERhdGUubm93KCkpO1xufVxuZnVuY3Rpb24gR3IodCwgZSkge1xuICBpZiAodC5hcHBDb250ZXh0LmNvbmZpZy5wZXJmb3JtYW5jZSAmJiBfdSgpKSB7XG4gICAgY29uc3QgbiA9IGB2dWUtJHtlfS0ke3QudWlkfWAsIHIgPSBuICsgXCI6ZW5kXCI7XG4gICAgV2kubWFyayhyKSwgV2kubWVhc3VyZShcbiAgICAgIGA8JHtUZCh0LCB0LnR5cGUpfT4gJHtlfWAsXG4gICAgICBuLFxuICAgICAgclxuICAgICksIFdpLmNsZWFyTWFya3MobiksIFdpLmNsZWFyTWFya3Mocik7XG4gIH1cbiAgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pICYmIGVFKHQsIGUsIF91KCkgPyBXaS5ub3coKSA6IERhdGUubm93KCkpO1xufVxuZnVuY3Rpb24gX3UoKSB7XG4gIHJldHVybiBkYSAhPT0gdm9pZCAwIHx8ICh0eXBlb2Ygd2luZG93IDwgXCJ1XCIgJiYgd2luZG93LnBlcmZvcm1hbmNlID8gKGRhID0gITAsIFdpID0gd2luZG93LnBlcmZvcm1hbmNlKSA6IGRhID0gITEpLCBkYTtcbn1cbmZ1bmN0aW9uIGYkKCkge1xuICBjb25zdCB0ID0gW107XG4gIGlmICh0eXBlb2YgX19WVUVfT1BUSU9OU19BUElfXyAhPSBcImJvb2xlYW5cIiAmJiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHQucHVzaChcIl9fVlVFX09QVElPTlNfQVBJX19cIiksIGJvKCkuX19WVUVfT1BUSU9OU19BUElfXyA9ICEwKSwgdHlwZW9mIF9fVlVFX1BST0RfREVWVE9PTFNfXyAhPSBcImJvb2xlYW5cIiAmJiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHQucHVzaChcIl9fVlVFX1BST0RfREVWVE9PTFNfX1wiKSwgYm8oKS5fX1ZVRV9QUk9EX0RFVlRPT0xTX18gPSAhMSksIHR5cGVvZiBfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18gIT0gXCJib29sZWFuXCIgJiYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB0LnB1c2goXCJfX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX19cIiksIGJvKCkuX19WVUVfUFJPRF9IWURSQVRJT05fTUlTTUFUQ0hfREVUQUlMU19fID0gITEpLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgdC5sZW5ndGgpIHtcbiAgICBjb25zdCBlID0gdC5sZW5ndGggPiAxO1xuICAgIGNvbnNvbGUud2FybihcbiAgICAgIGBGZWF0dXJlIGZsYWcke2UgPyBcInNcIiA6IFwiXCJ9ICR7dC5qb2luKFwiLCBcIil9ICR7ZSA/IFwiYXJlXCIgOiBcImlzXCJ9IG5vdCBleHBsaWNpdGx5IGRlZmluZWQuIFlvdSBhcmUgcnVubmluZyB0aGUgZXNtLWJ1bmRsZXIgYnVpbGQgb2YgVnVlLCB3aGljaCBleHBlY3RzIHRoZXNlIGNvbXBpbGUtdGltZSBmZWF0dXJlIGZsYWdzIHRvIGJlIGdsb2JhbGx5IGluamVjdGVkIHZpYSB0aGUgYnVuZGxlciBjb25maWcgaW4gb3JkZXIgdG8gZ2V0IGJldHRlciB0cmVlLXNoYWtpbmcgaW4gdGhlIHByb2R1Y3Rpb24gYnVuZGxlLlxuXG5Gb3IgbW9yZSBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9saW5rLnZ1ZWpzLm9yZy9mZWF0dXJlLWZsYWdzLmBcbiAgICApO1xuICB9XG59XG5jb25zdCBZdCA9IEp5O1xuZnVuY3Rpb24gXzEodCkge1xuICByZXR1cm4gRTEodCk7XG59XG5mdW5jdGlvbiBUMSh0KSB7XG4gIHJldHVybiBFMSh0LCBsJCk7XG59XG5mdW5jdGlvbiBFMSh0LCBlKSB7XG4gIGYkKCk7XG4gIGNvbnN0IG4gPSBibygpO1xuICBuLl9fVlVFX18gPSAhMCwgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pICYmIHBPKG4uX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXywgbik7XG4gIGNvbnN0IHtcbiAgICBpbnNlcnQ6IHIsXG4gICAgcmVtb3ZlOiBpLFxuICAgIHBhdGNoUHJvcDogcyxcbiAgICBjcmVhdGVFbGVtZW50OiBvLFxuICAgIGNyZWF0ZVRleHQ6IGEsXG4gICAgY3JlYXRlQ29tbWVudDogbCxcbiAgICBzZXRUZXh0OiBjLFxuICAgIHNldEVsZW1lbnRUZXh0OiB1LFxuICAgIHBhcmVudE5vZGU6IGQsXG4gICAgbmV4dFNpYmxpbmc6IGYsXG4gICAgc2V0U2NvcGVJZDogaCA9IGl0LFxuICAgIGluc2VydFN0YXRpY0NvbnRlbnQ6IHBcbiAgfSA9IHQsIE8gPSAoeCwgJCwgTiwgTSA9IG51bGwsIFggPSBudWxsLCB6ID0gbnVsbCwgZWUgPSB2b2lkIDAsIEggPSBudWxsLCBGID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIEhpID8gITEgOiAhISQuZHluYW1pY0NoaWxkcmVuKSA9PiB7XG4gICAgaWYgKHggPT09ICQpXG4gICAgICByZXR1cm47XG4gICAgeCAmJiAhbHIoeCwgJCkgJiYgKE0gPSBUbih4KSwgQmUoeCwgWCwgeiwgITApLCB4ID0gbnVsbCksICQucGF0Y2hGbGFnID09PSAtMiAmJiAoRiA9ICExLCAkLmR5bmFtaWNDaGlsZHJlbiA9IG51bGwpO1xuICAgIGNvbnN0IHsgdHlwZTogVSwgcmVmOiBzZSwgc2hhcGVGbGFnOiBtZSB9ID0gJDtcbiAgICBzd2l0Y2ggKFUpIHtcbiAgICAgIGNhc2UgbnM6XG4gICAgICAgIG0oeCwgJCwgTiwgTSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfdDpcbiAgICAgICAgeSh4LCAkLCBOLCBNKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEZpOlxuICAgICAgICB4ID09IG51bGwgPyBiKCQsIE4sIE0sIGVlKSA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBnKHgsICQsIE4sIGVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFBlOlxuICAgICAgICBXKFxuICAgICAgICAgIHgsXG4gICAgICAgICAgJCxcbiAgICAgICAgICBOLFxuICAgICAgICAgIE0sXG4gICAgICAgICAgWCxcbiAgICAgICAgICB6LFxuICAgICAgICAgIGVlLFxuICAgICAgICAgIEgsXG4gICAgICAgICAgRlxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG1lICYgMSA/IHcoXG4gICAgICAgICAgeCxcbiAgICAgICAgICAkLFxuICAgICAgICAgIE4sXG4gICAgICAgICAgTSxcbiAgICAgICAgICBYLFxuICAgICAgICAgIHosXG4gICAgICAgICAgZWUsXG4gICAgICAgICAgSCxcbiAgICAgICAgICBGXG4gICAgICAgICkgOiBtZSAmIDYgPyBMKFxuICAgICAgICAgIHgsXG4gICAgICAgICAgJCxcbiAgICAgICAgICBOLFxuICAgICAgICAgIE0sXG4gICAgICAgICAgWCxcbiAgICAgICAgICB6LFxuICAgICAgICAgIGVlLFxuICAgICAgICAgIEgsXG4gICAgICAgICAgRlxuICAgICAgICApIDogbWUgJiA2NCB8fCBtZSAmIDEyOCA/IFUucHJvY2VzcyhcbiAgICAgICAgICB4LFxuICAgICAgICAgICQsXG4gICAgICAgICAgTixcbiAgICAgICAgICBNLFxuICAgICAgICAgIFgsXG4gICAgICAgICAgeixcbiAgICAgICAgICBlZSxcbiAgICAgICAgICBILFxuICAgICAgICAgIEYsXG4gICAgICAgICAgRW5cbiAgICAgICAgKSA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBJKFwiSW52YWxpZCBWTm9kZSB0eXBlOlwiLCBVLCBgKCR7dHlwZW9mIFV9KWApO1xuICAgIH1cbiAgICBzZSAhPSBudWxsICYmIFggJiYgUHUoc2UsIHggJiYgeC5yZWYsIHosICQgfHwgeCwgISQpO1xuICB9LCBtID0gKHgsICQsIE4sIE0pID0+IHtcbiAgICBpZiAoeCA9PSBudWxsKVxuICAgICAgcihcbiAgICAgICAgJC5lbCA9IGEoJC5jaGlsZHJlbiksXG4gICAgICAgIE4sXG4gICAgICAgIE1cbiAgICAgICk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBYID0gJC5lbCA9IHguZWw7XG4gICAgICAkLmNoaWxkcmVuICE9PSB4LmNoaWxkcmVuICYmIGMoWCwgJC5jaGlsZHJlbik7XG4gICAgfVxuICB9LCB5ID0gKHgsICQsIE4sIE0pID0+IHtcbiAgICB4ID09IG51bGwgPyByKFxuICAgICAgJC5lbCA9IGwoJC5jaGlsZHJlbiB8fCBcIlwiKSxcbiAgICAgIE4sXG4gICAgICBNXG4gICAgKSA6ICQuZWwgPSB4LmVsO1xuICB9LCBiID0gKHgsICQsIE4sIE0pID0+IHtcbiAgICBbeC5lbCwgeC5hbmNob3JdID0gcChcbiAgICAgIHguY2hpbGRyZW4sXG4gICAgICAkLFxuICAgICAgTixcbiAgICAgIE0sXG4gICAgICB4LmVsLFxuICAgICAgeC5hbmNob3JcbiAgICApO1xuICB9LCBnID0gKHgsICQsIE4sIE0pID0+IHtcbiAgICBpZiAoJC5jaGlsZHJlbiAhPT0geC5jaGlsZHJlbikge1xuICAgICAgY29uc3QgWCA9IGYoeC5hbmNob3IpO1xuICAgICAgUyh4KSwgWyQuZWwsICQuYW5jaG9yXSA9IHAoXG4gICAgICAgICQuY2hpbGRyZW4sXG4gICAgICAgIE4sXG4gICAgICAgIFgsXG4gICAgICAgIE1cbiAgICAgICk7XG4gICAgfSBlbHNlXG4gICAgICAkLmVsID0geC5lbCwgJC5hbmNob3IgPSB4LmFuY2hvcjtcbiAgfSwgdiA9ICh7IGVsOiB4LCBhbmNob3I6ICQgfSwgTiwgTSkgPT4ge1xuICAgIGxldCBYO1xuICAgIGZvciAoOyB4ICYmIHggIT09ICQ7IClcbiAgICAgIFggPSBmKHgpLCByKHgsIE4sIE0pLCB4ID0gWDtcbiAgICByKCQsIE4sIE0pO1xuICB9LCBTID0gKHsgZWw6IHgsIGFuY2hvcjogJCB9KSA9PiB7XG4gICAgbGV0IE47XG4gICAgZm9yICg7IHggJiYgeCAhPT0gJDsgKVxuICAgICAgTiA9IGYoeCksIGkoeCksIHggPSBOO1xuICAgIGkoJCk7XG4gIH0sIHcgPSAoeCwgJCwgTiwgTSwgWCwgeiwgZWUsIEgsIEYpID0+IHtcbiAgICAkLnR5cGUgPT09IFwic3ZnXCIgPyBlZSA9IFwic3ZnXCIgOiAkLnR5cGUgPT09IFwibWF0aFwiICYmIChlZSA9IFwibWF0aG1sXCIpLCB4ID09IG51bGwgPyBrKFxuICAgICAgJCxcbiAgICAgIE4sXG4gICAgICBNLFxuICAgICAgWCxcbiAgICAgIHosXG4gICAgICBlZSxcbiAgICAgIEgsXG4gICAgICBGXG4gICAgKSA6IEMoXG4gICAgICB4LFxuICAgICAgJCxcbiAgICAgIFgsXG4gICAgICB6LFxuICAgICAgZWUsXG4gICAgICBILFxuICAgICAgRlxuICAgICk7XG4gIH0sIGsgPSAoeCwgJCwgTiwgTSwgWCwgeiwgZWUsIEgpID0+IHtcbiAgICBsZXQgRiwgVTtcbiAgICBjb25zdCB7IHByb3BzOiBzZSwgc2hhcGVGbGFnOiBtZSwgdHJhbnNpdGlvbjogaGUsIGRpcnM6IHllIH0gPSB4O1xuICAgIGlmIChGID0geC5lbCA9IG8oXG4gICAgICB4LnR5cGUsXG4gICAgICB6LFxuICAgICAgc2UgJiYgc2UuaXMsXG4gICAgICBzZVxuICAgICksIG1lICYgOCA/IHUoRiwgeC5jaGlsZHJlbikgOiBtZSAmIDE2ICYmIFQoXG4gICAgICB4LmNoaWxkcmVuLFxuICAgICAgRixcbiAgICAgIG51bGwsXG4gICAgICBNLFxuICAgICAgWCxcbiAgICAgIGZmKHgsIHopLFxuICAgICAgZWUsXG4gICAgICBIXG4gICAgKSwgeWUgJiYgX3IoeCwgbnVsbCwgTSwgXCJjcmVhdGVkXCIpLCBfKEYsIHgsIHguc2NvcGVJZCwgZWUsIE0pLCBzZSkge1xuICAgICAgZm9yIChjb25zdCBVZSBpbiBzZSlcbiAgICAgICAgVWUgIT09IFwidmFsdWVcIiAmJiAhVWkoVWUpICYmIHMoXG4gICAgICAgICAgRixcbiAgICAgICAgICBVZSxcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHNlW1VlXSxcbiAgICAgICAgICB6LFxuICAgICAgICAgIHguY2hpbGRyZW4sXG4gICAgICAgICAgTSxcbiAgICAgICAgICBYLFxuICAgICAgICAgIEl0XG4gICAgICAgICk7XG4gICAgICBcInZhbHVlXCIgaW4gc2UgJiYgcyhGLCBcInZhbHVlXCIsIG51bGwsIHNlLnZhbHVlLCB6KSwgKFUgPSBzZS5vblZub2RlQmVmb3JlTW91bnQpICYmIHluKFUsIE0sIHgpO1xuICAgIH1cbiAgICAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykgJiYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGLCBcIl9fdm5vZGVcIiwge1xuICAgICAgdmFsdWU6IHgsXG4gICAgICBlbnVtZXJhYmxlOiAhMVxuICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoRiwgXCJfX3Z1ZVBhcmVudENvbXBvbmVudFwiLCB7XG4gICAgICB2YWx1ZTogTSxcbiAgICAgIGVudW1lcmFibGU6ICExXG4gICAgfSkpLCB5ZSAmJiBfcih4LCBudWxsLCBNLCBcImJlZm9yZU1vdW50XCIpO1xuICAgIGNvbnN0IFFlID0gJDEoWCwgaGUpO1xuICAgIFFlICYmIGhlLmJlZm9yZUVudGVyKEYpLCByKEYsICQsIE4pLCAoKFUgPSBzZSAmJiBzZS5vblZub2RlTW91bnRlZCkgfHwgUWUgfHwgeWUpICYmIFl0KCgpID0+IHtcbiAgICAgIFUgJiYgeW4oVSwgTSwgeCksIFFlICYmIGhlLmVudGVyKEYpLCB5ZSAmJiBfcih4LCBudWxsLCBNLCBcIm1vdW50ZWRcIik7XG4gICAgfSwgWCk7XG4gIH0sIF8gPSAoeCwgJCwgTiwgTSwgWCkgPT4ge1xuICAgIGlmIChOICYmIGgoeCwgTiksIE0pXG4gICAgICBmb3IgKGxldCB6ID0gMDsgeiA8IE0ubGVuZ3RoOyB6KyspXG4gICAgICAgIGgoeCwgTVt6XSk7XG4gICAgaWYgKFgpIHtcbiAgICAgIGxldCB6ID0gWC5zdWJUcmVlO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB6LnBhdGNoRmxhZyA+IDAgJiYgei5wYXRjaEZsYWcgJiAyMDQ4ICYmICh6ID0geWQoei5jaGlsZHJlbikgfHwgeiksICQgPT09IHopIHtcbiAgICAgICAgY29uc3QgZWUgPSBYLnZub2RlO1xuICAgICAgICBfKFxuICAgICAgICAgIHgsXG4gICAgICAgICAgZWUsXG4gICAgICAgICAgZWUuc2NvcGVJZCxcbiAgICAgICAgICBlZS5zbG90U2NvcGVJZHMsXG4gICAgICAgICAgWC5wYXJlbnRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFQgPSAoeCwgJCwgTiwgTSwgWCwgeiwgZWUsIEgsIEYgPSAwKSA9PiB7XG4gICAgZm9yIChsZXQgVSA9IEY7IFUgPCB4Lmxlbmd0aDsgVSsrKSB7XG4gICAgICBjb25zdCBzZSA9IHhbVV0gPSBIID8gQWkoeFtVXSkgOiBTbih4W1VdKTtcbiAgICAgIE8oXG4gICAgICAgIG51bGwsXG4gICAgICAgIHNlLFxuICAgICAgICAkLFxuICAgICAgICBOLFxuICAgICAgICBNLFxuICAgICAgICBYLFxuICAgICAgICB6LFxuICAgICAgICBlZSxcbiAgICAgICAgSFxuICAgICAgKTtcbiAgICB9XG4gIH0sIEMgPSAoeCwgJCwgTiwgTSwgWCwgeiwgZWUpID0+IHtcbiAgICBjb25zdCBIID0gJC5lbCA9IHguZWw7XG4gICAgbGV0IHsgcGF0Y2hGbGFnOiBGLCBkeW5hbWljQ2hpbGRyZW46IFUsIGRpcnM6IHNlIH0gPSAkO1xuICAgIEYgfD0geC5wYXRjaEZsYWcgJiAxNjtcbiAgICBjb25zdCBtZSA9IHgucHJvcHMgfHwgVmUsIGhlID0gJC5wcm9wcyB8fCBWZTtcbiAgICBsZXQgeWU7XG4gICAgaWYgKE4gJiYgT3MoTiwgITEpLCAoeWUgPSBoZS5vblZub2RlQmVmb3JlVXBkYXRlKSAmJiB5bih5ZSwgTiwgJCwgeCksIHNlICYmIF9yKCQsIHgsIE4sIFwiYmVmb3JlVXBkYXRlXCIpLCBOICYmIE9zKE4sICEwKSwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIEhpICYmIChGID0gMCwgZWUgPSAhMSwgVSA9IG51bGwpLCBVID8gKEEoXG4gICAgICB4LmR5bmFtaWNDaGlsZHJlbixcbiAgICAgIFUsXG4gICAgICBILFxuICAgICAgTixcbiAgICAgIE0sXG4gICAgICBmZigkLCBYKSxcbiAgICAgIHpcbiAgICApLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgamEoeCwgJCkpIDogZWUgfHwgX2UoXG4gICAgICB4LFxuICAgICAgJCxcbiAgICAgIEgsXG4gICAgICBudWxsLFxuICAgICAgTixcbiAgICAgIE0sXG4gICAgICBmZigkLCBYKSxcbiAgICAgIHosXG4gICAgICAhMVxuICAgICksIEYgPiAwKSB7XG4gICAgICBpZiAoRiAmIDE2KVxuICAgICAgICBRKFxuICAgICAgICAgIEgsXG4gICAgICAgICAgJCxcbiAgICAgICAgICBtZSxcbiAgICAgICAgICBoZSxcbiAgICAgICAgICBOLFxuICAgICAgICAgIE0sXG4gICAgICAgICAgWFxuICAgICAgICApO1xuICAgICAgZWxzZSBpZiAoRiAmIDIgJiYgbWUuY2xhc3MgIT09IGhlLmNsYXNzICYmIHMoSCwgXCJjbGFzc1wiLCBudWxsLCBoZS5jbGFzcywgWCksIEYgJiA0ICYmIHMoSCwgXCJzdHlsZVwiLCBtZS5zdHlsZSwgaGUuc3R5bGUsIFgpLCBGICYgOCkge1xuICAgICAgICBjb25zdCBRZSA9ICQuZHluYW1pY1Byb3BzO1xuICAgICAgICBmb3IgKGxldCBVZSA9IDA7IFVlIDwgUWUubGVuZ3RoOyBVZSsrKSB7XG4gICAgICAgICAgY29uc3QgdHQgPSBRZVtVZV0sIGJ0ID0gbWVbdHRdLCAkbiA9IGhlW3R0XTtcbiAgICAgICAgICAoJG4gIT09IGJ0IHx8IHR0ID09PSBcInZhbHVlXCIpICYmIHMoXG4gICAgICAgICAgICBILFxuICAgICAgICAgICAgdHQsXG4gICAgICAgICAgICBidCxcbiAgICAgICAgICAgICRuLFxuICAgICAgICAgICAgWCxcbiAgICAgICAgICAgIHguY2hpbGRyZW4sXG4gICAgICAgICAgICBOLFxuICAgICAgICAgICAgTSxcbiAgICAgICAgICAgIEl0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgRiAmIDEgJiYgeC5jaGlsZHJlbiAhPT0gJC5jaGlsZHJlbiAmJiB1KEgsICQuY2hpbGRyZW4pO1xuICAgIH0gZWxzZVxuICAgICAgIWVlICYmIFUgPT0gbnVsbCAmJiBRKFxuICAgICAgICBILFxuICAgICAgICAkLFxuICAgICAgICBtZSxcbiAgICAgICAgaGUsXG4gICAgICAgIE4sXG4gICAgICAgIE0sXG4gICAgICAgIFhcbiAgICAgICk7XG4gICAgKCh5ZSA9IGhlLm9uVm5vZGVVcGRhdGVkKSB8fCBzZSkgJiYgWXQoKCkgPT4ge1xuICAgICAgeWUgJiYgeW4oeWUsIE4sICQsIHgpLCBzZSAmJiBfcigkLCB4LCBOLCBcInVwZGF0ZWRcIik7XG4gICAgfSwgTSk7XG4gIH0sIEEgPSAoeCwgJCwgTiwgTSwgWCwgeiwgZWUpID0+IHtcbiAgICBmb3IgKGxldCBIID0gMDsgSCA8ICQubGVuZ3RoOyBIKyspIHtcbiAgICAgIGNvbnN0IEYgPSB4W0hdLCBVID0gJFtIXSwgc2UgPSAoXG4gICAgICAgIC8vIG9sZFZOb2RlIG1heSBiZSBhbiBlcnJvcmVkIGFzeW5jIHNldHVwKCkgY29tcG9uZW50IGluc2lkZSBTdXNwZW5zZVxuICAgICAgICAvLyB3aGljaCB3aWxsIG5vdCBoYXZlIGEgbW91bnRlZCBlbGVtZW50XG4gICAgICAgIEYuZWwgJiYgLy8gLSBJbiB0aGUgY2FzZSBvZiBhIEZyYWdtZW50LCB3ZSBuZWVkIHRvIHByb3ZpZGUgdGhlIGFjdHVhbCBwYXJlbnRcbiAgICAgICAgLy8gb2YgdGhlIEZyYWdtZW50IGl0c2VsZiBzbyBpdCBjYW4gbW92ZSBpdHMgY2hpbGRyZW4uXG4gICAgICAgIChGLnR5cGUgPT09IFBlIHx8IC8vIC0gSW4gdGhlIGNhc2Ugb2YgZGlmZmVyZW50IG5vZGVzLCB0aGVyZSBpcyBnb2luZyB0byBiZSBhIHJlcGxhY2VtZW50XG4gICAgICAgIC8vIHdoaWNoIGFsc28gcmVxdWlyZXMgdGhlIGNvcnJlY3QgcGFyZW50IGNvbnRhaW5lclxuICAgICAgICAhbHIoRiwgVSkgfHwgLy8gLSBJbiB0aGUgY2FzZSBvZiBhIGNvbXBvbmVudCwgaXQgY291bGQgY29udGFpbiBhbnl0aGluZy5cbiAgICAgICAgRi5zaGFwZUZsYWcgJiA3MCkgPyBkKEYuZWwpIDogKFxuICAgICAgICAgIC8vIEluIG90aGVyIGNhc2VzLCB0aGUgcGFyZW50IGNvbnRhaW5lciBpcyBub3QgYWN0dWFsbHkgdXNlZCBzbyB3ZVxuICAgICAgICAgIC8vIGp1c3QgcGFzcyB0aGUgYmxvY2sgZWxlbWVudCBoZXJlIHRvIGF2b2lkIGEgRE9NIHBhcmVudE5vZGUgY2FsbC5cbiAgICAgICAgICBOXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBPKFxuICAgICAgICBGLFxuICAgICAgICBVLFxuICAgICAgICBzZSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgTSxcbiAgICAgICAgWCxcbiAgICAgICAgeixcbiAgICAgICAgZWUsXG4gICAgICAgICEwXG4gICAgICApO1xuICAgIH1cbiAgfSwgUSA9ICh4LCAkLCBOLCBNLCBYLCB6LCBlZSkgPT4ge1xuICAgIGlmIChOICE9PSBNKSB7XG4gICAgICBpZiAoTiAhPT0gVmUpXG4gICAgICAgIGZvciAoY29uc3QgSCBpbiBOKVxuICAgICAgICAgICFVaShIKSAmJiAhKEggaW4gTSkgJiYgcyhcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICBILFxuICAgICAgICAgICAgTltIXSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBlZSxcbiAgICAgICAgICAgICQuY2hpbGRyZW4sXG4gICAgICAgICAgICBYLFxuICAgICAgICAgICAgeixcbiAgICAgICAgICAgIEl0XG4gICAgICAgICAgKTtcbiAgICAgIGZvciAoY29uc3QgSCBpbiBNKSB7XG4gICAgICAgIGlmIChVaShIKSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgRiA9IE1bSF0sIFUgPSBOW0hdO1xuICAgICAgICBGICE9PSBVICYmIEggIT09IFwidmFsdWVcIiAmJiBzKFxuICAgICAgICAgIHgsXG4gICAgICAgICAgSCxcbiAgICAgICAgICBVLFxuICAgICAgICAgIEYsXG4gICAgICAgICAgZWUsXG4gICAgICAgICAgJC5jaGlsZHJlbixcbiAgICAgICAgICBYLFxuICAgICAgICAgIHosXG4gICAgICAgICAgSXRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIFwidmFsdWVcIiBpbiBNICYmIHMoeCwgXCJ2YWx1ZVwiLCBOLnZhbHVlLCBNLnZhbHVlLCBlZSk7XG4gICAgfVxuICB9LCBXID0gKHgsICQsIE4sIE0sIFgsIHosIGVlLCBILCBGKSA9PiB7XG4gICAgY29uc3QgVSA9ICQuZWwgPSB4ID8geC5lbCA6IGEoXCJcIiksIHNlID0gJC5hbmNob3IgPSB4ID8geC5hbmNob3IgOiBhKFwiXCIpO1xuICAgIGxldCB7IHBhdGNoRmxhZzogbWUsIGR5bmFtaWNDaGlsZHJlbjogaGUsIHNsb3RTY29wZUlkczogeWUgfSA9ICQ7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIC8vICM1NTIzIGRldiByb290IGZyYWdtZW50IG1heSBpbmhlcml0IGRpcmVjdGl2ZXNcbiAgICAoSGkgfHwgbWUgJiAyMDQ4KSAmJiAobWUgPSAwLCBGID0gITEsIGhlID0gbnVsbCksIHllICYmIChIID0gSCA/IEguY29uY2F0KHllKSA6IHllKSwgeCA9PSBudWxsID8gKHIoVSwgTiwgTSksIHIoc2UsIE4sIE0pLCBUKFxuICAgICAgLy8gIzEwMDA3XG4gICAgICAvLyBzdWNoIGZyYWdtZW50IGxpa2UgYDw+PC8+YCB3aWxsIGJlIGNvbXBpbGVkIGludG9cbiAgICAgIC8vIGEgZnJhZ21lbnQgd2hpY2ggZG9lc24ndCBoYXZlIGEgY2hpbGRyZW4uXG4gICAgICAvLyBJbiB0aGlzIGNhc2UgZmFsbGJhY2sgdG8gYW4gZW1wdHkgYXJyYXlcbiAgICAgICQuY2hpbGRyZW4gfHwgW10sXG4gICAgICBOLFxuICAgICAgc2UsXG4gICAgICBYLFxuICAgICAgeixcbiAgICAgIGVlLFxuICAgICAgSCxcbiAgICAgIEZcbiAgICApKSA6IG1lID4gMCAmJiBtZSAmIDY0ICYmIGhlICYmIC8vICMyNzE1IHRoZSBwcmV2aW91cyBmcmFnbWVudCBjb3VsZCd2ZSBiZWVuIGEgQkFJTGVkIG9uZSBhcyBhIHJlc3VsdFxuICAgIC8vIG9mIHJlbmRlclNsb3QoKSB3aXRoIG5vIHZhbGlkIGNoaWxkcmVuXG4gICAgeC5keW5hbWljQ2hpbGRyZW4gPyAoQShcbiAgICAgIHguZHluYW1pY0NoaWxkcmVuLFxuICAgICAgaGUsXG4gICAgICBOLFxuICAgICAgWCxcbiAgICAgIHosXG4gICAgICBlZSxcbiAgICAgIEhcbiAgICApLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBqYSh4LCAkKSA6IChcbiAgICAgIC8vICMyMDgwIGlmIHRoZSBzdGFibGUgZnJhZ21lbnQgaGFzIGEga2V5LCBpdCdzIGEgPHRlbXBsYXRlIHYtZm9yPiB0aGF0IG1heVxuICAgICAgLy8gIGdldCBtb3ZlZCBhcm91bmQuIE1ha2Ugc3VyZSBhbGwgcm9vdCBsZXZlbCB2bm9kZXMgaW5oZXJpdCBlbC5cbiAgICAgIC8vICMyMTM0IG9yIGlmIGl0J3MgYSBjb21wb25lbnQgcm9vdCwgaXQgbWF5IGFsc28gZ2V0IG1vdmVkIGFyb3VuZFxuICAgICAgLy8gYXMgdGhlIGNvbXBvbmVudCBpcyBiZWluZyBtb3ZlZC5cbiAgICAgICgkLmtleSAhPSBudWxsIHx8IFggJiYgJCA9PT0gWC5zdWJUcmVlKSAmJiBqYShcbiAgICAgICAgeCxcbiAgICAgICAgJCxcbiAgICAgICAgITBcbiAgICAgICAgLyogc2hhbGxvdyAqL1xuICAgICAgKVxuICAgICkpIDogX2UoXG4gICAgICB4LFxuICAgICAgJCxcbiAgICAgIE4sXG4gICAgICBzZSxcbiAgICAgIFgsXG4gICAgICB6LFxuICAgICAgZWUsXG4gICAgICBILFxuICAgICAgRlxuICAgICk7XG4gIH0sIEwgPSAoeCwgJCwgTiwgTSwgWCwgeiwgZWUsIEgsIEYpID0+IHtcbiAgICAkLnNsb3RTY29wZUlkcyA9IEgsIHggPT0gbnVsbCA/ICQuc2hhcGVGbGFnICYgNTEyID8gWC5jdHguYWN0aXZhdGUoXG4gICAgICAkLFxuICAgICAgTixcbiAgICAgIE0sXG4gICAgICBlZSxcbiAgICAgIEZcbiAgICApIDogcmUoXG4gICAgICAkLFxuICAgICAgTixcbiAgICAgIE0sXG4gICAgICBYLFxuICAgICAgeixcbiAgICAgIGVlLFxuICAgICAgRlxuICAgICkgOiBZKHgsICQsIEYpO1xuICB9LCByZSA9ICh4LCAkLCBOLCBNLCBYLCB6LCBlZSkgPT4ge1xuICAgIGNvbnN0IEggPSB4LmNvbXBvbmVudCA9IFYxKFxuICAgICAgeCxcbiAgICAgIE0sXG4gICAgICBYXG4gICAgKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIEgudHlwZS5fX2htcklkICYmIFVUKEgpLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKElhKHgpLCBGcihILCBcIm1vdW50XCIpKSwgdGEoeCkgJiYgKEguY3R4LnJlbmRlcmVyID0gRW4pLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgRnIoSCwgXCJpbml0XCIpLCBXMShIKSwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIEdyKEgsIFwiaW5pdFwiKSwgSC5hc3luY0RlcCkge1xuICAgICAgaWYgKFggJiYgWC5yZWdpc3RlckRlcChILCBLKSwgIXguZWwpIHtcbiAgICAgICAgY29uc3QgRiA9IEguc3ViVHJlZSA9IEooX3QpO1xuICAgICAgICB5KG51bGwsIEYsICQsIE4pO1xuICAgICAgfVxuICAgIH0gZWxzZVxuICAgICAgSyhcbiAgICAgICAgSCxcbiAgICAgICAgeCxcbiAgICAgICAgJCxcbiAgICAgICAgTixcbiAgICAgICAgWCxcbiAgICAgICAgeixcbiAgICAgICAgZWVcbiAgICAgICk7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChXYSgpLCBHcihILCBcIm1vdW50XCIpKTtcbiAgfSwgWSA9ICh4LCAkLCBOKSA9PiB7XG4gICAgY29uc3QgTSA9ICQuY29tcG9uZW50ID0geC5jb21wb25lbnQ7XG4gICAgaWYgKG9FKHgsICQsIE4pKVxuICAgICAgaWYgKE0uYXN5bmNEZXAgJiYgIU0uYXN5bmNSZXNvbHZlZCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgSWEoJCksIEIoTSwgJCwgTiksIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBXYSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2VcbiAgICAgICAgTS5uZXh0ID0gJCwgQlQoTS51cGRhdGUpLCBNLmVmZmVjdC5kaXJ0eSA9ICEwLCBNLnVwZGF0ZSgpO1xuICAgIGVsc2VcbiAgICAgICQuZWwgPSB4LmVsLCBNLnZub2RlID0gJDtcbiAgfSwgSyA9ICh4LCAkLCBOLCBNLCBYLCB6LCBlZSkgPT4ge1xuICAgIGNvbnN0IEggPSAoKSA9PiB7XG4gICAgICBpZiAoeC5pc01vdW50ZWQpIHtcbiAgICAgICAgbGV0IHsgbmV4dDogc2UsIGJ1OiBtZSwgdTogaGUsIHBhcmVudDogeWUsIHZub2RlOiBRZSB9ID0geDtcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IHlpID0gUTEoeCk7XG4gICAgICAgICAgaWYgKHlpKSB7XG4gICAgICAgICAgICBzZSAmJiAoc2UuZWwgPSBRZS5lbCwgQih4LCBzZSwgZWUpKSwgeWkuYXN5bmNEZXAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgIHguaXNVbm1vdW50ZWQgfHwgSCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBVZSA9IHNlLCB0dDtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIElhKHNlIHx8IHgudm5vZGUpLCBPcyh4LCAhMSksIHNlID8gKHNlLmVsID0gUWUuZWwsIEIoeCwgc2UsIGVlKSkgOiBzZSA9IFFlLCBtZSAmJiBJaShtZSksICh0dCA9IHNlLnByb3BzICYmIHNlLnByb3BzLm9uVm5vZGVCZWZvcmVVcGRhdGUpICYmIHluKHR0LCB5ZSwgc2UsIFFlKSwgT3MoeCwgITApLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgRnIoeCwgXCJyZW5kZXJcIik7XG4gICAgICAgIGNvbnN0IGJ0ID0gSGMoeCk7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBHcih4LCBcInJlbmRlclwiKTtcbiAgICAgICAgY29uc3QgJG4gPSB4LnN1YlRyZWU7XG4gICAgICAgIHguc3ViVHJlZSA9IGJ0LCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgRnIoeCwgXCJwYXRjaFwiKSwgTyhcbiAgICAgICAgICAkbixcbiAgICAgICAgICBidCxcbiAgICAgICAgICAvLyBwYXJlbnQgbWF5IGhhdmUgY2hhbmdlZCBpZiBpdCdzIGluIGEgdGVsZXBvcnRcbiAgICAgICAgICBkKCRuLmVsKSxcbiAgICAgICAgICAvLyBhbmNob3IgbWF5IGhhdmUgY2hhbmdlZCBpZiBpdCdzIGluIGEgZnJhZ21lbnRcbiAgICAgICAgICBUbigkbiksXG4gICAgICAgICAgeCxcbiAgICAgICAgICBYLFxuICAgICAgICAgIHpcbiAgICAgICAgKSwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIEdyKHgsIFwicGF0Y2hcIiksIHNlLmVsID0gYnQuZWwsIFVlID09PSBudWxsICYmIGdPKHgsIGJ0LmVsKSwgaGUgJiYgWXQoaGUsIFgpLCAodHQgPSBzZS5wcm9wcyAmJiBzZS5wcm9wcy5vblZub2RlVXBkYXRlZCkgJiYgWXQoXG4gICAgICAgICAgKCkgPT4geW4odHQsIHllLCBzZSwgUWUpLFxuICAgICAgICAgIFhcbiAgICAgICAgKSwgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiB8fCBfX1ZVRV9QUk9EX0RFVlRPT0xTX18pICYmIHp5KHgpLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgV2EoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBzZTtcbiAgICAgICAgY29uc3QgeyBlbDogbWUsIHByb3BzOiBoZSB9ID0gJCwgeyBibTogeWUsIG06IFFlLCBwYXJlbnQ6IFVlIH0gPSB4LCB0dCA9IERzKCQpO1xuICAgICAgICBpZiAoT3MoeCwgITEpLCB5ZSAmJiBJaSh5ZSksICF0dCAmJiAoc2UgPSBoZSAmJiBoZS5vblZub2RlQmVmb3JlTW91bnQpICYmIHluKHNlLCBVZSwgJCksIE9zKHgsICEwKSwgbWUgJiYgVXIpIHtcbiAgICAgICAgICBjb25zdCBidCA9ICgpID0+IHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBGcih4LCBcInJlbmRlclwiKSwgeC5zdWJUcmVlID0gSGMoeCksIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBHcih4LCBcInJlbmRlclwiKSwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIEZyKHgsIFwiaHlkcmF0ZVwiKSwgVXIoXG4gICAgICAgICAgICAgIG1lLFxuICAgICAgICAgICAgICB4LnN1YlRyZWUsXG4gICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgIFgsXG4gICAgICAgICAgICAgIG51bGxcbiAgICAgICAgICAgICksIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBHcih4LCBcImh5ZHJhdGVcIik7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0dCA/ICQudHlwZS5fX2FzeW5jTG9hZGVyKCkudGhlbihcbiAgICAgICAgICAgIC8vIG5vdGU6IHdlIGFyZSBtb3ZpbmcgdGhlIHJlbmRlciBjYWxsIGludG8gYW4gYXN5bmMgY2FsbGJhY2ssXG4gICAgICAgICAgICAvLyB3aGljaCBtZWFucyBpdCB3b24ndCB0cmFjayBkZXBlbmRlbmNpZXMgLSBidXQgaXQncyBvayBiZWNhdXNlXG4gICAgICAgICAgICAvLyBhIHNlcnZlci1yZW5kZXJlZCBhc3luYyB3cmFwcGVyIGlzIGFscmVhZHkgaW4gcmVzb2x2ZWQgc3RhdGVcbiAgICAgICAgICAgIC8vIGFuZCBpdCB3aWxsIG5ldmVyIG5lZWQgdG8gY2hhbmdlLlxuICAgICAgICAgICAgKCkgPT4gIXguaXNVbm1vdW50ZWQgJiYgYnQoKVxuICAgICAgICAgICkgOiBidCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBGcih4LCBcInJlbmRlclwiKTtcbiAgICAgICAgICBjb25zdCBidCA9IHguc3ViVHJlZSA9IEhjKHgpO1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBHcih4LCBcInJlbmRlclwiKSwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIEZyKHgsIFwicGF0Y2hcIiksIE8oXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgYnQsXG4gICAgICAgICAgICBOLFxuICAgICAgICAgICAgTSxcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICBYLFxuICAgICAgICAgICAgelxuICAgICAgICAgICksIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBHcih4LCBcInBhdGNoXCIpLCAkLmVsID0gYnQuZWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFFlICYmIFl0KFFlLCBYKSwgIXR0ICYmIChzZSA9IGhlICYmIGhlLm9uVm5vZGVNb3VudGVkKSkge1xuICAgICAgICAgIGNvbnN0IGJ0ID0gJDtcbiAgICAgICAgICBZdChcbiAgICAgICAgICAgICgpID0+IHluKHNlLCBVZSwgYnQpLFxuICAgICAgICAgICAgWFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgKCQuc2hhcGVGbGFnICYgMjU2IHx8IFVlICYmIERzKFVlLnZub2RlKSAmJiBVZS52bm9kZS5zaGFwZUZsYWcgJiAyNTYpICYmIHguYSAmJiBZdCh4LmEsIFgpLCB4LmlzTW91bnRlZCA9ICEwLCAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiIHx8IF9fVlVFX1BST0RfREVWVE9PTFNfXykgJiYgdWgoeCksICQgPSBOID0gTSA9IG51bGw7XG4gICAgICB9XG4gICAgfSwgRiA9IHguZWZmZWN0ID0gbmV3IEFvKFxuICAgICAgSCxcbiAgICAgIGl0LFxuICAgICAgKCkgPT4gTmwoVSksXG4gICAgICB4LnNjb3BlXG4gICAgICAvLyB0cmFjayBpdCBpbiBjb21wb25lbnQncyBlZmZlY3Qgc2NvcGVcbiAgICApLCBVID0geC51cGRhdGUgPSAoKSA9PiB7XG4gICAgICBGLmRpcnR5ICYmIEYucnVuKCk7XG4gICAgfTtcbiAgICBVLmlkID0geC51aWQsIE9zKHgsICEwKSwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChGLm9uVHJhY2sgPSB4LnJ0YyA/IChzZSkgPT4gSWkoeC5ydGMsIHNlKSA6IHZvaWQgMCwgRi5vblRyaWdnZXIgPSB4LnJ0ZyA/IChzZSkgPT4gSWkoeC5ydGcsIHNlKSA6IHZvaWQgMCwgVS5vd25lckluc3RhbmNlID0geCksIFUoKTtcbiAgfSwgQiA9ICh4LCAkLCBOKSA9PiB7XG4gICAgJC5jb21wb25lbnQgPSB4O1xuICAgIGNvbnN0IE0gPSB4LnZub2RlLnByb3BzO1xuICAgIHgudm5vZGUgPSAkLCB4Lm5leHQgPSBudWxsLCBHRSh4LCAkLnByb3BzLCBNLCBOKSwgcyQoeCwgJC5jaGlsZHJlbiwgTiksIGRzKCksIG1tKHgpLCBmcygpO1xuICB9LCBfZSA9ICh4LCAkLCBOLCBNLCBYLCB6LCBlZSwgSCwgRiA9ICExKSA9PiB7XG4gICAgY29uc3QgVSA9IHggJiYgeC5jaGlsZHJlbiwgc2UgPSB4ID8geC5zaGFwZUZsYWcgOiAwLCBtZSA9ICQuY2hpbGRyZW4sIHsgcGF0Y2hGbGFnOiBoZSwgc2hhcGVGbGFnOiB5ZSB9ID0gJDtcbiAgICBpZiAoaGUgPiAwKSB7XG4gICAgICBpZiAoaGUgJiAxMjgpIHtcbiAgICAgICAgdWUoXG4gICAgICAgICAgVSxcbiAgICAgICAgICBtZSxcbiAgICAgICAgICBOLFxuICAgICAgICAgIE0sXG4gICAgICAgICAgWCxcbiAgICAgICAgICB6LFxuICAgICAgICAgIGVlLFxuICAgICAgICAgIEgsXG4gICAgICAgICAgRlxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKGhlICYgMjU2KSB7XG4gICAgICAgIENlKFxuICAgICAgICAgIFUsXG4gICAgICAgICAgbWUsXG4gICAgICAgICAgTixcbiAgICAgICAgICBNLFxuICAgICAgICAgIFgsXG4gICAgICAgICAgeixcbiAgICAgICAgICBlZSxcbiAgICAgICAgICBILFxuICAgICAgICAgIEZcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB5ZSAmIDggPyAoc2UgJiAxNiAmJiBJdChVLCBYLCB6KSwgbWUgIT09IFUgJiYgdShOLCBtZSkpIDogc2UgJiAxNiA/IHllICYgMTYgPyB1ZShcbiAgICAgIFUsXG4gICAgICBtZSxcbiAgICAgIE4sXG4gICAgICBNLFxuICAgICAgWCxcbiAgICAgIHosXG4gICAgICBlZSxcbiAgICAgIEgsXG4gICAgICBGXG4gICAgKSA6IEl0KFUsIFgsIHosICEwKSA6IChzZSAmIDggJiYgdShOLCBcIlwiKSwgeWUgJiAxNiAmJiBUKFxuICAgICAgbWUsXG4gICAgICBOLFxuICAgICAgTSxcbiAgICAgIFgsXG4gICAgICB6LFxuICAgICAgZWUsXG4gICAgICBILFxuICAgICAgRlxuICAgICkpO1xuICB9LCBDZSA9ICh4LCAkLCBOLCBNLCBYLCB6LCBlZSwgSCwgRikgPT4ge1xuICAgIHggPSB4IHx8IG1vLCAkID0gJCB8fCBtbztcbiAgICBjb25zdCBVID0geC5sZW5ndGgsIHNlID0gJC5sZW5ndGgsIG1lID0gTWF0aC5taW4oVSwgc2UpO1xuICAgIGxldCBoZTtcbiAgICBmb3IgKGhlID0gMDsgaGUgPCBtZTsgaGUrKykge1xuICAgICAgY29uc3QgeWUgPSAkW2hlXSA9IEYgPyBBaSgkW2hlXSkgOiBTbigkW2hlXSk7XG4gICAgICBPKFxuICAgICAgICB4W2hlXSxcbiAgICAgICAgeWUsXG4gICAgICAgIE4sXG4gICAgICAgIG51bGwsXG4gICAgICAgIFgsXG4gICAgICAgIHosXG4gICAgICAgIGVlLFxuICAgICAgICBILFxuICAgICAgICBGXG4gICAgICApO1xuICAgIH1cbiAgICBVID4gc2UgPyBJdChcbiAgICAgIHgsXG4gICAgICBYLFxuICAgICAgeixcbiAgICAgICEwLFxuICAgICAgITEsXG4gICAgICBtZVxuICAgICkgOiBUKFxuICAgICAgJCxcbiAgICAgIE4sXG4gICAgICBNLFxuICAgICAgWCxcbiAgICAgIHosXG4gICAgICBlZSxcbiAgICAgIEgsXG4gICAgICBGLFxuICAgICAgbWVcbiAgICApO1xuICB9LCB1ZSA9ICh4LCAkLCBOLCBNLCBYLCB6LCBlZSwgSCwgRikgPT4ge1xuICAgIGxldCBVID0gMDtcbiAgICBjb25zdCBzZSA9ICQubGVuZ3RoO1xuICAgIGxldCBtZSA9IHgubGVuZ3RoIC0gMSwgaGUgPSBzZSAtIDE7XG4gICAgZm9yICg7IFUgPD0gbWUgJiYgVSA8PSBoZTsgKSB7XG4gICAgICBjb25zdCB5ZSA9IHhbVV0sIFFlID0gJFtVXSA9IEYgPyBBaSgkW1VdKSA6IFNuKCRbVV0pO1xuICAgICAgaWYgKGxyKHllLCBRZSkpXG4gICAgICAgIE8oXG4gICAgICAgICAgeWUsXG4gICAgICAgICAgUWUsXG4gICAgICAgICAgTixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIFgsXG4gICAgICAgICAgeixcbiAgICAgICAgICBlZSxcbiAgICAgICAgICBILFxuICAgICAgICAgIEZcbiAgICAgICAgKTtcbiAgICAgIGVsc2VcbiAgICAgICAgYnJlYWs7XG4gICAgICBVKys7XG4gICAgfVxuICAgIGZvciAoOyBVIDw9IG1lICYmIFUgPD0gaGU7ICkge1xuICAgICAgY29uc3QgeWUgPSB4W21lXSwgUWUgPSAkW2hlXSA9IEYgPyBBaSgkW2hlXSkgOiBTbigkW2hlXSk7XG4gICAgICBpZiAobHIoeWUsIFFlKSlcbiAgICAgICAgTyhcbiAgICAgICAgICB5ZSxcbiAgICAgICAgICBRZSxcbiAgICAgICAgICBOLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgWCxcbiAgICAgICAgICB6LFxuICAgICAgICAgIGVlLFxuICAgICAgICAgIEgsXG4gICAgICAgICAgRlxuICAgICAgICApO1xuICAgICAgZWxzZVxuICAgICAgICBicmVhaztcbiAgICAgIG1lLS0sIGhlLS07XG4gICAgfVxuICAgIGlmIChVID4gbWUpIHtcbiAgICAgIGlmIChVIDw9IGhlKSB7XG4gICAgICAgIGNvbnN0IHllID0gaGUgKyAxLCBRZSA9IHllIDwgc2UgPyAkW3llXS5lbCA6IE07XG4gICAgICAgIGZvciAoOyBVIDw9IGhlOyApXG4gICAgICAgICAgTyhcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAkW1VdID0gRiA/IEFpKCRbVV0pIDogU24oJFtVXSksXG4gICAgICAgICAgICBOLFxuICAgICAgICAgICAgUWUsXG4gICAgICAgICAgICBYLFxuICAgICAgICAgICAgeixcbiAgICAgICAgICAgIGVlLFxuICAgICAgICAgICAgSCxcbiAgICAgICAgICAgIEZcbiAgICAgICAgICApLCBVKys7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChVID4gaGUpXG4gICAgICBmb3IgKDsgVSA8PSBtZTsgKVxuICAgICAgICBCZSh4W1VdLCBYLCB6LCAhMCksIFUrKztcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IHllID0gVSwgUWUgPSBVLCBVZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICBmb3IgKFUgPSBRZTsgVSA8PSBoZTsgVSsrKSB7XG4gICAgICAgIGNvbnN0IEx0ID0gJFtVXSA9IEYgPyBBaSgkW1VdKSA6IFNuKCRbVV0pO1xuICAgICAgICBMdC5rZXkgIT0gbnVsbCAmJiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIFVlLmhhcyhMdC5rZXkpICYmIEkoXG4gICAgICAgICAgXCJEdXBsaWNhdGUga2V5cyBmb3VuZCBkdXJpbmcgdXBkYXRlOlwiLFxuICAgICAgICAgIEpTT04uc3RyaW5naWZ5KEx0LmtleSksXG4gICAgICAgICAgXCJNYWtlIHN1cmUga2V5cyBhcmUgdW5pcXVlLlwiXG4gICAgICAgICksIFVlLnNldChMdC5rZXksIFUpKTtcbiAgICAgIH1cbiAgICAgIGxldCB0dCwgYnQgPSAwO1xuICAgICAgY29uc3QgJG4gPSBoZSAtIFFlICsgMTtcbiAgICAgIGxldCB5aSA9ICExLCBhYyA9IDA7XG4gICAgICBjb25zdCBwcyA9IG5ldyBBcnJheSgkbik7XG4gICAgICBmb3IgKFUgPSAwOyBVIDwgJG47IFUrKylcbiAgICAgICAgcHNbVV0gPSAwO1xuICAgICAgZm9yIChVID0geWU7IFUgPD0gbWU7IFUrKykge1xuICAgICAgICBjb25zdCBMdCA9IHhbVV07XG4gICAgICAgIGlmIChidCA+PSAkbikge1xuICAgICAgICAgIEJlKEx0LCBYLCB6LCAhMCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IFVuO1xuICAgICAgICBpZiAoTHQua2V5ICE9IG51bGwpXG4gICAgICAgICAgVW4gPSBVZS5nZXQoTHQua2V5KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGZvciAodHQgPSBRZTsgdHQgPD0gaGU7IHR0KyspXG4gICAgICAgICAgICBpZiAocHNbdHQgLSBRZV0gPT09IDAgJiYgbHIoTHQsICRbdHRdKSkge1xuICAgICAgICAgICAgICBVbiA9IHR0O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgVW4gPT09IHZvaWQgMCA/IEJlKEx0LCBYLCB6LCAhMCkgOiAocHNbVW4gLSBRZV0gPSBVICsgMSwgVW4gPj0gYWMgPyBhYyA9IFVuIDogeWkgPSAhMCwgTyhcbiAgICAgICAgICBMdCxcbiAgICAgICAgICAkW1VuXSxcbiAgICAgICAgICBOLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgWCxcbiAgICAgICAgICB6LFxuICAgICAgICAgIGVlLFxuICAgICAgICAgIEgsXG4gICAgICAgICAgRlxuICAgICAgICApLCBidCsrKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxjID0geWkgPyBoJChwcykgOiBtbztcbiAgICAgIGZvciAodHQgPSBsYy5sZW5ndGggLSAxLCBVID0gJG4gLSAxOyBVID49IDA7IFUtLSkge1xuICAgICAgICBjb25zdCBMdCA9IFFlICsgVSwgVW4gPSAkW0x0XSwgcm8gPSBMdCArIDEgPCBzZSA/ICRbTHQgKyAxXS5lbCA6IE07XG4gICAgICAgIHBzW1VdID09PSAwID8gTyhcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIFVuLFxuICAgICAgICAgIE4sXG4gICAgICAgICAgcm8sXG4gICAgICAgICAgWCxcbiAgICAgICAgICB6LFxuICAgICAgICAgIGVlLFxuICAgICAgICAgIEgsXG4gICAgICAgICAgRlxuICAgICAgICApIDogeWkgJiYgKHR0IDwgMCB8fCBVICE9PSBsY1t0dF0gPyBnZShVbiwgTiwgcm8sIDIpIDogdHQtLSk7XG4gICAgICB9XG4gICAgfVxuICB9LCBnZSA9ICh4LCAkLCBOLCBNLCBYID0gbnVsbCkgPT4ge1xuICAgIGNvbnN0IHsgZWw6IHosIHR5cGU6IGVlLCB0cmFuc2l0aW9uOiBILCBjaGlsZHJlbjogRiwgc2hhcGVGbGFnOiBVIH0gPSB4O1xuICAgIGlmIChVICYgNikge1xuICAgICAgZ2UoeC5jb21wb25lbnQuc3ViVHJlZSwgJCwgTiwgTSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChVICYgMTI4KSB7XG4gICAgICB4LnN1c3BlbnNlLm1vdmUoJCwgTiwgTSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChVICYgNjQpIHtcbiAgICAgIGVlLm1vdmUoeCwgJCwgTiwgRW4pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZWUgPT09IFBlKSB7XG4gICAgICByKHosICQsIE4pO1xuICAgICAgZm9yIChsZXQgbWUgPSAwOyBtZSA8IEYubGVuZ3RoOyBtZSsrKVxuICAgICAgICBnZShGW21lXSwgJCwgTiwgTSk7XG4gICAgICByKHguYW5jaG9yLCAkLCBOKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGVlID09PSBGaSkge1xuICAgICAgdih4LCAkLCBOKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKE0gIT09IDIgJiYgVSAmIDEgJiYgSClcbiAgICAgIGlmIChNID09PSAwKVxuICAgICAgICBILmJlZm9yZUVudGVyKHopLCByKHosICQsIE4pLCBZdCgoKSA9PiBILmVudGVyKHopLCBYKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB7IGxlYXZlOiBtZSwgZGVsYXlMZWF2ZTogaGUsIGFmdGVyTGVhdmU6IHllIH0gPSBILCBRZSA9ICgpID0+IHIoeiwgJCwgTiksIFVlID0gKCkgPT4ge1xuICAgICAgICAgIG1lKHosICgpID0+IHtcbiAgICAgICAgICAgIFFlKCksIHllICYmIHllKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGhlID8gaGUoeiwgUWUsIFVlKSA6IFVlKCk7XG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgcih6LCAkLCBOKTtcbiAgfSwgQmUgPSAoeCwgJCwgTiwgTSA9ICExLCBYID0gITEpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlOiB6LFxuICAgICAgcHJvcHM6IGVlLFxuICAgICAgcmVmOiBILFxuICAgICAgY2hpbGRyZW46IEYsXG4gICAgICBkeW5hbWljQ2hpbGRyZW46IFUsXG4gICAgICBzaGFwZUZsYWc6IHNlLFxuICAgICAgcGF0Y2hGbGFnOiBtZSxcbiAgICAgIGRpcnM6IGhlXG4gICAgfSA9IHg7XG4gICAgaWYgKEggIT0gbnVsbCAmJiBQdShILCBudWxsLCBOLCB4LCAhMCksIHNlICYgMjU2KSB7XG4gICAgICAkLmN0eC5kZWFjdGl2YXRlKHgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB5ZSA9IHNlICYgMSAmJiBoZSwgUWUgPSAhRHMoeCk7XG4gICAgbGV0IFVlO1xuICAgIGlmIChRZSAmJiAoVWUgPSBlZSAmJiBlZS5vblZub2RlQmVmb3JlVW5tb3VudCkgJiYgeW4oVWUsICQsIHgpLCBzZSAmIDYpXG4gICAgICBWdCh4LmNvbXBvbmVudCwgTiwgTSk7XG4gICAgZWxzZSB7XG4gICAgICBpZiAoc2UgJiAxMjgpIHtcbiAgICAgICAgeC5zdXNwZW5zZS51bm1vdW50KE4sIE0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB5ZSAmJiBfcih4LCBudWxsLCAkLCBcImJlZm9yZVVubW91bnRcIiksIHNlICYgNjQgPyB4LnR5cGUucmVtb3ZlKFxuICAgICAgICB4LFxuICAgICAgICAkLFxuICAgICAgICBOLFxuICAgICAgICBYLFxuICAgICAgICBFbixcbiAgICAgICAgTVxuICAgICAgKSA6IFUgJiYgLy8gIzExNTM6IGZhc3QgcGF0aCBzaG91bGQgbm90IGJlIHRha2VuIGZvciBub24tc3RhYmxlICh2LWZvcikgZnJhZ21lbnRzXG4gICAgICAoeiAhPT0gUGUgfHwgbWUgPiAwICYmIG1lICYgNjQpID8gSXQoXG4gICAgICAgIFUsXG4gICAgICAgICQsXG4gICAgICAgIE4sXG4gICAgICAgICExLFxuICAgICAgICAhMFxuICAgICAgKSA6ICh6ID09PSBQZSAmJiBtZSAmIDM4NCB8fCAhWCAmJiBzZSAmIDE2KSAmJiBJdChGLCAkLCBOKSwgTSAmJiBMZSh4KTtcbiAgICB9XG4gICAgKFFlICYmIChVZSA9IGVlICYmIGVlLm9uVm5vZGVVbm1vdW50ZWQpIHx8IHllKSAmJiBZdCgoKSA9PiB7XG4gICAgICBVZSAmJiB5bihVZSwgJCwgeCksIHllICYmIF9yKHgsIG51bGwsICQsIFwidW5tb3VudGVkXCIpO1xuICAgIH0sIE4pO1xuICB9LCBMZSA9ICh4KSA9PiB7XG4gICAgY29uc3QgeyB0eXBlOiAkLCBlbDogTiwgYW5jaG9yOiBNLCB0cmFuc2l0aW9uOiBYIH0gPSB4O1xuICAgIGlmICgkID09PSBQZSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHgucGF0Y2hGbGFnID4gMCAmJiB4LnBhdGNoRmxhZyAmIDIwNDggJiYgWCAmJiAhWC5wZXJzaXN0ZWQgPyB4LmNoaWxkcmVuLmZvckVhY2goKGVlKSA9PiB7XG4gICAgICAgIGVlLnR5cGUgPT09IF90ID8gaShlZS5lbCkgOiBMZShlZSk7XG4gICAgICB9KSA6IFp0KE4sIE0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoJCA9PT0gRmkpIHtcbiAgICAgIFMoeCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHogPSAoKSA9PiB7XG4gICAgICBpKE4pLCBYICYmICFYLnBlcnNpc3RlZCAmJiBYLmFmdGVyTGVhdmUgJiYgWC5hZnRlckxlYXZlKCk7XG4gICAgfTtcbiAgICBpZiAoeC5zaGFwZUZsYWcgJiAxICYmIFggJiYgIVgucGVyc2lzdGVkKSB7XG4gICAgICBjb25zdCB7IGxlYXZlOiBlZSwgZGVsYXlMZWF2ZTogSCB9ID0gWCwgRiA9ICgpID0+IGVlKE4sIHopO1xuICAgICAgSCA/IEgoeC5lbCwgeiwgRikgOiBGKCk7XG4gICAgfSBlbHNlXG4gICAgICB6KCk7XG4gIH0sIFp0ID0gKHgsICQpID0+IHtcbiAgICBsZXQgTjtcbiAgICBmb3IgKDsgeCAhPT0gJDsgKVxuICAgICAgTiA9IGYoeCksIGkoeCksIHggPSBOO1xuICAgIGkoJCk7XG4gIH0sIFZ0ID0gKHgsICQsIE4pID0+IHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgeC50eXBlLl9faG1ySWQgJiYgcVQoeCk7XG4gICAgY29uc3QgeyBidW06IE0sIHNjb3BlOiBYLCB1cGRhdGU6IHosIHN1YlRyZWU6IGVlLCB1bTogSCB9ID0geDtcbiAgICBNICYmIElpKE0pLCBYLnN0b3AoKSwgeiAmJiAoei5hY3RpdmUgPSAhMSwgQmUoZWUsIHgsICQsIE4pKSwgSCAmJiBZdChILCAkKSwgWXQoKCkgPT4ge1xuICAgICAgeC5pc1VubW91bnRlZCA9ICEwO1xuICAgIH0sICQpLCAkICYmICQucGVuZGluZ0JyYW5jaCAmJiAhJC5pc1VubW91bnRlZCAmJiB4LmFzeW5jRGVwICYmICF4LmFzeW5jUmVzb2x2ZWQgJiYgeC5zdXNwZW5zZUlkID09PSAkLnBlbmRpbmdJZCAmJiAoJC5kZXBzLS0sICQuZGVwcyA9PT0gMCAmJiAkLnJlc29sdmUoKSksIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSAmJiBLVCh4KTtcbiAgfSwgSXQgPSAoeCwgJCwgTiwgTSA9ICExLCBYID0gITEsIHogPSAwKSA9PiB7XG4gICAgZm9yIChsZXQgZWUgPSB6OyBlZSA8IHgubGVuZ3RoOyBlZSsrKVxuICAgICAgQmUoeFtlZV0sICQsIE4sIE0sIFgpO1xuICB9LCBUbiA9ICh4KSA9PiB4LnNoYXBlRmxhZyAmIDYgPyBUbih4LmNvbXBvbmVudC5zdWJUcmVlKSA6IHguc2hhcGVGbGFnICYgMTI4ID8geC5zdXNwZW5zZS5uZXh0KCkgOiBmKHguYW5jaG9yIHx8IHguZWwpO1xuICBsZXQgU3IgPSAhMTtcbiAgY29uc3Qgb3IgPSAoeCwgJCwgTikgPT4ge1xuICAgIHggPT0gbnVsbCA/ICQuX3Zub2RlICYmIEJlKCQuX3Zub2RlLCBudWxsLCBudWxsLCAhMCkgOiBPKFxuICAgICAgJC5fdm5vZGUgfHwgbnVsbCxcbiAgICAgIHgsXG4gICAgICAkLFxuICAgICAgbnVsbCxcbiAgICAgIG51bGwsXG4gICAgICBudWxsLFxuICAgICAgTlxuICAgICksIFNyIHx8IChTciA9ICEwLCBtbSgpLCBTdSgpLCBTciA9ICExKSwgJC5fdm5vZGUgPSB4O1xuICB9LCBFbiA9IHtcbiAgICBwOiBPLFxuICAgIHVtOiBCZSxcbiAgICBtOiBnZSxcbiAgICByOiBMZSxcbiAgICBtdDogcmUsXG4gICAgbWM6IFQsXG4gICAgcGM6IF9lLFxuICAgIHBiYzogQSxcbiAgICBuOiBUbixcbiAgICBvOiB0XG4gIH07XG4gIGxldCB2aSwgVXI7XG4gIHJldHVybiBlICYmIChbdmksIFVyXSA9IGUoXG4gICAgRW5cbiAgKSksIHtcbiAgICByZW5kZXI6IG9yLFxuICAgIGh5ZHJhdGU6IHZpLFxuICAgIGNyZWF0ZUFwcDogWUUob3IsIHZpKVxuICB9O1xufVxuZnVuY3Rpb24gZmYoeyB0eXBlOiB0LCBwcm9wczogZSB9LCBuKSB7XG4gIHJldHVybiBuID09PSBcInN2Z1wiICYmIHQgPT09IFwiZm9yZWlnbk9iamVjdFwiIHx8IG4gPT09IFwibWF0aG1sXCIgJiYgdCA9PT0gXCJhbm5vdGF0aW9uLXhtbFwiICYmIGUgJiYgZS5lbmNvZGluZyAmJiBlLmVuY29kaW5nLmluY2x1ZGVzKFwiaHRtbFwiKSA/IHZvaWQgMCA6IG47XG59XG5mdW5jdGlvbiBPcyh7IGVmZmVjdDogdCwgdXBkYXRlOiBlIH0sIG4pIHtcbiAgdC5hbGxvd1JlY3Vyc2UgPSBlLmFsbG93UmVjdXJzZSA9IG47XG59XG5mdW5jdGlvbiAkMSh0LCBlKSB7XG4gIHJldHVybiAoIXQgfHwgdCAmJiAhdC5wZW5kaW5nQnJhbmNoKSAmJiBlICYmICFlLnBlcnNpc3RlZDtcbn1cbmZ1bmN0aW9uIGphKHQsIGUsIG4gPSAhMSkge1xuICBjb25zdCByID0gdC5jaGlsZHJlbiwgaSA9IGUuY2hpbGRyZW47XG4gIGlmIChpZShyKSAmJiBpZShpKSlcbiAgICBmb3IgKGxldCBzID0gMDsgcyA8IHIubGVuZ3RoOyBzKyspIHtcbiAgICAgIGNvbnN0IG8gPSByW3NdO1xuICAgICAgbGV0IGEgPSBpW3NdO1xuICAgICAgYS5zaGFwZUZsYWcgJiAxICYmICFhLmR5bmFtaWNDaGlsZHJlbiAmJiAoKGEucGF0Y2hGbGFnIDw9IDAgfHwgYS5wYXRjaEZsYWcgPT09IDMyKSAmJiAoYSA9IGlbc10gPSBBaShpW3NdKSwgYS5lbCA9IG8uZWwpLCBuIHx8IGphKG8sIGEpKSwgYS50eXBlID09PSBucyAmJiAoYS5lbCA9IG8uZWwpLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgYS50eXBlID09PSBfdCAmJiAhYS5lbCAmJiAoYS5lbCA9IG8uZWwpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGgkKHQpIHtcbiAgY29uc3QgZSA9IHQuc2xpY2UoKSwgbiA9IFswXTtcbiAgbGV0IHIsIGksIHMsIG8sIGE7XG4gIGNvbnN0IGwgPSB0Lmxlbmd0aDtcbiAgZm9yIChyID0gMDsgciA8IGw7IHIrKykge1xuICAgIGNvbnN0IGMgPSB0W3JdO1xuICAgIGlmIChjICE9PSAwKSB7XG4gICAgICBpZiAoaSA9IG5bbi5sZW5ndGggLSAxXSwgdFtpXSA8IGMpIHtcbiAgICAgICAgZVtyXSA9IGksIG4ucHVzaChyKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmb3IgKHMgPSAwLCBvID0gbi5sZW5ndGggLSAxOyBzIDwgbzsgKVxuICAgICAgICBhID0gcyArIG8gPj4gMSwgdFtuW2FdXSA8IGMgPyBzID0gYSArIDEgOiBvID0gYTtcbiAgICAgIGMgPCB0W25bc11dICYmIChzID4gMCAmJiAoZVtyXSA9IG5bcyAtIDFdKSwgbltzXSA9IHIpO1xuICAgIH1cbiAgfVxuICBmb3IgKHMgPSBuLmxlbmd0aCwgbyA9IG5bcyAtIDFdOyBzLS0gPiAwOyApXG4gICAgbltzXSA9IG8sIG8gPSBlW29dO1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIFExKHQpIHtcbiAgY29uc3QgZSA9IHQuc3ViVHJlZS5jb21wb25lbnQ7XG4gIGlmIChlKVxuICAgIHJldHVybiBlLmFzeW5jRGVwICYmICFlLmFzeW5jUmVzb2x2ZWQgPyBlIDogUTEoZSk7XG59XG5jb25zdCBwJCA9ICh0KSA9PiB0Ll9faXNUZWxlcG9ydCwga28gPSAodCkgPT4gdCAmJiAodC5kaXNhYmxlZCB8fCB0LmRpc2FibGVkID09PSBcIlwiKSwgRG0gPSAodCkgPT4gdHlwZW9mIFNWR0VsZW1lbnQgPCBcInVcIiAmJiB0IGluc3RhbmNlb2YgU1ZHRWxlbWVudCwgWm0gPSAodCkgPT4gdHlwZW9mIE1hdGhNTEVsZW1lbnQgPT0gXCJmdW5jdGlvblwiICYmIHQgaW5zdGFuY2VvZiBNYXRoTUxFbGVtZW50LCBiaCA9ICh0LCBlKSA9PiB7XG4gIGNvbnN0IG4gPSB0ICYmIHQudG87XG4gIGlmICh3ZShuKSlcbiAgICBpZiAoZSkge1xuICAgICAgY29uc3QgciA9IGUobik7XG4gICAgICByZXR1cm4gciB8fCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgSShcbiAgICAgICAgYEZhaWxlZCB0byBsb2NhdGUgVGVsZXBvcnQgdGFyZ2V0IHdpdGggc2VsZWN0b3IgXCIke259XCIuIE5vdGUgdGhlIHRhcmdldCBlbGVtZW50IG11c3QgZXhpc3QgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZCAtIGkuZS4gdGhlIHRhcmdldCBjYW5ub3QgYmUgcmVuZGVyZWQgYnkgdGhlIGNvbXBvbmVudCBpdHNlbGYsIGFuZCBpZGVhbGx5IHNob3VsZCBiZSBvdXRzaWRlIG9mIHRoZSBlbnRpcmUgVnVlIGNvbXBvbmVudCB0cmVlLmBcbiAgICAgICksIHI7XG4gICAgfSBlbHNlXG4gICAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIEkoXG4gICAgICAgIFwiQ3VycmVudCByZW5kZXJlciBkb2VzIG5vdCBzdXBwb3J0IHN0cmluZyB0YXJnZXQgZm9yIFRlbGVwb3J0cy4gKG1pc3NpbmcgcXVlcnlTZWxlY3RvciByZW5kZXJlciBvcHRpb24pXCJcbiAgICAgICksIG51bGw7XG4gIGVsc2VcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFuICYmICFrbyh0KSAmJiBJKGBJbnZhbGlkIFRlbGVwb3J0IHRhcmdldDogJHtufWApLCBuO1xufSwgTyQgPSB7XG4gIG5hbWU6IFwiVGVsZXBvcnRcIixcbiAgX19pc1RlbGVwb3J0OiAhMCxcbiAgcHJvY2Vzcyh0LCBlLCBuLCByLCBpLCBzLCBvLCBhLCBsLCBjKSB7XG4gICAgY29uc3Qge1xuICAgICAgbWM6IHUsXG4gICAgICBwYzogZCxcbiAgICAgIHBiYzogZixcbiAgICAgIG86IHsgaW5zZXJ0OiBoLCBxdWVyeVNlbGVjdG9yOiBwLCBjcmVhdGVUZXh0OiBPLCBjcmVhdGVDb21tZW50OiBtIH1cbiAgICB9ID0gYywgeSA9IGtvKGUucHJvcHMpO1xuICAgIGxldCB7IHNoYXBlRmxhZzogYiwgY2hpbGRyZW46IGcsIGR5bmFtaWNDaGlsZHJlbjogdiB9ID0gZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIEhpICYmIChsID0gITEsIHYgPSBudWxsKSwgdCA9PSBudWxsKSB7XG4gICAgICBjb25zdCBTID0gZS5lbCA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IG0oXCJ0ZWxlcG9ydCBzdGFydFwiKSA6IE8oXCJcIiksIHcgPSBlLmFuY2hvciA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IG0oXCJ0ZWxlcG9ydCBlbmRcIikgOiBPKFwiXCIpO1xuICAgICAgaChTLCBuLCByKSwgaCh3LCBuLCByKTtcbiAgICAgIGNvbnN0IGsgPSBlLnRhcmdldCA9IGJoKGUucHJvcHMsIHApLCBfID0gZS50YXJnZXRBbmNob3IgPSBPKFwiXCIpO1xuICAgICAgayA/IChoKF8sIGspLCBvID09PSBcInN2Z1wiIHx8IERtKGspID8gbyA9IFwic3ZnXCIgOiAobyA9PT0gXCJtYXRobWxcIiB8fCBabShrKSkgJiYgKG8gPSBcIm1hdGhtbFwiKSkgOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIXkgJiYgSShcIkludmFsaWQgVGVsZXBvcnQgdGFyZ2V0IG9uIG1vdW50OlwiLCBrLCBgKCR7dHlwZW9mIGt9KWApO1xuICAgICAgY29uc3QgVCA9IChDLCBBKSA9PiB7XG4gICAgICAgIGIgJiAxNiAmJiB1KFxuICAgICAgICAgIGcsXG4gICAgICAgICAgQyxcbiAgICAgICAgICBBLFxuICAgICAgICAgIGksXG4gICAgICAgICAgcyxcbiAgICAgICAgICBvLFxuICAgICAgICAgIGEsXG4gICAgICAgICAgbFxuICAgICAgICApO1xuICAgICAgfTtcbiAgICAgIHkgPyBUKG4sIHcpIDogayAmJiBUKGssIF8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlLmVsID0gdC5lbDtcbiAgICAgIGNvbnN0IFMgPSBlLmFuY2hvciA9IHQuYW5jaG9yLCB3ID0gZS50YXJnZXQgPSB0LnRhcmdldCwgayA9IGUudGFyZ2V0QW5jaG9yID0gdC50YXJnZXRBbmNob3IsIF8gPSBrbyh0LnByb3BzKSwgVCA9IF8gPyBuIDogdywgQyA9IF8gPyBTIDogaztcbiAgICAgIGlmIChvID09PSBcInN2Z1wiIHx8IERtKHcpID8gbyA9IFwic3ZnXCIgOiAobyA9PT0gXCJtYXRobWxcIiB8fCBabSh3KSkgJiYgKG8gPSBcIm1hdGhtbFwiKSwgdiA/IChmKFxuICAgICAgICB0LmR5bmFtaWNDaGlsZHJlbixcbiAgICAgICAgdixcbiAgICAgICAgVCxcbiAgICAgICAgaSxcbiAgICAgICAgcyxcbiAgICAgICAgbyxcbiAgICAgICAgYVxuICAgICAgKSwgamEodCwgZSwgITApKSA6IGwgfHwgZChcbiAgICAgICAgdCxcbiAgICAgICAgZSxcbiAgICAgICAgVCxcbiAgICAgICAgQyxcbiAgICAgICAgaSxcbiAgICAgICAgcyxcbiAgICAgICAgbyxcbiAgICAgICAgYSxcbiAgICAgICAgITFcbiAgICAgICksIHkpXG4gICAgICAgIF8gPyBlLnByb3BzICYmIHQucHJvcHMgJiYgZS5wcm9wcy50byAhPT0gdC5wcm9wcy50byAmJiAoZS5wcm9wcy50byA9IHQucHJvcHMudG8pIDogbWMoXG4gICAgICAgICAgZSxcbiAgICAgICAgICBuLFxuICAgICAgICAgIFMsXG4gICAgICAgICAgYyxcbiAgICAgICAgICAxXG4gICAgICAgICk7XG4gICAgICBlbHNlIGlmICgoZS5wcm9wcyAmJiBlLnByb3BzLnRvKSAhPT0gKHQucHJvcHMgJiYgdC5wcm9wcy50bykpIHtcbiAgICAgICAgY29uc3QgQSA9IGUudGFyZ2V0ID0gYmgoXG4gICAgICAgICAgZS5wcm9wcyxcbiAgICAgICAgICBwXG4gICAgICAgICk7XG4gICAgICAgIEEgPyBtYyhcbiAgICAgICAgICBlLFxuICAgICAgICAgIEEsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICBjLFxuICAgICAgICAgIDBcbiAgICAgICAgKSA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBJKFxuICAgICAgICAgIFwiSW52YWxpZCBUZWxlcG9ydCB0YXJnZXQgb24gdXBkYXRlOlwiLFxuICAgICAgICAgIHcsXG4gICAgICAgICAgYCgke3R5cGVvZiB3fSlgXG4gICAgICAgICk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgXyAmJiBtYyhcbiAgICAgICAgICBlLFxuICAgICAgICAgIHcsXG4gICAgICAgICAgayxcbiAgICAgICAgICBjLFxuICAgICAgICAgIDFcbiAgICAgICAgKTtcbiAgICB9XG4gICAgQzEoZSk7XG4gIH0sXG4gIHJlbW92ZSh0LCBlLCBuLCByLCB7IHVtOiBpLCBvOiB7IHJlbW92ZTogcyB9IH0sIG8pIHtcbiAgICBjb25zdCB7IHNoYXBlRmxhZzogYSwgY2hpbGRyZW46IGwsIGFuY2hvcjogYywgdGFyZ2V0QW5jaG9yOiB1LCB0YXJnZXQ6IGQsIHByb3BzOiBmIH0gPSB0O1xuICAgIGlmIChkICYmIHModSksIG8gJiYgcyhjKSwgYSAmIDE2KSB7XG4gICAgICBjb25zdCBoID0gbyB8fCAha28oZik7XG4gICAgICBmb3IgKGxldCBwID0gMDsgcCA8IGwubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgY29uc3QgTyA9IGxbcF07XG4gICAgICAgIGkoXG4gICAgICAgICAgTyxcbiAgICAgICAgICBlLFxuICAgICAgICAgIG4sXG4gICAgICAgICAgaCxcbiAgICAgICAgICAhIU8uZHluYW1pY0NoaWxkcmVuXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtb3ZlOiBtYyxcbiAgaHlkcmF0ZTogZyRcbn07XG5mdW5jdGlvbiBtYyh0LCBlLCBuLCB7IG86IHsgaW5zZXJ0OiByIH0sIG06IGkgfSwgcyA9IDIpIHtcbiAgcyA9PT0gMCAmJiByKHQudGFyZ2V0QW5jaG9yLCBlLCBuKTtcbiAgY29uc3QgeyBlbDogbywgYW5jaG9yOiBhLCBzaGFwZUZsYWc6IGwsIGNoaWxkcmVuOiBjLCBwcm9wczogdSB9ID0gdCwgZCA9IHMgPT09IDI7XG4gIGlmIChkICYmIHIobywgZSwgbiksICghZCB8fCBrbyh1KSkgJiYgbCAmIDE2KVxuICAgIGZvciAobGV0IGYgPSAwOyBmIDwgYy5sZW5ndGg7IGYrKylcbiAgICAgIGkoXG4gICAgICAgIGNbZl0sXG4gICAgICAgIGUsXG4gICAgICAgIG4sXG4gICAgICAgIDJcbiAgICAgICk7XG4gIGQgJiYgcihhLCBlLCBuKTtcbn1cbmZ1bmN0aW9uIGckKHQsIGUsIG4sIHIsIGksIHMsIHtcbiAgbzogeyBuZXh0U2libGluZzogbywgcGFyZW50Tm9kZTogYSwgcXVlcnlTZWxlY3RvcjogbCB9XG59LCBjKSB7XG4gIGNvbnN0IHUgPSBlLnRhcmdldCA9IGJoKFxuICAgIGUucHJvcHMsXG4gICAgbFxuICApO1xuICBpZiAodSkge1xuICAgIGNvbnN0IGQgPSB1Ll9scGEgfHwgdS5maXJzdENoaWxkO1xuICAgIGlmIChlLnNoYXBlRmxhZyAmIDE2KVxuICAgICAgaWYgKGtvKGUucHJvcHMpKVxuICAgICAgICBlLmFuY2hvciA9IGMoXG4gICAgICAgICAgbyh0KSxcbiAgICAgICAgICBlLFxuICAgICAgICAgIGEodCksXG4gICAgICAgICAgbixcbiAgICAgICAgICByLFxuICAgICAgICAgIGksXG4gICAgICAgICAgc1xuICAgICAgICApLCBlLnRhcmdldEFuY2hvciA9IGQ7XG4gICAgICBlbHNlIHtcbiAgICAgICAgZS5hbmNob3IgPSBvKHQpO1xuICAgICAgICBsZXQgZiA9IGQ7XG4gICAgICAgIGZvciAoOyBmOyApXG4gICAgICAgICAgaWYgKGYgPSBvKGYpLCBmICYmIGYubm9kZVR5cGUgPT09IDggJiYgZi5kYXRhID09PSBcInRlbGVwb3J0IGFuY2hvclwiKSB7XG4gICAgICAgICAgICBlLnRhcmdldEFuY2hvciA9IGYsIHUuX2xwYSA9IGUudGFyZ2V0QW5jaG9yICYmIG8oZS50YXJnZXRBbmNob3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjKFxuICAgICAgICAgIGQsXG4gICAgICAgICAgZSxcbiAgICAgICAgICB1LFxuICAgICAgICAgIG4sXG4gICAgICAgICAgcixcbiAgICAgICAgICBpLFxuICAgICAgICAgIHNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICBDMShlKTtcbiAgfVxuICByZXR1cm4gZS5hbmNob3IgJiYgbyhlLmFuY2hvcik7XG59XG5jb25zdCBUTyA9IE8kO1xuZnVuY3Rpb24gQzEodCkge1xuICBjb25zdCBlID0gdC5jdHg7XG4gIGlmIChlICYmIGUudXQpIHtcbiAgICBsZXQgbiA9IHQuY2hpbGRyZW5bMF0uZWw7XG4gICAgZm9yICg7IG4gJiYgbiAhPT0gdC50YXJnZXRBbmNob3I7IClcbiAgICAgIG4ubm9kZVR5cGUgPT09IDEgJiYgbi5zZXRBdHRyaWJ1dGUoXCJkYXRhLXYtb3duZXJcIiwgZS51aWQpLCBuID0gbi5uZXh0U2libGluZztcbiAgICBlLnV0KCk7XG4gIH1cbn1cbmNvbnN0IFBlID0gU3ltYm9sLmZvcihcInYtZmd0XCIpLCBucyA9IFN5bWJvbC5mb3IoXCJ2LXR4dFwiKSwgX3QgPSBTeW1ib2wuZm9yKFwidi1jbXRcIiksIEZpID0gU3ltYm9sLmZvcihcInYtc3RjXCIpLCBCYSA9IFtdO1xubGV0IGtuID0gbnVsbDtcbmZ1bmN0aW9uIFoodCA9ICExKSB7XG4gIEJhLnB1c2goa24gPSB0ID8gbnVsbCA6IFtdKTtcbn1cbmZ1bmN0aW9uIEExKCkge1xuICBCYS5wb3AoKSwga24gPSBCYVtCYS5sZW5ndGggLSAxXSB8fCBudWxsO1xufVxubGV0IGpzID0gMTtcbmZ1bmN0aW9uIHZoKHQpIHtcbiAganMgKz0gdDtcbn1cbmZ1bmN0aW9uIFIxKHQpIHtcbiAgcmV0dXJuIHQuZHluYW1pY0NoaWxkcmVuID0ganMgPiAwID8ga24gfHwgbW8gOiBudWxsLCBBMSgpLCBqcyA+IDAgJiYga24gJiYga24ucHVzaCh0KSwgdDtcbn1cbmZ1bmN0aW9uIG5lKHQsIGUsIG4sIHIsIGksIHMpIHtcbiAgcmV0dXJuIFIxKFxuICAgIEQoXG4gICAgICB0LFxuICAgICAgZSxcbiAgICAgIG4sXG4gICAgICByLFxuICAgICAgaSxcbiAgICAgIHMsXG4gICAgICAhMFxuICAgIClcbiAgKTtcbn1cbmZ1bmN0aW9uIGtlKHQsIGUsIG4sIHIsIGkpIHtcbiAgcmV0dXJuIFIxKFxuICAgIEooXG4gICAgICB0LFxuICAgICAgZSxcbiAgICAgIG4sXG4gICAgICByLFxuICAgICAgaSxcbiAgICAgICEwXG4gICAgKVxuICApO1xufVxuZnVuY3Rpb24gbGkodCkge1xuICByZXR1cm4gdCA/IHQuX192X2lzVk5vZGUgPT09ICEwIDogITE7XG59XG5mdW5jdGlvbiBscih0LCBlKSB7XG4gIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZS5zaGFwZUZsYWcgJiA2ICYmIHVvLmhhcyhlLnR5cGUpID8gKHQuc2hhcGVGbGFnICY9IC0yNTcsIGUuc2hhcGVGbGFnICY9IC01MTMsICExKSA6IHQudHlwZSA9PT0gZS50eXBlICYmIHQua2V5ID09PSBlLmtleTtcbn1cbmxldCB5aDtcbmZ1bmN0aW9uIG0kKHQpIHtcbiAgeWggPSB0O1xufVxuY29uc3QgYiQgPSAoLi4udCkgPT4gRDEoXG4gIC4uLnloID8geWgodCwgT3QpIDogdFxuKSwgUGQgPSBcIl9fdkludGVybmFsXCIsIE4xID0gKHsga2V5OiB0IH0pID0+IHQgPz8gbnVsbCwgRmMgPSAoe1xuICByZWY6IHQsXG4gIHJlZl9rZXk6IGUsXG4gIHJlZl9mb3I6IG5cbn0pID0+ICh0eXBlb2YgdCA9PSBcIm51bWJlclwiICYmICh0ID0gXCJcIiArIHQpLCB0ICE9IG51bGwgPyB3ZSh0KSB8fCBDdCh0KSB8fCBiZSh0KSA/IHsgaTogT3QsIHI6IHQsIGs6IGUsIGY6ICEhbiB9IDogdCA6IG51bGwpO1xuZnVuY3Rpb24gRCh0LCBlID0gbnVsbCwgbiA9IG51bGwsIHIgPSAwLCBpID0gbnVsbCwgcyA9IHQgPT09IFBlID8gMCA6IDEsIG8gPSAhMSwgYSA9ICExKSB7XG4gIGNvbnN0IGwgPSB7XG4gICAgX192X2lzVk5vZGU6ICEwLFxuICAgIF9fdl9za2lwOiAhMCxcbiAgICB0eXBlOiB0LFxuICAgIHByb3BzOiBlLFxuICAgIGtleTogZSAmJiBOMShlKSxcbiAgICByZWY6IGUgJiYgRmMoZSksXG4gICAgc2NvcGVJZDogdmQsXG4gICAgc2xvdFNjb3BlSWRzOiBudWxsLFxuICAgIGNoaWxkcmVuOiBuLFxuICAgIGNvbXBvbmVudDogbnVsbCxcbiAgICBzdXNwZW5zZTogbnVsbCxcbiAgICBzc0NvbnRlbnQ6IG51bGwsXG4gICAgc3NGYWxsYmFjazogbnVsbCxcbiAgICBkaXJzOiBudWxsLFxuICAgIHRyYW5zaXRpb246IG51bGwsXG4gICAgZWw6IG51bGwsXG4gICAgYW5jaG9yOiBudWxsLFxuICAgIHRhcmdldDogbnVsbCxcbiAgICB0YXJnZXRBbmNob3I6IG51bGwsXG4gICAgc3RhdGljQ291bnQ6IDAsXG4gICAgc2hhcGVGbGFnOiBzLFxuICAgIHBhdGNoRmxhZzogcixcbiAgICBkeW5hbWljUHJvcHM6IGksXG4gICAgZHluYW1pY0NoaWxkcmVuOiBudWxsLFxuICAgIGFwcENvbnRleHQ6IG51bGwsXG4gICAgY3R4OiBPdFxuICB9O1xuICByZXR1cm4gYSA/ICgkTyhsLCBuKSwgcyAmIDEyOCAmJiB0Lm5vcm1hbGl6ZShsKSkgOiBuICYmIChsLnNoYXBlRmxhZyB8PSB3ZShuKSA/IDggOiAxNiksIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBsLmtleSAhPT0gbC5rZXkgJiYgSShcIlZOb2RlIGNyZWF0ZWQgd2l0aCBpbnZhbGlkIGtleSAoTmFOKS4gVk5vZGUgdHlwZTpcIiwgbC50eXBlKSwganMgPiAwICYmIC8vIGF2b2lkIGEgYmxvY2sgbm9kZSBmcm9tIHRyYWNraW5nIGl0c2VsZlxuICAhbyAmJiAvLyBoYXMgY3VycmVudCBwYXJlbnQgYmxvY2tcbiAga24gJiYgLy8gcHJlc2VuY2Ugb2YgYSBwYXRjaCBmbGFnIGluZGljYXRlcyB0aGlzIG5vZGUgbmVlZHMgcGF0Y2hpbmcgb24gdXBkYXRlcy5cbiAgLy8gY29tcG9uZW50IG5vZGVzIGFsc28gc2hvdWxkIGFsd2F5cyBiZSBwYXRjaGVkLCBiZWNhdXNlIGV2ZW4gaWYgdGhlXG4gIC8vIGNvbXBvbmVudCBkb2Vzbid0IG5lZWQgdG8gdXBkYXRlLCBpdCBuZWVkcyB0byBwZXJzaXN0IHRoZSBpbnN0YW5jZSBvbiB0b1xuICAvLyB0aGUgbmV4dCB2bm9kZSBzbyB0aGF0IGl0IGNhbiBiZSBwcm9wZXJseSB1bm1vdW50ZWQgbGF0ZXIuXG4gIChsLnBhdGNoRmxhZyA+IDAgfHwgcyAmIDYpICYmIC8vIHRoZSBFVkVOVFMgZmxhZyBpcyBvbmx5IGZvciBoeWRyYXRpb24gYW5kIGlmIGl0IGlzIHRoZSBvbmx5IGZsYWcsIHRoZVxuICAvLyB2bm9kZSBzaG91bGQgbm90IGJlIGNvbnNpZGVyZWQgZHluYW1pYyBkdWUgdG8gaGFuZGxlciBjYWNoaW5nLlxuICBsLnBhdGNoRmxhZyAhPT0gMzIgJiYga24ucHVzaChsKSwgbDtcbn1cbmNvbnN0IEogPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBiJCA6IEQxO1xuZnVuY3Rpb24gRDEodCwgZSA9IG51bGwsIG4gPSBudWxsLCByID0gMCwgaSA9IG51bGwsIHMgPSAhMSkge1xuICBpZiAoKCF0IHx8IHQgPT09IG1PKSAmJiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICF0ICYmIEkoYEludmFsaWQgdm5vZGUgdHlwZSB3aGVuIGNyZWF0aW5nIHZub2RlOiAke3R9LmApLCB0ID0gX3QpLCBsaSh0KSkge1xuICAgIGNvbnN0IGEgPSBqbihcbiAgICAgIHQsXG4gICAgICBlLFxuICAgICAgITBcbiAgICAgIC8qIG1lcmdlUmVmOiB0cnVlICovXG4gICAgKTtcbiAgICByZXR1cm4gbiAmJiAkTyhhLCBuKSwganMgPiAwICYmICFzICYmIGtuICYmIChhLnNoYXBlRmxhZyAmIDYgPyBrbltrbi5pbmRleE9mKHQpXSA9IGEgOiBrbi5wdXNoKGEpKSwgYS5wYXRjaEZsYWcgfD0gLTIsIGE7XG4gIH1cbiAgaWYgKEIxKHQpICYmICh0ID0gdC5fX3ZjY09wdHMpLCBlKSB7XG4gICAgZSA9IEVPKGUpO1xuICAgIGxldCB7IGNsYXNzOiBhLCBzdHlsZTogbCB9ID0gZTtcbiAgICBhICYmICF3ZShhKSAmJiAoZS5jbGFzcyA9IEtlKGEpKSwgWmUobCkgJiYgKEphKGwpICYmICFpZShsKSAmJiAobCA9ICRlKHt9LCBsKSksIGUuc3R5bGUgPSBCcihsKSk7XG4gIH1cbiAgY29uc3QgbyA9IHdlKHQpID8gMSA6IEt5KHQpID8gMTI4IDogcCQodCkgPyA2NCA6IFplKHQpID8gNCA6IGJlKHQpID8gMiA6IDA7XG4gIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgbyAmIDQgJiYgSmEodCkgJiYgKHQgPSBPZSh0KSwgSShcbiAgICBcIlZ1ZSByZWNlaXZlZCBhIENvbXBvbmVudCB0aGF0IHdhcyBtYWRlIGEgcmVhY3RpdmUgb2JqZWN0LiBUaGlzIGNhbiBsZWFkIHRvIHVubmVjZXNzYXJ5IHBlcmZvcm1hbmNlIG92ZXJoZWFkIGFuZCBzaG91bGQgYmUgYXZvaWRlZCBieSBtYXJraW5nIHRoZSBjb21wb25lbnQgd2l0aCBgbWFya1Jhd2Agb3IgdXNpbmcgYHNoYWxsb3dSZWZgIGluc3RlYWQgb2YgYHJlZmAuXCIsXG4gICAgYFxuQ29tcG9uZW50IHRoYXQgd2FzIG1hZGUgcmVhY3RpdmU6IGAsXG4gICAgdFxuICApKSwgRChcbiAgICB0LFxuICAgIGUsXG4gICAgbixcbiAgICByLFxuICAgIGksXG4gICAgbyxcbiAgICBzLFxuICAgICEwXG4gICk7XG59XG5mdW5jdGlvbiBFTyh0KSB7XG4gIHJldHVybiB0ID8gSmEodCkgfHwgUGQgaW4gdCA/ICRlKHt9LCB0KSA6IHQgOiBudWxsO1xufVxuZnVuY3Rpb24gam4odCwgZSwgbiA9ICExKSB7XG4gIGNvbnN0IHsgcHJvcHM6IHIsIHJlZjogaSwgcGF0Y2hGbGFnOiBzLCBjaGlsZHJlbjogbyB9ID0gdCwgYSA9IGUgPyBNbChyIHx8IHt9LCBlKSA6IHI7XG4gIHJldHVybiB7XG4gICAgX192X2lzVk5vZGU6ICEwLFxuICAgIF9fdl9za2lwOiAhMCxcbiAgICB0eXBlOiB0LnR5cGUsXG4gICAgcHJvcHM6IGEsXG4gICAga2V5OiBhICYmIE4xKGEpLFxuICAgIHJlZjogZSAmJiBlLnJlZiA/IChcbiAgICAgIC8vICMyMDc4IGluIHRoZSBjYXNlIG9mIDxjb21wb25lbnQgOmlzPVwidm5vZGVcIiByZWY9XCJleHRyYVwiLz5cbiAgICAgIC8vIGlmIHRoZSB2bm9kZSBpdHNlbGYgYWxyZWFkeSBoYXMgYSByZWYsIGNsb25lVk5vZGUgd2lsbCBuZWVkIHRvIG1lcmdlXG4gICAgICAvLyB0aGUgcmVmcyBzbyB0aGUgc2luZ2xlIHZub2RlIGNhbiBiZSBzZXQgb24gbXVsdGlwbGUgcmVmc1xuICAgICAgbiAmJiBpID8gaWUoaSkgPyBpLmNvbmNhdChGYyhlKSkgOiBbaSwgRmMoZSldIDogRmMoZSlcbiAgICApIDogaSxcbiAgICBzY29wZUlkOiB0LnNjb3BlSWQsXG4gICAgc2xvdFNjb3BlSWRzOiB0LnNsb3RTY29wZUlkcyxcbiAgICBjaGlsZHJlbjogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHMgPT09IC0xICYmIGllKG8pID8gby5tYXAoWjEpIDogbyxcbiAgICB0YXJnZXQ6IHQudGFyZ2V0LFxuICAgIHRhcmdldEFuY2hvcjogdC50YXJnZXRBbmNob3IsXG4gICAgc3RhdGljQ291bnQ6IHQuc3RhdGljQ291bnQsXG4gICAgc2hhcGVGbGFnOiB0LnNoYXBlRmxhZyxcbiAgICAvLyBpZiB0aGUgdm5vZGUgaXMgY2xvbmVkIHdpdGggZXh0cmEgcHJvcHMsIHdlIGNhbiBubyBsb25nZXIgYXNzdW1lIGl0c1xuICAgIC8vIGV4aXN0aW5nIHBhdGNoIGZsYWcgdG8gYmUgcmVsaWFibGUgYW5kIG5lZWQgdG8gYWRkIHRoZSBGVUxMX1BST1BTIGZsYWcuXG4gICAgLy8gbm90ZTogcHJlc2VydmUgZmxhZyBmb3IgZnJhZ21lbnRzIHNpbmNlIHRoZXkgdXNlIHRoZSBmbGFnIGZvciBjaGlsZHJlblxuICAgIC8vIGZhc3QgcGF0aHMgb25seS5cbiAgICBwYXRjaEZsYWc6IGUgJiYgdC50eXBlICE9PSBQZSA/IHMgPT09IC0xID8gMTYgOiBzIHwgMTYgOiBzLFxuICAgIGR5bmFtaWNQcm9wczogdC5keW5hbWljUHJvcHMsXG4gICAgZHluYW1pY0NoaWxkcmVuOiB0LmR5bmFtaWNDaGlsZHJlbixcbiAgICBhcHBDb250ZXh0OiB0LmFwcENvbnRleHQsXG4gICAgZGlyczogdC5kaXJzLFxuICAgIHRyYW5zaXRpb246IHQudHJhbnNpdGlvbixcbiAgICAvLyBUaGVzZSBzaG91bGQgdGVjaG5pY2FsbHkgb25seSBiZSBub24tbnVsbCBvbiBtb3VudGVkIFZOb2Rlcy4gSG93ZXZlcixcbiAgICAvLyB0aGV5ICpzaG91bGQqIGJlIGNvcGllZCBmb3Iga2VwdC1hbGl2ZSB2bm9kZXMuIFNvIHdlIGp1c3QgYWx3YXlzIGNvcHlcbiAgICAvLyB0aGVtIHNpbmNlIHRoZW0gYmVpbmcgbm9uLW51bGwgZHVyaW5nIGEgbW91bnQgZG9lc24ndCBhZmZlY3QgdGhlIGxvZ2ljIGFzXG4gICAgLy8gdGhleSB3aWxsIHNpbXBseSBiZSBvdmVyd3JpdHRlbi5cbiAgICBjb21wb25lbnQ6IHQuY29tcG9uZW50LFxuICAgIHN1c3BlbnNlOiB0LnN1c3BlbnNlLFxuICAgIHNzQ29udGVudDogdC5zc0NvbnRlbnQgJiYgam4odC5zc0NvbnRlbnQpLFxuICAgIHNzRmFsbGJhY2s6IHQuc3NGYWxsYmFjayAmJiBqbih0LnNzRmFsbGJhY2spLFxuICAgIGVsOiB0LmVsLFxuICAgIGFuY2hvcjogdC5hbmNob3IsXG4gICAgY3R4OiB0LmN0eCxcbiAgICBjZTogdC5jZVxuICB9O1xufVxuZnVuY3Rpb24gWjEodCkge1xuICBjb25zdCBlID0gam4odCk7XG4gIHJldHVybiBpZSh0LmNoaWxkcmVuKSAmJiAoZS5jaGlsZHJlbiA9IHQuY2hpbGRyZW4ubWFwKFoxKSksIGU7XG59XG5mdW5jdGlvbiBIZSh0ID0gXCIgXCIsIGUgPSAwKSB7XG4gIHJldHVybiBKKG5zLCBudWxsLCB0LCBlKTtcbn1cbmZ1bmN0aW9uIFdsKHQsIGUpIHtcbiAgY29uc3QgbiA9IEooRmksIG51bGwsIHQpO1xuICByZXR1cm4gbi5zdGF0aWNDb3VudCA9IGUsIG47XG59XG5mdW5jdGlvbiBzdCh0ID0gXCJcIiwgZSA9ICExKSB7XG4gIHJldHVybiBlID8gKFooKSwga2UoX3QsIG51bGwsIHQpKSA6IEooX3QsIG51bGwsIHQpO1xufVxuZnVuY3Rpb24gU24odCkge1xuICByZXR1cm4gdCA9PSBudWxsIHx8IHR5cGVvZiB0ID09IFwiYm9vbGVhblwiID8gSihfdCkgOiBpZSh0KSA/IEooXG4gICAgUGUsXG4gICAgbnVsbCxcbiAgICAvLyAjMzY2NiwgYXZvaWQgcmVmZXJlbmNlIHBvbGx1dGlvbiB3aGVuIHJldXNpbmcgdm5vZGVcbiAgICB0LnNsaWNlKClcbiAgKSA6IHR5cGVvZiB0ID09IFwib2JqZWN0XCIgPyBBaSh0KSA6IEoobnMsIG51bGwsIFN0cmluZyh0KSk7XG59XG5mdW5jdGlvbiBBaSh0KSB7XG4gIHJldHVybiB0LmVsID09PSBudWxsICYmIHQucGF0Y2hGbGFnICE9PSAtMSB8fCB0Lm1lbW8gPyB0IDogam4odCk7XG59XG5mdW5jdGlvbiAkTyh0LCBlKSB7XG4gIGxldCBuID0gMDtcbiAgY29uc3QgeyBzaGFwZUZsYWc6IHIgfSA9IHQ7XG4gIGlmIChlID09IG51bGwpXG4gICAgZSA9IG51bGw7XG4gIGVsc2UgaWYgKGllKGUpKVxuICAgIG4gPSAxNjtcbiAgZWxzZSBpZiAodHlwZW9mIGUgPT0gXCJvYmplY3RcIilcbiAgICBpZiAociAmIDY1KSB7XG4gICAgICBjb25zdCBpID0gZS5kZWZhdWx0O1xuICAgICAgaSAmJiAoaS5fYyAmJiAoaS5fZCA9ICExKSwgJE8odCwgaSgpKSwgaS5fYyAmJiAoaS5fZCA9ICEwKSk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIG4gPSAzMjtcbiAgICAgIGNvbnN0IGkgPSBlLl87XG4gICAgICAhaSAmJiAhKFBkIGluIGUpID8gZS5fY3R4ID0gT3QgOiBpID09PSAzICYmIE90ICYmIChPdC5zbG90cy5fID09PSAxID8gZS5fID0gMSA6IChlLl8gPSAyLCB0LnBhdGNoRmxhZyB8PSAxMDI0KSk7XG4gICAgfVxuICBlbHNlXG4gICAgYmUoZSkgPyAoZSA9IHsgZGVmYXVsdDogZSwgX2N0eDogT3QgfSwgbiA9IDMyKSA6IChlID0gU3RyaW5nKGUpLCByICYgNjQgPyAobiA9IDE2LCBlID0gW0hlKGUpXSkgOiBuID0gOCk7XG4gIHQuY2hpbGRyZW4gPSBlLCB0LnNoYXBlRmxhZyB8PSBuO1xufVxuZnVuY3Rpb24gTWwoLi4udCkge1xuICBjb25zdCBlID0ge307XG4gIGZvciAobGV0IG4gPSAwOyBuIDwgdC5sZW5ndGg7IG4rKykge1xuICAgIGNvbnN0IHIgPSB0W25dO1xuICAgIGZvciAoY29uc3QgaSBpbiByKVxuICAgICAgaWYgKGkgPT09IFwiY2xhc3NcIilcbiAgICAgICAgZS5jbGFzcyAhPT0gci5jbGFzcyAmJiAoZS5jbGFzcyA9IEtlKFtlLmNsYXNzLCByLmNsYXNzXSkpO1xuICAgICAgZWxzZSBpZiAoaSA9PT0gXCJzdHlsZVwiKVxuICAgICAgICBlLnN0eWxlID0gQnIoW2Uuc3R5bGUsIHIuc3R5bGVdKTtcbiAgICAgIGVsc2UgaWYgKG9pKGkpKSB7XG4gICAgICAgIGNvbnN0IHMgPSBlW2ldLCBvID0gcltpXTtcbiAgICAgICAgbyAmJiBzICE9PSBvICYmICEoaWUocykgJiYgcy5pbmNsdWRlcyhvKSkgJiYgKGVbaV0gPSBzID8gW10uY29uY2F0KHMsIG8pIDogbyk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgaSAhPT0gXCJcIiAmJiAoZVtpXSA9IHJbaV0pO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24geW4odCwgZSwgbiwgciA9IG51bGwpIHtcbiAgV24odCwgZSwgNywgW1xuICAgIG4sXG4gICAgclxuICBdKTtcbn1cbmNvbnN0IHYkID0gdjEoKTtcbmxldCB5JCA9IDA7XG5mdW5jdGlvbiBWMSh0LCBlLCBuKSB7XG4gIGNvbnN0IHIgPSB0LnR5cGUsIGkgPSAoZSA/IGUuYXBwQ29udGV4dCA6IHQuYXBwQ29udGV4dCkgfHwgdiQsIHMgPSB7XG4gICAgdWlkOiB5JCsrLFxuICAgIHZub2RlOiB0LFxuICAgIHR5cGU6IHIsXG4gICAgcGFyZW50OiBlLFxuICAgIGFwcENvbnRleHQ6IGksXG4gICAgcm9vdDogbnVsbCxcbiAgICAvLyB0byBiZSBpbW1lZGlhdGVseSBzZXRcbiAgICBuZXh0OiBudWxsLFxuICAgIHN1YlRyZWU6IG51bGwsXG4gICAgLy8gd2lsbCBiZSBzZXQgc3luY2hyb25vdXNseSByaWdodCBhZnRlciBjcmVhdGlvblxuICAgIGVmZmVjdDogbnVsbCxcbiAgICB1cGRhdGU6IG51bGwsXG4gICAgLy8gd2lsbCBiZSBzZXQgc3luY2hyb25vdXNseSByaWdodCBhZnRlciBjcmVhdGlvblxuICAgIHNjb3BlOiBuZXcgZU8oXG4gICAgICAhMFxuICAgICAgLyogZGV0YWNoZWQgKi9cbiAgICApLFxuICAgIHJlbmRlcjogbnVsbCxcbiAgICBwcm94eTogbnVsbCxcbiAgICBleHBvc2VkOiBudWxsLFxuICAgIGV4cG9zZVByb3h5OiBudWxsLFxuICAgIHdpdGhQcm94eTogbnVsbCxcbiAgICBwcm92aWRlczogZSA/IGUucHJvdmlkZXMgOiBPYmplY3QuY3JlYXRlKGkucHJvdmlkZXMpLFxuICAgIGFjY2Vzc0NhY2hlOiBudWxsLFxuICAgIHJlbmRlckNhY2hlOiBbXSxcbiAgICAvLyBsb2NhbCByZXNvbHZlZCBhc3NldHNcbiAgICBjb21wb25lbnRzOiBudWxsLFxuICAgIGRpcmVjdGl2ZXM6IG51bGwsXG4gICAgLy8gcmVzb2x2ZWQgcHJvcHMgYW5kIGVtaXRzIG9wdGlvbnNcbiAgICBwcm9wc09wdGlvbnM6IFMxKHIsIGkpLFxuICAgIGVtaXRzT3B0aW9uczogRnkociwgaSksXG4gICAgLy8gZW1pdFxuICAgIGVtaXQ6IG51bGwsXG4gICAgLy8gdG8gYmUgc2V0IGltbWVkaWF0ZWx5XG4gICAgZW1pdHRlZDogbnVsbCxcbiAgICAvLyBwcm9wcyBkZWZhdWx0IHZhbHVlXG4gICAgcHJvcHNEZWZhdWx0czogVmUsXG4gICAgLy8gaW5oZXJpdEF0dHJzXG4gICAgaW5oZXJpdEF0dHJzOiByLmluaGVyaXRBdHRycyxcbiAgICAvLyBzdGF0ZVxuICAgIGN0eDogVmUsXG4gICAgZGF0YTogVmUsXG4gICAgcHJvcHM6IFZlLFxuICAgIGF0dHJzOiBWZSxcbiAgICBzbG90czogVmUsXG4gICAgcmVmczogVmUsXG4gICAgc2V0dXBTdGF0ZTogVmUsXG4gICAgc2V0dXBDb250ZXh0OiBudWxsLFxuICAgIGF0dHJzUHJveHk6IG51bGwsXG4gICAgc2xvdHNQcm94eTogbnVsbCxcbiAgICAvLyBzdXNwZW5zZSByZWxhdGVkXG4gICAgc3VzcGVuc2U6IG4sXG4gICAgc3VzcGVuc2VJZDogbiA/IG4ucGVuZGluZ0lkIDogMCxcbiAgICBhc3luY0RlcDogbnVsbCxcbiAgICBhc3luY1Jlc29sdmVkOiAhMSxcbiAgICAvLyBsaWZlY3ljbGUgaG9va3NcbiAgICAvLyBub3QgdXNpbmcgZW51bXMgaGVyZSBiZWNhdXNlIGl0IHJlc3VsdHMgaW4gY29tcHV0ZWQgcHJvcGVydGllc1xuICAgIGlzTW91bnRlZDogITEsXG4gICAgaXNVbm1vdW50ZWQ6ICExLFxuICAgIGlzRGVhY3RpdmF0ZWQ6ICExLFxuICAgIGJjOiBudWxsLFxuICAgIGM6IG51bGwsXG4gICAgYm06IG51bGwsXG4gICAgbTogbnVsbCxcbiAgICBidTogbnVsbCxcbiAgICB1OiBudWxsLFxuICAgIHVtOiBudWxsLFxuICAgIGJ1bTogbnVsbCxcbiAgICBkYTogbnVsbCxcbiAgICBhOiBudWxsLFxuICAgIHJ0ZzogbnVsbCxcbiAgICBydGM6IG51bGwsXG4gICAgZWM6IG51bGwsXG4gICAgc3A6IG51bGxcbiAgfTtcbiAgcmV0dXJuIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHMuY3R4ID0gUEUocykgOiBzLmN0eCA9IHsgXzogcyB9LCBzLnJvb3QgPSBlID8gZS5yb290IDogcywgcy5lbWl0ID0gbkUuYmluZChudWxsLCBzKSwgdC5jZSAmJiB0LmNlKHMpLCBzO1xufVxubGV0IHh0ID0gbnVsbDtcbmNvbnN0IGlyID0gKCkgPT4geHQgfHwgT3Q7XG5sZXQgVHUsIFNoO1xue1xuICBjb25zdCB0ID0gYm8oKSwgZSA9IChuLCByKSA9PiB7XG4gICAgbGV0IGk7XG4gICAgcmV0dXJuIChpID0gdFtuXSkgfHwgKGkgPSB0W25dID0gW10pLCBpLnB1c2gociksIChzKSA9PiB7XG4gICAgICBpLmxlbmd0aCA+IDEgPyBpLmZvckVhY2goKG8pID0+IG8ocykpIDogaVswXShzKTtcbiAgICB9O1xuICB9O1xuICBUdSA9IGUoXG4gICAgXCJfX1ZVRV9JTlNUQU5DRV9TRVRURVJTX19cIixcbiAgICAobikgPT4geHQgPSBuXG4gICksIFNoID0gZShcbiAgICBcIl9fVlVFX1NTUl9TRVRURVJTX19cIixcbiAgICAobikgPT4gWGwgPSBuXG4gICk7XG59XG5jb25zdCBCcyA9ICh0KSA9PiB7XG4gIGNvbnN0IGUgPSB4dDtcbiAgcmV0dXJuIFR1KHQpLCB0LnNjb3BlLm9uKCksICgpID0+IHtcbiAgICB0LnNjb3BlLm9mZigpLCBUdShlKTtcbiAgfTtcbn0sIHdoID0gKCkgPT4ge1xuICB4dCAmJiB4dC5zY29wZS5vZmYoKSwgVHUobnVsbCk7XG59LCBTJCA9IC8qIEBfX1BVUkVfXyAqLyBCdChcInNsb3QsY29tcG9uZW50XCIpO1xuZnVuY3Rpb24ga2godCwgeyBpc05hdGl2ZVRhZzogZSB9KSB7XG4gIChTJCh0KSB8fCBlKHQpKSAmJiBJKFxuICAgIFwiRG8gbm90IHVzZSBidWlsdC1pbiBvciByZXNlcnZlZCBIVE1MIGVsZW1lbnRzIGFzIGNvbXBvbmVudCBpZDogXCIgKyB0XG4gICk7XG59XG5mdW5jdGlvbiBJMSh0KSB7XG4gIHJldHVybiB0LnZub2RlLnNoYXBlRmxhZyAmIDQ7XG59XG5sZXQgWGwgPSAhMTtcbmZ1bmN0aW9uIFcxKHQsIGUgPSAhMSkge1xuICBlICYmIFNoKGUpO1xuICBjb25zdCB7IHByb3BzOiBuLCBjaGlsZHJlbjogciB9ID0gdC52bm9kZSwgaSA9IEkxKHQpO1xuICBIRSh0LCBuLCBpLCBlKSwgaSQodCwgcik7XG4gIGNvbnN0IHMgPSBpID8gdyQodCwgZSkgOiB2b2lkIDA7XG4gIHJldHVybiBlICYmIFNoKCExKSwgcztcbn1cbmZ1bmN0aW9uIHckKHQsIGUpIHtcbiAgdmFyIG47XG4gIGNvbnN0IHIgPSB0LnR5cGU7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoci5uYW1lICYmIGtoKHIubmFtZSwgdC5hcHBDb250ZXh0LmNvbmZpZyksIHIuY29tcG9uZW50cykge1xuICAgICAgY29uc3QgcyA9IE9iamVjdC5rZXlzKHIuY29tcG9uZW50cyk7XG4gICAgICBmb3IgKGxldCBvID0gMDsgbyA8IHMubGVuZ3RoOyBvKyspXG4gICAgICAgIGtoKHNbb10sIHQuYXBwQ29udGV4dC5jb25maWcpO1xuICAgIH1cbiAgICBpZiAoci5kaXJlY3RpdmVzKSB7XG4gICAgICBjb25zdCBzID0gT2JqZWN0LmtleXMoci5kaXJlY3RpdmVzKTtcbiAgICAgIGZvciAobGV0IG8gPSAwOyBvIDwgcy5sZW5ndGg7IG8rKylcbiAgICAgICAgaTEoc1tvXSk7XG4gICAgfVxuICAgIHIuY29tcGlsZXJPcHRpb25zICYmIFFPKCkgJiYgSShcbiAgICAgICdcImNvbXBpbGVyT3B0aW9uc1wiIGlzIG9ubHkgc3VwcG9ydGVkIHdoZW4gdXNpbmcgYSBidWlsZCBvZiBWdWUgdGhhdCBpbmNsdWRlcyB0aGUgcnVudGltZSBjb21waWxlci4gU2luY2UgeW91IGFyZSB1c2luZyBhIHJ1bnRpbWUtb25seSBidWlsZCwgdGhlIG9wdGlvbnMgc2hvdWxkIGJlIHBhc3NlZCB2aWEgeW91ciBidWlsZCB0b29sIGNvbmZpZyBpbnN0ZWFkLidcbiAgICApO1xuICB9XG4gIHQuYWNjZXNzQ2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgdC5wcm94eSA9IG9PKG5ldyBQcm94eSh0LmN0eCwgWGEpKSwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIF9FKHQpO1xuICBjb25zdCB7IHNldHVwOiBpIH0gPSByO1xuICBpZiAoaSkge1xuICAgIGNvbnN0IHMgPSB0LnNldHVwQ29udGV4dCA9IGkubGVuZ3RoID4gMSA/IGoxKHQpIDogbnVsbCwgbyA9IEJzKHQpO1xuICAgIGRzKCk7XG4gICAgY29uc3QgYSA9IFZyKFxuICAgICAgaSxcbiAgICAgIHQsXG4gICAgICAwLFxuICAgICAgW1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBEbih0LnByb3BzKSA6IHQucHJvcHMsXG4gICAgICAgIHNcbiAgICAgIF1cbiAgICApO1xuICAgIGlmIChmcygpLCBvKCksIGRkKGEpKSB7XG4gICAgICBpZiAoYS50aGVuKHdoLCB3aCksIGUpXG4gICAgICAgIHJldHVybiBhLnRoZW4oKGwpID0+IHtcbiAgICAgICAgICB4aCh0LCBsLCBlKTtcbiAgICAgICAgfSkuY2F0Y2goKGwpID0+IHtcbiAgICAgICAgICBocyhsLCB0LCAwKTtcbiAgICAgICAgfSk7XG4gICAgICBpZiAodC5hc3luY0RlcCA9IGEsIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhdC5zdXNwZW5zZSkge1xuICAgICAgICBjb25zdCBsID0gKG4gPSByLm5hbWUpICE9IG51bGwgPyBuIDogXCJBbm9ueW1vdXNcIjtcbiAgICAgICAgSShcbiAgICAgICAgICBgQ29tcG9uZW50IDwke2x9Pjogc2V0dXAgZnVuY3Rpb24gcmV0dXJuZWQgYSBwcm9taXNlLCBidXQgbm8gPFN1c3BlbnNlPiBib3VuZGFyeSB3YXMgZm91bmQgaW4gdGhlIHBhcmVudCBjb21wb25lbnQgdHJlZS4gQSBjb21wb25lbnQgd2l0aCBhc3luYyBzZXR1cCgpIG11c3QgYmUgbmVzdGVkIGluIGEgPFN1c3BlbnNlPiBpbiBvcmRlciB0byBiZSByZW5kZXJlZC5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlXG4gICAgICB4aCh0LCBhLCBlKTtcbiAgfSBlbHNlXG4gICAgWDEodCwgZSk7XG59XG5mdW5jdGlvbiB4aCh0LCBlLCBuKSB7XG4gIGJlKGUpID8gdC50eXBlLl9fc3NySW5saW5lUmVuZGVyID8gdC5zc3JSZW5kZXIgPSBlIDogdC5yZW5kZXIgPSBlIDogWmUoZSkgPyAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGxpKGUpICYmIEkoXG4gICAgXCJzZXR1cCgpIHNob3VsZCBub3QgcmV0dXJuIFZOb2RlcyBkaXJlY3RseSAtIHJldHVybiBhIHJlbmRlciBmdW5jdGlvbiBpbnN0ZWFkLlwiXG4gICksIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgfHwgX19WVUVfUFJPRF9ERVZUT09MU19fKSAmJiAodC5kZXZ0b29sc1Jhd1NldHVwU3RhdGUgPSBlKSwgdC5zZXR1cFN0YXRlID0gdU8oZSksIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBURSh0KSkgOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZSAhPT0gdm9pZCAwICYmIEkoXG4gICAgYHNldHVwKCkgc2hvdWxkIHJldHVybiBhbiBvYmplY3QuIFJlY2VpdmVkOiAke2UgPT09IG51bGwgPyBcIm51bGxcIiA6IHR5cGVvZiBlfWBcbiAgKSwgWDEodCwgbik7XG59XG5sZXQgTGEsIFBoO1xuZnVuY3Rpb24gTTEodCkge1xuICBMYSA9IHQsIFBoID0gKGUpID0+IHtcbiAgICBlLnJlbmRlci5fcmMgJiYgKGUud2l0aFByb3h5ID0gbmV3IFByb3h5KGUuY3R4LCB4RSkpO1xuICB9O1xufVxuY29uc3QgUU8gPSAoKSA9PiAhTGE7XG5mdW5jdGlvbiBYMSh0LCBlLCBuKSB7XG4gIGNvbnN0IHIgPSB0LnR5cGU7XG4gIGlmICghdC5yZW5kZXIpIHtcbiAgICBpZiAoIWUgJiYgTGEgJiYgIXIucmVuZGVyKSB7XG4gICAgICBjb25zdCBpID0gci50ZW1wbGF0ZSB8fCBQTyh0KS50ZW1wbGF0ZTtcbiAgICAgIGlmIChpKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBGcih0LCBcImNvbXBpbGVcIik7XG4gICAgICAgIGNvbnN0IHsgaXNDdXN0b21FbGVtZW50OiBzLCBjb21waWxlck9wdGlvbnM6IG8gfSA9IHQuYXBwQ29udGV4dC5jb25maWcsIHsgZGVsaW1pdGVyczogYSwgY29tcGlsZXJPcHRpb25zOiBsIH0gPSByLCBjID0gJGUoXG4gICAgICAgICAgJGUoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlzQ3VzdG9tRWxlbWVudDogcyxcbiAgICAgICAgICAgICAgZGVsaW1pdGVyczogYVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9cbiAgICAgICAgICApLFxuICAgICAgICAgIGxcbiAgICAgICAgKTtcbiAgICAgICAgci5yZW5kZXIgPSBMYShpLCBjKSwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIEdyKHQsIFwiY29tcGlsZVwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdC5yZW5kZXIgPSByLnJlbmRlciB8fCBpdCwgUGggJiYgUGgodCk7XG4gIH1cbiAgaWYgKF9fVlVFX09QVElPTlNfQVBJX18pIHtcbiAgICBjb25zdCBpID0gQnModCk7XG4gICAgZHMoKTtcbiAgICB0cnkge1xuICAgICAgWEUodCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGZzKCksIGkoKTtcbiAgICB9XG4gIH1cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFyLnJlbmRlciAmJiB0LnJlbmRlciA9PT0gaXQgJiYgIWUgJiYgKCFMYSAmJiByLnRlbXBsYXRlID8gSShcbiAgICAnQ29tcG9uZW50IHByb3ZpZGVkIHRlbXBsYXRlIG9wdGlvbiBidXQgcnVudGltZSBjb21waWxhdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnVpbGQgb2YgVnVlLiBDb25maWd1cmUgeW91ciBidW5kbGVyIHRvIGFsaWFzIFwidnVlXCIgdG8gXCJ2dWUvZGlzdC92dWUuZXNtLWJ1bmRsZXIuanNcIi4nXG4gICkgOiBJKFwiQ29tcG9uZW50IGlzIG1pc3NpbmcgdGVtcGxhdGUgb3IgcmVuZGVyIGZ1bmN0aW9uLlwiKSk7XG59XG5mdW5jdGlvbiBWbSh0KSB7XG4gIHJldHVybiB0LmF0dHJzUHJveHkgfHwgKHQuYXR0cnNQcm94eSA9IG5ldyBQcm94eShcbiAgICB0LmF0dHJzLFxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IHtcbiAgICAgIGdldChlLCBuKSB7XG4gICAgICAgIHJldHVybiB3dSgpLCBLdCh0LCBcImdldFwiLCBcIiRhdHRyc1wiKSwgZVtuXTtcbiAgICAgIH0sXG4gICAgICBzZXQoKSB7XG4gICAgICAgIHJldHVybiBJKFwic2V0dXBDb250ZXh0LmF0dHJzIGlzIHJlYWRvbmx5LlwiKSwgITE7XG4gICAgICB9LFxuICAgICAgZGVsZXRlUHJvcGVydHkoKSB7XG4gICAgICAgIHJldHVybiBJKFwic2V0dXBDb250ZXh0LmF0dHJzIGlzIHJlYWRvbmx5LlwiKSwgITE7XG4gICAgICB9XG4gICAgfSA6IHtcbiAgICAgIGdldChlLCBuKSB7XG4gICAgICAgIHJldHVybiBLdCh0LCBcImdldFwiLCBcIiRhdHRyc1wiKSwgZVtuXTtcbiAgICAgIH1cbiAgICB9XG4gICkpO1xufVxuZnVuY3Rpb24gayQodCkge1xuICByZXR1cm4gdC5zbG90c1Byb3h5IHx8ICh0LnNsb3RzUHJveHkgPSBuZXcgUHJveHkodC5zbG90cywge1xuICAgIGdldChlLCBuKSB7XG4gICAgICByZXR1cm4gS3QodCwgXCJnZXRcIiwgXCIkc2xvdHNcIiksIGVbbl07XG4gICAgfVxuICB9KSk7XG59XG5mdW5jdGlvbiBqMSh0KSB7XG4gIGNvbnN0IGUgPSAobikgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKHQuZXhwb3NlZCAmJiBJKFwiZXhwb3NlKCkgc2hvdWxkIGJlIGNhbGxlZCBvbmx5IG9uY2UgcGVyIHNldHVwKCkuXCIpLCBuICE9IG51bGwpKSB7XG4gICAgICBsZXQgciA9IHR5cGVvZiBuO1xuICAgICAgciA9PT0gXCJvYmplY3RcIiAmJiAoaWUobikgPyByID0gXCJhcnJheVwiIDogQ3QobikgJiYgKHIgPSBcInJlZlwiKSksIHIgIT09IFwib2JqZWN0XCIgJiYgSShcbiAgICAgICAgYGV4cG9zZSgpIHNob3VsZCBiZSBwYXNzZWQgYSBwbGFpbiBvYmplY3QsIHJlY2VpdmVkICR7cn0uYFxuICAgICAgKTtcbiAgICB9XG4gICAgdC5leHBvc2VkID0gbiB8fCB7fTtcbiAgfTtcbiAgcmV0dXJuIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IE9iamVjdC5mcmVlemUoe1xuICAgIGdldCBhdHRycygpIHtcbiAgICAgIHJldHVybiBWbSh0KTtcbiAgICB9LFxuICAgIGdldCBzbG90cygpIHtcbiAgICAgIHJldHVybiBrJCh0KTtcbiAgICB9LFxuICAgIGdldCBlbWl0KCkge1xuICAgICAgcmV0dXJuIChuLCAuLi5yKSA9PiB0LmVtaXQobiwgLi4ucik7XG4gICAgfSxcbiAgICBleHBvc2U6IGVcbiAgfSkgOiB7XG4gICAgZ2V0IGF0dHJzKCkge1xuICAgICAgcmV0dXJuIFZtKHQpO1xuICAgIH0sXG4gICAgc2xvdHM6IHQuc2xvdHMsXG4gICAgZW1pdDogdC5lbWl0LFxuICAgIGV4cG9zZTogZVxuICB9O1xufVxuZnVuY3Rpb24gX2QodCkge1xuICBpZiAodC5leHBvc2VkKVxuICAgIHJldHVybiB0LmV4cG9zZVByb3h5IHx8ICh0LmV4cG9zZVByb3h5ID0gbmV3IFByb3h5KHVPKG9PKHQuZXhwb3NlZCkpLCB7XG4gICAgICBnZXQoZSwgbikge1xuICAgICAgICBpZiAobiBpbiBlKVxuICAgICAgICAgIHJldHVybiBlW25dO1xuICAgICAgICBpZiAobiBpbiBacylcbiAgICAgICAgICByZXR1cm4gWnNbbl0odCk7XG4gICAgICB9LFxuICAgICAgaGFzKGUsIG4pIHtcbiAgICAgICAgcmV0dXJuIG4gaW4gZSB8fCBuIGluIFpzO1xuICAgICAgfVxuICAgIH0pKTtcbn1cbmNvbnN0IHgkID0gLyg/Ol58Wy1fXSkoXFx3KS9nLCBQJCA9ICh0KSA9PiB0LnJlcGxhY2UoeCQsIChlKSA9PiBlLnRvVXBwZXJDYXNlKCkpLnJlcGxhY2UoL1stX10vZywgXCJcIik7XG5mdW5jdGlvbiBhbCh0LCBlID0gITApIHtcbiAgcmV0dXJuIGJlKHQpID8gdC5kaXNwbGF5TmFtZSB8fCB0Lm5hbWUgOiB0Lm5hbWUgfHwgZSAmJiB0Ll9fbmFtZTtcbn1cbmZ1bmN0aW9uIFRkKHQsIGUsIG4gPSAhMSkge1xuICBsZXQgciA9IGFsKGUpO1xuICBpZiAoIXIgJiYgZS5fX2ZpbGUpIHtcbiAgICBjb25zdCBpID0gZS5fX2ZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwuXFx3KyQvKTtcbiAgICBpICYmIChyID0gaVsxXSk7XG4gIH1cbiAgaWYgKCFyICYmIHQgJiYgdC5wYXJlbnQpIHtcbiAgICBjb25zdCBpID0gKHMpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbyBpbiBzKVxuICAgICAgICBpZiAoc1tvXSA9PT0gZSlcbiAgICAgICAgICByZXR1cm4gbztcbiAgICB9O1xuICAgIHIgPSBpKFxuICAgICAgdC5jb21wb25lbnRzIHx8IHQucGFyZW50LnR5cGUuY29tcG9uZW50c1xuICAgICkgfHwgaSh0LmFwcENvbnRleHQuY29tcG9uZW50cyk7XG4gIH1cbiAgcmV0dXJuIHIgPyBQJChyKSA6IG4gPyBcIkFwcFwiIDogXCJBbm9ueW1vdXNcIjtcbn1cbmZ1bmN0aW9uIEIxKHQpIHtcbiAgcmV0dXJuIGJlKHQpICYmIFwiX192Y2NPcHRzXCIgaW4gdDtcbn1cbmNvbnN0IGogPSAodCwgZSkgPT4ge1xuICBjb25zdCBuID0gUFQodCwgZSwgWGwpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgY29uc3QgciA9IGlyKCk7XG4gICAgciAmJiByLmFwcENvbnRleHQuY29uZmlnLndhcm5SZWN1cnNpdmVDb21wdXRlZCAmJiAobi5fd2FyblJlY3Vyc2l2ZSA9ICEwKTtcbiAgfVxuICByZXR1cm4gbjtcbn07XG5mdW5jdGlvbiBfJCh0LCBlLCBuID0gVmUpIHtcbiAgY29uc3QgciA9IGlyKCk7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIXIpXG4gICAgcmV0dXJuIEkoXCJ1c2VNb2RlbCgpIGNhbGxlZCB3aXRob3V0IGFjdGl2ZSBpbnN0YW5jZS5cIiksIEcoKTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAhci5wcm9wc09wdGlvbnNbMF1bZV0pXG4gICAgcmV0dXJuIEkoYHVzZU1vZGVsKCkgY2FsbGVkIHdpdGggcHJvcCBcIiR7ZX1cIiB3aGljaCBpcyBub3QgZGVjbGFyZWQuYCksIEcoKTtcbiAgY29uc3QgaSA9IG10KGUpLCBzID0gcm4oZSksIG8gPSBYeSgobCwgYykgPT4ge1xuICAgIGxldCB1O1xuICAgIHJldHVybiBuMSgoKSA9PiB7XG4gICAgICBjb25zdCBkID0gdFtlXTtcbiAgICAgIGdyKHUsIGQpICYmICh1ID0gZCwgYygpKTtcbiAgICB9KSwge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gbCgpLCBuLmdldCA/IG4uZ2V0KHUpIDogdTtcbiAgICAgIH0sXG4gICAgICBzZXQoZCkge1xuICAgICAgICBjb25zdCBmID0gci52bm9kZS5wcm9wcztcbiAgICAgICAgIShmICYmIC8vIGNoZWNrIGlmIHBhcmVudCBoYXMgcGFzc2VkIHYtbW9kZWxcbiAgICAgICAgKGUgaW4gZiB8fCBpIGluIGYgfHwgcyBpbiBmKSAmJiAoYG9uVXBkYXRlOiR7ZX1gIGluIGYgfHwgYG9uVXBkYXRlOiR7aX1gIGluIGYgfHwgYG9uVXBkYXRlOiR7c31gIGluIGYpKSAmJiBncihkLCB1KSAmJiAodSA9IGQsIGMoKSksIHIuZW1pdChgdXBkYXRlOiR7ZX1gLCBuLnNldCA/IG4uc2V0KGQpIDogZCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSksIGEgPSBlID09PSBcIm1vZGVsVmFsdWVcIiA/IFwibW9kZWxNb2RpZmllcnNcIiA6IGAke2V9TW9kaWZpZXJzYDtcbiAgcmV0dXJuIG9bU3ltYm9sLml0ZXJhdG9yXSA9ICgpID0+IHtcbiAgICBsZXQgbCA9IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQoKSB7XG4gICAgICAgIHJldHVybiBsIDwgMiA/IHsgdmFsdWU6IGwrKyA/IHRbYV0gfHwge30gOiBvLCBkb25lOiAhMSB9IDogeyBkb25lOiAhMCB9O1xuICAgICAgfVxuICAgIH07XG4gIH0sIG87XG59XG5mdW5jdGlvbiBrdCh0LCBlLCBuKSB7XG4gIGNvbnN0IHIgPSBhcmd1bWVudHMubGVuZ3RoO1xuICByZXR1cm4gciA9PT0gMiA/IFplKGUpICYmICFpZShlKSA/IGxpKGUpID8gSih0LCBudWxsLCBbZV0pIDogSih0LCBlKSA6IEoodCwgbnVsbCwgZSkgOiAociA+IDMgPyBuID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSA6IHIgPT09IDMgJiYgbGkobikgJiYgKG4gPSBbbl0pLCBKKHQsIGUsIG4pKTtcbn1cbmZ1bmN0aW9uIENPKCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiIHx8IHR5cGVvZiB3aW5kb3cgPiBcInVcIilcbiAgICByZXR1cm47XG4gIGNvbnN0IHQgPSB7IHN0eWxlOiBcImNvbG9yOiMzYmE3NzZcIiB9LCBlID0geyBzdHlsZTogXCJjb2xvcjojMTY3N2ZmXCIgfSwgbiA9IHsgc3R5bGU6IFwiY29sb3I6I2Y1MjIyZFwiIH0sIHIgPSB7IHN0eWxlOiBcImNvbG9yOiNlYjJmOTZcIiB9LCBpID0ge1xuICAgIGhlYWRlcihkKSB7XG4gICAgICByZXR1cm4gWmUoZCkgPyBkLl9faXNWdWUgPyBbXCJkaXZcIiwgdCwgXCJWdWVJbnN0YW5jZVwiXSA6IEN0KGQpID8gW1xuICAgICAgICBcImRpdlwiLFxuICAgICAgICB7fSxcbiAgICAgICAgW1wic3BhblwiLCB0LCB1KGQpXSxcbiAgICAgICAgXCI8XCIsXG4gICAgICAgIGEoZC52YWx1ZSksXG4gICAgICAgIFwiPlwiXG4gICAgICBdIDogWWkoZCkgPyBbXG4gICAgICAgIFwiZGl2XCIsXG4gICAgICAgIHt9LFxuICAgICAgICBbXCJzcGFuXCIsIHQsIHppKGQpID8gXCJTaGFsbG93UmVhY3RpdmVcIiA6IFwiUmVhY3RpdmVcIl0sXG4gICAgICAgIFwiPFwiLFxuICAgICAgICBhKGQpLFxuICAgICAgICBgPiR7YWkoZCkgPyBcIiAocmVhZG9ubHkpXCIgOiBcIlwifWBcbiAgICAgIF0gOiBhaShkKSA/IFtcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAge30sXG4gICAgICAgIFtcInNwYW5cIiwgdCwgemkoZCkgPyBcIlNoYWxsb3dSZWFkb25seVwiIDogXCJSZWFkb25seVwiXSxcbiAgICAgICAgXCI8XCIsXG4gICAgICAgIGEoZCksXG4gICAgICAgIFwiPlwiXG4gICAgICBdIDogbnVsbCA6IG51bGw7XG4gICAgfSxcbiAgICBoYXNCb2R5KGQpIHtcbiAgICAgIHJldHVybiBkICYmIGQuX19pc1Z1ZTtcbiAgICB9LFxuICAgIGJvZHkoZCkge1xuICAgICAgaWYgKGQgJiYgZC5fX2lzVnVlKVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAge30sXG4gICAgICAgICAgLi4ucyhkLiQpXG4gICAgICAgIF07XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBzKGQpIHtcbiAgICBjb25zdCBmID0gW107XG4gICAgZC50eXBlLnByb3BzICYmIGQucHJvcHMgJiYgZi5wdXNoKG8oXCJwcm9wc1wiLCBPZShkLnByb3BzKSkpLCBkLnNldHVwU3RhdGUgIT09IFZlICYmIGYucHVzaChvKFwic2V0dXBcIiwgZC5zZXR1cFN0YXRlKSksIGQuZGF0YSAhPT0gVmUgJiYgZi5wdXNoKG8oXCJkYXRhXCIsIE9lKGQuZGF0YSkpKTtcbiAgICBjb25zdCBoID0gbChkLCBcImNvbXB1dGVkXCIpO1xuICAgIGggJiYgZi5wdXNoKG8oXCJjb21wdXRlZFwiLCBoKSk7XG4gICAgY29uc3QgcCA9IGwoZCwgXCJpbmplY3RcIik7XG4gICAgcmV0dXJuIHAgJiYgZi5wdXNoKG8oXCJpbmplY3RlZFwiLCBwKSksIGYucHVzaChbXG4gICAgICBcImRpdlwiLFxuICAgICAge30sXG4gICAgICBbXG4gICAgICAgIFwic3BhblwiLFxuICAgICAgICB7XG4gICAgICAgICAgc3R5bGU6IHIuc3R5bGUgKyBcIjtvcGFjaXR5OjAuNjZcIlxuICAgICAgICB9LFxuICAgICAgICBcIiQgKGludGVybmFsKTogXCJcbiAgICAgIF0sXG4gICAgICBbXCJvYmplY3RcIiwgeyBvYmplY3Q6IGQgfV1cbiAgICBdKSwgZjtcbiAgfVxuICBmdW5jdGlvbiBvKGQsIGYpIHtcbiAgICByZXR1cm4gZiA9ICRlKHt9LCBmKSwgT2JqZWN0LmtleXMoZikubGVuZ3RoID8gW1xuICAgICAgXCJkaXZcIixcbiAgICAgIHsgc3R5bGU6IFwibGluZS1oZWlnaHQ6MS4yNWVtO21hcmdpbi1ib3R0b206MC42ZW1cIiB9LFxuICAgICAgW1xuICAgICAgICBcImRpdlwiLFxuICAgICAgICB7XG4gICAgICAgICAgc3R5bGU6IFwiY29sb3I6IzQ3NjU4MlwiXG4gICAgICAgIH0sXG4gICAgICAgIGRcbiAgICAgIF0sXG4gICAgICBbXG4gICAgICAgIFwiZGl2XCIsXG4gICAgICAgIHtcbiAgICAgICAgICBzdHlsZTogXCJwYWRkaW5nLWxlZnQ6MS4yNWVtXCJcbiAgICAgICAgfSxcbiAgICAgICAgLi4uT2JqZWN0LmtleXMoZikubWFwKChoKSA9PiBbXG4gICAgICAgICAgXCJkaXZcIixcbiAgICAgICAgICB7fSxcbiAgICAgICAgICBbXCJzcGFuXCIsIHIsIGggKyBcIjogXCJdLFxuICAgICAgICAgIGEoZltoXSwgITEpXG4gICAgICAgIF0pXG4gICAgICBdXG4gICAgXSA6IFtcInNwYW5cIiwge31dO1xuICB9XG4gIGZ1bmN0aW9uIGEoZCwgZiA9ICEwKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBkID09IFwibnVtYmVyXCIgPyBbXCJzcGFuXCIsIGUsIGRdIDogdHlwZW9mIGQgPT0gXCJzdHJpbmdcIiA/IFtcInNwYW5cIiwgbiwgSlNPTi5zdHJpbmdpZnkoZCldIDogdHlwZW9mIGQgPT0gXCJib29sZWFuXCIgPyBbXCJzcGFuXCIsIHIsIGRdIDogWmUoZCkgPyBbXCJvYmplY3RcIiwgeyBvYmplY3Q6IGYgPyBPZShkKSA6IGQgfV0gOiBbXCJzcGFuXCIsIG4sIFN0cmluZyhkKV07XG4gIH1cbiAgZnVuY3Rpb24gbChkLCBmKSB7XG4gICAgY29uc3QgaCA9IGQudHlwZTtcbiAgICBpZiAoYmUoaCkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcCA9IHt9O1xuICAgIGZvciAoY29uc3QgTyBpbiBkLmN0eClcbiAgICAgIGMoaCwgTywgZikgJiYgKHBbT10gPSBkLmN0eFtPXSk7XG4gICAgcmV0dXJuIHA7XG4gIH1cbiAgZnVuY3Rpb24gYyhkLCBmLCBoKSB7XG4gICAgY29uc3QgcCA9IGRbaF07XG4gICAgaWYgKGllKHApICYmIHAuaW5jbHVkZXMoZikgfHwgWmUocCkgJiYgZiBpbiBwIHx8IGQuZXh0ZW5kcyAmJiBjKGQuZXh0ZW5kcywgZiwgaCkgfHwgZC5taXhpbnMgJiYgZC5taXhpbnMuc29tZSgoTykgPT4gYyhPLCBmLCBoKSkpXG4gICAgICByZXR1cm4gITA7XG4gIH1cbiAgZnVuY3Rpb24gdShkKSB7XG4gICAgcmV0dXJuIHppKGQpID8gXCJTaGFsbG93UmVmXCIgOiBkLmVmZmVjdCA/IFwiQ29tcHV0ZWRSZWZcIiA6IFwiUmVmXCI7XG4gIH1cbiAgd2luZG93LmRldnRvb2xzRm9ybWF0dGVycyA/IHdpbmRvdy5kZXZ0b29sc0Zvcm1hdHRlcnMucHVzaChpKSA6IHdpbmRvdy5kZXZ0b29sc0Zvcm1hdHRlcnMgPSBbaV07XG59XG5mdW5jdGlvbiBUJCh0LCBlLCBuLCByKSB7XG4gIGNvbnN0IGkgPSBuW3JdO1xuICBpZiAoaSAmJiBMMShpLCB0KSlcbiAgICByZXR1cm4gaTtcbiAgY29uc3QgcyA9IGUoKTtcbiAgcmV0dXJuIHMubWVtbyA9IHQuc2xpY2UoKSwgbltyXSA9IHM7XG59XG5mdW5jdGlvbiBMMSh0LCBlKSB7XG4gIGNvbnN0IG4gPSB0Lm1lbW87XG4gIGlmIChuLmxlbmd0aCAhPSBlLmxlbmd0aClcbiAgICByZXR1cm4gITE7XG4gIGZvciAobGV0IHIgPSAwOyByIDwgbi5sZW5ndGg7IHIrKylcbiAgICBpZiAoZ3IobltyXSwgZVtyXSkpXG4gICAgICByZXR1cm4gITE7XG4gIHJldHVybiBqcyA+IDAgJiYga24gJiYga24ucHVzaCh0KSwgITA7XG59XG5jb25zdCBfaCA9IFwiMy40LjIxXCIsIFh0ID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gSSA6IGl0LCBFJCA9IG1kLCAkJCA9IChwcm9jZXNzLmVudi5OT0RFX0VOViwgYXIpLCBRJCA9IChwcm9jZXNzLmVudi5OT0RFX0VOViwgcE8pLCBDJCA9IHtcbiAgY3JlYXRlQ29tcG9uZW50SW5zdGFuY2U6IFYxLFxuICBzZXR1cENvbXBvbmVudDogVzEsXG4gIHJlbmRlckNvbXBvbmVudFJvb3Q6IEhjLFxuICBzZXRDdXJyZW50UmVuZGVyaW5nSW5zdGFuY2U6IGlsLFxuICBpc1ZOb2RlOiBsaSxcbiAgbm9ybWFsaXplVk5vZGU6IFNuXG59LCBBJCA9IEMkLCBSJCA9IG51bGwsIE4kID0gbnVsbCwgRCQgPSBudWxsO1xuLyoqXG4qIEB2dWUvcnVudGltZS1kb20gdjMuNC4yMVxuKiAoYykgMjAxOC1wcmVzZW50IFl1eGkgKEV2YW4pIFlvdSBhbmQgVnVlIGNvbnRyaWJ1dG9yc1xuKiBAbGljZW5zZSBNSVRcbioqL1xuY29uc3QgWiQgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFYkID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCIsIFJpID0gdHlwZW9mIGRvY3VtZW50IDwgXCJ1XCIgPyBkb2N1bWVudCA6IG51bGwsIEltID0gUmkgJiYgLyogQF9fUFVSRV9fICovIFJpLmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKSwgSSQgPSB7XG4gIGluc2VydDogKHQsIGUsIG4pID0+IHtcbiAgICBlLmluc2VydEJlZm9yZSh0LCBuIHx8IG51bGwpO1xuICB9LFxuICByZW1vdmU6ICh0KSA9PiB7XG4gICAgY29uc3QgZSA9IHQucGFyZW50Tm9kZTtcbiAgICBlICYmIGUucmVtb3ZlQ2hpbGQodCk7XG4gIH0sXG4gIGNyZWF0ZUVsZW1lbnQ6ICh0LCBlLCBuLCByKSA9PiB7XG4gICAgY29uc3QgaSA9IGUgPT09IFwic3ZnXCIgPyBSaS5jcmVhdGVFbGVtZW50TlMoWiQsIHQpIDogZSA9PT0gXCJtYXRobWxcIiA/IFJpLmNyZWF0ZUVsZW1lbnROUyhWJCwgdCkgOiBSaS5jcmVhdGVFbGVtZW50KHQsIG4gPyB7IGlzOiBuIH0gOiB2b2lkIDApO1xuICAgIHJldHVybiB0ID09PSBcInNlbGVjdFwiICYmIHIgJiYgci5tdWx0aXBsZSAhPSBudWxsICYmIGkuc2V0QXR0cmlidXRlKFwibXVsdGlwbGVcIiwgci5tdWx0aXBsZSksIGk7XG4gIH0sXG4gIGNyZWF0ZVRleHQ6ICh0KSA9PiBSaS5jcmVhdGVUZXh0Tm9kZSh0KSxcbiAgY3JlYXRlQ29tbWVudDogKHQpID0+IFJpLmNyZWF0ZUNvbW1lbnQodCksXG4gIHNldFRleHQ6ICh0LCBlKSA9PiB7XG4gICAgdC5ub2RlVmFsdWUgPSBlO1xuICB9LFxuICBzZXRFbGVtZW50VGV4dDogKHQsIGUpID0+IHtcbiAgICB0LnRleHRDb250ZW50ID0gZTtcbiAgfSxcbiAgcGFyZW50Tm9kZTogKHQpID0+IHQucGFyZW50Tm9kZSxcbiAgbmV4dFNpYmxpbmc6ICh0KSA9PiB0Lm5leHRTaWJsaW5nLFxuICBxdWVyeVNlbGVjdG9yOiAodCkgPT4gUmkucXVlcnlTZWxlY3Rvcih0KSxcbiAgc2V0U2NvcGVJZCh0LCBlKSB7XG4gICAgdC5zZXRBdHRyaWJ1dGUoZSwgXCJcIik7XG4gIH0sXG4gIC8vIF9fVU5TQUZFX19cbiAgLy8gUmVhc29uOiBpbm5lckhUTUwuXG4gIC8vIFN0YXRpYyBjb250ZW50IGhlcmUgY2FuIG9ubHkgY29tZSBmcm9tIGNvbXBpbGVkIHRlbXBsYXRlcy5cbiAgLy8gQXMgbG9uZyBhcyB0aGUgdXNlciBvbmx5IHVzZXMgdHJ1c3RlZCB0ZW1wbGF0ZXMsIHRoaXMgaXMgc2FmZS5cbiAgaW5zZXJ0U3RhdGljQ29udGVudCh0LCBlLCBuLCByLCBpLCBzKSB7XG4gICAgY29uc3QgbyA9IG4gPyBuLnByZXZpb3VzU2libGluZyA6IGUubGFzdENoaWxkO1xuICAgIGlmIChpICYmIChpID09PSBzIHx8IGkubmV4dFNpYmxpbmcpKVxuICAgICAgZm9yICg7IGUuaW5zZXJ0QmVmb3JlKGkuY2xvbmVOb2RlKCEwKSwgbiksICEoaSA9PT0gcyB8fCAhKGkgPSBpLm5leHRTaWJsaW5nKSk7IClcbiAgICAgICAgO1xuICAgIGVsc2Uge1xuICAgICAgSW0uaW5uZXJIVE1MID0gciA9PT0gXCJzdmdcIiA/IGA8c3ZnPiR7dH08L3N2Zz5gIDogciA9PT0gXCJtYXRobWxcIiA/IGA8bWF0aD4ke3R9PC9tYXRoPmAgOiB0O1xuICAgICAgY29uc3QgYSA9IEltLmNvbnRlbnQ7XG4gICAgICBpZiAociA9PT0gXCJzdmdcIiB8fCByID09PSBcIm1hdGhtbFwiKSB7XG4gICAgICAgIGNvbnN0IGwgPSBhLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGZvciAoOyBsLmZpcnN0Q2hpbGQ7IClcbiAgICAgICAgICBhLmFwcGVuZENoaWxkKGwuZmlyc3RDaGlsZCk7XG4gICAgICAgIGEucmVtb3ZlQ2hpbGQobCk7XG4gICAgICB9XG4gICAgICBlLmluc2VydEJlZm9yZShhLCBuKTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgIC8vIGZpcnN0XG4gICAgICBvID8gby5uZXh0U2libGluZyA6IGUuZmlyc3RDaGlsZCxcbiAgICAgIC8vIGxhc3RcbiAgICAgIG4gPyBuLnByZXZpb3VzU2libGluZyA6IGUubGFzdENoaWxkXG4gICAgXTtcbiAgfVxufSwgd2kgPSBcInRyYW5zaXRpb25cIiwgZmEgPSBcImFuaW1hdGlvblwiLCBObyA9IFN5bWJvbChcIl92dGNcIiksIEFPID0gKHQsIHsgc2xvdHM6IGUgfSkgPT4ga3QoczEsIHExKHQpLCBlKTtcbkFPLmRpc3BsYXlOYW1lID0gXCJUcmFuc2l0aW9uXCI7XG5jb25zdCBVMSA9IHtcbiAgbmFtZTogU3RyaW5nLFxuICB0eXBlOiBTdHJpbmcsXG4gIGNzczoge1xuICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgZGVmYXVsdDogITBcbiAgfSxcbiAgZHVyYXRpb246IFtTdHJpbmcsIE51bWJlciwgT2JqZWN0XSxcbiAgZW50ZXJGcm9tQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBlbnRlclRvQ2xhc3M6IFN0cmluZyxcbiAgYXBwZWFyRnJvbUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhclRvQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVGcm9tQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxuICBsZWF2ZVRvQ2xhc3M6IFN0cmluZ1xufSwgVyQgPSBBTy5wcm9wcyA9IC8qIEBfX1BVUkVfXyAqLyAkZShcbiAge30sXG4gIHdPLFxuICBVMVxuKSwgZ3MgPSAodCwgZSA9IFtdKSA9PiB7XG4gIGllKHQpID8gdC5mb3JFYWNoKChuKSA9PiBuKC4uLmUpKSA6IHQgJiYgdCguLi5lKTtcbn0sIFdtID0gKHQpID0+IHQgPyBpZSh0KSA/IHQuc29tZSgoZSkgPT4gZS5sZW5ndGggPiAxKSA6IHQubGVuZ3RoID4gMSA6ICExO1xuZnVuY3Rpb24gcTEodCkge1xuICBjb25zdCBlID0ge307XG4gIGZvciAoY29uc3QgUSBpbiB0KVxuICAgIFEgaW4gVTEgfHwgKGVbUV0gPSB0W1FdKTtcbiAgaWYgKHQuY3NzID09PSAhMSlcbiAgICByZXR1cm4gZTtcbiAgY29uc3Qge1xuICAgIG5hbWU6IG4gPSBcInZcIixcbiAgICB0eXBlOiByLFxuICAgIGR1cmF0aW9uOiBpLFxuICAgIGVudGVyRnJvbUNsYXNzOiBzID0gYCR7bn0tZW50ZXItZnJvbWAsXG4gICAgZW50ZXJBY3RpdmVDbGFzczogbyA9IGAke259LWVudGVyLWFjdGl2ZWAsXG4gICAgZW50ZXJUb0NsYXNzOiBhID0gYCR7bn0tZW50ZXItdG9gLFxuICAgIGFwcGVhckZyb21DbGFzczogbCA9IHMsXG4gICAgYXBwZWFyQWN0aXZlQ2xhc3M6IGMgPSBvLFxuICAgIGFwcGVhclRvQ2xhc3M6IHUgPSBhLFxuICAgIGxlYXZlRnJvbUNsYXNzOiBkID0gYCR7bn0tbGVhdmUtZnJvbWAsXG4gICAgbGVhdmVBY3RpdmVDbGFzczogZiA9IGAke259LWxlYXZlLWFjdGl2ZWAsXG4gICAgbGVhdmVUb0NsYXNzOiBoID0gYCR7bn0tbGVhdmUtdG9gXG4gIH0gPSB0LCBwID0gTSQoaSksIE8gPSBwICYmIHBbMF0sIG0gPSBwICYmIHBbMV0sIHtcbiAgICBvbkJlZm9yZUVudGVyOiB5LFxuICAgIG9uRW50ZXI6IGIsXG4gICAgb25FbnRlckNhbmNlbGxlZDogZyxcbiAgICBvbkxlYXZlOiB2LFxuICAgIG9uTGVhdmVDYW5jZWxsZWQ6IFMsXG4gICAgb25CZWZvcmVBcHBlYXI6IHcgPSB5LFxuICAgIG9uQXBwZWFyOiBrID0gYixcbiAgICBvbkFwcGVhckNhbmNlbGxlZDogXyA9IGdcbiAgfSA9IGUsIFQgPSAoUSwgVywgTCkgPT4ge1xuICAgICRpKFEsIFcgPyB1IDogYSksICRpKFEsIFcgPyBjIDogbyksIEwgJiYgTCgpO1xuICB9LCBDID0gKFEsIFcpID0+IHtcbiAgICBRLl9pc0xlYXZpbmcgPSAhMSwgJGkoUSwgZCksICRpKFEsIGgpLCAkaShRLCBmKSwgVyAmJiBXKCk7XG4gIH0sIEEgPSAoUSkgPT4gKFcsIEwpID0+IHtcbiAgICBjb25zdCByZSA9IFEgPyBrIDogYiwgWSA9ICgpID0+IFQoVywgUSwgTCk7XG4gICAgZ3MocmUsIFtXLCBZXSksIE1tKCgpID0+IHtcbiAgICAgICRpKFcsIFEgPyBsIDogcyksIEtyKFcsIFEgPyB1IDogYSksIFdtKHJlKSB8fCBYbShXLCByLCBPLCBZKTtcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuICRlKGUsIHtcbiAgICBvbkJlZm9yZUVudGVyKFEpIHtcbiAgICAgIGdzKHksIFtRXSksIEtyKFEsIHMpLCBLcihRLCBvKTtcbiAgICB9LFxuICAgIG9uQmVmb3JlQXBwZWFyKFEpIHtcbiAgICAgIGdzKHcsIFtRXSksIEtyKFEsIGwpLCBLcihRLCBjKTtcbiAgICB9LFxuICAgIG9uRW50ZXI6IEEoITEpLFxuICAgIG9uQXBwZWFyOiBBKCEwKSxcbiAgICBvbkxlYXZlKFEsIFcpIHtcbiAgICAgIFEuX2lzTGVhdmluZyA9ICEwO1xuICAgICAgY29uc3QgTCA9ICgpID0+IEMoUSwgVyk7XG4gICAgICBLcihRLCBkKSwgejEoKSwgS3IoUSwgZiksIE1tKCgpID0+IHtcbiAgICAgICAgUS5faXNMZWF2aW5nICYmICgkaShRLCBkKSwgS3IoUSwgaCksIFdtKHYpIHx8IFhtKFEsIHIsIG0sIEwpKTtcbiAgICAgIH0pLCBncyh2LCBbUSwgTF0pO1xuICAgIH0sXG4gICAgb25FbnRlckNhbmNlbGxlZChRKSB7XG4gICAgICBUKFEsICExKSwgZ3MoZywgW1FdKTtcbiAgICB9LFxuICAgIG9uQXBwZWFyQ2FuY2VsbGVkKFEpIHtcbiAgICAgIFQoUSwgITApLCBncyhfLCBbUV0pO1xuICAgIH0sXG4gICAgb25MZWF2ZUNhbmNlbGxlZChRKSB7XG4gICAgICBDKFEpLCBncyhTLCBbUV0pO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBNJCh0KSB7XG4gIGlmICh0ID09IG51bGwpXG4gICAgcmV0dXJuIG51bGw7XG4gIGlmIChaZSh0KSlcbiAgICByZXR1cm4gW2hmKHQuZW50ZXIpLCBoZih0LmxlYXZlKV07XG4gIHtcbiAgICBjb25zdCBlID0gaGYodCk7XG4gICAgcmV0dXJuIFtlLCBlXTtcbiAgfVxufVxuZnVuY3Rpb24gaGYodCkge1xuICBjb25zdCBlID0gdnUodCk7XG4gIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZE8oZSwgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgZHVyYXRpb25cIiksIGU7XG59XG5mdW5jdGlvbiBLcih0LCBlKSB7XG4gIGUuc3BsaXQoL1xccysvKS5mb3JFYWNoKChuKSA9PiBuICYmIHQuY2xhc3NMaXN0LmFkZChuKSksICh0W05vXSB8fCAodFtOb10gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKSkuYWRkKGUpO1xufVxuZnVuY3Rpb24gJGkodCwgZSkge1xuICBlLnNwbGl0KC9cXHMrLykuZm9yRWFjaCgocikgPT4gciAmJiB0LmNsYXNzTGlzdC5yZW1vdmUocikpO1xuICBjb25zdCBuID0gdFtOb107XG4gIG4gJiYgKG4uZGVsZXRlKGUpLCBuLnNpemUgfHwgKHRbTm9dID0gdm9pZCAwKSk7XG59XG5mdW5jdGlvbiBNbSh0KSB7XG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHQpO1xuICB9KTtcbn1cbmxldCBYJCA9IDA7XG5mdW5jdGlvbiBYbSh0LCBlLCBuLCByKSB7XG4gIGNvbnN0IGkgPSB0Ll9lbmRJZCA9ICsrWCQsIHMgPSAoKSA9PiB7XG4gICAgaSA9PT0gdC5fZW5kSWQgJiYgcigpO1xuICB9O1xuICBpZiAobilcbiAgICByZXR1cm4gc2V0VGltZW91dChzLCBuKTtcbiAgY29uc3QgeyB0eXBlOiBvLCB0aW1lb3V0OiBhLCBwcm9wQ291bnQ6IGwgfSA9IFkxKHQsIGUpO1xuICBpZiAoIW8pXG4gICAgcmV0dXJuIHIoKTtcbiAgY29uc3QgYyA9IG8gKyBcImVuZFwiO1xuICBsZXQgdSA9IDA7XG4gIGNvbnN0IGQgPSAoKSA9PiB7XG4gICAgdC5yZW1vdmVFdmVudExpc3RlbmVyKGMsIGYpLCBzKCk7XG4gIH0sIGYgPSAoaCkgPT4ge1xuICAgIGgudGFyZ2V0ID09PSB0ICYmICsrdSA+PSBsICYmIGQoKTtcbiAgfTtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgdSA8IGwgJiYgZCgpO1xuICB9LCBhICsgMSksIHQuYWRkRXZlbnRMaXN0ZW5lcihjLCBmKTtcbn1cbmZ1bmN0aW9uIFkxKHQsIGUpIHtcbiAgY29uc3QgbiA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHQpLCByID0gKHApID0+IChuW3BdIHx8IFwiXCIpLnNwbGl0KFwiLCBcIiksIGkgPSByKGAke3dpfURlbGF5YCksIHMgPSByKGAke3dpfUR1cmF0aW9uYCksIG8gPSBqbShpLCBzKSwgYSA9IHIoYCR7ZmF9RGVsYXlgKSwgbCA9IHIoYCR7ZmF9RHVyYXRpb25gKSwgYyA9IGptKGEsIGwpO1xuICBsZXQgdSA9IG51bGwsIGQgPSAwLCBmID0gMDtcbiAgZSA9PT0gd2kgPyBvID4gMCAmJiAodSA9IHdpLCBkID0gbywgZiA9IHMubGVuZ3RoKSA6IGUgPT09IGZhID8gYyA+IDAgJiYgKHUgPSBmYSwgZCA9IGMsIGYgPSBsLmxlbmd0aCkgOiAoZCA9IE1hdGgubWF4KG8sIGMpLCB1ID0gZCA+IDAgPyBvID4gYyA/IHdpIDogZmEgOiBudWxsLCBmID0gdSA/IHUgPT09IHdpID8gcy5sZW5ndGggOiBsLmxlbmd0aCA6IDApO1xuICBjb25zdCBoID0gdSA9PT0gd2kgJiYgL1xcYih0cmFuc2Zvcm18YWxsKSgsfCQpLy50ZXN0KFxuICAgIHIoYCR7d2l9UHJvcGVydHlgKS50b1N0cmluZygpXG4gICk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogdSxcbiAgICB0aW1lb3V0OiBkLFxuICAgIHByb3BDb3VudDogZixcbiAgICBoYXNUcmFuc2Zvcm06IGhcbiAgfTtcbn1cbmZ1bmN0aW9uIGptKHQsIGUpIHtcbiAgZm9yICg7IHQubGVuZ3RoIDwgZS5sZW5ndGg7IClcbiAgICB0ID0gdC5jb25jYXQodCk7XG4gIHJldHVybiBNYXRoLm1heCguLi5lLm1hcCgobiwgcikgPT4gQm0obikgKyBCbSh0W3JdKSkpO1xufVxuZnVuY3Rpb24gQm0odCkge1xuICByZXR1cm4gdCA9PT0gXCJhdXRvXCIgPyAwIDogTnVtYmVyKHQuc2xpY2UoMCwgLTEpLnJlcGxhY2UoXCIsXCIsIFwiLlwiKSkgKiAxZTM7XG59XG5mdW5jdGlvbiB6MSgpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmJvZHkub2Zmc2V0SGVpZ2h0O1xufVxuZnVuY3Rpb24gaiQodCwgZSwgbikge1xuICBjb25zdCByID0gdFtOb107XG4gIHIgJiYgKGUgPSAoZSA/IFtlLCAuLi5yXSA6IFsuLi5yXSkuam9pbihcIiBcIikpLCBlID09IG51bGwgPyB0LnJlbW92ZUF0dHJpYnV0ZShcImNsYXNzXCIpIDogbiA/IHQuc2V0QXR0cmlidXRlKFwiY2xhc3NcIiwgZSkgOiB0LmNsYXNzTmFtZSA9IGU7XG59XG5jb25zdCBFdSA9IFN5bWJvbChcIl92b2RcIiksIEgxID0gU3ltYm9sKFwiX3ZzaFwiKSwgamwgPSB7XG4gIGJlZm9yZU1vdW50KHQsIHsgdmFsdWU6IGUgfSwgeyB0cmFuc2l0aW9uOiBuIH0pIHtcbiAgICB0W0V1XSA9IHQuc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgPyBcIlwiIDogdC5zdHlsZS5kaXNwbGF5LCBuICYmIGUgPyBuLmJlZm9yZUVudGVyKHQpIDogaGEodCwgZSk7XG4gIH0sXG4gIG1vdW50ZWQodCwgeyB2YWx1ZTogZSB9LCB7IHRyYW5zaXRpb246IG4gfSkge1xuICAgIG4gJiYgZSAmJiBuLmVudGVyKHQpO1xuICB9LFxuICB1cGRhdGVkKHQsIHsgdmFsdWU6IGUsIG9sZFZhbHVlOiBuIH0sIHsgdHJhbnNpdGlvbjogciB9KSB7XG4gICAgIWUgIT0gIW4gJiYgKHIgPyBlID8gKHIuYmVmb3JlRW50ZXIodCksIGhhKHQsICEwKSwgci5lbnRlcih0KSkgOiByLmxlYXZlKHQsICgpID0+IHtcbiAgICAgIGhhKHQsICExKTtcbiAgICB9KSA6IGhhKHQsIGUpKTtcbiAgfSxcbiAgYmVmb3JlVW5tb3VudCh0LCB7IHZhbHVlOiBlIH0pIHtcbiAgICBoYSh0LCBlKTtcbiAgfVxufTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAoamwubmFtZSA9IFwic2hvd1wiKTtcbmZ1bmN0aW9uIGhhKHQsIGUpIHtcbiAgdC5zdHlsZS5kaXNwbGF5ID0gZSA/IHRbRXVdIDogXCJub25lXCIsIHRbSDFdID0gIWU7XG59XG5mdW5jdGlvbiBCJCgpIHtcbiAgamwuZ2V0U1NSUHJvcHMgPSAoeyB2YWx1ZTogdCB9KSA9PiB7XG4gICAgaWYgKCF0KVxuICAgICAgcmV0dXJuIHsgc3R5bGU6IHsgZGlzcGxheTogXCJub25lXCIgfSB9O1xuICB9O1xufVxuY29uc3QgRjEgPSBTeW1ib2wocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJDU1NfVkFSX1RFWFRcIiA6IFwiXCIpO1xuZnVuY3Rpb24gRzEodCkge1xuICBjb25zdCBlID0gaXIoKTtcbiAgaWYgKCFlKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIFh0KFwidXNlQ3NzVmFycyBpcyBjYWxsZWQgd2l0aG91dCBjdXJyZW50IGFjdGl2ZSBjb21wb25lbnQgaW5zdGFuY2UuXCIpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBuID0gZS51dCA9IChpID0gdChlLnByb3h5KSkgPT4ge1xuICAgIEFycmF5LmZyb20oXG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGBbZGF0YS12LW93bmVyPVwiJHtlLnVpZH1cIl1gKVxuICAgICkuZm9yRWFjaCgocykgPT4gRWgocywgaSkpO1xuICB9O1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgKGUuZ2V0Q3NzVmFycyA9ICgpID0+IHQoZS5wcm94eSkpO1xuICBjb25zdCByID0gKCkgPT4ge1xuICAgIGNvbnN0IGkgPSB0KGUucHJveHkpO1xuICAgIFRoKGUuc3ViVHJlZSwgaSksIG4oaSk7XG4gIH07XG4gIHQxKHIpLCBldCgoKSA9PiB7XG4gICAgY29uc3QgaSA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHIpO1xuICAgIGkub2JzZXJ2ZShlLnN1YlRyZWUuZWwucGFyZW50Tm9kZSwgeyBjaGlsZExpc3Q6ICEwIH0pLCBqdCgoKSA9PiBpLmRpc2Nvbm5lY3QoKSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gVGgodCwgZSkge1xuICBpZiAodC5zaGFwZUZsYWcgJiAxMjgpIHtcbiAgICBjb25zdCBuID0gdC5zdXNwZW5zZTtcbiAgICB0ID0gbi5hY3RpdmVCcmFuY2gsIG4ucGVuZGluZ0JyYW5jaCAmJiAhbi5pc0h5ZHJhdGluZyAmJiBuLmVmZmVjdHMucHVzaCgoKSA9PiB7XG4gICAgICBUaChuLmFjdGl2ZUJyYW5jaCwgZSk7XG4gICAgfSk7XG4gIH1cbiAgZm9yICg7IHQuY29tcG9uZW50OyApXG4gICAgdCA9IHQuY29tcG9uZW50LnN1YlRyZWU7XG4gIGlmICh0LnNoYXBlRmxhZyAmIDEgJiYgdC5lbClcbiAgICBFaCh0LmVsLCBlKTtcbiAgZWxzZSBpZiAodC50eXBlID09PSBQZSlcbiAgICB0LmNoaWxkcmVuLmZvckVhY2goKG4pID0+IFRoKG4sIGUpKTtcbiAgZWxzZSBpZiAodC50eXBlID09PSBGaSkge1xuICAgIGxldCB7IGVsOiBuLCBhbmNob3I6IHIgfSA9IHQ7XG4gICAgZm9yICg7IG4gJiYgKEVoKG4sIGUpLCBuICE9PSByKTsgKVxuICAgICAgbiA9IG4ubmV4dFNpYmxpbmc7XG4gIH1cbn1cbmZ1bmN0aW9uIEVoKHQsIGUpIHtcbiAgaWYgKHQubm9kZVR5cGUgPT09IDEpIHtcbiAgICBjb25zdCBuID0gdC5zdHlsZTtcbiAgICBsZXQgciA9IFwiXCI7XG4gICAgZm9yIChjb25zdCBpIGluIGUpXG4gICAgICBuLnNldFByb3BlcnR5KGAtLSR7aX1gLCBlW2ldKSwgciArPSBgLS0ke2l9OiAke2VbaV19O2A7XG4gICAgbltGMV0gPSByO1xuICB9XG59XG5jb25zdCBMJCA9IC8oXnw7KVxccypkaXNwbGF5XFxzKjovO1xuZnVuY3Rpb24gVSQodCwgZSwgbikge1xuICBjb25zdCByID0gdC5zdHlsZSwgaSA9IHdlKG4pO1xuICBsZXQgcyA9ICExO1xuICBpZiAobiAmJiAhaSkge1xuICAgIGlmIChlKVxuICAgICAgaWYgKHdlKGUpKVxuICAgICAgICBmb3IgKGNvbnN0IG8gb2YgZS5zcGxpdChcIjtcIikpIHtcbiAgICAgICAgICBjb25zdCBhID0gby5zbGljZSgwLCBvLmluZGV4T2YoXCI6XCIpKS50cmltKCk7XG4gICAgICAgICAgblthXSA9PSBudWxsICYmIEdjKHIsIGEsIFwiXCIpO1xuICAgICAgICB9XG4gICAgICBlbHNlXG4gICAgICAgIGZvciAoY29uc3QgbyBpbiBlKVxuICAgICAgICAgIG5bb10gPT0gbnVsbCAmJiBHYyhyLCBvLCBcIlwiKTtcbiAgICBmb3IgKGNvbnN0IG8gaW4gbilcbiAgICAgIG8gPT09IFwiZGlzcGxheVwiICYmIChzID0gITApLCBHYyhyLCBvLCBuW29dKTtcbiAgfSBlbHNlIGlmIChpKSB7XG4gICAgaWYgKGUgIT09IG4pIHtcbiAgICAgIGNvbnN0IG8gPSByW0YxXTtcbiAgICAgIG8gJiYgKG4gKz0gXCI7XCIgKyBvKSwgci5jc3NUZXh0ID0gbiwgcyA9IEwkLnRlc3Qobik7XG4gICAgfVxuICB9IGVsc2VcbiAgICBlICYmIHQucmVtb3ZlQXR0cmlidXRlKFwic3R5bGVcIik7XG4gIEV1IGluIHQgJiYgKHRbRXVdID0gcyA/IHIuZGlzcGxheSA6IFwiXCIsIHRbSDFdICYmIChyLmRpc3BsYXkgPSBcIm5vbmVcIikpO1xufVxuY29uc3QgcSQgPSAvW15cXFxcXTtcXHMqJC8sIExtID0gL1xccyohaW1wb3J0YW50JC87XG5mdW5jdGlvbiBHYyh0LCBlLCBuKSB7XG4gIGlmIChpZShuKSlcbiAgICBuLmZvckVhY2goKHIpID0+IEdjKHQsIGUsIHIpKTtcbiAgZWxzZSBpZiAobiA9PSBudWxsICYmIChuID0gXCJcIiksIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBxJC50ZXN0KG4pICYmIFh0KFxuICAgIGBVbmV4cGVjdGVkIHNlbWljb2xvbiBhdCB0aGUgZW5kIG9mICcke2V9JyBzdHlsZSB2YWx1ZTogJyR7bn0nYFxuICApLCBlLnN0YXJ0c1dpdGgoXCItLVwiKSlcbiAgICB0LnNldFByb3BlcnR5KGUsIG4pO1xuICBlbHNlIHtcbiAgICBjb25zdCByID0gWSQodCwgZSk7XG4gICAgTG0udGVzdChuKSA/IHQuc2V0UHJvcGVydHkoXG4gICAgICBybihyKSxcbiAgICAgIG4ucmVwbGFjZShMbSwgXCJcIiksXG4gICAgICBcImltcG9ydGFudFwiXG4gICAgKSA6IHRbcl0gPSBuO1xuICB9XG59XG5jb25zdCBVbSA9IFtcIldlYmtpdFwiLCBcIk1velwiLCBcIm1zXCJdLCBwZiA9IHt9O1xuZnVuY3Rpb24gWSQodCwgZSkge1xuICBjb25zdCBuID0gcGZbZV07XG4gIGlmIChuKVxuICAgIHJldHVybiBuO1xuICBsZXQgciA9IG10KGUpO1xuICBpZiAociAhPT0gXCJmaWx0ZXJcIiAmJiByIGluIHQpXG4gICAgcmV0dXJuIHBmW2VdID0gcjtcbiAgciA9IFdyKHIpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IFVtLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcyA9IFVtW2ldICsgcjtcbiAgICBpZiAocyBpbiB0KVxuICAgICAgcmV0dXJuIHBmW2VdID0gcztcbiAgfVxuICByZXR1cm4gZTtcbn1cbmNvbnN0IHFtID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCI7XG5mdW5jdGlvbiB6JCh0LCBlLCBuLCByLCBpKSB7XG4gIGlmIChyICYmIGUuc3RhcnRzV2l0aChcInhsaW5rOlwiKSlcbiAgICBuID09IG51bGwgPyB0LnJlbW92ZUF0dHJpYnV0ZU5TKHFtLCBlLnNsaWNlKDYsIGUubGVuZ3RoKSkgOiB0LnNldEF0dHJpYnV0ZU5TKHFtLCBlLCBuKTtcbiAgZWxzZSB7XG4gICAgY29uc3QgcyA9IEZfKGUpO1xuICAgIG4gPT0gbnVsbCB8fCBzICYmICFKcChuKSA/IHQucmVtb3ZlQXR0cmlidXRlKGUpIDogdC5zZXRBdHRyaWJ1dGUoZSwgcyA/IFwiXCIgOiBuKTtcbiAgfVxufVxuZnVuY3Rpb24gSCQodCwgZSwgbiwgciwgaSwgcywgbykge1xuICBpZiAoZSA9PT0gXCJpbm5lckhUTUxcIiB8fCBlID09PSBcInRleHRDb250ZW50XCIpIHtcbiAgICByICYmIG8ociwgaSwgcyksIHRbZV0gPSBuID8/IFwiXCI7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGEgPSB0LnRhZ05hbWU7XG4gIGlmIChlID09PSBcInZhbHVlXCIgJiYgYSAhPT0gXCJQUk9HUkVTU1wiICYmIC8vIGN1c3RvbSBlbGVtZW50cyBtYXkgdXNlIF92YWx1ZSBpbnRlcm5hbGx5XG4gICFhLmluY2x1ZGVzKFwiLVwiKSkge1xuICAgIGNvbnN0IGMgPSBhID09PSBcIk9QVElPTlwiID8gdC5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSB8fCBcIlwiIDogdC52YWx1ZSwgdSA9IG4gPz8gXCJcIjtcbiAgICAoYyAhPT0gdSB8fCAhKFwiX3ZhbHVlXCIgaW4gdCkpICYmICh0LnZhbHVlID0gdSksIG4gPT0gbnVsbCAmJiB0LnJlbW92ZUF0dHJpYnV0ZShlKSwgdC5fdmFsdWUgPSBuO1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgbCA9ICExO1xuICBpZiAobiA9PT0gXCJcIiB8fCBuID09IG51bGwpIHtcbiAgICBjb25zdCBjID0gdHlwZW9mIHRbZV07XG4gICAgYyA9PT0gXCJib29sZWFuXCIgPyBuID0gSnAobikgOiBuID09IG51bGwgJiYgYyA9PT0gXCJzdHJpbmdcIiA/IChuID0gXCJcIiwgbCA9ICEwKSA6IGMgPT09IFwibnVtYmVyXCIgJiYgKG4gPSAwLCBsID0gITApO1xuICB9XG4gIHRyeSB7XG4gICAgdFtlXSA9IG47XG4gIH0gY2F0Y2ggKGMpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIWwgJiYgWHQoXG4gICAgICBgRmFpbGVkIHNldHRpbmcgcHJvcCBcIiR7ZX1cIiBvbiA8JHthLnRvTG93ZXJDYXNlKCl9PjogdmFsdWUgJHtufSBpcyBpbnZhbGlkLmAsXG4gICAgICBjXG4gICAgKTtcbiAgfVxuICBsICYmIHQucmVtb3ZlQXR0cmlidXRlKGUpO1xufVxuZnVuY3Rpb24gbmkodCwgZSwgbiwgcikge1xuICB0LmFkZEV2ZW50TGlzdGVuZXIoZSwgbiwgcik7XG59XG5mdW5jdGlvbiBGJCh0LCBlLCBuLCByKSB7XG4gIHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLCBuLCByKTtcbn1cbmNvbnN0IFltID0gU3ltYm9sKFwiX3ZlaVwiKTtcbmZ1bmN0aW9uIEckKHQsIGUsIG4sIHIsIGkgPSBudWxsKSB7XG4gIGNvbnN0IHMgPSB0W1ltXSB8fCAodFtZbV0gPSB7fSksIG8gPSBzW2VdO1xuICBpZiAociAmJiBvKVxuICAgIG8udmFsdWUgPSByO1xuICBlbHNlIHtcbiAgICBjb25zdCBbYSwgbF0gPSBLJChlKTtcbiAgICBpZiAocikge1xuICAgICAgY29uc3QgYyA9IHNbZV0gPSB0UShyLCBpKTtcbiAgICAgIG5pKHQsIGEsIGMsIGwpO1xuICAgIH0gZWxzZVxuICAgICAgbyAmJiAoRiQodCwgYSwgbywgbCksIHNbZV0gPSB2b2lkIDApO1xuICB9XG59XG5jb25zdCB6bSA9IC8oPzpPbmNlfFBhc3NpdmV8Q2FwdHVyZSkkLztcbmZ1bmN0aW9uIEskKHQpIHtcbiAgbGV0IGU7XG4gIGlmICh6bS50ZXN0KHQpKSB7XG4gICAgZSA9IHt9O1xuICAgIGxldCByO1xuICAgIGZvciAoOyByID0gdC5tYXRjaCh6bSk7IClcbiAgICAgIHQgPSB0LnNsaWNlKDAsIHQubGVuZ3RoIC0gclswXS5sZW5ndGgpLCBlW3JbMF0udG9Mb3dlckNhc2UoKV0gPSAhMDtcbiAgfVxuICByZXR1cm4gW3RbMl0gPT09IFwiOlwiID8gdC5zbGljZSgzKSA6IHJuKHQuc2xpY2UoMikpLCBlXTtcbn1cbmxldCBPZiA9IDA7XG5jb25zdCBKJCA9IC8qIEBfX1BVUkVfXyAqLyBQcm9taXNlLnJlc29sdmUoKSwgZVEgPSAoKSA9PiBPZiB8fCAoSiQudGhlbigoKSA9PiBPZiA9IDApLCBPZiA9IERhdGUubm93KCkpO1xuZnVuY3Rpb24gdFEodCwgZSkge1xuICBjb25zdCBuID0gKHIpID0+IHtcbiAgICBpZiAoIXIuX3Z0cylcbiAgICAgIHIuX3Z0cyA9IERhdGUubm93KCk7XG4gICAgZWxzZSBpZiAoci5fdnRzIDw9IG4uYXR0YWNoZWQpXG4gICAgICByZXR1cm47XG4gICAgV24oXG4gICAgICBuUShyLCBuLnZhbHVlKSxcbiAgICAgIGUsXG4gICAgICA1LFxuICAgICAgW3JdXG4gICAgKTtcbiAgfTtcbiAgcmV0dXJuIG4udmFsdWUgPSB0LCBuLmF0dGFjaGVkID0gZVEoKSwgbjtcbn1cbmZ1bmN0aW9uIG5RKHQsIGUpIHtcbiAgaWYgKGllKGUpKSB7XG4gICAgY29uc3QgbiA9IHQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uO1xuICAgIHJldHVybiB0LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9ICgpID0+IHtcbiAgICAgIG4uY2FsbCh0KSwgdC5fc3RvcHBlZCA9ICEwO1xuICAgIH0sIGUubWFwKChyKSA9PiAoaSkgPT4gIWkuX3N0b3BwZWQgJiYgciAmJiByKGkpKTtcbiAgfSBlbHNlXG4gICAgcmV0dXJuIGU7XG59XG5jb25zdCBIbSA9ICh0KSA9PiB0LmNoYXJDb2RlQXQoMCkgPT09IDExMSAmJiB0LmNoYXJDb2RlQXQoMSkgPT09IDExMCAmJiAvLyBsb3dlcmNhc2UgbGV0dGVyXG50LmNoYXJDb2RlQXQoMikgPiA5NiAmJiB0LmNoYXJDb2RlQXQoMikgPCAxMjMsIHJRID0gKHQsIGUsIG4sIHIsIGksIHMsIG8sIGEsIGwpID0+IHtcbiAgY29uc3QgYyA9IGkgPT09IFwic3ZnXCI7XG4gIGUgPT09IFwiY2xhc3NcIiA/IGokKHQsIHIsIGMpIDogZSA9PT0gXCJzdHlsZVwiID8gVSQodCwgbiwgcikgOiBvaShlKSA/IG11KGUpIHx8IEckKHQsIGUsIG4sIHIsIG8pIDogKGVbMF0gPT09IFwiLlwiID8gKGUgPSBlLnNsaWNlKDEpLCAhMCkgOiBlWzBdID09PSBcIl5cIiA/IChlID0gZS5zbGljZSgxKSwgITEpIDogaVEodCwgZSwgciwgYykpID8gSCQoXG4gICAgdCxcbiAgICBlLFxuICAgIHIsXG4gICAgcyxcbiAgICBvLFxuICAgIGEsXG4gICAgbFxuICApIDogKGUgPT09IFwidHJ1ZS12YWx1ZVwiID8gdC5fdHJ1ZVZhbHVlID0gciA6IGUgPT09IFwiZmFsc2UtdmFsdWVcIiAmJiAodC5fZmFsc2VWYWx1ZSA9IHIpLCB6JCh0LCBlLCByLCBjKSk7XG59O1xuZnVuY3Rpb24gaVEodCwgZSwgbiwgcikge1xuICBpZiAocilcbiAgICByZXR1cm4gISEoZSA9PT0gXCJpbm5lckhUTUxcIiB8fCBlID09PSBcInRleHRDb250ZW50XCIgfHwgZSBpbiB0ICYmIEhtKGUpICYmIGJlKG4pKTtcbiAgaWYgKGUgPT09IFwic3BlbGxjaGVja1wiIHx8IGUgPT09IFwiZHJhZ2dhYmxlXCIgfHwgZSA9PT0gXCJ0cmFuc2xhdGVcIiB8fCBlID09PSBcImZvcm1cIiB8fCBlID09PSBcImxpc3RcIiAmJiB0LnRhZ05hbWUgPT09IFwiSU5QVVRcIiB8fCBlID09PSBcInR5cGVcIiAmJiB0LnRhZ05hbWUgPT09IFwiVEVYVEFSRUFcIilcbiAgICByZXR1cm4gITE7XG4gIGlmIChlID09PSBcIndpZHRoXCIgfHwgZSA9PT0gXCJoZWlnaHRcIikge1xuICAgIGNvbnN0IGkgPSB0LnRhZ05hbWU7XG4gICAgaWYgKGkgPT09IFwiSU1HXCIgfHwgaSA9PT0gXCJWSURFT1wiIHx8IGkgPT09IFwiQ0FOVkFTXCIgfHwgaSA9PT0gXCJTT1VSQ0VcIilcbiAgICAgIHJldHVybiAhMTtcbiAgfVxuICByZXR1cm4gSG0oZSkgJiYgd2UobikgPyAhMSA6IGUgaW4gdDtcbn1cbi8qISAjX19OT19TSURFX0VGRkVDVFNfXyAqL1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmZ1bmN0aW9uIEsxKHQsIGUpIHtcbiAgY29uc3QgbiA9IC8qIEBfX1BVUkVfXyAqLyBsZSh0KTtcbiAgY2xhc3MgciBleHRlbmRzIEVkIHtcbiAgICBjb25zdHJ1Y3RvcihzKSB7XG4gICAgICBzdXBlcihuLCBzLCBlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHIuZGVmID0gbiwgcjtcbn1cbi8qISAjX19OT19TSURFX0VGRkVDVFNfXyAqL1xuY29uc3Qgc1EgPSAvKiBAX19OT19TSURFX0VGRkVDVFNfXyAqLyAodCkgPT4gLyogQF9fUFVSRV9fICovIEsxKHQsIGZTKSwgb1EgPSB0eXBlb2YgSFRNTEVsZW1lbnQgPCBcInVcIiA/IEhUTUxFbGVtZW50IDogY2xhc3Mge1xufTtcbmNsYXNzIEVkIGV4dGVuZHMgb1Ege1xuICBjb25zdHJ1Y3RvcihlLCBuID0ge30sIHIpIHtcbiAgICBzdXBlcigpLCB0aGlzLl9kZWYgPSBlLCB0aGlzLl9wcm9wcyA9IG4sIHRoaXMuX2luc3RhbmNlID0gbnVsbCwgdGhpcy5fY29ubmVjdGVkID0gITEsIHRoaXMuX3Jlc29sdmVkID0gITEsIHRoaXMuX251bWJlclByb3BzID0gbnVsbCwgdGhpcy5fb2IgPSBudWxsLCB0aGlzLnNoYWRvd1Jvb3QgJiYgciA/IHIodGhpcy5fY3JlYXRlVk5vZGUoKSwgdGhpcy5zaGFkb3dSb290KSA6IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgdGhpcy5zaGFkb3dSb290ICYmIFh0KFxuICAgICAgXCJDdXN0b20gZWxlbWVudCBoYXMgcHJlLXJlbmRlcmVkIGRlY2xhcmF0aXZlIHNoYWRvdyByb290IGJ1dCBpcyBub3QgZGVmaW5lZCBhcyBoeWRyYXRhYmxlLiBVc2UgYGRlZmluZVNTUkN1c3RvbUVsZW1lbnRgLlwiXG4gICAgKSwgdGhpcy5hdHRhY2hTaGFkb3coeyBtb2RlOiBcIm9wZW5cIiB9KSwgdGhpcy5fZGVmLl9fYXN5bmNMb2FkZXIgfHwgdGhpcy5fcmVzb2x2ZVByb3BzKHRoaXMuX2RlZikpO1xuICB9XG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX2Nvbm5lY3RlZCA9ICEwLCB0aGlzLl9pbnN0YW5jZSB8fCAodGhpcy5fcmVzb2x2ZWQgPyB0aGlzLl91cGRhdGUoKSA6IHRoaXMuX3Jlc29sdmVEZWYoKSk7XG4gIH1cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5fY29ubmVjdGVkID0gITEsIHRoaXMuX29iICYmICh0aGlzLl9vYi5kaXNjb25uZWN0KCksIHRoaXMuX29iID0gbnVsbCksIFBuKCgpID0+IHtcbiAgICAgIHRoaXMuX2Nvbm5lY3RlZCB8fCAoJGgobnVsbCwgdGhpcy5zaGFkb3dSb290KSwgdGhpcy5faW5zdGFuY2UgPSBudWxsKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogcmVzb2x2ZSBpbm5lciBjb21wb25lbnQgZGVmaW5pdGlvbiAoaGFuZGxlIHBvc3NpYmxlIGFzeW5jIGNvbXBvbmVudClcbiAgICovXG4gIF9yZXNvbHZlRGVmKCkge1xuICAgIHRoaXMuX3Jlc29sdmVkID0gITA7XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCB0aGlzLmF0dHJpYnV0ZXMubGVuZ3RoOyByKyspXG4gICAgICB0aGlzLl9zZXRBdHRyKHRoaXMuYXR0cmlidXRlc1tyXS5uYW1lKTtcbiAgICB0aGlzLl9vYiA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKChyKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGkgb2YgcilcbiAgICAgICAgdGhpcy5fc2V0QXR0cihpLmF0dHJpYnV0ZU5hbWUpO1xuICAgIH0pLCB0aGlzLl9vYi5vYnNlcnZlKHRoaXMsIHsgYXR0cmlidXRlczogITAgfSk7XG4gICAgY29uc3QgZSA9IChyLCBpID0gITEpID0+IHtcbiAgICAgIGNvbnN0IHsgcHJvcHM6IHMsIHN0eWxlczogbyB9ID0gcjtcbiAgICAgIGxldCBhO1xuICAgICAgaWYgKHMgJiYgIWllKHMpKVxuICAgICAgICBmb3IgKGNvbnN0IGwgaW4gcykge1xuICAgICAgICAgIGNvbnN0IGMgPSBzW2xdO1xuICAgICAgICAgIChjID09PSBOdW1iZXIgfHwgYyAmJiBjLnR5cGUgPT09IE51bWJlcikgJiYgKGwgaW4gdGhpcy5fcHJvcHMgJiYgKHRoaXMuX3Byb3BzW2xdID0gdnUodGhpcy5fcHJvcHNbbF0pKSwgKGEgfHwgKGEgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSkpW210KGwpXSA9ICEwKTtcbiAgICAgICAgfVxuICAgICAgdGhpcy5fbnVtYmVyUHJvcHMgPSBhLCBpICYmIHRoaXMuX3Jlc29sdmVQcm9wcyhyKSwgdGhpcy5fYXBwbHlTdHlsZXMobyksIHRoaXMuX3VwZGF0ZSgpO1xuICAgIH0sIG4gPSB0aGlzLl9kZWYuX19hc3luY0xvYWRlcjtcbiAgICBuID8gbigpLnRoZW4oKHIpID0+IGUociwgITApKSA6IGUodGhpcy5fZGVmKTtcbiAgfVxuICBfcmVzb2x2ZVByb3BzKGUpIHtcbiAgICBjb25zdCB7IHByb3BzOiBuIH0gPSBlLCByID0gaWUobikgPyBuIDogT2JqZWN0LmtleXMobiB8fCB7fSk7XG4gICAgZm9yIChjb25zdCBpIG9mIE9iamVjdC5rZXlzKHRoaXMpKVxuICAgICAgaVswXSAhPT0gXCJfXCIgJiYgci5pbmNsdWRlcyhpKSAmJiB0aGlzLl9zZXRQcm9wKGksIHRoaXNbaV0sICEwLCAhMSk7XG4gICAgZm9yIChjb25zdCBpIG9mIHIubWFwKG10KSlcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBpLCB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UHJvcChpKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHMpIHtcbiAgICAgICAgICB0aGlzLl9zZXRQcm9wKGksIHMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgfVxuICBfc2V0QXR0cihlKSB7XG4gICAgbGV0IG4gPSB0aGlzLmdldEF0dHJpYnV0ZShlKTtcbiAgICBjb25zdCByID0gbXQoZSk7XG4gICAgdGhpcy5fbnVtYmVyUHJvcHMgJiYgdGhpcy5fbnVtYmVyUHJvcHNbcl0gJiYgKG4gPSB2dShuKSksIHRoaXMuX3NldFByb3AociwgbiwgITEpO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9nZXRQcm9wKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJvcHNbZV07XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3NldFByb3AoZSwgbiwgciA9ICEwLCBpID0gITApIHtcbiAgICBuICE9PSB0aGlzLl9wcm9wc1tlXSAmJiAodGhpcy5fcHJvcHNbZV0gPSBuLCBpICYmIHRoaXMuX2luc3RhbmNlICYmIHRoaXMuX3VwZGF0ZSgpLCByICYmIChuID09PSAhMCA/IHRoaXMuc2V0QXR0cmlidXRlKHJuKGUpLCBcIlwiKSA6IHR5cGVvZiBuID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIG4gPT0gXCJudW1iZXJcIiA/IHRoaXMuc2V0QXR0cmlidXRlKHJuKGUpLCBuICsgXCJcIikgOiBuIHx8IHRoaXMucmVtb3ZlQXR0cmlidXRlKHJuKGUpKSkpO1xuICB9XG4gIF91cGRhdGUoKSB7XG4gICAgJGgodGhpcy5fY3JlYXRlVk5vZGUoKSwgdGhpcy5zaGFkb3dSb290KTtcbiAgfVxuICBfY3JlYXRlVk5vZGUoKSB7XG4gICAgY29uc3QgZSA9IEoodGhpcy5fZGVmLCAkZSh7fSwgdGhpcy5fcHJvcHMpKTtcbiAgICByZXR1cm4gdGhpcy5faW5zdGFuY2UgfHwgKGUuY2UgPSAobikgPT4ge1xuICAgICAgdGhpcy5faW5zdGFuY2UgPSBuLCBuLmlzQ0UgPSAhMCwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChuLmNlUmVsb2FkID0gKHMpID0+IHtcbiAgICAgICAgdGhpcy5fc3R5bGVzICYmICh0aGlzLl9zdHlsZXMuZm9yRWFjaCgobykgPT4gdGhpcy5zaGFkb3dSb290LnJlbW92ZUNoaWxkKG8pKSwgdGhpcy5fc3R5bGVzLmxlbmd0aCA9IDApLCB0aGlzLl9hcHBseVN0eWxlcyhzKSwgdGhpcy5faW5zdGFuY2UgPSBudWxsLCB0aGlzLl91cGRhdGUoKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgciA9IChzLCBvKSA9PiB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICBuZXcgQ3VzdG9tRXZlbnQocywge1xuICAgICAgICAgICAgZGV0YWlsOiBvXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgICBuLmVtaXQgPSAocywgLi4ubykgPT4ge1xuICAgICAgICByKHMsIG8pLCBybihzKSAhPT0gcyAmJiByKHJuKHMpLCBvKTtcbiAgICAgIH07XG4gICAgICBsZXQgaSA9IHRoaXM7XG4gICAgICBmb3IgKDsgaSA9IGkgJiYgKGkucGFyZW50Tm9kZSB8fCBpLmhvc3QpOyApXG4gICAgICAgIGlmIChpIGluc3RhbmNlb2YgRWQpIHtcbiAgICAgICAgICBuLnBhcmVudCA9IGkuX2luc3RhbmNlLCBuLnByb3ZpZGVzID0gaS5faW5zdGFuY2UucHJvdmlkZXM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9KSwgZTtcbiAgfVxuICBfYXBwbHlTdHlsZXMoZSkge1xuICAgIGUgJiYgZS5mb3JFYWNoKChuKSA9PiB7XG4gICAgICBjb25zdCByID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgci50ZXh0Q29udGVudCA9IG4sIHRoaXMuc2hhZG93Um9vdC5hcHBlbmRDaGlsZChyKSwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICh0aGlzLl9zdHlsZXMgfHwgKHRoaXMuX3N0eWxlcyA9IFtdKSkucHVzaChyKTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gSjEodCA9IFwiJHN0eWxlXCIpIHtcbiAge1xuICAgIGNvbnN0IGUgPSBpcigpO1xuICAgIGlmICghZSlcbiAgICAgIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgWHQoXCJ1c2VDc3NNb2R1bGUgbXVzdCBiZSBjYWxsZWQgaW5zaWRlIHNldHVwKClcIiksIFZlO1xuICAgIGNvbnN0IG4gPSBlLnR5cGUuX19jc3NNb2R1bGVzO1xuICAgIGlmICghbilcbiAgICAgIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgWHQoXCJDdXJyZW50IGluc3RhbmNlIGRvZXMgbm90IGhhdmUgQ1NTIG1vZHVsZXMgaW5qZWN0ZWQuXCIpLCBWZTtcbiAgICBjb25zdCByID0gblt0XTtcbiAgICByZXR1cm4gciB8fCAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIFh0KGBDdXJyZW50IGluc3RhbmNlIGRvZXMgbm90IGhhdmUgQ1NTIG1vZHVsZSBuYW1lZCBcIiR7dH1cIi5gKSwgVmUpO1xuICB9XG59XG5jb25zdCBlUyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCB0UyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCAkdSA9IFN5bWJvbChcIl9tb3ZlQ2JcIiksIEZtID0gU3ltYm9sKFwiX2VudGVyQ2JcIiksIG5TID0ge1xuICBuYW1lOiBcIlRyYW5zaXRpb25Hcm91cFwiLFxuICBwcm9wczogLyogQF9fUFVSRV9fICovICRlKHt9LCBXJCwge1xuICAgIHRhZzogU3RyaW5nLFxuICAgIG1vdmVDbGFzczogU3RyaW5nXG4gIH0pLFxuICBzZXR1cCh0LCB7IHNsb3RzOiBlIH0pIHtcbiAgICBjb25zdCBuID0gaXIoKSwgciA9IFNPKCk7XG4gICAgbGV0IGksIHM7XG4gICAgcmV0dXJuIGtkKCgpID0+IHtcbiAgICAgIGlmICghaS5sZW5ndGgpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IG8gPSB0Lm1vdmVDbGFzcyB8fCBgJHt0Lm5hbWUgfHwgXCJ2XCJ9LW1vdmVgO1xuICAgICAgaWYgKCFmUShcbiAgICAgICAgaVswXS5lbCxcbiAgICAgICAgbi52bm9kZS5lbCxcbiAgICAgICAgb1xuICAgICAgKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaS5mb3JFYWNoKGNRKSwgaS5mb3JFYWNoKHVRKTtcbiAgICAgIGNvbnN0IGEgPSBpLmZpbHRlcihkUSk7XG4gICAgICB6MSgpLCBhLmZvckVhY2goKGwpID0+IHtcbiAgICAgICAgY29uc3QgYyA9IGwuZWwsIHUgPSBjLnN0eWxlO1xuICAgICAgICBLcihjLCBvKSwgdS50cmFuc2Zvcm0gPSB1LndlYmtpdFRyYW5zZm9ybSA9IHUudHJhbnNpdGlvbkR1cmF0aW9uID0gXCJcIjtcbiAgICAgICAgY29uc3QgZCA9IGNbJHVdID0gKGYpID0+IHtcbiAgICAgICAgICBmICYmIGYudGFyZ2V0ICE9PSBjIHx8ICghZiB8fCAvdHJhbnNmb3JtJC8udGVzdChmLnByb3BlcnR5TmFtZSkpICYmIChjLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIsIGQpLCBjWyR1XSA9IG51bGwsICRpKGMsIG8pKTtcbiAgICAgICAgfTtcbiAgICAgICAgYy5hZGRFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbmVuZFwiLCBkKTtcbiAgICAgIH0pO1xuICAgIH0pLCAoKSA9PiB7XG4gICAgICBjb25zdCBvID0gT2UodCksIGEgPSBxMShvKTtcbiAgICAgIGxldCBsID0gby50YWcgfHwgUGU7XG4gICAgICBpID0gcywgcyA9IGUuZGVmYXVsdCA/IFNkKGUuZGVmYXVsdCgpKSA6IFtdO1xuICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgIGNvbnN0IHUgPSBzW2NdO1xuICAgICAgICB1LmtleSAhPSBudWxsID8gWHMoXG4gICAgICAgICAgdSxcbiAgICAgICAgICBSbyh1LCBhLCByLCBuKVxuICAgICAgICApIDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIFh0KFwiPFRyYW5zaXRpb25Hcm91cD4gY2hpbGRyZW4gbXVzdCBiZSBrZXllZC5cIik7XG4gICAgICB9XG4gICAgICBpZiAoaSlcbiAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCBpLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgY29uc3QgdSA9IGlbY107XG4gICAgICAgICAgWHMoXG4gICAgICAgICAgICB1LFxuICAgICAgICAgICAgUm8odSwgYSwgciwgbilcbiAgICAgICAgICApLCBlUy5zZXQodSwgdS5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBKKGwsIG51bGwsIHMpO1xuICAgIH07XG4gIH1cbn0sIGFRID0gKHQpID0+IGRlbGV0ZSB0Lm1vZGU7XG5uUy5wcm9wcztcbmNvbnN0IGxRID0gblM7XG5mdW5jdGlvbiBjUSh0KSB7XG4gIGNvbnN0IGUgPSB0LmVsO1xuICBlWyR1XSAmJiBlWyR1XSgpLCBlW0ZtXSAmJiBlW0ZtXSgpO1xufVxuZnVuY3Rpb24gdVEodCkge1xuICB0Uy5zZXQodCwgdC5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSk7XG59XG5mdW5jdGlvbiBkUSh0KSB7XG4gIGNvbnN0IGUgPSBlUy5nZXQodCksIG4gPSB0Uy5nZXQodCksIHIgPSBlLmxlZnQgLSBuLmxlZnQsIGkgPSBlLnRvcCAtIG4udG9wO1xuICBpZiAociB8fCBpKSB7XG4gICAgY29uc3QgcyA9IHQuZWwuc3R5bGU7XG4gICAgcmV0dXJuIHMudHJhbnNmb3JtID0gcy53ZWJraXRUcmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7cn1weCwke2l9cHgpYCwgcy50cmFuc2l0aW9uRHVyYXRpb24gPSBcIjBzXCIsIHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGZRKHQsIGUsIG4pIHtcbiAgY29uc3QgciA9IHQuY2xvbmVOb2RlKCksIGkgPSB0W05vXTtcbiAgaSAmJiBpLmZvckVhY2goKGEpID0+IHtcbiAgICBhLnNwbGl0KC9cXHMrLykuZm9yRWFjaCgobCkgPT4gbCAmJiByLmNsYXNzTGlzdC5yZW1vdmUobCkpO1xuICB9KSwgbi5zcGxpdCgvXFxzKy8pLmZvckVhY2goKGEpID0+IGEgJiYgci5jbGFzc0xpc3QuYWRkKGEpKSwgci5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gIGNvbnN0IHMgPSBlLm5vZGVUeXBlID09PSAxID8gZSA6IGUucGFyZW50Tm9kZTtcbiAgcy5hcHBlbmRDaGlsZChyKTtcbiAgY29uc3QgeyBoYXNUcmFuc2Zvcm06IG8gfSA9IFkxKHIpO1xuICByZXR1cm4gcy5yZW1vdmVDaGlsZChyKSwgbztcbn1cbmNvbnN0IHJzID0gKHQpID0+IHtcbiAgY29uc3QgZSA9IHQucHJvcHNbXCJvblVwZGF0ZTptb2RlbFZhbHVlXCJdIHx8ICExO1xuICByZXR1cm4gaWUoZSkgPyAobikgPT4gSWkoZSwgbikgOiBlO1xufTtcbmZ1bmN0aW9uIGhRKHQpIHtcbiAgdC50YXJnZXQuY29tcG9zaW5nID0gITA7XG59XG5mdW5jdGlvbiBHbSh0KSB7XG4gIGNvbnN0IGUgPSB0LnRhcmdldDtcbiAgZS5jb21wb3NpbmcgJiYgKGUuY29tcG9zaW5nID0gITEsIGUuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoXCJpbnB1dFwiKSkpO1xufVxuY29uc3QgSm4gPSBTeW1ib2woXCJfYXNzaWduXCIpLCBHaSA9IHtcbiAgY3JlYXRlZCh0LCB7IG1vZGlmaWVyczogeyBsYXp5OiBlLCB0cmltOiBuLCBudW1iZXI6IHIgfSB9LCBpKSB7XG4gICAgdFtKbl0gPSBycyhpKTtcbiAgICBjb25zdCBzID0gciB8fCBpLnByb3BzICYmIGkucHJvcHMudHlwZSA9PT0gXCJudW1iZXJcIjtcbiAgICBuaSh0LCBlID8gXCJjaGFuZ2VcIiA6IFwiaW5wdXRcIiwgKG8pID0+IHtcbiAgICAgIGlmIChvLnRhcmdldC5jb21wb3NpbmcpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGxldCBhID0gdC52YWx1ZTtcbiAgICAgIG4gJiYgKGEgPSBhLnRyaW0oKSksIHMgJiYgKGEgPSBLYShhKSksIHRbSm5dKGEpO1xuICAgIH0pLCBuICYmIG5pKHQsIFwiY2hhbmdlXCIsICgpID0+IHtcbiAgICAgIHQudmFsdWUgPSB0LnZhbHVlLnRyaW0oKTtcbiAgICB9KSwgZSB8fCAobmkodCwgXCJjb21wb3NpdGlvbnN0YXJ0XCIsIGhRKSwgbmkodCwgXCJjb21wb3NpdGlvbmVuZFwiLCBHbSksIG5pKHQsIFwiY2hhbmdlXCIsIEdtKSk7XG4gIH0sXG4gIC8vIHNldCB2YWx1ZSBvbiBtb3VudGVkIHNvIGl0J3MgYWZ0ZXIgbWluL21heCBmb3IgdHlwZT1cInJhbmdlXCJcbiAgbW91bnRlZCh0LCB7IHZhbHVlOiBlIH0pIHtcbiAgICB0LnZhbHVlID0gZSA/PyBcIlwiO1xuICB9LFxuICBiZWZvcmVVcGRhdGUodCwgeyB2YWx1ZTogZSwgbW9kaWZpZXJzOiB7IGxhenk6IG4sIHRyaW06IHIsIG51bWJlcjogaSB9IH0sIHMpIHtcbiAgICBpZiAodFtKbl0gPSBycyhzKSwgdC5jb21wb3NpbmcpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbyA9IGkgfHwgdC50eXBlID09PSBcIm51bWJlclwiID8gS2EodC52YWx1ZSkgOiB0LnZhbHVlLCBhID0gZSA/PyBcIlwiO1xuICAgIG8gIT09IGEgJiYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHQgJiYgdC50eXBlICE9PSBcInJhbmdlXCIgJiYgKG4gfHwgciAmJiB0LnZhbHVlLnRyaW0oKSA9PT0gYSkgfHwgKHQudmFsdWUgPSBhKSk7XG4gIH1cbn0sICRkID0ge1xuICAvLyAjNDA5NiBhcnJheSBjaGVja2JveGVzIG5lZWQgdG8gYmUgZGVlcCB0cmF2ZXJzZWRcbiAgZGVlcDogITAsXG4gIGNyZWF0ZWQodCwgZSwgbikge1xuICAgIHRbSm5dID0gcnMobiksIG5pKHQsIFwiY2hhbmdlXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHIgPSB0Ll9tb2RlbFZhbHVlLCBpID0gRG8odCksIHMgPSB0LmNoZWNrZWQsIG8gPSB0W0puXTtcbiAgICAgIGlmIChpZShyKSkge1xuICAgICAgICBjb25zdCBhID0gaGQociwgaSksIGwgPSBhICE9PSAtMTtcbiAgICAgICAgaWYgKHMgJiYgIWwpXG4gICAgICAgICAgbyhyLmNvbmNhdChpKSk7XG4gICAgICAgIGVsc2UgaWYgKCFzICYmIGwpIHtcbiAgICAgICAgICBjb25zdCBjID0gWy4uLnJdO1xuICAgICAgICAgIGMuc3BsaWNlKGEsIDEpLCBvKGMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKEdzKHIpKSB7XG4gICAgICAgIGNvbnN0IGEgPSBuZXcgU2V0KHIpO1xuICAgICAgICBzID8gYS5hZGQoaSkgOiBhLmRlbGV0ZShpKSwgbyhhKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBvKGlTKHQsIHMpKTtcbiAgICB9KTtcbiAgfSxcbiAgLy8gc2V0IGluaXRpYWwgY2hlY2tlZCBvbiBtb3VudCB0byB3YWl0IGZvciB0cnVlLXZhbHVlL2ZhbHNlLXZhbHVlXG4gIG1vdW50ZWQ6IEttLFxuICBiZWZvcmVVcGRhdGUodCwgZSwgbikge1xuICAgIHRbSm5dID0gcnMobiksIEttKHQsIGUsIG4pO1xuICB9XG59O1xuZnVuY3Rpb24gS20odCwgeyB2YWx1ZTogZSwgb2xkVmFsdWU6IG4gfSwgcikge1xuICB0Ll9tb2RlbFZhbHVlID0gZSwgaWUoZSkgPyB0LmNoZWNrZWQgPSBoZChlLCByLnByb3BzLnZhbHVlKSA+IC0xIDogR3MoZSkgPyB0LmNoZWNrZWQgPSBlLmhhcyhyLnByb3BzLnZhbHVlKSA6IGUgIT09IG4gJiYgKHQuY2hlY2tlZCA9IHRzKGUsIGlTKHQsICEwKSkpO1xufVxuY29uc3QgUk8gPSB7XG4gIGNyZWF0ZWQodCwgeyB2YWx1ZTogZSB9LCBuKSB7XG4gICAgdC5jaGVja2VkID0gdHMoZSwgbi5wcm9wcy52YWx1ZSksIHRbSm5dID0gcnMobiksIG5pKHQsIFwiY2hhbmdlXCIsICgpID0+IHtcbiAgICAgIHRbSm5dKERvKHQpKTtcbiAgICB9KTtcbiAgfSxcbiAgYmVmb3JlVXBkYXRlKHQsIHsgdmFsdWU6IGUsIG9sZFZhbHVlOiBuIH0sIHIpIHtcbiAgICB0W0puXSA9IHJzKHIpLCBlICE9PSBuICYmICh0LmNoZWNrZWQgPSB0cyhlLCByLnByb3BzLnZhbHVlKSk7XG4gIH1cbn0sIHJTID0ge1xuICAvLyA8c2VsZWN0IG11bHRpcGxlPiB2YWx1ZSBuZWVkIHRvIGJlIGRlZXAgdHJhdmVyc2VkXG4gIGRlZXA6ICEwLFxuICBjcmVhdGVkKHQsIHsgdmFsdWU6IGUsIG1vZGlmaWVyczogeyBudW1iZXI6IG4gfSB9LCByKSB7XG4gICAgY29uc3QgaSA9IEdzKGUpO1xuICAgIG5pKHQsIFwiY2hhbmdlXCIsICgpID0+IHtcbiAgICAgIGNvbnN0IHMgPSBBcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwodC5vcHRpb25zLCAobykgPT4gby5zZWxlY3RlZCkubWFwKFxuICAgICAgICAobykgPT4gbiA/IEthKERvKG8pKSA6IERvKG8pXG4gICAgICApO1xuICAgICAgdFtKbl0oXG4gICAgICAgIHQubXVsdGlwbGUgPyBpID8gbmV3IFNldChzKSA6IHMgOiBzWzBdXG4gICAgICApLCB0Ll9hc3NpZ25pbmcgPSAhMCwgUG4oKCkgPT4ge1xuICAgICAgICB0Ll9hc3NpZ25pbmcgPSAhMTtcbiAgICAgIH0pO1xuICAgIH0pLCB0W0puXSA9IHJzKHIpO1xuICB9LFxuICAvLyBzZXQgdmFsdWUgaW4gbW91bnRlZCAmIHVwZGF0ZWQgYmVjYXVzZSA8c2VsZWN0PiByZWxpZXMgb24gaXRzIGNoaWxkcmVuXG4gIC8vIDxvcHRpb24+cy5cbiAgbW91bnRlZCh0LCB7IHZhbHVlOiBlLCBtb2RpZmllcnM6IHsgbnVtYmVyOiBuIH0gfSkge1xuICAgIEptKHQsIGUsIG4pO1xuICB9LFxuICBiZWZvcmVVcGRhdGUodCwgZSwgbikge1xuICAgIHRbSm5dID0gcnMobik7XG4gIH0sXG4gIHVwZGF0ZWQodCwgeyB2YWx1ZTogZSwgbW9kaWZpZXJzOiB7IG51bWJlcjogbiB9IH0pIHtcbiAgICB0Ll9hc3NpZ25pbmcgfHwgSm0odCwgZSwgbik7XG4gIH1cbn07XG5mdW5jdGlvbiBKbSh0LCBlLCBuKSB7XG4gIGNvbnN0IHIgPSB0Lm11bHRpcGxlLCBpID0gaWUoZSk7XG4gIGlmIChyICYmICFpICYmICFHcyhlKSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBYdChcbiAgICAgIGA8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw+IGV4cGVjdHMgYW4gQXJyYXkgb3IgU2V0IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCAke09iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChlKS5zbGljZSg4LCAtMSl9LmBcbiAgICApO1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKGxldCBzID0gMCwgbyA9IHQub3B0aW9ucy5sZW5ndGg7IHMgPCBvOyBzKyspIHtcbiAgICBjb25zdCBhID0gdC5vcHRpb25zW3NdLCBsID0gRG8oYSk7XG4gICAgaWYgKHIpXG4gICAgICBpZiAoaSkge1xuICAgICAgICBjb25zdCBjID0gdHlwZW9mIGw7XG4gICAgICAgIGMgPT09IFwic3RyaW5nXCIgfHwgYyA9PT0gXCJudW1iZXJcIiA/IGEuc2VsZWN0ZWQgPSBlLmluY2x1ZGVzKFxuICAgICAgICAgIG4gPyBLYShsKSA6IGxcbiAgICAgICAgKSA6IGEuc2VsZWN0ZWQgPSBoZChlLCBsKSA+IC0xO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGEuc2VsZWN0ZWQgPSBlLmhhcyhsKTtcbiAgICBlbHNlIGlmICh0cyhEbyhhKSwgZSkpIHtcbiAgICAgIHQuc2VsZWN0ZWRJbmRleCAhPT0gcyAmJiAodC5zZWxlY3RlZEluZGV4ID0gcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gICFyICYmIHQuc2VsZWN0ZWRJbmRleCAhPT0gLTEgJiYgKHQuc2VsZWN0ZWRJbmRleCA9IC0xKTtcbn1cbmZ1bmN0aW9uIERvKHQpIHtcbiAgcmV0dXJuIFwiX3ZhbHVlXCIgaW4gdCA/IHQuX3ZhbHVlIDogdC52YWx1ZTtcbn1cbmZ1bmN0aW9uIGlTKHQsIGUpIHtcbiAgY29uc3QgbiA9IGUgPyBcIl90cnVlVmFsdWVcIiA6IFwiX2ZhbHNlVmFsdWVcIjtcbiAgcmV0dXJuIG4gaW4gdCA/IHRbbl0gOiBlO1xufVxuY29uc3Qgc1MgPSB7XG4gIGNyZWF0ZWQodCwgZSwgbikge1xuICAgIGJjKHQsIGUsIG4sIG51bGwsIFwiY3JlYXRlZFwiKTtcbiAgfSxcbiAgbW91bnRlZCh0LCBlLCBuKSB7XG4gICAgYmModCwgZSwgbiwgbnVsbCwgXCJtb3VudGVkXCIpO1xuICB9LFxuICBiZWZvcmVVcGRhdGUodCwgZSwgbiwgcikge1xuICAgIGJjKHQsIGUsIG4sIHIsIFwiYmVmb3JlVXBkYXRlXCIpO1xuICB9LFxuICB1cGRhdGVkKHQsIGUsIG4sIHIpIHtcbiAgICBiYyh0LCBlLCBuLCByLCBcInVwZGF0ZWRcIik7XG4gIH1cbn07XG5mdW5jdGlvbiBvUyh0LCBlKSB7XG4gIHN3aXRjaCAodCkge1xuICAgIGNhc2UgXCJTRUxFQ1RcIjpcbiAgICAgIHJldHVybiByUztcbiAgICBjYXNlIFwiVEVYVEFSRUFcIjpcbiAgICAgIHJldHVybiBHaTtcbiAgICBkZWZhdWx0OlxuICAgICAgc3dpdGNoIChlKSB7XG4gICAgICAgIGNhc2UgXCJjaGVja2JveFwiOlxuICAgICAgICAgIHJldHVybiAkZDtcbiAgICAgICAgY2FzZSBcInJhZGlvXCI6XG4gICAgICAgICAgcmV0dXJuIFJPO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBHaTtcbiAgICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYmModCwgZSwgbiwgciwgaSkge1xuICBjb25zdCBvID0gb1MoXG4gICAgdC50YWdOYW1lLFxuICAgIG4ucHJvcHMgJiYgbi5wcm9wcy50eXBlXG4gIClbaV07XG4gIG8gJiYgbyh0LCBlLCBuLCByKTtcbn1cbmZ1bmN0aW9uIHBRKCkge1xuICBHaS5nZXRTU1JQcm9wcyA9ICh7IHZhbHVlOiB0IH0pID0+ICh7IHZhbHVlOiB0IH0pLCBSTy5nZXRTU1JQcm9wcyA9ICh7IHZhbHVlOiB0IH0sIGUpID0+IHtcbiAgICBpZiAoZS5wcm9wcyAmJiB0cyhlLnByb3BzLnZhbHVlLCB0KSlcbiAgICAgIHJldHVybiB7IGNoZWNrZWQ6ICEwIH07XG4gIH0sICRkLmdldFNTUlByb3BzID0gKHsgdmFsdWU6IHQgfSwgZSkgPT4ge1xuICAgIGlmIChpZSh0KSkge1xuICAgICAgaWYgKGUucHJvcHMgJiYgaGQodCwgZS5wcm9wcy52YWx1ZSkgPiAtMSlcbiAgICAgICAgcmV0dXJuIHsgY2hlY2tlZDogITAgfTtcbiAgICB9IGVsc2UgaWYgKEdzKHQpKSB7XG4gICAgICBpZiAoZS5wcm9wcyAmJiB0LmhhcyhlLnByb3BzLnZhbHVlKSlcbiAgICAgICAgcmV0dXJuIHsgY2hlY2tlZDogITAgfTtcbiAgICB9IGVsc2UgaWYgKHQpXG4gICAgICByZXR1cm4geyBjaGVja2VkOiAhMCB9O1xuICB9LCBzUy5nZXRTU1JQcm9wcyA9ICh0LCBlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBlLnR5cGUgIT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBuID0gb1MoXG4gICAgICAvLyByZXNvbHZlRHluYW1pY01vZGVsIGV4cGVjdHMgYW4gdXBwZXJjYXNlIHRhZyBuYW1lLCBidXQgdm5vZGUudHlwZSBpcyBsb3dlcmNhc2VcbiAgICAgIGUudHlwZS50b1VwcGVyQ2FzZSgpLFxuICAgICAgZS5wcm9wcyAmJiBlLnByb3BzLnR5cGVcbiAgICApO1xuICAgIGlmIChuLmdldFNTUlByb3BzKVxuICAgICAgcmV0dXJuIG4uZ2V0U1NSUHJvcHModCwgZSk7XG4gIH07XG59XG5jb25zdCBPUSA9IFtcImN0cmxcIiwgXCJzaGlmdFwiLCBcImFsdFwiLCBcIm1ldGFcIl0sIGdRID0ge1xuICBzdG9wOiAodCkgPT4gdC5zdG9wUHJvcGFnYXRpb24oKSxcbiAgcHJldmVudDogKHQpID0+IHQucHJldmVudERlZmF1bHQoKSxcbiAgc2VsZjogKHQpID0+IHQudGFyZ2V0ICE9PSB0LmN1cnJlbnRUYXJnZXQsXG4gIGN0cmw6ICh0KSA9PiAhdC5jdHJsS2V5LFxuICBzaGlmdDogKHQpID0+ICF0LnNoaWZ0S2V5LFxuICBhbHQ6ICh0KSA9PiAhdC5hbHRLZXksXG4gIG1ldGE6ICh0KSA9PiAhdC5tZXRhS2V5LFxuICBsZWZ0OiAodCkgPT4gXCJidXR0b25cIiBpbiB0ICYmIHQuYnV0dG9uICE9PSAwLFxuICBtaWRkbGU6ICh0KSA9PiBcImJ1dHRvblwiIGluIHQgJiYgdC5idXR0b24gIT09IDEsXG4gIHJpZ2h0OiAodCkgPT4gXCJidXR0b25cIiBpbiB0ICYmIHQuYnV0dG9uICE9PSAyLFxuICBleGFjdDogKHQsIGUpID0+IE9RLnNvbWUoKG4pID0+IHRbYCR7bn1LZXlgXSAmJiAhZS5pbmNsdWRlcyhuKSlcbn0sIGFTID0gKHQsIGUpID0+IHtcbiAgY29uc3QgbiA9IHQuX3dpdGhNb2RzIHx8ICh0Ll93aXRoTW9kcyA9IHt9KSwgciA9IGUuam9pbihcIi5cIik7XG4gIHJldHVybiBuW3JdIHx8IChuW3JdID0gKGksIC4uLnMpID0+IHtcbiAgICBmb3IgKGxldCBvID0gMDsgbyA8IGUubGVuZ3RoOyBvKyspIHtcbiAgICAgIGNvbnN0IGEgPSBnUVtlW29dXTtcbiAgICAgIGlmIChhICYmIGEoaSwgZSkpXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIHQoaSwgLi4ucyk7XG4gIH0pO1xufSwgbVEgPSB7XG4gIGVzYzogXCJlc2NhcGVcIixcbiAgc3BhY2U6IFwiIFwiLFxuICB1cDogXCJhcnJvdy11cFwiLFxuICBsZWZ0OiBcImFycm93LWxlZnRcIixcbiAgcmlnaHQ6IFwiYXJyb3ctcmlnaHRcIixcbiAgZG93bjogXCJhcnJvdy1kb3duXCIsXG4gIGRlbGV0ZTogXCJiYWNrc3BhY2VcIlxufSwgbFMgPSAodCwgZSkgPT4ge1xuICBjb25zdCBuID0gdC5fd2l0aEtleXMgfHwgKHQuX3dpdGhLZXlzID0ge30pLCByID0gZS5qb2luKFwiLlwiKTtcbiAgcmV0dXJuIG5bcl0gfHwgKG5bcl0gPSAoaSkgPT4ge1xuICAgIGlmICghKFwia2V5XCIgaW4gaSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcyA9IHJuKGkua2V5KTtcbiAgICBpZiAoZS5zb21lKChvKSA9PiBvID09PSBzIHx8IG1RW29dID09PSBzKSlcbiAgICAgIHJldHVybiB0KGkpO1xuICB9KTtcbn0sIGNTID0gLyogQF9fUFVSRV9fICovICRlKHsgcGF0Y2hQcm9wOiByUSB9LCBJJCk7XG5sZXQgVWEsIGViID0gITE7XG5mdW5jdGlvbiB1UygpIHtcbiAgcmV0dXJuIFVhIHx8IChVYSA9IF8xKGNTKSk7XG59XG5mdW5jdGlvbiBkUygpIHtcbiAgcmV0dXJuIFVhID0gZWIgPyBVYSA6IFQxKGNTKSwgZWIgPSAhMCwgVWE7XG59XG5jb25zdCAkaCA9ICguLi50KSA9PiB7XG4gIHVTKCkucmVuZGVyKC4uLnQpO1xufSwgZlMgPSAoLi4udCkgPT4ge1xuICBkUygpLmh5ZHJhdGUoLi4udCk7XG59LCBoUyA9ICguLi50KSA9PiB7XG4gIGNvbnN0IGUgPSB1UygpLmNyZWF0ZUFwcCguLi50KTtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChPUyhlKSwgZ1MoZSkpO1xuICBjb25zdCB7IG1vdW50OiBuIH0gPSBlO1xuICByZXR1cm4gZS5tb3VudCA9IChyKSA9PiB7XG4gICAgY29uc3QgaSA9IG1TKHIpO1xuICAgIGlmICghaSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBzID0gZS5fY29tcG9uZW50O1xuICAgICFiZShzKSAmJiAhcy5yZW5kZXIgJiYgIXMudGVtcGxhdGUgJiYgKHMudGVtcGxhdGUgPSBpLmlubmVySFRNTCksIGkuaW5uZXJIVE1MID0gXCJcIjtcbiAgICBjb25zdCBvID0gbihpLCAhMSwgcFMoaSkpO1xuICAgIHJldHVybiBpIGluc3RhbmNlb2YgRWxlbWVudCAmJiAoaS5yZW1vdmVBdHRyaWJ1dGUoXCJ2LWNsb2FrXCIpLCBpLnNldEF0dHJpYnV0ZShcImRhdGEtdi1hcHBcIiwgXCJcIikpLCBvO1xuICB9LCBlO1xufSwgYlEgPSAoLi4udCkgPT4ge1xuICBjb25zdCBlID0gZFMoKS5jcmVhdGVBcHAoLi4udCk7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAoT1MoZSksIGdTKGUpKTtcbiAgY29uc3QgeyBtb3VudDogbiB9ID0gZTtcbiAgcmV0dXJuIGUubW91bnQgPSAocikgPT4ge1xuICAgIGNvbnN0IGkgPSBtUyhyKTtcbiAgICBpZiAoaSlcbiAgICAgIHJldHVybiBuKGksICEwLCBwUyhpKSk7XG4gIH0sIGU7XG59O1xuZnVuY3Rpb24gcFModCkge1xuICBpZiAodCBpbnN0YW5jZW9mIFNWR0VsZW1lbnQpXG4gICAgcmV0dXJuIFwic3ZnXCI7XG4gIGlmICh0eXBlb2YgTWF0aE1MRWxlbWVudCA9PSBcImZ1bmN0aW9uXCIgJiYgdCBpbnN0YW5jZW9mIE1hdGhNTEVsZW1lbnQpXG4gICAgcmV0dXJuIFwibWF0aG1sXCI7XG59XG5mdW5jdGlvbiBPUyh0KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LmNvbmZpZywgXCJpc05hdGl2ZVRhZ1wiLCB7XG4gICAgdmFsdWU6IChlKSA9PiBieShlKSB8fCB2eShlKSB8fCB5eShlKSxcbiAgICB3cml0YWJsZTogITFcbiAgfSk7XG59XG5mdW5jdGlvbiBnUyh0KSB7XG4gIGlmIChRTygpKSB7XG4gICAgY29uc3QgZSA9IHQuY29uZmlnLmlzQ3VzdG9tRWxlbWVudDtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodC5jb25maWcsIFwiaXNDdXN0b21FbGVtZW50XCIsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9LFxuICAgICAgc2V0KCkge1xuICAgICAgICBYdChcbiAgICAgICAgICBcIlRoZSBgaXNDdXN0b21FbGVtZW50YCBjb25maWcgb3B0aW9uIGlzIGRlcHJlY2F0ZWQuIFVzZSBgY29tcGlsZXJPcHRpb25zLmlzQ3VzdG9tRWxlbWVudGAgaW5zdGVhZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IG4gPSB0LmNvbmZpZy5jb21waWxlck9wdGlvbnMsIHIgPSAnVGhlIGBjb21waWxlck9wdGlvbnNgIGNvbmZpZyBvcHRpb24gaXMgb25seSByZXNwZWN0ZWQgd2hlbiB1c2luZyBhIGJ1aWxkIG9mIFZ1ZS5qcyB0aGF0IGluY2x1ZGVzIHRoZSBydW50aW1lIGNvbXBpbGVyIChha2EgXCJmdWxsIGJ1aWxkXCIpLiBTaW5jZSB5b3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQsIGBjb21waWxlck9wdGlvbnNgIG11c3QgYmUgcGFzc2VkIHRvIGBAdnVlL2NvbXBpbGVyLWRvbWAgaW4gdGhlIGJ1aWxkIHNldHVwIGluc3RlYWQuXFxuLSBGb3IgdnVlLWxvYWRlcjogcGFzcyBpdCB2aWEgdnVlLWxvYWRlclxcJ3MgYGNvbXBpbGVyT3B0aW9uc2AgbG9hZGVyIG9wdGlvbi5cXG4tIEZvciB2dWUtY2xpOiBzZWUgaHR0cHM6Ly9jbGkudnVlanMub3JnL2d1aWRlL3dlYnBhY2suaHRtbCNtb2RpZnlpbmctb3B0aW9ucy1vZi1hLWxvYWRlclxcbi0gRm9yIHZpdGU6IHBhc3MgaXQgdmlhIEB2aXRlanMvcGx1Z2luLXZ1ZSBvcHRpb25zLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ZpdGVqcy92aXRlLXBsdWdpbi12dWUvdHJlZS9tYWluL3BhY2thZ2VzL3BsdWdpbi12dWUjZXhhbXBsZS1mb3ItcGFzc2luZy1vcHRpb25zLXRvLXZ1ZWNvbXBpbGVyLXNmYyc7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQuY29uZmlnLCBcImNvbXBpbGVyT3B0aW9uc1wiLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBYdChyKSwgbjtcbiAgICAgIH0sXG4gICAgICBzZXQoKSB7XG4gICAgICAgIFh0KHIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBtUyh0KSB7XG4gIGlmICh3ZSh0KSkge1xuICAgIGNvbnN0IGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHQpO1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIWUgJiYgWHQoXG4gICAgICBgRmFpbGVkIHRvIG1vdW50IGFwcDogbW91bnQgdGFyZ2V0IHNlbGVjdG9yIFwiJHt0fVwiIHJldHVybmVkIG51bGwuYFxuICAgICksIGU7XG4gIH1cbiAgcmV0dXJuIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB3aW5kb3cuU2hhZG93Um9vdCAmJiB0IGluc3RhbmNlb2Ygd2luZG93LlNoYWRvd1Jvb3QgJiYgdC5tb2RlID09PSBcImNsb3NlZFwiICYmIFh0KFxuICAgICdtb3VudGluZyBvbiBhIFNoYWRvd1Jvb3Qgd2l0aCBge21vZGU6IFwiY2xvc2VkXCJ9YCBtYXkgbGVhZCB0byB1bnByZWRpY3RhYmxlIGJ1Z3MnXG4gICksIHQ7XG59XG5sZXQgdGIgPSAhMTtcbmNvbnN0IHZRID0gKCkgPT4ge1xuICB0YiB8fCAodGIgPSAhMCwgcFEoKSwgQiQoKSk7XG59LCB5USA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIEJhc2VUcmFuc2l0aW9uOiBzMSxcbiAgQmFzZVRyYW5zaXRpb25Qcm9wc1ZhbGlkYXRvcnM6IHdPLFxuICBDb21tZW50OiBfdCxcbiAgRGVwcmVjYXRpb25UeXBlczogRCQsXG4gIEVmZmVjdFNjb3BlOiBlTyxcbiAgRXJyb3JDb2RlczogV1QsXG4gIEVycm9yVHlwZVN0cmluZ3M6IEUkLFxuICBGcmFnbWVudDogUGUsXG4gIEtlZXBBbGl2ZTogeUUsXG4gIFJlYWN0aXZlRWZmZWN0OiBBbyxcbiAgU3RhdGljOiBGaSxcbiAgU3VzcGVuc2U6IGRFLFxuICBUZWxlcG9ydDogVE8sXG4gIFRleHQ6IG5zLFxuICBUcmFja09wVHlwZXM6IFJULFxuICBUcmFuc2l0aW9uOiBBTyxcbiAgVHJhbnNpdGlvbkdyb3VwOiBsUSxcbiAgVHJpZ2dlck9wVHlwZXM6IE5ULFxuICBWdWVFbGVtZW50OiBFZCxcbiAgYXNzZXJ0TnVtYmVyOiBkTyxcbiAgY2FsbFdpdGhBc3luY0Vycm9ySGFuZGxpbmc6IFduLFxuICBjYWxsV2l0aEVycm9ySGFuZGxpbmc6IFZyLFxuICBjYW1lbGl6ZTogbXQsXG4gIGNhcGl0YWxpemU6IFdyLFxuICBjbG9uZVZOb2RlOiBqbixcbiAgY29tcGF0VXRpbHM6IE4kLFxuICBjb21wdXRlZDogaixcbiAgY3JlYXRlQXBwOiBoUyxcbiAgY3JlYXRlQmxvY2s6IGtlLFxuICBjcmVhdGVDb21tZW50Vk5vZGU6IHN0LFxuICBjcmVhdGVFbGVtZW50QmxvY2s6IG5lLFxuICBjcmVhdGVFbGVtZW50Vk5vZGU6IEQsXG4gIGNyZWF0ZUh5ZHJhdGlvblJlbmRlcmVyOiBUMSxcbiAgY3JlYXRlUHJvcHNSZXN0UHJveHk6IElFLFxuICBjcmVhdGVSZW5kZXJlcjogXzEsXG4gIGNyZWF0ZVNTUkFwcDogYlEsXG4gIGNyZWF0ZVNsb3RzOiB3RSxcbiAgY3JlYXRlU3RhdGljVk5vZGU6IFdsLFxuICBjcmVhdGVUZXh0Vk5vZGU6IEhlLFxuICBjcmVhdGVWTm9kZTogSixcbiAgY3VzdG9tUmVmOiBYeSxcbiAgZGVmaW5lQXN5bmNDb21wb25lbnQ6IGExLFxuICBkZWZpbmVDb21wb25lbnQ6IGxlLFxuICBkZWZpbmVDdXN0b21FbGVtZW50OiBLMSxcbiAgZGVmaW5lRW1pdHM6ICRFLFxuICBkZWZpbmVFeHBvc2U6IFFFLFxuICBkZWZpbmVNb2RlbDogUkUsXG4gIGRlZmluZU9wdGlvbnM6IENFLFxuICBkZWZpbmVQcm9wczogRUUsXG4gIGRlZmluZVNTUkN1c3RvbUVsZW1lbnQ6IHNRLFxuICBkZWZpbmVTbG90czogQUUsXG4gIGRldnRvb2xzOiAkJCxcbiAgZWZmZWN0OiByVCxcbiAgZWZmZWN0U2NvcGU6IHRULFxuICBnZXRDdXJyZW50SW5zdGFuY2U6IGlyLFxuICBnZXRDdXJyZW50U2NvcGU6IFJsLFxuICBnZXRUcmFuc2l0aW9uUmF3Q2hpbGRyZW46IFNkLFxuICBndWFyZFJlYWN0aXZlUHJvcHM6IEVPLFxuICBoOiBrdCxcbiAgaGFuZGxlRXJyb3I6IGhzLFxuICBoYXNJbmplY3Rpb25Db250ZXh0OiB6RSxcbiAgaHlkcmF0ZTogZlMsXG4gIGluaXRDdXN0b21Gb3JtYXR0ZXI6IENPLFxuICBpbml0RGlyZWN0aXZlc0ZvclNTUjogdlEsXG4gIGluamVjdDogUHQsXG4gIGlzTWVtb1NhbWU6IEwxLFxuICBpc1Byb3h5OiBKYSxcbiAgaXNSZWFjdGl2ZTogWWksXG4gIGlzUmVhZG9ubHk6IGFpLFxuICBpc1JlZjogQ3QsXG4gIGlzUnVudGltZU9ubHk6IFFPLFxuICBpc1NoYWxsb3c6IHppLFxuICBpc1ZOb2RlOiBsaSxcbiAgbWFya1Jhdzogb08sXG4gIG1lcmdlRGVmYXVsdHM6IFpFLFxuICBtZXJnZU1vZGVsczogVkUsXG4gIG1lcmdlUHJvcHM6IE1sLFxuICBuZXh0VGljazogUG4sXG4gIG5vcm1hbGl6ZUNsYXNzOiBLZSxcbiAgbm9ybWFsaXplUHJvcHM6IG15LFxuICBub3JtYWxpemVTdHlsZTogQnIsXG4gIG9uQWN0aXZhdGVkOiBsMSxcbiAgb25CZWZvcmVNb3VudDogZDEsXG4gIG9uQmVmb3JlVW5tb3VudDogSWwsXG4gIG9uQmVmb3JlVXBkYXRlOiBmMSxcbiAgb25EZWFjdGl2YXRlZDogYzEsXG4gIG9uRXJyb3JDYXB0dXJlZDogTzEsXG4gIG9uTW91bnRlZDogZXQsXG4gIG9uUmVuZGVyVHJhY2tlZDogcDEsXG4gIG9uUmVuZGVyVHJpZ2dlcmVkOiBoMSxcbiAgb25TY29wZURpc3Bvc2U6IHRPLFxuICBvblNlcnZlclByZWZldGNoOiB4ZCxcbiAgb25Vbm1vdW50ZWQ6IGp0LFxuICBvblVwZGF0ZWQ6IGtkLFxuICBvcGVuQmxvY2s6IFosXG4gIHBvcFNjb3BlSWQ6IEpzLFxuICBwcm92aWRlOiBfbixcbiAgcHJveHlSZWZzOiB1TyxcbiAgcHVzaFNjb3BlSWQ6IEtzLFxuICBxdWV1ZVBvc3RGbHVzaENiOiBubCxcbiAgcmVhY3RpdmU6IFhuLFxuICByZWFkb25seTogc08sXG4gIHJlZjogRyxcbiAgcmVnaXN0ZXJSdW50aW1lQ29tcGlsZXI6IE0xLFxuICByZW5kZXI6ICRoLFxuICByZW5kZXJMaXN0OiBYcixcbiAgcmVuZGVyU2xvdDogcHQsXG4gIHJlc29sdmVDb21wb25lbnQ6IGxFLFxuICByZXNvbHZlRGlyZWN0aXZlOiBjRSxcbiAgcmVzb2x2ZUR5bmFtaWNDb21wb25lbnQ6IFpsLFxuICByZXNvbHZlRmlsdGVyOiBSJCxcbiAgcmVzb2x2ZVRyYW5zaXRpb25Ib29rczogUm8sXG4gIHNldEJsb2NrVHJhY2tpbmc6IHZoLFxuICBzZXREZXZ0b29sc0hvb2s6IFEkLFxuICBzZXRUcmFuc2l0aW9uSG9va3M6IFhzLFxuICBzaGFsbG93UmVhY3RpdmU6IEl5LFxuICBzaGFsbG93UmVhZG9ubHk6IERuLFxuICBzaGFsbG93UmVmOiBjTyxcbiAgc3NyQ29udGV4dEtleTogZTEsXG4gIHNzclV0aWxzOiBBJCxcbiAgc3RvcDogaVQsXG4gIHRvRGlzcGxheVN0cmluZzogRGUsXG4gIHRvSGFuZGxlcktleTogVHIsXG4gIHRvSGFuZGxlcnM6IGtFLFxuICB0b1JhdzogT2UsXG4gIHRvUmVmOiBFaSxcbiAgdG9SZWZzOiBRVCxcbiAgdG9WYWx1ZTogSnQsXG4gIHRyYW5zZm9ybVZOb2RlQXJnczogbSQsXG4gIHRyaWdnZXJSZWY6IFRULFxuICB1bnJlZjogUixcbiAgdXNlQXR0cnM6IHhPLFxuICB1c2VDc3NNb2R1bGU6IEoxLFxuICB1c2VDc3NWYXJzOiBHMSxcbiAgdXNlTW9kZWw6IF8kLFxuICB1c2VTU1JDb250ZXh0OiB5TyxcbiAgdXNlU2xvdHM6IERFLFxuICB1c2VUcmFuc2l0aW9uU3RhdGU6IFNPLFxuICB2TW9kZWxDaGVja2JveDogJGQsXG4gIHZNb2RlbER5bmFtaWM6IHNTLFxuICB2TW9kZWxSYWRpbzogUk8sXG4gIHZNb2RlbFNlbGVjdDogclMsXG4gIHZNb2RlbFRleHQ6IEdpLFxuICB2U2hvdzogamwsXG4gIHZlcnNpb246IF9oLFxuICB3YXJuOiBYdCxcbiAgd2F0Y2g6IGh0LFxuICB3YXRjaEVmZmVjdDogQm4sXG4gIHdhdGNoUG9zdEVmZmVjdDogdDEsXG4gIHdhdGNoU3luY0VmZmVjdDogbjEsXG4gIHdpdGhBc3luY0NvbnRleHQ6IFdFLFxuICB3aXRoQ3R4OiBjZSxcbiAgd2l0aERlZmF1bHRzOiBORSxcbiAgd2l0aERpcmVjdGl2ZXM6IFhpLFxuICB3aXRoS2V5czogbFMsXG4gIHdpdGhNZW1vOiBUJCxcbiAgd2l0aE1vZGlmaWVyczogYVMsXG4gIHdpdGhTY29wZUlkOiByRVxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKTtcbi8qKlxuKiB2dWUgdjMuNC4yMVxuKiAoYykgMjAxOC1wcmVzZW50IFl1eGkgKEV2YW4pIFlvdSBhbmQgVnVlIGNvbnRyaWJ1dG9yc1xuKiBAbGljZW5zZSBNSVRcbioqL1xuZnVuY3Rpb24gU1EoKSB7XG4gIENPKCk7XG59XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgU1EoKTtcbmZ1bmN0aW9uIHdRKHQsIGUsIG4pIHtcbiAgbGV0IHIgPSBHKG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4udmFsdWUpLCBpID0gaigoKSA9PiB0LnZhbHVlICE9PSB2b2lkIDApO1xuICByZXR1cm4gW2ooKCkgPT4gaS52YWx1ZSA/IHQudmFsdWUgOiByLnZhbHVlKSwgZnVuY3Rpb24ocykge1xuICAgIHJldHVybiBpLnZhbHVlIHx8IChyLnZhbHVlID0gcyksIGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUocyk7XG4gIH1dO1xufVxubGV0IGtRID0gU3ltYm9sKFwiaGVhZGxlc3N1aS51c2VpZFwiKSwgeFEgPSAwO1xuZnVuY3Rpb24gbXIoKSB7XG4gIHJldHVybiBQdChrUSwgKCkgPT4gYCR7Kyt4UX1gKSgpO1xufVxuZnVuY3Rpb24gcGUodCkge1xuICB2YXIgZTtcbiAgaWYgKHQgPT0gbnVsbCB8fCB0LnZhbHVlID09IG51bGwpXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCBuID0gKGUgPSB0LnZhbHVlLiRlbCkgIT0gbnVsbCA/IGUgOiB0LnZhbHVlO1xuICByZXR1cm4gbiBpbnN0YW5jZW9mIE5vZGUgPyBuIDogbnVsbDtcbn1cbmZ1bmN0aW9uIFR0KHQsIGUsIC4uLm4pIHtcbiAgaWYgKHQgaW4gZSkge1xuICAgIGxldCBpID0gZVt0XTtcbiAgICByZXR1cm4gdHlwZW9mIGkgPT0gXCJmdW5jdGlvblwiID8gaSguLi5uKSA6IGk7XG4gIH1cbiAgbGV0IHIgPSBuZXcgRXJyb3IoYFRyaWVkIHRvIGhhbmRsZSBcIiR7dH1cIiBidXQgdGhlcmUgaXMgbm8gaGFuZGxlciBkZWZpbmVkLiBPbmx5IGRlZmluZWQgaGFuZGxlcnMgYXJlOiAke09iamVjdC5rZXlzKGUpLm1hcCgoaSkgPT4gYFwiJHtpfVwiYCkuam9pbihcIiwgXCIpfS5gKTtcbiAgdGhyb3cgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgJiYgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UociwgVHQpLCByO1xufVxudmFyIFBRID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBfUSA9ICh0LCBlLCBuKSA9PiBlIGluIHQgPyBQUSh0LCBlLCB7IGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAsIHZhbHVlOiBuIH0pIDogdFtlXSA9IG4sIG5iID0gKHQsIGUsIG4pID0+IChfUSh0LCB0eXBlb2YgZSAhPSBcInN5bWJvbFwiID8gZSArIFwiXCIgOiBlLCBuKSwgbik7XG5sZXQgVFEgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIG5iKHRoaXMsIFwiY3VycmVudFwiLCB0aGlzLmRldGVjdCgpKSwgbmIodGhpcywgXCJjdXJyZW50SWRcIiwgMCk7XG4gIH1cbiAgc2V0KGUpIHtcbiAgICB0aGlzLmN1cnJlbnQgIT09IGUgJiYgKHRoaXMuY3VycmVudElkID0gMCwgdGhpcy5jdXJyZW50ID0gZSk7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5zZXQodGhpcy5kZXRlY3QoKSk7XG4gIH1cbiAgbmV4dElkKCkge1xuICAgIHJldHVybiArK3RoaXMuY3VycmVudElkO1xuICB9XG4gIGdldCBpc1NlcnZlcigpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50ID09PSBcInNlcnZlclwiO1xuICB9XG4gIGdldCBpc0NsaWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50ID09PSBcImNsaWVudFwiO1xuICB9XG4gIGRldGVjdCgpIHtcbiAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyA+IFwidVwiIHx8IHR5cGVvZiBkb2N1bWVudCA+IFwidVwiID8gXCJzZXJ2ZXJcIiA6IFwiY2xpZW50XCI7XG4gIH1cbn0sIFFkID0gbmV3IFRRKCk7XG5mdW5jdGlvbiB0byh0KSB7XG4gIGlmIChRZC5pc1NlcnZlcilcbiAgICByZXR1cm4gbnVsbDtcbiAgaWYgKHQgaW5zdGFuY2VvZiBOb2RlKVxuICAgIHJldHVybiB0Lm93bmVyRG9jdW1lbnQ7XG4gIGlmICh0ICE9IG51bGwgJiYgdC5oYXNPd25Qcm9wZXJ0eShcInZhbHVlXCIpKSB7XG4gICAgbGV0IGUgPSBwZSh0KTtcbiAgICBpZiAoZSlcbiAgICAgIHJldHVybiBlLm93bmVyRG9jdW1lbnQ7XG4gIH1cbiAgcmV0dXJuIGRvY3VtZW50O1xufVxubGV0IFFoID0gW1wiW2NvbnRlbnRFZGl0YWJsZT10cnVlXVwiLCBcIlt0YWJpbmRleF1cIiwgXCJhW2hyZWZdXCIsIFwiYXJlYVtocmVmXVwiLCBcImJ1dHRvbjpub3QoW2Rpc2FibGVkXSlcIiwgXCJpZnJhbWVcIiwgXCJpbnB1dDpub3QoW2Rpc2FibGVkXSlcIiwgXCJzZWxlY3Q6bm90KFtkaXNhYmxlZF0pXCIsIFwidGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pXCJdLm1hcCgodCkgPT4gYCR7dH06bm90KFt0YWJpbmRleD0nLTEnXSlgKS5qb2luKFwiLFwiKTtcbnZhciBXdCA9ICgodCkgPT4gKHRbdC5GaXJzdCA9IDFdID0gXCJGaXJzdFwiLCB0W3QuUHJldmlvdXMgPSAyXSA9IFwiUHJldmlvdXNcIiwgdFt0Lk5leHQgPSA0XSA9IFwiTmV4dFwiLCB0W3QuTGFzdCA9IDhdID0gXCJMYXN0XCIsIHRbdC5XcmFwQXJvdW5kID0gMTZdID0gXCJXcmFwQXJvdW5kXCIsIHRbdC5Ob1Njcm9sbCA9IDMyXSA9IFwiTm9TY3JvbGxcIiwgdCkpKFd0IHx8IHt9KSwgaG8gPSAoKHQpID0+ICh0W3QuRXJyb3IgPSAwXSA9IFwiRXJyb3JcIiwgdFt0Lk92ZXJmbG93ID0gMV0gPSBcIk92ZXJmbG93XCIsIHRbdC5TdWNjZXNzID0gMl0gPSBcIlN1Y2Nlc3NcIiwgdFt0LlVuZGVyZmxvdyA9IDNdID0gXCJVbmRlcmZsb3dcIiwgdCkpKGhvIHx8IHt9KSwgRVEgPSAoKHQpID0+ICh0W3QuUHJldmlvdXMgPSAtMV0gPSBcIlByZXZpb3VzXCIsIHRbdC5OZXh0ID0gMV0gPSBcIk5leHRcIiwgdCkpKEVRIHx8IHt9KTtcbmZ1bmN0aW9uICRRKHQgPSBkb2N1bWVudC5ib2R5KSB7XG4gIHJldHVybiB0ID09IG51bGwgPyBbXSA6IEFycmF5LmZyb20odC5xdWVyeVNlbGVjdG9yQWxsKFFoKSkuc29ydCgoZSwgbikgPT4gTWF0aC5zaWduKChlLnRhYkluZGV4IHx8IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSAtIChuLnRhYkluZGV4IHx8IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSkpO1xufVxudmFyIE5PID0gKCh0KSA9PiAodFt0LlN0cmljdCA9IDBdID0gXCJTdHJpY3RcIiwgdFt0Lkxvb3NlID0gMV0gPSBcIkxvb3NlXCIsIHQpKShOTyB8fCB7fSk7XG5mdW5jdGlvbiBiUyh0LCBlID0gMCkge1xuICB2YXIgbjtcbiAgcmV0dXJuIHQgPT09ICgobiA9IHRvKHQpKSA9PSBudWxsID8gdm9pZCAwIDogbi5ib2R5KSA/ICExIDogVHQoZSwgeyAwKCkge1xuICAgIHJldHVybiB0Lm1hdGNoZXMoUWgpO1xuICB9LCAxKCkge1xuICAgIGxldCByID0gdDtcbiAgICBmb3IgKDsgciAhPT0gbnVsbDsgKSB7XG4gICAgICBpZiAoci5tYXRjaGVzKFFoKSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgciA9IHIucGFyZW50RWxlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuICExO1xuICB9IH0pO1xufVxudmFyIFFRID0gKCh0KSA9PiAodFt0LktleWJvYXJkID0gMF0gPSBcIktleWJvYXJkXCIsIHRbdC5Nb3VzZSA9IDFdID0gXCJNb3VzZVwiLCB0KSkoUVEgfHwge30pO1xudHlwZW9mIHdpbmRvdyA8IFwidVwiICYmIHR5cGVvZiBkb2N1bWVudCA8IFwidVwiICYmIChkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCAodCkgPT4ge1xuICB0Lm1ldGFLZXkgfHwgdC5hbHRLZXkgfHwgdC5jdHJsS2V5IHx8IChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZGF0YXNldC5oZWFkbGVzc3VpRm9jdXNWaXNpYmxlID0gXCJcIik7XG59LCAhMCksIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAodCkgPT4ge1xuICB0LmRldGFpbCA9PT0gMSA/IGRlbGV0ZSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZGF0YXNldC5oZWFkbGVzc3VpRm9jdXNWaXNpYmxlIDogdC5kZXRhaWwgPT09IDAgJiYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kYXRhc2V0LmhlYWRsZXNzdWlGb2N1c1Zpc2libGUgPSBcIlwiKTtcbn0sICEwKSk7XG5mdW5jdGlvbiBWcyh0KSB7XG4gIHQgPT0gbnVsbCB8fCB0LmZvY3VzKHsgcHJldmVudFNjcm9sbDogITAgfSk7XG59XG5sZXQgQ1EgPSBbXCJ0ZXh0YXJlYVwiLCBcImlucHV0XCJdLmpvaW4oXCIsXCIpO1xuZnVuY3Rpb24gQVEodCkge1xuICB2YXIgZSwgbjtcbiAgcmV0dXJuIChuID0gKGUgPSB0ID09IG51bGwgPyB2b2lkIDAgOiB0Lm1hdGNoZXMpID09IG51bGwgPyB2b2lkIDAgOiBlLmNhbGwodCwgQ1EpKSAhPSBudWxsID8gbiA6ICExO1xufVxuZnVuY3Rpb24gdnModCwgZSA9IChuKSA9PiBuKSB7XG4gIHJldHVybiB0LnNsaWNlKCkuc29ydCgobiwgcikgPT4ge1xuICAgIGxldCBpID0gZShuKSwgcyA9IGUocik7XG4gICAgaWYgKGkgPT09IG51bGwgfHwgcyA9PT0gbnVsbClcbiAgICAgIHJldHVybiAwO1xuICAgIGxldCBvID0gaS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihzKTtcbiAgICByZXR1cm4gbyAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HID8gLTEgOiBvICYgTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkcgPyAxIDogMDtcbiAgfSk7XG59XG5mdW5jdGlvbiBFcih0LCBlLCB7IHNvcnRlZDogbiA9ICEwLCByZWxhdGl2ZVRvOiByID0gbnVsbCwgc2tpcEVsZW1lbnRzOiBpID0gW10gfSA9IHt9KSB7XG4gIHZhciBzO1xuICBsZXQgbyA9IChzID0gQXJyYXkuaXNBcnJheSh0KSA/IHQubGVuZ3RoID4gMCA/IHRbMF0ub3duZXJEb2N1bWVudCA6IGRvY3VtZW50IDogdCA9PSBudWxsID8gdm9pZCAwIDogdC5vd25lckRvY3VtZW50KSAhPSBudWxsID8gcyA6IGRvY3VtZW50LCBhID0gQXJyYXkuaXNBcnJheSh0KSA/IG4gPyB2cyh0KSA6IHQgOiAkUSh0KTtcbiAgaS5sZW5ndGggPiAwICYmIGEubGVuZ3RoID4gMSAmJiAoYSA9IGEuZmlsdGVyKChwKSA9PiAhaS5pbmNsdWRlcyhwKSkpLCByID0gciA/PyBvLmFjdGl2ZUVsZW1lbnQ7XG4gIGxldCBsID0gKCgpID0+IHtcbiAgICBpZiAoZSAmIDUpXG4gICAgICByZXR1cm4gMTtcbiAgICBpZiAoZSAmIDEwKVxuICAgICAgcmV0dXJuIC0xO1xuICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgRm9jdXMuRmlyc3QsIEZvY3VzLlByZXZpb3VzLCBGb2N1cy5OZXh0IG9yIEZvY3VzLkxhc3RcIik7XG4gIH0pKCksIGMgPSAoKCkgPT4ge1xuICAgIGlmIChlICYgMSlcbiAgICAgIHJldHVybiAwO1xuICAgIGlmIChlICYgMilcbiAgICAgIHJldHVybiBNYXRoLm1heCgwLCBhLmluZGV4T2YocikpIC0gMTtcbiAgICBpZiAoZSAmIDQpXG4gICAgICByZXR1cm4gTWF0aC5tYXgoMCwgYS5pbmRleE9mKHIpKSArIDE7XG4gICAgaWYgKGUgJiA4KVxuICAgICAgcmV0dXJuIGEubGVuZ3RoIC0gMTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIEZvY3VzLkZpcnN0LCBGb2N1cy5QcmV2aW91cywgRm9jdXMuTmV4dCBvciBGb2N1cy5MYXN0XCIpO1xuICB9KSgpLCB1ID0gZSAmIDMyID8geyBwcmV2ZW50U2Nyb2xsOiAhMCB9IDoge30sIGQgPSAwLCBmID0gYS5sZW5ndGgsIGg7XG4gIGRvIHtcbiAgICBpZiAoZCA+PSBmIHx8IGQgKyBmIDw9IDApXG4gICAgICByZXR1cm4gMDtcbiAgICBsZXQgcCA9IGMgKyBkO1xuICAgIGlmIChlICYgMTYpXG4gICAgICBwID0gKHAgKyBmKSAlIGY7XG4gICAgZWxzZSB7XG4gICAgICBpZiAocCA8IDApXG4gICAgICAgIHJldHVybiAzO1xuICAgICAgaWYgKHAgPj0gZilcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGggPSBhW3BdLCBoID09IG51bGwgfHwgaC5mb2N1cyh1KSwgZCArPSBsO1xuICB9IHdoaWxlIChoICE9PSBvLmFjdGl2ZUVsZW1lbnQpO1xuICByZXR1cm4gZSAmIDYgJiYgQVEoaCkgJiYgaC5zZWxlY3QoKSwgMjtcbn1cbmZ1bmN0aW9uIHZTKCkge1xuICByZXR1cm4gL2lQaG9uZS9naS50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm0pIHx8IC9NYWMvZ2kudGVzdCh3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtKSAmJiB3aW5kb3cubmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMDtcbn1cbmZ1bmN0aW9uIFJRKCkge1xuICByZXR1cm4gL0FuZHJvaWQvZ2kudGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG59XG5mdW5jdGlvbiBOUSgpIHtcbiAgcmV0dXJuIHZTKCkgfHwgUlEoKTtcbn1cbmZ1bmN0aW9uIHZjKHQsIGUsIG4pIHtcbiAgUWQuaXNTZXJ2ZXIgfHwgQm4oKHIpID0+IHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKHQsIGUsIG4pLCByKCgpID0+IGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodCwgZSwgbikpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHlTKHQsIGUsIG4pIHtcbiAgUWQuaXNTZXJ2ZXIgfHwgQm4oKHIpID0+IHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcih0LCBlLCBuKSwgcigoKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcih0LCBlLCBuKSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gU1ModCwgZSwgbiA9IGooKCkgPT4gITApKSB7XG4gIGZ1bmN0aW9uIHIocywgbykge1xuICAgIGlmICghbi52YWx1ZSB8fCBzLmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICByZXR1cm47XG4gICAgbGV0IGEgPSBvKHMpO1xuICAgIGlmIChhID09PSBudWxsIHx8ICFhLmdldFJvb3ROb2RlKCkuY29udGFpbnMoYSkpXG4gICAgICByZXR1cm47XG4gICAgbGV0IGwgPSBmdW5jdGlvbiBjKHUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdSA9PSBcImZ1bmN0aW9uXCIgPyBjKHUoKSkgOiBBcnJheS5pc0FycmF5KHUpIHx8IHUgaW5zdGFuY2VvZiBTZXQgPyB1IDogW3VdO1xuICAgIH0odCk7XG4gICAgZm9yIChsZXQgYyBvZiBsKSB7XG4gICAgICBpZiAoYyA9PT0gbnVsbClcbiAgICAgICAgY29udGludWU7XG4gICAgICBsZXQgdSA9IGMgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA/IGMgOiBwZShjKTtcbiAgICAgIGlmICh1ICE9IG51bGwgJiYgdS5jb250YWlucyhhKSB8fCBzLmNvbXBvc2VkICYmIHMuY29tcG9zZWRQYXRoKCkuaW5jbHVkZXModSkpXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuICFiUyhhLCBOTy5Mb29zZSkgJiYgYS50YWJJbmRleCAhPT0gLTEgJiYgcy5wcmV2ZW50RGVmYXVsdCgpLCBlKHMsIGEpO1xuICB9XG4gIGxldCBpID0gRyhudWxsKTtcbiAgdmMoXCJwb2ludGVyZG93blwiLCAocykgPT4ge1xuICAgIHZhciBvLCBhO1xuICAgIG4udmFsdWUgJiYgKGkudmFsdWUgPSAoKGEgPSAobyA9IHMuY29tcG9zZWRQYXRoKSA9PSBudWxsID8gdm9pZCAwIDogby5jYWxsKHMpKSA9PSBudWxsID8gdm9pZCAwIDogYVswXSkgfHwgcy50YXJnZXQpO1xuICB9LCAhMCksIHZjKFwibW91c2Vkb3duXCIsIChzKSA9PiB7XG4gICAgdmFyIG8sIGE7XG4gICAgbi52YWx1ZSAmJiAoaS52YWx1ZSA9ICgoYSA9IChvID0gcy5jb21wb3NlZFBhdGgpID09IG51bGwgPyB2b2lkIDAgOiBvLmNhbGwocykpID09IG51bGwgPyB2b2lkIDAgOiBhWzBdKSB8fCBzLnRhcmdldCk7XG4gIH0sICEwKSwgdmMoXCJjbGlja1wiLCAocykgPT4ge1xuICAgIE5RKCkgfHwgaS52YWx1ZSAmJiAocihzLCAoKSA9PiBpLnZhbHVlKSwgaS52YWx1ZSA9IG51bGwpO1xuICB9LCAhMCksIHZjKFwidG91Y2hlbmRcIiwgKHMpID0+IHIocywgKCkgPT4gcy50YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA/IHMudGFyZ2V0IDogbnVsbCksICEwKSwgeVMoXCJibHVyXCIsIChzKSA9PiByKHMsICgpID0+IHdpbmRvdy5kb2N1bWVudC5hY3RpdmVFbGVtZW50IGluc3RhbmNlb2YgSFRNTElGcmFtZUVsZW1lbnQgPyB3aW5kb3cuZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA6IG51bGwpLCAhMCk7XG59XG5mdW5jdGlvbiByYih0LCBlKSB7XG4gIGlmICh0KVxuICAgIHJldHVybiB0O1xuICBsZXQgbiA9IGUgPz8gXCJidXR0b25cIjtcbiAgaWYgKHR5cGVvZiBuID09IFwic3RyaW5nXCIgJiYgbi50b0xvd2VyQ2FzZSgpID09PSBcImJ1dHRvblwiKVxuICAgIHJldHVybiBcImJ1dHRvblwiO1xufVxuZnVuY3Rpb24gRE8odCwgZSkge1xuICBsZXQgbiA9IEcocmIodC52YWx1ZS50eXBlLCB0LnZhbHVlLmFzKSk7XG4gIHJldHVybiBldCgoKSA9PiB7XG4gICAgbi52YWx1ZSA9IHJiKHQudmFsdWUudHlwZSwgdC52YWx1ZS5hcyk7XG4gIH0pLCBCbigoKSA9PiB7XG4gICAgdmFyIHI7XG4gICAgbi52YWx1ZSB8fCBwZShlKSAmJiBwZShlKSBpbnN0YW5jZW9mIEhUTUxCdXR0b25FbGVtZW50ICYmICEoKHIgPSBwZShlKSkgIT0gbnVsbCAmJiByLmhhc0F0dHJpYnV0ZShcInR5cGVcIikpICYmIChuLnZhbHVlID0gXCJidXR0b25cIik7XG4gIH0pLCBuO1xufVxuZnVuY3Rpb24gaWIodCkge1xuICByZXR1cm4gW3Quc2NyZWVuWCwgdC5zY3JlZW5ZXTtcbn1cbmZ1bmN0aW9uIERRKCkge1xuICBsZXQgdCA9IEcoWy0xLCAtMV0pO1xuICByZXR1cm4geyB3YXNNb3ZlZChlKSB7XG4gICAgbGV0IG4gPSBpYihlKTtcbiAgICByZXR1cm4gdC52YWx1ZVswXSA9PT0gblswXSAmJiB0LnZhbHVlWzFdID09PSBuWzFdID8gITEgOiAodC52YWx1ZSA9IG4sICEwKTtcbiAgfSwgdXBkYXRlKGUpIHtcbiAgICB0LnZhbHVlID0gaWIoZSk7XG4gIH0gfTtcbn1cbnZhciBjaSA9ICgodCkgPT4gKHRbdC5Ob25lID0gMF0gPSBcIk5vbmVcIiwgdFt0LlJlbmRlclN0cmF0ZWd5ID0gMV0gPSBcIlJlbmRlclN0cmF0ZWd5XCIsIHRbdC5TdGF0aWMgPSAyXSA9IFwiU3RhdGljXCIsIHQpKShjaSB8fCB7fSksIFpRID0gKCh0KSA9PiAodFt0LlVubW91bnQgPSAwXSA9IFwiVW5tb3VudFwiLCB0W3QuSGlkZGVuID0gMV0gPSBcIkhpZGRlblwiLCB0KSkoWlEgfHwge30pO1xuZnVuY3Rpb24gRXQoeyB2aXNpYmxlOiB0ID0gITAsIGZlYXR1cmVzOiBlID0gMCwgb3VyUHJvcHM6IG4sIHRoZWlyUHJvcHM6IHIsIC4uLmkgfSkge1xuICB2YXIgcztcbiAgbGV0IG8gPSBrUyhyLCBuKSwgYSA9IE9iamVjdC5hc3NpZ24oaSwgeyBwcm9wczogbyB9KTtcbiAgaWYgKHQgfHwgZSAmIDIgJiYgby5zdGF0aWMpXG4gICAgcmV0dXJuIGdmKGEpO1xuICBpZiAoZSAmIDEpIHtcbiAgICBsZXQgbCA9IChzID0gby51bm1vdW50KSA9PSBudWxsIHx8IHMgPyAwIDogMTtcbiAgICByZXR1cm4gVHQobCwgeyAwKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSwgMSgpIHtcbiAgICAgIHJldHVybiBnZih7IC4uLmksIHByb3BzOiB7IC4uLm8sIGhpZGRlbjogITAsIHN0eWxlOiB7IGRpc3BsYXk6IFwibm9uZVwiIH0gfSB9KTtcbiAgICB9IH0pO1xuICB9XG4gIHJldHVybiBnZihhKTtcbn1cbmZ1bmN0aW9uIGdmKHsgcHJvcHM6IHQsIGF0dHJzOiBlLCBzbG90czogbiwgc2xvdDogciwgbmFtZTogaSB9KSB7XG4gIHZhciBzLCBvO1xuICBsZXQgeyBhczogYSwgLi4ubCB9ID0gWk8odCwgW1widW5tb3VudFwiLCBcInN0YXRpY1wiXSksIGMgPSAocyA9IG4uZGVmYXVsdCkgPT0gbnVsbCA/IHZvaWQgMCA6IHMuY2FsbChuLCByKSwgdSA9IHt9O1xuICBpZiAocikge1xuICAgIGxldCBkID0gITEsIGYgPSBbXTtcbiAgICBmb3IgKGxldCBbaCwgcF0gb2YgT2JqZWN0LmVudHJpZXMocikpXG4gICAgICB0eXBlb2YgcCA9PSBcImJvb2xlYW5cIiAmJiAoZCA9ICEwKSwgcCA9PT0gITAgJiYgZi5wdXNoKGgpO1xuICAgIGQgJiYgKHVbXCJkYXRhLWhlYWRsZXNzdWktc3RhdGVcIl0gPSBmLmpvaW4oXCIgXCIpKTtcbiAgfVxuICBpZiAoYSA9PT0gXCJ0ZW1wbGF0ZVwiKSB7XG4gICAgaWYgKGMgPSB3UyhjID8/IFtdKSwgT2JqZWN0LmtleXMobCkubGVuZ3RoID4gMCB8fCBPYmplY3Qua2V5cyhlKS5sZW5ndGggPiAwKSB7XG4gICAgICBsZXQgW2QsIC4uLmZdID0gYyA/PyBbXTtcbiAgICAgIGlmICghSVEoZCkgfHwgZi5sZW5ndGggPiAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoWydQYXNzaW5nIHByb3BzIG9uIFwidGVtcGxhdGVcIiEnLCBcIlwiLCBgVGhlIGN1cnJlbnQgY29tcG9uZW50IDwke2l9IC8+IGlzIHJlbmRlcmluZyBhIFwidGVtcGxhdGVcIi5gLCBcIkhvd2V2ZXIgd2UgbmVlZCB0byBwYXNzdGhyb3VnaCB0aGUgZm9sbG93aW5nIHByb3BzOlwiLCBPYmplY3Qua2V5cyhsKS5jb25jYXQoT2JqZWN0LmtleXMoZSkpLm1hcCgoTykgPT4gTy50cmltKCkpLmZpbHRlcigoTywgbSwgeSkgPT4geS5pbmRleE9mKE8pID09PSBtKS5zb3J0KChPLCBtKSA9PiBPLmxvY2FsZUNvbXBhcmUobSkpLm1hcCgoTykgPT4gYCAgLSAke099YCkuam9pbihgXG5gKSwgXCJcIiwgXCJZb3UgY2FuIGFwcGx5IGEgZmV3IHNvbHV0aW9uczpcIiwgWydBZGQgYW4gYGFzPVwiLi4uXCJgIHByb3AsIHRvIGVuc3VyZSB0aGF0IHdlIHJlbmRlciBhbiBhY3R1YWwgZWxlbWVudCBpbnN0ZWFkIG9mIGEgXCJ0ZW1wbGF0ZVwiLicsIFwiUmVuZGVyIGEgc2luZ2xlIGVsZW1lbnQgYXMgdGhlIGNoaWxkIHNvIHRoYXQgd2UgY2FuIGZvcndhcmQgdGhlIHByb3BzIG9udG8gdGhhdCBlbGVtZW50LlwiXS5tYXAoKE8pID0+IGAgIC0gJHtPfWApLmpvaW4oYFxuYCldLmpvaW4oYFxuYCkpO1xuICAgICAgbGV0IGggPSBrUygobyA9IGQucHJvcHMpICE9IG51bGwgPyBvIDoge30sIGwsIHUpLCBwID0gam4oZCwgaCwgITApO1xuICAgICAgZm9yIChsZXQgTyBpbiBoKVxuICAgICAgICBPLnN0YXJ0c1dpdGgoXCJvblwiKSAmJiAocC5wcm9wcyB8fCAocC5wcm9wcyA9IHt9KSwgcC5wcm9wc1tPXSA9IGhbT10pO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGMpICYmIGMubGVuZ3RoID09PSAxID8gY1swXSA6IGM7XG4gIH1cbiAgcmV0dXJuIGt0KGEsIE9iamVjdC5hc3NpZ24oe30sIGwsIHUpLCB7IGRlZmF1bHQ6ICgpID0+IGMgfSk7XG59XG5mdW5jdGlvbiB3Uyh0KSB7XG4gIHJldHVybiB0LmZsYXRNYXAoKGUpID0+IGUudHlwZSA9PT0gUGUgPyB3UyhlLmNoaWxkcmVuKSA6IFtlXSk7XG59XG5mdW5jdGlvbiBrUyguLi50KSB7XG4gIGlmICh0Lmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4ge307XG4gIGlmICh0Lmxlbmd0aCA9PT0gMSlcbiAgICByZXR1cm4gdFswXTtcbiAgbGV0IGUgPSB7fSwgbiA9IHt9O1xuICBmb3IgKGxldCByIG9mIHQpXG4gICAgZm9yIChsZXQgaSBpbiByKVxuICAgICAgaS5zdGFydHNXaXRoKFwib25cIikgJiYgdHlwZW9mIHJbaV0gPT0gXCJmdW5jdGlvblwiID8gKG5baV0gIT0gbnVsbCB8fCAobltpXSA9IFtdKSwgbltpXS5wdXNoKHJbaV0pKSA6IGVbaV0gPSByW2ldO1xuICBpZiAoZS5kaXNhYmxlZCB8fCBlW1wiYXJpYS1kaXNhYmxlZFwiXSlcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihlLCBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmtleXMobikubWFwKChyKSA9PiBbciwgdm9pZCAwXSkpKTtcbiAgZm9yIChsZXQgciBpbiBuKVxuICAgIE9iamVjdC5hc3NpZ24oZSwgeyBbcl0oaSwgLi4ucykge1xuICAgICAgbGV0IG8gPSBuW3JdO1xuICAgICAgZm9yIChsZXQgYSBvZiBvKSB7XG4gICAgICAgIGlmIChpIGluc3RhbmNlb2YgRXZlbnQgJiYgaS5kZWZhdWx0UHJldmVudGVkKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgYShpLCAuLi5zKTtcbiAgICAgIH1cbiAgICB9IH0pO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIFZRKHQpIHtcbiAgbGV0IGUgPSBPYmplY3QuYXNzaWduKHt9LCB0KTtcbiAgZm9yIChsZXQgbiBpbiBlKVxuICAgIGVbbl0gPT09IHZvaWQgMCAmJiBkZWxldGUgZVtuXTtcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBaTyh0LCBlID0gW10pIHtcbiAgbGV0IG4gPSBPYmplY3QuYXNzaWduKHt9LCB0KTtcbiAgZm9yIChsZXQgciBvZiBlKVxuICAgIHIgaW4gbiAmJiBkZWxldGUgbltyXTtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBJUSh0KSB7XG4gIHJldHVybiB0ID09IG51bGwgPyAhMSA6IHR5cGVvZiB0LnR5cGUgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdC50eXBlID09IFwib2JqZWN0XCIgfHwgdHlwZW9mIHQudHlwZSA9PSBcImZ1bmN0aW9uXCI7XG59XG52YXIgWm8gPSAoKHQpID0+ICh0W3QuTm9uZSA9IDFdID0gXCJOb25lXCIsIHRbdC5Gb2N1c2FibGUgPSAyXSA9IFwiRm9jdXNhYmxlXCIsIHRbdC5IaWRkZW4gPSA0XSA9IFwiSGlkZGVuXCIsIHQpKShabyB8fCB7fSk7XG5sZXQgVm8gPSAvKiBAX19QVVJFX18gKi8gbGUoeyBuYW1lOiBcIkhpZGRlblwiLCBwcm9wczogeyBhczogeyB0eXBlOiBbT2JqZWN0LCBTdHJpbmddLCBkZWZhdWx0OiBcImRpdlwiIH0sIGZlYXR1cmVzOiB7IHR5cGU6IE51bWJlciwgZGVmYXVsdDogMSB9IH0sIHNldHVwKHQsIHsgc2xvdHM6IGUsIGF0dHJzOiBuIH0pIHtcbiAgcmV0dXJuICgpID0+IHtcbiAgICB2YXIgcjtcbiAgICBsZXQgeyBmZWF0dXJlczogaSwgLi4ucyB9ID0gdCwgbyA9IHsgXCJhcmlhLWhpZGRlblwiOiAoaSAmIDIpID09PSAyID8gITAgOiAociA9IHNbXCJhcmlhLWhpZGRlblwiXSkgIT0gbnVsbCA/IHIgOiB2b2lkIDAsIGhpZGRlbjogKGkgJiA0KSA9PT0gNCA/ICEwIDogdm9pZCAwLCBzdHlsZTogeyBwb3NpdGlvbjogXCJmaXhlZFwiLCB0b3A6IDEsIGxlZnQ6IDEsIHdpZHRoOiAxLCBoZWlnaHQ6IDAsIHBhZGRpbmc6IDAsIG1hcmdpbjogLTEsIG92ZXJmbG93OiBcImhpZGRlblwiLCBjbGlwOiBcInJlY3QoMCwgMCwgMCwgMClcIiwgd2hpdGVTcGFjZTogXCJub3dyYXBcIiwgYm9yZGVyV2lkdGg6IFwiMFwiLCAuLi4oaSAmIDQpID09PSA0ICYmIChpICYgMikgIT09IDIgJiYgeyBkaXNwbGF5OiBcIm5vbmVcIiB9IH0gfTtcbiAgICByZXR1cm4gRXQoeyBvdXJQcm9wczogbywgdGhlaXJQcm9wczogcywgc2xvdDoge30sIGF0dHJzOiBuLCBzbG90czogZSwgbmFtZTogXCJIaWRkZW5cIiB9KTtcbiAgfTtcbn0gfSksIHhTID0gU3ltYm9sKFwiQ29udGV4dFwiKTtcbnZhciBJbiA9ICgodCkgPT4gKHRbdC5PcGVuID0gMV0gPSBcIk9wZW5cIiwgdFt0LkNsb3NlZCA9IDJdID0gXCJDbG9zZWRcIiwgdFt0LkNsb3NpbmcgPSA0XSA9IFwiQ2xvc2luZ1wiLCB0W3QuT3BlbmluZyA9IDhdID0gXCJPcGVuaW5nXCIsIHQpKShJbiB8fCB7fSk7XG5mdW5jdGlvbiBWTygpIHtcbiAgcmV0dXJuIFB0KHhTLCBudWxsKTtcbn1cbmZ1bmN0aW9uIFBTKHQpIHtcbiAgX24oeFMsIHQpO1xufVxudmFyIFhlID0gKCh0KSA9PiAodC5TcGFjZSA9IFwiIFwiLCB0LkVudGVyID0gXCJFbnRlclwiLCB0LkVzY2FwZSA9IFwiRXNjYXBlXCIsIHQuQmFja3NwYWNlID0gXCJCYWNrc3BhY2VcIiwgdC5EZWxldGUgPSBcIkRlbGV0ZVwiLCB0LkFycm93TGVmdCA9IFwiQXJyb3dMZWZ0XCIsIHQuQXJyb3dVcCA9IFwiQXJyb3dVcFwiLCB0LkFycm93UmlnaHQgPSBcIkFycm93UmlnaHRcIiwgdC5BcnJvd0Rvd24gPSBcIkFycm93RG93blwiLCB0LkhvbWUgPSBcIkhvbWVcIiwgdC5FbmQgPSBcIkVuZFwiLCB0LlBhZ2VVcCA9IFwiUGFnZVVwXCIsIHQuUGFnZURvd24gPSBcIlBhZ2VEb3duXCIsIHQuVGFiID0gXCJUYWJcIiwgdCkpKFhlIHx8IHt9KTtcbmZ1bmN0aW9uIFdRKHQpIHtcbiAgZnVuY3Rpb24gZSgpIHtcbiAgICBkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImxvYWRpbmdcIiAmJiAodCgpLCBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBlKSk7XG4gIH1cbiAgdHlwZW9mIHdpbmRvdyA8IFwidVwiICYmIHR5cGVvZiBkb2N1bWVudCA8IFwidVwiICYmIChkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBlKSwgZSgpKTtcbn1cbmxldCB5cyA9IFtdO1xuV1EoKCkgPT4ge1xuICBmdW5jdGlvbiB0KGUpIHtcbiAgICBlLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIGUudGFyZ2V0ICE9PSBkb2N1bWVudC5ib2R5ICYmIHlzWzBdICE9PSBlLnRhcmdldCAmJiAoeXMudW5zaGlmdChlLnRhcmdldCksIHlzID0geXMuZmlsdGVyKChuKSA9PiBuICE9IG51bGwgJiYgbi5pc0Nvbm5lY3RlZCksIHlzLnNwbGljZSgxMCkpO1xuICB9XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdCwgeyBjYXB0dXJlOiAhMCB9KSwgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdCwgeyBjYXB0dXJlOiAhMCB9KSwgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB0LCB7IGNhcHR1cmU6ICEwIH0pLCBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0LCB7IGNhcHR1cmU6ICEwIH0pLCBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdCwgeyBjYXB0dXJlOiAhMCB9KSwgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdCwgeyBjYXB0dXJlOiAhMCB9KTtcbn0pO1xuZnVuY3Rpb24gTVEodCkge1xuICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG9iamVjdDogXCIgKyB0KTtcbn1cbnZhciBobiA9ICgodCkgPT4gKHRbdC5GaXJzdCA9IDBdID0gXCJGaXJzdFwiLCB0W3QuUHJldmlvdXMgPSAxXSA9IFwiUHJldmlvdXNcIiwgdFt0Lk5leHQgPSAyXSA9IFwiTmV4dFwiLCB0W3QuTGFzdCA9IDNdID0gXCJMYXN0XCIsIHRbdC5TcGVjaWZpYyA9IDRdID0gXCJTcGVjaWZpY1wiLCB0W3QuTm90aGluZyA9IDVdID0gXCJOb3RoaW5nXCIsIHQpKShobiB8fCB7fSk7XG5mdW5jdGlvbiBYUSh0LCBlKSB7XG4gIGxldCBuID0gZS5yZXNvbHZlSXRlbXMoKTtcbiAgaWYgKG4ubGVuZ3RoIDw9IDApXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCByID0gZS5yZXNvbHZlQWN0aXZlSW5kZXgoKSwgaSA9IHIgPz8gLTE7XG4gIHN3aXRjaCAodC5mb2N1cykge1xuICAgIGNhc2UgMDoge1xuICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCBuLmxlbmd0aDsgKytzKVxuICAgICAgICBpZiAoIWUucmVzb2x2ZURpc2FibGVkKG5bc10sIHMsIG4pKVxuICAgICAgICAgIHJldHVybiBzO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIGNhc2UgMToge1xuICAgICAgaSA9PT0gLTEgJiYgKGkgPSBuLmxlbmd0aCk7XG4gICAgICBmb3IgKGxldCBzID0gaSAtIDE7IHMgPj0gMDsgLS1zKVxuICAgICAgICBpZiAoIWUucmVzb2x2ZURpc2FibGVkKG5bc10sIHMsIG4pKVxuICAgICAgICAgIHJldHVybiBzO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIGNhc2UgMjoge1xuICAgICAgZm9yIChsZXQgcyA9IGkgKyAxOyBzIDwgbi5sZW5ndGg7ICsrcylcbiAgICAgICAgaWYgKCFlLnJlc29sdmVEaXNhYmxlZChuW3NdLCBzLCBuKSlcbiAgICAgICAgICByZXR1cm4gcztcbiAgICAgIHJldHVybiByO1xuICAgIH1cbiAgICBjYXNlIDM6IHtcbiAgICAgIGZvciAobGV0IHMgPSBuLmxlbmd0aCAtIDE7IHMgPj0gMDsgLS1zKVxuICAgICAgICBpZiAoIWUucmVzb2x2ZURpc2FibGVkKG5bc10sIHMsIG4pKVxuICAgICAgICAgIHJldHVybiBzO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIGNhc2UgNDoge1xuICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCBuLmxlbmd0aDsgKytzKVxuICAgICAgICBpZiAoZS5yZXNvbHZlSWQobltzXSwgcywgbikgPT09IHQuaWQpXG4gICAgICAgICAgcmV0dXJuIHM7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgY2FzZSA1OlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgZGVmYXVsdDpcbiAgICAgIE1RKHQpO1xuICB9XG59XG5mdW5jdGlvbiBDZCh0KSB7XG4gIHR5cGVvZiBxdWV1ZU1pY3JvdGFzayA9PSBcImZ1bmN0aW9uXCIgPyBxdWV1ZU1pY3JvdGFzayh0KSA6IFByb21pc2UucmVzb2x2ZSgpLnRoZW4odCkuY2F0Y2goKGUpID0+IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIHRocm93IGU7XG4gIH0pKTtcbn1cbmZ1bmN0aW9uIElPKCkge1xuICBsZXQgdCA9IFtdLCBlID0geyBhZGRFdmVudExpc3RlbmVyKG4sIHIsIGksIHMpIHtcbiAgICByZXR1cm4gbi5hZGRFdmVudExpc3RlbmVyKHIsIGksIHMpLCBlLmFkZCgoKSA9PiBuLnJlbW92ZUV2ZW50TGlzdGVuZXIociwgaSwgcykpO1xuICB9LCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoLi4ubikge1xuICAgIGxldCByID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKC4uLm4pO1xuICAgIGUuYWRkKCgpID0+IGNhbmNlbEFuaW1hdGlvbkZyYW1lKHIpKTtcbiAgfSwgbmV4dEZyYW1lKC4uLm4pIHtcbiAgICBlLnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBlLnJlcXVlc3RBbmltYXRpb25GcmFtZSguLi5uKTtcbiAgICB9KTtcbiAgfSwgc2V0VGltZW91dCguLi5uKSB7XG4gICAgbGV0IHIgPSBzZXRUaW1lb3V0KC4uLm4pO1xuICAgIGUuYWRkKCgpID0+IGNsZWFyVGltZW91dChyKSk7XG4gIH0sIG1pY3JvVGFzayguLi5uKSB7XG4gICAgbGV0IHIgPSB7IGN1cnJlbnQ6ICEwIH07XG4gICAgcmV0dXJuIENkKCgpID0+IHtcbiAgICAgIHIuY3VycmVudCAmJiBuWzBdKCk7XG4gICAgfSksIGUuYWRkKCgpID0+IHtcbiAgICAgIHIuY3VycmVudCA9ICExO1xuICAgIH0pO1xuICB9LCBzdHlsZShuLCByLCBpKSB7XG4gICAgbGV0IHMgPSBuLnN0eWxlLmdldFByb3BlcnR5VmFsdWUocik7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obi5zdHlsZSwgeyBbcl06IGkgfSksIHRoaXMuYWRkKCgpID0+IHtcbiAgICAgIE9iamVjdC5hc3NpZ24obi5zdHlsZSwgeyBbcl06IHMgfSk7XG4gICAgfSk7XG4gIH0sIGdyb3VwKG4pIHtcbiAgICBsZXQgciA9IElPKCk7XG4gICAgcmV0dXJuIG4ociksIHRoaXMuYWRkKCgpID0+IHIuZGlzcG9zZSgpKTtcbiAgfSwgYWRkKG4pIHtcbiAgICByZXR1cm4gdC5wdXNoKG4pLCAoKSA9PiB7XG4gICAgICBsZXQgciA9IHQuaW5kZXhPZihuKTtcbiAgICAgIGlmIChyID49IDApXG4gICAgICAgIGZvciAobGV0IGkgb2YgdC5zcGxpY2UociwgMSkpXG4gICAgICAgICAgaSgpO1xuICAgIH07XG4gIH0sIGRpc3Bvc2UoKSB7XG4gICAgZm9yIChsZXQgbiBvZiB0LnNwbGljZSgwKSlcbiAgICAgIG4oKTtcbiAgfSB9O1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIF9TKHQgPSB7fSwgZSA9IG51bGwsIG4gPSBbXSkge1xuICBmb3IgKGxldCBbciwgaV0gb2YgT2JqZWN0LmVudHJpZXModCkpXG4gICAgRVMobiwgVFMoZSwgciksIGkpO1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIFRTKHQsIGUpIHtcbiAgcmV0dXJuIHQgPyB0ICsgXCJbXCIgKyBlICsgXCJdXCIgOiBlO1xufVxuZnVuY3Rpb24gRVModCwgZSwgbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShuKSlcbiAgICBmb3IgKGxldCBbciwgaV0gb2Ygbi5lbnRyaWVzKCkpXG4gICAgICBFUyh0LCBUUyhlLCByLnRvU3RyaW5nKCkpLCBpKTtcbiAgZWxzZVxuICAgIG4gaW5zdGFuY2VvZiBEYXRlID8gdC5wdXNoKFtlLCBuLnRvSVNPU3RyaW5nKCldKSA6IHR5cGVvZiBuID09IFwiYm9vbGVhblwiID8gdC5wdXNoKFtlLCBuID8gXCIxXCIgOiBcIjBcIl0pIDogdHlwZW9mIG4gPT0gXCJzdHJpbmdcIiA/IHQucHVzaChbZSwgbl0pIDogdHlwZW9mIG4gPT0gXCJudW1iZXJcIiA/IHQucHVzaChbZSwgYCR7bn1gXSkgOiBuID09IG51bGwgPyB0LnB1c2goW2UsIFwiXCJdKSA6IF9TKG4sIGUsIHQpO1xufVxuZnVuY3Rpb24gJFModCwgZSwgbiwgcikge1xuICBRZC5pc1NlcnZlciB8fCBCbigoaSkgPT4ge1xuICAgIHQgPSB0ID8/IHdpbmRvdywgdC5hZGRFdmVudExpc3RlbmVyKGUsIG4sIHIpLCBpKCgpID0+IHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLCBuLCByKSk7XG4gIH0pO1xufVxudmFyIEFhID0gKCh0KSA9PiAodFt0LkZvcndhcmRzID0gMF0gPSBcIkZvcndhcmRzXCIsIHRbdC5CYWNrd2FyZHMgPSAxXSA9IFwiQmFja3dhcmRzXCIsIHQpKShBYSB8fCB7fSk7XG5mdW5jdGlvbiBqUSgpIHtcbiAgbGV0IHQgPSBHKDApO1xuICByZXR1cm4geVMoXCJrZXlkb3duXCIsIChlKSA9PiB7XG4gICAgZS5rZXkgPT09IFwiVGFiXCIgJiYgKHQudmFsdWUgPSBlLnNoaWZ0S2V5ID8gMSA6IDApO1xuICB9KSwgdDtcbn1cbmZ1bmN0aW9uIFFTKHQpIHtcbiAgaWYgKCF0KVxuICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBpZiAodHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiBuZXcgU2V0KHQoKSk7XG4gIGxldCBlID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZm9yIChsZXQgbiBvZiB0LnZhbHVlKSB7XG4gICAgbGV0IHIgPSBwZShuKTtcbiAgICByIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgZS5hZGQocik7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG52YXIgQ1MgPSAoKHQpID0+ICh0W3QuTm9uZSA9IDFdID0gXCJOb25lXCIsIHRbdC5Jbml0aWFsRm9jdXMgPSAyXSA9IFwiSW5pdGlhbEZvY3VzXCIsIHRbdC5UYWJMb2NrID0gNF0gPSBcIlRhYkxvY2tcIiwgdFt0LkZvY3VzTG9jayA9IDhdID0gXCJGb2N1c0xvY2tcIiwgdFt0LlJlc3RvcmVGb2N1cyA9IDE2XSA9IFwiUmVzdG9yZUZvY3VzXCIsIHRbdC5BbGwgPSAzMF0gPSBcIkFsbFwiLCB0KSkoQ1MgfHwge30pO1xubGV0IHBhID0gT2JqZWN0LmFzc2lnbigvKiBAX19QVVJFX18gKi8gbGUoeyBuYW1lOiBcIkZvY3VzVHJhcFwiLCBwcm9wczogeyBhczogeyB0eXBlOiBbT2JqZWN0LCBTdHJpbmddLCBkZWZhdWx0OiBcImRpdlwiIH0sIGluaXRpYWxGb2N1czogeyB0eXBlOiBPYmplY3QsIGRlZmF1bHQ6IG51bGwgfSwgZmVhdHVyZXM6IHsgdHlwZTogTnVtYmVyLCBkZWZhdWx0OiAzMCB9LCBjb250YWluZXJzOiB7IHR5cGU6IFtPYmplY3QsIEZ1bmN0aW9uXSwgZGVmYXVsdDogRygvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKSB9IH0sIGluaGVyaXRBdHRyczogITEsIHNldHVwKHQsIHsgYXR0cnM6IGUsIHNsb3RzOiBuLCBleHBvc2U6IHIgfSkge1xuICBsZXQgaSA9IEcobnVsbCk7XG4gIHIoeyBlbDogaSwgJGVsOiBpIH0pO1xuICBsZXQgcyA9IGooKCkgPT4gdG8oaSkpLCBvID0gRyghMSk7XG4gIGV0KCgpID0+IG8udmFsdWUgPSAhMCksIGp0KCgpID0+IG8udmFsdWUgPSAhMSksIExRKHsgb3duZXJEb2N1bWVudDogcyB9LCBqKCgpID0+IG8udmFsdWUgJiYgISEodC5mZWF0dXJlcyAmIDE2KSkpO1xuICBsZXQgYSA9IFVRKHsgb3duZXJEb2N1bWVudDogcywgY29udGFpbmVyOiBpLCBpbml0aWFsRm9jdXM6IGooKCkgPT4gdC5pbml0aWFsRm9jdXMpIH0sIGooKCkgPT4gby52YWx1ZSAmJiAhISh0LmZlYXR1cmVzICYgMikpKTtcbiAgcVEoeyBvd25lckRvY3VtZW50OiBzLCBjb250YWluZXI6IGksIGNvbnRhaW5lcnM6IHQuY29udGFpbmVycywgcHJldmlvdXNBY3RpdmVFbGVtZW50OiBhIH0sIGooKCkgPT4gby52YWx1ZSAmJiAhISh0LmZlYXR1cmVzICYgOCkpKTtcbiAgbGV0IGwgPSBqUSgpO1xuICBmdW5jdGlvbiBjKGgpIHtcbiAgICBsZXQgcCA9IHBlKGkpO1xuICAgIHAgJiYgKChPKSA9PiBPKCkpKCgpID0+IHtcbiAgICAgIFR0KGwudmFsdWUsIHsgW0FhLkZvcndhcmRzXTogKCkgPT4ge1xuICAgICAgICBFcihwLCBXdC5GaXJzdCwgeyBza2lwRWxlbWVudHM6IFtoLnJlbGF0ZWRUYXJnZXRdIH0pO1xuICAgICAgfSwgW0FhLkJhY2t3YXJkc106ICgpID0+IHtcbiAgICAgICAgRXIocCwgV3QuTGFzdCwgeyBza2lwRWxlbWVudHM6IFtoLnJlbGF0ZWRUYXJnZXRdIH0pO1xuICAgICAgfSB9KTtcbiAgICB9KTtcbiAgfVxuICBsZXQgdSA9IEcoITEpO1xuICBmdW5jdGlvbiBkKGgpIHtcbiAgICBoLmtleSA9PT0gXCJUYWJcIiAmJiAodS52YWx1ZSA9ICEwLCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdS52YWx1ZSA9ICExO1xuICAgIH0pKTtcbiAgfVxuICBmdW5jdGlvbiBmKGgpIHtcbiAgICBpZiAoIW8udmFsdWUpXG4gICAgICByZXR1cm47XG4gICAgbGV0IHAgPSBRUyh0LmNvbnRhaW5lcnMpO1xuICAgIHBlKGkpIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgcC5hZGQocGUoaSkpO1xuICAgIGxldCBPID0gaC5yZWxhdGVkVGFyZ2V0O1xuICAgIE8gaW5zdGFuY2VvZiBIVE1MRWxlbWVudCAmJiBPLmRhdGFzZXQuaGVhZGxlc3N1aUZvY3VzR3VhcmQgIT09IFwidHJ1ZVwiICYmIChBUyhwLCBPKSB8fCAodS52YWx1ZSA/IEVyKHBlKGkpLCBUdChsLnZhbHVlLCB7IFtBYS5Gb3J3YXJkc106ICgpID0+IFd0Lk5leHQsIFtBYS5CYWNrd2FyZHNdOiAoKSA9PiBXdC5QcmV2aW91cyB9KSB8IFd0LldyYXBBcm91bmQsIHsgcmVsYXRpdmVUbzogaC50YXJnZXQgfSkgOiBoLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIFZzKGgudGFyZ2V0KSkpO1xuICB9XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbGV0IGggPSB7fSwgcCA9IHsgcmVmOiBpLCBvbktleWRvd246IGQsIG9uRm9jdXNvdXQ6IGYgfSwgeyBmZWF0dXJlczogTywgaW5pdGlhbEZvY3VzOiBtLCBjb250YWluZXJzOiB5LCAuLi5iIH0gPSB0O1xuICAgIHJldHVybiBrdChQZSwgWyEhKE8gJiA0KSAmJiBrdChWbywgeyBhczogXCJidXR0b25cIiwgdHlwZTogXCJidXR0b25cIiwgXCJkYXRhLWhlYWRsZXNzdWktZm9jdXMtZ3VhcmRcIjogITAsIG9uRm9jdXM6IGMsIGZlYXR1cmVzOiBaby5Gb2N1c2FibGUgfSksIEV0KHsgb3VyUHJvcHM6IHAsIHRoZWlyUHJvcHM6IHsgLi4uZSwgLi4uYiB9LCBzbG90OiBoLCBhdHRyczogZSwgc2xvdHM6IG4sIG5hbWU6IFwiRm9jdXNUcmFwXCIgfSksICEhKE8gJiA0KSAmJiBrdChWbywgeyBhczogXCJidXR0b25cIiwgdHlwZTogXCJidXR0b25cIiwgXCJkYXRhLWhlYWRsZXNzdWktZm9jdXMtZ3VhcmRcIjogITAsIG9uRm9jdXM6IGMsIGZlYXR1cmVzOiBaby5Gb2N1c2FibGUgfSldKTtcbiAgfTtcbn0gfSksIHsgZmVhdHVyZXM6IENTIH0pO1xuZnVuY3Rpb24gQlEodCkge1xuICBsZXQgZSA9IEcoeXMuc2xpY2UoKSk7XG4gIHJldHVybiBodChbdF0sIChbbl0sIFtyXSkgPT4ge1xuICAgIHIgPT09ICEwICYmIG4gPT09ICExID8gQ2QoKCkgPT4ge1xuICAgICAgZS52YWx1ZS5zcGxpY2UoMCk7XG4gICAgfSkgOiByID09PSAhMSAmJiBuID09PSAhMCAmJiAoZS52YWx1ZSA9IHlzLnNsaWNlKCkpO1xuICB9LCB7IGZsdXNoOiBcInBvc3RcIiB9KSwgKCkgPT4ge1xuICAgIHZhciBuO1xuICAgIHJldHVybiAobiA9IGUudmFsdWUuZmluZCgocikgPT4gciAhPSBudWxsICYmIHIuaXNDb25uZWN0ZWQpKSAhPSBudWxsID8gbiA6IG51bGw7XG4gIH07XG59XG5mdW5jdGlvbiBMUSh7IG93bmVyRG9jdW1lbnQ6IHQgfSwgZSkge1xuICBsZXQgbiA9IEJRKGUpO1xuICBldCgoKSA9PiB7XG4gICAgQm4oKCkgPT4ge1xuICAgICAgdmFyIHIsIGk7XG4gICAgICBlLnZhbHVlIHx8ICgociA9IHQudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiByLmFjdGl2ZUVsZW1lbnQpID09PSAoKGkgPSB0LnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogaS5ib2R5KSAmJiBWcyhuKCkpO1xuICAgIH0sIHsgZmx1c2g6IFwicG9zdFwiIH0pO1xuICB9KSwganQoKCkgPT4ge1xuICAgIGUudmFsdWUgJiYgVnMobigpKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBVUSh7IG93bmVyRG9jdW1lbnQ6IHQsIGNvbnRhaW5lcjogZSwgaW5pdGlhbEZvY3VzOiBuIH0sIHIpIHtcbiAgbGV0IGkgPSBHKG51bGwpLCBzID0gRyghMSk7XG4gIHJldHVybiBldCgoKSA9PiBzLnZhbHVlID0gITApLCBqdCgoKSA9PiBzLnZhbHVlID0gITEpLCBldCgoKSA9PiB7XG4gICAgaHQoW2UsIG4sIHJdLCAobywgYSkgPT4ge1xuICAgICAgaWYgKG8uZXZlcnkoKGMsIHUpID0+IChhID09IG51bGwgPyB2b2lkIDAgOiBhW3VdKSA9PT0gYykgfHwgIXIudmFsdWUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGxldCBsID0gcGUoZSk7XG4gICAgICBsICYmIENkKCgpID0+IHtcbiAgICAgICAgdmFyIGMsIHU7XG4gICAgICAgIGlmICghcy52YWx1ZSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBkID0gcGUobiksIGYgPSAoYyA9IHQudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBjLmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGlmIChkKSB7XG4gICAgICAgICAgaWYgKGQgPT09IGYpIHtcbiAgICAgICAgICAgIGkudmFsdWUgPSBmO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChsLmNvbnRhaW5zKGYpKSB7XG4gICAgICAgICAgaS52YWx1ZSA9IGY7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGQgPyBWcyhkKSA6IEVyKGwsIFd0LkZpcnN0IHwgV3QuTm9TY3JvbGwpID09PSBoby5FcnJvciAmJiBjb25zb2xlLndhcm4oXCJUaGVyZSBhcmUgbm8gZm9jdXNhYmxlIGVsZW1lbnRzIGluc2lkZSB0aGUgPEZvY3VzVHJhcCAvPlwiKSwgaS52YWx1ZSA9ICh1ID0gdC52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IHUuYWN0aXZlRWxlbWVudDtcbiAgICAgIH0pO1xuICAgIH0sIHsgaW1tZWRpYXRlOiAhMCwgZmx1c2g6IFwicG9zdFwiIH0pO1xuICB9KSwgaTtcbn1cbmZ1bmN0aW9uIHFRKHsgb3duZXJEb2N1bWVudDogdCwgY29udGFpbmVyOiBlLCBjb250YWluZXJzOiBuLCBwcmV2aW91c0FjdGl2ZUVsZW1lbnQ6IHIgfSwgaSkge1xuICB2YXIgcztcbiAgJFMoKHMgPSB0LnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogcy5kZWZhdWx0VmlldywgXCJmb2N1c1wiLCAobykgPT4ge1xuICAgIGlmICghaS52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBsZXQgYSA9IFFTKG4pO1xuICAgIHBlKGUpIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgYS5hZGQocGUoZSkpO1xuICAgIGxldCBsID0gci52YWx1ZTtcbiAgICBpZiAoIWwpXG4gICAgICByZXR1cm47XG4gICAgbGV0IGMgPSBvLnRhcmdldDtcbiAgICBjICYmIGMgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA/IEFTKGEsIGMpID8gKHIudmFsdWUgPSBjLCBWcyhjKSkgOiAoby5wcmV2ZW50RGVmYXVsdCgpLCBvLnN0b3BQcm9wYWdhdGlvbigpLCBWcyhsKSkgOiBWcyhyLnZhbHVlKTtcbiAgfSwgITApO1xufVxuZnVuY3Rpb24gQVModCwgZSkge1xuICBmb3IgKGxldCBuIG9mIHQpXG4gICAgaWYgKG4uY29udGFpbnMoZSkpXG4gICAgICByZXR1cm4gITA7XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIFlRKHQpIHtcbiAgbGV0IGUgPSBjTyh0LmdldFNuYXBzaG90KCkpO1xuICByZXR1cm4ganQodC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgIGUudmFsdWUgPSB0LmdldFNuYXBzaG90KCk7XG4gIH0pKSwgZTtcbn1cbmZ1bmN0aW9uIHpRKHQsIGUpIHtcbiAgbGV0IG4gPSB0KCksIHIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICByZXR1cm4geyBnZXRTbmFwc2hvdCgpIHtcbiAgICByZXR1cm4gbjtcbiAgfSwgc3Vic2NyaWJlKGkpIHtcbiAgICByZXR1cm4gci5hZGQoaSksICgpID0+IHIuZGVsZXRlKGkpO1xuICB9LCBkaXNwYXRjaChpLCAuLi5zKSB7XG4gICAgbGV0IG8gPSBlW2ldLmNhbGwobiwgLi4ucyk7XG4gICAgbyAmJiAobiA9IG8sIHIuZm9yRWFjaCgoYSkgPT4gYSgpKSk7XG4gIH0gfTtcbn1cbmZ1bmN0aW9uIEhRKCkge1xuICBsZXQgdDtcbiAgcmV0dXJuIHsgYmVmb3JlKHsgZG9jOiBlIH0pIHtcbiAgICB2YXIgbjtcbiAgICBsZXQgciA9IGUuZG9jdW1lbnRFbGVtZW50O1xuICAgIHQgPSAoKG4gPSBlLmRlZmF1bHRWaWV3KSAhPSBudWxsID8gbiA6IHdpbmRvdykuaW5uZXJXaWR0aCAtIHIuY2xpZW50V2lkdGg7XG4gIH0sIGFmdGVyKHsgZG9jOiBlLCBkOiBuIH0pIHtcbiAgICBsZXQgciA9IGUuZG9jdW1lbnRFbGVtZW50LCBpID0gci5jbGllbnRXaWR0aCAtIHIub2Zmc2V0V2lkdGgsIHMgPSB0IC0gaTtcbiAgICBuLnN0eWxlKHIsIFwicGFkZGluZ1JpZ2h0XCIsIGAke3N9cHhgKTtcbiAgfSB9O1xufVxuZnVuY3Rpb24gRlEoKSB7XG4gIHJldHVybiB2UygpID8geyBiZWZvcmUoeyBkb2M6IHQsIGQ6IGUsIG1ldGE6IG4gfSkge1xuICAgIGZ1bmN0aW9uIHIoaSkge1xuICAgICAgcmV0dXJuIG4uY29udGFpbmVycy5mbGF0TWFwKChzKSA9PiBzKCkpLnNvbWUoKHMpID0+IHMuY29udGFpbnMoaSkpO1xuICAgIH1cbiAgICBlLm1pY3JvVGFzaygoKSA9PiB7XG4gICAgICB2YXIgaTtcbiAgICAgIGlmICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0LmRvY3VtZW50RWxlbWVudCkuc2Nyb2xsQmVoYXZpb3IgIT09IFwiYXV0b1wiKSB7XG4gICAgICAgIGxldCBhID0gSU8oKTtcbiAgICAgICAgYS5zdHlsZSh0LmRvY3VtZW50RWxlbWVudCwgXCJzY3JvbGxCZWhhdmlvclwiLCBcImF1dG9cIiksIGUuYWRkKCgpID0+IGUubWljcm9UYXNrKCgpID0+IGEuZGlzcG9zZSgpKSk7XG4gICAgICB9XG4gICAgICBsZXQgcyA9IChpID0gd2luZG93LnNjcm9sbFkpICE9IG51bGwgPyBpIDogd2luZG93LnBhZ2VZT2Zmc2V0LCBvID0gbnVsbDtcbiAgICAgIGUuYWRkRXZlbnRMaXN0ZW5lcih0LCBcImNsaWNrXCIsIChhKSA9PiB7XG4gICAgICAgIGlmIChhLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgbCA9IGEudGFyZ2V0LmNsb3Nlc3QoXCJhXCIpO1xuICAgICAgICAgICAgaWYgKCFsKVxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgeyBoYXNoOiBjIH0gPSBuZXcgVVJMKGwuaHJlZiksIHUgPSB0LnF1ZXJ5U2VsZWN0b3IoYyk7XG4gICAgICAgICAgICB1ICYmICFyKHUpICYmIChvID0gdSk7XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgfVxuICAgICAgfSwgITApLCBlLmFkZEV2ZW50TGlzdGVuZXIodCwgXCJ0b3VjaHN0YXJ0XCIsIChhKSA9PiB7XG4gICAgICAgIGlmIChhLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KVxuICAgICAgICAgIGlmIChyKGEudGFyZ2V0KSkge1xuICAgICAgICAgICAgbGV0IGwgPSBhLnRhcmdldDtcbiAgICAgICAgICAgIGZvciAoOyBsLnBhcmVudEVsZW1lbnQgJiYgcihsLnBhcmVudEVsZW1lbnQpOyApXG4gICAgICAgICAgICAgIGwgPSBsLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgICBlLnN0eWxlKGwsIFwib3ZlcnNjcm9sbEJlaGF2aW9yXCIsIFwiY29udGFpblwiKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIGUuc3R5bGUoYS50YXJnZXQsIFwidG91Y2hBY3Rpb25cIiwgXCJub25lXCIpO1xuICAgICAgfSksIGUuYWRkRXZlbnRMaXN0ZW5lcih0LCBcInRvdWNobW92ZVwiLCAoYSkgPT4ge1xuICAgICAgICBpZiAoYS50YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudClcbiAgICAgICAgICBpZiAocihhLnRhcmdldCkpIHtcbiAgICAgICAgICAgIGxldCBsID0gYS50YXJnZXQ7XG4gICAgICAgICAgICBmb3IgKDsgbC5wYXJlbnRFbGVtZW50ICYmIGwuZGF0YXNldC5oZWFkbGVzc3VpUG9ydGFsICE9PSBcIlwiICYmICEobC5zY3JvbGxIZWlnaHQgPiBsLmNsaWVudEhlaWdodCB8fCBsLnNjcm9sbFdpZHRoID4gbC5jbGllbnRXaWR0aCk7IClcbiAgICAgICAgICAgICAgbCA9IGwucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIGwuZGF0YXNldC5oZWFkbGVzc3VpUG9ydGFsID09PSBcIlwiICYmIGEucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIGEucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0sIHsgcGFzc2l2ZTogITEgfSksIGUuYWRkKCgpID0+IHtcbiAgICAgICAgdmFyIGE7XG4gICAgICAgIGxldCBsID0gKGEgPSB3aW5kb3cuc2Nyb2xsWSkgIT0gbnVsbCA/IGEgOiB3aW5kb3cucGFnZVlPZmZzZXQ7XG4gICAgICAgIHMgIT09IGwgJiYgd2luZG93LnNjcm9sbFRvKDAsIHMpLCBvICYmIG8uaXNDb25uZWN0ZWQgJiYgKG8uc2Nyb2xsSW50b1ZpZXcoeyBibG9jazogXCJuZWFyZXN0XCIgfSksIG8gPSBudWxsKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9IH0gOiB7fTtcbn1cbmZ1bmN0aW9uIEdRKCkge1xuICByZXR1cm4geyBiZWZvcmUoeyBkb2M6IHQsIGQ6IGUgfSkge1xuICAgIGUuc3R5bGUodC5kb2N1bWVudEVsZW1lbnQsIFwib3ZlcmZsb3dcIiwgXCJoaWRkZW5cIik7XG4gIH0gfTtcbn1cbmZ1bmN0aW9uIEtRKHQpIHtcbiAgbGV0IGUgPSB7fTtcbiAgZm9yIChsZXQgbiBvZiB0KVxuICAgIE9iamVjdC5hc3NpZ24oZSwgbihlKSk7XG4gIHJldHVybiBlO1xufVxubGV0IGtzID0gelEoKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgeyBQVVNIKHQsIGUpIHtcbiAgdmFyIG47XG4gIGxldCByID0gKG4gPSB0aGlzLmdldCh0KSkgIT0gbnVsbCA/IG4gOiB7IGRvYzogdCwgY291bnQ6IDAsIGQ6IElPKCksIG1ldGE6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkgfTtcbiAgcmV0dXJuIHIuY291bnQrKywgci5tZXRhLmFkZChlKSwgdGhpcy5zZXQodCwgciksIHRoaXM7XG59LCBQT1AodCwgZSkge1xuICBsZXQgbiA9IHRoaXMuZ2V0KHQpO1xuICByZXR1cm4gbiAmJiAobi5jb3VudC0tLCBuLm1ldGEuZGVsZXRlKGUpKSwgdGhpcztcbn0sIFNDUk9MTF9QUkVWRU5UKHsgZG9jOiB0LCBkOiBlLCBtZXRhOiBuIH0pIHtcbiAgbGV0IHIgPSB7IGRvYzogdCwgZDogZSwgbWV0YTogS1EobikgfSwgaSA9IFtGUSgpLCBIUSgpLCBHUSgpXTtcbiAgaS5mb3JFYWNoKCh7IGJlZm9yZTogcyB9KSA9PiBzID09IG51bGwgPyB2b2lkIDAgOiBzKHIpKSwgaS5mb3JFYWNoKCh7IGFmdGVyOiBzIH0pID0+IHMgPT0gbnVsbCA/IHZvaWQgMCA6IHMocikpO1xufSwgU0NST0xMX0FMTE9XKHsgZDogdCB9KSB7XG4gIHQuZGlzcG9zZSgpO1xufSwgVEVBUkRPV04oeyBkb2M6IHQgfSkge1xuICB0aGlzLmRlbGV0ZSh0KTtcbn0gfSk7XG5rcy5zdWJzY3JpYmUoKCkgPT4ge1xuICBsZXQgdCA9IGtzLmdldFNuYXBzaG90KCksIGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBmb3IgKGxldCBbbl0gb2YgdClcbiAgICBlLnNldChuLCBuLmRvY3VtZW50RWxlbWVudC5zdHlsZS5vdmVyZmxvdyk7XG4gIGZvciAobGV0IG4gb2YgdC52YWx1ZXMoKSkge1xuICAgIGxldCByID0gZS5nZXQobi5kb2MpID09PSBcImhpZGRlblwiLCBpID0gbi5jb3VudCAhPT0gMDtcbiAgICAoaSAmJiAhciB8fCAhaSAmJiByKSAmJiBrcy5kaXNwYXRjaChuLmNvdW50ID4gMCA/IFwiU0NST0xMX1BSRVZFTlRcIiA6IFwiU0NST0xMX0FMTE9XXCIsIG4pLCBuLmNvdW50ID09PSAwICYmIGtzLmRpc3BhdGNoKFwiVEVBUkRPV05cIiwgbik7XG4gIH1cbn0pO1xuZnVuY3Rpb24gSlEodCwgZSwgbikge1xuICBsZXQgciA9IFlRKGtzKSwgaSA9IGooKCkgPT4ge1xuICAgIGxldCBzID0gdC52YWx1ZSA/IHIudmFsdWUuZ2V0KHQudmFsdWUpIDogdm9pZCAwO1xuICAgIHJldHVybiBzID8gcy5jb3VudCA+IDAgOiAhMTtcbiAgfSk7XG4gIHJldHVybiBodChbdCwgZV0sIChbcywgb10sIFthXSwgbCkgPT4ge1xuICAgIGlmICghcyB8fCAhbylcbiAgICAgIHJldHVybjtcbiAgICBrcy5kaXNwYXRjaChcIlBVU0hcIiwgcywgbik7XG4gICAgbGV0IGMgPSAhMTtcbiAgICBsKCgpID0+IHtcbiAgICAgIGMgfHwgKGtzLmRpc3BhdGNoKFwiUE9QXCIsIGEgPz8gcywgbiksIGMgPSAhMCk7XG4gICAgfSk7XG4gIH0sIHsgaW1tZWRpYXRlOiAhMCB9KSwgaTtcbn1cbmxldCBtZiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIE9hID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmZ1bmN0aW9uIHNiKHQsIGUgPSBHKCEwKSkge1xuICBCbigobikgPT4ge1xuICAgIHZhciByO1xuICAgIGlmICghZS52YWx1ZSlcbiAgICAgIHJldHVybjtcbiAgICBsZXQgaSA9IHBlKHQpO1xuICAgIGlmICghaSlcbiAgICAgIHJldHVybjtcbiAgICBuKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG87XG4gICAgICBpZiAoIWkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGxldCBhID0gKG8gPSBPYS5nZXQoaSkpICE9IG51bGwgPyBvIDogMTtcbiAgICAgIGlmIChhID09PSAxID8gT2EuZGVsZXRlKGkpIDogT2Euc2V0KGksIGEgLSAxKSwgYSAhPT0gMSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbGV0IGwgPSBtZi5nZXQoaSk7XG4gICAgICBsICYmIChsW1wiYXJpYS1oaWRkZW5cIl0gPT09IG51bGwgPyBpLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIpIDogaS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBsW1wiYXJpYS1oaWRkZW5cIl0pLCBpLmluZXJ0ID0gbC5pbmVydCwgbWYuZGVsZXRlKGkpKTtcbiAgICB9KTtcbiAgICBsZXQgcyA9IChyID0gT2EuZ2V0KGkpKSAhPSBudWxsID8gciA6IDA7XG4gICAgT2Euc2V0KGksIHMgKyAxKSwgcyA9PT0gMCAmJiAobWYuc2V0KGksIHsgXCJhcmlhLWhpZGRlblwiOiBpLmdldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIpLCBpbmVydDogaS5pbmVydCB9KSwgaS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWhpZGRlblwiLCBcInRydWVcIiksIGkuaW5lcnQgPSAhMCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZUMoeyBkZWZhdWx0Q29udGFpbmVyczogdCA9IFtdLCBwb3J0YWxzOiBlLCBtYWluVHJlZU5vZGVSZWY6IG4gfSA9IHt9KSB7XG4gIGxldCByID0gRyhudWxsKSwgaSA9IHRvKHIpO1xuICBmdW5jdGlvbiBzKCkge1xuICAgIHZhciBvLCBhLCBsO1xuICAgIGxldCBjID0gW107XG4gICAgZm9yIChsZXQgdSBvZiB0KVxuICAgICAgdSAhPT0gbnVsbCAmJiAodSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ID8gYy5wdXNoKHUpIDogXCJ2YWx1ZVwiIGluIHUgJiYgdS52YWx1ZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIGMucHVzaCh1LnZhbHVlKSk7XG4gICAgaWYgKGUgIT0gbnVsbCAmJiBlLnZhbHVlKVxuICAgICAgZm9yIChsZXQgdSBvZiBlLnZhbHVlKVxuICAgICAgICBjLnB1c2godSk7XG4gICAgZm9yIChsZXQgdSBvZiAobyA9IGkgPT0gbnVsbCA/IHZvaWQgMCA6IGkucXVlcnlTZWxlY3RvckFsbChcImh0bWwgPiAqLCBib2R5ID4gKlwiKSkgIT0gbnVsbCA/IG8gOiBbXSlcbiAgICAgIHUgIT09IGRvY3VtZW50LmJvZHkgJiYgdSAhPT0gZG9jdW1lbnQuaGVhZCAmJiB1IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgJiYgdS5pZCAhPT0gXCJoZWFkbGVzc3VpLXBvcnRhbC1yb290XCIgJiYgKHUuY29udGFpbnMocGUocikpIHx8IHUuY29udGFpbnMoKGwgPSAoYSA9IHBlKHIpKSA9PSBudWxsID8gdm9pZCAwIDogYS5nZXRSb290Tm9kZSgpKSA9PSBudWxsID8gdm9pZCAwIDogbC5ob3N0KSB8fCBjLnNvbWUoKGQpID0+IHUuY29udGFpbnMoZCkpIHx8IGMucHVzaCh1KSk7XG4gICAgcmV0dXJuIGM7XG4gIH1cbiAgcmV0dXJuIHsgcmVzb2x2ZUNvbnRhaW5lcnM6IHMsIGNvbnRhaW5zKG8pIHtcbiAgICByZXR1cm4gcygpLnNvbWUoKGEpID0+IGEuY29udGFpbnMobykpO1xuICB9LCBtYWluVHJlZU5vZGVSZWY6IHIsIE1haW5UcmVlTm9kZSgpIHtcbiAgICByZXR1cm4gbiAhPSBudWxsID8gbnVsbCA6IGt0KFZvLCB7IGZlYXR1cmVzOiBaby5IaWRkZW4sIHJlZjogciB9KTtcbiAgfSB9O1xufVxubGV0IFJTID0gU3ltYm9sKFwiRm9yY2VQb3J0YWxSb290Q29udGV4dFwiKTtcbmZ1bmN0aW9uIHRDKCkge1xuICByZXR1cm4gUHQoUlMsICExKTtcbn1cbmxldCBvYiA9IC8qIEBfX1BVUkVfXyAqLyBsZSh7IG5hbWU6IFwiRm9yY2VQb3J0YWxSb290XCIsIHByb3BzOiB7IGFzOiB7IHR5cGU6IFtPYmplY3QsIFN0cmluZ10sIGRlZmF1bHQ6IFwidGVtcGxhdGVcIiB9LCBmb3JjZTogeyB0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiAhMSB9IH0sIHNldHVwKHQsIHsgc2xvdHM6IGUsIGF0dHJzOiBuIH0pIHtcbiAgcmV0dXJuIF9uKFJTLCB0LmZvcmNlKSwgKCkgPT4ge1xuICAgIGxldCB7IGZvcmNlOiByLCAuLi5pIH0gPSB0O1xuICAgIHJldHVybiBFdCh7IHRoZWlyUHJvcHM6IGksIG91clByb3BzOiB7fSwgc2xvdDoge30sIHNsb3RzOiBlLCBhdHRyczogbiwgbmFtZTogXCJGb3JjZVBvcnRhbFJvb3RcIiB9KTtcbiAgfTtcbn0gfSksIE5TID0gU3ltYm9sKFwiU3RhY2tDb250ZXh0XCIpO1xudmFyIENoID0gKCh0KSA9PiAodFt0LkFkZCA9IDBdID0gXCJBZGRcIiwgdFt0LlJlbW92ZSA9IDFdID0gXCJSZW1vdmVcIiwgdCkpKENoIHx8IHt9KTtcbmZ1bmN0aW9uIG5DKCkge1xuICByZXR1cm4gUHQoTlMsICgpID0+IHtcbiAgfSk7XG59XG5mdW5jdGlvbiByQyh7IHR5cGU6IHQsIGVuYWJsZWQ6IGUsIGVsZW1lbnQ6IG4sIG9uVXBkYXRlOiByIH0pIHtcbiAgbGV0IGkgPSBuQygpO1xuICBmdW5jdGlvbiBzKC4uLm8pIHtcbiAgICByID09IG51bGwgfHwgciguLi5vKSwgaSguLi5vKTtcbiAgfVxuICBldCgoKSA9PiB7XG4gICAgaHQoZSwgKG8sIGEpID0+IHtcbiAgICAgIG8gPyBzKDAsIHQsIG4pIDogYSA9PT0gITAgJiYgcygxLCB0LCBuKTtcbiAgICB9LCB7IGltbWVkaWF0ZTogITAsIGZsdXNoOiBcInN5bmNcIiB9KTtcbiAgfSksIGp0KCgpID0+IHtcbiAgICBlLnZhbHVlICYmIHMoMSwgdCwgbik7XG4gIH0pLCBfbihOUywgcyk7XG59XG5sZXQgRFMgPSBTeW1ib2woXCJEZXNjcmlwdGlvbkNvbnRleHRcIik7XG5mdW5jdGlvbiBpQygpIHtcbiAgbGV0IHQgPSBQdChEUywgbnVsbCk7XG4gIGlmICh0ID09PSBudWxsKVxuICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgcGFyZW50XCIpO1xuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIHNDKHsgc2xvdDogdCA9IEcoe30pLCBuYW1lOiBlID0gXCJEZXNjcmlwdGlvblwiLCBwcm9wczogbiA9IHt9IH0gPSB7fSkge1xuICBsZXQgciA9IEcoW10pO1xuICBmdW5jdGlvbiBpKHMpIHtcbiAgICByZXR1cm4gci52YWx1ZS5wdXNoKHMpLCAoKSA9PiB7XG4gICAgICBsZXQgbyA9IHIudmFsdWUuaW5kZXhPZihzKTtcbiAgICAgIG8gIT09IC0xICYmIHIudmFsdWUuc3BsaWNlKG8sIDEpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIF9uKERTLCB7IHJlZ2lzdGVyOiBpLCBzbG90OiB0LCBuYW1lOiBlLCBwcm9wczogbiB9KSwgaigoKSA9PiByLnZhbHVlLmxlbmd0aCA+IDAgPyByLnZhbHVlLmpvaW4oXCIgXCIpIDogdm9pZCAwKTtcbn1cbmxldCBvQyA9IC8qIEBfX1BVUkVfXyAqLyBsZSh7IG5hbWU6IFwiRGVzY3JpcHRpb25cIiwgcHJvcHM6IHsgYXM6IHsgdHlwZTogW09iamVjdCwgU3RyaW5nXSwgZGVmYXVsdDogXCJwXCIgfSwgaWQ6IHsgdHlwZTogU3RyaW5nLCBkZWZhdWx0OiBudWxsIH0gfSwgc2V0dXAodCwgeyBhdHRyczogZSwgc2xvdHM6IG4gfSkge1xuICB2YXIgcjtcbiAgbGV0IGkgPSAociA9IHQuaWQpICE9IG51bGwgPyByIDogYGhlYWRsZXNzdWktZGVzY3JpcHRpb24tJHttcigpfWAsIHMgPSBpQygpO1xuICByZXR1cm4gZXQoKCkgPT4ganQocy5yZWdpc3RlcihpKSkpLCAoKSA9PiB7XG4gICAgbGV0IHsgbmFtZTogbyA9IFwiRGVzY3JpcHRpb25cIiwgc2xvdDogYSA9IEcoe30pLCBwcm9wczogbCA9IHt9IH0gPSBzLCB7IC4uLmMgfSA9IHQsIHUgPSB7IC4uLk9iamVjdC5lbnRyaWVzKGwpLnJlZHVjZSgoZCwgW2YsIGhdKSA9PiBPYmplY3QuYXNzaWduKGQsIHsgW2ZdOiBSKGgpIH0pLCB7fSksIGlkOiBpIH07XG4gICAgcmV0dXJuIEV0KHsgb3VyUHJvcHM6IHUsIHRoZWlyUHJvcHM6IGMsIHNsb3Q6IGEudmFsdWUsIGF0dHJzOiBlLCBzbG90czogbiwgbmFtZTogbyB9KTtcbiAgfTtcbn0gfSk7XG5mdW5jdGlvbiBhQyh0KSB7XG4gIGxldCBlID0gdG8odCk7XG4gIGlmICghZSkge1xuICAgIGlmICh0ID09PSBudWxsKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBbSGVhZGxlc3MgVUldOiBDYW5ub3QgZmluZCBvd25lckRvY3VtZW50IGZvciBjb250ZXh0RWxlbWVudDogJHt0fWApO1xuICB9XG4gIGxldCBuID0gZS5nZXRFbGVtZW50QnlJZChcImhlYWRsZXNzdWktcG9ydGFsLXJvb3RcIik7XG4gIGlmIChuKVxuICAgIHJldHVybiBuO1xuICBsZXQgciA9IGUuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgcmV0dXJuIHIuc2V0QXR0cmlidXRlKFwiaWRcIiwgXCJoZWFkbGVzc3VpLXBvcnRhbC1yb290XCIpLCBlLmJvZHkuYXBwZW5kQ2hpbGQocik7XG59XG5sZXQgbEMgPSAvKiBAX19QVVJFX18gKi8gbGUoeyBuYW1lOiBcIlBvcnRhbFwiLCBwcm9wczogeyBhczogeyB0eXBlOiBbT2JqZWN0LCBTdHJpbmddLCBkZWZhdWx0OiBcImRpdlwiIH0gfSwgc2V0dXAodCwgeyBzbG90czogZSwgYXR0cnM6IG4gfSkge1xuICBsZXQgciA9IEcobnVsbCksIGkgPSBqKCgpID0+IHRvKHIpKSwgcyA9IHRDKCksIG8gPSBQdChaUywgbnVsbCksIGEgPSBHKHMgPT09ICEwIHx8IG8gPT0gbnVsbCA/IGFDKHIudmFsdWUpIDogby5yZXNvbHZlVGFyZ2V0KCkpLCBsID0gRyghMSk7XG4gIGV0KCgpID0+IHtcbiAgICBsLnZhbHVlID0gITA7XG4gIH0pLCBCbigoKSA9PiB7XG4gICAgcyB8fCBvICE9IG51bGwgJiYgKGEudmFsdWUgPSBvLnJlc29sdmVUYXJnZXQoKSk7XG4gIH0pO1xuICBsZXQgYyA9IFB0KEFoLCBudWxsKSwgdSA9ICExLCBkID0gaXIoKTtcbiAgcmV0dXJuIGh0KHIsICgpID0+IHtcbiAgICBpZiAodSB8fCAhYylcbiAgICAgIHJldHVybjtcbiAgICBsZXQgZiA9IHBlKHIpO1xuICAgIGYgJiYgKGp0KGMucmVnaXN0ZXIoZiksIGQpLCB1ID0gITApO1xuICB9KSwganQoKCkgPT4ge1xuICAgIHZhciBmLCBoO1xuICAgIGxldCBwID0gKGYgPSBpLnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogZi5nZXRFbGVtZW50QnlJZChcImhlYWRsZXNzdWktcG9ydGFsLXJvb3RcIik7XG4gICAgcCAmJiBhLnZhbHVlID09PSBwICYmIGEudmFsdWUuY2hpbGRyZW4ubGVuZ3RoIDw9IDAgJiYgKChoID0gYS52YWx1ZS5wYXJlbnRFbGVtZW50KSA9PSBudWxsIHx8IGgucmVtb3ZlQ2hpbGQoYS52YWx1ZSkpO1xuICB9KSwgKCkgPT4ge1xuICAgIGlmICghbC52YWx1ZSB8fCBhLnZhbHVlID09PSBudWxsKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGYgPSB7IHJlZjogciwgXCJkYXRhLWhlYWRsZXNzdWktcG9ydGFsXCI6IFwiXCIgfTtcbiAgICByZXR1cm4ga3QoVE8sIHsgdG86IGEudmFsdWUgfSwgRXQoeyBvdXJQcm9wczogZiwgdGhlaXJQcm9wczogdCwgc2xvdDoge30sIGF0dHJzOiBuLCBzbG90czogZSwgbmFtZTogXCJQb3J0YWxcIiB9KSk7XG4gIH07XG59IH0pLCBBaCA9IFN5bWJvbChcIlBvcnRhbFBhcmVudENvbnRleHRcIik7XG5mdW5jdGlvbiBjQygpIHtcbiAgbGV0IHQgPSBQdChBaCwgbnVsbCksIGUgPSBHKFtdKTtcbiAgZnVuY3Rpb24gbihzKSB7XG4gICAgcmV0dXJuIGUudmFsdWUucHVzaChzKSwgdCAmJiB0LnJlZ2lzdGVyKHMpLCAoKSA9PiByKHMpO1xuICB9XG4gIGZ1bmN0aW9uIHIocykge1xuICAgIGxldCBvID0gZS52YWx1ZS5pbmRleE9mKHMpO1xuICAgIG8gIT09IC0xICYmIGUudmFsdWUuc3BsaWNlKG8sIDEpLCB0ICYmIHQudW5yZWdpc3RlcihzKTtcbiAgfVxuICBsZXQgaSA9IHsgcmVnaXN0ZXI6IG4sIHVucmVnaXN0ZXI6IHIsIHBvcnRhbHM6IGUgfTtcbiAgcmV0dXJuIFtlLCAvKiBAX19QVVJFX18gKi8gbGUoeyBuYW1lOiBcIlBvcnRhbFdyYXBwZXJcIiwgc2V0dXAocywgeyBzbG90czogbyB9KSB7XG4gICAgcmV0dXJuIF9uKEFoLCBpKSwgKCkgPT4ge1xuICAgICAgdmFyIGE7XG4gICAgICByZXR1cm4gKGEgPSBvLmRlZmF1bHQpID09IG51bGwgPyB2b2lkIDAgOiBhLmNhbGwobyk7XG4gICAgfTtcbiAgfSB9KV07XG59XG5sZXQgWlMgPSBTeW1ib2woXCJQb3J0YWxHcm91cENvbnRleHRcIiksIHVDID0gLyogQF9fUFVSRV9fICovIGxlKHsgbmFtZTogXCJQb3J0YWxHcm91cFwiLCBwcm9wczogeyBhczogeyB0eXBlOiBbT2JqZWN0LCBTdHJpbmddLCBkZWZhdWx0OiBcInRlbXBsYXRlXCIgfSwgdGFyZ2V0OiB7IHR5cGU6IE9iamVjdCwgZGVmYXVsdDogbnVsbCB9IH0sIHNldHVwKHQsIHsgYXR0cnM6IGUsIHNsb3RzOiBuIH0pIHtcbiAgbGV0IHIgPSBYbih7IHJlc29sdmVUYXJnZXQoKSB7XG4gICAgcmV0dXJuIHQudGFyZ2V0O1xuICB9IH0pO1xuICByZXR1cm4gX24oWlMsIHIpLCAoKSA9PiB7XG4gICAgbGV0IHsgdGFyZ2V0OiBpLCAuLi5zIH0gPSB0O1xuICAgIHJldHVybiBFdCh7IHRoZWlyUHJvcHM6IHMsIG91clByb3BzOiB7fSwgc2xvdDoge30sIGF0dHJzOiBlLCBzbG90czogbiwgbmFtZTogXCJQb3J0YWxHcm91cFwiIH0pO1xuICB9O1xufSB9KTtcbnZhciBkQyA9ICgodCkgPT4gKHRbdC5PcGVuID0gMF0gPSBcIk9wZW5cIiwgdFt0LkNsb3NlZCA9IDFdID0gXCJDbG9zZWRcIiwgdCkpKGRDIHx8IHt9KTtcbmxldCBSaCA9IFN5bWJvbChcIkRpYWxvZ0NvbnRleHRcIik7XG5mdW5jdGlvbiBXTyh0KSB7XG4gIGxldCBlID0gUHQoUmgsIG51bGwpO1xuICBpZiAoZSA9PT0gbnVsbCkge1xuICAgIGxldCBuID0gbmV3IEVycm9yKGA8JHt0fSAvPiBpcyBtaXNzaW5nIGEgcGFyZW50IDxEaWFsb2cgLz4gY29tcG9uZW50LmApO1xuICAgIHRocm93IEVycm9yLmNhcHR1cmVTdGFja1RyYWNlICYmIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKG4sIFdPKSwgbjtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmxldCB5YyA9IFwiREM4Rjg5MkQtMkVCRC00NDdDLUE0QzgtQTAzMDU4NDM2RkY0XCIsIGZDID0gLyogQF9fUFVSRV9fICovIGxlKHsgbmFtZTogXCJEaWFsb2dcIiwgaW5oZXJpdEF0dHJzOiAhMSwgcHJvcHM6IHsgYXM6IHsgdHlwZTogW09iamVjdCwgU3RyaW5nXSwgZGVmYXVsdDogXCJkaXZcIiB9LCBzdGF0aWM6IHsgdHlwZTogQm9vbGVhbiwgZGVmYXVsdDogITEgfSwgdW5tb3VudDogeyB0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiAhMCB9LCBvcGVuOiB7IHR5cGU6IFtCb29sZWFuLCBTdHJpbmddLCBkZWZhdWx0OiB5YyB9LCBpbml0aWFsRm9jdXM6IHsgdHlwZTogT2JqZWN0LCBkZWZhdWx0OiBudWxsIH0sIGlkOiB7IHR5cGU6IFN0cmluZywgZGVmYXVsdDogbnVsbCB9LCByb2xlOiB7IHR5cGU6IFN0cmluZywgZGVmYXVsdDogXCJkaWFsb2dcIiB9IH0sIGVtaXRzOiB7IGNsb3NlOiAodCkgPT4gITAgfSwgc2V0dXAodCwgeyBlbWl0OiBlLCBhdHRyczogbiwgc2xvdHM6IHIsIGV4cG9zZTogaSB9KSB7XG4gIHZhciBzLCBvO1xuICBsZXQgYSA9IChzID0gdC5pZCkgIT0gbnVsbCA/IHMgOiBgaGVhZGxlc3N1aS1kaWFsb2ctJHttcigpfWAsIGwgPSBHKCExKTtcbiAgZXQoKCkgPT4ge1xuICAgIGwudmFsdWUgPSAhMDtcbiAgfSk7XG4gIGxldCBjID0gITEsIHUgPSBqKCgpID0+IHQucm9sZSA9PT0gXCJkaWFsb2dcIiB8fCB0LnJvbGUgPT09IFwiYWxlcnRkaWFsb2dcIiA/IHQucm9sZSA6IChjIHx8IChjID0gITAsIGNvbnNvbGUud2FybihgSW52YWxpZCByb2xlIFske3V9XSBwYXNzZWQgdG8gPERpYWxvZyAvPi4gT25seSBcXGBkaWFsb2dcXGAgYW5kIGFuZCBcXGBhbGVydGRpYWxvZ1xcYCBhcmUgc3VwcG9ydGVkLiBVc2luZyBcXGBkaWFsb2dcXGAgaW5zdGVhZC5gKSksIFwiZGlhbG9nXCIpKSwgZCA9IEcoMCksIGYgPSBWTygpLCBoID0gaigoKSA9PiB0Lm9wZW4gPT09IHljICYmIGYgIT09IG51bGwgPyAoZi52YWx1ZSAmIEluLk9wZW4pID09PSBJbi5PcGVuIDogdC5vcGVuKSwgcCA9IEcobnVsbCksIE8gPSBqKCgpID0+IHRvKHApKTtcbiAgaWYgKGkoeyBlbDogcCwgJGVsOiBwIH0pLCAhKHQub3BlbiAhPT0geWMgfHwgZiAhPT0gbnVsbCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGZvcmdvdCB0byBwcm92aWRlIGFuIGBvcGVuYCBwcm9wIHRvIHRoZSBgRGlhbG9nYC5cIik7XG4gIGlmICh0eXBlb2YgaC52YWx1ZSAhPSBcImJvb2xlYW5cIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBwcm92aWRlZCBhbiBcXGBvcGVuXFxgIHByb3AgdG8gdGhlIFxcYERpYWxvZ1xcYCwgYnV0IHRoZSB2YWx1ZSBpcyBub3QgYSBib29sZWFuLiBSZWNlaXZlZDogJHtoLnZhbHVlID09PSB5YyA/IHZvaWQgMCA6IHQub3Blbn1gKTtcbiAgbGV0IG0gPSBqKCgpID0+IGwudmFsdWUgJiYgaC52YWx1ZSA/IDAgOiAxKSwgeSA9IGooKCkgPT4gbS52YWx1ZSA9PT0gMCksIGIgPSBqKCgpID0+IGQudmFsdWUgPiAxKSwgZyA9IFB0KFJoLCBudWxsKSAhPT0gbnVsbCwgW3YsIFNdID0gY0MoKSwgeyByZXNvbHZlQ29udGFpbmVyczogdywgbWFpblRyZWVOb2RlUmVmOiBrLCBNYWluVHJlZU5vZGU6IF8gfSA9IGVDKHsgcG9ydGFsczogdiwgZGVmYXVsdENvbnRhaW5lcnM6IFtqKCgpID0+IHtcbiAgICB2YXIgdWU7XG4gICAgcmV0dXJuICh1ZSA9IEsucGFuZWxSZWYudmFsdWUpICE9IG51bGwgPyB1ZSA6IHAudmFsdWU7XG4gIH0pXSB9KSwgVCA9IGooKCkgPT4gYi52YWx1ZSA/IFwicGFyZW50XCIgOiBcImxlYWZcIiksIEMgPSBqKCgpID0+IGYgIT09IG51bGwgPyAoZi52YWx1ZSAmIEluLkNsb3NpbmcpID09PSBJbi5DbG9zaW5nIDogITEpLCBBID0gaigoKSA9PiBnIHx8IEMudmFsdWUgPyAhMSA6IHkudmFsdWUpLCBRID0gaigoKSA9PiB7XG4gICAgdmFyIHVlLCBnZSwgQmU7XG4gICAgcmV0dXJuIChCZSA9IEFycmF5LmZyb20oKGdlID0gKHVlID0gTy52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IHVlLnF1ZXJ5U2VsZWN0b3JBbGwoXCJib2R5ID4gKlwiKSkgIT0gbnVsbCA/IGdlIDogW10pLmZpbmQoKExlKSA9PiBMZS5pZCA9PT0gXCJoZWFkbGVzc3VpLXBvcnRhbC1yb290XCIgPyAhMSA6IExlLmNvbnRhaW5zKHBlKGspKSAmJiBMZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkgIT0gbnVsbCA/IEJlIDogbnVsbDtcbiAgfSk7XG4gIHNiKFEsIEEpO1xuICBsZXQgVyA9IGooKCkgPT4gYi52YWx1ZSA/ICEwIDogeS52YWx1ZSksIEwgPSBqKCgpID0+IHtcbiAgICB2YXIgdWUsIGdlLCBCZTtcbiAgICByZXR1cm4gKEJlID0gQXJyYXkuZnJvbSgoZ2UgPSAodWUgPSBPLnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogdWUucXVlcnlTZWxlY3RvckFsbChcIltkYXRhLWhlYWRsZXNzdWktcG9ydGFsXVwiKSkgIT0gbnVsbCA/IGdlIDogW10pLmZpbmQoKExlKSA9PiBMZS5jb250YWlucyhwZShrKSkgJiYgTGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpICE9IG51bGwgPyBCZSA6IG51bGw7XG4gIH0pO1xuICBzYihMLCBXKSwgckMoeyB0eXBlOiBcIkRpYWxvZ1wiLCBlbmFibGVkOiBqKCgpID0+IG0udmFsdWUgPT09IDApLCBlbGVtZW50OiBwLCBvblVwZGF0ZTogKHVlLCBnZSkgPT4ge1xuICAgIGlmIChnZSA9PT0gXCJEaWFsb2dcIilcbiAgICAgIHJldHVybiBUdCh1ZSwgeyBbQ2guQWRkXTogKCkgPT4gZC52YWx1ZSArPSAxLCBbQ2guUmVtb3ZlXTogKCkgPT4gZC52YWx1ZSAtPSAxIH0pO1xuICB9IH0pO1xuICBsZXQgcmUgPSBzQyh7IG5hbWU6IFwiRGlhbG9nRGVzY3JpcHRpb25cIiwgc2xvdDogaigoKSA9PiAoeyBvcGVuOiBoLnZhbHVlIH0pKSB9KSwgWSA9IEcobnVsbCksIEsgPSB7IHRpdGxlSWQ6IFksIHBhbmVsUmVmOiBHKG51bGwpLCBkaWFsb2dTdGF0ZTogbSwgc2V0VGl0bGVJZCh1ZSkge1xuICAgIFkudmFsdWUgIT09IHVlICYmIChZLnZhbHVlID0gdWUpO1xuICB9LCBjbG9zZSgpIHtcbiAgICBlKFwiY2xvc2VcIiwgITEpO1xuICB9IH07XG4gIF9uKFJoLCBLKTtcbiAgbGV0IEIgPSBqKCgpID0+ICEoIXkudmFsdWUgfHwgYi52YWx1ZSkpO1xuICBTUyh3LCAodWUsIGdlKSA9PiB7XG4gICAgdWUucHJldmVudERlZmF1bHQoKSwgSy5jbG9zZSgpLCBQbigoKSA9PiBnZSA9PSBudWxsID8gdm9pZCAwIDogZ2UuZm9jdXMoKSk7XG4gIH0sIEIpO1xuICBsZXQgX2UgPSBqKCgpID0+ICEoYi52YWx1ZSB8fCBtLnZhbHVlICE9PSAwKSk7XG4gICRTKChvID0gTy52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IG8uZGVmYXVsdFZpZXcsIFwia2V5ZG93blwiLCAodWUpID0+IHtcbiAgICBfZS52YWx1ZSAmJiAodWUuZGVmYXVsdFByZXZlbnRlZCB8fCB1ZS5rZXkgPT09IFhlLkVzY2FwZSAmJiAodWUucHJldmVudERlZmF1bHQoKSwgdWUuc3RvcFByb3BhZ2F0aW9uKCksIEsuY2xvc2UoKSkpO1xuICB9KTtcbiAgbGV0IENlID0gaigoKSA9PiAhKEMudmFsdWUgfHwgbS52YWx1ZSAhPT0gMCB8fCBnKSk7XG4gIHJldHVybiBKUShPLCBDZSwgKHVlKSA9PiB7XG4gICAgdmFyIGdlO1xuICAgIHJldHVybiB7IGNvbnRhaW5lcnM6IFsuLi4oZ2UgPSB1ZS5jb250YWluZXJzKSAhPSBudWxsID8gZ2UgOiBbXSwgd10gfTtcbiAgfSksIEJuKCh1ZSkgPT4ge1xuICAgIGlmIChtLnZhbHVlICE9PSAwKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCBnZSA9IHBlKHApO1xuICAgIGlmICghZ2UpXG4gICAgICByZXR1cm47XG4gICAgbGV0IEJlID0gbmV3IFJlc2l6ZU9ic2VydmVyKChMZSkgPT4ge1xuICAgICAgZm9yIChsZXQgWnQgb2YgTGUpIHtcbiAgICAgICAgbGV0IFZ0ID0gWnQudGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBWdC54ID09PSAwICYmIFZ0LnkgPT09IDAgJiYgVnQud2lkdGggPT09IDAgJiYgVnQuaGVpZ2h0ID09PSAwICYmIEsuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBCZS5vYnNlcnZlKGdlKSwgdWUoKCkgPT4gQmUuZGlzY29ubmVjdCgpKTtcbiAgfSksICgpID0+IHtcbiAgICBsZXQgeyBvcGVuOiB1ZSwgaW5pdGlhbEZvY3VzOiBnZSwgLi4uQmUgfSA9IHQsIExlID0geyAuLi5uLCByZWY6IHAsIGlkOiBhLCByb2xlOiB1LnZhbHVlLCBcImFyaWEtbW9kYWxcIjogbS52YWx1ZSA9PT0gMCA/ICEwIDogdm9pZCAwLCBcImFyaWEtbGFiZWxsZWRieVwiOiBZLnZhbHVlLCBcImFyaWEtZGVzY3JpYmVkYnlcIjogcmUudmFsdWUgfSwgWnQgPSB7IG9wZW46IG0udmFsdWUgPT09IDAgfTtcbiAgICByZXR1cm4ga3Qob2IsIHsgZm9yY2U6ICEwIH0sICgpID0+IFtrdChsQywgKCkgPT4ga3QodUMsIHsgdGFyZ2V0OiBwLnZhbHVlIH0sICgpID0+IGt0KG9iLCB7IGZvcmNlOiAhMSB9LCAoKSA9PiBrdChwYSwgeyBpbml0aWFsRm9jdXM6IGdlLCBjb250YWluZXJzOiB3LCBmZWF0dXJlczogeS52YWx1ZSA/IFR0KFQudmFsdWUsIHsgcGFyZW50OiBwYS5mZWF0dXJlcy5SZXN0b3JlRm9jdXMsIGxlYWY6IHBhLmZlYXR1cmVzLkFsbCAmIH5wYS5mZWF0dXJlcy5Gb2N1c0xvY2sgfSkgOiBwYS5mZWF0dXJlcy5Ob25lIH0sICgpID0+IGt0KFMsIHt9LCAoKSA9PiBFdCh7IG91clByb3BzOiBMZSwgdGhlaXJQcm9wczogeyAuLi5CZSwgLi4ubiB9LCBzbG90OiBadCwgYXR0cnM6IG4sIHNsb3RzOiByLCB2aXNpYmxlOiBtLnZhbHVlID09PSAwLCBmZWF0dXJlczogY2kuUmVuZGVyU3RyYXRlZ3kgfCBjaS5TdGF0aWMsIG5hbWU6IFwiRGlhbG9nXCIgfSkpKSkpKSwga3QoXyldKTtcbiAgfTtcbn0gfSksIGhDID0gLyogQF9fUFVSRV9fICovIGxlKHsgbmFtZTogXCJEaWFsb2dQYW5lbFwiLCBwcm9wczogeyBhczogeyB0eXBlOiBbT2JqZWN0LCBTdHJpbmddLCBkZWZhdWx0OiBcImRpdlwiIH0sIGlkOiB7IHR5cGU6IFN0cmluZywgZGVmYXVsdDogbnVsbCB9IH0sIHNldHVwKHQsIHsgYXR0cnM6IGUsIHNsb3RzOiBuLCBleHBvc2U6IHIgfSkge1xuICB2YXIgaTtcbiAgbGV0IHMgPSAoaSA9IHQuaWQpICE9IG51bGwgPyBpIDogYGhlYWRsZXNzdWktZGlhbG9nLXBhbmVsLSR7bXIoKX1gLCBvID0gV08oXCJEaWFsb2dQYW5lbFwiKTtcbiAgcih7IGVsOiBvLnBhbmVsUmVmLCAkZWw6IG8ucGFuZWxSZWYgfSk7XG4gIGZ1bmN0aW9uIGEobCkge1xuICAgIGwuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cbiAgcmV0dXJuICgpID0+IHtcbiAgICBsZXQgeyAuLi5sIH0gPSB0LCBjID0geyBpZDogcywgcmVmOiBvLnBhbmVsUmVmLCBvbkNsaWNrOiBhIH07XG4gICAgcmV0dXJuIEV0KHsgb3VyUHJvcHM6IGMsIHRoZWlyUHJvcHM6IGwsIHNsb3Q6IHsgb3Blbjogby5kaWFsb2dTdGF0ZS52YWx1ZSA9PT0gMCB9LCBhdHRyczogZSwgc2xvdHM6IG4sIG5hbWU6IFwiRGlhbG9nUGFuZWxcIiB9KTtcbiAgfTtcbn0gfSksIHBDID0gLyogQF9fUFVSRV9fICovIGxlKHsgbmFtZTogXCJEaWFsb2dUaXRsZVwiLCBwcm9wczogeyBhczogeyB0eXBlOiBbT2JqZWN0LCBTdHJpbmddLCBkZWZhdWx0OiBcImgyXCIgfSwgaWQ6IHsgdHlwZTogU3RyaW5nLCBkZWZhdWx0OiBudWxsIH0gfSwgc2V0dXAodCwgeyBhdHRyczogZSwgc2xvdHM6IG4gfSkge1xuICB2YXIgcjtcbiAgbGV0IGkgPSAociA9IHQuaWQpICE9IG51bGwgPyByIDogYGhlYWRsZXNzdWktZGlhbG9nLXRpdGxlLSR7bXIoKX1gLCBzID0gV08oXCJEaWFsb2dUaXRsZVwiKTtcbiAgcmV0dXJuIGV0KCgpID0+IHtcbiAgICBzLnNldFRpdGxlSWQoaSksIGp0KCgpID0+IHMuc2V0VGl0bGVJZChudWxsKSk7XG4gIH0pLCAoKSA9PiB7XG4gICAgbGV0IHsgLi4ubyB9ID0gdDtcbiAgICByZXR1cm4gRXQoeyBvdXJQcm9wczogeyBpZDogaSB9LCB0aGVpclByb3BzOiBvLCBzbG90OiB7IG9wZW46IHMuZGlhbG9nU3RhdGUudmFsdWUgPT09IDAgfSwgYXR0cnM6IGUsIHNsb3RzOiBuLCBuYW1lOiBcIkRpYWxvZ1RpdGxlXCIgfSk7XG4gIH07XG59IH0pLCBPQyA9IG9DO1xudmFyIGdDID0gKCh0KSA9PiAodFt0Lk9wZW4gPSAwXSA9IFwiT3BlblwiLCB0W3QuQ2xvc2VkID0gMV0gPSBcIkNsb3NlZFwiLCB0KSkoZ0MgfHwge30pO1xubGV0IFZTID0gU3ltYm9sKFwiRGlzY2xvc3VyZUNvbnRleHRcIik7XG5mdW5jdGlvbiBNTyh0KSB7XG4gIGxldCBlID0gUHQoVlMsIG51bGwpO1xuICBpZiAoZSA9PT0gbnVsbCkge1xuICAgIGxldCBuID0gbmV3IEVycm9yKGA8JHt0fSAvPiBpcyBtaXNzaW5nIGEgcGFyZW50IDxEaXNjbG9zdXJlIC8+IGNvbXBvbmVudC5gKTtcbiAgICB0aHJvdyBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSAmJiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShuLCBNTyksIG47XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5sZXQgSVMgPSBTeW1ib2woXCJEaXNjbG9zdXJlUGFuZWxDb250ZXh0XCIpO1xuZnVuY3Rpb24gbUMoKSB7XG4gIHJldHVybiBQdChJUywgbnVsbCk7XG59XG5sZXQgYkMgPSAvKiBAX19QVVJFX18gKi8gbGUoeyBuYW1lOiBcIkRpc2Nsb3N1cmVcIiwgcHJvcHM6IHsgYXM6IHsgdHlwZTogW09iamVjdCwgU3RyaW5nXSwgZGVmYXVsdDogXCJ0ZW1wbGF0ZVwiIH0sIGRlZmF1bHRPcGVuOiB7IHR5cGU6IFtCb29sZWFuXSwgZGVmYXVsdDogITEgfSB9LCBzZXR1cCh0LCB7IHNsb3RzOiBlLCBhdHRyczogbiB9KSB7XG4gIGxldCByID0gRyh0LmRlZmF1bHRPcGVuID8gMCA6IDEpLCBpID0gRyhudWxsKSwgcyA9IEcobnVsbCksIG8gPSB7IGJ1dHRvbklkOiBHKGBoZWFkbGVzc3VpLWRpc2Nsb3N1cmUtYnV0dG9uLSR7bXIoKX1gKSwgcGFuZWxJZDogRyhgaGVhZGxlc3N1aS1kaXNjbG9zdXJlLXBhbmVsLSR7bXIoKX1gKSwgZGlzY2xvc3VyZVN0YXRlOiByLCBwYW5lbDogaSwgYnV0dG9uOiBzLCB0b2dnbGVEaXNjbG9zdXJlKCkge1xuICAgIHIudmFsdWUgPSBUdChyLnZhbHVlLCB7IDA6IDEsIDE6IDAgfSk7XG4gIH0sIGNsb3NlRGlzY2xvc3VyZSgpIHtcbiAgICByLnZhbHVlICE9PSAxICYmIChyLnZhbHVlID0gMSk7XG4gIH0sIGNsb3NlKGEpIHtcbiAgICBvLmNsb3NlRGlzY2xvc3VyZSgpO1xuICAgIGxldCBsID0gYSA/IGEgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCA/IGEgOiBhLnZhbHVlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgPyBwZShhKSA6IHBlKG8uYnV0dG9uKSA6IHBlKG8uYnV0dG9uKTtcbiAgICBsID09IG51bGwgfHwgbC5mb2N1cygpO1xuICB9IH07XG4gIHJldHVybiBfbihWUywgbyksIFBTKGooKCkgPT4gVHQoci52YWx1ZSwgeyAwOiBJbi5PcGVuLCAxOiBJbi5DbG9zZWQgfSkpKSwgKCkgPT4ge1xuICAgIGxldCB7IGRlZmF1bHRPcGVuOiBhLCAuLi5sIH0gPSB0LCBjID0geyBvcGVuOiByLnZhbHVlID09PSAwLCBjbG9zZTogby5jbG9zZSB9O1xuICAgIHJldHVybiBFdCh7IHRoZWlyUHJvcHM6IGwsIG91clByb3BzOiB7fSwgc2xvdDogYywgc2xvdHM6IGUsIGF0dHJzOiBuLCBuYW1lOiBcIkRpc2Nsb3N1cmVcIiB9KTtcbiAgfTtcbn0gfSksIHZDID0gLyogQF9fUFVSRV9fICovIGxlKHsgbmFtZTogXCJEaXNjbG9zdXJlQnV0dG9uXCIsIHByb3BzOiB7IGFzOiB7IHR5cGU6IFtPYmplY3QsIFN0cmluZ10sIGRlZmF1bHQ6IFwiYnV0dG9uXCIgfSwgZGlzYWJsZWQ6IHsgdHlwZTogW0Jvb2xlYW5dLCBkZWZhdWx0OiAhMSB9LCBpZDogeyB0eXBlOiBTdHJpbmcsIGRlZmF1bHQ6IG51bGwgfSB9LCBzZXR1cCh0LCB7IGF0dHJzOiBlLCBzbG90czogbiwgZXhwb3NlOiByIH0pIHtcbiAgbGV0IGkgPSBNTyhcIkRpc2Nsb3N1cmVCdXR0b25cIiksIHMgPSBtQygpLCBvID0gaigoKSA9PiBzID09PSBudWxsID8gITEgOiBzLnZhbHVlID09PSBpLnBhbmVsSWQudmFsdWUpO1xuICBldCgoKSA9PiB7XG4gICAgby52YWx1ZSB8fCB0LmlkICE9PSBudWxsICYmIChpLmJ1dHRvbklkLnZhbHVlID0gdC5pZCk7XG4gIH0pLCBqdCgoKSA9PiB7XG4gICAgby52YWx1ZSB8fCAoaS5idXR0b25JZC52YWx1ZSA9IG51bGwpO1xuICB9KTtcbiAgbGV0IGEgPSBHKG51bGwpO1xuICByKHsgZWw6IGEsICRlbDogYSB9KSwgby52YWx1ZSB8fCBCbigoKSA9PiB7XG4gICAgaS5idXR0b24udmFsdWUgPSBhLnZhbHVlO1xuICB9KTtcbiAgbGV0IGwgPSBETyhqKCgpID0+ICh7IGFzOiB0LmFzLCB0eXBlOiBlLnR5cGUgfSkpLCBhKTtcbiAgZnVuY3Rpb24gYygpIHtcbiAgICB2YXIgZjtcbiAgICB0LmRpc2FibGVkIHx8IChvLnZhbHVlID8gKGkudG9nZ2xlRGlzY2xvc3VyZSgpLCAoZiA9IHBlKGkuYnV0dG9uKSkgPT0gbnVsbCB8fCBmLmZvY3VzKCkpIDogaS50b2dnbGVEaXNjbG9zdXJlKCkpO1xuICB9XG4gIGZ1bmN0aW9uIHUoZikge1xuICAgIHZhciBoO1xuICAgIGlmICghdC5kaXNhYmxlZClcbiAgICAgIGlmIChvLnZhbHVlKVxuICAgICAgICBzd2l0Y2ggKGYua2V5KSB7XG4gICAgICAgICAgY2FzZSBYZS5TcGFjZTpcbiAgICAgICAgICBjYXNlIFhlLkVudGVyOlxuICAgICAgICAgICAgZi5wcmV2ZW50RGVmYXVsdCgpLCBmLnN0b3BQcm9wYWdhdGlvbigpLCBpLnRvZ2dsZURpc2Nsb3N1cmUoKSwgKGggPSBwZShpLmJ1dHRvbikpID09IG51bGwgfHwgaC5mb2N1cygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGVsc2VcbiAgICAgICAgc3dpdGNoIChmLmtleSkge1xuICAgICAgICAgIGNhc2UgWGUuU3BhY2U6XG4gICAgICAgICAgY2FzZSBYZS5FbnRlcjpcbiAgICAgICAgICAgIGYucHJldmVudERlZmF1bHQoKSwgZi5zdG9wUHJvcGFnYXRpb24oKSwgaS50b2dnbGVEaXNjbG9zdXJlKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICB9XG4gIGZ1bmN0aW9uIGQoZikge1xuICAgIHN3aXRjaCAoZi5rZXkpIHtcbiAgICAgIGNhc2UgWGUuU3BhY2U6XG4gICAgICAgIGYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiAoKSA9PiB7XG4gICAgdmFyIGY7XG4gICAgbGV0IGggPSB7IG9wZW46IGkuZGlzY2xvc3VyZVN0YXRlLnZhbHVlID09PSAwIH0sIHsgaWQ6IHAsIC4uLk8gfSA9IHQsIG0gPSBvLnZhbHVlID8geyByZWY6IGEsIHR5cGU6IGwudmFsdWUsIG9uQ2xpY2s6IGMsIG9uS2V5ZG93bjogdSB9IDogeyBpZDogKGYgPSBpLmJ1dHRvbklkLnZhbHVlKSAhPSBudWxsID8gZiA6IHAsIHJlZjogYSwgdHlwZTogbC52YWx1ZSwgXCJhcmlhLWV4cGFuZGVkXCI6IGkuZGlzY2xvc3VyZVN0YXRlLnZhbHVlID09PSAwLCBcImFyaWEtY29udHJvbHNcIjogaS5kaXNjbG9zdXJlU3RhdGUudmFsdWUgPT09IDAgfHwgcGUoaS5wYW5lbCkgPyBpLnBhbmVsSWQudmFsdWUgOiB2b2lkIDAsIGRpc2FibGVkOiB0LmRpc2FibGVkID8gITAgOiB2b2lkIDAsIG9uQ2xpY2s6IGMsIG9uS2V5ZG93bjogdSwgb25LZXl1cDogZCB9O1xuICAgIHJldHVybiBFdCh7IG91clByb3BzOiBtLCB0aGVpclByb3BzOiBPLCBzbG90OiBoLCBhdHRyczogZSwgc2xvdHM6IG4sIG5hbWU6IFwiRGlzY2xvc3VyZUJ1dHRvblwiIH0pO1xuICB9O1xufSB9KSwgeUMgPSAvKiBAX19QVVJFX18gKi8gbGUoeyBuYW1lOiBcIkRpc2Nsb3N1cmVQYW5lbFwiLCBwcm9wczogeyBhczogeyB0eXBlOiBbT2JqZWN0LCBTdHJpbmddLCBkZWZhdWx0OiBcImRpdlwiIH0sIHN0YXRpYzogeyB0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiAhMSB9LCB1bm1vdW50OiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6ICEwIH0sIGlkOiB7IHR5cGU6IFN0cmluZywgZGVmYXVsdDogbnVsbCB9IH0sIHNldHVwKHQsIHsgYXR0cnM6IGUsIHNsb3RzOiBuLCBleHBvc2U6IHIgfSkge1xuICBsZXQgaSA9IE1PKFwiRGlzY2xvc3VyZVBhbmVsXCIpO1xuICBldCgoKSA9PiB7XG4gICAgdC5pZCAhPT0gbnVsbCAmJiAoaS5wYW5lbElkLnZhbHVlID0gdC5pZCk7XG4gIH0pLCBqdCgoKSA9PiB7XG4gICAgaS5wYW5lbElkLnZhbHVlID0gbnVsbDtcbiAgfSksIHIoeyBlbDogaS5wYW5lbCwgJGVsOiBpLnBhbmVsIH0pLCBfbihJUywgaS5wYW5lbElkKTtcbiAgbGV0IHMgPSBWTygpLCBvID0gaigoKSA9PiBzICE9PSBudWxsID8gKHMudmFsdWUgJiBJbi5PcGVuKSA9PT0gSW4uT3BlbiA6IGkuZGlzY2xvc3VyZVN0YXRlLnZhbHVlID09PSAwKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICB2YXIgYTtcbiAgICBsZXQgbCA9IHsgb3BlbjogaS5kaXNjbG9zdXJlU3RhdGUudmFsdWUgPT09IDAsIGNsb3NlOiBpLmNsb3NlIH0sIHsgaWQ6IGMsIC4uLnUgfSA9IHQsIGQgPSB7IGlkOiAoYSA9IGkucGFuZWxJZC52YWx1ZSkgIT0gbnVsbCA/IGEgOiBjLCByZWY6IGkucGFuZWwgfTtcbiAgICByZXR1cm4gRXQoeyBvdXJQcm9wczogZCwgdGhlaXJQcm9wczogdSwgc2xvdDogbCwgYXR0cnM6IGUsIHNsb3RzOiBuLCBmZWF0dXJlczogY2kuUmVuZGVyU3RyYXRlZ3kgfCBjaS5TdGF0aWMsIHZpc2libGU6IG8udmFsdWUsIG5hbWU6IFwiRGlzY2xvc3VyZVBhbmVsXCIgfSk7XG4gIH07XG59IH0pLCBhYiA9IC8oW1xcdTI3MDAtXFx1MjdCRl18W1xcdUUwMDAtXFx1RjhGRl18XFx1RDgzQ1tcXHVEQzAwLVxcdURGRkZdfFxcdUQ4M0RbXFx1REMwMC1cXHVERkZGXXxbXFx1MjAxMS1cXHUyNkZGXXxcXHVEODNFW1xcdUREMTAtXFx1RERGRl0pL2c7XG5mdW5jdGlvbiBsYih0KSB7XG4gIHZhciBlLCBuO1xuICBsZXQgciA9IChlID0gdC5pbm5lclRleHQpICE9IG51bGwgPyBlIDogXCJcIiwgaSA9IHQuY2xvbmVOb2RlKCEwKTtcbiAgaWYgKCEoaSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSlcbiAgICByZXR1cm4gcjtcbiAgbGV0IHMgPSAhMTtcbiAgZm9yIChsZXQgYSBvZiBpLnF1ZXJ5U2VsZWN0b3JBbGwoJ1toaWRkZW5dLFthcmlhLWhpZGRlbl0sW3JvbGU9XCJpbWdcIl0nKSlcbiAgICBhLnJlbW92ZSgpLCBzID0gITA7XG4gIGxldCBvID0gcyA/IChuID0gaS5pbm5lclRleHQpICE9IG51bGwgPyBuIDogXCJcIiA6IHI7XG4gIHJldHVybiBhYi50ZXN0KG8pICYmIChvID0gby5yZXBsYWNlKGFiLCBcIlwiKSksIG87XG59XG5mdW5jdGlvbiBTQyh0KSB7XG4gIGxldCBlID0gdC5nZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIpO1xuICBpZiAodHlwZW9mIGUgPT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gZS50cmltKCk7XG4gIGxldCBuID0gdC5nZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsbGVkYnlcIik7XG4gIGlmIChuKSB7XG4gICAgbGV0IHIgPSBuLnNwbGl0KFwiIFwiKS5tYXAoKGkpID0+IHtcbiAgICAgIGxldCBzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaSk7XG4gICAgICBpZiAocykge1xuICAgICAgICBsZXQgbyA9IHMuZ2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvID09IFwic3RyaW5nXCIgPyBvLnRyaW0oKSA6IGxiKHMpLnRyaW0oKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0pLmZpbHRlcihCb29sZWFuKTtcbiAgICBpZiAoci5sZW5ndGggPiAwKVxuICAgICAgcmV0dXJuIHIuam9pbihcIiwgXCIpO1xuICB9XG4gIHJldHVybiBsYih0KS50cmltKCk7XG59XG5mdW5jdGlvbiB3Qyh0KSB7XG4gIGxldCBlID0gRyhcIlwiKSwgbiA9IEcoXCJcIik7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbGV0IHIgPSBwZSh0KTtcbiAgICBpZiAoIXIpXG4gICAgICByZXR1cm4gXCJcIjtcbiAgICBsZXQgaSA9IHIuaW5uZXJUZXh0O1xuICAgIGlmIChlLnZhbHVlID09PSBpKVxuICAgICAgcmV0dXJuIG4udmFsdWU7XG4gICAgbGV0IHMgPSBTQyhyKS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICByZXR1cm4gZS52YWx1ZSA9IGksIG4udmFsdWUgPSBzLCBzO1xuICB9O1xufVxuZnVuY3Rpb24ga0ModCwgZSkge1xuICByZXR1cm4gdCA9PT0gZTtcbn1cbnZhciB4QyA9ICgodCkgPT4gKHRbdC5PcGVuID0gMF0gPSBcIk9wZW5cIiwgdFt0LkNsb3NlZCA9IDFdID0gXCJDbG9zZWRcIiwgdCkpKHhDIHx8IHt9KSwgUEMgPSAoKHQpID0+ICh0W3QuU2luZ2xlID0gMF0gPSBcIlNpbmdsZVwiLCB0W3QuTXVsdGkgPSAxXSA9IFwiTXVsdGlcIiwgdCkpKFBDIHx8IHt9KSwgX0MgPSAoKHQpID0+ICh0W3QuUG9pbnRlciA9IDBdID0gXCJQb2ludGVyXCIsIHRbdC5PdGhlciA9IDFdID0gXCJPdGhlclwiLCB0KSkoX0MgfHwge30pO1xuZnVuY3Rpb24gVEModCkge1xuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHQpKTtcbn1cbmxldCBXUyA9IFN5bWJvbChcIkxpc3Rib3hDb250ZXh0XCIpO1xuZnVuY3Rpb24gQWQodCkge1xuICBsZXQgZSA9IFB0KFdTLCBudWxsKTtcbiAgaWYgKGUgPT09IG51bGwpIHtcbiAgICBsZXQgbiA9IG5ldyBFcnJvcihgPCR7dH0gLz4gaXMgbWlzc2luZyBhIHBhcmVudCA8TGlzdGJveCAvPiBjb21wb25lbnQuYCk7XG4gICAgdGhyb3cgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgJiYgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UobiwgQWQpLCBuO1xuICB9XG4gIHJldHVybiBlO1xufVxubGV0IEVDID0gLyogQF9fUFVSRV9fICovIGxlKHsgbmFtZTogXCJMaXN0Ym94XCIsIGVtaXRzOiB7IFwidXBkYXRlOm1vZGVsVmFsdWVcIjogKHQpID0+ICEwIH0sIHByb3BzOiB7IGFzOiB7IHR5cGU6IFtPYmplY3QsIFN0cmluZ10sIGRlZmF1bHQ6IFwidGVtcGxhdGVcIiB9LCBkaXNhYmxlZDogeyB0eXBlOiBbQm9vbGVhbl0sIGRlZmF1bHQ6ICExIH0sIGJ5OiB7IHR5cGU6IFtTdHJpbmcsIEZ1bmN0aW9uXSwgZGVmYXVsdDogKCkgPT4ga0MgfSwgaG9yaXpvbnRhbDogeyB0eXBlOiBbQm9vbGVhbl0sIGRlZmF1bHQ6ICExIH0sIG1vZGVsVmFsdWU6IHsgdHlwZTogW09iamVjdCwgU3RyaW5nLCBOdW1iZXIsIEJvb2xlYW5dLCBkZWZhdWx0OiB2b2lkIDAgfSwgZGVmYXVsdFZhbHVlOiB7IHR5cGU6IFtPYmplY3QsIFN0cmluZywgTnVtYmVyLCBCb29sZWFuXSwgZGVmYXVsdDogdm9pZCAwIH0sIGZvcm06IHsgdHlwZTogU3RyaW5nLCBvcHRpb25hbDogITAgfSwgbmFtZTogeyB0eXBlOiBTdHJpbmcsIG9wdGlvbmFsOiAhMCB9LCBtdWx0aXBsZTogeyB0eXBlOiBbQm9vbGVhbl0sIGRlZmF1bHQ6ICExIH0gfSwgaW5oZXJpdEF0dHJzOiAhMSwgc2V0dXAodCwgeyBzbG90czogZSwgYXR0cnM6IG4sIGVtaXQ6IHIgfSkge1xuICBsZXQgaSA9IEcoMSksIHMgPSBHKG51bGwpLCBvID0gRyhudWxsKSwgYSA9IEcobnVsbCksIGwgPSBHKFtdKSwgYyA9IEcoXCJcIiksIHUgPSBHKG51bGwpLCBkID0gRygxKTtcbiAgZnVuY3Rpb24gZihnID0gKHYpID0+IHYpIHtcbiAgICBsZXQgdiA9IHUudmFsdWUgIT09IG51bGwgPyBsLnZhbHVlW3UudmFsdWVdIDogbnVsbCwgUyA9IHZzKGcobC52YWx1ZS5zbGljZSgpKSwgKGspID0+IHBlKGsuZGF0YVJlZi5kb21SZWYpKSwgdyA9IHYgPyBTLmluZGV4T2YodikgOiBudWxsO1xuICAgIHJldHVybiB3ID09PSAtMSAmJiAodyA9IG51bGwpLCB7IG9wdGlvbnM6IFMsIGFjdGl2ZU9wdGlvbkluZGV4OiB3IH07XG4gIH1cbiAgbGV0IGggPSBqKCgpID0+IHQubXVsdGlwbGUgPyAxIDogMCksIFtwLCBPXSA9IHdRKGooKCkgPT4gdC5tb2RlbFZhbHVlKSwgKGcpID0+IHIoXCJ1cGRhdGU6bW9kZWxWYWx1ZVwiLCBnKSwgaigoKSA9PiB0LmRlZmF1bHRWYWx1ZSkpLCBtID0gaigoKSA9PiBwLnZhbHVlID09PSB2b2lkIDAgPyBUdChoLnZhbHVlLCB7IDE6IFtdLCAwOiB2b2lkIDAgfSkgOiBwLnZhbHVlKSwgeSA9IHsgbGlzdGJveFN0YXRlOiBpLCB2YWx1ZTogbSwgbW9kZTogaCwgY29tcGFyZShnLCB2KSB7XG4gICAgaWYgKHR5cGVvZiB0LmJ5ID09IFwic3RyaW5nXCIpIHtcbiAgICAgIGxldCBTID0gdC5ieTtcbiAgICAgIHJldHVybiAoZyA9PSBudWxsID8gdm9pZCAwIDogZ1tTXSkgPT09ICh2ID09IG51bGwgPyB2b2lkIDAgOiB2W1NdKTtcbiAgICB9XG4gICAgcmV0dXJuIHQuYnkoZywgdik7XG4gIH0sIG9yaWVudGF0aW9uOiBqKCgpID0+IHQuaG9yaXpvbnRhbCA/IFwiaG9yaXpvbnRhbFwiIDogXCJ2ZXJ0aWNhbFwiKSwgbGFiZWxSZWY6IHMsIGJ1dHRvblJlZjogbywgb3B0aW9uc1JlZjogYSwgZGlzYWJsZWQ6IGooKCkgPT4gdC5kaXNhYmxlZCksIG9wdGlvbnM6IGwsIHNlYXJjaFF1ZXJ5OiBjLCBhY3RpdmVPcHRpb25JbmRleDogdSwgYWN0aXZhdGlvblRyaWdnZXI6IGQsIGNsb3NlTGlzdGJveCgpIHtcbiAgICB0LmRpc2FibGVkIHx8IGkudmFsdWUgIT09IDEgJiYgKGkudmFsdWUgPSAxLCB1LnZhbHVlID0gbnVsbCk7XG4gIH0sIG9wZW5MaXN0Ym94KCkge1xuICAgIHQuZGlzYWJsZWQgfHwgaS52YWx1ZSAhPT0gMCAmJiAoaS52YWx1ZSA9IDApO1xuICB9LCBnb1RvT3B0aW9uKGcsIHYsIFMpIHtcbiAgICBpZiAodC5kaXNhYmxlZCB8fCBpLnZhbHVlID09PSAxKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCB3ID0gZigpLCBrID0gWFEoZyA9PT0gaG4uU3BlY2lmaWMgPyB7IGZvY3VzOiBobi5TcGVjaWZpYywgaWQ6IHYgfSA6IHsgZm9jdXM6IGcgfSwgeyByZXNvbHZlSXRlbXM6ICgpID0+IHcub3B0aW9ucywgcmVzb2x2ZUFjdGl2ZUluZGV4OiAoKSA9PiB3LmFjdGl2ZU9wdGlvbkluZGV4LCByZXNvbHZlSWQ6IChfKSA9PiBfLmlkLCByZXNvbHZlRGlzYWJsZWQ6IChfKSA9PiBfLmRhdGFSZWYuZGlzYWJsZWQgfSk7XG4gICAgYy52YWx1ZSA9IFwiXCIsIHUudmFsdWUgPSBrLCBkLnZhbHVlID0gUyA/PyAxLCBsLnZhbHVlID0gdy5vcHRpb25zO1xuICB9LCBzZWFyY2goZykge1xuICAgIGlmICh0LmRpc2FibGVkIHx8IGkudmFsdWUgPT09IDEpXG4gICAgICByZXR1cm47XG4gICAgbGV0IHYgPSBjLnZhbHVlICE9PSBcIlwiID8gMCA6IDE7XG4gICAgYy52YWx1ZSArPSBnLnRvTG93ZXJDYXNlKCk7XG4gICAgbGV0IFMgPSAodS52YWx1ZSAhPT0gbnVsbCA/IGwudmFsdWUuc2xpY2UodS52YWx1ZSArIHYpLmNvbmNhdChsLnZhbHVlLnNsaWNlKDAsIHUudmFsdWUgKyB2KSkgOiBsLnZhbHVlKS5maW5kKChrKSA9PiBrLmRhdGFSZWYudGV4dFZhbHVlLnN0YXJ0c1dpdGgoYy52YWx1ZSkgJiYgIWsuZGF0YVJlZi5kaXNhYmxlZCksIHcgPSBTID8gbC52YWx1ZS5pbmRleE9mKFMpIDogLTE7XG4gICAgdyA9PT0gLTEgfHwgdyA9PT0gdS52YWx1ZSB8fCAodS52YWx1ZSA9IHcsIGQudmFsdWUgPSAxKTtcbiAgfSwgY2xlYXJTZWFyY2goKSB7XG4gICAgdC5kaXNhYmxlZCB8fCBpLnZhbHVlICE9PSAxICYmIGMudmFsdWUgIT09IFwiXCIgJiYgKGMudmFsdWUgPSBcIlwiKTtcbiAgfSwgcmVnaXN0ZXJPcHRpb24oZywgdikge1xuICAgIGxldCBTID0gZigodykgPT4gWy4uLncsIHsgaWQ6IGcsIGRhdGFSZWY6IHYgfV0pO1xuICAgIGwudmFsdWUgPSBTLm9wdGlvbnMsIHUudmFsdWUgPSBTLmFjdGl2ZU9wdGlvbkluZGV4O1xuICB9LCB1bnJlZ2lzdGVyT3B0aW9uKGcpIHtcbiAgICBsZXQgdiA9IGYoKFMpID0+IHtcbiAgICAgIGxldCB3ID0gUy5maW5kSW5kZXgoKGspID0+IGsuaWQgPT09IGcpO1xuICAgICAgcmV0dXJuIHcgIT09IC0xICYmIFMuc3BsaWNlKHcsIDEpLCBTO1xuICAgIH0pO1xuICAgIGwudmFsdWUgPSB2Lm9wdGlvbnMsIHUudmFsdWUgPSB2LmFjdGl2ZU9wdGlvbkluZGV4LCBkLnZhbHVlID0gMTtcbiAgfSwgdGhlaXJPbkNoYW5nZShnKSB7XG4gICAgdC5kaXNhYmxlZCB8fCBPKGcpO1xuICB9LCBzZWxlY3QoZykge1xuICAgIHQuZGlzYWJsZWQgfHwgTyhUdChoLnZhbHVlLCB7IDA6ICgpID0+IGcsIDE6ICgpID0+IHtcbiAgICAgIGxldCB2ID0gT2UoeS52YWx1ZS52YWx1ZSkuc2xpY2UoKSwgUyA9IE9lKGcpLCB3ID0gdi5maW5kSW5kZXgoKGspID0+IHkuY29tcGFyZShTLCBPZShrKSkpO1xuICAgICAgcmV0dXJuIHcgPT09IC0xID8gdi5wdXNoKFMpIDogdi5zcGxpY2UodywgMSksIHY7XG4gICAgfSB9KSk7XG4gIH0gfTtcbiAgU1MoW28sIGFdLCAoZywgdikgPT4ge1xuICAgIHZhciBTO1xuICAgIHkuY2xvc2VMaXN0Ym94KCksIGJTKHYsIE5PLkxvb3NlKSB8fCAoZy5wcmV2ZW50RGVmYXVsdCgpLCAoUyA9IHBlKG8pKSA9PSBudWxsIHx8IFMuZm9jdXMoKSk7XG4gIH0sIGooKCkgPT4gaS52YWx1ZSA9PT0gMCkpLCBfbihXUywgeSksIFBTKGooKCkgPT4gVHQoaS52YWx1ZSwgeyAwOiBJbi5PcGVuLCAxOiBJbi5DbG9zZWQgfSkpKTtcbiAgbGV0IGIgPSBqKCgpID0+IHtcbiAgICB2YXIgZztcbiAgICByZXR1cm4gKGcgPSBwZShvKSkgPT0gbnVsbCA/IHZvaWQgMCA6IGcuY2xvc2VzdChcImZvcm1cIik7XG4gIH0pO1xuICByZXR1cm4gZXQoKCkgPT4ge1xuICAgIGh0KFtiXSwgKCkgPT4ge1xuICAgICAgaWYgKCFiLnZhbHVlIHx8IHQuZGVmYXVsdFZhbHVlID09PSB2b2lkIDApXG4gICAgICAgIHJldHVybjtcbiAgICAgIGZ1bmN0aW9uIGcoKSB7XG4gICAgICAgIHkudGhlaXJPbkNoYW5nZSh0LmRlZmF1bHRWYWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYi52YWx1ZS5hZGRFdmVudExpc3RlbmVyKFwicmVzZXRcIiwgZyksICgpID0+IHtcbiAgICAgICAgdmFyIHY7XG4gICAgICAgICh2ID0gYi52YWx1ZSkgPT0gbnVsbCB8fCB2LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNldFwiLCBnKTtcbiAgICAgIH07XG4gICAgfSwgeyBpbW1lZGlhdGU6ICEwIH0pO1xuICB9KSwgKCkgPT4ge1xuICAgIGxldCB7IG5hbWU6IGcsIG1vZGVsVmFsdWU6IHYsIGRpc2FibGVkOiBTLCBmb3JtOiB3LCAuLi5rIH0gPSB0LCBfID0geyBvcGVuOiBpLnZhbHVlID09PSAwLCBkaXNhYmxlZDogUywgdmFsdWU6IG0udmFsdWUgfTtcbiAgICByZXR1cm4ga3QoUGUsIFsuLi5nICE9IG51bGwgJiYgbS52YWx1ZSAhPSBudWxsID8gX1MoeyBbZ106IG0udmFsdWUgfSkubWFwKChbVCwgQ10pID0+IGt0KFZvLCBWUSh7IGZlYXR1cmVzOiBaby5IaWRkZW4sIGtleTogVCwgYXM6IFwiaW5wdXRcIiwgdHlwZTogXCJoaWRkZW5cIiwgaGlkZGVuOiAhMCwgcmVhZE9ubHk6ICEwLCBmb3JtOiB3LCBkaXNhYmxlZDogUywgbmFtZTogVCwgdmFsdWU6IEMgfSkpKSA6IFtdLCBFdCh7IG91clByb3BzOiB7fSwgdGhlaXJQcm9wczogeyAuLi5uLCAuLi5aTyhrLCBbXCJkZWZhdWx0VmFsdWVcIiwgXCJvblVwZGF0ZTptb2RlbFZhbHVlXCIsIFwiaG9yaXpvbnRhbFwiLCBcIm11bHRpcGxlXCIsIFwiYnlcIl0pIH0sIHNsb3Q6IF8sIHNsb3RzOiBlLCBhdHRyczogbiwgbmFtZTogXCJMaXN0Ym94XCIgfSldKTtcbiAgfTtcbn0gfSksICRDID0gLyogQF9fUFVSRV9fICovIGxlKHsgbmFtZTogXCJMaXN0Ym94QnV0dG9uXCIsIHByb3BzOiB7IGFzOiB7IHR5cGU6IFtPYmplY3QsIFN0cmluZ10sIGRlZmF1bHQ6IFwiYnV0dG9uXCIgfSwgaWQ6IHsgdHlwZTogU3RyaW5nLCBkZWZhdWx0OiBudWxsIH0gfSwgc2V0dXAodCwgeyBhdHRyczogZSwgc2xvdHM6IG4sIGV4cG9zZTogciB9KSB7XG4gIHZhciBpO1xuICBsZXQgcyA9IChpID0gdC5pZCkgIT0gbnVsbCA/IGkgOiBgaGVhZGxlc3N1aS1saXN0Ym94LWJ1dHRvbi0ke21yKCl9YCwgbyA9IEFkKFwiTGlzdGJveEJ1dHRvblwiKTtcbiAgcih7IGVsOiBvLmJ1dHRvblJlZiwgJGVsOiBvLmJ1dHRvblJlZiB9KTtcbiAgZnVuY3Rpb24gYShkKSB7XG4gICAgc3dpdGNoIChkLmtleSkge1xuICAgICAgY2FzZSBYZS5TcGFjZTpcbiAgICAgIGNhc2UgWGUuRW50ZXI6XG4gICAgICBjYXNlIFhlLkFycm93RG93bjpcbiAgICAgICAgZC5wcmV2ZW50RGVmYXVsdCgpLCBvLm9wZW5MaXN0Ym94KCksIFBuKCgpID0+IHtcbiAgICAgICAgICB2YXIgZjtcbiAgICAgICAgICAoZiA9IHBlKG8ub3B0aW9uc1JlZikpID09IG51bGwgfHwgZi5mb2N1cyh7IHByZXZlbnRTY3JvbGw6ICEwIH0pLCBvLnZhbHVlLnZhbHVlIHx8IG8uZ29Ub09wdGlvbihobi5GaXJzdCk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgWGUuQXJyb3dVcDpcbiAgICAgICAgZC5wcmV2ZW50RGVmYXVsdCgpLCBvLm9wZW5MaXN0Ym94KCksIFBuKCgpID0+IHtcbiAgICAgICAgICB2YXIgZjtcbiAgICAgICAgICAoZiA9IHBlKG8ub3B0aW9uc1JlZikpID09IG51bGwgfHwgZi5mb2N1cyh7IHByZXZlbnRTY3JvbGw6ICEwIH0pLCBvLnZhbHVlLnZhbHVlIHx8IG8uZ29Ub09wdGlvbihobi5MYXN0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBsKGQpIHtcbiAgICBzd2l0Y2ggKGQua2V5KSB7XG4gICAgICBjYXNlIFhlLlNwYWNlOlxuICAgICAgICBkLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBjKGQpIHtcbiAgICBvLmRpc2FibGVkLnZhbHVlIHx8IChvLmxpc3Rib3hTdGF0ZS52YWx1ZSA9PT0gMCA/IChvLmNsb3NlTGlzdGJveCgpLCBQbigoKSA9PiB7XG4gICAgICB2YXIgZjtcbiAgICAgIHJldHVybiAoZiA9IHBlKG8uYnV0dG9uUmVmKSkgPT0gbnVsbCA/IHZvaWQgMCA6IGYuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiAhMCB9KTtcbiAgICB9KSkgOiAoZC5wcmV2ZW50RGVmYXVsdCgpLCBvLm9wZW5MaXN0Ym94KCksIFRDKCgpID0+IHtcbiAgICAgIHZhciBmO1xuICAgICAgcmV0dXJuIChmID0gcGUoby5vcHRpb25zUmVmKSkgPT0gbnVsbCA/IHZvaWQgMCA6IGYuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiAhMCB9KTtcbiAgICB9KSkpO1xuICB9XG4gIGxldCB1ID0gRE8oaigoKSA9PiAoeyBhczogdC5hcywgdHlwZTogZS50eXBlIH0pKSwgby5idXR0b25SZWYpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIHZhciBkLCBmO1xuICAgIGxldCBoID0geyBvcGVuOiBvLmxpc3Rib3hTdGF0ZS52YWx1ZSA9PT0gMCwgZGlzYWJsZWQ6IG8uZGlzYWJsZWQudmFsdWUsIHZhbHVlOiBvLnZhbHVlLnZhbHVlIH0sIHsgLi4ucCB9ID0gdCwgTyA9IHsgcmVmOiBvLmJ1dHRvblJlZiwgaWQ6IHMsIHR5cGU6IHUudmFsdWUsIFwiYXJpYS1oYXNwb3B1cFwiOiBcImxpc3Rib3hcIiwgXCJhcmlhLWNvbnRyb2xzXCI6IChkID0gcGUoby5vcHRpb25zUmVmKSkgPT0gbnVsbCA/IHZvaWQgMCA6IGQuaWQsIFwiYXJpYS1leHBhbmRlZFwiOiBvLmxpc3Rib3hTdGF0ZS52YWx1ZSA9PT0gMCwgXCJhcmlhLWxhYmVsbGVkYnlcIjogby5sYWJlbFJlZi52YWx1ZSA/IFsoZiA9IHBlKG8ubGFiZWxSZWYpKSA9PSBudWxsID8gdm9pZCAwIDogZi5pZCwgc10uam9pbihcIiBcIikgOiB2b2lkIDAsIGRpc2FibGVkOiBvLmRpc2FibGVkLnZhbHVlID09PSAhMCA/ICEwIDogdm9pZCAwLCBvbktleWRvd246IGEsIG9uS2V5dXA6IGwsIG9uQ2xpY2s6IGMgfTtcbiAgICByZXR1cm4gRXQoeyBvdXJQcm9wczogTywgdGhlaXJQcm9wczogcCwgc2xvdDogaCwgYXR0cnM6IGUsIHNsb3RzOiBuLCBuYW1lOiBcIkxpc3Rib3hCdXR0b25cIiB9KTtcbiAgfTtcbn0gfSksIFFDID0gLyogQF9fUFVSRV9fICovIGxlKHsgbmFtZTogXCJMaXN0Ym94T3B0aW9uc1wiLCBwcm9wczogeyBhczogeyB0eXBlOiBbT2JqZWN0LCBTdHJpbmddLCBkZWZhdWx0OiBcInVsXCIgfSwgc3RhdGljOiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6ICExIH0sIHVubW91bnQ6IHsgdHlwZTogQm9vbGVhbiwgZGVmYXVsdDogITAgfSwgaWQ6IHsgdHlwZTogU3RyaW5nLCBkZWZhdWx0OiBudWxsIH0gfSwgc2V0dXAodCwgeyBhdHRyczogZSwgc2xvdHM6IG4sIGV4cG9zZTogciB9KSB7XG4gIHZhciBpO1xuICBsZXQgcyA9IChpID0gdC5pZCkgIT0gbnVsbCA/IGkgOiBgaGVhZGxlc3N1aS1saXN0Ym94LW9wdGlvbnMtJHttcigpfWAsIG8gPSBBZChcIkxpc3Rib3hPcHRpb25zXCIpLCBhID0gRyhudWxsKTtcbiAgcih7IGVsOiBvLm9wdGlvbnNSZWYsICRlbDogby5vcHRpb25zUmVmIH0pO1xuICBmdW5jdGlvbiBsKGQpIHtcbiAgICBzd2l0Y2ggKGEudmFsdWUgJiYgY2xlYXJUaW1lb3V0KGEudmFsdWUpLCBkLmtleSkge1xuICAgICAgY2FzZSBYZS5TcGFjZTpcbiAgICAgICAgaWYgKG8uc2VhcmNoUXVlcnkudmFsdWUgIT09IFwiXCIpXG4gICAgICAgICAgcmV0dXJuIGQucHJldmVudERlZmF1bHQoKSwgZC5zdG9wUHJvcGFnYXRpb24oKSwgby5zZWFyY2goZC5rZXkpO1xuICAgICAgY2FzZSBYZS5FbnRlcjpcbiAgICAgICAgaWYgKGQucHJldmVudERlZmF1bHQoKSwgZC5zdG9wUHJvcGFnYXRpb24oKSwgby5hY3RpdmVPcHRpb25JbmRleC52YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGxldCBmID0gby5vcHRpb25zLnZhbHVlW28uYWN0aXZlT3B0aW9uSW5kZXgudmFsdWVdO1xuICAgICAgICAgIG8uc2VsZWN0KGYuZGF0YVJlZi52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgby5tb2RlLnZhbHVlID09PSAwICYmIChvLmNsb3NlTGlzdGJveCgpLCBQbigoKSA9PiB7XG4gICAgICAgICAgdmFyIGY7XG4gICAgICAgICAgcmV0dXJuIChmID0gcGUoby5idXR0b25SZWYpKSA9PSBudWxsID8gdm9pZCAwIDogZi5mb2N1cyh7IHByZXZlbnRTY3JvbGw6ICEwIH0pO1xuICAgICAgICB9KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUdChvLm9yaWVudGF0aW9uLnZhbHVlLCB7IHZlcnRpY2FsOiBYZS5BcnJvd0Rvd24sIGhvcml6b250YWw6IFhlLkFycm93UmlnaHQgfSk6XG4gICAgICAgIHJldHVybiBkLnByZXZlbnREZWZhdWx0KCksIGQuc3RvcFByb3BhZ2F0aW9uKCksIG8uZ29Ub09wdGlvbihobi5OZXh0KTtcbiAgICAgIGNhc2UgVHQoby5vcmllbnRhdGlvbi52YWx1ZSwgeyB2ZXJ0aWNhbDogWGUuQXJyb3dVcCwgaG9yaXpvbnRhbDogWGUuQXJyb3dMZWZ0IH0pOlxuICAgICAgICByZXR1cm4gZC5wcmV2ZW50RGVmYXVsdCgpLCBkLnN0b3BQcm9wYWdhdGlvbigpLCBvLmdvVG9PcHRpb24oaG4uUHJldmlvdXMpO1xuICAgICAgY2FzZSBYZS5Ib21lOlxuICAgICAgY2FzZSBYZS5QYWdlVXA6XG4gICAgICAgIHJldHVybiBkLnByZXZlbnREZWZhdWx0KCksIGQuc3RvcFByb3BhZ2F0aW9uKCksIG8uZ29Ub09wdGlvbihobi5GaXJzdCk7XG4gICAgICBjYXNlIFhlLkVuZDpcbiAgICAgIGNhc2UgWGUuUGFnZURvd246XG4gICAgICAgIHJldHVybiBkLnByZXZlbnREZWZhdWx0KCksIGQuc3RvcFByb3BhZ2F0aW9uKCksIG8uZ29Ub09wdGlvbihobi5MYXN0KTtcbiAgICAgIGNhc2UgWGUuRXNjYXBlOlxuICAgICAgICBkLnByZXZlbnREZWZhdWx0KCksIGQuc3RvcFByb3BhZ2F0aW9uKCksIG8uY2xvc2VMaXN0Ym94KCksIFBuKCgpID0+IHtcbiAgICAgICAgICB2YXIgZjtcbiAgICAgICAgICByZXR1cm4gKGYgPSBwZShvLmJ1dHRvblJlZikpID09IG51bGwgPyB2b2lkIDAgOiBmLmZvY3VzKHsgcHJldmVudFNjcm9sbDogITAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgWGUuVGFiOlxuICAgICAgICBkLnByZXZlbnREZWZhdWx0KCksIGQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZC5rZXkubGVuZ3RoID09PSAxICYmIChvLnNlYXJjaChkLmtleSksIGEudmFsdWUgPSBzZXRUaW1lb3V0KCgpID0+IG8uY2xlYXJTZWFyY2goKSwgMzUwKSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBsZXQgYyA9IFZPKCksIHUgPSBqKCgpID0+IGMgIT09IG51bGwgPyAoYy52YWx1ZSAmIEluLk9wZW4pID09PSBJbi5PcGVuIDogby5saXN0Ym94U3RhdGUudmFsdWUgPT09IDApO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIHZhciBkLCBmO1xuICAgIGxldCBoID0geyBvcGVuOiBvLmxpc3Rib3hTdGF0ZS52YWx1ZSA9PT0gMCB9LCB7IC4uLnAgfSA9IHQsIE8gPSB7IFwiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCI6IG8uYWN0aXZlT3B0aW9uSW5kZXgudmFsdWUgPT09IG51bGwgfHwgKGQgPSBvLm9wdGlvbnMudmFsdWVbby5hY3RpdmVPcHRpb25JbmRleC52YWx1ZV0pID09IG51bGwgPyB2b2lkIDAgOiBkLmlkLCBcImFyaWEtbXVsdGlzZWxlY3RhYmxlXCI6IG8ubW9kZS52YWx1ZSA9PT0gMSA/ICEwIDogdm9pZCAwLCBcImFyaWEtbGFiZWxsZWRieVwiOiAoZiA9IHBlKG8uYnV0dG9uUmVmKSkgPT0gbnVsbCA/IHZvaWQgMCA6IGYuaWQsIFwiYXJpYS1vcmllbnRhdGlvblwiOiBvLm9yaWVudGF0aW9uLnZhbHVlLCBpZDogcywgb25LZXlkb3duOiBsLCByb2xlOiBcImxpc3Rib3hcIiwgdGFiSW5kZXg6IDAsIHJlZjogby5vcHRpb25zUmVmIH07XG4gICAgcmV0dXJuIEV0KHsgb3VyUHJvcHM6IE8sIHRoZWlyUHJvcHM6IHAsIHNsb3Q6IGgsIGF0dHJzOiBlLCBzbG90czogbiwgZmVhdHVyZXM6IGNpLlJlbmRlclN0cmF0ZWd5IHwgY2kuU3RhdGljLCB2aXNpYmxlOiB1LnZhbHVlLCBuYW1lOiBcIkxpc3Rib3hPcHRpb25zXCIgfSk7XG4gIH07XG59IH0pLCBDQyA9IC8qIEBfX1BVUkVfXyAqLyBsZSh7IG5hbWU6IFwiTGlzdGJveE9wdGlvblwiLCBwcm9wczogeyBhczogeyB0eXBlOiBbT2JqZWN0LCBTdHJpbmddLCBkZWZhdWx0OiBcImxpXCIgfSwgdmFsdWU6IHsgdHlwZTogW09iamVjdCwgU3RyaW5nLCBOdW1iZXIsIEJvb2xlYW5dIH0sIGRpc2FibGVkOiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6ICExIH0sIGlkOiB7IHR5cGU6IFN0cmluZywgZGVmYXVsdDogbnVsbCB9IH0sIHNldHVwKHQsIHsgc2xvdHM6IGUsIGF0dHJzOiBuLCBleHBvc2U6IHIgfSkge1xuICB2YXIgaTtcbiAgbGV0IHMgPSAoaSA9IHQuaWQpICE9IG51bGwgPyBpIDogYGhlYWRsZXNzdWktbGlzdGJveC1vcHRpb24tJHttcigpfWAsIG8gPSBBZChcIkxpc3Rib3hPcHRpb25cIiksIGEgPSBHKG51bGwpO1xuICByKHsgZWw6IGEsICRlbDogYSB9KTtcbiAgbGV0IGwgPSBqKCgpID0+IG8uYWN0aXZlT3B0aW9uSW5kZXgudmFsdWUgIT09IG51bGwgPyBvLm9wdGlvbnMudmFsdWVbby5hY3RpdmVPcHRpb25JbmRleC52YWx1ZV0uaWQgPT09IHMgOiAhMSksIGMgPSBqKCgpID0+IFR0KG8ubW9kZS52YWx1ZSwgeyAwOiAoKSA9PiBvLmNvbXBhcmUoT2Uoby52YWx1ZS52YWx1ZSksIE9lKHQudmFsdWUpKSwgMTogKCkgPT4gT2Uoby52YWx1ZS52YWx1ZSkuc29tZSgoZykgPT4gby5jb21wYXJlKE9lKGcpLCBPZSh0LnZhbHVlKSkpIH0pKSwgdSA9IGooKCkgPT4gVHQoby5tb2RlLnZhbHVlLCB7IDE6ICgpID0+IHtcbiAgICB2YXIgZztcbiAgICBsZXQgdiA9IE9lKG8udmFsdWUudmFsdWUpO1xuICAgIHJldHVybiAoKGcgPSBvLm9wdGlvbnMudmFsdWUuZmluZCgoUykgPT4gdi5zb21lKCh3KSA9PiBvLmNvbXBhcmUoT2UodyksIE9lKFMuZGF0YVJlZi52YWx1ZSkpKSkpID09IG51bGwgPyB2b2lkIDAgOiBnLmlkKSA9PT0gcztcbiAgfSwgMDogKCkgPT4gYy52YWx1ZSB9KSksIGQgPSB3QyhhKSwgZiA9IGooKCkgPT4gKHsgZGlzYWJsZWQ6IHQuZGlzYWJsZWQsIHZhbHVlOiB0LnZhbHVlLCBnZXQgdGV4dFZhbHVlKCkge1xuICAgIHJldHVybiBkKCk7XG4gIH0sIGRvbVJlZjogYSB9KSk7XG4gIGV0KCgpID0+IG8ucmVnaXN0ZXJPcHRpb24ocywgZikpLCBqdCgoKSA9PiBvLnVucmVnaXN0ZXJPcHRpb24ocykpLCBldCgoKSA9PiB7XG4gICAgaHQoW28ubGlzdGJveFN0YXRlLCBjXSwgKCkgPT4ge1xuICAgICAgby5saXN0Ym94U3RhdGUudmFsdWUgPT09IDAgJiYgYy52YWx1ZSAmJiBUdChvLm1vZGUudmFsdWUsIHsgMTogKCkgPT4ge1xuICAgICAgICB1LnZhbHVlICYmIG8uZ29Ub09wdGlvbihobi5TcGVjaWZpYywgcyk7XG4gICAgICB9LCAwOiAoKSA9PiB7XG4gICAgICAgIG8uZ29Ub09wdGlvbihobi5TcGVjaWZpYywgcyk7XG4gICAgICB9IH0pO1xuICAgIH0sIHsgaW1tZWRpYXRlOiAhMCB9KTtcbiAgfSksIEJuKCgpID0+IHtcbiAgICBvLmxpc3Rib3hTdGF0ZS52YWx1ZSA9PT0gMCAmJiBsLnZhbHVlICYmIG8uYWN0aXZhdGlvblRyaWdnZXIudmFsdWUgIT09IDAgJiYgUG4oKCkgPT4ge1xuICAgICAgdmFyIGcsIHY7XG4gICAgICByZXR1cm4gKHYgPSAoZyA9IHBlKGEpKSA9PSBudWxsID8gdm9pZCAwIDogZy5zY3JvbGxJbnRvVmlldykgPT0gbnVsbCA/IHZvaWQgMCA6IHYuY2FsbChnLCB7IGJsb2NrOiBcIm5lYXJlc3RcIiB9KTtcbiAgICB9KTtcbiAgfSk7XG4gIGZ1bmN0aW9uIGgoZykge1xuICAgIGlmICh0LmRpc2FibGVkKVxuICAgICAgcmV0dXJuIGcucHJldmVudERlZmF1bHQoKTtcbiAgICBvLnNlbGVjdCh0LnZhbHVlKSwgby5tb2RlLnZhbHVlID09PSAwICYmIChvLmNsb3NlTGlzdGJveCgpLCBQbigoKSA9PiB7XG4gICAgICB2YXIgdjtcbiAgICAgIHJldHVybiAodiA9IHBlKG8uYnV0dG9uUmVmKSkgPT0gbnVsbCA/IHZvaWQgMCA6IHYuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiAhMCB9KTtcbiAgICB9KSk7XG4gIH1cbiAgZnVuY3Rpb24gcCgpIHtcbiAgICBpZiAodC5kaXNhYmxlZClcbiAgICAgIHJldHVybiBvLmdvVG9PcHRpb24oaG4uTm90aGluZyk7XG4gICAgby5nb1RvT3B0aW9uKGhuLlNwZWNpZmljLCBzKTtcbiAgfVxuICBsZXQgTyA9IERRKCk7XG4gIGZ1bmN0aW9uIG0oZykge1xuICAgIE8udXBkYXRlKGcpO1xuICB9XG4gIGZ1bmN0aW9uIHkoZykge1xuICAgIE8ud2FzTW92ZWQoZykgJiYgKHQuZGlzYWJsZWQgfHwgbC52YWx1ZSB8fCBvLmdvVG9PcHRpb24oaG4uU3BlY2lmaWMsIHMsIDApKTtcbiAgfVxuICBmdW5jdGlvbiBiKGcpIHtcbiAgICBPLndhc01vdmVkKGcpICYmICh0LmRpc2FibGVkIHx8IGwudmFsdWUgJiYgby5nb1RvT3B0aW9uKGhuLk5vdGhpbmcpKTtcbiAgfVxuICByZXR1cm4gKCkgPT4ge1xuICAgIGxldCB7IGRpc2FibGVkOiBnIH0gPSB0LCB2ID0geyBhY3RpdmU6IGwudmFsdWUsIHNlbGVjdGVkOiBjLnZhbHVlLCBkaXNhYmxlZDogZyB9LCB7IHZhbHVlOiBTLCBkaXNhYmxlZDogdywgLi4uayB9ID0gdCwgXyA9IHsgaWQ6IHMsIHJlZjogYSwgcm9sZTogXCJvcHRpb25cIiwgdGFiSW5kZXg6IGcgPT09ICEwID8gdm9pZCAwIDogLTEsIFwiYXJpYS1kaXNhYmxlZFwiOiBnID09PSAhMCA/ICEwIDogdm9pZCAwLCBcImFyaWEtc2VsZWN0ZWRcIjogYy52YWx1ZSwgZGlzYWJsZWQ6IHZvaWQgMCwgb25DbGljazogaCwgb25Gb2N1czogcCwgb25Qb2ludGVyZW50ZXI6IG0sIG9uTW91c2VlbnRlcjogbSwgb25Qb2ludGVybW92ZTogeSwgb25Nb3VzZW1vdmU6IHksIG9uUG9pbnRlcmxlYXZlOiBiLCBvbk1vdXNlbGVhdmU6IGIgfTtcbiAgICByZXR1cm4gRXQoeyBvdXJQcm9wczogXywgdGhlaXJQcm9wczogaywgc2xvdDogdiwgYXR0cnM6IG4sIHNsb3RzOiBlLCBuYW1lOiBcIkxpc3Rib3hPcHRpb25cIiB9KTtcbiAgfTtcbn0gfSksIEFDID0gLyogQF9fUFVSRV9fICovIGxlKHsgcHJvcHM6IHsgb25Gb2N1czogeyB0eXBlOiBGdW5jdGlvbiwgcmVxdWlyZWQ6ICEwIH0gfSwgc2V0dXAodCkge1xuICBsZXQgZSA9IEcoITApO1xuICByZXR1cm4gKCkgPT4gZS52YWx1ZSA/IGt0KFZvLCB7IGFzOiBcImJ1dHRvblwiLCB0eXBlOiBcImJ1dHRvblwiLCBmZWF0dXJlczogWm8uRm9jdXNhYmxlLCBvbkZvY3VzKG4pIHtcbiAgICBuLnByZXZlbnREZWZhdWx0KCk7XG4gICAgbGV0IHIsIGkgPSA1MDtcbiAgICBmdW5jdGlvbiBzKCkge1xuICAgICAgdmFyIG87XG4gICAgICBpZiAoaS0tIDw9IDApIHtcbiAgICAgICAgciAmJiBjYW5jZWxBbmltYXRpb25GcmFtZShyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKChvID0gdC5vbkZvY3VzKSAhPSBudWxsICYmIG8uY2FsbCh0KSkge1xuICAgICAgICBlLnZhbHVlID0gITEsIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHMpO1xuICAgIH1cbiAgICByID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHMpO1xuICB9IH0pIDogbnVsbDtcbn0gfSk7XG52YXIgUkMgPSAoKHQpID0+ICh0W3QuRm9yd2FyZHMgPSAwXSA9IFwiRm9yd2FyZHNcIiwgdFt0LkJhY2t3YXJkcyA9IDFdID0gXCJCYWNrd2FyZHNcIiwgdCkpKFJDIHx8IHt9KSwgTkMgPSAoKHQpID0+ICh0W3QuTGVzcyA9IC0xXSA9IFwiTGVzc1wiLCB0W3QuRXF1YWwgPSAwXSA9IFwiRXF1YWxcIiwgdFt0LkdyZWF0ZXIgPSAxXSA9IFwiR3JlYXRlclwiLCB0KSkoTkMgfHwge30pO1xubGV0IE1TID0gU3ltYm9sKFwiVGFic0NvbnRleHRcIik7XG5mdW5jdGlvbiBCbCh0KSB7XG4gIGxldCBlID0gUHQoTVMsIG51bGwpO1xuICBpZiAoZSA9PT0gbnVsbCkge1xuICAgIGxldCBuID0gbmV3IEVycm9yKGA8JHt0fSAvPiBpcyBtaXNzaW5nIGEgcGFyZW50IDxUYWJHcm91cCAvPiBjb21wb25lbnQuYCk7XG4gICAgdGhyb3cgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgJiYgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UobiwgQmwpLCBuO1xuICB9XG4gIHJldHVybiBlO1xufVxubGV0IFhPID0gU3ltYm9sKFwiVGFic1NTUkNvbnRleHRcIiksIERDID0gLyogQF9fUFVSRV9fICovIGxlKHsgbmFtZTogXCJUYWJHcm91cFwiLCBlbWl0czogeyBjaGFuZ2U6ICh0KSA9PiAhMCB9LCBwcm9wczogeyBhczogeyB0eXBlOiBbT2JqZWN0LCBTdHJpbmddLCBkZWZhdWx0OiBcInRlbXBsYXRlXCIgfSwgc2VsZWN0ZWRJbmRleDogeyB0eXBlOiBbTnVtYmVyXSwgZGVmYXVsdDogbnVsbCB9LCBkZWZhdWx0SW5kZXg6IHsgdHlwZTogW051bWJlcl0sIGRlZmF1bHQ6IDAgfSwgdmVydGljYWw6IHsgdHlwZTogW0Jvb2xlYW5dLCBkZWZhdWx0OiAhMSB9LCBtYW51YWw6IHsgdHlwZTogW0Jvb2xlYW5dLCBkZWZhdWx0OiAhMSB9IH0sIGluaGVyaXRBdHRyczogITEsIHNldHVwKHQsIHsgc2xvdHM6IGUsIGF0dHJzOiBuLCBlbWl0OiByIH0pIHtcbiAgdmFyIGk7XG4gIGxldCBzID0gRygoaSA9IHQuc2VsZWN0ZWRJbmRleCkgIT0gbnVsbCA/IGkgOiB0LmRlZmF1bHRJbmRleCksIG8gPSBHKFtdKSwgYSA9IEcoW10pLCBsID0gaigoKSA9PiB0LnNlbGVjdGVkSW5kZXggIT09IG51bGwpLCBjID0gaigoKSA9PiBsLnZhbHVlID8gdC5zZWxlY3RlZEluZGV4IDogcy52YWx1ZSk7XG4gIGZ1bmN0aW9uIHUoTykge1xuICAgIHZhciBtO1xuICAgIGxldCB5ID0gdnMoZC50YWJzLnZhbHVlLCBwZSksIGIgPSB2cyhkLnBhbmVscy52YWx1ZSwgcGUpLCBnID0geS5maWx0ZXIoKHYpID0+IHtcbiAgICAgIHZhciBTO1xuICAgICAgcmV0dXJuICEoKFMgPSBwZSh2KSkgIT0gbnVsbCAmJiBTLmhhc0F0dHJpYnV0ZShcImRpc2FibGVkXCIpKTtcbiAgICB9KTtcbiAgICBpZiAoTyA8IDAgfHwgTyA+IHkubGVuZ3RoIC0gMSkge1xuICAgICAgbGV0IHYgPSBUdChzLnZhbHVlID09PSBudWxsID8gMCA6IE1hdGguc2lnbihPIC0gcy52YWx1ZSksIHsgWy0xXTogKCkgPT4gMSwgMDogKCkgPT4gVHQoTWF0aC5zaWduKE8pLCB7IFstMV06ICgpID0+IDAsIDA6ICgpID0+IDAsIDE6ICgpID0+IDEgfSksIDE6ICgpID0+IDAgfSksIFMgPSBUdCh2LCB7IDA6ICgpID0+IHkuaW5kZXhPZihnWzBdKSwgMTogKCkgPT4geS5pbmRleE9mKGdbZy5sZW5ndGggLSAxXSkgfSk7XG4gICAgICBTICE9PSAtMSAmJiAocy52YWx1ZSA9IFMpLCBkLnRhYnMudmFsdWUgPSB5LCBkLnBhbmVscy52YWx1ZSA9IGI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB2ID0geS5zbGljZSgwLCBPKSwgUyA9IFsuLi55LnNsaWNlKE8pLCAuLi52XS5maW5kKChrKSA9PiBnLmluY2x1ZGVzKGspKTtcbiAgICAgIGlmICghUylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbGV0IHcgPSAobSA9IHkuaW5kZXhPZihTKSkgIT0gbnVsbCA/IG0gOiBkLnNlbGVjdGVkSW5kZXgudmFsdWU7XG4gICAgICB3ID09PSAtMSAmJiAodyA9IGQuc2VsZWN0ZWRJbmRleC52YWx1ZSksIHMudmFsdWUgPSB3LCBkLnRhYnMudmFsdWUgPSB5LCBkLnBhbmVscy52YWx1ZSA9IGI7XG4gICAgfVxuICB9XG4gIGxldCBkID0geyBzZWxlY3RlZEluZGV4OiBqKCgpID0+IHtcbiAgICB2YXIgTywgbTtcbiAgICByZXR1cm4gKG0gPSAoTyA9IHMudmFsdWUpICE9IG51bGwgPyBPIDogdC5kZWZhdWx0SW5kZXgpICE9IG51bGwgPyBtIDogbnVsbDtcbiAgfSksIG9yaWVudGF0aW9uOiBqKCgpID0+IHQudmVydGljYWwgPyBcInZlcnRpY2FsXCIgOiBcImhvcml6b250YWxcIiksIGFjdGl2YXRpb246IGooKCkgPT4gdC5tYW51YWwgPyBcIm1hbnVhbFwiIDogXCJhdXRvXCIpLCB0YWJzOiBvLCBwYW5lbHM6IGEsIHNldFNlbGVjdGVkSW5kZXgoTykge1xuICAgIGMudmFsdWUgIT09IE8gJiYgcihcImNoYW5nZVwiLCBPKSwgbC52YWx1ZSB8fCB1KE8pO1xuICB9LCByZWdpc3RlclRhYihPKSB7XG4gICAgdmFyIG07XG4gICAgaWYgKG8udmFsdWUuaW5jbHVkZXMoTykpXG4gICAgICByZXR1cm47XG4gICAgbGV0IHkgPSBvLnZhbHVlW3MudmFsdWVdO1xuICAgIGlmIChvLnZhbHVlLnB1c2goTyksIG8udmFsdWUgPSB2cyhvLnZhbHVlLCBwZSksICFsLnZhbHVlKSB7XG4gICAgICBsZXQgYiA9IChtID0gby52YWx1ZS5pbmRleE9mKHkpKSAhPSBudWxsID8gbSA6IHMudmFsdWU7XG4gICAgICBiICE9PSAtMSAmJiAocy52YWx1ZSA9IGIpO1xuICAgIH1cbiAgfSwgdW5yZWdpc3RlclRhYihPKSB7XG4gICAgbGV0IG0gPSBvLnZhbHVlLmluZGV4T2YoTyk7XG4gICAgbSAhPT0gLTEgJiYgby52YWx1ZS5zcGxpY2UobSwgMSk7XG4gIH0sIHJlZ2lzdGVyUGFuZWwoTykge1xuICAgIGEudmFsdWUuaW5jbHVkZXMoTykgfHwgKGEudmFsdWUucHVzaChPKSwgYS52YWx1ZSA9IHZzKGEudmFsdWUsIHBlKSk7XG4gIH0sIHVucmVnaXN0ZXJQYW5lbChPKSB7XG4gICAgbGV0IG0gPSBhLnZhbHVlLmluZGV4T2YoTyk7XG4gICAgbSAhPT0gLTEgJiYgYS52YWx1ZS5zcGxpY2UobSwgMSk7XG4gIH0gfTtcbiAgX24oTVMsIGQpO1xuICBsZXQgZiA9IEcoeyB0YWJzOiBbXSwgcGFuZWxzOiBbXSB9KSwgaCA9IEcoITEpO1xuICBldCgoKSA9PiB7XG4gICAgaC52YWx1ZSA9ICEwO1xuICB9KSwgX24oWE8sIGooKCkgPT4gaC52YWx1ZSA/IG51bGwgOiBmLnZhbHVlKSk7XG4gIGxldCBwID0gaigoKSA9PiB0LnNlbGVjdGVkSW5kZXgpO1xuICByZXR1cm4gZXQoKCkgPT4ge1xuICAgIGh0KFtwXSwgKCkgPT4ge1xuICAgICAgdmFyIE87XG4gICAgICByZXR1cm4gdSgoTyA9IHQuc2VsZWN0ZWRJbmRleCkgIT0gbnVsbCA/IE8gOiB0LmRlZmF1bHRJbmRleCk7XG4gICAgfSwgeyBpbW1lZGlhdGU6ICEwIH0pO1xuICB9KSwgQm4oKCkgPT4ge1xuICAgIGlmICghbC52YWx1ZSB8fCBjLnZhbHVlID09IG51bGwgfHwgZC50YWJzLnZhbHVlLmxlbmd0aCA8PSAwKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCBPID0gdnMoZC50YWJzLnZhbHVlLCBwZSk7XG4gICAgTy5zb21lKChtLCB5KSA9PiBwZShkLnRhYnMudmFsdWVbeV0pICE9PSBwZShtKSkgJiYgZC5zZXRTZWxlY3RlZEluZGV4KE8uZmluZEluZGV4KChtKSA9PiBwZShtKSA9PT0gcGUoZC50YWJzLnZhbHVlW2MudmFsdWVdKSkpO1xuICB9KSwgKCkgPT4ge1xuICAgIGxldCBPID0geyBzZWxlY3RlZEluZGV4OiBzLnZhbHVlIH07XG4gICAgcmV0dXJuIGt0KFBlLCBbby52YWx1ZS5sZW5ndGggPD0gMCAmJiBrdChBQywgeyBvbkZvY3VzOiAoKSA9PiB7XG4gICAgICBmb3IgKGxldCBtIG9mIG8udmFsdWUpIHtcbiAgICAgICAgbGV0IHkgPSBwZShtKTtcbiAgICAgICAgaWYgKCh5ID09IG51bGwgPyB2b2lkIDAgOiB5LnRhYkluZGV4KSA9PT0gMClcbiAgICAgICAgICByZXR1cm4geS5mb2N1cygpLCAhMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAhMTtcbiAgICB9IH0pLCBFdCh7IHRoZWlyUHJvcHM6IHsgLi4ubiwgLi4uWk8odCwgW1wic2VsZWN0ZWRJbmRleFwiLCBcImRlZmF1bHRJbmRleFwiLCBcIm1hbnVhbFwiLCBcInZlcnRpY2FsXCIsIFwib25DaGFuZ2VcIl0pIH0sIG91clByb3BzOiB7fSwgc2xvdDogTywgc2xvdHM6IGUsIGF0dHJzOiBuLCBuYW1lOiBcIlRhYkdyb3VwXCIgfSldKTtcbiAgfTtcbn0gfSksIFpDID0gLyogQF9fUFVSRV9fICovIGxlKHsgbmFtZTogXCJUYWJMaXN0XCIsIHByb3BzOiB7IGFzOiB7IHR5cGU6IFtPYmplY3QsIFN0cmluZ10sIGRlZmF1bHQ6IFwiZGl2XCIgfSB9LCBzZXR1cCh0LCB7IGF0dHJzOiBlLCBzbG90czogbiB9KSB7XG4gIGxldCByID0gQmwoXCJUYWJMaXN0XCIpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGxldCBpID0geyBzZWxlY3RlZEluZGV4OiByLnNlbGVjdGVkSW5kZXgudmFsdWUgfSwgcyA9IHsgcm9sZTogXCJ0YWJsaXN0XCIsIFwiYXJpYS1vcmllbnRhdGlvblwiOiByLm9yaWVudGF0aW9uLnZhbHVlIH07XG4gICAgcmV0dXJuIEV0KHsgb3VyUHJvcHM6IHMsIHRoZWlyUHJvcHM6IHQsIHNsb3Q6IGksIGF0dHJzOiBlLCBzbG90czogbiwgbmFtZTogXCJUYWJMaXN0XCIgfSk7XG4gIH07XG59IH0pLCBjYiA9IC8qIEBfX1BVUkVfXyAqLyBsZSh7IG5hbWU6IFwiVGFiXCIsIHByb3BzOiB7IGFzOiB7IHR5cGU6IFtPYmplY3QsIFN0cmluZ10sIGRlZmF1bHQ6IFwiYnV0dG9uXCIgfSwgZGlzYWJsZWQ6IHsgdHlwZTogW0Jvb2xlYW5dLCBkZWZhdWx0OiAhMSB9LCBpZDogeyB0eXBlOiBTdHJpbmcsIGRlZmF1bHQ6IG51bGwgfSB9LCBzZXR1cCh0LCB7IGF0dHJzOiBlLCBzbG90czogbiwgZXhwb3NlOiByIH0pIHtcbiAgdmFyIGk7XG4gIGxldCBzID0gKGkgPSB0LmlkKSAhPSBudWxsID8gaSA6IGBoZWFkbGVzc3VpLXRhYnMtdGFiLSR7bXIoKX1gLCBvID0gQmwoXCJUYWJcIiksIGEgPSBHKG51bGwpO1xuICByKHsgZWw6IGEsICRlbDogYSB9KSwgZXQoKCkgPT4gby5yZWdpc3RlclRhYihhKSksIGp0KCgpID0+IG8udW5yZWdpc3RlclRhYihhKSk7XG4gIGxldCBsID0gUHQoWE8pLCBjID0gaigoKSA9PiB7XG4gICAgaWYgKGwudmFsdWUpIHtcbiAgICAgIGxldCBiID0gbC52YWx1ZS50YWJzLmluZGV4T2Yocyk7XG4gICAgICByZXR1cm4gYiA9PT0gLTEgPyBsLnZhbHVlLnRhYnMucHVzaChzKSAtIDEgOiBiO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH0pLCB1ID0gaigoKSA9PiB7XG4gICAgbGV0IGIgPSBvLnRhYnMudmFsdWUuaW5kZXhPZihhKTtcbiAgICByZXR1cm4gYiA9PT0gLTEgPyBjLnZhbHVlIDogYjtcbiAgfSksIGQgPSBqKCgpID0+IHUudmFsdWUgPT09IG8uc2VsZWN0ZWRJbmRleC52YWx1ZSk7XG4gIGZ1bmN0aW9uIGYoYikge1xuICAgIHZhciBnO1xuICAgIGxldCB2ID0gYigpO1xuICAgIGlmICh2ID09PSBoby5TdWNjZXNzICYmIG8uYWN0aXZhdGlvbi52YWx1ZSA9PT0gXCJhdXRvXCIpIHtcbiAgICAgIGxldCBTID0gKGcgPSB0byhhKSkgPT0gbnVsbCA/IHZvaWQgMCA6IGcuYWN0aXZlRWxlbWVudCwgdyA9IG8udGFicy52YWx1ZS5maW5kSW5kZXgoKGspID0+IHBlKGspID09PSBTKTtcbiAgICAgIHcgIT09IC0xICYmIG8uc2V0U2VsZWN0ZWRJbmRleCh3KTtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG4gIH1cbiAgZnVuY3Rpb24gaChiKSB7XG4gICAgbGV0IGcgPSBvLnRhYnMudmFsdWUubWFwKCh2KSA9PiBwZSh2KSkuZmlsdGVyKEJvb2xlYW4pO1xuICAgIGlmIChiLmtleSA9PT0gWGUuU3BhY2UgfHwgYi5rZXkgPT09IFhlLkVudGVyKSB7XG4gICAgICBiLnByZXZlbnREZWZhdWx0KCksIGIuc3RvcFByb3BhZ2F0aW9uKCksIG8uc2V0U2VsZWN0ZWRJbmRleCh1LnZhbHVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3dpdGNoIChiLmtleSkge1xuICAgICAgY2FzZSBYZS5Ib21lOlxuICAgICAgY2FzZSBYZS5QYWdlVXA6XG4gICAgICAgIHJldHVybiBiLnByZXZlbnREZWZhdWx0KCksIGIuc3RvcFByb3BhZ2F0aW9uKCksIGYoKCkgPT4gRXIoZywgV3QuRmlyc3QpKTtcbiAgICAgIGNhc2UgWGUuRW5kOlxuICAgICAgY2FzZSBYZS5QYWdlRG93bjpcbiAgICAgICAgcmV0dXJuIGIucHJldmVudERlZmF1bHQoKSwgYi5zdG9wUHJvcGFnYXRpb24oKSwgZigoKSA9PiBFcihnLCBXdC5MYXN0KSk7XG4gICAgfVxuICAgIGlmIChmKCgpID0+IFR0KG8ub3JpZW50YXRpb24udmFsdWUsIHsgdmVydGljYWwoKSB7XG4gICAgICByZXR1cm4gYi5rZXkgPT09IFhlLkFycm93VXAgPyBFcihnLCBXdC5QcmV2aW91cyB8IFd0LldyYXBBcm91bmQpIDogYi5rZXkgPT09IFhlLkFycm93RG93biA/IEVyKGcsIFd0Lk5leHQgfCBXdC5XcmFwQXJvdW5kKSA6IGhvLkVycm9yO1xuICAgIH0sIGhvcml6b250YWwoKSB7XG4gICAgICByZXR1cm4gYi5rZXkgPT09IFhlLkFycm93TGVmdCA/IEVyKGcsIFd0LlByZXZpb3VzIHwgV3QuV3JhcEFyb3VuZCkgOiBiLmtleSA9PT0gWGUuQXJyb3dSaWdodCA/IEVyKGcsIFd0Lk5leHQgfCBXdC5XcmFwQXJvdW5kKSA6IGhvLkVycm9yO1xuICAgIH0gfSkpID09PSBoby5TdWNjZXNzKVxuICAgICAgcmV0dXJuIGIucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBsZXQgcCA9IEcoITEpO1xuICBmdW5jdGlvbiBPKCkge1xuICAgIHZhciBiO1xuICAgIHAudmFsdWUgfHwgKHAudmFsdWUgPSAhMCwgIXQuZGlzYWJsZWQgJiYgKChiID0gcGUoYSkpID09IG51bGwgfHwgYi5mb2N1cyh7IHByZXZlbnRTY3JvbGw6ICEwIH0pLCBvLnNldFNlbGVjdGVkSW5kZXgodS52YWx1ZSksIENkKCgpID0+IHtcbiAgICAgIHAudmFsdWUgPSAhMTtcbiAgICB9KSkpO1xuICB9XG4gIGZ1bmN0aW9uIG0oYikge1xuICAgIGIucHJldmVudERlZmF1bHQoKTtcbiAgfVxuICBsZXQgeSA9IERPKGooKCkgPT4gKHsgYXM6IHQuYXMsIHR5cGU6IGUudHlwZSB9KSksIGEpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIHZhciBiLCBnO1xuICAgIGxldCB2ID0geyBzZWxlY3RlZDogZC52YWx1ZSwgZGlzYWJsZWQ6IChiID0gdC5kaXNhYmxlZCkgIT0gbnVsbCA/IGIgOiAhMSB9LCB7IC4uLlMgfSA9IHQsIHcgPSB7IHJlZjogYSwgb25LZXlkb3duOiBoLCBvbk1vdXNlZG93bjogbSwgb25DbGljazogTywgaWQ6IHMsIHJvbGU6IFwidGFiXCIsIHR5cGU6IHkudmFsdWUsIFwiYXJpYS1jb250cm9sc1wiOiAoZyA9IHBlKG8ucGFuZWxzLnZhbHVlW3UudmFsdWVdKSkgPT0gbnVsbCA/IHZvaWQgMCA6IGcuaWQsIFwiYXJpYS1zZWxlY3RlZFwiOiBkLnZhbHVlLCB0YWJJbmRleDogZC52YWx1ZSA/IDAgOiAtMSwgZGlzYWJsZWQ6IHQuZGlzYWJsZWQgPyAhMCA6IHZvaWQgMCB9O1xuICAgIHJldHVybiBFdCh7IG91clByb3BzOiB3LCB0aGVpclByb3BzOiBTLCBzbG90OiB2LCBhdHRyczogZSwgc2xvdHM6IG4sIG5hbWU6IFwiVGFiXCIgfSk7XG4gIH07XG59IH0pLCBWQyA9IC8qIEBfX1BVUkVfXyAqLyBsZSh7IG5hbWU6IFwiVGFiUGFuZWxzXCIsIHByb3BzOiB7IGFzOiB7IHR5cGU6IFtPYmplY3QsIFN0cmluZ10sIGRlZmF1bHQ6IFwiZGl2XCIgfSB9LCBzZXR1cCh0LCB7IHNsb3RzOiBlLCBhdHRyczogbiB9KSB7XG4gIGxldCByID0gQmwoXCJUYWJQYW5lbHNcIik7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgbGV0IGkgPSB7IHNlbGVjdGVkSW5kZXg6IHIuc2VsZWN0ZWRJbmRleC52YWx1ZSB9O1xuICAgIHJldHVybiBFdCh7IHRoZWlyUHJvcHM6IHQsIG91clByb3BzOiB7fSwgc2xvdDogaSwgYXR0cnM6IG4sIHNsb3RzOiBlLCBuYW1lOiBcIlRhYlBhbmVsc1wiIH0pO1xuICB9O1xufSB9KSwgdWIgPSAvKiBAX19QVVJFX18gKi8gbGUoeyBuYW1lOiBcIlRhYlBhbmVsXCIsIHByb3BzOiB7IGFzOiB7IHR5cGU6IFtPYmplY3QsIFN0cmluZ10sIGRlZmF1bHQ6IFwiZGl2XCIgfSwgc3RhdGljOiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6ICExIH0sIHVubW91bnQ6IHsgdHlwZTogQm9vbGVhbiwgZGVmYXVsdDogITAgfSwgaWQ6IHsgdHlwZTogU3RyaW5nLCBkZWZhdWx0OiBudWxsIH0sIHRhYkluZGV4OiB7IHR5cGU6IE51bWJlciwgZGVmYXVsdDogMCB9IH0sIHNldHVwKHQsIHsgYXR0cnM6IGUsIHNsb3RzOiBuLCBleHBvc2U6IHIgfSkge1xuICB2YXIgaTtcbiAgbGV0IHMgPSAoaSA9IHQuaWQpICE9IG51bGwgPyBpIDogYGhlYWRsZXNzdWktdGFicy1wYW5lbC0ke21yKCl9YCwgbyA9IEJsKFwiVGFiUGFuZWxcIiksIGEgPSBHKG51bGwpO1xuICByKHsgZWw6IGEsICRlbDogYSB9KSwgZXQoKCkgPT4gby5yZWdpc3RlclBhbmVsKGEpKSwganQoKCkgPT4gby51bnJlZ2lzdGVyUGFuZWwoYSkpO1xuICBsZXQgbCA9IFB0KFhPKSwgYyA9IGooKCkgPT4ge1xuICAgIGlmIChsLnZhbHVlKSB7XG4gICAgICBsZXQgZiA9IGwudmFsdWUucGFuZWxzLmluZGV4T2Yocyk7XG4gICAgICByZXR1cm4gZiA9PT0gLTEgPyBsLnZhbHVlLnBhbmVscy5wdXNoKHMpIC0gMSA6IGY7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfSksIHUgPSBqKCgpID0+IHtcbiAgICBsZXQgZiA9IG8ucGFuZWxzLnZhbHVlLmluZGV4T2YoYSk7XG4gICAgcmV0dXJuIGYgPT09IC0xID8gYy52YWx1ZSA6IGY7XG4gIH0pLCBkID0gaigoKSA9PiB1LnZhbHVlID09PSBvLnNlbGVjdGVkSW5kZXgudmFsdWUpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIHZhciBmO1xuICAgIGxldCBoID0geyBzZWxlY3RlZDogZC52YWx1ZSB9LCB7IHRhYkluZGV4OiBwLCAuLi5PIH0gPSB0LCBtID0geyByZWY6IGEsIGlkOiBzLCByb2xlOiBcInRhYnBhbmVsXCIsIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IChmID0gcGUoby50YWJzLnZhbHVlW3UudmFsdWVdKSkgPT0gbnVsbCA/IHZvaWQgMCA6IGYuaWQsIHRhYkluZGV4OiBkLnZhbHVlID8gcCA6IC0xIH07XG4gICAgcmV0dXJuICFkLnZhbHVlICYmIHQudW5tb3VudCAmJiAhdC5zdGF0aWMgPyBrdChWbywgeyBhczogXCJzcGFuXCIsIFwiYXJpYS1oaWRkZW5cIjogITAsIC4uLm0gfSkgOiBFdCh7IG91clByb3BzOiBtLCB0aGVpclByb3BzOiBPLCBzbG90OiBoLCBhdHRyczogZSwgc2xvdHM6IG4sIGZlYXR1cmVzOiBjaS5TdGF0aWMgfCBjaS5SZW5kZXJTdHJhdGVneSwgdmlzaWJsZTogZC52YWx1ZSwgbmFtZTogXCJUYWJQYW5lbFwiIH0pO1xuICB9O1xufSB9KTtcbmZ1bmN0aW9uIFhTKHQpIHtcbiAgcmV0dXJuIFJsKCkgPyAodE8odCksICEwKSA6ICExO1xufVxuZnVuY3Rpb24gbGwodCkge1xuICByZXR1cm4gdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiID8gdCgpIDogUih0KTtcbn1cbmNvbnN0IElDID0gdHlwZW9mIHdpbmRvdyA8IFwidVwiICYmIHR5cGVvZiBkb2N1bWVudCA8IFwidVwiO1xudHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlIDwgXCJ1XCIgJiYgZ2xvYmFsVGhpcyBpbnN0YW5jZW9mIFdvcmtlckdsb2JhbFNjb3BlO1xuY29uc3QgV0MgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLCBNQyA9ICh0KSA9PiBXQy5jYWxsKHQpID09PSBcIltvYmplY3QgT2JqZWN0XVwiLCBqUyA9ICgpID0+IHtcbn07XG5mdW5jdGlvbiBOaCh0LCBlLCBuKSB7XG4gIGNvbnN0IHIgPSBodChcbiAgICB0LFxuICAgIChpLCBzLCBvKSA9PiB7XG4gICAgICBpICYmIChuICE9IG51bGwgJiYgbi5vbmNlICYmIFBuKCgpID0+IHIoKSksIGUoaSwgcywgbykpO1xuICAgIH0sXG4gICAge1xuICAgICAgLi4ubixcbiAgICAgIG9uY2U6ICExXG4gICAgfVxuICApO1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIFhDKHQpIHtcbiAgdmFyIGU7XG4gIGNvbnN0IG4gPSBsbCh0KTtcbiAgcmV0dXJuIChlID0gbiA9PSBudWxsID8gdm9pZCAwIDogbi4kZWwpICE9IG51bGwgPyBlIDogbjtcbn1cbmNvbnN0IGpPID0gSUMgPyB3aW5kb3cgOiB2b2lkIDA7XG5mdW5jdGlvbiBTYyguLi50KSB7XG4gIGxldCBlLCBuLCByLCBpO1xuICBpZiAodHlwZW9mIHRbMF0gPT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KHRbMF0pID8gKFtuLCByLCBpXSA9IHQsIGUgPSBqTykgOiBbZSwgbiwgciwgaV0gPSB0LCAhZSlcbiAgICByZXR1cm4galM7XG4gIEFycmF5LmlzQXJyYXkobikgfHwgKG4gPSBbbl0pLCBBcnJheS5pc0FycmF5KHIpIHx8IChyID0gW3JdKTtcbiAgY29uc3QgcyA9IFtdLCBvID0gKCkgPT4ge1xuICAgIHMuZm9yRWFjaCgodSkgPT4gdSgpKSwgcy5sZW5ndGggPSAwO1xuICB9LCBhID0gKHUsIGQsIGYsIGgpID0+ICh1LmFkZEV2ZW50TGlzdGVuZXIoZCwgZiwgaCksICgpID0+IHUucmVtb3ZlRXZlbnRMaXN0ZW5lcihkLCBmLCBoKSksIGwgPSBodChcbiAgICAoKSA9PiBbWEMoZSksIGxsKGkpXSxcbiAgICAoW3UsIGRdKSA9PiB7XG4gICAgICBpZiAobygpLCAhdSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgZiA9IE1DKGQpID8geyAuLi5kIH0gOiBkO1xuICAgICAgcy5wdXNoKFxuICAgICAgICAuLi5uLmZsYXRNYXAoKGgpID0+IHIubWFwKChwKSA9PiBhKHUsIGgsIHAsIGYpKSlcbiAgICAgICk7XG4gICAgfSxcbiAgICB7IGltbWVkaWF0ZTogITAsIGZsdXNoOiBcInBvc3RcIiB9XG4gICksIGMgPSAoKSA9PiB7XG4gICAgbCgpLCBvKCk7XG4gIH07XG4gIHJldHVybiBYUyhjKSwgYztcbn1cbmZ1bmN0aW9uIGpDKCkge1xuICBjb25zdCB0ID0gRyghMSksIGUgPSBpcigpO1xuICByZXR1cm4gZSAmJiBldCgoKSA9PiB7XG4gICAgdC52YWx1ZSA9ICEwO1xuICB9LCBlKSwgdDtcbn1cbmZ1bmN0aW9uIEJDKHQpIHtcbiAgY29uc3QgZSA9IGpDKCk7XG4gIHJldHVybiBqKCgpID0+IChlLnZhbHVlLCAhIXQoKSkpO1xufVxuZnVuY3Rpb24gTEModCwgZSA9IHt9KSB7XG4gIGNvbnN0IHsgd2luZG93OiBuID0gak8gfSA9IGUsIHIgPSBCQygoKSA9PiBuICYmIFwibWF0Y2hNZWRpYVwiIGluIG4gJiYgdHlwZW9mIG4ubWF0Y2hNZWRpYSA9PSBcImZ1bmN0aW9uXCIpO1xuICBsZXQgaTtcbiAgY29uc3QgcyA9IEcoITEpLCBvID0gKGMpID0+IHtcbiAgICBzLnZhbHVlID0gYy5tYXRjaGVzO1xuICB9LCBhID0gKCkgPT4ge1xuICAgIGkgJiYgKFwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiIGluIGkgPyBpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgbykgOiBpLnJlbW92ZUxpc3RlbmVyKG8pKTtcbiAgfSwgbCA9IEJuKCgpID0+IHtcbiAgICByLnZhbHVlICYmIChhKCksIGkgPSBuLm1hdGNoTWVkaWEobGwodCkpLCBcImFkZEV2ZW50TGlzdGVuZXJcIiBpbiBpID8gaS5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIG8pIDogaS5hZGRMaXN0ZW5lcihvKSwgcy52YWx1ZSA9IGkubWF0Y2hlcyk7XG4gIH0pO1xuICByZXR1cm4gWFMoKCkgPT4ge1xuICAgIGwoKSwgYSgpLCBpID0gdm9pZCAwO1xuICB9KSwgcztcbn1cbmNvbnN0IGdhID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmZ1bmN0aW9uIFVDKHQpIHtcbiAgY29uc3QgZSA9IFJsKCk7XG4gIGZ1bmN0aW9uIG4oYSkge1xuICAgIHZhciBsO1xuICAgIGNvbnN0IGMgPSBnYS5nZXQodCkgfHwgLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBjLmFkZChhKSwgZ2Euc2V0KHQsIGMpO1xuICAgIGNvbnN0IHUgPSAoKSA9PiBpKGEpO1xuICAgIHJldHVybiAobCA9IGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUuY2xlYW51cHMpID09IG51bGwgfHwgbC5wdXNoKHUpLCB1O1xuICB9XG4gIGZ1bmN0aW9uIHIoYSkge1xuICAgIGZ1bmN0aW9uIGwoLi4uYykge1xuICAgICAgaShsKSwgYSguLi5jKTtcbiAgICB9XG4gICAgcmV0dXJuIG4obCk7XG4gIH1cbiAgZnVuY3Rpb24gaShhKSB7XG4gICAgY29uc3QgbCA9IGdhLmdldCh0KTtcbiAgICBsICYmIChsLmRlbGV0ZShhKSwgbC5zaXplIHx8IHMoKSk7XG4gIH1cbiAgZnVuY3Rpb24gcygpIHtcbiAgICBnYS5kZWxldGUodCk7XG4gIH1cbiAgZnVuY3Rpb24gbyhhLCBsKSB7XG4gICAgdmFyIGM7XG4gICAgKGMgPSBnYS5nZXQodCkpID09IG51bGwgfHwgYy5mb3JFYWNoKCh1KSA9PiB1KGEsIGwpKTtcbiAgfVxuICByZXR1cm4geyBvbjogbiwgb25jZTogciwgb2ZmOiBpLCBlbWl0OiBvLCByZXNldDogcyB9O1xufVxuY29uc3QgcUMgPSB7XG4gIGN0cmw6IFwiY29udHJvbFwiLFxuICBjb21tYW5kOiBcIm1ldGFcIixcbiAgY21kOiBcIm1ldGFcIixcbiAgb3B0aW9uOiBcImFsdFwiLFxuICB1cDogXCJhcnJvd3VwXCIsXG4gIGRvd246IFwiYXJyb3dkb3duXCIsXG4gIGxlZnQ6IFwiYXJyb3dsZWZ0XCIsXG4gIHJpZ2h0OiBcImFycm93cmlnaHRcIlxufTtcbmZ1bmN0aW9uIEJTKHQgPSB7fSkge1xuICBjb25zdCB7XG4gICAgcmVhY3RpdmU6IGUgPSAhMSxcbiAgICB0YXJnZXQ6IG4gPSBqTyxcbiAgICBhbGlhc01hcDogciA9IHFDLFxuICAgIHBhc3NpdmU6IGkgPSAhMCxcbiAgICBvbkV2ZW50RmlyZWQ6IHMgPSBqU1xuICB9ID0gdCwgbyA9IFhuKC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpLCBhID0ge1xuICAgIHRvSlNPTigpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9LFxuICAgIGN1cnJlbnQ6IG9cbiAgfSwgbCA9IGUgPyBYbihhKSA6IGEsIGMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLCB1ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgZnVuY3Rpb24gZChPLCBtKSB7XG4gICAgTyBpbiBsICYmIChlID8gbFtPXSA9IG0gOiBsW09dLnZhbHVlID0gbSk7XG4gIH1cbiAgZnVuY3Rpb24gZigpIHtcbiAgICBvLmNsZWFyKCk7XG4gICAgZm9yIChjb25zdCBPIG9mIHUpXG4gICAgICBkKE8sICExKTtcbiAgfVxuICBmdW5jdGlvbiBoKE8sIG0pIHtcbiAgICB2YXIgeSwgYjtcbiAgICBjb25zdCBnID0gKHkgPSBPLmtleSkgPT0gbnVsbCA/IHZvaWQgMCA6IHkudG9Mb3dlckNhc2UoKSwgUyA9IFsoYiA9IE8uY29kZSkgPT0gbnVsbCA/IHZvaWQgMCA6IGIudG9Mb3dlckNhc2UoKSwgZ10uZmlsdGVyKEJvb2xlYW4pO1xuICAgIGcgJiYgKG0gPyBvLmFkZChnKSA6IG8uZGVsZXRlKGcpKTtcbiAgICBmb3IgKGNvbnN0IHcgb2YgUylcbiAgICAgIHUuYWRkKHcpLCBkKHcsIG0pO1xuICAgIGcgPT09IFwibWV0YVwiICYmICFtID8gKGMuZm9yRWFjaCgodykgPT4ge1xuICAgICAgby5kZWxldGUodyksIGQodywgITEpO1xuICAgIH0pLCBjLmNsZWFyKCkpIDogdHlwZW9mIE8uZ2V0TW9kaWZpZXJTdGF0ZSA9PSBcImZ1bmN0aW9uXCIgJiYgTy5nZXRNb2RpZmllclN0YXRlKFwiTWV0YVwiKSAmJiBtICYmIFsuLi5vLCAuLi5TXS5mb3JFYWNoKCh3KSA9PiBjLmFkZCh3KSk7XG4gIH1cbiAgU2MobiwgXCJrZXlkb3duXCIsIChPKSA9PiAoaChPLCAhMCksIHMoTykpLCB7IHBhc3NpdmU6IGkgfSksIFNjKG4sIFwia2V5dXBcIiwgKE8pID0+IChoKE8sICExKSwgcyhPKSksIHsgcGFzc2l2ZTogaSB9KSwgU2MoXCJibHVyXCIsIGYsIHsgcGFzc2l2ZTogITAgfSksIFNjKFwiZm9jdXNcIiwgZiwgeyBwYXNzaXZlOiAhMCB9KTtcbiAgY29uc3QgcCA9IG5ldyBQcm94eShcbiAgICBsLFxuICAgIHtcbiAgICAgIGdldChPLCBtLCB5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgbSAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldChPLCBtLCB5KTtcbiAgICAgICAgaWYgKG0gPSBtLnRvTG93ZXJDYXNlKCksIG0gaW4gciAmJiAobSA9IHJbbV0pLCAhKG0gaW4gbCkpXG4gICAgICAgICAgaWYgKC9bK18tXS8udGVzdChtKSkge1xuICAgICAgICAgICAgY29uc3QgZyA9IG0uc3BsaXQoL1srXy1dL2cpLm1hcCgodikgPT4gdi50cmltKCkpO1xuICAgICAgICAgICAgbFttXSA9IGooKCkgPT4gZy5ldmVyeSgodikgPT4gbGwocFt2XSkpKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIGxbbV0gPSBHKCExKTtcbiAgICAgICAgY29uc3QgYiA9IFJlZmxlY3QuZ2V0KE8sIG0sIHkpO1xuICAgICAgICByZXR1cm4gZSA/IGxsKGIpIDogYjtcbiAgICAgIH1cbiAgICB9XG4gICk7XG4gIHJldHVybiBwO1xufVxuZnVuY3Rpb24gTFModCwgZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHQuYXBwbHkoZSwgYXJndW1lbnRzKTtcbiAgfTtcbn1cbmNvbnN0IHsgdG9TdHJpbmc6IFlDIH0gPSBPYmplY3QucHJvdG90eXBlLCB7IGdldFByb3RvdHlwZU9mOiBCTyB9ID0gT2JqZWN0LCBSZCA9IC8qIEBfX1BVUkVfXyAqLyAoKHQpID0+IChlKSA9PiB7XG4gIGNvbnN0IG4gPSBZQy5jYWxsKGUpO1xuICByZXR1cm4gdFtuXSB8fCAodFtuXSA9IG4uc2xpY2UoOCwgLTEpLnRvTG93ZXJDYXNlKCkpO1xufSkoLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCkpLCBMciA9ICh0KSA9PiAodCA9IHQudG9Mb3dlckNhc2UoKSwgKGUpID0+IFJkKGUpID09PSB0KSwgTmQgPSAodCkgPT4gKGUpID0+IHR5cGVvZiBlID09PSB0LCB7IGlzQXJyYXk6IG5hIH0gPSBBcnJheSwgY2wgPSBOZChcInVuZGVmaW5lZFwiKTtcbmZ1bmN0aW9uIHpDKHQpIHtcbiAgcmV0dXJuIHQgIT09IG51bGwgJiYgIWNsKHQpICYmIHQuY29uc3RydWN0b3IgIT09IG51bGwgJiYgIWNsKHQuY29uc3RydWN0b3IpICYmIGVyKHQuY29uc3RydWN0b3IuaXNCdWZmZXIpICYmIHQuY29uc3RydWN0b3IuaXNCdWZmZXIodCk7XG59XG5jb25zdCBVUyA9IExyKFwiQXJyYXlCdWZmZXJcIik7XG5mdW5jdGlvbiBIQyh0KSB7XG4gIGxldCBlO1xuICByZXR1cm4gdHlwZW9mIEFycmF5QnVmZmVyIDwgXCJ1XCIgJiYgQXJyYXlCdWZmZXIuaXNWaWV3ID8gZSA9IEFycmF5QnVmZmVyLmlzVmlldyh0KSA6IGUgPSB0ICYmIHQuYnVmZmVyICYmIFVTKHQuYnVmZmVyKSwgZTtcbn1cbmNvbnN0IEZDID0gTmQoXCJzdHJpbmdcIiksIGVyID0gTmQoXCJmdW5jdGlvblwiKSwgcVMgPSBOZChcIm51bWJlclwiKSwgRGQgPSAodCkgPT4gdCAhPT0gbnVsbCAmJiB0eXBlb2YgdCA9PSBcIm9iamVjdFwiLCBHQyA9ICh0KSA9PiB0ID09PSAhMCB8fCB0ID09PSAhMSwgS2MgPSAodCkgPT4ge1xuICBpZiAoUmQodCkgIT09IFwib2JqZWN0XCIpXG4gICAgcmV0dXJuICExO1xuICBjb25zdCBlID0gQk8odCk7XG4gIHJldHVybiAoZSA9PT0gbnVsbCB8fCBlID09PSBPYmplY3QucHJvdG90eXBlIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihlKSA9PT0gbnVsbCkgJiYgIShTeW1ib2wudG9TdHJpbmdUYWcgaW4gdCkgJiYgIShTeW1ib2wuaXRlcmF0b3IgaW4gdCk7XG59LCBLQyA9IExyKFwiRGF0ZVwiKSwgSkMgPSBMcihcIkZpbGVcIiksIGVBID0gTHIoXCJCbG9iXCIpLCB0QSA9IExyKFwiRmlsZUxpc3RcIiksIG5BID0gKHQpID0+IERkKHQpICYmIGVyKHQucGlwZSksIHJBID0gKHQpID0+IHtcbiAgbGV0IGU7XG4gIHJldHVybiB0ICYmICh0eXBlb2YgRm9ybURhdGEgPT0gXCJmdW5jdGlvblwiICYmIHQgaW5zdGFuY2VvZiBGb3JtRGF0YSB8fCBlcih0LmFwcGVuZCkgJiYgKChlID0gUmQodCkpID09PSBcImZvcm1kYXRhXCIgfHwgLy8gZGV0ZWN0IGZvcm0tZGF0YSBpbnN0YW5jZVxuICBlID09PSBcIm9iamVjdFwiICYmIGVyKHQudG9TdHJpbmcpICYmIHQudG9TdHJpbmcoKSA9PT0gXCJbb2JqZWN0IEZvcm1EYXRhXVwiKSk7XG59LCBpQSA9IExyKFwiVVJMU2VhcmNoUGFyYW1zXCIpLCBzQSA9ICh0KSA9PiB0LnRyaW0gPyB0LnRyaW0oKSA6IHQucmVwbGFjZSgvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csIFwiXCIpO1xuZnVuY3Rpb24gTGwodCwgZSwgeyBhbGxPd25LZXlzOiBuID0gITEgfSA9IHt9KSB7XG4gIGlmICh0ID09PSBudWxsIHx8IHR5cGVvZiB0ID4gXCJ1XCIpXG4gICAgcmV0dXJuO1xuICBsZXQgciwgaTtcbiAgaWYgKHR5cGVvZiB0ICE9IFwib2JqZWN0XCIgJiYgKHQgPSBbdF0pLCBuYSh0KSlcbiAgICBmb3IgKHIgPSAwLCBpID0gdC5sZW5ndGg7IHIgPCBpOyByKyspXG4gICAgICBlLmNhbGwobnVsbCwgdFtyXSwgciwgdCk7XG4gIGVsc2Uge1xuICAgIGNvbnN0IHMgPSBuID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModCkgOiBPYmplY3Qua2V5cyh0KSwgbyA9IHMubGVuZ3RoO1xuICAgIGxldCBhO1xuICAgIGZvciAociA9IDA7IHIgPCBvOyByKyspXG4gICAgICBhID0gc1tyXSwgZS5jYWxsKG51bGwsIHRbYV0sIGEsIHQpO1xuICB9XG59XG5mdW5jdGlvbiBZUyh0LCBlKSB7XG4gIGUgPSBlLnRvTG93ZXJDYXNlKCk7XG4gIGNvbnN0IG4gPSBPYmplY3Qua2V5cyh0KTtcbiAgbGV0IHIgPSBuLmxlbmd0aCwgaTtcbiAgZm9yICg7IHItLSA+IDA7IClcbiAgICBpZiAoaSA9IG5bcl0sIGUgPT09IGkudG9Mb3dlckNhc2UoKSlcbiAgICAgIHJldHVybiBpO1xuICByZXR1cm4gbnVsbDtcbn1cbmNvbnN0IHpTID0gdHlwZW9mIGdsb2JhbFRoaXMgPCBcInVcIiA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygc2VsZiA8IFwidVwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgPCBcInVcIiA/IHdpbmRvdyA6IGdsb2JhbCwgSFMgPSAodCkgPT4gIWNsKHQpICYmIHQgIT09IHpTO1xuZnVuY3Rpb24gRGgoKSB7XG4gIGNvbnN0IHsgY2FzZWxlc3M6IHQgfSA9IEhTKHRoaXMpICYmIHRoaXMgfHwge30sIGUgPSB7fSwgbiA9IChyLCBpKSA9PiB7XG4gICAgY29uc3QgcyA9IHQgJiYgWVMoZSwgaSkgfHwgaTtcbiAgICBLYyhlW3NdKSAmJiBLYyhyKSA/IGVbc10gPSBEaChlW3NdLCByKSA6IEtjKHIpID8gZVtzXSA9IERoKHt9LCByKSA6IG5hKHIpID8gZVtzXSA9IHIuc2xpY2UoKSA6IGVbc10gPSByO1xuICB9O1xuICBmb3IgKGxldCByID0gMCwgaSA9IGFyZ3VtZW50cy5sZW5ndGg7IHIgPCBpOyByKyspXG4gICAgYXJndW1lbnRzW3JdICYmIExsKGFyZ3VtZW50c1tyXSwgbik7XG4gIHJldHVybiBlO1xufVxuY29uc3Qgb0EgPSAodCwgZSwgbiwgeyBhbGxPd25LZXlzOiByIH0gPSB7fSkgPT4gKExsKGUsIChpLCBzKSA9PiB7XG4gIG4gJiYgZXIoaSkgPyB0W3NdID0gTFMoaSwgbikgOiB0W3NdID0gaTtcbn0sIHsgYWxsT3duS2V5czogciB9KSwgdCksIGFBID0gKHQpID0+ICh0LmNoYXJDb2RlQXQoMCkgPT09IDY1Mjc5ICYmICh0ID0gdC5zbGljZSgxKSksIHQpLCBsQSA9ICh0LCBlLCBuLCByKSA9PiB7XG4gIHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlLnByb3RvdHlwZSwgciksIHQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gdCwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwic3VwZXJcIiwge1xuICAgIHZhbHVlOiBlLnByb3RvdHlwZVxuICB9KSwgbiAmJiBPYmplY3QuYXNzaWduKHQucHJvdG90eXBlLCBuKTtcbn0sIGNBID0gKHQsIGUsIG4sIHIpID0+IHtcbiAgbGV0IGksIHMsIG87XG4gIGNvbnN0IGEgPSB7fTtcbiAgaWYgKGUgPSBlIHx8IHt9LCB0ID09IG51bGwpXG4gICAgcmV0dXJuIGU7XG4gIGRvIHtcbiAgICBmb3IgKGkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0KSwgcyA9IGkubGVuZ3RoOyBzLS0gPiAwOyApXG4gICAgICBvID0gaVtzXSwgKCFyIHx8IHIobywgdCwgZSkpICYmICFhW29dICYmIChlW29dID0gdFtvXSwgYVtvXSA9ICEwKTtcbiAgICB0ID0gbiAhPT0gITEgJiYgQk8odCk7XG4gIH0gd2hpbGUgKHQgJiYgKCFuIHx8IG4odCwgZSkpICYmIHQgIT09IE9iamVjdC5wcm90b3R5cGUpO1xuICByZXR1cm4gZTtcbn0sIHVBID0gKHQsIGUsIG4pID0+IHtcbiAgdCA9IFN0cmluZyh0KSwgKG4gPT09IHZvaWQgMCB8fCBuID4gdC5sZW5ndGgpICYmIChuID0gdC5sZW5ndGgpLCBuIC09IGUubGVuZ3RoO1xuICBjb25zdCByID0gdC5pbmRleE9mKGUsIG4pO1xuICByZXR1cm4gciAhPT0gLTEgJiYgciA9PT0gbjtcbn0sIGRBID0gKHQpID0+IHtcbiAgaWYgKCF0KVxuICAgIHJldHVybiBudWxsO1xuICBpZiAobmEodCkpXG4gICAgcmV0dXJuIHQ7XG4gIGxldCBlID0gdC5sZW5ndGg7XG4gIGlmICghcVMoZSkpXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IG4gPSBuZXcgQXJyYXkoZSk7XG4gIGZvciAoOyBlLS0gPiAwOyApXG4gICAgbltlXSA9IHRbZV07XG4gIHJldHVybiBuO1xufSwgZkEgPSAvKiBAX19QVVJFX18gKi8gKCh0KSA9PiAoZSkgPT4gdCAmJiBlIGluc3RhbmNlb2YgdCkodHlwZW9mIFVpbnQ4QXJyYXkgPCBcInVcIiAmJiBCTyhVaW50OEFycmF5KSksIGhBID0gKHQsIGUpID0+IHtcbiAgY29uc3QgciA9ICh0ICYmIHRbU3ltYm9sLml0ZXJhdG9yXSkuY2FsbCh0KTtcbiAgbGV0IGk7XG4gIGZvciAoOyAoaSA9IHIubmV4dCgpKSAmJiAhaS5kb25lOyApIHtcbiAgICBjb25zdCBzID0gaS52YWx1ZTtcbiAgICBlLmNhbGwodCwgc1swXSwgc1sxXSk7XG4gIH1cbn0sIHBBID0gKHQsIGUpID0+IHtcbiAgbGV0IG47XG4gIGNvbnN0IHIgPSBbXTtcbiAgZm9yICg7IChuID0gdC5leGVjKGUpKSAhPT0gbnVsbDsgKVxuICAgIHIucHVzaChuKTtcbiAgcmV0dXJuIHI7XG59LCBPQSA9IExyKFwiSFRNTEZvcm1FbGVtZW50XCIpLCBnQSA9ICh0KSA9PiB0LnRvTG93ZXJDYXNlKCkucmVwbGFjZShcbiAgL1stX1xcc10oW2EtelxcZF0pKFxcdyopL2csXG4gIGZ1bmN0aW9uKG4sIHIsIGkpIHtcbiAgICByZXR1cm4gci50b1VwcGVyQ2FzZSgpICsgaTtcbiAgfVxuKSwgZGIgPSAoKHsgaGFzT3duUHJvcGVydHk6IHQgfSkgPT4gKGUsIG4pID0+IHQuY2FsbChlLCBuKSkoT2JqZWN0LnByb3RvdHlwZSksIG1BID0gTHIoXCJSZWdFeHBcIiksIEZTID0gKHQsIGUpID0+IHtcbiAgY29uc3QgbiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpLCByID0ge307XG4gIExsKG4sIChpLCBzKSA9PiB7XG4gICAgbGV0IG87XG4gICAgKG8gPSBlKGksIHMsIHQpKSAhPT0gITEgJiYgKHJbc10gPSBvIHx8IGkpO1xuICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModCwgcik7XG59LCBiQSA9ICh0KSA9PiB7XG4gIEZTKHQsIChlLCBuKSA9PiB7XG4gICAgaWYgKGVyKHQpICYmIFtcImFyZ3VtZW50c1wiLCBcImNhbGxlclwiLCBcImNhbGxlZVwiXS5pbmRleE9mKG4pICE9PSAtMSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCByID0gdFtuXTtcbiAgICBpZiAoZXIocikpIHtcbiAgICAgIGlmIChlLmVudW1lcmFibGUgPSAhMSwgXCJ3cml0YWJsZVwiIGluIGUpIHtcbiAgICAgICAgZS53cml0YWJsZSA9ICExO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBlLnNldCB8fCAoZS5zZXQgPSAoKSA9PiB7XG4gICAgICAgIHRocm93IEVycm9yKFwiQ2FuIG5vdCByZXdyaXRlIHJlYWQtb25seSBtZXRob2QgJ1wiICsgbiArIFwiJ1wiKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59LCB2QSA9ICh0LCBlKSA9PiB7XG4gIGNvbnN0IG4gPSB7fSwgciA9IChpKSA9PiB7XG4gICAgaS5mb3JFYWNoKChzKSA9PiB7XG4gICAgICBuW3NdID0gITA7XG4gICAgfSk7XG4gIH07XG4gIHJldHVybiBuYSh0KSA/IHIodCkgOiByKFN0cmluZyh0KS5zcGxpdChlKSksIG47XG59LCB5QSA9ICgpID0+IHtcbn0sIFNBID0gKHQsIGUpID0+ICh0ID0gK3QsIE51bWJlci5pc0Zpbml0ZSh0KSA/IHQgOiBlKSwgYmYgPSBcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCIsIGZiID0gXCIwMTIzNDU2Nzg5XCIsIEdTID0ge1xuICBESUdJVDogZmIsXG4gIEFMUEhBOiBiZixcbiAgQUxQSEFfRElHSVQ6IGJmICsgYmYudG9VcHBlckNhc2UoKSArIGZiXG59LCB3QSA9ICh0ID0gMTYsIGUgPSBHUy5BTFBIQV9ESUdJVCkgPT4ge1xuICBsZXQgbiA9IFwiXCI7XG4gIGNvbnN0IHsgbGVuZ3RoOiByIH0gPSBlO1xuICBmb3IgKDsgdC0tOyApXG4gICAgbiArPSBlW01hdGgucmFuZG9tKCkgKiByIHwgMF07XG4gIHJldHVybiBuO1xufTtcbmZ1bmN0aW9uIGtBKHQpIHtcbiAgcmV0dXJuICEhKHQgJiYgZXIodC5hcHBlbmQpICYmIHRbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gXCJGb3JtRGF0YVwiICYmIHRbU3ltYm9sLml0ZXJhdG9yXSk7XG59XG5jb25zdCB4QSA9ICh0KSA9PiB7XG4gIGNvbnN0IGUgPSBuZXcgQXJyYXkoMTApLCBuID0gKHIsIGkpID0+IHtcbiAgICBpZiAoRGQocikpIHtcbiAgICAgIGlmIChlLmluZGV4T2YocikgPj0gMClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKCEoXCJ0b0pTT05cIiBpbiByKSkge1xuICAgICAgICBlW2ldID0gcjtcbiAgICAgICAgY29uc3QgcyA9IG5hKHIpID8gW10gOiB7fTtcbiAgICAgICAgcmV0dXJuIExsKHIsIChvLCBhKSA9PiB7XG4gICAgICAgICAgY29uc3QgbCA9IG4obywgaSArIDEpO1xuICAgICAgICAgICFjbChsKSAmJiAoc1thXSA9IGwpO1xuICAgICAgICB9KSwgZVtpXSA9IHZvaWQgMCwgcztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH07XG4gIHJldHVybiBuKHQsIDApO1xufSwgUEEgPSBMcihcIkFzeW5jRnVuY3Rpb25cIiksIF9BID0gKHQpID0+IHQgJiYgKERkKHQpIHx8IGVyKHQpKSAmJiBlcih0LnRoZW4pICYmIGVyKHQuY2F0Y2gpLCBWID0ge1xuICBpc0FycmF5OiBuYSxcbiAgaXNBcnJheUJ1ZmZlcjogVVMsXG4gIGlzQnVmZmVyOiB6QyxcbiAgaXNGb3JtRGF0YTogckEsXG4gIGlzQXJyYXlCdWZmZXJWaWV3OiBIQyxcbiAgaXNTdHJpbmc6IEZDLFxuICBpc051bWJlcjogcVMsXG4gIGlzQm9vbGVhbjogR0MsXG4gIGlzT2JqZWN0OiBEZCxcbiAgaXNQbGFpbk9iamVjdDogS2MsXG4gIGlzVW5kZWZpbmVkOiBjbCxcbiAgaXNEYXRlOiBLQyxcbiAgaXNGaWxlOiBKQyxcbiAgaXNCbG9iOiBlQSxcbiAgaXNSZWdFeHA6IG1BLFxuICBpc0Z1bmN0aW9uOiBlcixcbiAgaXNTdHJlYW06IG5BLFxuICBpc1VSTFNlYXJjaFBhcmFtczogaUEsXG4gIGlzVHlwZWRBcnJheTogZkEsXG4gIGlzRmlsZUxpc3Q6IHRBLFxuICBmb3JFYWNoOiBMbCxcbiAgbWVyZ2U6IERoLFxuICBleHRlbmQ6IG9BLFxuICB0cmltOiBzQSxcbiAgc3RyaXBCT006IGFBLFxuICBpbmhlcml0czogbEEsXG4gIHRvRmxhdE9iamVjdDogY0EsXG4gIGtpbmRPZjogUmQsXG4gIGtpbmRPZlRlc3Q6IExyLFxuICBlbmRzV2l0aDogdUEsXG4gIHRvQXJyYXk6IGRBLFxuICBmb3JFYWNoRW50cnk6IGhBLFxuICBtYXRjaEFsbDogcEEsXG4gIGlzSFRNTEZvcm06IE9BLFxuICBoYXNPd25Qcm9wZXJ0eTogZGIsXG4gIGhhc093blByb3A6IGRiLFxuICAvLyBhbiBhbGlhcyB0byBhdm9pZCBFU0xpbnQgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIGRldGVjdGlvblxuICByZWR1Y2VEZXNjcmlwdG9yczogRlMsXG4gIGZyZWV6ZU1ldGhvZHM6IGJBLFxuICB0b09iamVjdFNldDogdkEsXG4gIHRvQ2FtZWxDYXNlOiBnQSxcbiAgbm9vcDogeUEsXG4gIHRvRmluaXRlTnVtYmVyOiBTQSxcbiAgZmluZEtleTogWVMsXG4gIGdsb2JhbDogelMsXG4gIGlzQ29udGV4dERlZmluZWQ6IEhTLFxuICBBTFBIQUJFVDogR1MsXG4gIGdlbmVyYXRlU3RyaW5nOiB3QSxcbiAgaXNTcGVjQ29tcGxpYW50Rm9ybToga0EsXG4gIHRvSlNPTk9iamVjdDogeEEsXG4gIGlzQXN5bmNGbjogUEEsXG4gIGlzVGhlbmFibGU6IF9BXG59O1xuZnVuY3Rpb24gamUodCwgZSwgbiwgciwgaSkge1xuICBFcnJvci5jYWxsKHRoaXMpLCBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA/IEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpIDogdGhpcy5zdGFjayA9IG5ldyBFcnJvcigpLnN0YWNrLCB0aGlzLm1lc3NhZ2UgPSB0LCB0aGlzLm5hbWUgPSBcIkF4aW9zRXJyb3JcIiwgZSAmJiAodGhpcy5jb2RlID0gZSksIG4gJiYgKHRoaXMuY29uZmlnID0gbiksIHIgJiYgKHRoaXMucmVxdWVzdCA9IHIpLCBpICYmICh0aGlzLnJlc3BvbnNlID0gaSk7XG59XG5WLmluaGVyaXRzKGplLCBFcnJvciwge1xuICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvLyBTdGFuZGFyZFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgLy8gTWljcm9zb2Z0XG4gICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICAgIG51bWJlcjogdGhpcy5udW1iZXIsXG4gICAgICAvLyBNb3ppbGxhXG4gICAgICBmaWxlTmFtZTogdGhpcy5maWxlTmFtZSxcbiAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcbiAgICAgIGNvbHVtbk51bWJlcjogdGhpcy5jb2x1bW5OdW1iZXIsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIC8vIEF4aW9zXG4gICAgICBjb25maWc6IFYudG9KU09OT2JqZWN0KHRoaXMuY29uZmlnKSxcbiAgICAgIGNvZGU6IHRoaXMuY29kZSxcbiAgICAgIHN0YXR1czogdGhpcy5yZXNwb25zZSAmJiB0aGlzLnJlc3BvbnNlLnN0YXR1cyA/IHRoaXMucmVzcG9uc2Uuc3RhdHVzIDogbnVsbFxuICAgIH07XG4gIH1cbn0pO1xuY29uc3QgS1MgPSBqZS5wcm90b3R5cGUsIEpTID0ge307XG5bXG4gIFwiRVJSX0JBRF9PUFRJT05fVkFMVUVcIixcbiAgXCJFUlJfQkFEX09QVElPTlwiLFxuICBcIkVDT05OQUJPUlRFRFwiLFxuICBcIkVUSU1FRE9VVFwiLFxuICBcIkVSUl9ORVRXT1JLXCIsXG4gIFwiRVJSX0ZSX1RPT19NQU5ZX1JFRElSRUNUU1wiLFxuICBcIkVSUl9ERVBSRUNBVEVEXCIsXG4gIFwiRVJSX0JBRF9SRVNQT05TRVwiLFxuICBcIkVSUl9CQURfUkVRVUVTVFwiLFxuICBcIkVSUl9DQU5DRUxFRFwiLFxuICBcIkVSUl9OT1RfU1VQUE9SVFwiLFxuICBcIkVSUl9JTlZBTElEX1VSTFwiXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5dLmZvckVhY2goKHQpID0+IHtcbiAgSlNbdF0gPSB7IHZhbHVlOiB0IH07XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGplLCBKUyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoS1MsIFwiaXNBeGlvc0Vycm9yXCIsIHsgdmFsdWU6ICEwIH0pO1xuamUuZnJvbSA9ICh0LCBlLCBuLCByLCBpLCBzKSA9PiB7XG4gIGNvbnN0IG8gPSBPYmplY3QuY3JlYXRlKEtTKTtcbiAgcmV0dXJuIFYudG9GbGF0T2JqZWN0KHQsIG8sIGZ1bmN0aW9uKGwpIHtcbiAgICByZXR1cm4gbCAhPT0gRXJyb3IucHJvdG90eXBlO1xuICB9LCAoYSkgPT4gYSAhPT0gXCJpc0F4aW9zRXJyb3JcIiksIGplLmNhbGwobywgdC5tZXNzYWdlLCBlLCBuLCByLCBpKSwgby5jYXVzZSA9IHQsIG8ubmFtZSA9IHQubmFtZSwgcyAmJiBPYmplY3QuYXNzaWduKG8sIHMpLCBvO1xufTtcbmNvbnN0IFRBID0gbnVsbDtcbmZ1bmN0aW9uIFpoKHQpIHtcbiAgcmV0dXJuIFYuaXNQbGFpbk9iamVjdCh0KSB8fCBWLmlzQXJyYXkodCk7XG59XG5mdW5jdGlvbiBldyh0KSB7XG4gIHJldHVybiBWLmVuZHNXaXRoKHQsIFwiW11cIikgPyB0LnNsaWNlKDAsIC0yKSA6IHQ7XG59XG5mdW5jdGlvbiBoYih0LCBlLCBuKSB7XG4gIHJldHVybiB0ID8gdC5jb25jYXQoZSkubWFwKGZ1bmN0aW9uKGksIHMpIHtcbiAgICByZXR1cm4gaSA9IGV3KGkpLCAhbiAmJiBzID8gXCJbXCIgKyBpICsgXCJdXCIgOiBpO1xuICB9KS5qb2luKG4gPyBcIi5cIiA6IFwiXCIpIDogZTtcbn1cbmZ1bmN0aW9uIEVBKHQpIHtcbiAgcmV0dXJuIFYuaXNBcnJheSh0KSAmJiAhdC5zb21lKFpoKTtcbn1cbmNvbnN0ICRBID0gVi50b0ZsYXRPYmplY3QoViwge30sIG51bGwsIGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIC9eaXNbQS1aXS8udGVzdChlKTtcbn0pO1xuZnVuY3Rpb24gWmQodCwgZSwgbikge1xuICBpZiAoIVYuaXNPYmplY3QodCkpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInRhcmdldCBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbiAgZSA9IGUgfHwgbmV3IEZvcm1EYXRhKCksIG4gPSBWLnRvRmxhdE9iamVjdChuLCB7XG4gICAgbWV0YVRva2VuczogITAsXG4gICAgZG90czogITEsXG4gICAgaW5kZXhlczogITFcbiAgfSwgITEsIGZ1bmN0aW9uKE8sIG0pIHtcbiAgICByZXR1cm4gIVYuaXNVbmRlZmluZWQobVtPXSk7XG4gIH0pO1xuICBjb25zdCByID0gbi5tZXRhVG9rZW5zLCBpID0gbi52aXNpdG9yIHx8IHUsIHMgPSBuLmRvdHMsIG8gPSBuLmluZGV4ZXMsIGwgPSAobi5CbG9iIHx8IHR5cGVvZiBCbG9iIDwgXCJ1XCIgJiYgQmxvYikgJiYgVi5pc1NwZWNDb21wbGlhbnRGb3JtKGUpO1xuICBpZiAoIVYuaXNGdW5jdGlvbihpKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwidmlzaXRvciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gIGZ1bmN0aW9uIGMocCkge1xuICAgIGlmIChwID09PSBudWxsKVxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgaWYgKFYuaXNEYXRlKHApKVxuICAgICAgcmV0dXJuIHAudG9JU09TdHJpbmcoKTtcbiAgICBpZiAoIWwgJiYgVi5pc0Jsb2IocCkpXG4gICAgICB0aHJvdyBuZXcgamUoXCJCbG9iIGlzIG5vdCBzdXBwb3J0ZWQuIFVzZSBhIEJ1ZmZlciBpbnN0ZWFkLlwiKTtcbiAgICByZXR1cm4gVi5pc0FycmF5QnVmZmVyKHApIHx8IFYuaXNUeXBlZEFycmF5KHApID8gbCAmJiB0eXBlb2YgQmxvYiA9PSBcImZ1bmN0aW9uXCIgPyBuZXcgQmxvYihbcF0pIDogQnVmZmVyLmZyb20ocCkgOiBwO1xuICB9XG4gIGZ1bmN0aW9uIHUocCwgTywgbSkge1xuICAgIGxldCB5ID0gcDtcbiAgICBpZiAocCAmJiAhbSAmJiB0eXBlb2YgcCA9PSBcIm9iamVjdFwiKSB7XG4gICAgICBpZiAoVi5lbmRzV2l0aChPLCBcInt9XCIpKVxuICAgICAgICBPID0gciA/IE8gOiBPLnNsaWNlKDAsIC0yKSwgcCA9IEpTT04uc3RyaW5naWZ5KHApO1xuICAgICAgZWxzZSBpZiAoVi5pc0FycmF5KHApICYmIEVBKHApIHx8IChWLmlzRmlsZUxpc3QocCkgfHwgVi5lbmRzV2l0aChPLCBcIltdXCIpKSAmJiAoeSA9IFYudG9BcnJheShwKSkpXG4gICAgICAgIHJldHVybiBPID0gZXcoTyksIHkuZm9yRWFjaChmdW5jdGlvbihnLCB2KSB7XG4gICAgICAgICAgIShWLmlzVW5kZWZpbmVkKGcpIHx8IGcgPT09IG51bGwpICYmIGUuYXBwZW5kKFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgICAgICAgICBvID09PSAhMCA/IGhiKFtPXSwgdiwgcykgOiBvID09PSBudWxsID8gTyA6IE8gKyBcIltdXCIsXG4gICAgICAgICAgICBjKGcpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSksICExO1xuICAgIH1cbiAgICByZXR1cm4gWmgocCkgPyAhMCA6IChlLmFwcGVuZChoYihtLCBPLCBzKSwgYyhwKSksICExKTtcbiAgfVxuICBjb25zdCBkID0gW10sIGYgPSBPYmplY3QuYXNzaWduKCRBLCB7XG4gICAgZGVmYXVsdFZpc2l0b3I6IHUsXG4gICAgY29udmVydFZhbHVlOiBjLFxuICAgIGlzVmlzaXRhYmxlOiBaaFxuICB9KTtcbiAgZnVuY3Rpb24gaChwLCBPKSB7XG4gICAgaWYgKCFWLmlzVW5kZWZpbmVkKHApKSB7XG4gICAgICBpZiAoZC5pbmRleE9mKHApICE9PSAtMSlcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJDaXJjdWxhciByZWZlcmVuY2UgZGV0ZWN0ZWQgaW4gXCIgKyBPLmpvaW4oXCIuXCIpKTtcbiAgICAgIGQucHVzaChwKSwgVi5mb3JFYWNoKHAsIGZ1bmN0aW9uKHksIGIpIHtcbiAgICAgICAgKCEoVi5pc1VuZGVmaW5lZCh5KSB8fCB5ID09PSBudWxsKSAmJiBpLmNhbGwoXG4gICAgICAgICAgZSxcbiAgICAgICAgICB5LFxuICAgICAgICAgIFYuaXNTdHJpbmcoYikgPyBiLnRyaW0oKSA6IGIsXG4gICAgICAgICAgTyxcbiAgICAgICAgICBmXG4gICAgICAgICkpID09PSAhMCAmJiBoKHksIE8gPyBPLmNvbmNhdChiKSA6IFtiXSk7XG4gICAgICB9KSwgZC5wb3AoKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFWLmlzT2JqZWN0KHQpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJkYXRhIG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICByZXR1cm4gaCh0KSwgZTtcbn1cbmZ1bmN0aW9uIHBiKHQpIHtcbiAgY29uc3QgZSA9IHtcbiAgICBcIiFcIjogXCIlMjFcIixcbiAgICBcIidcIjogXCIlMjdcIixcbiAgICBcIihcIjogXCIlMjhcIixcbiAgICBcIilcIjogXCIlMjlcIixcbiAgICBcIn5cIjogXCIlN0VcIixcbiAgICBcIiUyMFwiOiBcIitcIixcbiAgICBcIiUwMFwiOiBcIlxcMFwiXG4gIH07XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodCkucmVwbGFjZSgvWyEnKCl+XXwlMjB8JTAwL2csIGZ1bmN0aW9uKHIpIHtcbiAgICByZXR1cm4gZVtyXTtcbiAgfSk7XG59XG5mdW5jdGlvbiBMTyh0LCBlKSB7XG4gIHRoaXMuX3BhaXJzID0gW10sIHQgJiYgWmQodCwgdGhpcywgZSk7XG59XG5jb25zdCB0dyA9IExPLnByb3RvdHlwZTtcbnR3LmFwcGVuZCA9IGZ1bmN0aW9uKGUsIG4pIHtcbiAgdGhpcy5fcGFpcnMucHVzaChbZSwgbl0pO1xufTtcbnR3LnRvU3RyaW5nID0gZnVuY3Rpb24oZSkge1xuICBjb25zdCBuID0gZSA/IGZ1bmN0aW9uKHIpIHtcbiAgICByZXR1cm4gZS5jYWxsKHRoaXMsIHIsIHBiKTtcbiAgfSA6IHBiO1xuICByZXR1cm4gdGhpcy5fcGFpcnMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICByZXR1cm4gbihpWzBdKSArIFwiPVwiICsgbihpWzFdKTtcbiAgfSwgXCJcIikuam9pbihcIiZcIik7XG59O1xuZnVuY3Rpb24gUUEodCkge1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHQpLnJlcGxhY2UoLyUzQS9naSwgXCI6XCIpLnJlcGxhY2UoLyUyNC9nLCBcIiRcIikucmVwbGFjZSgvJTJDL2dpLCBcIixcIikucmVwbGFjZSgvJTIwL2csIFwiK1wiKS5yZXBsYWNlKC8lNUIvZ2ksIFwiW1wiKS5yZXBsYWNlKC8lNUQvZ2ksIFwiXVwiKTtcbn1cbmZ1bmN0aW9uIG53KHQsIGUsIG4pIHtcbiAgaWYgKCFlKVxuICAgIHJldHVybiB0O1xuICBjb25zdCByID0gbiAmJiBuLmVuY29kZSB8fCBRQSwgaSA9IG4gJiYgbi5zZXJpYWxpemU7XG4gIGxldCBzO1xuICBpZiAoaSA/IHMgPSBpKGUsIG4pIDogcyA9IFYuaXNVUkxTZWFyY2hQYXJhbXMoZSkgPyBlLnRvU3RyaW5nKCkgOiBuZXcgTE8oZSwgbikudG9TdHJpbmcociksIHMpIHtcbiAgICBjb25zdCBvID0gdC5pbmRleE9mKFwiI1wiKTtcbiAgICBvICE9PSAtMSAmJiAodCA9IHQuc2xpY2UoMCwgbykpLCB0ICs9ICh0LmluZGV4T2YoXCI/XCIpID09PSAtMSA/IFwiP1wiIDogXCImXCIpICsgcztcbiAgfVxuICByZXR1cm4gdDtcbn1cbmNsYXNzIE9iIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5oYW5kbGVycyA9IFtdO1xuICB9XG4gIC8qKlxuICAgKiBBZGQgYSBuZXcgaW50ZXJjZXB0b3IgdG8gdGhlIHN0YWNrXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bGZpbGxlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGB0aGVuYCBmb3IgYSBgUHJvbWlzZWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0ZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgcmVqZWN0YCBmb3IgYSBgUHJvbWlzZWBcbiAgICpcbiAgICogQHJldHVybiB7TnVtYmVyfSBBbiBJRCB1c2VkIHRvIHJlbW92ZSBpbnRlcmNlcHRvciBsYXRlclxuICAgKi9cbiAgdXNlKGUsIG4sIHIpIHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVycy5wdXNoKHtcbiAgICAgIGZ1bGZpbGxlZDogZSxcbiAgICAgIHJlamVjdGVkOiBuLFxuICAgICAgc3luY2hyb25vdXM6IHIgPyByLnN5bmNocm9ub3VzIDogITEsXG4gICAgICBydW5XaGVuOiByID8gci5ydW5XaGVuIDogbnVsbFxuICAgIH0pLCB0aGlzLmhhbmRsZXJzLmxlbmd0aCAtIDE7XG4gIH1cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBpbnRlcmNlcHRvciBmcm9tIHRoZSBzdGFja1xuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gaWQgVGhlIElEIHRoYXQgd2FzIHJldHVybmVkIGJ5IGB1c2VgXG4gICAqXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGludGVyY2VwdG9yIHdhcyByZW1vdmVkLCBgZmFsc2VgIG90aGVyd2lzZVxuICAgKi9cbiAgZWplY3QoZSkge1xuICAgIHRoaXMuaGFuZGxlcnNbZV0gJiYgKHRoaXMuaGFuZGxlcnNbZV0gPSBudWxsKTtcbiAgfVxuICAvKipcbiAgICogQ2xlYXIgYWxsIGludGVyY2VwdG9ycyBmcm9tIHRoZSBzdGFja1xuICAgKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGNsZWFyKCkge1xuICAgIHRoaXMuaGFuZGxlcnMgJiYgKHRoaXMuaGFuZGxlcnMgPSBbXSk7XG4gIH1cbiAgLyoqXG4gICAqIEl0ZXJhdGUgb3ZlciBhbGwgdGhlIHJlZ2lzdGVyZWQgaW50ZXJjZXB0b3JzXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHNraXBwaW5nIG92ZXIgYW55XG4gICAqIGludGVyY2VwdG9ycyB0aGF0IG1heSBoYXZlIGJlY29tZSBgbnVsbGAgY2FsbGluZyBgZWplY3RgLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpbnRlcmNlcHRvclxuICAgKlxuICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICovXG4gIGZvckVhY2goZSkge1xuICAgIFYuZm9yRWFjaCh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbihyKSB7XG4gICAgICByICE9PSBudWxsICYmIGUocik7XG4gICAgfSk7XG4gIH1cbn1cbmNvbnN0IHJ3ID0ge1xuICBzaWxlbnRKU09OUGFyc2luZzogITAsXG4gIGZvcmNlZEpTT05QYXJzaW5nOiAhMCxcbiAgY2xhcmlmeVRpbWVvdXRFcnJvcjogITFcbn0sIENBID0gdHlwZW9mIFVSTFNlYXJjaFBhcmFtcyA8IFwidVwiID8gVVJMU2VhcmNoUGFyYW1zIDogTE8sIEFBID0gdHlwZW9mIEZvcm1EYXRhIDwgXCJ1XCIgPyBGb3JtRGF0YSA6IG51bGwsIFJBID0gdHlwZW9mIEJsb2IgPCBcInVcIiA/IEJsb2IgOiBudWxsLCBOQSA9IHtcbiAgaXNCcm93c2VyOiAhMCxcbiAgY2xhc3Nlczoge1xuICAgIFVSTFNlYXJjaFBhcmFtczogQ0EsXG4gICAgRm9ybURhdGE6IEFBLFxuICAgIEJsb2I6IFJBXG4gIH0sXG4gIHByb3RvY29sczogW1wiaHR0cFwiLCBcImh0dHBzXCIsIFwiZmlsZVwiLCBcImJsb2JcIiwgXCJ1cmxcIiwgXCJkYXRhXCJdXG59LCBpdyA9IHR5cGVvZiB3aW5kb3cgPCBcInVcIiAmJiB0eXBlb2YgZG9jdW1lbnQgPCBcInVcIiwgREEgPSAoKHQpID0+IGl3ICYmIFtcIlJlYWN0TmF0aXZlXCIsIFwiTmF0aXZlU2NyaXB0XCIsIFwiTlNcIl0uaW5kZXhPZih0KSA8IDApKHR5cGVvZiBuYXZpZ2F0b3IgPCBcInVcIiAmJiBuYXZpZ2F0b3IucHJvZHVjdCksIFpBID0gdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlIDwgXCJ1XCIgJiYgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5zZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUgJiYgdHlwZW9mIHNlbGYuaW1wb3J0U2NyaXB0cyA9PSBcImZ1bmN0aW9uXCIsIFZBID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgaGFzQnJvd3NlckVudjogaXcsXG4gIGhhc1N0YW5kYXJkQnJvd3NlckVudjogREEsXG4gIGhhc1N0YW5kYXJkQnJvd3NlcldlYldvcmtlckVudjogWkFcbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSksIEFyID0ge1xuICAuLi5WQSxcbiAgLi4uTkFcbn07XG5mdW5jdGlvbiBJQSh0LCBlKSB7XG4gIHJldHVybiBaZCh0LCBuZXcgQXIuY2xhc3Nlcy5VUkxTZWFyY2hQYXJhbXMoKSwgT2JqZWN0LmFzc2lnbih7XG4gICAgdmlzaXRvcjogZnVuY3Rpb24obiwgciwgaSwgcykge1xuICAgICAgcmV0dXJuIEFyLmlzTm9kZSAmJiBWLmlzQnVmZmVyKG4pID8gKHRoaXMuYXBwZW5kKHIsIG4udG9TdHJpbmcoXCJiYXNlNjRcIikpLCAhMSkgOiBzLmRlZmF1bHRWaXNpdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9LCBlKSk7XG59XG5mdW5jdGlvbiBXQSh0KSB7XG4gIHJldHVybiBWLm1hdGNoQWxsKC9cXHcrfFxcWyhcXHcqKV0vZywgdCkubWFwKChlKSA9PiBlWzBdID09PSBcIltdXCIgPyBcIlwiIDogZVsxXSB8fCBlWzBdKTtcbn1cbmZ1bmN0aW9uIE1BKHQpIHtcbiAgY29uc3QgZSA9IHt9LCBuID0gT2JqZWN0LmtleXModCk7XG4gIGxldCByO1xuICBjb25zdCBpID0gbi5sZW5ndGg7XG4gIGxldCBzO1xuICBmb3IgKHIgPSAwOyByIDwgaTsgcisrKVxuICAgIHMgPSBuW3JdLCBlW3NdID0gdFtzXTtcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBzdyh0KSB7XG4gIGZ1bmN0aW9uIGUobiwgciwgaSwgcykge1xuICAgIGxldCBvID0gbltzKytdO1xuICAgIGlmIChvID09PSBcIl9fcHJvdG9fX1wiKVxuICAgICAgcmV0dXJuICEwO1xuICAgIGNvbnN0IGEgPSBOdW1iZXIuaXNGaW5pdGUoK28pLCBsID0gcyA+PSBuLmxlbmd0aDtcbiAgICByZXR1cm4gbyA9ICFvICYmIFYuaXNBcnJheShpKSA/IGkubGVuZ3RoIDogbywgbCA/IChWLmhhc093blByb3AoaSwgbykgPyBpW29dID0gW2lbb10sIHJdIDogaVtvXSA9IHIsICFhKSA6ICgoIWlbb10gfHwgIVYuaXNPYmplY3QoaVtvXSkpICYmIChpW29dID0gW10pLCBlKG4sIHIsIGlbb10sIHMpICYmIFYuaXNBcnJheShpW29dKSAmJiAoaVtvXSA9IE1BKGlbb10pKSwgIWEpO1xuICB9XG4gIGlmIChWLmlzRm9ybURhdGEodCkgJiYgVi5pc0Z1bmN0aW9uKHQuZW50cmllcykpIHtcbiAgICBjb25zdCBuID0ge307XG4gICAgcmV0dXJuIFYuZm9yRWFjaEVudHJ5KHQsIChyLCBpKSA9PiB7XG4gICAgICBlKFdBKHIpLCBpLCBuLCAwKTtcbiAgICB9KSwgbjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIFhBKHQsIGUsIG4pIHtcbiAgaWYgKFYuaXNTdHJpbmcodCkpXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiAoZSB8fCBKU09OLnBhcnNlKSh0KSwgVi50cmltKHQpO1xuICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgIGlmIChyLm5hbWUgIT09IFwiU3ludGF4RXJyb3JcIilcbiAgICAgICAgdGhyb3cgcjtcbiAgICB9XG4gIHJldHVybiAobiB8fCBKU09OLnN0cmluZ2lmeSkodCk7XG59XG5jb25zdCBVTyA9IHtcbiAgdHJhbnNpdGlvbmFsOiBydyxcbiAgYWRhcHRlcjogW1wieGhyXCIsIFwiaHR0cFwiXSxcbiAgdHJhbnNmb3JtUmVxdWVzdDogW2Z1bmN0aW9uKGUsIG4pIHtcbiAgICBjb25zdCByID0gbi5nZXRDb250ZW50VHlwZSgpIHx8IFwiXCIsIGkgPSByLmluZGV4T2YoXCJhcHBsaWNhdGlvbi9qc29uXCIpID4gLTEsIHMgPSBWLmlzT2JqZWN0KGUpO1xuICAgIGlmIChzICYmIFYuaXNIVE1MRm9ybShlKSAmJiAoZSA9IG5ldyBGb3JtRGF0YShlKSksIFYuaXNGb3JtRGF0YShlKSlcbiAgICAgIHJldHVybiBpID8gSlNPTi5zdHJpbmdpZnkoc3coZSkpIDogZTtcbiAgICBpZiAoVi5pc0FycmF5QnVmZmVyKGUpIHx8IFYuaXNCdWZmZXIoZSkgfHwgVi5pc1N0cmVhbShlKSB8fCBWLmlzRmlsZShlKSB8fCBWLmlzQmxvYihlKSlcbiAgICAgIHJldHVybiBlO1xuICAgIGlmIChWLmlzQXJyYXlCdWZmZXJWaWV3KGUpKVxuICAgICAgcmV0dXJuIGUuYnVmZmVyO1xuICAgIGlmIChWLmlzVVJMU2VhcmNoUGFyYW1zKGUpKVxuICAgICAgcmV0dXJuIG4uc2V0Q29udGVudFR5cGUoXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD11dGYtOFwiLCAhMSksIGUudG9TdHJpbmcoKTtcbiAgICBsZXQgYTtcbiAgICBpZiAocykge1xuICAgICAgaWYgKHIuaW5kZXhPZihcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSA+IC0xKVxuICAgICAgICByZXR1cm4gSUEoZSwgdGhpcy5mb3JtU2VyaWFsaXplcikudG9TdHJpbmcoKTtcbiAgICAgIGlmICgoYSA9IFYuaXNGaWxlTGlzdChlKSkgfHwgci5pbmRleE9mKFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiKSA+IC0xKSB7XG4gICAgICAgIGNvbnN0IGwgPSB0aGlzLmVudiAmJiB0aGlzLmVudi5Gb3JtRGF0YTtcbiAgICAgICAgcmV0dXJuIFpkKFxuICAgICAgICAgIGEgPyB7IFwiZmlsZXNbXVwiOiBlIH0gOiBlLFxuICAgICAgICAgIGwgJiYgbmV3IGwoKSxcbiAgICAgICAgICB0aGlzLmZvcm1TZXJpYWxpemVyXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzIHx8IGkgPyAobi5zZXRDb250ZW50VHlwZShcImFwcGxpY2F0aW9uL2pzb25cIiwgITEpLCBYQShlKSkgOiBlO1xuICB9XSxcbiAgdHJhbnNmb3JtUmVzcG9uc2U6IFtmdW5jdGlvbihlKSB7XG4gICAgY29uc3QgbiA9IHRoaXMudHJhbnNpdGlvbmFsIHx8IFVPLnRyYW5zaXRpb25hbCwgciA9IG4gJiYgbi5mb3JjZWRKU09OUGFyc2luZywgaSA9IHRoaXMucmVzcG9uc2VUeXBlID09PSBcImpzb25cIjtcbiAgICBpZiAoZSAmJiBWLmlzU3RyaW5nKGUpICYmIChyICYmICF0aGlzLnJlc3BvbnNlVHlwZSB8fCBpKSkge1xuICAgICAgY29uc3QgbyA9ICEobiAmJiBuLnNpbGVudEpTT05QYXJzaW5nKSAmJiBpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZSk7XG4gICAgICB9IGNhdGNoIChhKSB7XG4gICAgICAgIGlmIChvKVxuICAgICAgICAgIHRocm93IGEubmFtZSA9PT0gXCJTeW50YXhFcnJvclwiID8gamUuZnJvbShhLCBqZS5FUlJfQkFEX1JFU1BPTlNFLCB0aGlzLCBudWxsLCB0aGlzLnJlc3BvbnNlKSA6IGE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9XSxcbiAgLyoqXG4gICAqIEEgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gYWJvcnQgYSByZXF1ZXN0LiBJZiBzZXQgdG8gMCAoZGVmYXVsdCkgYVxuICAgKiB0aW1lb3V0IGlzIG5vdCBjcmVhdGVkLlxuICAgKi9cbiAgdGltZW91dDogMCxcbiAgeHNyZkNvb2tpZU5hbWU6IFwiWFNSRi1UT0tFTlwiLFxuICB4c3JmSGVhZGVyTmFtZTogXCJYLVhTUkYtVE9LRU5cIixcbiAgbWF4Q29udGVudExlbmd0aDogLTEsXG4gIG1heEJvZHlMZW5ndGg6IC0xLFxuICBlbnY6IHtcbiAgICBGb3JtRGF0YTogQXIuY2xhc3Nlcy5Gb3JtRGF0YSxcbiAgICBCbG9iOiBBci5jbGFzc2VzLkJsb2JcbiAgfSxcbiAgdmFsaWRhdGVTdGF0dXM6IGZ1bmN0aW9uKGUpIHtcbiAgICByZXR1cm4gZSA+PSAyMDAgJiYgZSA8IDMwMDtcbiAgfSxcbiAgaGVhZGVyczoge1xuICAgIGNvbW1vbjoge1xuICAgICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICovKlwiLFxuICAgICAgXCJDb250ZW50LVR5cGVcIjogdm9pZCAwXG4gICAgfVxuICB9XG59O1xuVi5mb3JFYWNoKFtcImRlbGV0ZVwiLCBcImdldFwiLCBcImhlYWRcIiwgXCJwb3N0XCIsIFwicHV0XCIsIFwicGF0Y2hcIl0sICh0KSA9PiB7XG4gIFVPLmhlYWRlcnNbdF0gPSB7fTtcbn0pO1xuY29uc3QgcU8gPSBVTywgakEgPSBWLnRvT2JqZWN0U2V0KFtcbiAgXCJhZ2VcIixcbiAgXCJhdXRob3JpemF0aW9uXCIsXG4gIFwiY29udGVudC1sZW5ndGhcIixcbiAgXCJjb250ZW50LXR5cGVcIixcbiAgXCJldGFnXCIsXG4gIFwiZXhwaXJlc1wiLFxuICBcImZyb21cIixcbiAgXCJob3N0XCIsXG4gIFwiaWYtbW9kaWZpZWQtc2luY2VcIixcbiAgXCJpZi11bm1vZGlmaWVkLXNpbmNlXCIsXG4gIFwibGFzdC1tb2RpZmllZFwiLFxuICBcImxvY2F0aW9uXCIsXG4gIFwibWF4LWZvcndhcmRzXCIsXG4gIFwicHJveHktYXV0aG9yaXphdGlvblwiLFxuICBcInJlZmVyZXJcIixcbiAgXCJyZXRyeS1hZnRlclwiLFxuICBcInVzZXItYWdlbnRcIlxuXSksIEJBID0gKHQpID0+IHtcbiAgY29uc3QgZSA9IHt9O1xuICBsZXQgbiwgciwgaTtcbiAgcmV0dXJuIHQgJiYgdC5zcGxpdChgXG5gKS5mb3JFYWNoKGZ1bmN0aW9uKG8pIHtcbiAgICBpID0gby5pbmRleE9mKFwiOlwiKSwgbiA9IG8uc3Vic3RyaW5nKDAsIGkpLnRyaW0oKS50b0xvd2VyQ2FzZSgpLCByID0gby5zdWJzdHJpbmcoaSArIDEpLnRyaW0oKSwgISghbiB8fCBlW25dICYmIGpBW25dKSAmJiAobiA9PT0gXCJzZXQtY29va2llXCIgPyBlW25dID8gZVtuXS5wdXNoKHIpIDogZVtuXSA9IFtyXSA6IGVbbl0gPSBlW25dID8gZVtuXSArIFwiLCBcIiArIHIgOiByKTtcbiAgfSksIGU7XG59LCBnYiA9IFN5bWJvbChcImludGVybmFsc1wiKTtcbmZ1bmN0aW9uIG1hKHQpIHtcbiAgcmV0dXJuIHQgJiYgU3RyaW5nKHQpLnRyaW0oKS50b0xvd2VyQ2FzZSgpO1xufVxuZnVuY3Rpb24gSmModCkge1xuICByZXR1cm4gdCA9PT0gITEgfHwgdCA9PSBudWxsID8gdCA6IFYuaXNBcnJheSh0KSA/IHQubWFwKEpjKSA6IFN0cmluZyh0KTtcbn1cbmZ1bmN0aW9uIExBKHQpIHtcbiAgY29uc3QgZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCBuID0gLyhbXlxccyw7PV0rKVxccyooPzo9XFxzKihbXiw7XSspKT8vZztcbiAgbGV0IHI7XG4gIGZvciAoOyByID0gbi5leGVjKHQpOyApXG4gICAgZVtyWzFdXSA9IHJbMl07XG4gIHJldHVybiBlO1xufVxuY29uc3QgVUEgPSAodCkgPT4gL15bLV9hLXpBLVowLTleYHx+LCEjJCUmJyorLl0rJC8udGVzdCh0LnRyaW0oKSk7XG5mdW5jdGlvbiB2Zih0LCBlLCBuLCByLCBpKSB7XG4gIGlmIChWLmlzRnVuY3Rpb24ocikpXG4gICAgcmV0dXJuIHIuY2FsbCh0aGlzLCBlLCBuKTtcbiAgaWYgKGkgJiYgKGUgPSBuKSwgISFWLmlzU3RyaW5nKGUpKSB7XG4gICAgaWYgKFYuaXNTdHJpbmcocikpXG4gICAgICByZXR1cm4gZS5pbmRleE9mKHIpICE9PSAtMTtcbiAgICBpZiAoVi5pc1JlZ0V4cChyKSlcbiAgICAgIHJldHVybiByLnRlc3QoZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHFBKHQpIHtcbiAgcmV0dXJuIHQudHJpbSgpLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvKFthLXpcXGRdKShcXHcqKS9nLCAoZSwgbiwgcikgPT4gbi50b1VwcGVyQ2FzZSgpICsgcik7XG59XG5mdW5jdGlvbiBZQSh0LCBlKSB7XG4gIGNvbnN0IG4gPSBWLnRvQ2FtZWxDYXNlKFwiIFwiICsgZSk7XG4gIFtcImdldFwiLCBcInNldFwiLCBcImhhc1wiXS5mb3JFYWNoKChyKSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIHIgKyBuLCB7XG4gICAgICB2YWx1ZTogZnVuY3Rpb24oaSwgcywgbykge1xuICAgICAgICByZXR1cm4gdGhpc1tyXS5jYWxsKHRoaXMsIGUsIGksIHMsIG8pO1xuICAgICAgfSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICB9KTtcbiAgfSk7XG59XG5jbGFzcyBWZCB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBlICYmIHRoaXMuc2V0KGUpO1xuICB9XG4gIHNldChlLCBuLCByKSB7XG4gICAgY29uc3QgaSA9IHRoaXM7XG4gICAgZnVuY3Rpb24gcyhhLCBsLCBjKSB7XG4gICAgICBjb25zdCB1ID0gbWEobCk7XG4gICAgICBpZiAoIXUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImhlYWRlciBuYW1lIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nXCIpO1xuICAgICAgY29uc3QgZCA9IFYuZmluZEtleShpLCB1KTtcbiAgICAgICghZCB8fCBpW2RdID09PSB2b2lkIDAgfHwgYyA9PT0gITAgfHwgYyA9PT0gdm9pZCAwICYmIGlbZF0gIT09ICExKSAmJiAoaVtkIHx8IGxdID0gSmMoYSkpO1xuICAgIH1cbiAgICBjb25zdCBvID0gKGEsIGwpID0+IFYuZm9yRWFjaChhLCAoYywgdSkgPT4gcyhjLCB1LCBsKSk7XG4gICAgcmV0dXJuIFYuaXNQbGFpbk9iamVjdChlKSB8fCBlIGluc3RhbmNlb2YgdGhpcy5jb25zdHJ1Y3RvciA/IG8oZSwgbikgOiBWLmlzU3RyaW5nKGUpICYmIChlID0gZS50cmltKCkpICYmICFVQShlKSA/IG8oQkEoZSksIG4pIDogZSAhPSBudWxsICYmIHMobiwgZSwgciksIHRoaXM7XG4gIH1cbiAgZ2V0KGUsIG4pIHtcbiAgICBpZiAoZSA9IG1hKGUpLCBlKSB7XG4gICAgICBjb25zdCByID0gVi5maW5kS2V5KHRoaXMsIGUpO1xuICAgICAgaWYgKHIpIHtcbiAgICAgICAgY29uc3QgaSA9IHRoaXNbcl07XG4gICAgICAgIGlmICghbilcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgaWYgKG4gPT09ICEwKVxuICAgICAgICAgIHJldHVybiBMQShpKTtcbiAgICAgICAgaWYgKFYuaXNGdW5jdGlvbihuKSlcbiAgICAgICAgICByZXR1cm4gbi5jYWxsKHRoaXMsIGksIHIpO1xuICAgICAgICBpZiAoVi5pc1JlZ0V4cChuKSlcbiAgICAgICAgICByZXR1cm4gbi5leGVjKGkpO1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwicGFyc2VyIG11c3QgYmUgYm9vbGVhbnxyZWdleHB8ZnVuY3Rpb25cIik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGhhcyhlLCBuKSB7XG4gICAgaWYgKGUgPSBtYShlKSwgZSkge1xuICAgICAgY29uc3QgciA9IFYuZmluZEtleSh0aGlzLCBlKTtcbiAgICAgIHJldHVybiAhIShyICYmIHRoaXNbcl0gIT09IHZvaWQgMCAmJiAoIW4gfHwgdmYodGhpcywgdGhpc1tyXSwgciwgbikpKTtcbiAgICB9XG4gICAgcmV0dXJuICExO1xuICB9XG4gIGRlbGV0ZShlLCBuKSB7XG4gICAgY29uc3QgciA9IHRoaXM7XG4gICAgbGV0IGkgPSAhMTtcbiAgICBmdW5jdGlvbiBzKG8pIHtcbiAgICAgIGlmIChvID0gbWEobyksIG8pIHtcbiAgICAgICAgY29uc3QgYSA9IFYuZmluZEtleShyLCBvKTtcbiAgICAgICAgYSAmJiAoIW4gfHwgdmYociwgclthXSwgYSwgbikpICYmIChkZWxldGUgclthXSwgaSA9ICEwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFYuaXNBcnJheShlKSA/IGUuZm9yRWFjaChzKSA6IHMoZSksIGk7XG4gIH1cbiAgY2xlYXIoZSkge1xuICAgIGNvbnN0IG4gPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgICBsZXQgciA9IG4ubGVuZ3RoLCBpID0gITE7XG4gICAgZm9yICg7IHItLTsgKSB7XG4gICAgICBjb25zdCBzID0gbltyXTtcbiAgICAgICghZSB8fCB2Zih0aGlzLCB0aGlzW3NdLCBzLCBlLCAhMCkpICYmIChkZWxldGUgdGhpc1tzXSwgaSA9ICEwKTtcbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH1cbiAgbm9ybWFsaXplKGUpIHtcbiAgICBjb25zdCBuID0gdGhpcywgciA9IHt9O1xuICAgIHJldHVybiBWLmZvckVhY2godGhpcywgKGksIHMpID0+IHtcbiAgICAgIGNvbnN0IG8gPSBWLmZpbmRLZXkociwgcyk7XG4gICAgICBpZiAobykge1xuICAgICAgICBuW29dID0gSmMoaSksIGRlbGV0ZSBuW3NdO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBhID0gZSA/IHFBKHMpIDogU3RyaW5nKHMpLnRyaW0oKTtcbiAgICAgIGEgIT09IHMgJiYgZGVsZXRlIG5bc10sIG5bYV0gPSBKYyhpKSwgclthXSA9ICEwO1xuICAgIH0pLCB0aGlzO1xuICB9XG4gIGNvbmNhdCguLi5lKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuY29uY2F0KHRoaXMsIC4uLmUpO1xuICB9XG4gIHRvSlNPTihlKSB7XG4gICAgY29uc3QgbiA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHJldHVybiBWLmZvckVhY2godGhpcywgKHIsIGkpID0+IHtcbiAgICAgIHIgIT0gbnVsbCAmJiByICE9PSAhMSAmJiAobltpXSA9IGUgJiYgVi5pc0FycmF5KHIpID8gci5qb2luKFwiLCBcIikgOiByKTtcbiAgICB9KSwgbjtcbiAgfVxuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXModGhpcy50b0pTT04oKSlbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyh0aGlzLnRvSlNPTigpKS5tYXAoKFtlLCBuXSkgPT4gZSArIFwiOiBcIiArIG4pLmpvaW4oYFxuYCk7XG4gIH1cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiBcIkF4aW9zSGVhZGVyc1wiO1xuICB9XG4gIHN0YXRpYyBmcm9tKGUpIHtcbiAgICByZXR1cm4gZSBpbnN0YW5jZW9mIHRoaXMgPyBlIDogbmV3IHRoaXMoZSk7XG4gIH1cbiAgc3RhdGljIGNvbmNhdChlLCAuLi5uKSB7XG4gICAgY29uc3QgciA9IG5ldyB0aGlzKGUpO1xuICAgIHJldHVybiBuLmZvckVhY2goKGkpID0+IHIuc2V0KGkpKSwgcjtcbiAgfVxuICBzdGF0aWMgYWNjZXNzb3IoZSkge1xuICAgIGNvbnN0IHIgPSAodGhpc1tnYl0gPSB0aGlzW2diXSA9IHtcbiAgICAgIGFjY2Vzc29yczoge31cbiAgICB9KS5hY2Nlc3NvcnMsIGkgPSB0aGlzLnByb3RvdHlwZTtcbiAgICBmdW5jdGlvbiBzKG8pIHtcbiAgICAgIGNvbnN0IGEgPSBtYShvKTtcbiAgICAgIHJbYV0gfHwgKFlBKGksIG8pLCByW2FdID0gITApO1xuICAgIH1cbiAgICByZXR1cm4gVi5pc0FycmF5KGUpID8gZS5mb3JFYWNoKHMpIDogcyhlKSwgdGhpcztcbiAgfVxufVxuVmQuYWNjZXNzb3IoW1wiQ29udGVudC1UeXBlXCIsIFwiQ29udGVudC1MZW5ndGhcIiwgXCJBY2NlcHRcIiwgXCJBY2NlcHQtRW5jb2RpbmdcIiwgXCJVc2VyLUFnZW50XCIsIFwiQXV0aG9yaXphdGlvblwiXSk7XG5WLnJlZHVjZURlc2NyaXB0b3JzKFZkLnByb3RvdHlwZSwgKHsgdmFsdWU6IHQgfSwgZSkgPT4ge1xuICBsZXQgbiA9IGVbMF0udG9VcHBlckNhc2UoKSArIGUuc2xpY2UoMSk7XG4gIHJldHVybiB7XG4gICAgZ2V0OiAoKSA9PiB0LFxuICAgIHNldChyKSB7XG4gICAgICB0aGlzW25dID0gcjtcbiAgICB9XG4gIH07XG59KTtcblYuZnJlZXplTWV0aG9kcyhWZCk7XG5jb25zdCByaSA9IFZkO1xuZnVuY3Rpb24geWYodCwgZSkge1xuICBjb25zdCBuID0gdGhpcyB8fCBxTywgciA9IGUgfHwgbiwgaSA9IHJpLmZyb20oci5oZWFkZXJzKTtcbiAgbGV0IHMgPSByLmRhdGE7XG4gIHJldHVybiBWLmZvckVhY2godCwgZnVuY3Rpb24oYSkge1xuICAgIHMgPSBhLmNhbGwobiwgcywgaS5ub3JtYWxpemUoKSwgZSA/IGUuc3RhdHVzIDogdm9pZCAwKTtcbiAgfSksIGkubm9ybWFsaXplKCksIHM7XG59XG5mdW5jdGlvbiBvdyh0KSB7XG4gIHJldHVybiAhISh0ICYmIHQuX19DQU5DRUxfXyk7XG59XG5mdW5jdGlvbiBVbCh0LCBlLCBuKSB7XG4gIGplLmNhbGwodGhpcywgdCA/PyBcImNhbmNlbGVkXCIsIGplLkVSUl9DQU5DRUxFRCwgZSwgbiksIHRoaXMubmFtZSA9IFwiQ2FuY2VsZWRFcnJvclwiO1xufVxuVi5pbmhlcml0cyhVbCwgamUsIHtcbiAgX19DQU5DRUxfXzogITBcbn0pO1xuZnVuY3Rpb24gekEodCwgZSwgbikge1xuICBjb25zdCByID0gbi5jb25maWcudmFsaWRhdGVTdGF0dXM7XG4gICFuLnN0YXR1cyB8fCAhciB8fCByKG4uc3RhdHVzKSA/IHQobikgOiBlKG5ldyBqZShcbiAgICBcIlJlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgXCIgKyBuLnN0YXR1cyxcbiAgICBbamUuRVJSX0JBRF9SRVFVRVNULCBqZS5FUlJfQkFEX1JFU1BPTlNFXVtNYXRoLmZsb29yKG4uc3RhdHVzIC8gMTAwKSAtIDRdLFxuICAgIG4uY29uZmlnLFxuICAgIG4ucmVxdWVzdCxcbiAgICBuXG4gICkpO1xufVxuY29uc3QgSEEgPSBBci5oYXNTdGFuZGFyZEJyb3dzZXJFbnYgPyAoXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBzdXBwb3J0IGRvY3VtZW50LmNvb2tpZVxuICB7XG4gICAgd3JpdGUodCwgZSwgbiwgciwgaSwgcykge1xuICAgICAgY29uc3QgbyA9IFt0ICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoZSldO1xuICAgICAgVi5pc051bWJlcihuKSAmJiBvLnB1c2goXCJleHBpcmVzPVwiICsgbmV3IERhdGUobikudG9HTVRTdHJpbmcoKSksIFYuaXNTdHJpbmcocikgJiYgby5wdXNoKFwicGF0aD1cIiArIHIpLCBWLmlzU3RyaW5nKGkpICYmIG8ucHVzaChcImRvbWFpbj1cIiArIGkpLCBzID09PSAhMCAmJiBvLnB1c2goXCJzZWN1cmVcIiksIGRvY3VtZW50LmNvb2tpZSA9IG8uam9pbihcIjsgXCIpO1xuICAgIH0sXG4gICAgcmVhZCh0KSB7XG4gICAgICBjb25zdCBlID0gZG9jdW1lbnQuY29va2llLm1hdGNoKG5ldyBSZWdFeHAoXCIoXnw7XFxcXHMqKShcIiArIHQgKyBcIik9KFteO10qKVwiKSk7XG4gICAgICByZXR1cm4gZSA/IGRlY29kZVVSSUNvbXBvbmVudChlWzNdKSA6IG51bGw7XG4gICAgfSxcbiAgICByZW1vdmUodCkge1xuICAgICAgdGhpcy53cml0ZSh0LCBcIlwiLCBEYXRlLm5vdygpIC0gODY0ZTUpO1xuICAgIH1cbiAgfVxuKSA6IChcbiAgLy8gTm9uLXN0YW5kYXJkIGJyb3dzZXIgZW52ICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICB7XG4gICAgd3JpdGUoKSB7XG4gICAgfSxcbiAgICByZWFkKCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICByZW1vdmUoKSB7XG4gICAgfVxuICB9XG4pO1xuZnVuY3Rpb24gRkEodCkge1xuICByZXR1cm4gL14oW2Etel1bYS16XFxkK1xcLS5dKjopP1xcL1xcLy9pLnRlc3QodCk7XG59XG5mdW5jdGlvbiBHQSh0LCBlKSB7XG4gIHJldHVybiBlID8gdC5yZXBsYWNlKC9cXC8/XFwvJC8sIFwiXCIpICsgXCIvXCIgKyBlLnJlcGxhY2UoL15cXC8rLywgXCJcIikgOiB0O1xufVxuZnVuY3Rpb24gYXcodCwgZSkge1xuICByZXR1cm4gdCAmJiAhRkEoZSkgPyBHQSh0LCBlKSA6IGU7XG59XG5jb25zdCBLQSA9IEFyLmhhc1N0YW5kYXJkQnJvd3NlckVudiA/IChcbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIGhhdmUgZnVsbCBzdXBwb3J0IG9mIHRoZSBBUElzIG5lZWRlZCB0byB0ZXN0XG4gIC8vIHdoZXRoZXIgdGhlIHJlcXVlc3QgVVJMIGlzIG9mIHRoZSBzYW1lIG9yaWdpbiBhcyBjdXJyZW50IGxvY2F0aW9uLlxuICBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBlID0gLyhtc2llfHRyaWRlbnQpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSwgbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgIGxldCByO1xuICAgIGZ1bmN0aW9uIGkocykge1xuICAgICAgbGV0IG8gPSBzO1xuICAgICAgcmV0dXJuIGUgJiYgKG4uc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBvKSwgbyA9IG4uaHJlZiksIG4uc2V0QXR0cmlidXRlKFwiaHJlZlwiLCBvKSwge1xuICAgICAgICBocmVmOiBuLmhyZWYsXG4gICAgICAgIHByb3RvY29sOiBuLnByb3RvY29sID8gbi5wcm90b2NvbC5yZXBsYWNlKC86JC8sIFwiXCIpIDogXCJcIixcbiAgICAgICAgaG9zdDogbi5ob3N0LFxuICAgICAgICBzZWFyY2g6IG4uc2VhcmNoID8gbi5zZWFyY2gucmVwbGFjZSgvXlxcPy8sIFwiXCIpIDogXCJcIixcbiAgICAgICAgaGFzaDogbi5oYXNoID8gbi5oYXNoLnJlcGxhY2UoL14jLywgXCJcIikgOiBcIlwiLFxuICAgICAgICBob3N0bmFtZTogbi5ob3N0bmFtZSxcbiAgICAgICAgcG9ydDogbi5wb3J0LFxuICAgICAgICBwYXRobmFtZTogbi5wYXRobmFtZS5jaGFyQXQoMCkgPT09IFwiL1wiID8gbi5wYXRobmFtZSA6IFwiL1wiICsgbi5wYXRobmFtZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHIgPSBpKHdpbmRvdy5sb2NhdGlvbi5ocmVmKSwgZnVuY3Rpb24obykge1xuICAgICAgY29uc3QgYSA9IFYuaXNTdHJpbmcobykgPyBpKG8pIDogbztcbiAgICAgIHJldHVybiBhLnByb3RvY29sID09PSByLnByb3RvY29sICYmIGEuaG9zdCA9PT0gci5ob3N0O1xuICAgIH07XG4gIH0oKVxuKSA6IChcbiAgLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52cyAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAgLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhMDtcbiAgICB9O1xuICB9KClcbik7XG5mdW5jdGlvbiBKQSh0KSB7XG4gIGNvbnN0IGUgPSAvXihbLStcXHddezEsMjV9KSg6P1xcL1xcL3w6KS8uZXhlYyh0KTtcbiAgcmV0dXJuIGUgJiYgZVsxXSB8fCBcIlwiO1xufVxuZnVuY3Rpb24gZTIodCwgZSkge1xuICB0ID0gdCB8fCAxMDtcbiAgY29uc3QgbiA9IG5ldyBBcnJheSh0KSwgciA9IG5ldyBBcnJheSh0KTtcbiAgbGV0IGkgPSAwLCBzID0gMCwgbztcbiAgcmV0dXJuIGUgPSBlICE9PSB2b2lkIDAgPyBlIDogMWUzLCBmdW5jdGlvbihsKSB7XG4gICAgY29uc3QgYyA9IERhdGUubm93KCksIHUgPSByW3NdO1xuICAgIG8gfHwgKG8gPSBjKSwgbltpXSA9IGwsIHJbaV0gPSBjO1xuICAgIGxldCBkID0gcywgZiA9IDA7XG4gICAgZm9yICg7IGQgIT09IGk7IClcbiAgICAgIGYgKz0gbltkKytdLCBkID0gZCAlIHQ7XG4gICAgaWYgKGkgPSAoaSArIDEpICUgdCwgaSA9PT0gcyAmJiAocyA9IChzICsgMSkgJSB0KSwgYyAtIG8gPCBlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGggPSB1ICYmIGMgLSB1O1xuICAgIHJldHVybiBoID8gTWF0aC5yb3VuZChmICogMWUzIC8gaCkgOiB2b2lkIDA7XG4gIH07XG59XG5mdW5jdGlvbiBtYih0LCBlKSB7XG4gIGxldCBuID0gMDtcbiAgY29uc3QgciA9IGUyKDUwLCAyNTApO1xuICByZXR1cm4gKGkpID0+IHtcbiAgICBjb25zdCBzID0gaS5sb2FkZWQsIG8gPSBpLmxlbmd0aENvbXB1dGFibGUgPyBpLnRvdGFsIDogdm9pZCAwLCBhID0gcyAtIG4sIGwgPSByKGEpLCBjID0gcyA8PSBvO1xuICAgIG4gPSBzO1xuICAgIGNvbnN0IHUgPSB7XG4gICAgICBsb2FkZWQ6IHMsXG4gICAgICB0b3RhbDogbyxcbiAgICAgIHByb2dyZXNzOiBvID8gcyAvIG8gOiB2b2lkIDAsXG4gICAgICBieXRlczogYSxcbiAgICAgIHJhdGU6IGwgfHwgdm9pZCAwLFxuICAgICAgZXN0aW1hdGVkOiBsICYmIG8gJiYgYyA/IChvIC0gcykgLyBsIDogdm9pZCAwLFxuICAgICAgZXZlbnQ6IGlcbiAgICB9O1xuICAgIHVbZSA/IFwiZG93bmxvYWRcIiA6IFwidXBsb2FkXCJdID0gITAsIHQodSk7XG4gIH07XG59XG5jb25zdCB0MiA9IHR5cGVvZiBYTUxIdHRwUmVxdWVzdCA8IFwidVwiLCBuMiA9IHQyICYmIGZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKG4sIHIpIHtcbiAgICBsZXQgaSA9IHQuZGF0YTtcbiAgICBjb25zdCBzID0gcmkuZnJvbSh0LmhlYWRlcnMpLm5vcm1hbGl6ZSgpO1xuICAgIGxldCB7IHJlc3BvbnNlVHlwZTogbywgd2l0aFhTUkZUb2tlbjogYSB9ID0gdCwgbDtcbiAgICBmdW5jdGlvbiBjKCkge1xuICAgICAgdC5jYW5jZWxUb2tlbiAmJiB0LmNhbmNlbFRva2VuLnVuc3Vic2NyaWJlKGwpLCB0LnNpZ25hbCAmJiB0LnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgbCk7XG4gICAgfVxuICAgIGxldCB1O1xuICAgIGlmIChWLmlzRm9ybURhdGEoaSkpIHtcbiAgICAgIGlmIChBci5oYXNTdGFuZGFyZEJyb3dzZXJFbnYgfHwgQXIuaGFzU3RhbmRhcmRCcm93c2VyV2ViV29ya2VyRW52KVxuICAgICAgICBzLnNldENvbnRlbnRUeXBlKCExKTtcbiAgICAgIGVsc2UgaWYgKCh1ID0gcy5nZXRDb250ZW50VHlwZSgpKSAhPT0gITEpIHtcbiAgICAgICAgY29uc3QgW08sIC4uLm1dID0gdSA/IHUuc3BsaXQoXCI7XCIpLm1hcCgoeSkgPT4geS50cmltKCkpLmZpbHRlcihCb29sZWFuKSA6IFtdO1xuICAgICAgICBzLnNldENvbnRlbnRUeXBlKFtPIHx8IFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiLCAuLi5tXS5qb2luKFwiOyBcIikpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgZCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIGlmICh0LmF1dGgpIHtcbiAgICAgIGNvbnN0IE8gPSB0LmF1dGgudXNlcm5hbWUgfHwgXCJcIiwgbSA9IHQuYXV0aC5wYXNzd29yZCA/IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudCh0LmF1dGgucGFzc3dvcmQpKSA6IFwiXCI7XG4gICAgICBzLnNldChcIkF1dGhvcml6YXRpb25cIiwgXCJCYXNpYyBcIiArIGJ0b2EoTyArIFwiOlwiICsgbSkpO1xuICAgIH1cbiAgICBjb25zdCBmID0gYXcodC5iYXNlVVJMLCB0LnVybCk7XG4gICAgZC5vcGVuKHQubWV0aG9kLnRvVXBwZXJDYXNlKCksIG53KGYsIHQucGFyYW1zLCB0LnBhcmFtc1NlcmlhbGl6ZXIpLCAhMCksIGQudGltZW91dCA9IHQudGltZW91dDtcbiAgICBmdW5jdGlvbiBoKCkge1xuICAgICAgaWYgKCFkKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBPID0gcmkuZnJvbShcbiAgICAgICAgXCJnZXRBbGxSZXNwb25zZUhlYWRlcnNcIiBpbiBkICYmIGQuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKClcbiAgICAgICksIHkgPSB7XG4gICAgICAgIGRhdGE6ICFvIHx8IG8gPT09IFwidGV4dFwiIHx8IG8gPT09IFwianNvblwiID8gZC5yZXNwb25zZVRleHQgOiBkLnJlc3BvbnNlLFxuICAgICAgICBzdGF0dXM6IGQuc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiBkLnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnM6IE8sXG4gICAgICAgIGNvbmZpZzogdCxcbiAgICAgICAgcmVxdWVzdDogZFxuICAgICAgfTtcbiAgICAgIHpBKGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgbihnKSwgYygpO1xuICAgICAgfSwgZnVuY3Rpb24oZykge1xuICAgICAgICByKGcpLCBjKCk7XG4gICAgICB9LCB5KSwgZCA9IG51bGw7XG4gICAgfVxuICAgIGlmIChcIm9ubG9hZGVuZFwiIGluIGQgPyBkLm9ubG9hZGVuZCA9IGggOiBkLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgIWQgfHwgZC5yZWFkeVN0YXRlICE9PSA0IHx8IGQuc3RhdHVzID09PSAwICYmICEoZC5yZXNwb25zZVVSTCAmJiBkLnJlc3BvbnNlVVJMLmluZGV4T2YoXCJmaWxlOlwiKSA9PT0gMCkgfHwgc2V0VGltZW91dChoKTtcbiAgICB9LCBkLm9uYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGQgJiYgKHIobmV3IGplKFwiUmVxdWVzdCBhYm9ydGVkXCIsIGplLkVDT05OQUJPUlRFRCwgdCwgZCkpLCBkID0gbnVsbCk7XG4gICAgfSwgZC5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICByKG5ldyBqZShcIk5ldHdvcmsgRXJyb3JcIiwgamUuRVJSX05FVFdPUkssIHQsIGQpKSwgZCA9IG51bGw7XG4gICAgfSwgZC5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGxldCBtID0gdC50aW1lb3V0ID8gXCJ0aW1lb3V0IG9mIFwiICsgdC50aW1lb3V0ICsgXCJtcyBleGNlZWRlZFwiIDogXCJ0aW1lb3V0IGV4Y2VlZGVkXCI7XG4gICAgICBjb25zdCB5ID0gdC50cmFuc2l0aW9uYWwgfHwgcnc7XG4gICAgICB0LnRpbWVvdXRFcnJvck1lc3NhZ2UgJiYgKG0gPSB0LnRpbWVvdXRFcnJvck1lc3NhZ2UpLCByKG5ldyBqZShcbiAgICAgICAgbSxcbiAgICAgICAgeS5jbGFyaWZ5VGltZW91dEVycm9yID8gamUuRVRJTUVET1VUIDogamUuRUNPTk5BQk9SVEVELFxuICAgICAgICB0LFxuICAgICAgICBkXG4gICAgICApKSwgZCA9IG51bGw7XG4gICAgfSwgQXIuaGFzU3RhbmRhcmRCcm93c2VyRW52ICYmIChhICYmIFYuaXNGdW5jdGlvbihhKSAmJiAoYSA9IGEodCkpLCBhIHx8IGEgIT09ICExICYmIEtBKGYpKSkge1xuICAgICAgY29uc3QgTyA9IHQueHNyZkhlYWRlck5hbWUgJiYgdC54c3JmQ29va2llTmFtZSAmJiBIQS5yZWFkKHQueHNyZkNvb2tpZU5hbWUpO1xuICAgICAgTyAmJiBzLnNldCh0LnhzcmZIZWFkZXJOYW1lLCBPKTtcbiAgICB9XG4gICAgaSA9PT0gdm9pZCAwICYmIHMuc2V0Q29udGVudFR5cGUobnVsbCksIFwic2V0UmVxdWVzdEhlYWRlclwiIGluIGQgJiYgVi5mb3JFYWNoKHMudG9KU09OKCksIGZ1bmN0aW9uKG0sIHkpIHtcbiAgICAgIGQuc2V0UmVxdWVzdEhlYWRlcih5LCBtKTtcbiAgICB9KSwgVi5pc1VuZGVmaW5lZCh0LndpdGhDcmVkZW50aWFscykgfHwgKGQud2l0aENyZWRlbnRpYWxzID0gISF0LndpdGhDcmVkZW50aWFscyksIG8gJiYgbyAhPT0gXCJqc29uXCIgJiYgKGQucmVzcG9uc2VUeXBlID0gdC5yZXNwb25zZVR5cGUpLCB0eXBlb2YgdC5vbkRvd25sb2FkUHJvZ3Jlc3MgPT0gXCJmdW5jdGlvblwiICYmIGQuYWRkRXZlbnRMaXN0ZW5lcihcInByb2dyZXNzXCIsIG1iKHQub25Eb3dubG9hZFByb2dyZXNzLCAhMCkpLCB0eXBlb2YgdC5vblVwbG9hZFByb2dyZXNzID09IFwiZnVuY3Rpb25cIiAmJiBkLnVwbG9hZCAmJiBkLnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwgbWIodC5vblVwbG9hZFByb2dyZXNzKSksICh0LmNhbmNlbFRva2VuIHx8IHQuc2lnbmFsKSAmJiAobCA9IChPKSA9PiB7XG4gICAgICBkICYmIChyKCFPIHx8IE8udHlwZSA/IG5ldyBVbChudWxsLCB0LCBkKSA6IE8pLCBkLmFib3J0KCksIGQgPSBudWxsKTtcbiAgICB9LCB0LmNhbmNlbFRva2VuICYmIHQuY2FuY2VsVG9rZW4uc3Vic2NyaWJlKGwpLCB0LnNpZ25hbCAmJiAodC5zaWduYWwuYWJvcnRlZCA/IGwoKSA6IHQuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBsKSkpO1xuICAgIGNvbnN0IHAgPSBKQShmKTtcbiAgICBpZiAocCAmJiBBci5wcm90b2NvbHMuaW5kZXhPZihwKSA9PT0gLTEpIHtcbiAgICAgIHIobmV3IGplKFwiVW5zdXBwb3J0ZWQgcHJvdG9jb2wgXCIgKyBwICsgXCI6XCIsIGplLkVSUl9CQURfUkVRVUVTVCwgdCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkLnNlbmQoaSB8fCBudWxsKTtcbiAgfSk7XG59LCBWaCA9IHtcbiAgaHR0cDogVEEsXG4gIHhocjogbjJcbn07XG5WLmZvckVhY2goVmgsICh0LCBlKSA9PiB7XG4gIGlmICh0KSB7XG4gICAgdHJ5IHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcIm5hbWVcIiwgeyB2YWx1ZTogZSB9KTtcbiAgICB9IGNhdGNoIHtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiYWRhcHRlck5hbWVcIiwgeyB2YWx1ZTogZSB9KTtcbiAgfVxufSk7XG5jb25zdCBiYiA9ICh0KSA9PiBgLSAke3R9YCwgcjIgPSAodCkgPT4gVi5pc0Z1bmN0aW9uKHQpIHx8IHQgPT09IG51bGwgfHwgdCA9PT0gITEsIGx3ID0ge1xuICBnZXRBZGFwdGVyOiAodCkgPT4ge1xuICAgIHQgPSBWLmlzQXJyYXkodCkgPyB0IDogW3RdO1xuICAgIGNvbnN0IHsgbGVuZ3RoOiBlIH0gPSB0O1xuICAgIGxldCBuLCByO1xuICAgIGNvbnN0IGkgPSB7fTtcbiAgICBmb3IgKGxldCBzID0gMDsgcyA8IGU7IHMrKykge1xuICAgICAgbiA9IHRbc107XG4gICAgICBsZXQgbztcbiAgICAgIGlmIChyID0gbiwgIXIyKG4pICYmIChyID0gVmhbKG8gPSBTdHJpbmcobikpLnRvTG93ZXJDYXNlKCldLCByID09PSB2b2lkIDApKVxuICAgICAgICB0aHJvdyBuZXcgamUoYFVua25vd24gYWRhcHRlciAnJHtvfSdgKTtcbiAgICAgIGlmIChyKVxuICAgICAgICBicmVhaztcbiAgICAgIGlbbyB8fCBcIiNcIiArIHNdID0gcjtcbiAgICB9XG4gICAgaWYgKCFyKSB7XG4gICAgICBjb25zdCBzID0gT2JqZWN0LmVudHJpZXMoaSkubWFwKFxuICAgICAgICAoW2EsIGxdKSA9PiBgYWRhcHRlciAke2F9IGAgKyAobCA9PT0gITEgPyBcImlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGVudmlyb25tZW50XCIgOiBcImlzIG5vdCBhdmFpbGFibGUgaW4gdGhlIGJ1aWxkXCIpXG4gICAgICApO1xuICAgICAgbGV0IG8gPSBlID8gcy5sZW5ndGggPiAxID8gYHNpbmNlIDpcbmAgKyBzLm1hcChiYikuam9pbihgXG5gKSA6IFwiIFwiICsgYmIoc1swXSkgOiBcImFzIG5vIGFkYXB0ZXIgc3BlY2lmaWVkXCI7XG4gICAgICB0aHJvdyBuZXcgamUoXG4gICAgICAgIFwiVGhlcmUgaXMgbm8gc3VpdGFibGUgYWRhcHRlciB0byBkaXNwYXRjaCB0aGUgcmVxdWVzdCBcIiArIG8sXG4gICAgICAgIFwiRVJSX05PVF9TVVBQT1JUXCJcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9LFxuICBhZGFwdGVyczogVmhcbn07XG5mdW5jdGlvbiBTZih0KSB7XG4gIGlmICh0LmNhbmNlbFRva2VuICYmIHQuY2FuY2VsVG9rZW4udGhyb3dJZlJlcXVlc3RlZCgpLCB0LnNpZ25hbCAmJiB0LnNpZ25hbC5hYm9ydGVkKVxuICAgIHRocm93IG5ldyBVbChudWxsLCB0KTtcbn1cbmZ1bmN0aW9uIHZiKHQpIHtcbiAgcmV0dXJuIFNmKHQpLCB0LmhlYWRlcnMgPSByaS5mcm9tKHQuaGVhZGVycyksIHQuZGF0YSA9IHlmLmNhbGwoXG4gICAgdCxcbiAgICB0LnRyYW5zZm9ybVJlcXVlc3RcbiAgKSwgW1wicG9zdFwiLCBcInB1dFwiLCBcInBhdGNoXCJdLmluZGV4T2YodC5tZXRob2QpICE9PSAtMSAmJiB0LmhlYWRlcnMuc2V0Q29udGVudFR5cGUoXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiwgITEpLCBsdy5nZXRBZGFwdGVyKHQuYWRhcHRlciB8fCBxTy5hZGFwdGVyKSh0KS50aGVuKGZ1bmN0aW9uKHIpIHtcbiAgICByZXR1cm4gU2YodCksIHIuZGF0YSA9IHlmLmNhbGwoXG4gICAgICB0LFxuICAgICAgdC50cmFuc2Zvcm1SZXNwb25zZSxcbiAgICAgIHJcbiAgICApLCByLmhlYWRlcnMgPSByaS5mcm9tKHIuaGVhZGVycyksIHI7XG4gIH0sIGZ1bmN0aW9uKHIpIHtcbiAgICByZXR1cm4gb3cocikgfHwgKFNmKHQpLCByICYmIHIucmVzcG9uc2UgJiYgKHIucmVzcG9uc2UuZGF0YSA9IHlmLmNhbGwoXG4gICAgICB0LFxuICAgICAgdC50cmFuc2Zvcm1SZXNwb25zZSxcbiAgICAgIHIucmVzcG9uc2VcbiAgICApLCByLnJlc3BvbnNlLmhlYWRlcnMgPSByaS5mcm9tKHIucmVzcG9uc2UuaGVhZGVycykpKSwgUHJvbWlzZS5yZWplY3Qocik7XG4gIH0pO1xufVxuY29uc3QgeWIgPSAodCkgPT4gdCBpbnN0YW5jZW9mIHJpID8geyAuLi50IH0gOiB0O1xuZnVuY3Rpb24gSW8odCwgZSkge1xuICBlID0gZSB8fCB7fTtcbiAgY29uc3QgbiA9IHt9O1xuICBmdW5jdGlvbiByKGMsIHUsIGQpIHtcbiAgICByZXR1cm4gVi5pc1BsYWluT2JqZWN0KGMpICYmIFYuaXNQbGFpbk9iamVjdCh1KSA/IFYubWVyZ2UuY2FsbCh7IGNhc2VsZXNzOiBkIH0sIGMsIHUpIDogVi5pc1BsYWluT2JqZWN0KHUpID8gVi5tZXJnZSh7fSwgdSkgOiBWLmlzQXJyYXkodSkgPyB1LnNsaWNlKCkgOiB1O1xuICB9XG4gIGZ1bmN0aW9uIGkoYywgdSwgZCkge1xuICAgIGlmIChWLmlzVW5kZWZpbmVkKHUpKSB7XG4gICAgICBpZiAoIVYuaXNVbmRlZmluZWQoYykpXG4gICAgICAgIHJldHVybiByKHZvaWQgMCwgYywgZCk7XG4gICAgfSBlbHNlXG4gICAgICByZXR1cm4gcihjLCB1LCBkKTtcbiAgfVxuICBmdW5jdGlvbiBzKGMsIHUpIHtcbiAgICBpZiAoIVYuaXNVbmRlZmluZWQodSkpXG4gICAgICByZXR1cm4gcih2b2lkIDAsIHUpO1xuICB9XG4gIGZ1bmN0aW9uIG8oYywgdSkge1xuICAgIGlmIChWLmlzVW5kZWZpbmVkKHUpKSB7XG4gICAgICBpZiAoIVYuaXNVbmRlZmluZWQoYykpXG4gICAgICAgIHJldHVybiByKHZvaWQgMCwgYyk7XG4gICAgfSBlbHNlXG4gICAgICByZXR1cm4gcih2b2lkIDAsIHUpO1xuICB9XG4gIGZ1bmN0aW9uIGEoYywgdSwgZCkge1xuICAgIGlmIChkIGluIGUpXG4gICAgICByZXR1cm4gcihjLCB1KTtcbiAgICBpZiAoZCBpbiB0KVxuICAgICAgcmV0dXJuIHIodm9pZCAwLCBjKTtcbiAgfVxuICBjb25zdCBsID0ge1xuICAgIHVybDogcyxcbiAgICBtZXRob2Q6IHMsXG4gICAgZGF0YTogcyxcbiAgICBiYXNlVVJMOiBvLFxuICAgIHRyYW5zZm9ybVJlcXVlc3Q6IG8sXG4gICAgdHJhbnNmb3JtUmVzcG9uc2U6IG8sXG4gICAgcGFyYW1zU2VyaWFsaXplcjogbyxcbiAgICB0aW1lb3V0OiBvLFxuICAgIHRpbWVvdXRNZXNzYWdlOiBvLFxuICAgIHdpdGhDcmVkZW50aWFsczogbyxcbiAgICB3aXRoWFNSRlRva2VuOiBvLFxuICAgIGFkYXB0ZXI6IG8sXG4gICAgcmVzcG9uc2VUeXBlOiBvLFxuICAgIHhzcmZDb29raWVOYW1lOiBvLFxuICAgIHhzcmZIZWFkZXJOYW1lOiBvLFxuICAgIG9uVXBsb2FkUHJvZ3Jlc3M6IG8sXG4gICAgb25Eb3dubG9hZFByb2dyZXNzOiBvLFxuICAgIGRlY29tcHJlc3M6IG8sXG4gICAgbWF4Q29udGVudExlbmd0aDogbyxcbiAgICBtYXhCb2R5TGVuZ3RoOiBvLFxuICAgIGJlZm9yZVJlZGlyZWN0OiBvLFxuICAgIHRyYW5zcG9ydDogbyxcbiAgICBodHRwQWdlbnQ6IG8sXG4gICAgaHR0cHNBZ2VudDogbyxcbiAgICBjYW5jZWxUb2tlbjogbyxcbiAgICBzb2NrZXRQYXRoOiBvLFxuICAgIHJlc3BvbnNlRW5jb2Rpbmc6IG8sXG4gICAgdmFsaWRhdGVTdGF0dXM6IGEsXG4gICAgaGVhZGVyczogKGMsIHUpID0+IGkoeWIoYyksIHliKHUpLCAhMClcbiAgfTtcbiAgcmV0dXJuIFYuZm9yRWFjaChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0LCBlKSksIGZ1bmN0aW9uKHUpIHtcbiAgICBjb25zdCBkID0gbFt1XSB8fCBpLCBmID0gZCh0W3VdLCBlW3VdLCB1KTtcbiAgICBWLmlzVW5kZWZpbmVkKGYpICYmIGQgIT09IGEgfHwgKG5bdV0gPSBmKTtcbiAgfSksIG47XG59XG5jb25zdCBjdyA9IFwiMS42LjhcIiwgWU8gPSB7fTtcbltcIm9iamVjdFwiLCBcImJvb2xlYW5cIiwgXCJudW1iZXJcIiwgXCJmdW5jdGlvblwiLCBcInN0cmluZ1wiLCBcInN5bWJvbFwiXS5mb3JFYWNoKCh0LCBlKSA9PiB7XG4gIFlPW3RdID0gZnVuY3Rpb24ocikge1xuICAgIHJldHVybiB0eXBlb2YgciA9PT0gdCB8fCBcImFcIiArIChlIDwgMSA/IFwibiBcIiA6IFwiIFwiKSArIHQ7XG4gIH07XG59KTtcbmNvbnN0IFNiID0ge307XG5ZTy50cmFuc2l0aW9uYWwgPSBmdW5jdGlvbihlLCBuLCByKSB7XG4gIGZ1bmN0aW9uIGkocywgbykge1xuICAgIHJldHVybiBcIltBeGlvcyB2XCIgKyBjdyArIFwiXSBUcmFuc2l0aW9uYWwgb3B0aW9uICdcIiArIHMgKyBcIidcIiArIG8gKyAociA/IFwiLiBcIiArIHIgOiBcIlwiKTtcbiAgfVxuICByZXR1cm4gKHMsIG8sIGEpID0+IHtcbiAgICBpZiAoZSA9PT0gITEpXG4gICAgICB0aHJvdyBuZXcgamUoXG4gICAgICAgIGkobywgXCIgaGFzIGJlZW4gcmVtb3ZlZFwiICsgKG4gPyBcIiBpbiBcIiArIG4gOiBcIlwiKSksXG4gICAgICAgIGplLkVSUl9ERVBSRUNBVEVEXG4gICAgICApO1xuICAgIHJldHVybiBuICYmICFTYltvXSAmJiAoU2Jbb10gPSAhMCwgY29uc29sZS53YXJuKFxuICAgICAgaShcbiAgICAgICAgbyxcbiAgICAgICAgXCIgaGFzIGJlZW4gZGVwcmVjYXRlZCBzaW5jZSB2XCIgKyBuICsgXCIgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmVhciBmdXR1cmVcIlxuICAgICAgKVxuICAgICkpLCBlID8gZShzLCBvLCBhKSA6ICEwO1xuICB9O1xufTtcbmZ1bmN0aW9uIGkyKHQsIGUsIG4pIHtcbiAgaWYgKHR5cGVvZiB0ICE9IFwib2JqZWN0XCIpXG4gICAgdGhyb3cgbmV3IGplKFwib3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdFwiLCBqZS5FUlJfQkFEX09QVElPTl9WQUxVRSk7XG4gIGNvbnN0IHIgPSBPYmplY3Qua2V5cyh0KTtcbiAgbGV0IGkgPSByLmxlbmd0aDtcbiAgZm9yICg7IGktLSA+IDA7ICkge1xuICAgIGNvbnN0IHMgPSByW2ldLCBvID0gZVtzXTtcbiAgICBpZiAobykge1xuICAgICAgY29uc3QgYSA9IHRbc10sIGwgPSBhID09PSB2b2lkIDAgfHwgbyhhLCBzLCB0KTtcbiAgICAgIGlmIChsICE9PSAhMClcbiAgICAgICAgdGhyb3cgbmV3IGplKFwib3B0aW9uIFwiICsgcyArIFwiIG11c3QgYmUgXCIgKyBsLCBqZS5FUlJfQkFEX09QVElPTl9WQUxVRSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG4gIT09ICEwKVxuICAgICAgdGhyb3cgbmV3IGplKFwiVW5rbm93biBvcHRpb24gXCIgKyBzLCBqZS5FUlJfQkFEX09QVElPTik7XG4gIH1cbn1cbmNvbnN0IEloID0ge1xuICBhc3NlcnRPcHRpb25zOiBpMixcbiAgdmFsaWRhdG9yczogWU9cbn0sIGtpID0gSWgudmFsaWRhdG9ycztcbmNsYXNzIFF1IHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMuZGVmYXVsdHMgPSBlLCB0aGlzLmludGVyY2VwdG9ycyA9IHtcbiAgICAgIHJlcXVlc3Q6IG5ldyBPYigpLFxuICAgICAgcmVzcG9uc2U6IG5ldyBPYigpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogRGlzcGF0Y2ggYSByZXF1ZXN0XG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gY29uZmlnT3JVcmwgVGhlIGNvbmZpZyBzcGVjaWZpYyBmb3IgdGhpcyByZXF1ZXN0IChtZXJnZWQgd2l0aCB0aGlzLmRlZmF1bHRzKVxuICAgKiBAcGFyYW0gez9PYmplY3R9IGNvbmZpZ1xuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIFByb21pc2UgdG8gYmUgZnVsZmlsbGVkXG4gICAqL1xuICBhc3luYyByZXF1ZXN0KGUsIG4pIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3JlcXVlc3QoZSwgbik7XG4gICAgfSBjYXRjaCAocikge1xuICAgICAgaWYgKHIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgPyBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShpID0ge30pIDogaSA9IG5ldyBFcnJvcigpO1xuICAgICAgICBjb25zdCBzID0gaS5zdGFjayA/IGkuc3RhY2sucmVwbGFjZSgvXi4rXFxuLywgXCJcIikgOiBcIlwiO1xuICAgICAgICByLnN0YWNrID8gcyAmJiAhU3RyaW5nKHIuc3RhY2spLmVuZHNXaXRoKHMucmVwbGFjZSgvXi4rXFxuLitcXG4vLCBcIlwiKSkgJiYgKHIuc3RhY2sgKz0gYFxuYCArIHMpIDogci5zdGFjayA9IHM7XG4gICAgICB9XG4gICAgICB0aHJvdyByO1xuICAgIH1cbiAgfVxuICBfcmVxdWVzdChlLCBuKSB7XG4gICAgdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiA/IChuID0gbiB8fCB7fSwgbi51cmwgPSBlKSA6IG4gPSBlIHx8IHt9LCBuID0gSW8odGhpcy5kZWZhdWx0cywgbik7XG4gICAgY29uc3QgeyB0cmFuc2l0aW9uYWw6IHIsIHBhcmFtc1NlcmlhbGl6ZXI6IGksIGhlYWRlcnM6IHMgfSA9IG47XG4gICAgciAhPT0gdm9pZCAwICYmIEloLmFzc2VydE9wdGlvbnMociwge1xuICAgICAgc2lsZW50SlNPTlBhcnNpbmc6IGtpLnRyYW5zaXRpb25hbChraS5ib29sZWFuKSxcbiAgICAgIGZvcmNlZEpTT05QYXJzaW5nOiBraS50cmFuc2l0aW9uYWwoa2kuYm9vbGVhbiksXG4gICAgICBjbGFyaWZ5VGltZW91dEVycm9yOiBraS50cmFuc2l0aW9uYWwoa2kuYm9vbGVhbilcbiAgICB9LCAhMSksIGkgIT0gbnVsbCAmJiAoVi5pc0Z1bmN0aW9uKGkpID8gbi5wYXJhbXNTZXJpYWxpemVyID0ge1xuICAgICAgc2VyaWFsaXplOiBpXG4gICAgfSA6IEloLmFzc2VydE9wdGlvbnMoaSwge1xuICAgICAgZW5jb2RlOiBraS5mdW5jdGlvbixcbiAgICAgIHNlcmlhbGl6ZToga2kuZnVuY3Rpb25cbiAgICB9LCAhMCkpLCBuLm1ldGhvZCA9IChuLm1ldGhvZCB8fCB0aGlzLmRlZmF1bHRzLm1ldGhvZCB8fCBcImdldFwiKS50b0xvd2VyQ2FzZSgpO1xuICAgIGxldCBvID0gcyAmJiBWLm1lcmdlKFxuICAgICAgcy5jb21tb24sXG4gICAgICBzW24ubWV0aG9kXVxuICAgICk7XG4gICAgcyAmJiBWLmZvckVhY2goXG4gICAgICBbXCJkZWxldGVcIiwgXCJnZXRcIiwgXCJoZWFkXCIsIFwicG9zdFwiLCBcInB1dFwiLCBcInBhdGNoXCIsIFwiY29tbW9uXCJdLFxuICAgICAgKHApID0+IHtcbiAgICAgICAgZGVsZXRlIHNbcF07XG4gICAgICB9XG4gICAgKSwgbi5oZWFkZXJzID0gcmkuY29uY2F0KG8sIHMpO1xuICAgIGNvbnN0IGEgPSBbXTtcbiAgICBsZXQgbCA9ICEwO1xuICAgIHRoaXMuaW50ZXJjZXB0b3JzLnJlcXVlc3QuZm9yRWFjaChmdW5jdGlvbihPKSB7XG4gICAgICB0eXBlb2YgTy5ydW5XaGVuID09IFwiZnVuY3Rpb25cIiAmJiBPLnJ1bldoZW4obikgPT09ICExIHx8IChsID0gbCAmJiBPLnN5bmNocm9ub3VzLCBhLnVuc2hpZnQoTy5mdWxmaWxsZWQsIE8ucmVqZWN0ZWQpKTtcbiAgICB9KTtcbiAgICBjb25zdCBjID0gW107XG4gICAgdGhpcy5pbnRlcmNlcHRvcnMucmVzcG9uc2UuZm9yRWFjaChmdW5jdGlvbihPKSB7XG4gICAgICBjLnB1c2goTy5mdWxmaWxsZWQsIE8ucmVqZWN0ZWQpO1xuICAgIH0pO1xuICAgIGxldCB1LCBkID0gMCwgZjtcbiAgICBpZiAoIWwpIHtcbiAgICAgIGNvbnN0IHAgPSBbdmIuYmluZCh0aGlzKSwgdm9pZCAwXTtcbiAgICAgIGZvciAocC51bnNoaWZ0LmFwcGx5KHAsIGEpLCBwLnB1c2guYXBwbHkocCwgYyksIGYgPSBwLmxlbmd0aCwgdSA9IFByb21pc2UucmVzb2x2ZShuKTsgZCA8IGY7IClcbiAgICAgICAgdSA9IHUudGhlbihwW2QrK10sIHBbZCsrXSk7XG4gICAgICByZXR1cm4gdTtcbiAgICB9XG4gICAgZiA9IGEubGVuZ3RoO1xuICAgIGxldCBoID0gbjtcbiAgICBmb3IgKGQgPSAwOyBkIDwgZjsgKSB7XG4gICAgICBjb25zdCBwID0gYVtkKytdLCBPID0gYVtkKytdO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaCA9IHAoaCk7XG4gICAgICB9IGNhdGNoIChtKSB7XG4gICAgICAgIE8uY2FsbCh0aGlzLCBtKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB1ID0gdmIuY2FsbCh0aGlzLCBoKTtcbiAgICB9IGNhdGNoIChwKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocCk7XG4gICAgfVxuICAgIGZvciAoZCA9IDAsIGYgPSBjLmxlbmd0aDsgZCA8IGY7IClcbiAgICAgIHUgPSB1LnRoZW4oY1tkKytdLCBjW2QrK10pO1xuICAgIHJldHVybiB1O1xuICB9XG4gIGdldFVyaShlKSB7XG4gICAgZSA9IElvKHRoaXMuZGVmYXVsdHMsIGUpO1xuICAgIGNvbnN0IG4gPSBhdyhlLmJhc2VVUkwsIGUudXJsKTtcbiAgICByZXR1cm4gbncobiwgZS5wYXJhbXMsIGUucGFyYW1zU2VyaWFsaXplcik7XG4gIH1cbn1cblYuZm9yRWFjaChbXCJkZWxldGVcIiwgXCJnZXRcIiwgXCJoZWFkXCIsIFwib3B0aW9uc1wiXSwgZnVuY3Rpb24oZSkge1xuICBRdS5wcm90b3R5cGVbZV0gPSBmdW5jdGlvbihuLCByKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChJbyhyIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IGUsXG4gICAgICB1cmw6IG4sXG4gICAgICBkYXRhOiAociB8fCB7fSkuZGF0YVxuICAgIH0pKTtcbiAgfTtcbn0pO1xuVi5mb3JFYWNoKFtcInBvc3RcIiwgXCJwdXRcIiwgXCJwYXRjaFwiXSwgZnVuY3Rpb24oZSkge1xuICBmdW5jdGlvbiBuKHIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ocywgbywgYSkge1xuICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChJbyhhIHx8IHt9LCB7XG4gICAgICAgIG1ldGhvZDogZSxcbiAgICAgICAgaGVhZGVyczogciA/IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcIm11bHRpcGFydC9mb3JtLWRhdGFcIlxuICAgICAgICB9IDoge30sXG4gICAgICAgIHVybDogcyxcbiAgICAgICAgZGF0YTogb1xuICAgICAgfSkpO1xuICAgIH07XG4gIH1cbiAgUXUucHJvdG90eXBlW2VdID0gbigpLCBRdS5wcm90b3R5cGVbZSArIFwiRm9ybVwiXSA9IG4oITApO1xufSk7XG5jb25zdCBldSA9IFF1O1xuY2xhc3Mgek8ge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgaWYgKHR5cGVvZiBlICE9IFwiZnVuY3Rpb25cIilcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb24uXCIpO1xuICAgIGxldCBuO1xuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHMpIHtcbiAgICAgIG4gPSBzO1xuICAgIH0pO1xuICAgIGNvbnN0IHIgPSB0aGlzO1xuICAgIHRoaXMucHJvbWlzZS50aGVuKChpKSA9PiB7XG4gICAgICBpZiAoIXIuX2xpc3RlbmVycylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbGV0IHMgPSByLl9saXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgZm9yICg7IHMtLSA+IDA7IClcbiAgICAgICAgci5fbGlzdGVuZXJzW3NdKGkpO1xuICAgICAgci5fbGlzdGVuZXJzID0gbnVsbDtcbiAgICB9KSwgdGhpcy5wcm9taXNlLnRoZW4gPSAoaSkgPT4ge1xuICAgICAgbGV0IHM7XG4gICAgICBjb25zdCBvID0gbmV3IFByb21pc2UoKGEpID0+IHtcbiAgICAgICAgci5zdWJzY3JpYmUoYSksIHMgPSBhO1xuICAgICAgfSkudGhlbihpKTtcbiAgICAgIHJldHVybiBvLmNhbmNlbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByLnVuc3Vic2NyaWJlKHMpO1xuICAgICAgfSwgbztcbiAgICB9LCBlKGZ1bmN0aW9uKHMsIG8sIGEpIHtcbiAgICAgIHIucmVhc29uIHx8IChyLnJlYXNvbiA9IG5ldyBVbChzLCBvLCBhKSwgbihyLnJlYXNvbikpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBUaHJvd3MgYSBgQ2FuY2VsZWRFcnJvcmAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAgICovXG4gIHRocm93SWZSZXF1ZXN0ZWQoKSB7XG4gICAgaWYgKHRoaXMucmVhc29uKVxuICAgICAgdGhyb3cgdGhpcy5yZWFzb247XG4gIH1cbiAgLyoqXG4gICAqIFN1YnNjcmliZSB0byB0aGUgY2FuY2VsIHNpZ25hbFxuICAgKi9cbiAgc3Vic2NyaWJlKGUpIHtcbiAgICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICAgIGUodGhpcy5yZWFzb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9saXN0ZW5lcnMgPyB0aGlzLl9saXN0ZW5lcnMucHVzaChlKSA6IHRoaXMuX2xpc3RlbmVycyA9IFtlXTtcbiAgfVxuICAvKipcbiAgICogVW5zdWJzY3JpYmUgZnJvbSB0aGUgY2FuY2VsIHNpZ25hbFxuICAgKi9cbiAgdW5zdWJzY3JpYmUoZSkge1xuICAgIGlmICghdGhpcy5fbGlzdGVuZXJzKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG4gPSB0aGlzLl9saXN0ZW5lcnMuaW5kZXhPZihlKTtcbiAgICBuICE9PSAtMSAmJiB0aGlzLl9saXN0ZW5lcnMuc3BsaWNlKG4sIDEpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgbmV3IGBDYW5jZWxUb2tlbmAgYW5kIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsXG4gICAqIGNhbmNlbHMgdGhlIGBDYW5jZWxUb2tlbmAuXG4gICAqL1xuICBzdGF0aWMgc291cmNlKCkge1xuICAgIGxldCBlO1xuICAgIHJldHVybiB7XG4gICAgICB0b2tlbjogbmV3IHpPKGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgZSA9IGk7XG4gICAgICB9KSxcbiAgICAgIGNhbmNlbDogZVxuICAgIH07XG4gIH1cbn1cbmNvbnN0IHMyID0gek87XG5mdW5jdGlvbiBvMih0KSB7XG4gIHJldHVybiBmdW5jdGlvbihuKSB7XG4gICAgcmV0dXJuIHQuYXBwbHkobnVsbCwgbik7XG4gIH07XG59XG5mdW5jdGlvbiBhMih0KSB7XG4gIHJldHVybiBWLmlzT2JqZWN0KHQpICYmIHQuaXNBeGlvc0Vycm9yID09PSAhMDtcbn1cbmNvbnN0IFdoID0ge1xuICBDb250aW51ZTogMTAwLFxuICBTd2l0Y2hpbmdQcm90b2NvbHM6IDEwMSxcbiAgUHJvY2Vzc2luZzogMTAyLFxuICBFYXJseUhpbnRzOiAxMDMsXG4gIE9rOiAyMDAsXG4gIENyZWF0ZWQ6IDIwMSxcbiAgQWNjZXB0ZWQ6IDIwMixcbiAgTm9uQXV0aG9yaXRhdGl2ZUluZm9ybWF0aW9uOiAyMDMsXG4gIE5vQ29udGVudDogMjA0LFxuICBSZXNldENvbnRlbnQ6IDIwNSxcbiAgUGFydGlhbENvbnRlbnQ6IDIwNixcbiAgTXVsdGlTdGF0dXM6IDIwNyxcbiAgQWxyZWFkeVJlcG9ydGVkOiAyMDgsXG4gIEltVXNlZDogMjI2LFxuICBNdWx0aXBsZUNob2ljZXM6IDMwMCxcbiAgTW92ZWRQZXJtYW5lbnRseTogMzAxLFxuICBGb3VuZDogMzAyLFxuICBTZWVPdGhlcjogMzAzLFxuICBOb3RNb2RpZmllZDogMzA0LFxuICBVc2VQcm94eTogMzA1LFxuICBVbnVzZWQ6IDMwNixcbiAgVGVtcG9yYXJ5UmVkaXJlY3Q6IDMwNyxcbiAgUGVybWFuZW50UmVkaXJlY3Q6IDMwOCxcbiAgQmFkUmVxdWVzdDogNDAwLFxuICBVbmF1dGhvcml6ZWQ6IDQwMSxcbiAgUGF5bWVudFJlcXVpcmVkOiA0MDIsXG4gIEZvcmJpZGRlbjogNDAzLFxuICBOb3RGb3VuZDogNDA0LFxuICBNZXRob2ROb3RBbGxvd2VkOiA0MDUsXG4gIE5vdEFjY2VwdGFibGU6IDQwNixcbiAgUHJveHlBdXRoZW50aWNhdGlvblJlcXVpcmVkOiA0MDcsXG4gIFJlcXVlc3RUaW1lb3V0OiA0MDgsXG4gIENvbmZsaWN0OiA0MDksXG4gIEdvbmU6IDQxMCxcbiAgTGVuZ3RoUmVxdWlyZWQ6IDQxMSxcbiAgUHJlY29uZGl0aW9uRmFpbGVkOiA0MTIsXG4gIFBheWxvYWRUb29MYXJnZTogNDEzLFxuICBVcmlUb29Mb25nOiA0MTQsXG4gIFVuc3VwcG9ydGVkTWVkaWFUeXBlOiA0MTUsXG4gIFJhbmdlTm90U2F0aXNmaWFibGU6IDQxNixcbiAgRXhwZWN0YXRpb25GYWlsZWQ6IDQxNyxcbiAgSW1BVGVhcG90OiA0MTgsXG4gIE1pc2RpcmVjdGVkUmVxdWVzdDogNDIxLFxuICBVbnByb2Nlc3NhYmxlRW50aXR5OiA0MjIsXG4gIExvY2tlZDogNDIzLFxuICBGYWlsZWREZXBlbmRlbmN5OiA0MjQsXG4gIFRvb0Vhcmx5OiA0MjUsXG4gIFVwZ3JhZGVSZXF1aXJlZDogNDI2LFxuICBQcmVjb25kaXRpb25SZXF1aXJlZDogNDI4LFxuICBUb29NYW55UmVxdWVzdHM6IDQyOSxcbiAgUmVxdWVzdEhlYWRlckZpZWxkc1Rvb0xhcmdlOiA0MzEsXG4gIFVuYXZhaWxhYmxlRm9yTGVnYWxSZWFzb25zOiA0NTEsXG4gIEludGVybmFsU2VydmVyRXJyb3I6IDUwMCxcbiAgTm90SW1wbGVtZW50ZWQ6IDUwMSxcbiAgQmFkR2F0ZXdheTogNTAyLFxuICBTZXJ2aWNlVW5hdmFpbGFibGU6IDUwMyxcbiAgR2F0ZXdheVRpbWVvdXQ6IDUwNCxcbiAgSHR0cFZlcnNpb25Ob3RTdXBwb3J0ZWQ6IDUwNSxcbiAgVmFyaWFudEFsc29OZWdvdGlhdGVzOiA1MDYsXG4gIEluc3VmZmljaWVudFN0b3JhZ2U6IDUwNyxcbiAgTG9vcERldGVjdGVkOiA1MDgsXG4gIE5vdEV4dGVuZGVkOiA1MTAsXG4gIE5ldHdvcmtBdXRoZW50aWNhdGlvblJlcXVpcmVkOiA1MTFcbn07XG5PYmplY3QuZW50cmllcyhXaCkuZm9yRWFjaCgoW3QsIGVdKSA9PiB7XG4gIFdoW2VdID0gdDtcbn0pO1xuY29uc3QgbDIgPSBXaDtcbmZ1bmN0aW9uIHV3KHQpIHtcbiAgY29uc3QgZSA9IG5ldyBldSh0KSwgbiA9IExTKGV1LnByb3RvdHlwZS5yZXF1ZXN0LCBlKTtcbiAgcmV0dXJuIFYuZXh0ZW5kKG4sIGV1LnByb3RvdHlwZSwgZSwgeyBhbGxPd25LZXlzOiAhMCB9KSwgVi5leHRlbmQobiwgZSwgbnVsbCwgeyBhbGxPd25LZXlzOiAhMCB9KSwgbi5jcmVhdGUgPSBmdW5jdGlvbihpKSB7XG4gICAgcmV0dXJuIHV3KElvKHQsIGkpKTtcbiAgfSwgbjtcbn1cbmNvbnN0IEF0ID0gdXcocU8pO1xuQXQuQXhpb3MgPSBldTtcbkF0LkNhbmNlbGVkRXJyb3IgPSBVbDtcbkF0LkNhbmNlbFRva2VuID0gczI7XG5BdC5pc0NhbmNlbCA9IG93O1xuQXQuVkVSU0lPTiA9IGN3O1xuQXQudG9Gb3JtRGF0YSA9IFpkO1xuQXQuQXhpb3NFcnJvciA9IGplO1xuQXQuQ2FuY2VsID0gQXQuQ2FuY2VsZWRFcnJvcjtcbkF0LmFsbCA9IGZ1bmN0aW9uKGUpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKGUpO1xufTtcbkF0LnNwcmVhZCA9IG8yO1xuQXQuaXNBeGlvc0Vycm9yID0gYTI7XG5BdC5tZXJnZUNvbmZpZyA9IElvO1xuQXQuQXhpb3NIZWFkZXJzID0gcmk7XG5BdC5mb3JtVG9KU09OID0gKHQpID0+IHN3KFYuaXNIVE1MRm9ybSh0KSA/IG5ldyBGb3JtRGF0YSh0KSA6IHQpO1xuQXQuZ2V0QWRhcHRlciA9IGx3LmdldEFkYXB0ZXI7XG5BdC5IdHRwU3RhdHVzQ29kZSA9IGwyO1xuQXQuZGVmYXVsdCA9IEF0O1xuY29uc3QgYzIgPSBcInVzZWFuZG9tLTI2VDE5ODM0MFBYNzVweEpBQ0tWRVJZTUlOREJVU0hXT0xGX0dRWmJmZ2hqa2xxdnd5enJpY3RcIjtcbmxldCB1MiA9ICh0ID0gMjEpID0+IHtcbiAgbGV0IGUgPSBcIlwiLCBuID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheSh0KSk7XG4gIGZvciAoOyB0LS07IClcbiAgICBlICs9IGMyW25bdF0gJiA2M107XG4gIHJldHVybiBlO1xufTtcbmNvbnN0IGQyID0gW1xuICBcIkJcIixcbiAgXCJrQlwiLFxuICBcIk1CXCIsXG4gIFwiR0JcIixcbiAgXCJUQlwiLFxuICBcIlBCXCIsXG4gIFwiRUJcIixcbiAgXCJaQlwiLFxuICBcIllCXCJcbl0sIGYyID0gW1xuICBcIkJcIixcbiAgXCJLaUJcIixcbiAgXCJNaUJcIixcbiAgXCJHaUJcIixcbiAgXCJUaUJcIixcbiAgXCJQaUJcIixcbiAgXCJFaUJcIixcbiAgXCJaaUJcIixcbiAgXCJZaUJcIlxuXSwgaDIgPSBbXG4gIFwiYlwiLFxuICBcImtiaXRcIixcbiAgXCJNYml0XCIsXG4gIFwiR2JpdFwiLFxuICBcIlRiaXRcIixcbiAgXCJQYml0XCIsXG4gIFwiRWJpdFwiLFxuICBcIlpiaXRcIixcbiAgXCJZYml0XCJcbl0sIHAyID0gW1xuICBcImJcIixcbiAgXCJraWJpdFwiLFxuICBcIk1pYml0XCIsXG4gIFwiR2liaXRcIixcbiAgXCJUaWJpdFwiLFxuICBcIlBpYml0XCIsXG4gIFwiRWliaXRcIixcbiAgXCJaaWJpdFwiLFxuICBcIllpYml0XCJcbl0sIHdiID0gKHQsIGUsIG4pID0+IHtcbiAgbGV0IHIgPSB0O1xuICByZXR1cm4gdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KGUpID8gciA9IHQudG9Mb2NhbGVTdHJpbmcoZSwgbikgOiAoZSA9PT0gITAgfHwgbiAhPT0gdm9pZCAwKSAmJiAociA9IHQudG9Mb2NhbGVTdHJpbmcodm9pZCAwLCBuKSksIHI7XG59O1xuZnVuY3Rpb24gQ3UodCwgZSkge1xuICBpZiAoIU51bWJlci5pc0Zpbml0ZSh0KSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBhIGZpbml0ZSBudW1iZXIsIGdvdCAke3R5cGVvZiB0fTogJHt0fWApO1xuICBlID0ge1xuICAgIGJpdHM6ICExLFxuICAgIGJpbmFyeTogITEsXG4gICAgc3BhY2U6ICEwLFxuICAgIC4uLmVcbiAgfTtcbiAgY29uc3QgbiA9IGUuYml0cyA/IGUuYmluYXJ5ID8gcDIgOiBoMiA6IGUuYmluYXJ5ID8gZjIgOiBkMiwgciA9IGUuc3BhY2UgPyBcIiBcIiA6IFwiXCI7XG4gIGlmIChlLnNpZ25lZCAmJiB0ID09PSAwKVxuICAgIHJldHVybiBgIDAke3J9JHtuWzBdfWA7XG4gIGNvbnN0IGkgPSB0IDwgMCwgcyA9IGkgPyBcIi1cIiA6IGUuc2lnbmVkID8gXCIrXCIgOiBcIlwiO1xuICBpICYmICh0ID0gLXQpO1xuICBsZXQgbztcbiAgaWYgKGUubWluaW11bUZyYWN0aW9uRGlnaXRzICE9PSB2b2lkIDAgJiYgKG8gPSB7IG1pbmltdW1GcmFjdGlvbkRpZ2l0czogZS5taW5pbXVtRnJhY3Rpb25EaWdpdHMgfSksIGUubWF4aW11bUZyYWN0aW9uRGlnaXRzICE9PSB2b2lkIDAgJiYgKG8gPSB7IG1heGltdW1GcmFjdGlvbkRpZ2l0czogZS5tYXhpbXVtRnJhY3Rpb25EaWdpdHMsIC4uLm8gfSksIHQgPCAxKSB7XG4gICAgY29uc3QgdSA9IHdiKHQsIGUubG9jYWxlLCBvKTtcbiAgICByZXR1cm4gcyArIHUgKyByICsgblswXTtcbiAgfVxuICBjb25zdCBhID0gTWF0aC5taW4oTWF0aC5mbG9vcihlLmJpbmFyeSA/IE1hdGgubG9nKHQpIC8gTWF0aC5sb2coMTAyNCkgOiBNYXRoLmxvZzEwKHQpIC8gMyksIG4ubGVuZ3RoIC0gMSk7XG4gIHQgLz0gKGUuYmluYXJ5ID8gMTAyNCA6IDFlMykgKiogYSwgbyB8fCAodCA9IHQudG9QcmVjaXNpb24oMykpO1xuICBjb25zdCBsID0gd2IoTnVtYmVyKHQpLCBlLmxvY2FsZSwgbyksIGMgPSBuW2FdO1xuICByZXR1cm4gcyArIGwgKyByICsgYztcbn1cbmZ1bmN0aW9uIE8yKHQpIHtcbiAgaWYgKHR5cGVvZiB0ICE9IFwibnVtYmVyXCIpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgbnVtYmVyXCIpO1xuICBjb25zdCBlID0gdCA+IDAgPyBNYXRoLmZsb29yIDogTWF0aC5jZWlsO1xuICByZXR1cm4ge1xuICAgIGRheXM6IGUodCAvIDg2NGU1KSxcbiAgICBob3VyczogZSh0IC8gMzZlNSkgJSAyNCxcbiAgICBtaW51dGVzOiBlKHQgLyA2ZTQpICUgNjAsXG4gICAgc2Vjb25kczogZSh0IC8gMWUzKSAlIDYwLFxuICAgIG1pbGxpc2Vjb25kczogZSh0KSAlIDFlMyxcbiAgICBtaWNyb3NlY29uZHM6IGUodCAqIDFlMykgJSAxZTMsXG4gICAgbmFub3NlY29uZHM6IGUodCAqIDFlNikgJSAxZTNcbiAgfTtcbn1cbmNvbnN0IGcyID0gKHQsIGUpID0+IGUgPT09IDEgPyB0IDogYCR7dH1zYCwgbTIgPSAxZS03O1xuZnVuY3Rpb24gZHcodCwgZSA9IHt9KSB7XG4gIGlmICghTnVtYmVyLmlzRmluaXRlKHQpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIGZpbml0ZSBudW1iZXJcIik7XG4gIGUuY29sb25Ob3RhdGlvbiAmJiAoZS5jb21wYWN0ID0gITEsIGUuZm9ybWF0U3ViTWlsbGlzZWNvbmRzID0gITEsIGUuc2VwYXJhdGVNaWxsaXNlY29uZHMgPSAhMSwgZS52ZXJib3NlID0gITEpLCBlLmNvbXBhY3QgJiYgKGUuc2Vjb25kc0RlY2ltYWxEaWdpdHMgPSAwLCBlLm1pbGxpc2Vjb25kc0RlY2ltYWxEaWdpdHMgPSAwKTtcbiAgY29uc3QgbiA9IFtdLCByID0gKG8sIGEpID0+IHtcbiAgICBjb25zdCBsID0gTWF0aC5mbG9vcihvICogMTAgKiogYSArIG0yKTtcbiAgICByZXR1cm4gKE1hdGgucm91bmQobCkgLyAxMCAqKiBhKS50b0ZpeGVkKGEpO1xuICB9LCBpID0gKG8sIGEsIGwsIGMpID0+IHtcbiAgICBpZiAoKG4ubGVuZ3RoID09PSAwIHx8ICFlLmNvbG9uTm90YXRpb24pICYmIG8gPT09IDAgJiYgIShlLmNvbG9uTm90YXRpb24gJiYgbCA9PT0gXCJtXCIpKVxuICAgICAgcmV0dXJuO1xuICAgIGMgPSAoYyB8fCBvIHx8IFwiMFwiKS50b1N0cmluZygpO1xuICAgIGxldCB1LCBkO1xuICAgIGlmIChlLmNvbG9uTm90YXRpb24pIHtcbiAgICAgIHUgPSBuLmxlbmd0aCA+IDAgPyBcIjpcIiA6IFwiXCIsIGQgPSBcIlwiO1xuICAgICAgY29uc3QgZiA9IGMuaW5jbHVkZXMoXCIuXCIpID8gYy5zcGxpdChcIi5cIilbMF0ubGVuZ3RoIDogYy5sZW5ndGgsIGggPSBuLmxlbmd0aCA+IDAgPyAyIDogMTtcbiAgICAgIGMgPSBcIjBcIi5yZXBlYXQoTWF0aC5tYXgoMCwgaCAtIGYpKSArIGM7XG4gICAgfSBlbHNlXG4gICAgICB1ID0gXCJcIiwgZCA9IGUudmVyYm9zZSA/IFwiIFwiICsgZzIoYSwgbykgOiBsO1xuICAgIG4ucHVzaCh1ICsgYyArIGQpO1xuICB9LCBzID0gTzIodCk7XG4gIGlmIChpKE1hdGgudHJ1bmMocy5kYXlzIC8gMzY1KSwgXCJ5ZWFyXCIsIFwieVwiKSwgaShzLmRheXMgJSAzNjUsIFwiZGF5XCIsIFwiZFwiKSwgaShzLmhvdXJzLCBcImhvdXJcIiwgXCJoXCIpLCBpKHMubWludXRlcywgXCJtaW51dGVcIiwgXCJtXCIpLCBlLnNlcGFyYXRlTWlsbGlzZWNvbmRzIHx8IGUuZm9ybWF0U3ViTWlsbGlzZWNvbmRzIHx8ICFlLmNvbG9uTm90YXRpb24gJiYgdCA8IDFlMylcbiAgICBpZiAoaShzLnNlY29uZHMsIFwic2Vjb25kXCIsIFwic1wiKSwgZS5mb3JtYXRTdWJNaWxsaXNlY29uZHMpXG4gICAgICBpKHMubWlsbGlzZWNvbmRzLCBcIm1pbGxpc2Vjb25kXCIsIFwibXNcIiksIGkocy5taWNyb3NlY29uZHMsIFwibWljcm9zZWNvbmRcIiwgXCLCtXNcIiksIGkocy5uYW5vc2Vjb25kcywgXCJuYW5vc2Vjb25kXCIsIFwibnNcIik7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBvID0gcy5taWxsaXNlY29uZHMgKyBzLm1pY3Jvc2Vjb25kcyAvIDFlMyArIHMubmFub3NlY29uZHMgLyAxZTYsIGEgPSB0eXBlb2YgZS5taWxsaXNlY29uZHNEZWNpbWFsRGlnaXRzID09IFwibnVtYmVyXCIgPyBlLm1pbGxpc2Vjb25kc0RlY2ltYWxEaWdpdHMgOiAwLCBsID0gbyA+PSAxID8gTWF0aC5yb3VuZChvKSA6IE1hdGguY2VpbChvKSwgYyA9IGEgPyBvLnRvRml4ZWQoYSkgOiBsO1xuICAgICAgaShcbiAgICAgICAgTnVtYmVyLnBhcnNlRmxvYXQoYyksXG4gICAgICAgIFwibWlsbGlzZWNvbmRcIixcbiAgICAgICAgXCJtc1wiLFxuICAgICAgICBjXG4gICAgICApO1xuICAgIH1cbiAgZWxzZSB7XG4gICAgY29uc3QgbyA9IHQgLyAxZTMgJSA2MCwgYSA9IHR5cGVvZiBlLnNlY29uZHNEZWNpbWFsRGlnaXRzID09IFwibnVtYmVyXCIgPyBlLnNlY29uZHNEZWNpbWFsRGlnaXRzIDogMSwgbCA9IHIobywgYSksIGMgPSBlLmtlZXBEZWNpbWFsc09uV2hvbGVTZWNvbmRzID8gbCA6IGwucmVwbGFjZSgvXFwuMCskLywgXCJcIik7XG4gICAgaShOdW1iZXIucGFyc2VGbG9hdChjKSwgXCJzZWNvbmRcIiwgXCJzXCIsIGMpO1xuICB9XG4gIGlmIChuLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gXCIwXCIgKyAoZS52ZXJib3NlID8gXCIgbWlsbGlzZWNvbmRzXCIgOiBcIm1zXCIpO1xuICBpZiAoZS5jb21wYWN0KVxuICAgIHJldHVybiBuWzBdO1xuICBpZiAodHlwZW9mIGUudW5pdENvdW50ID09IFwibnVtYmVyXCIpIHtcbiAgICBjb25zdCBvID0gZS5jb2xvbk5vdGF0aW9uID8gXCJcIiA6IFwiIFwiO1xuICAgIHJldHVybiBuLnNsaWNlKDAsIE1hdGgubWF4KGUudW5pdENvdW50LCAxKSkuam9pbihvKTtcbiAgfVxuICByZXR1cm4gZS5jb2xvbk5vdGF0aW9uID8gbi5qb2luKFwiXCIpIDogbi5qb2luKFwiIFwiKTtcbn1cbmNvbnN0IEF1ID0gTWF0aC5taW4sIElzID0gTWF0aC5tYXgsIFJ1ID0gTWF0aC5yb3VuZCwgd2MgPSBNYXRoLmZsb29yLCBpcyA9ICh0KSA9PiAoe1xuICB4OiB0LFxuICB5OiB0XG59KSwgYjIgPSB7XG4gIGxlZnQ6IFwicmlnaHRcIixcbiAgcmlnaHQ6IFwibGVmdFwiLFxuICBib3R0b206IFwidG9wXCIsXG4gIHRvcDogXCJib3R0b21cIlxufSwgdjIgPSB7XG4gIHN0YXJ0OiBcImVuZFwiLFxuICBlbmQ6IFwic3RhcnRcIlxufTtcbmZ1bmN0aW9uIGtiKHQsIGUsIG4pIHtcbiAgcmV0dXJuIElzKHQsIEF1KGUsIG4pKTtcbn1cbmZ1bmN0aW9uIElkKHQsIGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIiA/IHQoZSkgOiB0O1xufVxuZnVuY3Rpb24gTHModCkge1xuICByZXR1cm4gdC5zcGxpdChcIi1cIilbMF07XG59XG5mdW5jdGlvbiBXZCh0KSB7XG4gIHJldHVybiB0LnNwbGl0KFwiLVwiKVsxXTtcbn1cbmZ1bmN0aW9uIGZ3KHQpIHtcbiAgcmV0dXJuIHQgPT09IFwieFwiID8gXCJ5XCIgOiBcInhcIjtcbn1cbmZ1bmN0aW9uIGh3KHQpIHtcbiAgcmV0dXJuIHQgPT09IFwieVwiID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIjtcbn1cbmZ1bmN0aW9uIE1kKHQpIHtcbiAgcmV0dXJuIFtcInRvcFwiLCBcImJvdHRvbVwiXS5pbmNsdWRlcyhMcyh0KSkgPyBcInlcIiA6IFwieFwiO1xufVxuZnVuY3Rpb24gcHcodCkge1xuICByZXR1cm4gZncoTWQodCkpO1xufVxuZnVuY3Rpb24geTIodCwgZSwgbikge1xuICBuID09PSB2b2lkIDAgJiYgKG4gPSAhMSk7XG4gIGNvbnN0IHIgPSBXZCh0KSwgaSA9IHB3KHQpLCBzID0gaHcoaSk7XG4gIGxldCBvID0gaSA9PT0gXCJ4XCIgPyByID09PSAobiA/IFwiZW5kXCIgOiBcInN0YXJ0XCIpID8gXCJyaWdodFwiIDogXCJsZWZ0XCIgOiByID09PSBcInN0YXJ0XCIgPyBcImJvdHRvbVwiIDogXCJ0b3BcIjtcbiAgcmV0dXJuIGUucmVmZXJlbmNlW3NdID4gZS5mbG9hdGluZ1tzXSAmJiAobyA9IE51KG8pKSwgW28sIE51KG8pXTtcbn1cbmZ1bmN0aW9uIFMyKHQpIHtcbiAgY29uc3QgZSA9IE51KHQpO1xuICByZXR1cm4gW01oKHQpLCBlLCBNaChlKV07XG59XG5mdW5jdGlvbiBNaCh0KSB7XG4gIHJldHVybiB0LnJlcGxhY2UoL3N0YXJ0fGVuZC9nLCAoZSkgPT4gdjJbZV0pO1xufVxuZnVuY3Rpb24gdzIodCwgZSwgbikge1xuICBjb25zdCByID0gW1wibGVmdFwiLCBcInJpZ2h0XCJdLCBpID0gW1wicmlnaHRcIiwgXCJsZWZ0XCJdLCBzID0gW1widG9wXCIsIFwiYm90dG9tXCJdLCBvID0gW1wiYm90dG9tXCIsIFwidG9wXCJdO1xuICBzd2l0Y2ggKHQpIHtcbiAgICBjYXNlIFwidG9wXCI6XG4gICAgY2FzZSBcImJvdHRvbVwiOlxuICAgICAgcmV0dXJuIG4gPyBlID8gaSA6IHIgOiBlID8gciA6IGk7XG4gICAgY2FzZSBcImxlZnRcIjpcbiAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgIHJldHVybiBlID8gcyA6IG87XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBbXTtcbiAgfVxufVxuZnVuY3Rpb24gazIodCwgZSwgbiwgcikge1xuICBjb25zdCBpID0gV2QodCk7XG4gIGxldCBzID0gdzIoTHModCksIG4gPT09IFwic3RhcnRcIiwgcik7XG4gIHJldHVybiBpICYmIChzID0gcy5tYXAoKG8pID0+IG8gKyBcIi1cIiArIGkpLCBlICYmIChzID0gcy5jb25jYXQocy5tYXAoTWgpKSkpLCBzO1xufVxuZnVuY3Rpb24gTnUodCkge1xuICByZXR1cm4gdC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgKGUpID0+IGIyW2VdKTtcbn1cbmZ1bmN0aW9uIHgyKHQpIHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDAsXG4gICAgLi4udFxuICB9O1xufVxuZnVuY3Rpb24gUDIodCkge1xuICByZXR1cm4gdHlwZW9mIHQgIT0gXCJudW1iZXJcIiA/IHgyKHQpIDoge1xuICAgIHRvcDogdCxcbiAgICByaWdodDogdCxcbiAgICBib3R0b206IHQsXG4gICAgbGVmdDogdFxuICB9O1xufVxuZnVuY3Rpb24gRHUodCkge1xuICBjb25zdCB7XG4gICAgeDogZSxcbiAgICB5OiBuLFxuICAgIHdpZHRoOiByLFxuICAgIGhlaWdodDogaVxuICB9ID0gdDtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogcixcbiAgICBoZWlnaHQ6IGksXG4gICAgdG9wOiBuLFxuICAgIGxlZnQ6IGUsXG4gICAgcmlnaHQ6IGUgKyByLFxuICAgIGJvdHRvbTogbiArIGksXG4gICAgeDogZSxcbiAgICB5OiBuXG4gIH07XG59XG5mdW5jdGlvbiB4Yih0LCBlLCBuKSB7XG4gIGxldCB7XG4gICAgcmVmZXJlbmNlOiByLFxuICAgIGZsb2F0aW5nOiBpXG4gIH0gPSB0O1xuICBjb25zdCBzID0gTWQoZSksIG8gPSBwdyhlKSwgYSA9IGh3KG8pLCBsID0gTHMoZSksIGMgPSBzID09PSBcInlcIiwgdSA9IHIueCArIHIud2lkdGggLyAyIC0gaS53aWR0aCAvIDIsIGQgPSByLnkgKyByLmhlaWdodCAvIDIgLSBpLmhlaWdodCAvIDIsIGYgPSByW2FdIC8gMiAtIGlbYV0gLyAyO1xuICBsZXQgaDtcbiAgc3dpdGNoIChsKSB7XG4gICAgY2FzZSBcInRvcFwiOlxuICAgICAgaCA9IHtcbiAgICAgICAgeDogdSxcbiAgICAgICAgeTogci55IC0gaS5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICBoID0ge1xuICAgICAgICB4OiB1LFxuICAgICAgICB5OiByLnkgKyByLmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgaCA9IHtcbiAgICAgICAgeDogci54ICsgci53aWR0aCxcbiAgICAgICAgeTogZFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICBoID0ge1xuICAgICAgICB4OiByLnggLSBpLndpZHRoLFxuICAgICAgICB5OiBkXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGggPSB7XG4gICAgICAgIHg6IHIueCxcbiAgICAgICAgeTogci55XG4gICAgICB9O1xuICB9XG4gIHN3aXRjaCAoV2QoZSkpIHtcbiAgICBjYXNlIFwic3RhcnRcIjpcbiAgICAgIGhbb10gLT0gZiAqIChuICYmIGMgPyAtMSA6IDEpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcImVuZFwiOlxuICAgICAgaFtvXSArPSBmICogKG4gJiYgYyA/IC0xIDogMSk7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gaDtcbn1cbmNvbnN0IF8yID0gYXN5bmMgKHQsIGUsIG4pID0+IHtcbiAgY29uc3Qge1xuICAgIHBsYWNlbWVudDogciA9IFwiYm90dG9tXCIsXG4gICAgc3RyYXRlZ3k6IGkgPSBcImFic29sdXRlXCIsXG4gICAgbWlkZGxld2FyZTogcyA9IFtdLFxuICAgIHBsYXRmb3JtOiBvXG4gIH0gPSBuLCBhID0gcy5maWx0ZXIoQm9vbGVhbiksIGwgPSBhd2FpdCAoby5pc1JUTCA9PSBudWxsID8gdm9pZCAwIDogby5pc1JUTChlKSk7XG4gIGxldCBjID0gYXdhaXQgby5nZXRFbGVtZW50UmVjdHMoe1xuICAgIHJlZmVyZW5jZTogdCxcbiAgICBmbG9hdGluZzogZSxcbiAgICBzdHJhdGVneTogaVxuICB9KSwge1xuICAgIHg6IHUsXG4gICAgeTogZFxuICB9ID0geGIoYywgciwgbCksIGYgPSByLCBoID0ge30sIHAgPSAwO1xuICBmb3IgKGxldCBPID0gMDsgTyA8IGEubGVuZ3RoOyBPKyspIHtcbiAgICBjb25zdCB7XG4gICAgICBuYW1lOiBtLFxuICAgICAgZm46IHlcbiAgICB9ID0gYVtPXSwge1xuICAgICAgeDogYixcbiAgICAgIHk6IGcsXG4gICAgICBkYXRhOiB2LFxuICAgICAgcmVzZXQ6IFNcbiAgICB9ID0gYXdhaXQgeSh7XG4gICAgICB4OiB1LFxuICAgICAgeTogZCxcbiAgICAgIGluaXRpYWxQbGFjZW1lbnQ6IHIsXG4gICAgICBwbGFjZW1lbnQ6IGYsXG4gICAgICBzdHJhdGVneTogaSxcbiAgICAgIG1pZGRsZXdhcmVEYXRhOiBoLFxuICAgICAgcmVjdHM6IGMsXG4gICAgICBwbGF0Zm9ybTogbyxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIHJlZmVyZW5jZTogdCxcbiAgICAgICAgZmxvYXRpbmc6IGVcbiAgICAgIH1cbiAgICB9KTtcbiAgICB1ID0gYiA/PyB1LCBkID0gZyA/PyBkLCBoID0ge1xuICAgICAgLi4uaCxcbiAgICAgIFttXToge1xuICAgICAgICAuLi5oW21dLFxuICAgICAgICAuLi52XG4gICAgICB9XG4gICAgfSwgUyAmJiBwIDw9IDUwICYmIChwKyssIHR5cGVvZiBTID09IFwib2JqZWN0XCIgJiYgKFMucGxhY2VtZW50ICYmIChmID0gUy5wbGFjZW1lbnQpLCBTLnJlY3RzICYmIChjID0gUy5yZWN0cyA9PT0gITAgPyBhd2FpdCBvLmdldEVsZW1lbnRSZWN0cyh7XG4gICAgICByZWZlcmVuY2U6IHQsXG4gICAgICBmbG9hdGluZzogZSxcbiAgICAgIHN0cmF0ZWd5OiBpXG4gICAgfSkgOiBTLnJlY3RzKSwge1xuICAgICAgeDogdSxcbiAgICAgIHk6IGRcbiAgICB9ID0geGIoYywgZiwgbCkpLCBPID0gLTEpO1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogdSxcbiAgICB5OiBkLFxuICAgIHBsYWNlbWVudDogZixcbiAgICBzdHJhdGVneTogaSxcbiAgICBtaWRkbGV3YXJlRGF0YTogaFxuICB9O1xufTtcbmFzeW5jIGZ1bmN0aW9uIE93KHQsIGUpIHtcbiAgdmFyIG47XG4gIGUgPT09IHZvaWQgMCAmJiAoZSA9IHt9KTtcbiAgY29uc3Qge1xuICAgIHg6IHIsXG4gICAgeTogaSxcbiAgICBwbGF0Zm9ybTogcyxcbiAgICByZWN0czogbyxcbiAgICBlbGVtZW50czogYSxcbiAgICBzdHJhdGVneTogbFxuICB9ID0gdCwge1xuICAgIGJvdW5kYXJ5OiBjID0gXCJjbGlwcGluZ0FuY2VzdG9yc1wiLFxuICAgIHJvb3RCb3VuZGFyeTogdSA9IFwidmlld3BvcnRcIixcbiAgICBlbGVtZW50Q29udGV4dDogZCA9IFwiZmxvYXRpbmdcIixcbiAgICBhbHRCb3VuZGFyeTogZiA9ICExLFxuICAgIHBhZGRpbmc6IGggPSAwXG4gIH0gPSBJZChlLCB0KSwgcCA9IFAyKGgpLCBtID0gYVtmID8gZCA9PT0gXCJmbG9hdGluZ1wiID8gXCJyZWZlcmVuY2VcIiA6IFwiZmxvYXRpbmdcIiA6IGRdLCB5ID0gRHUoYXdhaXQgcy5nZXRDbGlwcGluZ1JlY3Qoe1xuICAgIGVsZW1lbnQ6IChuID0gYXdhaXQgKHMuaXNFbGVtZW50ID09IG51bGwgPyB2b2lkIDAgOiBzLmlzRWxlbWVudChtKSkpID09IG51bGwgfHwgbiA/IG0gOiBtLmNvbnRleHRFbGVtZW50IHx8IGF3YWl0IChzLmdldERvY3VtZW50RWxlbWVudCA9PSBudWxsID8gdm9pZCAwIDogcy5nZXREb2N1bWVudEVsZW1lbnQoYS5mbG9hdGluZykpLFxuICAgIGJvdW5kYXJ5OiBjLFxuICAgIHJvb3RCb3VuZGFyeTogdSxcbiAgICBzdHJhdGVneTogbFxuICB9KSksIGIgPSBkID09PSBcImZsb2F0aW5nXCIgPyB7XG4gICAgLi4uby5mbG9hdGluZyxcbiAgICB4OiByLFxuICAgIHk6IGlcbiAgfSA6IG8ucmVmZXJlbmNlLCBnID0gYXdhaXQgKHMuZ2V0T2Zmc2V0UGFyZW50ID09IG51bGwgPyB2b2lkIDAgOiBzLmdldE9mZnNldFBhcmVudChhLmZsb2F0aW5nKSksIHYgPSBhd2FpdCAocy5pc0VsZW1lbnQgPT0gbnVsbCA/IHZvaWQgMCA6IHMuaXNFbGVtZW50KGcpKSA/IGF3YWl0IChzLmdldFNjYWxlID09IG51bGwgPyB2b2lkIDAgOiBzLmdldFNjYWxlKGcpKSB8fCB7XG4gICAgeDogMSxcbiAgICB5OiAxXG4gIH0gOiB7XG4gICAgeDogMSxcbiAgICB5OiAxXG4gIH0sIFMgPSBEdShzLmNvbnZlcnRPZmZzZXRQYXJlbnRSZWxhdGl2ZVJlY3RUb1ZpZXdwb3J0UmVsYXRpdmVSZWN0ID8gYXdhaXQgcy5jb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCh7XG4gICAgZWxlbWVudHM6IGEsXG4gICAgcmVjdDogYixcbiAgICBvZmZzZXRQYXJlbnQ6IGcsXG4gICAgc3RyYXRlZ3k6IGxcbiAgfSkgOiBiKTtcbiAgcmV0dXJuIHtcbiAgICB0b3A6ICh5LnRvcCAtIFMudG9wICsgcC50b3ApIC8gdi55LFxuICAgIGJvdHRvbTogKFMuYm90dG9tIC0geS5ib3R0b20gKyBwLmJvdHRvbSkgLyB2LnksXG4gICAgbGVmdDogKHkubGVmdCAtIFMubGVmdCArIHAubGVmdCkgLyB2LngsXG4gICAgcmlnaHQ6IChTLnJpZ2h0IC0geS5yaWdodCArIHAucmlnaHQpIC8gdi54XG4gIH07XG59XG5jb25zdCBUMiA9IGZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIHQgPT09IHZvaWQgMCAmJiAodCA9IHt9KSwge1xuICAgIG5hbWU6IFwiZmxpcFwiLFxuICAgIG9wdGlvbnM6IHQsXG4gICAgYXN5bmMgZm4oZSkge1xuICAgICAgdmFyIG4sIHI7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHBsYWNlbWVudDogaSxcbiAgICAgICAgbWlkZGxld2FyZURhdGE6IHMsXG4gICAgICAgIHJlY3RzOiBvLFxuICAgICAgICBpbml0aWFsUGxhY2VtZW50OiBhLFxuICAgICAgICBwbGF0Zm9ybTogbCxcbiAgICAgICAgZWxlbWVudHM6IGNcbiAgICAgIH0gPSBlLCB7XG4gICAgICAgIG1haW5BeGlzOiB1ID0gITAsXG4gICAgICAgIGNyb3NzQXhpczogZCA9ICEwLFxuICAgICAgICBmYWxsYmFja1BsYWNlbWVudHM6IGYsXG4gICAgICAgIGZhbGxiYWNrU3RyYXRlZ3k6IGggPSBcImJlc3RGaXRcIixcbiAgICAgICAgZmFsbGJhY2tBeGlzU2lkZURpcmVjdGlvbjogcCA9IFwibm9uZVwiLFxuICAgICAgICBmbGlwQWxpZ25tZW50OiBPID0gITAsXG4gICAgICAgIC4uLm1cbiAgICAgIH0gPSBJZCh0LCBlKTtcbiAgICAgIGlmICgobiA9IHMuYXJyb3cpICE9IG51bGwgJiYgbi5hbGlnbm1lbnRPZmZzZXQpXG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIGNvbnN0IHkgPSBMcyhpKSwgYiA9IExzKGEpID09PSBhLCBnID0gYXdhaXQgKGwuaXNSVEwgPT0gbnVsbCA/IHZvaWQgMCA6IGwuaXNSVEwoYy5mbG9hdGluZykpLCB2ID0gZiB8fCAoYiB8fCAhTyA/IFtOdShhKV0gOiBTMihhKSk7XG4gICAgICAhZiAmJiBwICE9PSBcIm5vbmVcIiAmJiB2LnB1c2goLi4uazIoYSwgTywgcCwgZykpO1xuICAgICAgY29uc3QgUyA9IFthLCAuLi52XSwgdyA9IGF3YWl0IE93KGUsIG0pLCBrID0gW107XG4gICAgICBsZXQgXyA9ICgociA9IHMuZmxpcCkgPT0gbnVsbCA/IHZvaWQgMCA6IHIub3ZlcmZsb3dzKSB8fCBbXTtcbiAgICAgIGlmICh1ICYmIGsucHVzaCh3W3ldKSwgZCkge1xuICAgICAgICBjb25zdCBRID0geTIoaSwgbywgZyk7XG4gICAgICAgIGsucHVzaCh3W1FbMF1dLCB3W1FbMV1dKTtcbiAgICAgIH1cbiAgICAgIGlmIChfID0gWy4uLl8sIHtcbiAgICAgICAgcGxhY2VtZW50OiBpLFxuICAgICAgICBvdmVyZmxvd3M6IGtcbiAgICAgIH1dLCAhay5ldmVyeSgoUSkgPT4gUSA8PSAwKSkge1xuICAgICAgICB2YXIgVCwgQztcbiAgICAgICAgY29uc3QgUSA9ICgoKFQgPSBzLmZsaXApID09IG51bGwgPyB2b2lkIDAgOiBULmluZGV4KSB8fCAwKSArIDEsIFcgPSBTW1FdO1xuICAgICAgICBpZiAoVylcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICBpbmRleDogUSxcbiAgICAgICAgICAgICAgb3ZlcmZsb3dzOiBfXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVzZXQ6IHtcbiAgICAgICAgICAgICAgcGxhY2VtZW50OiBXXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgbGV0IEwgPSAoQyA9IF8uZmlsdGVyKChyZSkgPT4gcmUub3ZlcmZsb3dzWzBdIDw9IDApLnNvcnQoKHJlLCBZKSA9PiByZS5vdmVyZmxvd3NbMV0gLSBZLm92ZXJmbG93c1sxXSlbMF0pID09IG51bGwgPyB2b2lkIDAgOiBDLnBsYWNlbWVudDtcbiAgICAgICAgaWYgKCFMKVxuICAgICAgICAgIHN3aXRjaCAoaCkge1xuICAgICAgICAgICAgY2FzZSBcImJlc3RGaXRcIjoge1xuICAgICAgICAgICAgICB2YXIgQTtcbiAgICAgICAgICAgICAgY29uc3QgcmUgPSAoQSA9IF8ubWFwKChZKSA9PiBbWS5wbGFjZW1lbnQsIFkub3ZlcmZsb3dzLmZpbHRlcigoSykgPT4gSyA+IDApLnJlZHVjZSgoSywgQikgPT4gSyArIEIsIDApXSkuc29ydCgoWSwgSykgPT4gWVsxXSAtIEtbMV0pWzBdKSA9PSBudWxsID8gdm9pZCAwIDogQVswXTtcbiAgICAgICAgICAgICAgcmUgJiYgKEwgPSByZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImluaXRpYWxQbGFjZW1lbnRcIjpcbiAgICAgICAgICAgICAgTCA9IGE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgaWYgKGkgIT09IEwpXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlc2V0OiB7XG4gICAgICAgICAgICAgIHBsYWNlbWVudDogTFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICB9O1xufTtcbmFzeW5jIGZ1bmN0aW9uIEUyKHQsIGUpIHtcbiAgY29uc3Qge1xuICAgIHBsYWNlbWVudDogbixcbiAgICBwbGF0Zm9ybTogcixcbiAgICBlbGVtZW50czogaVxuICB9ID0gdCwgcyA9IGF3YWl0IChyLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiByLmlzUlRMKGkuZmxvYXRpbmcpKSwgbyA9IExzKG4pLCBhID0gV2QobiksIGwgPSBNZChuKSA9PT0gXCJ5XCIsIGMgPSBbXCJsZWZ0XCIsIFwidG9wXCJdLmluY2x1ZGVzKG8pID8gLTEgOiAxLCB1ID0gcyAmJiBsID8gLTEgOiAxLCBkID0gSWQoZSwgdCk7XG4gIGxldCB7XG4gICAgbWFpbkF4aXM6IGYsXG4gICAgY3Jvc3NBeGlzOiBoLFxuICAgIGFsaWdubWVudEF4aXM6IHBcbiAgfSA9IHR5cGVvZiBkID09IFwibnVtYmVyXCIgPyB7XG4gICAgbWFpbkF4aXM6IGQsXG4gICAgY3Jvc3NBeGlzOiAwLFxuICAgIGFsaWdubWVudEF4aXM6IG51bGxcbiAgfSA6IHtcbiAgICBtYWluQXhpczogMCxcbiAgICBjcm9zc0F4aXM6IDAsXG4gICAgYWxpZ25tZW50QXhpczogbnVsbCxcbiAgICAuLi5kXG4gIH07XG4gIHJldHVybiBhICYmIHR5cGVvZiBwID09IFwibnVtYmVyXCIgJiYgKGggPSBhID09PSBcImVuZFwiID8gcCAqIC0xIDogcCksIGwgPyB7XG4gICAgeDogaCAqIHUsXG4gICAgeTogZiAqIGNcbiAgfSA6IHtcbiAgICB4OiBmICogYyxcbiAgICB5OiBoICogdVxuICB9O1xufVxuY29uc3QgJDIgPSBmdW5jdGlvbih0KSB7XG4gIHJldHVybiB0ID09PSB2b2lkIDAgJiYgKHQgPSAwKSwge1xuICAgIG5hbWU6IFwib2Zmc2V0XCIsXG4gICAgb3B0aW9uczogdCxcbiAgICBhc3luYyBmbihlKSB7XG4gICAgICB2YXIgbiwgcjtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeDogaSxcbiAgICAgICAgeTogcyxcbiAgICAgICAgcGxhY2VtZW50OiBvLFxuICAgICAgICBtaWRkbGV3YXJlRGF0YTogYVxuICAgICAgfSA9IGUsIGwgPSBhd2FpdCBFMihlLCB0KTtcbiAgICAgIHJldHVybiBvID09PSAoKG4gPSBhLm9mZnNldCkgPT0gbnVsbCA/IHZvaWQgMCA6IG4ucGxhY2VtZW50KSAmJiAociA9IGEuYXJyb3cpICE9IG51bGwgJiYgci5hbGlnbm1lbnRPZmZzZXQgPyB7fSA6IHtcbiAgICAgICAgeDogaSArIGwueCxcbiAgICAgICAgeTogcyArIGwueSxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIC4uLmwsXG4gICAgICAgICAgcGxhY2VtZW50OiBvXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufSwgUTIgPSBmdW5jdGlvbih0KSB7XG4gIHJldHVybiB0ID09PSB2b2lkIDAgJiYgKHQgPSB7fSksIHtcbiAgICBuYW1lOiBcInNoaWZ0XCIsXG4gICAgb3B0aW9uczogdCxcbiAgICBhc3luYyBmbihlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHg6IG4sXG4gICAgICAgIHk6IHIsXG4gICAgICAgIHBsYWNlbWVudDogaVxuICAgICAgfSA9IGUsIHtcbiAgICAgICAgbWFpbkF4aXM6IHMgPSAhMCxcbiAgICAgICAgY3Jvc3NBeGlzOiBvID0gITEsXG4gICAgICAgIGxpbWl0ZXI6IGEgPSB7XG4gICAgICAgICAgZm46IChtKSA9PiB7XG4gICAgICAgICAgICBsZXQge1xuICAgICAgICAgICAgICB4OiB5LFxuICAgICAgICAgICAgICB5OiBiXG4gICAgICAgICAgICB9ID0gbTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHg6IHksXG4gICAgICAgICAgICAgIHk6IGJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAuLi5sXG4gICAgICB9ID0gSWQodCwgZSksIGMgPSB7XG4gICAgICAgIHg6IG4sXG4gICAgICAgIHk6IHJcbiAgICAgIH0sIHUgPSBhd2FpdCBPdyhlLCBsKSwgZCA9IE1kKExzKGkpKSwgZiA9IGZ3KGQpO1xuICAgICAgbGV0IGggPSBjW2ZdLCBwID0gY1tkXTtcbiAgICAgIGlmIChzKSB7XG4gICAgICAgIGNvbnN0IG0gPSBmID09PSBcInlcIiA/IFwidG9wXCIgOiBcImxlZnRcIiwgeSA9IGYgPT09IFwieVwiID8gXCJib3R0b21cIiA6IFwicmlnaHRcIiwgYiA9IGggKyB1W21dLCBnID0gaCAtIHVbeV07XG4gICAgICAgIGggPSBrYihiLCBoLCBnKTtcbiAgICAgIH1cbiAgICAgIGlmIChvKSB7XG4gICAgICAgIGNvbnN0IG0gPSBkID09PSBcInlcIiA/IFwidG9wXCIgOiBcImxlZnRcIiwgeSA9IGQgPT09IFwieVwiID8gXCJib3R0b21cIiA6IFwicmlnaHRcIiwgYiA9IHAgKyB1W21dLCBnID0gcCAtIHVbeV07XG4gICAgICAgIHAgPSBrYihiLCBwLCBnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IE8gPSBhLmZuKHtcbiAgICAgICAgLi4uZSxcbiAgICAgICAgW2ZdOiBoLFxuICAgICAgICBbZF06IHBcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uTyxcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIHg6IE8ueCAtIG4sXG4gICAgICAgICAgeTogTy55IC0gclxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn07XG5mdW5jdGlvbiB1aSh0KSB7XG4gIHJldHVybiBITyh0KSA/ICh0Lm5vZGVOYW1lIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkgOiBcIiNkb2N1bWVudFwiO1xufVxuZnVuY3Rpb24gTW4odCkge1xuICB2YXIgZTtcbiAgcmV0dXJuICh0ID09IG51bGwgfHwgKGUgPSB0Lm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBlLmRlZmF1bHRWaWV3KSB8fCB3aW5kb3c7XG59XG5mdW5jdGlvbiBtaSh0KSB7XG4gIHZhciBlO1xuICByZXR1cm4gKGUgPSAoSE8odCkgPyB0Lm93bmVyRG9jdW1lbnQgOiB0LmRvY3VtZW50KSB8fCB3aW5kb3cuZG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBlLmRvY3VtZW50RWxlbWVudDtcbn1cbmZ1bmN0aW9uIEhPKHQpIHtcbiAgcmV0dXJuIHQgaW5zdGFuY2VvZiBOb2RlIHx8IHQgaW5zdGFuY2VvZiBNbih0KS5Ob2RlO1xufVxuZnVuY3Rpb24gZGkodCkge1xuICByZXR1cm4gdCBpbnN0YW5jZW9mIEVsZW1lbnQgfHwgdCBpbnN0YW5jZW9mIE1uKHQpLkVsZW1lbnQ7XG59XG5mdW5jdGlvbiBqcih0KSB7XG4gIHJldHVybiB0IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgfHwgdCBpbnN0YW5jZW9mIE1uKHQpLkhUTUxFbGVtZW50O1xufVxuZnVuY3Rpb24gUGIodCkge1xuICByZXR1cm4gdHlwZW9mIFNoYWRvd1Jvb3QgPiBcInVcIiA/ICExIDogdCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgfHwgdCBpbnN0YW5jZW9mIE1uKHQpLlNoYWRvd1Jvb3Q7XG59XG5mdW5jdGlvbiBxbCh0KSB7XG4gIGNvbnN0IHtcbiAgICBvdmVyZmxvdzogZSxcbiAgICBvdmVyZmxvd1g6IG4sXG4gICAgb3ZlcmZsb3dZOiByLFxuICAgIGRpc3BsYXk6IGlcbiAgfSA9IG5yKHQpO1xuICByZXR1cm4gL2F1dG98c2Nyb2xsfG92ZXJsYXl8aGlkZGVufGNsaXAvLnRlc3QoZSArIHIgKyBuKSAmJiAhW1wiaW5saW5lXCIsIFwiY29udGVudHNcIl0uaW5jbHVkZXMoaSk7XG59XG5mdW5jdGlvbiBDMih0KSB7XG4gIHJldHVybiBbXCJ0YWJsZVwiLCBcInRkXCIsIFwidGhcIl0uaW5jbHVkZXModWkodCkpO1xufVxuZnVuY3Rpb24gRk8odCkge1xuICBjb25zdCBlID0gR08oKSwgbiA9IG5yKHQpO1xuICByZXR1cm4gbi50cmFuc2Zvcm0gIT09IFwibm9uZVwiIHx8IG4ucGVyc3BlY3RpdmUgIT09IFwibm9uZVwiIHx8IChuLmNvbnRhaW5lclR5cGUgPyBuLmNvbnRhaW5lclR5cGUgIT09IFwibm9ybWFsXCIgOiAhMSkgfHwgIWUgJiYgKG4uYmFja2Ryb3BGaWx0ZXIgPyBuLmJhY2tkcm9wRmlsdGVyICE9PSBcIm5vbmVcIiA6ICExKSB8fCAhZSAmJiAobi5maWx0ZXIgPyBuLmZpbHRlciAhPT0gXCJub25lXCIgOiAhMSkgfHwgW1widHJhbnNmb3JtXCIsIFwicGVyc3BlY3RpdmVcIiwgXCJmaWx0ZXJcIl0uc29tZSgocikgPT4gKG4ud2lsbENoYW5nZSB8fCBcIlwiKS5pbmNsdWRlcyhyKSkgfHwgW1wicGFpbnRcIiwgXCJsYXlvdXRcIiwgXCJzdHJpY3RcIiwgXCJjb250ZW50XCJdLnNvbWUoKHIpID0+IChuLmNvbnRhaW4gfHwgXCJcIikuaW5jbHVkZXMocikpO1xufVxuZnVuY3Rpb24gQTIodCkge1xuICBsZXQgZSA9IFdvKHQpO1xuICBmb3IgKDsganIoZSkgJiYgIVhkKGUpOyApIHtcbiAgICBpZiAoRk8oZSkpXG4gICAgICByZXR1cm4gZTtcbiAgICBlID0gV28oZSk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBHTygpIHtcbiAgcmV0dXJuIHR5cGVvZiBDU1MgPiBcInVcIiB8fCAhQ1NTLnN1cHBvcnRzID8gITEgOiBDU1Muc3VwcG9ydHMoXCItd2Via2l0LWJhY2tkcm9wLWZpbHRlclwiLCBcIm5vbmVcIik7XG59XG5mdW5jdGlvbiBYZCh0KSB7XG4gIHJldHVybiBbXCJodG1sXCIsIFwiYm9keVwiLCBcIiNkb2N1bWVudFwiXS5pbmNsdWRlcyh1aSh0KSk7XG59XG5mdW5jdGlvbiBucih0KSB7XG4gIHJldHVybiBNbih0KS5nZXRDb21wdXRlZFN0eWxlKHQpO1xufVxuZnVuY3Rpb24gamQodCkge1xuICByZXR1cm4gZGkodCkgPyB7XG4gICAgc2Nyb2xsTGVmdDogdC5zY3JvbGxMZWZ0LFxuICAgIHNjcm9sbFRvcDogdC5zY3JvbGxUb3BcbiAgfSA6IHtcbiAgICBzY3JvbGxMZWZ0OiB0LnBhZ2VYT2Zmc2V0LFxuICAgIHNjcm9sbFRvcDogdC5wYWdlWU9mZnNldFxuICB9O1xufVxuZnVuY3Rpb24gV28odCkge1xuICBpZiAodWkodCkgPT09IFwiaHRtbFwiKVxuICAgIHJldHVybiB0O1xuICBjb25zdCBlID0gKFxuICAgIC8vIFN0ZXAgaW50byB0aGUgc2hhZG93IERPTSBvZiB0aGUgcGFyZW50IG9mIGEgc2xvdHRlZCBub2RlLlxuICAgIHQuYXNzaWduZWRTbG90IHx8IC8vIERPTSBFbGVtZW50IGRldGVjdGVkLlxuICAgIHQucGFyZW50Tm9kZSB8fCAvLyBTaGFkb3dSb290IGRldGVjdGVkLlxuICAgIFBiKHQpICYmIHQuaG9zdCB8fCAvLyBGYWxsYmFjay5cbiAgICBtaSh0KVxuICApO1xuICByZXR1cm4gUGIoZSkgPyBlLmhvc3QgOiBlO1xufVxuZnVuY3Rpb24gZ3codCkge1xuICBjb25zdCBlID0gV28odCk7XG4gIHJldHVybiBYZChlKSA/IHQub3duZXJEb2N1bWVudCA/IHQub3duZXJEb2N1bWVudC5ib2R5IDogdC5ib2R5IDoganIoZSkgJiYgcWwoZSkgPyBlIDogZ3coZSk7XG59XG5mdW5jdGlvbiB1bCh0LCBlLCBuKSB7XG4gIHZhciByO1xuICBlID09PSB2b2lkIDAgJiYgKGUgPSBbXSksIG4gPT09IHZvaWQgMCAmJiAobiA9ICEwKTtcbiAgY29uc3QgaSA9IGd3KHQpLCBzID0gaSA9PT0gKChyID0gdC5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogci5ib2R5KSwgbyA9IE1uKGkpO1xuICByZXR1cm4gcyA/IGUuY29uY2F0KG8sIG8udmlzdWFsVmlld3BvcnQgfHwgW10sIHFsKGkpID8gaSA6IFtdLCBvLmZyYW1lRWxlbWVudCAmJiBuID8gdWwoby5mcmFtZUVsZW1lbnQpIDogW10pIDogZS5jb25jYXQoaSwgdWwoaSwgW10sIG4pKTtcbn1cbmZ1bmN0aW9uIG13KHQpIHtcbiAgY29uc3QgZSA9IG5yKHQpO1xuICBsZXQgbiA9IHBhcnNlRmxvYXQoZS53aWR0aCkgfHwgMCwgciA9IHBhcnNlRmxvYXQoZS5oZWlnaHQpIHx8IDA7XG4gIGNvbnN0IGkgPSBqcih0KSwgcyA9IGkgPyB0Lm9mZnNldFdpZHRoIDogbiwgbyA9IGkgPyB0Lm9mZnNldEhlaWdodCA6IHIsIGEgPSBSdShuKSAhPT0gcyB8fCBSdShyKSAhPT0gbztcbiAgcmV0dXJuIGEgJiYgKG4gPSBzLCByID0gbyksIHtcbiAgICB3aWR0aDogbixcbiAgICBoZWlnaHQ6IHIsXG4gICAgJDogYVxuICB9O1xufVxuZnVuY3Rpb24gS08odCkge1xuICByZXR1cm4gZGkodCkgPyB0IDogdC5jb250ZXh0RWxlbWVudDtcbn1cbmZ1bmN0aW9uIHhvKHQpIHtcbiAgY29uc3QgZSA9IEtPKHQpO1xuICBpZiAoIWpyKGUpKVxuICAgIHJldHVybiBpcygxKTtcbiAgY29uc3QgbiA9IGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHtcbiAgICB3aWR0aDogcixcbiAgICBoZWlnaHQ6IGksXG4gICAgJDogc1xuICB9ID0gbXcoZSk7XG4gIGxldCBvID0gKHMgPyBSdShuLndpZHRoKSA6IG4ud2lkdGgpIC8gciwgYSA9IChzID8gUnUobi5oZWlnaHQpIDogbi5oZWlnaHQpIC8gaTtcbiAgcmV0dXJuICghbyB8fCAhTnVtYmVyLmlzRmluaXRlKG8pKSAmJiAobyA9IDEpLCAoIWEgfHwgIU51bWJlci5pc0Zpbml0ZShhKSkgJiYgKGEgPSAxKSwge1xuICAgIHg6IG8sXG4gICAgeTogYVxuICB9O1xufVxuY29uc3QgUjIgPSAvKiBAX19QVVJFX18gKi8gaXMoMCk7XG5mdW5jdGlvbiBidyh0KSB7XG4gIGNvbnN0IGUgPSBNbih0KTtcbiAgcmV0dXJuICFHTygpIHx8ICFlLnZpc3VhbFZpZXdwb3J0ID8gUjIgOiB7XG4gICAgeDogZS52aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0LFxuICAgIHk6IGUudmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wXG4gIH07XG59XG5mdW5jdGlvbiBOMih0LCBlLCBuKSB7XG4gIHJldHVybiBlID09PSB2b2lkIDAgJiYgKGUgPSAhMSksICFuIHx8IGUgJiYgbiAhPT0gTW4odCkgPyAhMSA6IGU7XG59XG5mdW5jdGlvbiBVcyh0LCBlLCBuLCByKSB7XG4gIGUgPT09IHZvaWQgMCAmJiAoZSA9ICExKSwgbiA9PT0gdm9pZCAwICYmIChuID0gITEpO1xuICBjb25zdCBpID0gdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgcyA9IEtPKHQpO1xuICBsZXQgbyA9IGlzKDEpO1xuICBlICYmIChyID8gZGkocikgJiYgKG8gPSB4byhyKSkgOiBvID0geG8odCkpO1xuICBjb25zdCBhID0gTjIocywgbiwgcikgPyBidyhzKSA6IGlzKDApO1xuICBsZXQgbCA9IChpLmxlZnQgKyBhLngpIC8gby54LCBjID0gKGkudG9wICsgYS55KSAvIG8ueSwgdSA9IGkud2lkdGggLyBvLngsIGQgPSBpLmhlaWdodCAvIG8ueTtcbiAgaWYgKHMpIHtcbiAgICBjb25zdCBmID0gTW4ocyksIGggPSByICYmIGRpKHIpID8gTW4ocikgOiByO1xuICAgIGxldCBwID0gZiwgTyA9IHAuZnJhbWVFbGVtZW50O1xuICAgIGZvciAoOyBPICYmIHIgJiYgaCAhPT0gcDsgKSB7XG4gICAgICBjb25zdCBtID0geG8oTyksIHkgPSBPLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBiID0gbnIoTyksIGcgPSB5LmxlZnQgKyAoTy5jbGllbnRMZWZ0ICsgcGFyc2VGbG9hdChiLnBhZGRpbmdMZWZ0KSkgKiBtLngsIHYgPSB5LnRvcCArIChPLmNsaWVudFRvcCArIHBhcnNlRmxvYXQoYi5wYWRkaW5nVG9wKSkgKiBtLnk7XG4gICAgICBsICo9IG0ueCwgYyAqPSBtLnksIHUgKj0gbS54LCBkICo9IG0ueSwgbCArPSBnLCBjICs9IHYsIHAgPSBNbihPKSwgTyA9IHAuZnJhbWVFbGVtZW50O1xuICAgIH1cbiAgfVxuICByZXR1cm4gRHUoe1xuICAgIHdpZHRoOiB1LFxuICAgIGhlaWdodDogZCxcbiAgICB4OiBsLFxuICAgIHk6IGNcbiAgfSk7XG59XG5jb25zdCBEMiA9IFtcIjpwb3BvdmVyLW9wZW5cIiwgXCI6bW9kYWxcIl07XG5mdW5jdGlvbiB2dyh0KSB7XG4gIHJldHVybiBEMi5zb21lKChlKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0Lm1hdGNoZXMoZSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIFoyKHQpIHtcbiAgbGV0IHtcbiAgICBlbGVtZW50czogZSxcbiAgICByZWN0OiBuLFxuICAgIG9mZnNldFBhcmVudDogcixcbiAgICBzdHJhdGVneTogaVxuICB9ID0gdDtcbiAgY29uc3QgcyA9IGkgPT09IFwiZml4ZWRcIiwgbyA9IG1pKHIpLCBhID0gZSA/IHZ3KGUuZmxvYXRpbmcpIDogITE7XG4gIGlmIChyID09PSBvIHx8IGEgJiYgcylcbiAgICByZXR1cm4gbjtcbiAgbGV0IGwgPSB7XG4gICAgc2Nyb2xsTGVmdDogMCxcbiAgICBzY3JvbGxUb3A6IDBcbiAgfSwgYyA9IGlzKDEpO1xuICBjb25zdCB1ID0gaXMoMCksIGQgPSBqcihyKTtcbiAgaWYgKChkIHx8ICFkICYmICFzKSAmJiAoKHVpKHIpICE9PSBcImJvZHlcIiB8fCBxbChvKSkgJiYgKGwgPSBqZChyKSksIGpyKHIpKSkge1xuICAgIGNvbnN0IGYgPSBVcyhyKTtcbiAgICBjID0geG8ociksIHUueCA9IGYueCArIHIuY2xpZW50TGVmdCwgdS55ID0gZi55ICsgci5jbGllbnRUb3A7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogbi53aWR0aCAqIGMueCxcbiAgICBoZWlnaHQ6IG4uaGVpZ2h0ICogYy55LFxuICAgIHg6IG4ueCAqIGMueCAtIGwuc2Nyb2xsTGVmdCAqIGMueCArIHUueCxcbiAgICB5OiBuLnkgKiBjLnkgLSBsLnNjcm9sbFRvcCAqIGMueSArIHUueVxuICB9O1xufVxuZnVuY3Rpb24gVjIodCkge1xuICByZXR1cm4gQXJyYXkuZnJvbSh0LmdldENsaWVudFJlY3RzKCkpO1xufVxuZnVuY3Rpb24geXcodCkge1xuICByZXR1cm4gVXMobWkodCkpLmxlZnQgKyBqZCh0KS5zY3JvbGxMZWZ0O1xufVxuZnVuY3Rpb24gSTIodCkge1xuICBjb25zdCBlID0gbWkodCksIG4gPSBqZCh0KSwgciA9IHQub3duZXJEb2N1bWVudC5ib2R5LCBpID0gSXMoZS5zY3JvbGxXaWR0aCwgZS5jbGllbnRXaWR0aCwgci5zY3JvbGxXaWR0aCwgci5jbGllbnRXaWR0aCksIHMgPSBJcyhlLnNjcm9sbEhlaWdodCwgZS5jbGllbnRIZWlnaHQsIHIuc2Nyb2xsSGVpZ2h0LCByLmNsaWVudEhlaWdodCk7XG4gIGxldCBvID0gLW4uc2Nyb2xsTGVmdCArIHl3KHQpO1xuICBjb25zdCBhID0gLW4uc2Nyb2xsVG9wO1xuICByZXR1cm4gbnIocikuZGlyZWN0aW9uID09PSBcInJ0bFwiICYmIChvICs9IElzKGUuY2xpZW50V2lkdGgsIHIuY2xpZW50V2lkdGgpIC0gaSksIHtcbiAgICB3aWR0aDogaSxcbiAgICBoZWlnaHQ6IHMsXG4gICAgeDogbyxcbiAgICB5OiBhXG4gIH07XG59XG5mdW5jdGlvbiBXMih0LCBlKSB7XG4gIGNvbnN0IG4gPSBNbih0KSwgciA9IG1pKHQpLCBpID0gbi52aXN1YWxWaWV3cG9ydDtcbiAgbGV0IHMgPSByLmNsaWVudFdpZHRoLCBvID0gci5jbGllbnRIZWlnaHQsIGEgPSAwLCBsID0gMDtcbiAgaWYgKGkpIHtcbiAgICBzID0gaS53aWR0aCwgbyA9IGkuaGVpZ2h0O1xuICAgIGNvbnN0IGMgPSBHTygpO1xuICAgICghYyB8fCBjICYmIGUgPT09IFwiZml4ZWRcIikgJiYgKGEgPSBpLm9mZnNldExlZnQsIGwgPSBpLm9mZnNldFRvcCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogcyxcbiAgICBoZWlnaHQ6IG8sXG4gICAgeDogYSxcbiAgICB5OiBsXG4gIH07XG59XG5mdW5jdGlvbiBNMih0LCBlKSB7XG4gIGNvbnN0IG4gPSBVcyh0LCAhMCwgZSA9PT0gXCJmaXhlZFwiKSwgciA9IG4udG9wICsgdC5jbGllbnRUb3AsIGkgPSBuLmxlZnQgKyB0LmNsaWVudExlZnQsIHMgPSBqcih0KSA/IHhvKHQpIDogaXMoMSksIG8gPSB0LmNsaWVudFdpZHRoICogcy54LCBhID0gdC5jbGllbnRIZWlnaHQgKiBzLnksIGwgPSBpICogcy54LCBjID0gciAqIHMueTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogbyxcbiAgICBoZWlnaHQ6IGEsXG4gICAgeDogbCxcbiAgICB5OiBjXG4gIH07XG59XG5mdW5jdGlvbiBfYih0LCBlLCBuKSB7XG4gIGxldCByO1xuICBpZiAoZSA9PT0gXCJ2aWV3cG9ydFwiKVxuICAgIHIgPSBXMih0LCBuKTtcbiAgZWxzZSBpZiAoZSA9PT0gXCJkb2N1bWVudFwiKVxuICAgIHIgPSBJMihtaSh0KSk7XG4gIGVsc2UgaWYgKGRpKGUpKVxuICAgIHIgPSBNMihlLCBuKTtcbiAgZWxzZSB7XG4gICAgY29uc3QgaSA9IGJ3KHQpO1xuICAgIHIgPSB7XG4gICAgICAuLi5lLFxuICAgICAgeDogZS54IC0gaS54LFxuICAgICAgeTogZS55IC0gaS55XG4gICAgfTtcbiAgfVxuICByZXR1cm4gRHUocik7XG59XG5mdW5jdGlvbiBTdyh0LCBlKSB7XG4gIGNvbnN0IG4gPSBXbyh0KTtcbiAgcmV0dXJuIG4gPT09IGUgfHwgIWRpKG4pIHx8IFhkKG4pID8gITEgOiBucihuKS5wb3NpdGlvbiA9PT0gXCJmaXhlZFwiIHx8IFN3KG4sIGUpO1xufVxuZnVuY3Rpb24gWDIodCwgZSkge1xuICBjb25zdCBuID0gZS5nZXQodCk7XG4gIGlmIChuKVxuICAgIHJldHVybiBuO1xuICBsZXQgciA9IHVsKHQsIFtdLCAhMSkuZmlsdGVyKChhKSA9PiBkaShhKSAmJiB1aShhKSAhPT0gXCJib2R5XCIpLCBpID0gbnVsbDtcbiAgY29uc3QgcyA9IG5yKHQpLnBvc2l0aW9uID09PSBcImZpeGVkXCI7XG4gIGxldCBvID0gcyA/IFdvKHQpIDogdDtcbiAgZm9yICg7IGRpKG8pICYmICFYZChvKTsgKSB7XG4gICAgY29uc3QgYSA9IG5yKG8pLCBsID0gRk8obyk7XG4gICAgIWwgJiYgYS5wb3NpdGlvbiA9PT0gXCJmaXhlZFwiICYmIChpID0gbnVsbCksIChzID8gIWwgJiYgIWkgOiAhbCAmJiBhLnBvc2l0aW9uID09PSBcInN0YXRpY1wiICYmICEhaSAmJiBbXCJhYnNvbHV0ZVwiLCBcImZpeGVkXCJdLmluY2x1ZGVzKGkucG9zaXRpb24pIHx8IHFsKG8pICYmICFsICYmIFN3KHQsIG8pKSA/IHIgPSByLmZpbHRlcigodSkgPT4gdSAhPT0gbykgOiBpID0gYSwgbyA9IFdvKG8pO1xuICB9XG4gIHJldHVybiBlLnNldCh0LCByKSwgcjtcbn1cbmZ1bmN0aW9uIGoyKHQpIHtcbiAgbGV0IHtcbiAgICBlbGVtZW50OiBlLFxuICAgIGJvdW5kYXJ5OiBuLFxuICAgIHJvb3RCb3VuZGFyeTogcixcbiAgICBzdHJhdGVneTogaVxuICB9ID0gdDtcbiAgY29uc3QgbyA9IFsuLi5uID09PSBcImNsaXBwaW5nQW5jZXN0b3JzXCIgPyBYMihlLCB0aGlzLl9jKSA6IFtdLmNvbmNhdChuKSwgcl0sIGEgPSBvWzBdLCBsID0gby5yZWR1Y2UoKGMsIHUpID0+IHtcbiAgICBjb25zdCBkID0gX2IoZSwgdSwgaSk7XG4gICAgcmV0dXJuIGMudG9wID0gSXMoZC50b3AsIGMudG9wKSwgYy5yaWdodCA9IEF1KGQucmlnaHQsIGMucmlnaHQpLCBjLmJvdHRvbSA9IEF1KGQuYm90dG9tLCBjLmJvdHRvbSksIGMubGVmdCA9IElzKGQubGVmdCwgYy5sZWZ0KSwgYztcbiAgfSwgX2IoZSwgYSwgaSkpO1xuICByZXR1cm4ge1xuICAgIHdpZHRoOiBsLnJpZ2h0IC0gbC5sZWZ0LFxuICAgIGhlaWdodDogbC5ib3R0b20gLSBsLnRvcCxcbiAgICB4OiBsLmxlZnQsXG4gICAgeTogbC50b3BcbiAgfTtcbn1cbmZ1bmN0aW9uIEIyKHQpIHtcbiAgY29uc3Qge1xuICAgIHdpZHRoOiBlLFxuICAgIGhlaWdodDogblxuICB9ID0gbXcodCk7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IGUsXG4gICAgaGVpZ2h0OiBuXG4gIH07XG59XG5mdW5jdGlvbiBMMih0LCBlLCBuKSB7XG4gIGNvbnN0IHIgPSBqcihlKSwgaSA9IG1pKGUpLCBzID0gbiA9PT0gXCJmaXhlZFwiLCBvID0gVXModCwgITAsIHMsIGUpO1xuICBsZXQgYSA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICBjb25zdCBsID0gaXMoMCk7XG4gIGlmIChyIHx8ICFyICYmICFzKVxuICAgIGlmICgodWkoZSkgIT09IFwiYm9keVwiIHx8IHFsKGkpKSAmJiAoYSA9IGpkKGUpKSwgcikge1xuICAgICAgY29uc3QgZCA9IFVzKGUsICEwLCBzLCBlKTtcbiAgICAgIGwueCA9IGQueCArIGUuY2xpZW50TGVmdCwgbC55ID0gZC55ICsgZS5jbGllbnRUb3A7XG4gICAgfSBlbHNlXG4gICAgICBpICYmIChsLnggPSB5dyhpKSk7XG4gIGNvbnN0IGMgPSBvLmxlZnQgKyBhLnNjcm9sbExlZnQgLSBsLngsIHUgPSBvLnRvcCArIGEuc2Nyb2xsVG9wIC0gbC55O1xuICByZXR1cm4ge1xuICAgIHg6IGMsXG4gICAgeTogdSxcbiAgICB3aWR0aDogby53aWR0aCxcbiAgICBoZWlnaHQ6IG8uaGVpZ2h0XG4gIH07XG59XG5mdW5jdGlvbiBUYih0LCBlKSB7XG4gIHJldHVybiAhanIodCkgfHwgbnIodCkucG9zaXRpb24gPT09IFwiZml4ZWRcIiA/IG51bGwgOiBlID8gZSh0KSA6IHQub2Zmc2V0UGFyZW50O1xufVxuZnVuY3Rpb24gd3codCwgZSkge1xuICBjb25zdCBuID0gTW4odCk7XG4gIGlmICghanIodCkgfHwgdncodCkpXG4gICAgcmV0dXJuIG47XG4gIGxldCByID0gVGIodCwgZSk7XG4gIGZvciAoOyByICYmIEMyKHIpICYmIG5yKHIpLnBvc2l0aW9uID09PSBcInN0YXRpY1wiOyApXG4gICAgciA9IFRiKHIsIGUpO1xuICByZXR1cm4gciAmJiAodWkocikgPT09IFwiaHRtbFwiIHx8IHVpKHIpID09PSBcImJvZHlcIiAmJiBucihyKS5wb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiAmJiAhRk8ocikpID8gbiA6IHIgfHwgQTIodCkgfHwgbjtcbn1cbmNvbnN0IFUyID0gYXN5bmMgZnVuY3Rpb24odCkge1xuICBjb25zdCBlID0gdGhpcy5nZXRPZmZzZXRQYXJlbnQgfHwgd3csIG4gPSB0aGlzLmdldERpbWVuc2lvbnM7XG4gIHJldHVybiB7XG4gICAgcmVmZXJlbmNlOiBMMih0LnJlZmVyZW5jZSwgYXdhaXQgZSh0LmZsb2F0aW5nKSwgdC5zdHJhdGVneSksXG4gICAgZmxvYXRpbmc6IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwLFxuICAgICAgLi4uYXdhaXQgbih0LmZsb2F0aW5nKVxuICAgIH1cbiAgfTtcbn07XG5mdW5jdGlvbiBxMih0KSB7XG4gIHJldHVybiBucih0KS5kaXJlY3Rpb24gPT09IFwicnRsXCI7XG59XG5jb25zdCBZMiA9IHtcbiAgY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3Q6IFoyLFxuICBnZXREb2N1bWVudEVsZW1lbnQ6IG1pLFxuICBnZXRDbGlwcGluZ1JlY3Q6IGoyLFxuICBnZXRPZmZzZXRQYXJlbnQ6IHd3LFxuICBnZXRFbGVtZW50UmVjdHM6IFUyLFxuICBnZXRDbGllbnRSZWN0czogVjIsXG4gIGdldERpbWVuc2lvbnM6IEIyLFxuICBnZXRTY2FsZTogeG8sXG4gIGlzRWxlbWVudDogZGksXG4gIGlzUlRMOiBxMlxufTtcbmZ1bmN0aW9uIHoyKHQsIGUpIHtcbiAgbGV0IG4gPSBudWxsLCByO1xuICBjb25zdCBpID0gbWkodCk7XG4gIGZ1bmN0aW9uIHMoKSB7XG4gICAgdmFyIGE7XG4gICAgY2xlYXJUaW1lb3V0KHIpLCAoYSA9IG4pID09IG51bGwgfHwgYS5kaXNjb25uZWN0KCksIG4gPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIG8oYSwgbCkge1xuICAgIGEgPT09IHZvaWQgMCAmJiAoYSA9ICExKSwgbCA9PT0gdm9pZCAwICYmIChsID0gMSksIHMoKTtcbiAgICBjb25zdCB7XG4gICAgICBsZWZ0OiBjLFxuICAgICAgdG9wOiB1LFxuICAgICAgd2lkdGg6IGQsXG4gICAgICBoZWlnaHQ6IGZcbiAgICB9ID0gdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoYSB8fCBlKCksICFkIHx8ICFmKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGggPSB3Yyh1KSwgcCA9IHdjKGkuY2xpZW50V2lkdGggLSAoYyArIGQpKSwgTyA9IHdjKGkuY2xpZW50SGVpZ2h0IC0gKHUgKyBmKSksIG0gPSB3YyhjKSwgYiA9IHtcbiAgICAgIHJvb3RNYXJnaW46IC1oICsgXCJweCBcIiArIC1wICsgXCJweCBcIiArIC1PICsgXCJweCBcIiArIC1tICsgXCJweFwiLFxuICAgICAgdGhyZXNob2xkOiBJcygwLCBBdSgxLCBsKSkgfHwgMVxuICAgIH07XG4gICAgbGV0IGcgPSAhMDtcbiAgICBmdW5jdGlvbiB2KFMpIHtcbiAgICAgIGNvbnN0IHcgPSBTWzBdLmludGVyc2VjdGlvblJhdGlvO1xuICAgICAgaWYgKHcgIT09IGwpIHtcbiAgICAgICAgaWYgKCFnKVxuICAgICAgICAgIHJldHVybiBvKCk7XG4gICAgICAgIHcgPyBvKCExLCB3KSA6IHIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBvKCExLCAxZS03KTtcbiAgICAgICAgfSwgMTAwKTtcbiAgICAgIH1cbiAgICAgIGcgPSAhMTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIG4gPSBuZXcgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIodiwge1xuICAgICAgICAuLi5iLFxuICAgICAgICAvLyBIYW5kbGUgPGlmcmFtZT5zXG4gICAgICAgIHJvb3Q6IGkub3duZXJEb2N1bWVudFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICBuID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKHYsIGIpO1xuICAgIH1cbiAgICBuLm9ic2VydmUodCk7XG4gIH1cbiAgcmV0dXJuIG8oITApLCBzO1xufVxuZnVuY3Rpb24gSDIodCwgZSwgbiwgcikge1xuICByID09PSB2b2lkIDAgJiYgKHIgPSB7fSk7XG4gIGNvbnN0IHtcbiAgICBhbmNlc3RvclNjcm9sbDogaSA9ICEwLFxuICAgIGFuY2VzdG9yUmVzaXplOiBzID0gITAsXG4gICAgZWxlbWVudFJlc2l6ZTogbyA9IHR5cGVvZiBSZXNpemVPYnNlcnZlciA9PSBcImZ1bmN0aW9uXCIsXG4gICAgbGF5b3V0U2hpZnQ6IGEgPSB0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT0gXCJmdW5jdGlvblwiLFxuICAgIGFuaW1hdGlvbkZyYW1lOiBsID0gITFcbiAgfSA9IHIsIGMgPSBLTyh0KSwgdSA9IGkgfHwgcyA/IFsuLi5jID8gdWwoYykgOiBbXSwgLi4udWwoZSldIDogW107XG4gIHUuZm9yRWFjaCgoeSkgPT4ge1xuICAgIGkgJiYgeS5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIG4sIHtcbiAgICAgIHBhc3NpdmU6ICEwXG4gICAgfSksIHMgJiYgeS5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIG4pO1xuICB9KTtcbiAgY29uc3QgZCA9IGMgJiYgYSA/IHoyKGMsIG4pIDogbnVsbDtcbiAgbGV0IGYgPSAtMSwgaCA9IG51bGw7XG4gIG8gJiYgKGggPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKHkpID0+IHtcbiAgICBsZXQgW2JdID0geTtcbiAgICBiICYmIGIudGFyZ2V0ID09PSBjICYmIGggJiYgKGgudW5vYnNlcnZlKGUpLCBjYW5jZWxBbmltYXRpb25GcmFtZShmKSwgZiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB2YXIgZztcbiAgICAgIChnID0gaCkgPT0gbnVsbCB8fCBnLm9ic2VydmUoZSk7XG4gICAgfSkpLCBuKCk7XG4gIH0pLCBjICYmICFsICYmIGgub2JzZXJ2ZShjKSwgaC5vYnNlcnZlKGUpKTtcbiAgbGV0IHAsIE8gPSBsID8gVXModCkgOiBudWxsO1xuICBsICYmIG0oKTtcbiAgZnVuY3Rpb24gbSgpIHtcbiAgICBjb25zdCB5ID0gVXModCk7XG4gICAgTyAmJiAoeS54ICE9PSBPLnggfHwgeS55ICE9PSBPLnkgfHwgeS53aWR0aCAhPT0gTy53aWR0aCB8fCB5LmhlaWdodCAhPT0gTy5oZWlnaHQpICYmIG4oKSwgTyA9IHksIHAgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobSk7XG4gIH1cbiAgcmV0dXJuIG4oKSwgKCkgPT4ge1xuICAgIHZhciB5O1xuICAgIHUuZm9yRWFjaCgoYikgPT4ge1xuICAgICAgaSAmJiBiLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgbiksIHMgJiYgYi5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIG4pO1xuICAgIH0pLCBkID09IG51bGwgfHwgZCgpLCAoeSA9IGgpID09IG51bGwgfHwgeS5kaXNjb25uZWN0KCksIGggPSBudWxsLCBsICYmIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHApO1xuICB9O1xufVxuY29uc3QgRjIgPSBRMiwgRzIgPSBUMiwgSzIgPSAodCwgZSwgbikgPT4ge1xuICBjb25zdCByID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgaSA9IHtcbiAgICBwbGF0Zm9ybTogWTIsXG4gICAgLi4ublxuICB9LCBzID0ge1xuICAgIC4uLmkucGxhdGZvcm0sXG4gICAgX2M6IHJcbiAgfTtcbiAgcmV0dXJuIF8yKHQsIGUsIHtcbiAgICAuLi5pLFxuICAgIHBsYXRmb3JtOiBzXG4gIH0pO1xufTtcbmZ1bmN0aW9uIEoyKHQpIHtcbiAgcmV0dXJuIHQgIT0gbnVsbCAmJiB0eXBlb2YgdCA9PSBcIm9iamVjdFwiICYmIFwiJGVsXCIgaW4gdDtcbn1cbmZ1bmN0aW9uIEViKHQpIHtcbiAgaWYgKEoyKHQpKSB7XG4gICAgY29uc3QgZSA9IHQuJGVsO1xuICAgIHJldHVybiBITyhlKSAmJiB1aShlKSA9PT0gXCIjY29tbWVudFwiID8gbnVsbCA6IGU7XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBrdyh0KSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ID4gXCJ1XCIgPyAxIDogKHQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3cpLmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbn1cbmZ1bmN0aW9uICRiKHQsIGUpIHtcbiAgY29uc3QgbiA9IGt3KHQpO1xuICByZXR1cm4gTWF0aC5yb3VuZChlICogbikgLyBuO1xufVxuZnVuY3Rpb24gZVIodCwgZSwgbikge1xuICBuID09PSB2b2lkIDAgJiYgKG4gPSB7fSk7XG4gIGNvbnN0IHIgPSBuLndoaWxlRWxlbWVudHNNb3VudGVkLCBpID0gaigoKSA9PiB7XG4gICAgdmFyIGs7XG4gICAgcmV0dXJuIChrID0gUihuLm9wZW4pKSAhPSBudWxsID8gayA6ICEwO1xuICB9KSwgcyA9IGooKCkgPT4gUihuLm1pZGRsZXdhcmUpKSwgbyA9IGooKCkgPT4ge1xuICAgIHZhciBrO1xuICAgIHJldHVybiAoayA9IFIobi5wbGFjZW1lbnQpKSAhPSBudWxsID8gayA6IFwiYm90dG9tXCI7XG4gIH0pLCBhID0gaigoKSA9PiB7XG4gICAgdmFyIGs7XG4gICAgcmV0dXJuIChrID0gUihuLnN0cmF0ZWd5KSkgIT0gbnVsbCA/IGsgOiBcImFic29sdXRlXCI7XG4gIH0pLCBsID0gaigoKSA9PiB7XG4gICAgdmFyIGs7XG4gICAgcmV0dXJuIChrID0gUihuLnRyYW5zZm9ybSkpICE9IG51bGwgPyBrIDogITA7XG4gIH0pLCBjID0gaigoKSA9PiBFYih0LnZhbHVlKSksIHUgPSBqKCgpID0+IEViKGUudmFsdWUpKSwgZCA9IEcoMCksIGYgPSBHKDApLCBoID0gRyhhLnZhbHVlKSwgcCA9IEcoby52YWx1ZSksIE8gPSBjTyh7fSksIG0gPSBHKCExKSwgeSA9IGooKCkgPT4ge1xuICAgIGNvbnN0IGsgPSB7XG4gICAgICBwb3NpdGlvbjogaC52YWx1ZSxcbiAgICAgIGxlZnQ6IFwiMFwiLFxuICAgICAgdG9wOiBcIjBcIlxuICAgIH07XG4gICAgaWYgKCF1LnZhbHVlKVxuICAgICAgcmV0dXJuIGs7XG4gICAgY29uc3QgXyA9ICRiKHUudmFsdWUsIGQudmFsdWUpLCBUID0gJGIodS52YWx1ZSwgZi52YWx1ZSk7XG4gICAgcmV0dXJuIGwudmFsdWUgPyB7XG4gICAgICAuLi5rLFxuICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZShcIiArIF8gKyBcInB4LCBcIiArIFQgKyBcInB4KVwiLFxuICAgICAgLi4ua3codS52YWx1ZSkgPj0gMS41ICYmIHtcbiAgICAgICAgd2lsbENoYW5nZTogXCJ0cmFuc2Zvcm1cIlxuICAgICAgfVxuICAgIH0gOiB7XG4gICAgICBwb3NpdGlvbjogaC52YWx1ZSxcbiAgICAgIGxlZnQ6IF8gKyBcInB4XCIsXG4gICAgICB0b3A6IFQgKyBcInB4XCJcbiAgICB9O1xuICB9KTtcbiAgbGV0IGI7XG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgYy52YWx1ZSA9PSBudWxsIHx8IHUudmFsdWUgPT0gbnVsbCB8fCBLMihjLnZhbHVlLCB1LnZhbHVlLCB7XG4gICAgICBtaWRkbGV3YXJlOiBzLnZhbHVlLFxuICAgICAgcGxhY2VtZW50OiBvLnZhbHVlLFxuICAgICAgc3RyYXRlZ3k6IGEudmFsdWVcbiAgICB9KS50aGVuKChrKSA9PiB7XG4gICAgICBkLnZhbHVlID0gay54LCBmLnZhbHVlID0gay55LCBoLnZhbHVlID0gay5zdHJhdGVneSwgcC52YWx1ZSA9IGsucGxhY2VtZW50LCBPLnZhbHVlID0gay5taWRkbGV3YXJlRGF0YSwgbS52YWx1ZSA9ICEwO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIHYoKSB7XG4gICAgdHlwZW9mIGIgPT0gXCJmdW5jdGlvblwiICYmIChiKCksIGIgPSB2b2lkIDApO1xuICB9XG4gIGZ1bmN0aW9uIFMoKSB7XG4gICAgaWYgKHYoKSwgciA9PT0gdm9pZCAwKSB7XG4gICAgICBnKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjLnZhbHVlICE9IG51bGwgJiYgdS52YWx1ZSAhPSBudWxsKSB7XG4gICAgICBiID0gcihjLnZhbHVlLCB1LnZhbHVlLCBnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gdygpIHtcbiAgICBpLnZhbHVlIHx8IChtLnZhbHVlID0gITEpO1xuICB9XG4gIHJldHVybiBodChbcywgbywgYV0sIGcsIHtcbiAgICBmbHVzaDogXCJzeW5jXCJcbiAgfSksIGh0KFtjLCB1XSwgUywge1xuICAgIGZsdXNoOiBcInN5bmNcIlxuICB9KSwgaHQoaSwgdywge1xuICAgIGZsdXNoOiBcInN5bmNcIlxuICB9KSwgUmwoKSAmJiB0Tyh2KSwge1xuICAgIHg6IERuKGQpLFxuICAgIHk6IERuKGYpLFxuICAgIHN0cmF0ZWd5OiBEbihoKSxcbiAgICBwbGFjZW1lbnQ6IERuKHApLFxuICAgIG1pZGRsZXdhcmVEYXRhOiBEbihPKSxcbiAgICBpc1Bvc2l0aW9uZWQ6IERuKG0pLFxuICAgIGZsb2F0aW5nU3R5bGVzOiB5LFxuICAgIHVwZGF0ZTogZ1xuICB9O1xufVxudmFyIEpPID0ge307XG4vKiFcbiAqIGNvbnRlbnQtdHlwZVxuICogQ29weXJpZ2h0KGMpIDIwMTUgRG91Z2xhcyBDaHJpc3RvcGhlciBXaWxzb25cbiAqIE1JVCBMaWNlbnNlZFxuICovXG52YXIgUWIgPSAvOyAqKFshIyQlJicqKy5eX2B8fjAtOUEtWmEtei1dKykgKj0gKihcIig/OltcXHUwMDBiXFx1MDAyMFxcdTAwMjFcXHUwMDIzLVxcdTAwNWJcXHUwMDVkLVxcdTAwN2VcXHUwMDgwLVxcdTAwZmZdfFxcXFxbXFx1MDAwYlxcdTAwMjAtXFx1MDBmZl0pKlwifFshIyQlJicqKy5eX2B8fjAtOUEtWmEtei1dKykgKi9nLCB0UiA9IC9eW1xcdTAwMGJcXHUwMDIwLVxcdTAwN2VcXHUwMDgwLVxcdTAwZmZdKyQvLCB4dyA9IC9eWyEjJCUmJyorLl5fYHx+MC05QS1aYS16LV0rJC8sIG5SID0gL1xcXFwoW1xcdTAwMGJcXHUwMDIwLVxcdTAwZmZdKS9nLCByUiA9IC8oW1xcXFxcIl0pL2csIFB3ID0gL15bISMkJSYnKisuXl9gfH4wLTlBLVphLXotXStcXC9bISMkJSYnKisuXl9gfH4wLTlBLVphLXotXSskLztcbkpPLmZvcm1hdCA9IGlSO1xuSk8ucGFyc2UgPSBzUjtcbmZ1bmN0aW9uIGlSKHQpIHtcbiAgaWYgKCF0IHx8IHR5cGVvZiB0ICE9IFwib2JqZWN0XCIpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImFyZ3VtZW50IG9iaiBpcyByZXF1aXJlZFwiKTtcbiAgdmFyIGUgPSB0LnBhcmFtZXRlcnMsIG4gPSB0LnR5cGU7XG4gIGlmICghbiB8fCAhUHcudGVzdChuKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCB0eXBlXCIpO1xuICB2YXIgciA9IG47XG4gIGlmIChlICYmIHR5cGVvZiBlID09IFwib2JqZWN0XCIpXG4gICAgZm9yICh2YXIgaSwgcyA9IE9iamVjdC5rZXlzKGUpLnNvcnQoKSwgbyA9IDA7IG8gPCBzLmxlbmd0aDsgbysrKSB7XG4gICAgICBpZiAoaSA9IHNbb10sICF4dy50ZXN0KGkpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiaW52YWxpZCBwYXJhbWV0ZXIgbmFtZVwiKTtcbiAgICAgIHIgKz0gXCI7IFwiICsgaSArIFwiPVwiICsgYVIoZVtpXSk7XG4gICAgfVxuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIHNSKHQpIHtcbiAgaWYgKCF0KVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJhcmd1bWVudCBzdHJpbmcgaXMgcmVxdWlyZWRcIik7XG4gIHZhciBlID0gdHlwZW9mIHQgPT0gXCJvYmplY3RcIiA/IG9SKHQpIDogdDtcbiAgaWYgKHR5cGVvZiBlICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImFyZ3VtZW50IHN0cmluZyBpcyByZXF1aXJlZCB0byBiZSBhIHN0cmluZ1wiKTtcbiAgdmFyIG4gPSBlLmluZGV4T2YoXCI7XCIpLCByID0gbiAhPT0gLTEgPyBlLnNsaWNlKDAsIG4pLnRyaW0oKSA6IGUudHJpbSgpO1xuICBpZiAoIVB3LnRlc3QocikpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgbWVkaWEgdHlwZVwiKTtcbiAgdmFyIGkgPSBuZXcgbFIoci50b0xvd2VyQ2FzZSgpKTtcbiAgaWYgKG4gIT09IC0xKSB7XG4gICAgdmFyIHMsIG8sIGE7XG4gICAgZm9yIChRYi5sYXN0SW5kZXggPSBuOyBvID0gUWIuZXhlYyhlKTsgKSB7XG4gICAgICBpZiAoby5pbmRleCAhPT0gbilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcGFyYW1ldGVyIGZvcm1hdFwiKTtcbiAgICAgIG4gKz0gb1swXS5sZW5ndGgsIHMgPSBvWzFdLnRvTG93ZXJDYXNlKCksIGEgPSBvWzJdLCBhLmNoYXJDb2RlQXQoMCkgPT09IDM0ICYmIChhID0gYS5zbGljZSgxLCAtMSksIGEuaW5kZXhPZihcIlxcXFxcIikgIT09IC0xICYmIChhID0gYS5yZXBsYWNlKG5SLCBcIiQxXCIpKSksIGkucGFyYW1ldGVyc1tzXSA9IGE7XG4gICAgfVxuICAgIGlmIChuICE9PSBlLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJpbnZhbGlkIHBhcmFtZXRlciBmb3JtYXRcIik7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5mdW5jdGlvbiBvUih0KSB7XG4gIHZhciBlO1xuICBpZiAodHlwZW9mIHQuZ2V0SGVhZGVyID09IFwiZnVuY3Rpb25cIiA/IGUgPSB0LmdldEhlYWRlcihcImNvbnRlbnQtdHlwZVwiKSA6IHR5cGVvZiB0LmhlYWRlcnMgPT0gXCJvYmplY3RcIiAmJiAoZSA9IHQuaGVhZGVycyAmJiB0LmhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0pLCB0eXBlb2YgZSAhPSBcInN0cmluZ1wiKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjb250ZW50LXR5cGUgaGVhZGVyIGlzIG1pc3NpbmcgZnJvbSBvYmplY3RcIik7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gYVIodCkge1xuICB2YXIgZSA9IFN0cmluZyh0KTtcbiAgaWYgKHh3LnRlc3QoZSkpXG4gICAgcmV0dXJuIGU7XG4gIGlmIChlLmxlbmd0aCA+IDAgJiYgIXRSLnRlc3QoZSkpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImludmFsaWQgcGFyYW1ldGVyIHZhbHVlXCIpO1xuICByZXR1cm4gJ1wiJyArIGUucmVwbGFjZShyUiwgXCJcXFxcJDFcIikgKyAnXCInO1xufVxuZnVuY3Rpb24gbFIodCkge1xuICB0aGlzLnBhcmFtZXRlcnMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgdGhpcy50eXBlID0gdDtcbn1cbnZhciBjUiA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgdVIgPSAodCwgZSwgbikgPT4gZSBpbiB0ID8gY1IodCwgZSwgeyBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwLCB2YWx1ZTogbiB9KSA6IHRbZV0gPSBuLCBfdyA9ICh0LCBlLCBuKSA9PiAodVIodCwgdHlwZW9mIGUgIT0gXCJzeW1ib2xcIiA/IGUgKyBcIlwiIDogZSwgbiksIG4pO1xuY29uc3QgZFIgPSBgLyogYmFzaWMgdGhlbWUgKi9cbjpyb290IHtcbiAgLS1zY2FsYXItdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XG4gIC0tc2NhbGFyLXRleHQtZGVjb3JhdGlvbi1ob3ZlcjogdW5kZXJsaW5lO1xufVxuLmxpZ2h0LW1vZGUsXG4ubGlnaHQtbW9kZSAuZGFyay1tb2RlIHtcbiAgLS1zY2FsYXItYmFja2dyb3VuZC0xOiAjZjlmOWY5O1xuICAtLXNjYWxhci1iYWNrZ3JvdW5kLTI6ICNmMWYxZjE7XG4gIC0tc2NhbGFyLWJhY2tncm91bmQtMzogI2U3ZTdlNztcbiAgLS1zY2FsYXItYmFja2dyb3VuZC1jYXJkOiAjZmZmO1xuXG4gIC0tc2NhbGFyLWNvbG9yLTE6ICMyYTJmNDU7XG4gIC0tc2NhbGFyLWNvbG9yLTI6ICM3NTc1NzU7XG4gIC0tc2NhbGFyLWNvbG9yLTM6ICM4ZThlOGU7XG5cbiAgLS1zY2FsYXItY29sb3ItYWNjZW50OiB2YXIoLS1zY2FsYXItY29sb3ItMSk7XG4gIC0tc2NhbGFyLWJhY2tncm91bmQtYWNjZW50OiB2YXIoLS1zY2FsYXItYmFja2dyb3VuZC0zKTtcblxuICAtLXNjYWxhci1ib3JkZXItY29sb3I6IHJnYmEoMCwgMCwgMCwgMC4xKTtcbiAgLS1zY2FsYXItY29kZS1sYW5ndWFnZXMtYmFja2dyb3VuZC1zdXBlcnNlZGU6IHZhcigtLXNjYWxhci1iYWNrZ3JvdW5kLTEpO1xuICAtLXNjYWxhci1jb2RlLWxhbmd1YWdlLWNvbG9yLXN1cGVyc2VkZTogdmFyKC0tc2NhbGFyLWNvbG9yLTEpO1xufVxuLmRhcmstbW9kZSB7XG4gIC0tc2NhbGFyLWJhY2tncm91bmQtMTogIzEzMTMxMztcbiAgLS1zY2FsYXItYmFja2dyb3VuZC0yOiAjMWQxZDFkO1xuICAtLXNjYWxhci1iYWNrZ3JvdW5kLTM6ICMyNzI3Mjc7XG4gIC0tc2NhbGFyLWJhY2tncm91bmQtY2FyZDogIzFkMWQxZDtcblxuICAtLXNjYWxhci1jb2xvci0xOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOSk7XG4gIC0tc2NhbGFyLWNvbG9yLTI6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC42Mik7XG4gIC0tc2NhbGFyLWNvbG9yLTM6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC40NCk7XG5cbiAgLS1zY2FsYXItY29sb3ItYWNjZW50OiB2YXIoLS1zY2FsYXItY29sb3ItMSk7XG4gIC0tc2NhbGFyLWJhY2tncm91bmQtYWNjZW50OiB2YXIoLS1zY2FsYXItYmFja2dyb3VuZC0zKTtcblxuICAtLXNjYWxhci1ib3JkZXItY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4xKTtcbiAgLS1zY2FsYXItY29kZS1sYW5ndWFnZXMtYmFja2dyb3VuZC1zdXBlcnNlZGU6IHZhcigtLXNjYWxhci1iYWNrZ3JvdW5kLTMpO1xuICAtLXNjYWxhci1jb2RlLWxhbmd1YWdlLWNvbG9yLXN1cGVyc2VkZTogdmFyKC0tc2NhbGFyLWNvbG9yLTMpO1xufVxuLyogRG9jdW1lbnQgU2lkZWJhciAqL1xuLmxpZ2h0LW1vZGUgLnQtZG9jX19zaWRlYmFyLFxuLmRhcmstbW9kZSAudC1kb2NfX3NpZGViYXIge1xuICAtLXNjYWxhci1zaWRlYmFyLWJhY2tncm91bmQtMTogdmFyKC0tc2NhbGFyLWJhY2tncm91bmQtMSk7XG4gIC0tc2NhbGFyLXNpZGViYXItY29sb3ItMTogdmFyKC0tc2NhbGFyLWNvbG9yLTEpO1xuICAtLXNjYWxhci1zaWRlYmFyLWNvbG9yLTI6IHZhcigtLXNjYWxhci1jb2xvci0yKTtcbiAgLS1zY2FsYXItc2lkZWJhci1ib3JkZXItY29sb3I6IHZhcigtLXNjYWxhci1ib3JkZXItY29sb3IpO1xuXG4gIC0tc2NhbGFyLXNpZGViYXItaXRlbS1ob3Zlci1iYWNrZ3JvdW5kOiB2YXIoLS1zY2FsYXItYmFja2dyb3VuZC0yKTtcbiAgLS1zY2FsYXItc2lkZWJhci1pdGVtLWhvdmVyLWNvbG9yOiBjdXJyZW50Q29sb3I7XG5cbiAgLS1zY2FsYXItc2lkZWJhci1pdGVtLWFjdGl2ZS1iYWNrZ3JvdW5kOiB2YXIoLS1zY2FsYXItYmFja2dyb3VuZC1hY2NlbnQpO1xuICAtLXNjYWxhci1zaWRlYmFyLWNvbG9yLWFjdGl2ZTogdmFyKC0tc2NhbGFyLWNvbG9yLWFjY2VudCk7XG5cbiAgLS1zY2FsYXItc2lkZWJhci1zZWFyY2gtYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gIC0tc2NhbGFyLXNpZGViYXItc2VhcmNoLWNvbG9yOiB2YXIoLS1zY2FsYXItY29sb3ItMyk7XG4gIC0tc2NhbGFyLXNpZGViYXItc2VhcmNoLWJvcmRlci1jb2xvcjogdmFyKC0tc2NhbGFyLWJvcmRlci1jb2xvcik7XG5cbiAgLS1zY2FsYXItc2lkZWJhci1pbmRlbnQtYm9yZGVyOiB2YXIoLS1zY2FsYXItc2lkZWJhci1ib3JkZXItY29sb3IpO1xuICAtLXNjYWxhci1zaWRlYmFyLWluZGVudC1ib3JkZXItaG92ZXI6IHZhcigtLXNjYWxhci1zaWRlYmFyLWJvcmRlci1jb2xvcik7XG4gIC0tc2NhbGFyLXNpZGViYXItaW5kZW50LWJvcmRlci1hY3RpdmU6IHZhcigtLXNjYWxhci1zaWRlYmFyLWJvcmRlci1jb2xvcik7XG59XG4vKiBhZHZhbmNlZCAqL1xuLmxpZ2h0LW1vZGUgLmRhcmstbW9kZSxcbi5saWdodC1tb2RlIHtcbiAgLS1zY2FsYXItY29sb3ItZ3JlZW46ICMwNjkwNjE7XG4gIC0tc2NhbGFyLWNvbG9yLXJlZDogI2VmMDAwNjtcbiAgLS1zY2FsYXItY29sb3IteWVsbG93OiAjZWRiZTIwO1xuICAtLXNjYWxhci1jb2xvci1ibHVlOiAjMDA4MmQwO1xuICAtLXNjYWxhci1jb2xvci1vcmFuZ2U6ICNmYjg5MmM7XG4gIC0tc2NhbGFyLWNvbG9yLXB1cnBsZTogIzUyMDNkMTtcblxuICAtLXNjYWxhci1idXR0b24tMTogcmdiYSgwLCAwLCAwLCAxKTtcbiAgLS1zY2FsYXItYnV0dG9uLTEtaG92ZXI6IHJnYmEoMCwgMCwgMCwgMC44KTtcbiAgLS1zY2FsYXItYnV0dG9uLTEtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC45KTtcbn1cbi5kYXJrLW1vZGUge1xuICAtLXNjYWxhci1jb2xvci1ncmVlbjogIzAwYjY0ODtcbiAgLS1zY2FsYXItY29sb3ItcmVkOiAjZGQyZjJjO1xuICAtLXNjYWxhci1jb2xvci15ZWxsb3c6ICNmZmM5MGQ7XG4gIC0tc2NhbGFyLWNvbG9yLWJsdWU6ICM0ZWIzZWM7XG4gIC0tc2NhbGFyLWNvbG9yLW9yYW5nZTogI2ZmOGQ0ZDtcbiAgLS1zY2FsYXItY29sb3ItcHVycGxlOiAjYjE5MWY5O1xuXG4gIC0tc2NhbGFyLWJ1dHRvbi0xOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDEpO1xuICAtLXNjYWxhci1idXR0b24tMS1ob3ZlcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjkpO1xuICAtLXNjYWxhci1idXR0b24tMS1jb2xvcjogYmxhY2s7XG59XG5cbi5jb2RlLWxhbmd1YWdlcy1iYWNrZ3JvdW5kOmJlZm9yZSB7XG4gIGJveC1zaGFkb3c6IGluc2V0IDAgMCAwIDFweCB2YXIoLS1zY2FsYXItYm9yZGVyLWNvbG9yKSAhaW1wb3J0YW50O1xufVxuLnNjYWxhci1hcGktY2xpZW50X19pdGVtLFxuLnNjYWxhci1jYXJkLFxuLmRhcmstbW9kZSAuZGFyay1tb2RlLnNjYWxhci1jYXJkIHtcbiAgLS1zY2FsYXItYmFja2dyb3VuZC0xOiB2YXIoLS1zY2FsYXItYmFja2dyb3VuZC1jYXJkKTtcbiAgLS1zY2FsYXItYmFja2dyb3VuZC0yOiB2YXIoLS1zY2FsYXItYmFja2dyb3VuZC0xKTtcbiAgLS1zY2FsYXItYmFja2dyb3VuZC0zOiB2YXIoLS1zY2FsYXItYmFja2dyb3VuZC0xKTtcbn1cbi5kYXJrLW1vZGUgLmRhcmstbW9kZS5zY2FsYXItY2FyZCB7XG4gIC0tc2NhbGFyLWJhY2tncm91bmQtMzogdmFyKC0tc2NhbGFyLWJhY2tncm91bmQtMyk7XG59XG4udC1kb2NfX3NpZGViYXIge1xuICAtLXNjYWxhci1jb2xvci1ncmVlbjogdmFyKC0tc2NhbGFyLWNvbG9yLTEpO1xuICAtLXNjYWxhci1jb2xvci1yZWQ6IHZhcigtLXNjYWxhci1jb2xvci0xKTtcbiAgLS1zY2FsYXItY29sb3IteWVsbG93OiB2YXIoLS1zY2FsYXItY29sb3ItMSk7XG4gIC0tc2NhbGFyLWNvbG9yLWJsdWU6IHZhcigtLXNjYWxhci1jb2xvci0xKTtcbiAgLS1zY2FsYXItY29sb3Itb3JhbmdlOiB2YXIoLS1zY2FsYXItY29sb3ItMSk7XG4gIC0tc2NhbGFyLWNvbG9yLXB1cnBsZTogdmFyKC0tc2NhbGFyLWNvbG9yLTEpO1xufVxuYCwgZlIgPSBgLyogYmFzaWMgdGhlbWUgKi9cbjpyb290IHtcbiAgLS1zY2FsYXItdGV4dC1kZWNvcmF0aW9uOiB1bmRlcmxpbmU7XG4gIC0tc2NhbGFyLXRleHQtZGVjb3JhdGlvbi1ob3ZlcjogdW5kZXJsaW5lO1xufVxuLmxpZ2h0LW1vZGUge1xuICAtLXNjYWxhci1iYWNrZ3JvdW5kLTE6ICNmMGYyZjU7XG4gIC0tc2NhbGFyLWJhY2tncm91bmQtMjogI2VhZWNmMDtcbiAgLS1zY2FsYXItYmFja2dyb3VuZC0zOiAjZTBlMmU2O1xuICAtLXNjYWxhci1ib3JkZXItY29sb3I6IHJnYigyMjgsIDIyOCwgMjMxKTtcblxuICAtLXNjYWxhci1jb2xvci0xOiByZ2IoOSwgOSwgMTEpO1xuICAtLXNjYWxhci1jb2xvci0yOiByZ2IoMTEzLCAxMTMsIDEyMik7XG4gIC0tc2NhbGFyLWNvbG9yLTM6IHJnYmEoMjUsIDI1LCAyOCwgMC41KTtcblxuICAtLXNjYWxhci1jb2xvci1hY2NlbnQ6IHZhcigtLXNjYWxhci1jb2xvci0xKTtcbiAgLS1zY2FsYXItYmFja2dyb3VuZC1hY2NlbnQ6ICM4YWI0ZjgxZjtcblxuICAtLXNjYWxhci1jb2RlLWxhbmd1YWdlLWNvbG9yLXN1cGVyc2VkZTogdmFyKC0tc2NhbGFyLWNvbG9yLTEpO1xufVxuLmxpZ2h0LW1vZGUgLnNjYWxhci1jYXJkLmRhcmstbW9kZSxcbi5kYXJrLW1vZGUge1xuICAtLXNjYWxhci1iYWNrZ3JvdW5kLTE6ICMwMDBlMjM7XG4gIC0tc2NhbGFyLWJhY2tncm91bmQtMjogIzAxMTMyZTtcbiAgLS1zY2FsYXItYmFja2dyb3VuZC0zOiAjMDMxOTNiO1xuICAtLXNjYWxhci1ib3JkZXItY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4xMik7XG5cbiAgLS1zY2FsYXItY29sb3ItMTogI2ZhZmFmYTtcbiAgLS1zY2FsYXItY29sb3ItMjogcmdiKDE2MSwgMTYxLCAxNzApO1xuICAtLXNjYWxhci1jb2xvci0zOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNTMzKTtcblxuICAtLXNjYWxhci1jb2xvci1hY2NlbnQ6IHZhcigtLXNjYWxhci1jb2xvci0xKTtcbiAgLS1zY2FsYXItYmFja2dyb3VuZC1hY2NlbnQ6ICM4YWI0ZjgxZjtcblxuICAtLXNjYWxhci1jb2RlLWxhbmd1YWdlLWNvbG9yLXN1cGVyc2VkZTogdmFyKC0tc2NhbGFyLWNvbG9yLTEpO1xufVxuLyogRG9jdW1lbnQgU2lkZWJhciAqL1xuLmxpZ2h0LW1vZGUgLnQtZG9jX19zaWRlYmFyLFxuLmRhcmstbW9kZSAudC1kb2NfX3NpZGViYXIge1xuICAtLXNjYWxhci1zaWRlYmFyLWJhY2tncm91bmQtMTogdmFyKC0tc2NhbGFyLWJhY2tncm91bmQtMSk7XG4gIC0tc2NhbGFyLXNpZGViYXItY29sb3ItMTogdmFyKC0tc2NhbGFyLWNvbG9yLTEpO1xuICAtLXNjYWxhci1zaWRlYmFyLWNvbG9yLTI6IHZhcigtLXNjYWxhci1jb2xvci0yKTtcbiAgLS1zY2FsYXItc2lkZWJhci1ib3JkZXItY29sb3I6IHZhcigtLXNjYWxhci1ib3JkZXItY29sb3IpO1xuXG4gIC0tc2NhbGFyLXNpZGViYXItaXRlbS1ob3Zlci1iYWNrZ3JvdW5kOiB2YXIoLS1zY2FsYXItYmFja2dyb3VuZC0yKTtcbiAgLS1zY2FsYXItc2lkZWJhci1pdGVtLWhvdmVyLWNvbG9yOiBjdXJyZW50Q29sb3I7XG5cbiAgLS1zY2FsYXItc2lkZWJhci1pdGVtLWFjdGl2ZS1iYWNrZ3JvdW5kOiB2YXIoLS1zY2FsYXItYmFja2dyb3VuZC0zKTtcbiAgLS1zY2FsYXItc2lkZWJhci1jb2xvci1hY3RpdmU6IHZhcigtLXNjYWxhci1jb2xvci1hY2NlbnQpO1xuXG4gIC0tc2NhbGFyLXNpZGViYXItc2VhcmNoLWJhY2tncm91bmQ6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4xKTtcbiAgLS1zY2FsYXItc2lkZWJhci1zZWFyY2gtYm9yZGVyLWNvbG9yOiB2YXIoLS1zY2FsYXItYm9yZGVyLWNvbG9yKTtcbiAgLS1zY2FsYXItc2lkZWJhci1zZWFyY2gtY29sb3I6IHZhcigtLXNjYWxhci1jb2xvci0zKTtcbiAgei1pbmRleDogMTtcbn1cbi5saWdodC1tb2RlIC50LWRvY19fc2lkZWJhciB7XG4gIC0tc2NhbGFyLXNpZGViYXItc2VhcmNoLWJhY2tncm91bmQ6IHdoaXRlO1xufVxuLyogYWR2YW5jZWQgKi9cbi5saWdodC1tb2RlIHtcbiAgLS1zY2FsYXItY29sb3ItZ3JlZW46ICMwNjkwNjE7XG4gIC0tc2NhbGFyLWNvbG9yLXJlZDogI2VmMDAwNjtcbiAgLS1zY2FsYXItY29sb3IteWVsbG93OiAjZWRiZTIwO1xuICAtLXNjYWxhci1jb2xvci1ibHVlOiAjMDA4MmQwO1xuICAtLXNjYWxhci1jb2xvci1vcmFuZ2U6ICNmYjg5MmM7XG4gIC0tc2NhbGFyLWNvbG9yLXB1cnBsZTogIzUyMDNkMTtcblxuICAtLXNjYWxhci1idXR0b24tMTogcmdiYSgwLCAwLCAwLCAxKTtcbiAgLS1zY2FsYXItYnV0dG9uLTEtaG92ZXI6IHJnYmEoMCwgMCwgMCwgMC44KTtcbiAgLS1zY2FsYXItYnV0dG9uLTEtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC45KTtcbn1cbi5kYXJrLW1vZGUge1xuICAtLXNjYWxhci1jb2xvci1ncmVlbjogcmdiYSg2OSwgMjU1LCAxNjUsIDAuODIzKTtcbiAgLS1zY2FsYXItY29sb3ItcmVkOiAjZmY4NTg5O1xuICAtLXNjYWxhci1jb2xvci15ZWxsb3c6ICNmZmNjNGQ7XG4gIC0tc2NhbGFyLWNvbG9yLWJsdWU6ICM2YmMxZmU7XG4gIC0tc2NhbGFyLWNvbG9yLW9yYW5nZTogI2Y5ODk0MztcbiAgLS1zY2FsYXItY29sb3ItcHVycGxlOiAjYjE5MWY5O1xuXG4gIC0tc2NhbGFyLWJ1dHRvbi0xOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDEpO1xuICAtLXNjYWxhci1idXR0b24tMS1ob3ZlcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjkpO1xuICAtLXNjYWxhci1idXR0b24tMS1jb2xvcjogYmxhY2s7XG59XG4vKiBDdXN0b20gdGhlbWUgKi9cbi8qIERvY3VtZW50IGhlYWRlciAqL1xuQGtleWZyYW1lcyBoZWFkZXJiYWNrZ3JvdW5kIHtcbiAgZnJvbSB7XG4gICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gICAgYmFja2Ryb3AtZmlsdGVyOiBub25lO1xuICB9XG4gIHRvIHtcbiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1oZWFkZXItYmFja2dyb3VuZC0xKTtcbiAgICBiYWNrZHJvcC1maWx0ZXI6IGJsdXIoMTJweCk7XG4gIH1cbn1cbi5kYXJrLW1vZGUgaDIudC1lZGl0b3JfX2hlYWRpbmcsXG4uZGFyay1tb2RlIC50LWVkaXRvcl9fcGFnZS10aXRsZSBoMSxcbi5kYXJrLW1vZGUgaDEuc2VjdGlvbi1oZWFkZXIsXG4uZGFyay1tb2RlIC5tYXJrZG93biBoMSxcbi5kYXJrLW1vZGUgLm1hcmtkb3duIGgyLFxuLmRhcmstbW9kZSAubWFya2Rvd24gaDMsXG4uZGFyay1tb2RlIC5tYXJrZG93biBoNCxcbi5kYXJrLW1vZGUgLm1hcmtkb3duIGg1LFxuLmRhcmstbW9kZSAubWFya2Rvd24gaDYge1xuICAtd2Via2l0LXRleHQtZmlsbC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gIGJhY2tncm91bmQtaW1hZ2U6IGxpbmVhci1ncmFkaWVudChcbiAgICB0byByaWdodCBib3R0b20sXG4gICAgcmdiKDI1NSwgMjU1LCAyNTUpIDMwJSxcbiAgICByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMzgpXG4gICk7XG4gIC13ZWJraXQtYmFja2dyb3VuZC1jbGlwOiB0ZXh0O1xuICBiYWNrZ3JvdW5kLWNsaXA6IHRleHQ7XG59XG4uY29kZS1sYW5ndWFnZXMtYmFja2dyb3VuZCB7XG4gIGJhY2tncm91bmQ6IHZhcigtLXNjYWxhci1iYWNrZ3JvdW5kLTEpICFpbXBvcnRhbnQ7XG59XG4uY29kZS1sYW5ndWFnZXMtYmFja2dyb3VuZDpiZWZvcmUge1xuICBib3gtc2hhZG93OiBpbnNldCAwIDAgMCAycHggdmFyKC0tc2NhbGFyLWJvcmRlci1jb2xvcik7XG4gIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudChcbiAgICB0byByaWdodCB0b3AsXG4gICAgcmdiKDIxMSAyMjUgMjQ5IC8gMTIlKSxcbiAgICByZ2IoMjA5IDIyMyAyNDcgLyAxMSUpLFxuICAgIHJnYigyMjMgMjMzIDI1MSAvIDI5JSlcbiAgKSAhaW1wb3J0YW50O1xufVxuLmxpZ2h0LW1vZGUgLmNvZGUtbGFuZ3VhZ2VzLWJhY2tncm91bmQ6YmVmb3JlIHtcbiAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KFxuICAgIHRvIHJpZ2h0IHRvcCxcbiAgICByZ2IoMCAwIDAgLyA4JSksXG4gICAgcmdiKDAgMCAwIC8gNyUpLFxuICAgIHJnYigwIDAgMCAvIDE5JSlcbiAgKSAhaW1wb3J0YW50O1xufVxuLmNvZGUtbGFuZ3VhZ2VzX19hY3RpdmUgLmNvZGUtbGFuZ3VhZ2VzLWJhY2tncm91bmQ6YmVmb3JlIHtcbiAgYmFja2dyb3VuZDogdmFyKC0tc2NhbGFyLWJhY2tncm91bmQtMSkgIWltcG9ydGFudDtcbn1cbi5jb2RlLWxhbmd1YWdlcyBzcGFuIHtcbiAgbWFyZ2luLXRvcDogNXB4ICFpbXBvcnRhbnQ7XG59XG4vKiBIZXJvIFNlY3Rpb24gRmxhcmUgKi9cbi5zZWN0aW9uLWZsYXJlLWl0ZW06bnRoLW9mLXR5cGUoMSkge1xuICAtLWMxOiAjZmZmZmZmO1xuICAtLWMyOiAjYmFiZmQ4O1xuICAtLWMzOiAjMmU4YmIyO1xuICAtLWM0OiAjMWE4NTkzO1xuICAtLWM1OiAjMGExNDNlO1xuICAtLWM2OiAjMGEwZjUyO1xuICAtLWM3OiAjMjM0MWI4O1xuXG4gIC0tc29saWQ6IHZhcigtLWMxKSwgdmFyKC0tYzIpLCB2YXIoLS1jMyksIHZhcigtLWM0KSwgdmFyKC0tYzUpLCB2YXIoLS1jNiksXG4gICAgdmFyKC0tYzcpO1xuICAtLXNvbGlkLXdyYXA6IHZhcigtLXNvbGlkKSwgdmFyKC0tYzEpO1xuICAtLXRyYW5zOiB2YXIoLS1jMSksIHRyYW5zcGFyZW50LCB2YXIoLS1jMiksIHRyYW5zcGFyZW50LCB2YXIoLS1jMyksXG4gICAgdHJhbnNwYXJlbnQsIHZhcigtLWM0KSwgdHJhbnNwYXJlbnQsIHZhcigtLWM1KSwgdHJhbnNwYXJlbnQsIHZhcigtLWM2KSxcbiAgICB0cmFuc3BhcmVudCwgdmFyKC0tYzcpO1xuICAtLXRyYW5zLXdyYXA6IHZhcigtLXRyYW5zKSwgdHJhbnNwYXJlbnQsIHZhcigtLWMxKTtcblxuICBiYWNrZ3JvdW5kOiByYWRpYWwtZ3JhZGllbnQoY2lyY2xlLCB2YXIoLS10cmFucykpLFxuICAgIGNvbmljLWdyYWRpZW50KGZyb20gMTgwZGVnLCB2YXIoLS10cmFucy13cmFwKSksXG4gICAgcmFkaWFsLWdyYWRpZW50KGNpcmNsZSwgdmFyKC0tdHJhbnMpKSwgY29uaWMtZ3JhZGllbnQodmFyKC0tc29saWQtd3JhcCkpO1xuICB3aWR0aDogNzB2dztcbiAgaGVpZ2h0OiA3MDBweDtcbiAgYm9yZGVyLXJhZGl1czogNTAlO1xuICBmaWx0ZXI6IGJsdXIoMTAwcHgpO1xuICB6LWluZGV4OiAwO1xuICByaWdodDogMDtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0cmFuc2Zvcm06IHJvdGF0ZSgtNDVkZWcpO1xuICB0b3A6IC0zMDBweDtcbiAgb3BhY2l0eTogMC4zO1xufVxuLnNlY3Rpb24tZmxhcmUtaXRlbTpudGgtb2YtdHlwZSgzKSB7XG4gIC0tc3Rhci1jb2xvcjogIzZiOWFjYztcbiAgLS1zdGFyLWNvbG9yMjogIzQ0NmI4ZDtcbiAgLS1zdGFyLWNvbG9yMzogIzNlNTg3OTtcbiAgYmFja2dyb3VuZC1pbWFnZTogcmFkaWFsLWdyYWRpZW50KFxuICAgICAgMnB4IDJweCBhdCAyMHB4IDMwcHgsXG4gICAgICB2YXIoLS1zdGFyLWNvbG9yMiksXG4gICAgICByZ2JhKDAsIDAsIDAsIDApXG4gICAgKSxcbiAgICByYWRpYWwtZ3JhZGllbnQoMnB4IDJweCBhdCA0MHB4IDcwcHgsIHZhcigtLXN0YXItY29sb3IpLCByZ2JhKDAsIDAsIDAsIDApKSxcbiAgICByYWRpYWwtZ3JhZGllbnQoMnB4IDJweCBhdCA1MHB4IDE2MHB4LCB2YXIoLS1zdGFyLWNvbG9yMyksIHJnYmEoMCwgMCwgMCwgMCkpLFxuICAgIHJhZGlhbC1ncmFkaWVudCgycHggMnB4IGF0IDkwcHggNDBweCwgdmFyKC0tc3Rhci1jb2xvciksIHJnYmEoMCwgMCwgMCwgMCkpLFxuICAgIHJhZGlhbC1ncmFkaWVudCgycHggMnB4IGF0IDEzMHB4IDgwcHgsIHZhcigtLXN0YXItY29sb3IpLCByZ2JhKDAsIDAsIDAsIDApKSxcbiAgICByYWRpYWwtZ3JhZGllbnQoXG4gICAgICAycHggMnB4IGF0IDE2MHB4IDEyMHB4LFxuICAgICAgdmFyKC0tc3Rhci1jb2xvcjMpLFxuICAgICAgcmdiYSgwLCAwLCAwLCAwKVxuICAgICk7XG4gIGJhY2tncm91bmQtcmVwZWF0OiByZXBlYXQ7XG4gIGJhY2tncm91bmQtc2l6ZTogMjAwcHggMjAwcHg7XG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IDEwMCU7XG4gIG1hc2staW1hZ2U6IHJhZGlhbC1ncmFkaWVudChlbGxpcHNlIGF0IDEwMCUgMCUsIGJsYWNrIDQwJSwgdHJhbnNwYXJlbnQgNzAlKTtcbn1cbi5zZWN0aW9uLWZsYXJlIHtcbiAgdG9wOiAtMTUwcHggIWltcG9ydGFudDtcbiAgaGVpZ2h0OiAxMDB2aDtcbiAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KCMwMDAsIHZhcigtLXNjYWxhci1iYWNrZ3JvdW5kLTEpKTtcbiAgd2lkdGg6IDEwMHZ3O1xufVxuLmxpZ2h0LW1vZGUgLnNlY3Rpb24tZmxhcmUge1xuICBkaXNwbGF5OiBub25lO1xufVxuLmxpZ2h0LW1vZGUgLnNjYWxhci1jYXJkIHtcbiAgLS1zY2FsYXItYmFja2dyb3VuZC0xOiAjZmZmO1xuICAtLXNjYWxhci1iYWNrZ3JvdW5kLTI6ICNmZmY7XG4gIC0tc2NhbGFyLWJhY2tncm91bmQtMzogI2ZmZjtcbn1cbmAsIGhSID0gYC8qIGJhc2ljIHRoZW1lICovXG46cm9vdCB7XG4gIC0tc2NhbGFyLXRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lO1xuICAtLXNjYWxhci10ZXh0LWRlY29yYXRpb24taG92ZXI6IHVuZGVybGluZTtcbn1cbi5saWdodC1tb2RlIHtcbiAgLS1zY2FsYXItY29sb3ItMTogcmdiKDksIDksIDExKTtcbiAgLS1zY2FsYXItY29sb3ItMjogcmdiKDExMywgMTEzLCAxMjIpO1xuICAtLXNjYWxhci1jb2xvci0zOiByZ2JhKDI1LCAyNSwgMjgsIDAuNSk7XG4gIC0tc2NhbGFyLWNvbG9yLWFjY2VudDogdmFyKC0tc2NhbGFyLWNvbG9yLTEpO1xuXG4gIC0tc2NhbGFyLWJhY2tncm91bmQtMTogI2ZmZjtcbiAgLS1zY2FsYXItYmFja2dyb3VuZC0yOiAjZjRmNGY1O1xuICAtLXNjYWxhci1iYWNrZ3JvdW5kLTM6ICNlM2UzZTY7XG4gIC0tc2NhbGFyLWJhY2tncm91bmQtYWNjZW50OiAjOGFiNGY4MWY7XG5cbiAgLS1zY2FsYXItYm9yZGVyLWNvbG9yOiByZ2IoMjI4LCAyMjgsIDIzMSk7XG4gIC0tc2NhbGFyLWNvZGUtbGFuZ3VhZ2UtY29sb3Itc3VwZXJzZWRlOiB2YXIoLS1zY2FsYXItY29sb3ItMSk7XG59XG4uZGFyay1tb2RlIHtcbiAgLS1zY2FsYXItY29sb3ItMTogI2ZhZmFmYTtcbiAgLS1zY2FsYXItY29sb3ItMjogcmdiKDE2MSwgMTYxLCAxNzApO1xuICAtLXNjYWxhci1jb2xvci0zOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNTMzKTtcbiAgLS1zY2FsYXItY29sb3ItYWNjZW50OiB2YXIoLS1zY2FsYXItY29sb3ItMSk7XG5cbiAgLS1zY2FsYXItYmFja2dyb3VuZC0xOiAjMDkwOTBiO1xuICAtLXNjYWxhci1iYWNrZ3JvdW5kLTI6ICMxODE4MWI7XG4gIC0tc2NhbGFyLWJhY2tncm91bmQtMzogIzJjMmMzMDtcbiAgLS1zY2FsYXItYmFja2dyb3VuZC1hY2NlbnQ6ICM4YWI0ZjgxZjtcblxuICAtLXNjYWxhci1ib3JkZXItY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4xMik7XG4gIC0tc2NhbGFyLWNvZGUtbGFuZ3VhZ2UtY29sb3Itc3VwZXJzZWRlOiB2YXIoLS1zY2FsYXItY29sb3ItMSk7XG59XG5cbi8qIERvY3VtZW50IFNpZGViYXIgKi9cbi5saWdodC1tb2RlIC50LWRvY19fc2lkZWJhcixcbi5kYXJrLW1vZGUgLnQtZG9jX19zaWRlYmFyIHtcbiAgLS1zY2FsYXItc2lkZWJhci1iYWNrZ3JvdW5kLTE6IHZhcigtLXNjYWxhci1iYWNrZ3JvdW5kLTEpO1xuICAtLXNjYWxhci1zaWRlYmFyLWNvbG9yLTE6IHZhcigtLXNjYWxhci1jb2xvci0xKTtcbiAgLS1zY2FsYXItc2lkZWJhci1jb2xvci0yOiB2YXIoLS1zY2FsYXItY29sb3ItMik7XG4gIC0tc2NhbGFyLXNpZGViYXItYm9yZGVyLWNvbG9yOiB2YXIoLS1zY2FsYXItYm9yZGVyLWNvbG9yKTtcblxuICAtLXNjYWxhci1zaWRlYmFyLWl0ZW0taG92ZXItY29sb3I6IGN1cnJlbnRDb2xvcjtcbiAgLS1zY2FsYXItc2lkZWJhci1pdGVtLWhvdmVyLWJhY2tncm91bmQ6IHZhcigtLXNjYWxhci1iYWNrZ3JvdW5kLTIpO1xuXG4gIC0tc2NhbGFyLXNpZGViYXItaXRlbS1hY3RpdmUtYmFja2dyb3VuZDogdmFyKC0tc2NhbGFyLWJhY2tncm91bmQtMyk7XG4gIC0tc2NhbGFyLXNpZGViYXItY29sb3ItYWN0aXZlOiB2YXIoLS1zY2FsYXItY29sb3ItYWNjZW50KTtcblxuICAtLXNjYWxhci1zaWRlYmFyLXNlYXJjaC1iYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbiAgLS1zY2FsYXItc2lkZWJhci1zZWFyY2gtYm9yZGVyLWNvbG9yOiB2YXIoLS1zY2FsYXItYm9yZGVyLWNvbG9yKTtcbiAgLS1zY2FsYXItc2lkZWJhci1zZWFyY2gtY29sb3I6IHZhcigtLXNjYWxhci1jb2xvci0zKTtcbn1cbi5saWdodC1tb2RlIC50LWRvY19fc2lkZWJhciB7XG4gIC0tc2NhbGFyLXNpZGViYXItaXRlbS1hY3RpdmUtYmFja2dyb3VuZDogIzA5MDkwYjtcbiAgLS1zY2FsYXItc2lkZWJhci1jb2xvci1hY3RpdmU6IHZhcigtLXNjYWxhci1zaWRlYmFyLWJhY2tncm91bmQtMSk7XG59XG4vKiBhZHZhbmNlZCAqL1xuLmxpZ2h0LW1vZGUge1xuICAtLXNjYWxhci1jb2xvci1ncmVlbjogIzA2OTA2MTtcbiAgLS1zY2FsYXItY29sb3ItcmVkOiAjZWYwMDA2O1xuICAtLXNjYWxhci1jb2xvci15ZWxsb3c6ICNlZGJlMjA7XG4gIC0tc2NhbGFyLWNvbG9yLWJsdWU6ICMwMDgyZDA7XG4gIC0tc2NhbGFyLWNvbG9yLW9yYW5nZTogI2ZiODkyYztcbiAgLS1zY2FsYXItY29sb3ItcHVycGxlOiAjNTIwM2QxO1xuXG4gIC0tc2NhbGFyLWJ1dHRvbi0xOiByZ2JhKDAsIDAsIDAsIDEpO1xuICAtLXNjYWxhci1idXR0b24tMS1ob3ZlcjogcmdiYSgwLCAwLCAwLCAwLjgpO1xuICAtLXNjYWxhci1idXR0b24tMS1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjkpO1xufVxuLmRhcmstbW9kZSB7XG4gIC0tc2NhbGFyLWNvbG9yLWdyZWVuOiByZ2JhKDY5LCAyNTUsIDE2NSwgMC44MjMpO1xuICAtLXNjYWxhci1jb2xvci1yZWQ6ICNmZjg1ODk7XG4gIC0tc2NhbGFyLWNvbG9yLXllbGxvdzogI2ZmY2M0ZDtcbiAgLS1zY2FsYXItY29sb3ItYmx1ZTogIzZiYzFmZTtcbiAgLS1zY2FsYXItY29sb3Itb3JhbmdlOiAjZjk4OTQzO1xuICAtLXNjYWxhci1jb2xvci1wdXJwbGU6ICNiMTkxZjk7XG5cbiAgLS1zY2FsYXItYnV0dG9uLTE6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMSk7XG4gIC0tc2NhbGFyLWJ1dHRvbi0xLWhvdmVyOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOSk7XG4gIC0tc2NhbGFyLWJ1dHRvbi0xLWNvbG9yOiBibGFjaztcbn1cbi8qIEN1c3RvbSB0aGVtZSAqL1xuLmRhcmstbW9kZSBoMi50LWVkaXRvcl9faGVhZGluZyxcbi5kYXJrLW1vZGUgLnQtZWRpdG9yX19wYWdlLXRpdGxlIGgxLFxuLmRhcmstbW9kZSBoMS5zZWN0aW9uLWhlYWRlcixcbi5kYXJrLW1vZGUgLm1hcmtkb3duIGgxLFxuLmRhcmstbW9kZSAubWFya2Rvd24gaDIsXG4uZGFyay1tb2RlIC5tYXJrZG93biBoMyxcbi5kYXJrLW1vZGUgLm1hcmtkb3duIGg0LFxuLmRhcmstbW9kZSAubWFya2Rvd24gaDUsXG4uZGFyay1tb2RlIC5tYXJrZG93biBoNiB7XG4gIC13ZWJraXQtdGV4dC1maWxsLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgYmFja2dyb3VuZC1pbWFnZTogbGluZWFyLWdyYWRpZW50KFxuICAgIHRvIHJpZ2h0IGJvdHRvbSxcbiAgICByZ2IoMjU1LCAyNTUsIDI1NSkgMzAlLFxuICAgIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4zOClcbiAgKTtcbiAgLXdlYmtpdC1iYWNrZ3JvdW5kLWNsaXA6IHRleHQ7XG4gIGJhY2tncm91bmQtY2xpcDogdGV4dDtcbn1cbi5leGFtcGxlcyAuc2NhbGFyLWNhcmQtZm9vdGVyIHtcbiAgLS1zY2FsYXItYmFja2dyb3VuZC0zOiB0cmFuc3BhcmVudDtcbiAgcGFkZGluZy10b3A6IDA7XG59XG4uY29kZS1sYW5ndWFnZXMtYmFja2dyb3VuZCB7XG4gIGJhY2tncm91bmQ6IHZhcigtLXNjYWxhci1iYWNrZ3JvdW5kLTEpICFpbXBvcnRhbnQ7XG59XG4uY29kZS1sYW5ndWFnZXMtYmFja2dyb3VuZDpiZWZvcmUge1xuICBib3gtc2hhZG93OiBpbnNldCAwIDAgMCAycHggdmFyKC0tc2NhbGFyLWJvcmRlci1jb2xvcik7XG4gIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudChcbiAgICB0byByaWdodCB0b3AsXG4gICAgcmdiKDIxMSAyMjUgMjQ5IC8gMTIlKSxcbiAgICByZ2IoMjA5IDIyMyAyNDcgLyAxMSUpLFxuICAgIHJnYigyMjMgMjMzIDI1MSAvIDI5JSlcbiAgKSAhaW1wb3J0YW50O1xufVxuLmxpZ2h0LW1vZGUgLmNvZGUtbGFuZ3VhZ2VzLWJhY2tncm91bmQ6YmVmb3JlIHtcbiAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KFxuICAgIHRvIHJpZ2h0IHRvcCxcbiAgICByZ2IoMCAwIDAgLyA4JSksXG4gICAgcmdiKDAgMCAwIC8gNyUpLFxuICAgIHJnYigwIDAgMCAvIDE5JSlcbiAgKSAhaW1wb3J0YW50O1xufVxuLmNvZGUtbGFuZ3VhZ2VzX19hY3RpdmUgLmNvZGUtbGFuZ3VhZ2VzLWJhY2tncm91bmQ6YmVmb3JlIHtcbiAgYmFja2dyb3VuZDogdmFyKC0tc2NhbGFyLWJhY2tncm91bmQtMSkgIWltcG9ydGFudDtcbn1cbi5jb2RlLWxhbmd1YWdlcyBzcGFuIHtcbiAgbWFyZ2luLXRvcDogNXB4ICFpbXBvcnRhbnQ7XG59XG4vKiBIZXJvIHNlY3Rpb24gZmxhcmUgKi9cbi5zZWN0aW9uLWZsYXJlIHtcbiAgd2lkdGg6IDEwMHZ3O1xuICBoZWlnaHQ6IDU1MHB4O1xuICBwb3NpdGlvbjogcmVsYXRpdmU7XG59XG4uc2VjdGlvbi1mbGFyZS1pdGVtOm50aC1vZi10eXBlKDEpIHtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB3aWR0aDogMTAwdnc7XG4gIGhlaWdodDogNTUwcHg7XG4gIC0tc3RyaXBlc0Rhcms6IHJlcGVhdGluZy1saW5lYXItZ3JhZGllbnQoXG4gICAgMTAwZGVnLFxuICAgICMwMDAgMCUsXG4gICAgIzAwMCA3JSxcbiAgICB0cmFuc3BhcmVudCAxMCUsXG4gICAgdHJhbnNwYXJlbnQgMTIlLFxuICAgICMwMDAgMTYlXG4gICk7XG4gIC0tcmFpbmJvdzogcmVwZWF0aW5nLWxpbmVhci1ncmFkaWVudChcbiAgICAxMDBkZWcsXG4gICAgI2ZmZiAxMCUsXG4gICAgI2ZmZiAxNiUsXG4gICAgI2ZmZiAyMiUsXG4gICAgI2ZmZiAzMCVcbiAgKTtcbiAgYmFja2dyb3VuZC1pbWFnZTogdmFyKC0tc3RyaXBlc0RhcmspLCB2YXIoLS1yYWluYm93KTtcbiAgYmFja2dyb3VuZC1zaXplOiAzMDAlLCAyMDAlO1xuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOlxuICAgIDUwJSA1MCUsXG4gICAgNTAlIDUwJTtcbiAgZmlsdGVyOiBpbnZlcnQoMTAwJSk7XG4gIC13ZWJraXQtbWFzay1pbWFnZTogcmFkaWFsLWdyYWRpZW50KFxuICAgIGVsbGlwc2UgYXQgMTAwJSAwJSxcbiAgICBibGFjayA0MCUsXG4gICAgdHJhbnNwYXJlbnQgNzAlXG4gICk7XG4gIG1hc2staW1hZ2U6IHJhZGlhbC1ncmFkaWVudChlbGxpcHNlIGF0IDEwMCUgMCUsIGJsYWNrIDQwJSwgdHJhbnNwYXJlbnQgNzAlKTtcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gIG9wYWNpdHk6IDAuMDc7XG59XG4uZGFyay1tb2RlIC5zZWN0aW9uLWZsYXJlLWl0ZW06bnRoLW9mLXR5cGUoMSkge1xuICBiYWNrZ3JvdW5kLWltYWdlOiB2YXIoLS1zdHJpcGVzRGFyayksIHZhcigtLXJhaW5ib3cpO1xuICBmaWx0ZXI6IG9wYWNpdHkoNTAlKSBzYXR1cmF0ZSgyMDAlKTtcbiAgb3BhY2l0eTogMC4yNTtcbiAgaGVpZ2h0OiAzNTBweDtcbn1cbi5zZWN0aW9uLWZsYXJlLWl0ZW06bnRoLW9mLXR5cGUoMSk6YWZ0ZXIge1xuICBjb250ZW50OiAnJztcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0b3A6IDA7XG4gIHJpZ2h0OiAwO1xuICBib3R0b206IDA7XG4gIGxlZnQ6IDA7XG4gIGJhY2tncm91bmQtaW1hZ2U6IHZhcigtLXN0cmlwZXNEYXJrKSwgdmFyKC0tcmFpbmJvdyk7XG4gIGJhY2tncm91bmQtc2l6ZTogMjAwJSwgMTAwJTtcbiAgYmFja2dyb3VuZC1hdHRhY2htZW50OiBmaXhlZDtcbiAgbWl4LWJsZW5kLW1vZGU6IGRpZmZlcmVuY2U7XG59XG4uZGFyay1tb2RlIC5zZWN0aW9uLWZsYXJlOmFmdGVyIHtcbiAgYmFja2dyb3VuZC1pbWFnZTogdmFyKC0tc3RyaXBlc0RhcmspLCB2YXIoLS1yYWluYm93KTtcbn1cbi5zZWN0aW9uLWZsYXJlLWl0ZW06bnRoLW9mLXR5cGUoMikge1xuICAtLXN0YXItY29sb3I6ICNmZmY7XG4gIC0tc3Rhci1jb2xvcjI6ICNmZmY7XG4gIC0tc3Rhci1jb2xvcjM6ICNmZmY7XG4gIHdpZHRoOiAxMDAlO1xuICBoZWlnaHQ6IDEwMCU7XG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgYmFja2dyb3VuZC1pbWFnZTogcmFkaWFsLWdyYWRpZW50KFxuICAgICAgMnB4IDJweCBhdCAyMHB4IDMwcHgsXG4gICAgICB2YXIoLS1zdGFyLWNvbG9yMiksXG4gICAgICByZ2JhKDAsIDAsIDAsIDApXG4gICAgKSxcbiAgICByYWRpYWwtZ3JhZGllbnQoMnB4IDJweCBhdCA0MHB4IDcwcHgsIHZhcigtLXN0YXItY29sb3IpLCByZ2JhKDAsIDAsIDAsIDApKSxcbiAgICByYWRpYWwtZ3JhZGllbnQoMnB4IDJweCBhdCA1MHB4IDE2MHB4LCB2YXIoLS1zdGFyLWNvbG9yMyksIHJnYmEoMCwgMCwgMCwgMCkpLFxuICAgIHJhZGlhbC1ncmFkaWVudCgycHggMnB4IGF0IDkwcHggNDBweCwgdmFyKC0tc3Rhci1jb2xvciksIHJnYmEoMCwgMCwgMCwgMCkpLFxuICAgIHJhZGlhbC1ncmFkaWVudCgycHggMnB4IGF0IDEzMHB4IDgwcHgsIHZhcigtLXN0YXItY29sb3IpLCByZ2JhKDAsIDAsIDAsIDApKSxcbiAgICByYWRpYWwtZ3JhZGllbnQoXG4gICAgICAycHggMnB4IGF0IDE2MHB4IDEyMHB4LFxuICAgICAgdmFyKC0tc3Rhci1jb2xvcjMpLFxuICAgICAgcmdiYSgwLCAwLCAwLCAwKVxuICAgICk7XG4gIGJhY2tncm91bmQtcmVwZWF0OiByZXBlYXQ7XG4gIGJhY2tncm91bmQtc2l6ZTogMjAwcHggMjAwcHg7XG4gIG1hc2staW1hZ2U6IHJhZGlhbC1ncmFkaWVudChlbGxpcHNlIGF0IDEwMCUgMCUsIGJsYWNrIDQwJSwgdHJhbnNwYXJlbnQgNzAlKTtcbiAgb3BhY2l0eTogMC4yO1xufVxuYCwgVHcgPSBgLyogYmFzaWMgdGhlbWUgKi9cbi5saWdodC1tb2RlIHtcbiAgLS1zY2FsYXItYmFja2dyb3VuZC0xOiAjZmZmO1xuICAtLXNjYWxhci1iYWNrZ3JvdW5kLTI6ICNmNmY2ZjY7XG4gIC0tc2NhbGFyLWJhY2tncm91bmQtMzogI2U3ZTdlNztcbiAgLS1zY2FsYXItYmFja2dyb3VuZC1hY2NlbnQ6ICM4YWI0ZjgxZjtcblxuICAtLXNjYWxhci1jb2xvci0xOiAjMmEyZjQ1O1xuICAtLXNjYWxhci1jb2xvci0yOiAjNzU3NTc1O1xuICAtLXNjYWxhci1jb2xvci0zOiAjOGU4ZThlO1xuXG4gIC0tc2NhbGFyLWNvbG9yLWFjY2VudDogIzAwOTlmZjtcbiAgLS1zY2FsYXItYm9yZGVyLWNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuMSk7XG59XG4uZGFyay1tb2RlIHtcbiAgLS1zY2FsYXItYmFja2dyb3VuZC0xOiAjMGYwZjBmO1xuICAtLXNjYWxhci1iYWNrZ3JvdW5kLTI6ICMxYTFhMWE7XG4gIC0tc2NhbGFyLWJhY2tncm91bmQtMzogIzI3MjcyNztcblxuICAtLXNjYWxhci1jb2xvci0xOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOSk7XG4gIC0tc2NhbGFyLWNvbG9yLTI6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC42Mik7XG4gIC0tc2NhbGFyLWNvbG9yLTM6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC40NCk7XG5cbiAgLS1zY2FsYXItY29sb3ItYWNjZW50OiAjM2VhNmZmO1xuICAtLXNjYWxhci1iYWNrZ3JvdW5kLWFjY2VudDogIzNlYTZmZjFmO1xuXG4gIC0tc2NhbGFyLWJvcmRlci1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEpO1xufVxuLyogRG9jdW1lbnQgU2lkZWJhciAqL1xuLmxpZ2h0LW1vZGUgLnQtZG9jX19zaWRlYmFyLFxuLmRhcmstbW9kZSAudC1kb2NfX3NpZGViYXIge1xuICAtLXNjYWxhci1zaWRlYmFyLWJhY2tncm91bmQtMTogdmFyKC0tc2NhbGFyLWJhY2tncm91bmQtMSk7XG4gIC0tc2NhbGFyLXNpZGViYXItY29sb3ItMTogdmFyKC0tc2NhbGFyLWNvbG9yLTEpO1xuICAtLXNjYWxhci1zaWRlYmFyLWNvbG9yLTI6IHZhcigtLXNjYWxhci1jb2xvci0yKTtcbiAgLS1zY2FsYXItc2lkZWJhci1ib3JkZXItY29sb3I6IHZhcigtLXNjYWxhci1ib3JkZXItY29sb3IpO1xuXG4gIC0tc2NhbGFyLXNpZGViYXItaXRlbS1ob3Zlci1iYWNrZ3JvdW5kOiB2YXIoLS1zY2FsYXItYmFja2dyb3VuZC0yKTtcbiAgLS1zY2FsYXItc2lkZWJhci1pdGVtLWhvdmVyLWNvbG9yOiBjdXJyZW50Q29sb3I7XG5cbiAgLS1zY2FsYXItc2lkZWJhci1pdGVtLWFjdGl2ZS1iYWNrZ3JvdW5kOiB2YXIoLS1zY2FsYXItYmFja2dyb3VuZC0yKTtcbiAgLS1zY2FsYXItc2lkZWJhci1jb2xvci1hY3RpdmU6IHZhcigtLXNjYWxhci1jb2xvci0xKTtcblxuICAtLXNjYWxhci1zaWRlYmFyLXNlYXJjaC1iYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbiAgLS1zY2FsYXItc2lkZWJhci1zZWFyY2gtY29sb3I6IHZhcigtLXNjYWxhci1jb2xvci0zKTtcbiAgLS1zY2FsYXItc2lkZWJhci1zZWFyY2gtYm9yZGVyLWNvbG9yOiB2YXIoLS1zY2FsYXItYm9yZGVyLWNvbG9yKTtcbn1cblxuLyogYWR2YW5jZWQgKi9cbi5saWdodC1tb2RlIHtcbiAgLS1zY2FsYXItY29sb3ItZ3JlZW46ICMwNjkwNjE7XG4gIC0tc2NhbGFyLWNvbG9yLXJlZDogI2VmMDAwNjtcbiAgLS1zY2FsYXItY29sb3IteWVsbG93OiAjZWRiZTIwO1xuICAtLXNjYWxhci1jb2xvci1ibHVlOiAjMDA4MmQwO1xuICAtLXNjYWxhci1jb2xvci1vcmFuZ2U6ICNmYjg5MmM7XG4gIC0tc2NhbGFyLWNvbG9yLXB1cnBsZTogIzUyMDNkMTtcblxuICAtLXNjYWxhci1idXR0b24tMTogcmdiYSgwLCAwLCAwLCAxKTtcbiAgLS1zY2FsYXItYnV0dG9uLTEtaG92ZXI6IHJnYmEoMCwgMCwgMCwgMC44KTtcbiAgLS1zY2FsYXItYnV0dG9uLTEtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC45KTtcbn1cbi5kYXJrLW1vZGUge1xuICAtLXNjYWxhci1jb2xvci1ncmVlbjogIzAwYjY0ODtcbiAgLS1zY2FsYXItY29sb3ItcmVkOiAjZGMxYjE5O1xuICAtLXNjYWxhci1jb2xvci15ZWxsb3c6ICNmZmM5MGQ7XG4gIC0tc2NhbGFyLWNvbG9yLWJsdWU6ICM0ZWIzZWM7XG4gIC0tc2NhbGFyLWNvbG9yLW9yYW5nZTogI2ZmOGQ0ZDtcbiAgLS1zY2FsYXItY29sb3ItcHVycGxlOiAjYjE5MWY5O1xuXG4gIC0tc2NhbGFyLWJ1dHRvbi0xOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDEpO1xuICAtLXNjYWxhci1idXR0b24tMS1ob3ZlcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjkpO1xuICAtLXNjYWxhci1idXR0b24tMS1jb2xvcjogYmxhY2s7XG59XG5gLCBwUiA9IGAvKiBiYXNpYyB0aGVtZSAqL1xuLmxpZ2h0LW1vZGUge1xuICAtLXNjYWxhci1jb2xvci0xOiAjMmEyZjQ1O1xuICAtLXNjYWxhci1jb2xvci0yOiAjNzU3NTc1O1xuICAtLXNjYWxhci1jb2xvci0zOiAjOGU4ZThlO1xuICAtLXNjYWxhci1jb2xvci1hY2NlbnQ6ICM3MDcwZmY7XG5cbiAgLS1zY2FsYXItYmFja2dyb3VuZC0xOiAjZmZmO1xuICAtLXNjYWxhci1iYWNrZ3JvdW5kLTI6ICNmNmY2ZjY7XG4gIC0tc2NhbGFyLWJhY2tncm91bmQtMzogI2U3ZTdlNztcbiAgLS1zY2FsYXItYmFja2dyb3VuZC1hY2NlbnQ6ICM3MDcwZmYxZjtcblxuICAtLXNjYWxhci1ib3JkZXItY29sb3I6IHJnYmEoMCwgMCwgMCwgMC4xKTtcblxuICAtLXNjYWxhci1jb2RlLWxhbmd1YWdlLWNvbG9yLXN1cGVyc2VkZTogdmFyKC0tc2NhbGFyLWNvbG9yLTMpO1xufVxuLmRhcmstbW9kZSB7XG4gIC0tc2NhbGFyLWNvbG9yLTE6ICNmN2Y4Zjg7XG4gIC0tc2NhbGFyLWNvbG9yLTI6IHJnYigxODAsIDE4OCwgMjA4KTtcbiAgLS1zY2FsYXItY29sb3ItMzogI2I0YmNkMDk5O1xuICAtLXNjYWxhci1jb2xvci1hY2NlbnQ6ICM4MjhmZmY7XG5cbiAgLS1zY2FsYXItYmFja2dyb3VuZC0xOiAjMDAwMjEyO1xuICAtLXNjYWxhci1iYWNrZ3JvdW5kLTI6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4wNSk7XG4gIC0tc2NhbGFyLWJhY2tncm91bmQtMzogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjA5KTtcbiAgLS1zY2FsYXItYmFja2dyb3VuZC1hY2NlbnQ6ICM4YWI0ZjgxZjtcblxuICAtLXNjYWxhci1ib3JkZXItY29sb3I6ICMyNDI1Mzc7XG4gIC0tc2NhbGFyLWNvZGUtbGFuZ3VhZ2UtY29sb3Itc3VwZXJzZWRlOiB2YXIoLS1zY2FsYXItY29sb3ItMyk7XG59XG4vKiBEb2N1bWVudCBTaWRlYmFyICovXG4ubGlnaHQtbW9kZSAudC1kb2NfX3NpZGViYXIge1xuICAtLXNjYWxhci1zaWRlYmFyLWJhY2tncm91bmQtMTogdmFyKC0tc2NhbGFyLWJhY2tncm91bmQtMSk7XG4gIC0tc2NhbGFyLXNpZGViYXItaXRlbS1ob3Zlci1jb2xvcjogY3VycmVudENvbG9yO1xuICAtLXNjYWxhci1zaWRlYmFyLWl0ZW0taG92ZXItYmFja2dyb3VuZDogdmFyKC0tc2NhbGFyLWJhY2tncm91bmQtMik7XG4gIC0tc2NhbGFyLXNpZGViYXItaXRlbS1hY3RpdmUtYmFja2dyb3VuZDogdmFyKC0tc2NhbGFyLWJhY2tncm91bmQtYWNjZW50KTtcbiAgLS1zY2FsYXItc2lkZWJhci1ib3JkZXItY29sb3I6IHZhcigtLXNjYWxhci1ib3JkZXItY29sb3IpO1xuICAtLXNjYWxhci1zaWRlYmFyLWNvbG9yLTE6IHZhcigtLXNjYWxhci1jb2xvci0xKTtcbiAgLS1zY2FsYXItc2lkZWJhci1jb2xvci0yOiB2YXIoLS1zY2FsYXItY29sb3ItMik7XG4gIC0tc2NhbGFyLXNpZGViYXItY29sb3ItYWN0aXZlOiB2YXIoLS1zY2FsYXItY29sb3ItYWNjZW50KTtcbiAgLS1zY2FsYXItc2lkZWJhci1zZWFyY2gtYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjA1KTtcbiAgLS1zY2FsYXItc2lkZWJhci1zZWFyY2gtYm9yZGVyLWNvbG9yOiAxcHggc29saWQgcmdiYSgwLCAwLCAwLCAwLjA1KTtcbiAgLS1zY2FsYXItc2lkZWJhci1zZWFyY2gtY29sb3I6IHZhcigtLXNjYWxhci1jb2xvci0zKTtcbiAgLS1zY2FsYXItYmFja2dyb3VuZC0yOiByZ2JhKDAsIDAsIDAsIDAuMDMpO1xufVxuLmRhcmstbW9kZSAudC1kb2NfX3NpZGViYXIge1xuICAtLXNjYWxhci1zaWRlYmFyLWJhY2tncm91bmQtMTogdmFyKC0tc2NhbGFyLWJhY2tncm91bmQtMSk7XG4gIC0tc2NhbGFyLXNpZGViYXItaXRlbS1ob3Zlci1jb2xvcjogY3VycmVudENvbG9yO1xuICAtLXNjYWxhci1zaWRlYmFyLWl0ZW0taG92ZXItYmFja2dyb3VuZDogdmFyKC0tc2NhbGFyLWJhY2tncm91bmQtMik7XG4gIC0tc2NhbGFyLXNpZGViYXItaXRlbS1hY3RpdmUtYmFja2dyb3VuZDogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEpO1xuICAtLXNjYWxhci1zaWRlYmFyLWJvcmRlci1jb2xvcjogdmFyKC0tc2NhbGFyLWJvcmRlci1jb2xvcik7XG4gIC0tc2NhbGFyLXNpZGViYXItY29sb3ItMTogdmFyKC0tc2NhbGFyLWNvbG9yLTEpO1xuICAtLXNjYWxhci1zaWRlYmFyLWNvbG9yLTI6IHZhcigtLXNjYWxhci1jb2xvci0yKTtcbiAgLS1zY2FsYXItc2lkZWJhci1jb2xvci1hY3RpdmU6IHZhcigtLXNjYWxhci1jb2xvci1hY2NlbnQpO1xuICAtLXNjYWxhci1zaWRlYmFyLXNlYXJjaC1iYWNrZ3JvdW5kOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMSk7XG4gIC0tc2NhbGFyLXNpZGViYXItc2VhcmNoLWJvcmRlci1jb2xvcjogMXB4IHNvbGlkIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4wNSk7XG4gIC0tc2NhbGFyLXNpZGViYXItc2VhcmNoLWNvbG9yOiB2YXIoLS1zY2FsYXItY29sb3ItMyk7XG59XG4vKiBhZHZhbmNlZCAqL1xuLmxpZ2h0LW1vZGUge1xuICAtLXNjYWxhci1jb2xvci1ncmVlbjogIzA2OTA2MTtcbiAgLS1zY2FsYXItY29sb3ItcmVkOiAjZWYwMDA2O1xuICAtLXNjYWxhci1jb2xvci15ZWxsb3c6ICNlZGJlMjA7XG4gIC0tc2NhbGFyLWNvbG9yLWJsdWU6ICMwMDgyZDA7XG4gIC0tc2NhbGFyLWNvbG9yLW9yYW5nZTogI2ZiODkyYztcbiAgLS1zY2FsYXItY29sb3ItcHVycGxlOiAjNTIwM2QxO1xuXG4gIC0tc2NhbGFyLWJ1dHRvbi0xOiByZ2JhKDAsIDAsIDAsIDEpO1xuICAtLXNjYWxhci1idXR0b24tMS1ob3ZlcjogcmdiYSgwLCAwLCAwLCAwLjgpO1xuICAtLXNjYWxhci1idXR0b24tMS1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjkpO1xufVxuLmRhcmstbW9kZSB7XG4gIC0tc2NhbGFyLWNvbG9yLWdyZWVuOiAjMDBiNjQ4O1xuICAtLXNjYWxhci1jb2xvci1yZWQ6ICNkYzFiMTk7XG4gIC0tc2NhbGFyLWNvbG9yLXllbGxvdzogI2ZmYzkwZDtcbiAgLS1zY2FsYXItY29sb3ItYmx1ZTogIzRlYjNlYztcbiAgLS1zY2FsYXItY29sb3Itb3JhbmdlOiAjZmY4ZDRkO1xuICAtLXNjYWxhci1jb2xvci1wdXJwbGU6ICNiMTkxZjk7XG5cbiAgLS1zY2FsYXItYnV0dG9uLTE6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMSk7XG4gIC0tc2NhbGFyLWJ1dHRvbi0xLWhvdmVyOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOSk7XG4gIC0tc2NhbGFyLWJ1dHRvbi0xLWNvbG9yOiBibGFjaztcbn1cbi8qIEN1c3RvbSBUaGVtZSAqL1xuLmRhcmstbW9kZSBoMi50LWVkaXRvcl9faGVhZGluZyxcbi5kYXJrLW1vZGUgLnQtZWRpdG9yX19wYWdlLXRpdGxlIGgxLFxuLmRhcmstbW9kZSBoMS5zZWN0aW9uLWhlYWRlcixcbi5kYXJrLW1vZGUgLm1hcmtkb3duIGgxLFxuLmRhcmstbW9kZSAubWFya2Rvd24gaDIsXG4uZGFyay1tb2RlIC5tYXJrZG93biBoMyxcbi5kYXJrLW1vZGUgLm1hcmtkb3duIGg0LFxuLmRhcmstbW9kZSAubWFya2Rvd24gaDUsXG4uZGFyay1tb2RlIC5tYXJrZG93biBoNiB7XG4gIC13ZWJraXQtdGV4dC1maWxsLWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgYmFja2dyb3VuZC1pbWFnZTogbGluZWFyLWdyYWRpZW50KFxuICAgIHRvIHJpZ2h0IGJvdHRvbSxcbiAgICByZ2IoMjU1LCAyNTUsIDI1NSkgMzAlLFxuICAgIHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4zOClcbiAgKTtcbiAgLXdlYmtpdC1iYWNrZ3JvdW5kLWNsaXA6IHRleHQ7XG4gIGJhY2tncm91bmQtY2xpcDogdGV4dDtcbn1cbi5zaWRlYmFyLXNlYXJjaCB7XG4gIGJhY2tkcm9wLWZpbHRlcjogYmx1cigxMnB4KTtcbn1cbkBrZXlmcmFtZXMgaGVhZGVyYmFja2dyb3VuZCB7XG4gIGZyb20ge1xuICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuICAgIGJhY2tkcm9wLWZpbHRlcjogbm9uZTtcbiAgfVxuICB0byB7XG4gICAgYmFja2dyb3VuZDogdmFyKC0taGVhZGVyLWJhY2tncm91bmQtMSk7XG4gICAgYmFja2Ryb3AtZmlsdGVyOiBibHVyKDEycHgpO1xuICB9XG59XG4uZGFyay1tb2RlIC5zY2FsYXItY2FyZCB7XG4gIGJhY2tncm91bmQ6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4wNSkgIWltcG9ydGFudDtcbn1cbi5kYXJrLW1vZGUgLnNjYWxhci1jYXJkICoge1xuICAtLXNjYWxhci1iYWNrZ3JvdW5kLTI6IHRyYW5zcGFyZW50ICFpbXBvcnRhbnQ7XG4gIC0tc2NhbGFyLWJhY2tncm91bmQtMTogdHJhbnNwYXJlbnQgIWltcG9ydGFudDtcbn1cbi5saWdodC1tb2RlIC5kYXJrLW1vZGUuc2NhbGFyLWNhcmQgKixcbi5saWdodC1tb2RlIC5kYXJrLW1vZGUuc2NhbGFyLWNhcmQge1xuICAtLXNjYWxhci1iYWNrZ3JvdW5kLTE6ICMwZDBmMWUgIWltcG9ydGFudDtcbiAgLS1zY2FsYXItYmFja2dyb3VuZC0yOiAjMGQwZjFlICFpbXBvcnRhbnQ7XG4gIC0tc2NhbGFyLWJhY2tncm91bmQtMzogIzE5MWIyOSAhaW1wb3J0YW50O1xufVxuLmxpZ2h0LW1vZGUgLmRhcmstbW9kZS5zY2FsYXItY2FyZCB7XG4gIGJhY2tncm91bmQ6ICMxOTFiMjkgIWltcG9ydGFudDtcbn1cbi5iYWRnZSB7XG4gIGJveC1zaGFkb3c6IDAgMCAwIDFweCB2YXIoLS1zY2FsYXItYm9yZGVyLWNvbG9yKTtcbiAgbWFyZ2luLXJpZ2h0OiA2cHg7XG59XG5cbi50YWJsZS1yb3cucmVxdWlyZWQtcGFyYW1ldGVyIC50YWJsZS1yb3ctaXRlbTpudGgtb2YtdHlwZSgyKTphZnRlciB7XG4gIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuICBib3gtc2hhZG93OiBub25lO1xufVxuLmNvZGUtbGFuZ3VhZ2VzX19hY3RpdmUge1xuICAtLXNjYWxhci1jb2RlLWxhbmd1YWdlLWNvbG9yLXN1cGVyc2VkZTogdmFyKC0tc2NhbGFyLWNvbG9yLTEpO1xufVxuLmNvZGUtbGFuZ3VhZ2VzLWJhY2tncm91bmQge1xuICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoXG4gICAgcmdiYSgyNTUsIDI1NSwgMjU1LCAwKSAwJSxcbiAgICByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMDUpIDEwMCVcbiAgKSAhaW1wb3J0YW50O1xuICBib3gtc2hhZG93OiBpbnNldCAwIDAgMCAxcHggdmFyKC0tc2NhbGFyLWJvcmRlci1jb2xvcikgIWltcG9ydGFudDtcbn1cbi8qIEhlcm8gU2VjdGlvbiBGbGFyZSAqL1xuLnNlY3Rpb24tZmxhcmUge1xuICB3aWR0aDogMTAwdnc7XG4gIGJhY2tncm91bmQ6IHJhZGlhbC1ncmFkaWVudChcbiAgICBlbGxpcHNlIDgwJSA1MCUgYXQgNTAlIC0yMCUsXG4gICAgcmdiYSgxMjAsIDExOSwgMTk4LCAwLjMpLFxuICAgIHRyYW5zcGFyZW50XG4gICk7XG4gIGhlaWdodDogMTAwdmg7XG59XG5gLCBPUiA9IGAvKiBiYXNpYyB0aGVtZSAqL1xuOnJvb3Qge1xuICAtLXNjYWxhci10ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcbiAgLS1zY2FsYXItdGV4dC1kZWNvcmF0aW9uLWhvdmVyOiB1bmRlcmxpbmU7XG59XG4ubGlnaHQtbW9kZSB7XG4gIC0tc2NhbGFyLWJhY2tncm91bmQtMTogI2Y5ZjZmMDtcbiAgLS1zY2FsYXItYmFja2dyb3VuZC0yOiAjZjJlZmU4O1xuICAtLXNjYWxhci1iYWNrZ3JvdW5kLTM6ICNlOWU3ZTI7XG4gIC0tc2NhbGFyLWJvcmRlci1jb2xvcjogcmdiYSgyMDMsIDE2NSwgMTU2LCAwLjYpO1xuXG4gIC0tc2NhbGFyLWNvbG9yLTE6ICNjNzU1NDk7XG4gIC0tc2NhbGFyLWNvbG9yLTI6ICNjNzU1NDk7XG4gIC0tc2NhbGFyLWNvbG9yLTM6ICNjNzU1NDk7XG5cbiAgLS1zY2FsYXItY29sb3ItYWNjZW50OiAjYzc1NTQ5O1xuICAtLXNjYWxhci1iYWNrZ3JvdW5kLWFjY2VudDogI2RjYmZhODFmO1xuXG4gIC0tc2NhbGFyLWNvZGUtbGFuZ3VhZ2UtY29sb3Itc3VwZXJzZWRlOiB2YXIoLS1zY2FsYXItY29sb3ItMSk7XG59XG4uZGFyay1tb2RlIHtcbiAgLS1zY2FsYXItYmFja2dyb3VuZC0xOiAjMTQwNTA3O1xuICAtLXNjYWxhci1iYWNrZ3JvdW5kLTI6ICMyMDA5MGM7XG4gIC0tc2NhbGFyLWJhY2tncm91bmQtMzogIzMyMTExNjtcbiAgLS1zY2FsYXItYm9yZGVyLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMSk7XG5cbiAgLS1zY2FsYXItY29sb3ItMTogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjkpO1xuICAtLXNjYWxhci1jb2xvci0yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNjIpO1xuICAtLXNjYWxhci1jb2xvci0zOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNDQpO1xuXG4gIC0tc2NhbGFyLWNvbG9yLWFjY2VudDogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjkpO1xuICAtLXNjYWxhci1iYWNrZ3JvdW5kLWFjY2VudDogIzQ0MTMxMztcblxuICAtLXNjYWxhci1jb2RlLWxhbmd1YWdlLWNvbG9yLXN1cGVyc2VkZTogdmFyKC0tc2NhbGFyLWNvbG9yLTEpO1xufVxuXG4vKiBEb2N1bWVudCBTaWRlYmFyICovXG4ubGlnaHQtbW9kZSAudC1kb2NfX3NpZGViYXIsXG4uZGFyay1tb2RlIC50LWRvY19fc2lkZWJhciB7XG4gIC0tc2NhbGFyLXNpZGViYXItYmFja2dyb3VuZC0xOiB2YXIoLS1zY2FsYXItYmFja2dyb3VuZC0xKTtcbiAgLS1zY2FsYXItc2lkZWJhci1jb2xvci0xOiB2YXIoLS1zY2FsYXItY29sb3ItMSk7XG4gIC0tc2NhbGFyLXNpZGViYXItY29sb3ItMjogdmFyKC0tc2NhbGFyLWNvbG9yLTIpO1xuICAtLXNjYWxhci1zaWRlYmFyLWJvcmRlci1jb2xvcjogdmFyKC0tc2NhbGFyLWJvcmRlci1jb2xvcik7XG5cbiAgLS1zY2FsYXItc2lkZWJhci1pdGVtLWhvdmVyLWNvbG9yOiBjdXJyZW50Q29sb3I7XG4gIC0tc2NhbGFyLXNpZGViYXItaXRlbS1ob3Zlci1iYWNrZ3JvdW5kOiB2YXIoLS1zY2FsYXItYmFja2dyb3VuZC0yKTtcblxuICAtLXNjYWxhci1zaWRlYmFyLWl0ZW0tYWN0aXZlLWJhY2tncm91bmQ6IHZhcigtLXNjYWxhci1iYWNrZ3JvdW5kLTMpO1xuICAtLXNjYWxhci1zaWRlYmFyLWNvbG9yLWFjdGl2ZTogdmFyKC0tc2NhbGFyLWNvbG9yLWFjY2VudCk7XG5cbiAgLS1zY2FsYXItc2lkZWJhci1zZWFyY2gtYmFja2dyb3VuZDogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEpO1xuICAtLXNjYWxhci1zaWRlYmFyLXNlYXJjaC1jb2xvcjogdmFyKC0tc2NhbGFyLWNvbG9yLTMpO1xuICAtLXNjYWxhci1zaWRlYmFyLXNlYXJjaC1ib3JkZXItY29sb3I6IHZhcigtLXNjYWxhci1ib3JkZXItY29sb3IpO1xuICB6LWluZGV4OiAxO1xufVxuLyogYWR2YW5jZWQgKi9cbi5saWdodC1tb2RlIHtcbiAgLS1zY2FsYXItY29sb3ItZ3JlZW46ICMwOTUzM2E7XG4gIC0tc2NhbGFyLWNvbG9yLXJlZDogI2FhMTgxZDtcbiAgLS1zY2FsYXItY29sb3IteWVsbG93OiAjYWI4ZDJiO1xuICAtLXNjYWxhci1jb2xvci1ibHVlOiAjMTk2ODlhO1xuICAtLXNjYWxhci1jb2xvci1vcmFuZ2U6ICNiMjZjMzQ7XG4gIC0tc2NhbGFyLWNvbG9yLXB1cnBsZTogIzRjMjE5MTtcblxuICAtLXNjYWxhci1idXR0b24tMTogcmdiYSgwLCAwLCAwLCAxKTtcbiAgLS1zY2FsYXItYnV0dG9uLTEtaG92ZXI6IHJnYmEoMCwgMCwgMCwgMC44KTtcbiAgLS1zY2FsYXItYnV0dG9uLTEtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC45KTtcbn1cbi5kYXJrLW1vZGUge1xuICAtLXNjYWxhci1jb2xvci1ncmVlbjogcmdiYSg2OSwgMjU1LCAxNjUsIDAuODIzKTtcbiAgLS1zY2FsYXItY29sb3ItcmVkOiAjZmY4NTg5O1xuICAtLXNjYWxhci1jb2xvci15ZWxsb3c6ICNmZmNjNGQ7XG4gIC0tc2NhbGFyLWNvbG9yLWJsdWU6ICM2YmMxZmU7XG4gIC0tc2NhbGFyLWNvbG9yLW9yYW5nZTogI2Y5ODk0MztcbiAgLS1zY2FsYXItY29sb3ItcHVycGxlOiAjYjE5MWY5O1xuXG4gIC0tc2NhbGFyLWJ1dHRvbi0xOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDEpO1xuICAtLXNjYWxhci1idXR0b24tMS1ob3ZlcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjkpO1xuICAtLXNjYWxhci1idXR0b24tMS1jb2xvcjogYmxhY2s7XG59XG4vKiBDdXN0b20gVGhlbWUgKi9cbi5kYXJrLW1vZGUgaDIudC1lZGl0b3JfX2hlYWRpbmcsXG4uZGFyay1tb2RlIC50LWVkaXRvcl9fcGFnZS10aXRsZSBoMSxcbi5kYXJrLW1vZGUgaDEuc2VjdGlvbi1oZWFkZXIsXG4uZGFyay1tb2RlIC5tYXJrZG93biBoMSxcbi5kYXJrLW1vZGUgLm1hcmtkb3duIGgyLFxuLmRhcmstbW9kZSAubWFya2Rvd24gaDMsXG4uZGFyay1tb2RlIC5tYXJrZG93biBoNCxcbi5kYXJrLW1vZGUgLm1hcmtkb3duIGg1LFxuLmRhcmstbW9kZSAubWFya2Rvd24gaDYge1xuICAtd2Via2l0LXRleHQtZmlsbC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gIGJhY2tncm91bmQtaW1hZ2U6IGxpbmVhci1ncmFkaWVudChcbiAgICB0byByaWdodCBib3R0b20sXG4gICAgcmdiKDI1NSwgMjU1LCAyNTUpIDMwJSxcbiAgICByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMzgpXG4gICk7XG4gIC13ZWJraXQtYmFja2dyb3VuZC1jbGlwOiB0ZXh0O1xuICBiYWNrZ3JvdW5kLWNsaXA6IHRleHQ7XG59XG4ubGlnaHQtbW9kZSAudC1kb2NfX3NpZGViYXIge1xuICAtLXNjYWxhci1zaWRlYmFyLXNlYXJjaC1iYWNrZ3JvdW5kOiB3aGl0ZTtcbn1cbi5leGFtcGxlcyAuc2NhbGFyLWNhcmQtZm9vdGVyIHtcbiAgLS1zY2FsYXItYmFja2dyb3VuZC0zOiB0cmFuc3BhcmVudDtcbiAgcGFkZGluZy10b3A6IDA7XG59XG4uY29kZS1sYW5ndWFnZXMtYmFja2dyb3VuZCB7XG4gIGJhY2tncm91bmQ6IHZhcigtLXNjYWxhci1iYWNrZ3JvdW5kLTEpICFpbXBvcnRhbnQ7XG59XG4uY29kZS1sYW5ndWFnZXMtYmFja2dyb3VuZDpiZWZvcmUge1xuICBib3gtc2hhZG93OiBpbnNldCAwIDAgMCAycHggdmFyKC0tc2NhbGFyLWJvcmRlci1jb2xvcik7XG4gIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudChcbiAgICB0byByaWdodCB0b3AsXG4gICAgcmdiKDIxMSAyMjUgMjQ5IC8gMTIlKSxcbiAgICByZ2IoMjA5IDIyMyAyNDcgLyAxMSUpLFxuICAgIHJnYigyMjMgMjMzIDI1MSAvIDI5JSlcbiAgKSAhaW1wb3J0YW50O1xufVxuLmxpZ2h0LW1vZGUgLmNvZGUtbGFuZ3VhZ2VzLWJhY2tncm91bmQ6YmVmb3JlIHtcbiAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KFxuICAgIHRvIHJpZ2h0IHRvcCxcbiAgICByZ2IoMCAwIDAgLyA4JSksXG4gICAgcmdiKDAgMCAwIC8gNyUpLFxuICAgIHJnYigwIDAgMCAvIDE5JSlcbiAgKSAhaW1wb3J0YW50O1xufVxuLmNvZGUtbGFuZ3VhZ2VzX19hY3RpdmUgLmNvZGUtbGFuZ3VhZ2VzLWJhY2tncm91bmQ6YmVmb3JlIHtcbiAgYmFja2dyb3VuZDogdmFyKC0tc2NhbGFyLWJhY2tncm91bmQtMSkgIWltcG9ydGFudDtcbn1cblxuLmNvZGUtbGFuZ3VhZ2VzIHNwYW4ge1xuICBtYXJnaW4tdG9wOiA1cHggIWltcG9ydGFudDtcbn1cbi8qIEhlcm8gc2VjdGlvbiBmbGFyZSAqL1xuLnNlY3Rpb24tZmxhcmUtaXRlbTpudGgtb2YtdHlwZSgxKSB7XG4gIGJhY2tncm91bmQ6ICNkMjUwMTk7XG4gIHdpZHRoOiA4MHZ3O1xuICBoZWlnaHQ6IDUwMHB4O1xuICBtYXJnaW4tdG9wOiAtMTUwcHg7XG4gIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgZmlsdGVyOiBibHVyKDEwMHB4KTtcbiAgei1pbmRleDogMDtcbn1cbi5saWdodC1tb2RlIC5zZWN0aW9uLWZsYXJlIHtcbiAgZGlzcGxheTogbm9uZTtcbn1cbi5zZWN0aW9uLWZsYXJlIHtcbiAgdG9wOiAtMTUwcHggIWltcG9ydGFudDtcbiAgaGVpZ2h0OiAxMDB2aDtcbiAgcmlnaHQ6IC00MDBweCAhaW1wb3J0YW50O1xuICBsZWZ0OiBpbml0aWFsO1xufVxuYCwgZ1IgPSBgLmxpZ2h0LW1vZGUge1xuICBjb2xvci1zY2hlbWU6IGxpZ2h0O1xuICAtLXNjYWxhci1jb2xvci0xOiAjMDAwMDAwO1xuICAtLXNjYWxhci1jb2xvci0yOiAjMDAwMDAwO1xuICAtLXNjYWxhci1jb2xvci0zOiAjMDAwMDAwO1xuICAtLXNjYWxhci1jb2xvci1hY2NlbnQ6ICM2NDViMGY7XG4gIC0tc2NhbGFyLWJhY2tncm91bmQtMTogI2NjYzliMztcbiAgLS1zY2FsYXItYmFja2dyb3VuZC0yOiAjYzJiZmFhO1xuICAtLXNjYWxhci1iYWNrZ3JvdW5kLTM6ICNiOGI1YTE7XG4gIC0tc2NhbGFyLWJhY2tncm91bmQtYWNjZW50OiAjMDAwMDAwO1xuXG4gIC0tc2NhbGFyLWJvcmRlci1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjIpO1xuICAtLXNjYWxhci1zY3JvbGxiYXItY29sb3I6IHJnYmEoMCwgMCwgMCwgMC4xOCk7XG4gIC0tc2NhbGFyLXNjcm9sbGJhci1jb2xvci1hY3RpdmU6IHJnYmEoMCwgMCwgMCwgMC4zNik7XG4gIC0tc2NhbGFyLWxpZnRlZC1icmlnaHRuZXNzOiAxO1xuICAtLXNjYWxhci1iYWNrZHJvcC1icmlnaHRuZXNzOiAxO1xuXG4gIC0tc2NhbGFyLXNoYWRvdy0xOiAwIDFweCAzcHggMCByZ2JhKDAsIDAsIDAsIDAuMTEpO1xuICAtLXNjYWxhci1zaGFkb3ctMjogcmdiYSgwLCAwLCAwLCAwLjA4KSAwcHggMTNweCAyMHB4IDBweCxcbiAgICByZ2JhKDAsIDAsIDAsIDAuMDgpIDBweCAzcHggOHB4IDBweCwgdmFyKC0tc2NhbGFyLWJvcmRlci1jb2xvcikgMHB4IDAgMCAxcHg7XG5cbiAgLS1zY2FsYXItYnV0dG9uLTE6IHJnYig0OSA1MyA1Nik7XG4gIC0tc2NhbGFyLWJ1dHRvbi0xLWNvbG9yOiAjZmZmO1xuICAtLXNjYWxhci1idXR0b24tMS1ob3ZlcjogcmdiKDI4IDMxIDMzKTtcblxuICAtLXNjYWxhci1jb2xvci1yZWQ6ICNiOTFjMWM7XG4gIC0tc2NhbGFyLWNvbG9yLW9yYW5nZTogI2ExNjIwNztcbiAgLS1zY2FsYXItY29sb3ItZ3JlZW46ICMwNDc4NTc7XG4gIC0tc2NhbGFyLWNvbG9yLWJsdWU6ICMxZDRlZDg7XG4gIC0tc2NhbGFyLWNvbG9yLW9yYW5nZTogI2MyNDEwYztcbiAgLS1zY2FsYXItY29sb3ItcHVycGxlOiAjNmQyOGQ5O1xuXG4gIC0tc2NhbGFyLWNvZGUtbGFuZ3VhZ2VzLWJhY2tncm91bmQtc3VwZXJzZWRlOiB2YXIoLS1zY2FsYXItYmFja2dyb3VuZC0zKTtcbiAgLS1zY2FsYXItY29kZS1sYW5ndWFnZS1jb2xvci1zdXBlcnNlZGU6IHZhcigtLXNjYWxhci1jb2xvci0xKTtcbn1cblxuLmRhcmstbW9kZSB7XG4gIGNvbG9yLXNjaGVtZTogZGFyaztcbiAgLS1zY2FsYXItY29sb3ItMTogI2ZmZmVmMztcbiAgLS1zY2FsYXItY29sb3ItMjogI2ZmZmVmMztcbiAgLS1zY2FsYXItY29sb3ItMzogI2ZmZmVmMztcbiAgLS1zY2FsYXItY29sb3ItYWNjZW50OiAjYzNiNTMxO1xuICAtLXNjYWxhci1iYWNrZ3JvdW5kLTE6ICMzMTMzMzI7XG4gIC0tc2NhbGFyLWJhY2tncm91bmQtMjogIzM5M2IzYTtcbiAgLS1zY2FsYXItYmFja2dyb3VuZC0zOiAjNDE0MzQyO1xuICAtLXNjYWxhci1iYWNrZ3JvdW5kLWFjY2VudDogI2ZmZmVmMztcblxuICAtLXNjYWxhci1ib3JkZXItY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4xKTtcbiAgLS1zY2FsYXItc2Nyb2xsYmFyLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMjQpO1xuICAtLXNjYWxhci1zY3JvbGxiYXItY29sb3ItYWN0aXZlOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNDgpO1xuICAtLXNjYWxhci1saWZ0ZWQtYnJpZ2h0bmVzczogMS40NTtcbiAgLS1zY2FsYXItYmFja2Ryb3AtYnJpZ2h0bmVzczogMC41O1xuXG4gIC0tc2NhbGFyLXNoYWRvdy0xOiAwIDFweCAzcHggMCByZ2JhKDAsIDAsIDAsIDAuMTEpO1xuICAtLXNjYWxhci1zaGFkb3ctMjogcmdiYSgxNSwgMTUsIDE1LCAwLjIpIDBweCAzcHggNnB4LFxuICAgIHJnYmEoMTUsIDE1LCAxNSwgMC40KSAwcHggOXB4IDI0cHgsIDAgMCAwIDFweCByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMSk7XG5cbiAgLS1zY2FsYXItYnV0dG9uLTE6ICNmNmY2ZjY7XG4gIC0tc2NhbGFyLWJ1dHRvbi0xLWNvbG9yOiAjMDAwO1xuICAtLXNjYWxhci1idXR0b24tMS1ob3ZlcjogI2U3ZTdlNztcblxuICAtLXNjYWxhci1jb2xvci1ncmVlbjogIzAwYjY0ODtcbiAgLS1zY2FsYXItY29sb3ItcmVkOiAjZGMxYjE5O1xuICAtLXNjYWxhci1jb2xvci15ZWxsb3c6ICNmZmM5MGQ7XG4gIC0tc2NhbGFyLWNvbG9yLWJsdWU6ICM0ZWIzZWM7XG4gIC0tc2NhbGFyLWNvbG9yLW9yYW5nZTogI2ZmOGQ0ZDtcbiAgLS1zY2FsYXItY29sb3ItcHVycGxlOiAjYjE5MWY5O1xuXG4gIC0tc2NhbGFyLWNvZGUtbGFuZ3VhZ2VzLWJhY2tncm91bmQtc3VwZXJzZWRlOiB2YXIoLS1zY2FsYXItYmFja2dyb3VuZC0zKTtcbiAgLS1zY2FsYXItY29kZS1sYW5ndWFnZS1jb2xvci1zdXBlcnNlZGU6IHZhcigtLXNjYWxhci1jb2xvci0xKTtcbn1cblxuLyogU2lkZWJhciAqL1xuLmxpZ2h0LW1vZGUgLnQtZG9jX19zaWRlYmFyIHtcbiAgLS1zY2FsYXItc2lkZWJhci1iYWNrZ3JvdW5kLTE6IHZhcigtLXNjYWxhci1iYWNrZ3JvdW5kLTEpO1xuICAtLXNjYWxhci1zaWRlYmFyLWl0ZW0taG92ZXItY29sb3I6IGN1cnJlbnRDb2xvcjtcbiAgLS1zY2FsYXItc2lkZWJhci1pdGVtLWhvdmVyLWJhY2tncm91bmQ6IHZhcigtLXNjYWxhci1iYWNrZ3JvdW5kLTIpO1xuICAtLXNjYWxhci1zaWRlYmFyLWl0ZW0tYWN0aXZlLWJhY2tncm91bmQ6IHZhcigtLXNjYWxhci1iYWNrZ3JvdW5kLWFjY2VudCk7XG4gIC0tc2NhbGFyLXNpZGViYXItYm9yZGVyLWNvbG9yOiB2YXIoLS1zY2FsYXItYm9yZGVyLWNvbG9yKTtcbiAgLS1zY2FsYXItc2lkZWJhci1jb2xvci0xOiB2YXIoLS1zY2FsYXItY29sb3ItMSk7XG4gIC0tc2NhbGFyLXNpZGViYXItY29sb3ItMjogdmFyKC0tc2NhbGFyLWNvbG9yLTIpO1xuICAtLXNjYWxhci1zaWRlYmFyLWNvbG9yLWFjdGl2ZTogdmFyKC0tc2NhbGFyLXNpZGViYXItYmFja2dyb3VuZC0xKTtcbiAgLS1zY2FsYXItc2lkZWJhci1zZWFyY2gtYmFja2dyb3VuZDogdmFyKC0tc2NhbGFyLWJhY2tncm91bmQtMyk7XG4gIC0tc2NhbGFyLXNpZGViYXItc2VhcmNoLWJvcmRlci1jb2xvcjogdmFyKC0tc2NhbGFyLXNpZGViYXItc2VhcmNoLWJhY2tncm91bmQpO1xuICAtLXNjYWxhci1zaWRlYmFyLXNlYXJjaC0tY29sb3I6IHZhcigtLXNjYWxhci1jb2xvci0zKTtcbn1cblxuLmRhcmstbW9kZSAuc2lkZWJhciB7XG4gIC0tc2NhbGFyLXNpZGViYXItYmFja2dyb3VuZC0xOiB2YXIoLS1zY2FsYXItYmFja2dyb3VuZC0xKTtcbiAgLS1zY2FsYXItc2lkZWJhci1pdGVtLWhvdmVyLWNvbG9yOiBjdXJyZW50Q29sb3I7XG4gIC0tc2NhbGFyLXNpZGViYXItaXRlbS1ob3Zlci1iYWNrZ3JvdW5kOiB2YXIoLS1zY2FsYXItYmFja2dyb3VuZC0yKTtcbiAgLS1zY2FsYXItc2lkZWJhci1pdGVtLWFjdGl2ZS1iYWNrZ3JvdW5kOiB2YXIoLS1zY2FsYXItYmFja2dyb3VuZC1hY2NlbnQpO1xuICAtLXNjYWxhci1zaWRlYmFyLWJvcmRlci1jb2xvcjogdmFyKC0tc2NhbGFyLWJvcmRlci1jb2xvcik7XG4gIC0tc2NhbGFyLXNpZGViYXItY29sb3ItMTogdmFyKC0tc2NhbGFyLWNvbG9yLTEpO1xuICAtLXNjYWxhci1zaWRlYmFyLWNvbG9yLTI6IHZhcigtLXNjYWxhci1jb2xvci0yKTtcbiAgLS1zY2FsYXItc2lkZWJhci1jb2xvci1hY3RpdmU6IHZhcigtLXNjYWxhci1zaWRlYmFyLWJhY2tncm91bmQtMSk7XG4gIC0tc2NhbGFyLXNpZGViYXItc2VhcmNoLWJhY2tncm91bmQ6IHZhcigtLXNjYWxhci1iYWNrZ3JvdW5kLTMpO1xuICAtLXNjYWxhci1zaWRlYmFyLXNlYXJjaC1ib3JkZXItY29sb3I6IHZhcigtLXNjYWxhci1zaWRlYmFyLXNlYXJjaC1iYWNrZ3JvdW5kKTtcbiAgLS1zY2FsYXItc2lkZWJhci1zZWFyY2gtLWNvbG9yOiB2YXIoLS1zY2FsYXItY29sb3ItMyk7XG59XG5gLCBtUiA9IGAvKiBiYXNpYyB0aGVtZSAqL1xuLmxpZ2h0LW1vZGUge1xuICAtLXNjYWxhci1iYWNrZ3JvdW5kLTE6ICNmZmY7XG4gIC0tc2NhbGFyLWJhY2tncm91bmQtMjogI2Y1ZjZmODtcbiAgLS1zY2FsYXItYmFja2dyb3VuZC0zOiAjZWNlZWYxO1xuXG4gIC0tc2NhbGFyLWNvbG9yLTE6ICMyYTJmNDU7XG4gIC0tc2NhbGFyLWNvbG9yLTI6ICM3NTc1NzU7XG4gIC0tc2NhbGFyLWNvbG9yLTM6ICM4ZThlOGU7XG5cbiAgLS1zY2FsYXItY29sb3ItYWNjZW50OiAjNTQ2OWQ0O1xuICAtLXNjYWxhci1iYWNrZ3JvdW5kLWFjY2VudDogIzU0NjlkNDFmO1xuXG4gIC0tc2NhbGFyLWJvcmRlci1jb2xvcjogcmdiYSgyMTUsIDIxNSwgMjA2LCAwLjUpO1xufVxuLmRhcmstbW9kZSB7XG4gIC0tc2NhbGFyLWJhY2tncm91bmQtMTogIzE1MTcxYztcbiAgLS1zY2FsYXItYmFja2dyb3VuZC0yOiAjMWMxZTI0O1xuICAtLXNjYWxhci1iYWNrZ3JvdW5kLTM6ICMyMjI1MmI7XG5cbiAgLS1zY2FsYXItY29sb3ItMTogI2ZhZmFmYTtcbiAgLS1zY2FsYXItY29sb3ItMjogI2M5Y2VkODtcbiAgLS1zY2FsYXItY29sb3ItMzogIzhjOTlhZDtcblxuICAtLXNjYWxhci1jb2xvci1hY2NlbnQ6ICM1NDY5ZDQ7XG4gIC0tc2NhbGFyLWJhY2tncm91bmQtYWNjZW50OiAjNTQ2OWQ0MWY7XG5cbiAgLS1zY2FsYXItYm9yZGVyLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMTIpO1xufVxuLyogRG9jdW1lbnQgU2lkZWJhciAqL1xuLmxpZ2h0LW1vZGUgLnQtZG9jX19zaWRlYmFyLFxuLmRhcmstbW9kZSAudC1kb2NfX3NpZGViYXIge1xuICAtLXNjYWxhci1zaWRlYmFyLWJhY2tncm91bmQtMTogdmFyKC0tc2NhbGFyLWJhY2tncm91bmQtMSk7XG4gIC0tc2NhbGFyLXNpZGViYXItY29sb3ItMTogdmFyKC0tc2NhbGFyLWNvbG9yLTEpO1xuICAtLXNjYWxhci1zaWRlYmFyLWNvbG9yLTI6IHZhcigtLXNjYWxhci1jb2xvci0yKTtcbiAgLS1zY2FsYXItc2lkZWJhci1ib3JkZXItY29sb3I6IHZhcigtLXNjYWxhci1ib3JkZXItY29sb3IpO1xuXG4gIC0tc2NhbGFyLXNpZGViYXItaXRlbS1ob3Zlci1jb2xvcjogY3VycmVudENvbG9yO1xuICAtLXNjYWxhci1zaWRlYmFyLWl0ZW0taG92ZXItYmFja2dyb3VuZDogdmFyKC0tc2NhbGFyLWJhY2tncm91bmQtMyk7XG5cbiAgLS1zY2FsYXItc2lkZWJhci1pdGVtLWFjdGl2ZS1iYWNrZ3JvdW5kOiB2YXIoLS1zY2FsYXItYmFja2dyb3VuZC1hY2NlbnQpO1xuICAtLXNjYWxhci1zaWRlYmFyLWNvbG9yLWFjdGl2ZTogdmFyKC0tc2NhbGFyLWNvbG9yLWFjY2VudCk7XG5cbiAgLS1zY2FsYXItc2lkZWJhci1zZWFyY2gtYmFja2dyb3VuZDogdmFyKC0tc2NhbGFyLWJhY2tncm91bmQtMSk7XG4gIC0tc2NhbGFyLXNpZGViYXItc2VhcmNoLWNvbG9yOiB2YXIoLS1zY2FsYXItY29sb3ItMyk7XG4gIC0tc2NhbGFyLXNpZGViYXItc2VhcmNoLWJvcmRlci1jb2xvcjogdmFyKC0tc2NhbGFyLWJvcmRlci1jb2xvcik7XG59XG5cbi8qIGFkdmFuY2VkICovXG4ubGlnaHQtbW9kZSB7XG4gIC0tc2NhbGFyLWNvbG9yLWdyZWVuOiAjMTc4MDNkO1xuICAtLXNjYWxhci1jb2xvci1yZWQ6ICNlMTA5MDk7XG4gIC0tc2NhbGFyLWNvbG9yLXllbGxvdzogI2VkYmUyMDtcbiAgLS1zY2FsYXItY29sb3ItYmx1ZTogIzE3NjNhNjtcbiAgLS1zY2FsYXItY29sb3Itb3JhbmdlOiAjZTI1YjA5O1xuICAtLXNjYWxhci1jb2xvci1wdXJwbGU6ICM1YzM5OTM7XG5cbiAgLS1zY2FsYXItYnV0dG9uLTE6IHJnYmEoMCwgMCwgMCwgMSk7XG4gIC0tc2NhbGFyLWJ1dHRvbi0xLWhvdmVyOiByZ2JhKDAsIDAsIDAsIDAuOCk7XG4gIC0tc2NhbGFyLWJ1dHRvbi0xLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOSk7XG59XG4uZGFyay1tb2RlIHtcbiAgLS1zY2FsYXItY29sb3ItZ3JlZW46ICMzMGExNTk7XG4gIC0tc2NhbGFyLWNvbG9yLXJlZDogI2RjMWIxOTtcbiAgLS1zY2FsYXItY29sb3IteWVsbG93OiAjZWVjNjQ0O1xuICAtLXNjYWxhci1jb2xvci1ibHVlOiAjMmI3YWJmO1xuICAtLXNjYWxhci1jb2xvci1vcmFuZ2U6ICNmMDc1Mjg7XG4gIC0tc2NhbGFyLWNvbG9yLXB1cnBsZTogIzdhNTliMTtcblxuICAtLXNjYWxhci1idXR0b24tMTogcmdiYSgyNTUsIDI1NSwgMjU1LCAxKTtcbiAgLS1zY2FsYXItYnV0dG9uLTEtaG92ZXI6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC45KTtcbiAgLS1zY2FsYXItYnV0dG9uLTEtY29sb3I6IGJsYWNrO1xufVxuYCwgYlIgPSBgLyogYmFzaWMgdGhlbWUgKi9cbi5saWdodC1tb2RlIHtcbiAgLS1zY2FsYXItYmFja2dyb3VuZC0xOiAjZjNmM2VlO1xuICAtLXNjYWxhci1iYWNrZ3JvdW5kLTI6ICNlOGU4ZTM7XG4gIC0tc2NhbGFyLWJhY2tncm91bmQtMzogI2U0ZTRkZjtcbiAgLS1zY2FsYXItYm9yZGVyLWNvbG9yOiByZ2JhKDIxNSwgMjE1LCAyMDYsIDAuNSk7XG5cbiAgLS1zY2FsYXItY29sb3ItMTogIzJhMmY0NTtcbiAgLS1zY2FsYXItY29sb3ItMjogIzc1NzU3NTtcbiAgLS1zY2FsYXItY29sb3ItMzogIzhlOGU4ZTtcblxuICAtLXNjYWxhci1jb2xvci1hY2NlbnQ6ICMxNzYzYTY7XG4gIC0tc2NhbGFyLWJhY2tncm91bmQtYWNjZW50OiAjMWY2NDhlMWY7XG5cbiAgLS1zY2FsYXItY29kZS1sYW5ndWFnZS1jb2xvci1zdXBlcnNlZGU6IHZhcigtLXNjYWxhci1jb2xvci0xKTtcbiAgLS1zY2FsYXItY29kZS1sYW5ndWFnZXMtYmFja2dyb3VuZC1zdXBlcnNlZGU6IHZhcigtLXNjYWxhci1iYWNrZ3JvdW5kLTIpO1xufVxuLmRhcmstbW9kZSB7XG4gIC0tc2NhbGFyLWJhY2tncm91bmQtMTogIzA5MDkwYjtcbiAgLS1zY2FsYXItYmFja2dyb3VuZC0yOiAjMTgxODFiO1xuICAtLXNjYWxhci1iYWNrZ3JvdW5kLTM6ICMyYzJjMzA7XG4gIC0tc2NhbGFyLWJvcmRlci1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEyKTtcblxuICAtLXNjYWxhci1jb2xvci0xOiAjZmFmYWZhO1xuICAtLXNjYWxhci1jb2xvci0yOiByZ2IoMTYxLCAxNjEsIDE3MCk7XG4gIC0tc2NhbGFyLWNvbG9yLTM6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC41MzMpO1xuXG4gIC0tc2NhbGFyLWNvbG9yLWFjY2VudDogIzRlYjNlYztcbiAgLS1zY2FsYXItYmFja2dyb3VuZC1hY2NlbnQ6ICM4YWI0ZjgxZjtcblxuICAtLXNjYWxhci1jb2RlLWxhbmd1YWdlLWNvbG9yLXN1cGVyc2VkZTogdmFyKC0tc2NhbGFyLWNvbG9yLTEpO1xuICAtLXNjYWxhci1jb2RlLWxhbmd1YWdlcy1iYWNrZ3JvdW5kLXN1cGVyc2VkZTogdmFyKC0tc2NhbGFyLWJhY2tncm91bmQtMik7XG59XG4vKiBEb2N1bWVudCBTaWRlYmFyICovXG4ubGlnaHQtbW9kZSAudC1kb2NfX3NpZGViYXIsXG4uZGFyay1tb2RlIC50LWRvY19fc2lkZWJhciB7XG4gIC0tc2NhbGFyLXNpZGViYXItYmFja2dyb3VuZC0xOiB2YXIoLS1zY2FsYXItYmFja2dyb3VuZC0xKTtcbiAgLS1zY2FsYXItc2lkZWJhci1jb2xvci0xOiB2YXIoLS1zY2FsYXItY29sb3ItMSk7XG4gIC0tc2NhbGFyLXNpZGViYXItY29sb3ItMjogdmFyKC0tc2NhbGFyLWNvbG9yLTIpO1xuICAtLXNjYWxhci1zaWRlYmFyLWJvcmRlci1jb2xvcjogdmFyKC0tc2NhbGFyLWJvcmRlci1jb2xvcik7XG5cbiAgLS1zY2FsYXItc2lkZWJhci1pdGVtLWhvdmVyLWJhY2tncm91bmQ6IHZhcigtLXNjYWxhci1iYWNrZ3JvdW5kLTIpO1xuICAtLXNjYWxhci1zaWRlYmFyLWl0ZW0taG92ZXItY29sb3I6IGN1cnJlbnRDb2xvcjtcblxuICAtLXNjYWxhci1zaWRlYmFyLWl0ZW0tYWN0aXZlLWJhY2tncm91bmQ6IHZhcigtLXNjYWxhci1iYWNrZ3JvdW5kLTMpO1xuICAtLXNjYWxhci1zaWRlYmFyLWNvbG9yLWFjdGl2ZTogdmFyKC0tc2NhbGFyLWNvbG9yLTEpO1xuXG4gIC0tc2NhbGFyLXNpZGViYXItc2VhcmNoLWJhY2tncm91bmQ6IHZhcigtLXNjYWxhci1iYWNrZ3JvdW5kLTEpO1xuICAtLXNjYWxhci1zaWRlYmFyLXNlYXJjaC1ib3JkZXItY29sb3I6IHZhcigtLXNjYWxhci1ib3JkZXItY29sb3IpO1xuICAtLXNjYWxhci1zaWRlYmFyLXNlYXJjaC1jb2xvcjogdmFyKC0tc2NhbGFyLWNvbG9yLTMpO1xufVxuXG4vKiBhZHZhbmNlZCAqL1xuLmxpZ2h0LW1vZGUge1xuICAtLXNjYWxhci1jb2xvci1ncmVlbjogIzE3ODAzZDtcbiAgLS1zY2FsYXItY29sb3ItcmVkOiAjZTEwOTA5O1xuICAtLXNjYWxhci1jb2xvci15ZWxsb3c6ICNlZGJlMjA7XG4gIC0tc2NhbGFyLWNvbG9yLWJsdWU6ICMxNzYzYTY7XG4gIC0tc2NhbGFyLWNvbG9yLW9yYW5nZTogI2UyNWIwOTtcbiAgLS1zY2FsYXItY29sb3ItcHVycGxlOiAjNWMzOTkzO1xuXG4gIC0tc2NhbGFyLWJ1dHRvbi0xOiByZ2JhKDAsIDAsIDAsIDEpO1xuICAtLXNjYWxhci1idXR0b24tMS1ob3ZlcjogcmdiYSgwLCAwLCAwLCAwLjgpO1xuICAtLXNjYWxhci1idXR0b24tMS1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjkpO1xufVxuLmRhcmstbW9kZSB7XG4gIC0tc2NhbGFyLWNvbG9yLWdyZWVuOiAjMzBhMTU5O1xuICAtLXNjYWxhci1jb2xvci1yZWQ6ICNkYzFiMTk7XG4gIC0tc2NhbGFyLWNvbG9yLXllbGxvdzogI2VlYzY0NDtcbiAgLS1zY2FsYXItY29sb3ItYmx1ZTogIzJiN2FiZjtcbiAgLS1zY2FsYXItY29sb3Itb3JhbmdlOiAjZjA3NTI4O1xuICAtLXNjYWxhci1jb2xvci1wdXJwbGU6ICM3YTU5YjE7XG5cbiAgLS1zY2FsYXItYnV0dG9uLTE6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMSk7XG4gIC0tc2NhbGFyLWJ1dHRvbi0xLWhvdmVyOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuOSk7XG4gIC0tc2NhbGFyLWJ1dHRvbi0xLWNvbG9yOiBibGFjaztcbn1cbi5kYXJrLW1vZGUgaDIudC1lZGl0b3JfX2hlYWRpbmcsXG4uZGFyay1tb2RlIC50LWVkaXRvcl9fcGFnZS10aXRsZSBoMSxcbi5kYXJrLW1vZGUgaDEuc2VjdGlvbi1oZWFkZXIsXG4uZGFyay1tb2RlIC5tYXJrZG93biBoMSxcbi5kYXJrLW1vZGUgLm1hcmtkb3duIGgyLFxuLmRhcmstbW9kZSAubWFya2Rvd24gaDMsXG4uZGFyay1tb2RlIC5tYXJrZG93biBoNCxcbi5kYXJrLW1vZGUgLm1hcmtkb3duIGg1LFxuLmRhcmstbW9kZSAubWFya2Rvd24gaDYge1xuICAtd2Via2l0LXRleHQtZmlsbC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gIGJhY2tncm91bmQtaW1hZ2U6IGxpbmVhci1ncmFkaWVudChcbiAgICB0byByaWdodCBib3R0b20sXG4gICAgcmdiKDI1NSwgMjU1LCAyNTUpIDMwJSxcbiAgICByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMzgpXG4gICk7XG4gIC13ZWJraXQtYmFja2dyb3VuZC1jbGlwOiB0ZXh0O1xuICBiYWNrZ3JvdW5kLWNsaXA6IHRleHQ7XG59XG5gLCB2UiA9IGAubGlnaHQtbW9kZSB7XG4gIGNvbG9yLXNjaGVtZTogbGlnaHQ7XG4gIC0tc2NhbGFyLWNvbG9yLTE6ICM1ODRjMjc7XG4gIC0tc2NhbGFyLWNvbG9yLTI6ICM2MTYxNjE7XG4gIC0tc2NhbGFyLWNvbG9yLTM6ICNhODlmODQ7XG4gIC0tc2NhbGFyLWNvbG9yLWFjY2VudDogI2I1ODkwMDtcbiAgLS1zY2FsYXItYmFja2dyb3VuZC0xOiAjZmRmNmUzO1xuICAtLXNjYWxhci1iYWNrZ3JvdW5kLTI6ICNlZWU4ZDU7XG4gIC0tc2NhbGFyLWJhY2tncm91bmQtMzogI2RkZDZjMTtcbiAgLS1zY2FsYXItYmFja2dyb3VuZC1hY2NlbnQ6ICNiNTg5MDAxZjtcblxuICAtLXNjYWxhci1ib3JkZXItY29sb3I6ICNkZWQ4Yzg7XG4gIC0tc2NhbGFyLXNjcm9sbGJhci1jb2xvcjogcmdiYSgwLCAwLCAwLCAwLjE4KTtcbiAgLS1zY2FsYXItc2Nyb2xsYmFyLWNvbG9yLWFjdGl2ZTogcmdiYSgwLCAwLCAwLCAwLjM2KTtcbiAgLS1zY2FsYXItbGlmdGVkLWJyaWdodG5lc3M6IDE7XG4gIC0tc2NhbGFyLWJhY2tkcm9wLWJyaWdodG5lc3M6IDE7XG5cbiAgLS1zY2FsYXItc2hhZG93LTE6IDAgMXB4IDNweCAwIHJnYmEoMCwgMCwgMCwgMC4xMSk7XG4gIC0tc2NhbGFyLXNoYWRvdy0yOiByZ2JhKDAsIDAsIDAsIDAuMDgpIDBweCAxM3B4IDIwcHggMHB4LFxuICAgIHJnYmEoMCwgMCwgMCwgMC4wOCkgMHB4IDNweCA4cHggMHB4LCAjZWVlZWVkIDBweCAwIDAgMXB4O1xuXG4gIC0tc2NhbGFyLWJ1dHRvbi0xOiByZ2IoNDkgNTMgNTYpO1xuICAtLXNjYWxhci1idXR0b24tMS1jb2xvcjogI2ZmZjtcbiAgLS1zY2FsYXItYnV0dG9uLTEtaG92ZXI6IHJnYigyOCAzMSAzMyk7XG5cbiAgLS1zY2FsYXItY29sb3ItcmVkOiAjYjkxYzFjO1xuICAtLXNjYWxhci1jb2xvci1vcmFuZ2U6ICNhMTYyMDc7XG4gIC0tc2NhbGFyLWNvbG9yLWdyZWVuOiAjMDQ3ODU3O1xuICAtLXNjYWxhci1jb2xvci1ibHVlOiAjMWQ0ZWQ4O1xuICAtLXNjYWxhci1jb2xvci1vcmFuZ2U6ICNjMjQxMGM7XG4gIC0tc2NhbGFyLWNvbG9yLXB1cnBsZTogIzZkMjhkOTtcbn1cblxuLmRhcmstbW9kZSB7XG4gIGNvbG9yLXNjaGVtZTogZGFyaztcbiAgLS1zY2FsYXItY29sb3ItMTogI2ZmZjtcbiAgLS1zY2FsYXItY29sb3ItMjogI2NjY2NjYztcbiAgLS1zY2FsYXItY29sb3ItMzogIzZkODg5MDtcbiAgLS1zY2FsYXItY29sb3ItYWNjZW50OiAjMDA3YWNjO1xuICAtLXNjYWxhci1iYWNrZ3JvdW5kLTE6ICMwMDIxMmI7XG4gIC0tc2NhbGFyLWJhY2tncm91bmQtMjogIzAxMmIzNjtcbiAgLS1zY2FsYXItYmFja2dyb3VuZC0zOiAjMDA0MDUyO1xuICAtLXNjYWxhci1iYWNrZ3JvdW5kLWFjY2VudDogIzAxNWE2ZjtcblxuICAtLXNjYWxhci1ib3JkZXItY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4xKTtcbiAgLS1zY2FsYXItc2Nyb2xsYmFyLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMjQpO1xuICAtLXNjYWxhci1zY3JvbGxiYXItY29sb3ItYWN0aXZlOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNDgpO1xuICAtLXNjYWxhci1saWZ0ZWQtYnJpZ2h0bmVzczogMS40NTtcbiAgLS1zY2FsYXItYmFja2Ryb3AtYnJpZ2h0bmVzczogMC41O1xuXG4gIC0tc2NhbGFyLXNoYWRvdy0xOiAwIDFweCAzcHggMCByZ2IoMCwgMCwgMCwgMC4xKTtcbiAgLS1zY2FsYXItc2hhZG93LTI6IHJnYmEoMTUsIDE1LCAxNSwgMC4yKSAwcHggM3B4IDZweCxcbiAgICByZ2JhKDE1LCAxNSwgMTUsIDAuNCkgMHB4IDlweCAyNHB4LCAwIDAgMCAxcHggcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjEpO1xuXG4gIC0tc2NhbGFyLWJ1dHRvbi0xOiAjZjZmNmY2O1xuICAtLXNjYWxhci1idXR0b24tMS1jb2xvcjogIzAwMDtcbiAgLS1zY2FsYXItYnV0dG9uLTEtaG92ZXI6ICNlN2U3ZTc7XG5cbiAgLS1zY2FsYXItY29sb3ItZ3JlZW46ICMwMGI2NDg7XG4gIC0tc2NhbGFyLWNvbG9yLXJlZDogI2RjMWIxOTtcbiAgLS1zY2FsYXItY29sb3IteWVsbG93OiAjZmZjOTBkO1xuICAtLXNjYWxhci1jb2xvci1ibHVlOiAjNGViM2VjO1xuICAtLXNjYWxhci1jb2xvci1vcmFuZ2U6ICNmZjhkNGQ7XG4gIC0tc2NhbGFyLWNvbG9yLXB1cnBsZTogI2IxOTFmOTtcbn1cblxuLyogU2lkZWJhciAqL1xuLmxpZ2h0LW1vZGUgLnQtZG9jX19zaWRlYmFyIHtcbiAgLS1zY2FsYXItc2lkZWJhci1iYWNrZ3JvdW5kLTE6IHZhcigtLXNjYWxhci1iYWNrZ3JvdW5kLTEpO1xuICAtLXNjYWxhci1zaWRlYmFyLWl0ZW0taG92ZXItY29sb3I6IGN1cnJlbnRDb2xvcjtcbiAgLS1zY2FsYXItc2lkZWJhci1pdGVtLWhvdmVyLWJhY2tncm91bmQ6IHZhcigtLXNjYWxhci1iYWNrZ3JvdW5kLTIpO1xuICAtLXNjYWxhci1zaWRlYmFyLWl0ZW0tYWN0aXZlLWJhY2tncm91bmQ6IHZhcigtLXNjYWxhci1iYWNrZ3JvdW5kLWFjY2VudCk7XG4gIC0tc2NhbGFyLXNpZGViYXItYm9yZGVyLWNvbG9yOiB2YXIoLS1zY2FsYXItYm9yZGVyLWNvbG9yKTtcbiAgLS1zY2FsYXItc2lkZWJhci1jb2xvci0xOiB2YXIoLS1zY2FsYXItY29sb3ItMSk7XG4gIC0tc2NhbGFyLXNpZGViYXItY29sb3ItMjogdmFyKC0tc2NhbGFyLWNvbG9yLTIpO1xuICAtLXNjYWxhci1zaWRlYmFyLWNvbG9yLWFjdGl2ZTogdmFyKC0tc2NhbGFyLWNvbG9yLWFjY2VudCk7XG4gIC0tc2NhbGFyLXNpZGViYXItc2VhcmNoLWJhY2tncm91bmQ6IHZhcigtLXNjYWxhci1iYWNrZ3JvdW5kLTIpO1xuICAtLXNjYWxhci1zaWRlYmFyLXNlYXJjaC1ib3JkZXItY29sb3I6IHZhcigtLXNjYWxhci1zaWRlYmFyLXNlYXJjaC1iYWNrZ3JvdW5kKTtcbiAgLS1zY2FsYXItc2lkZWJhci1zZWFyY2gtLWNvbG9yOiB2YXIoLS1zY2FsYXItY29sb3ItMyk7XG59XG5cbi5kYXJrLW1vZGUgLnNpZGViYXIge1xuICAtLXNjYWxhci1zaWRlYmFyLWJhY2tncm91bmQtMTogdmFyKC0tc2NhbGFyLWJhY2tncm91bmQtMSk7XG4gIC0tc2NhbGFyLXNpZGViYXItaXRlbS1ob3Zlci1jb2xvcjogY3VycmVudENvbG9yO1xuICAtLXNjYWxhci1zaWRlYmFyLWl0ZW0taG92ZXItYmFja2dyb3VuZDogdmFyKC0tc2NhbGFyLWJhY2tncm91bmQtMik7XG4gIC0tc2NhbGFyLXNpZGViYXItaXRlbS1hY3RpdmUtYmFja2dyb3VuZDogdmFyKC0tc2NhbGFyLWJhY2tncm91bmQtYWNjZW50KTtcbiAgLS1zY2FsYXItc2lkZWJhci1ib3JkZXItY29sb3I6IHZhcigtLXNjYWxhci1ib3JkZXItY29sb3IpO1xuICAtLXNjYWxhci1zaWRlYmFyLWNvbG9yLTE6IHZhcigtLXNjYWxhci1jb2xvci0xKTtcbiAgLS1zY2FsYXItc2lkZWJhci1jb2xvci0yOiB2YXIoLS1zY2FsYXItY29sb3ItMik7XG4gIC0tc2NhbGFyLXNpZGViYXItY29sb3ItYWN0aXZlOiB2YXIoLS1zY2FsYXItc2lkZWJhci1jb2xvci0xKTtcbiAgLS1zY2FsYXItc2lkZWJhci1zZWFyY2gtYmFja2dyb3VuZDogdmFyKC0tc2NhbGFyLWJhY2tncm91bmQtMik7XG4gIC0tc2NhbGFyLXNpZGViYXItc2VhcmNoLWJvcmRlci1jb2xvcjogdmFyKC0tc2NhbGFyLXNpZGViYXItc2VhcmNoLWJhY2tncm91bmQpO1xuICAtLXNjYWxhci1zaWRlYmFyLXNlYXJjaC0tY29sb3I6IHZhcigtLXNjYWxhci1jb2xvci0zKTtcbn1cbmAsIHlSID0gYFxuQGltcG9ydCB1cmwoJ2h0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzMj9mYW1pbHk9SW50ZXI6d2dodEAxMDAuLjkwMCcpO1xuQGltcG9ydCB1cmwoJ2h0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzP2ZhbWlseT1KZXRCcmFpbnMlMjBNb25vJyk7XG4vKiBJbnRlciAoLS1zY2FsYXItZm9udCkgKi9cbi8qIEpldEJyYWlucyBNb25vICgtLXNjYWxhci1mb250LWNvZGUpICovXG5gLCBTUiA9IC8qIEBfX1BVUkVfXyAqLyBsZSh7XG4gIF9fbmFtZTogXCJEZWZhdWx0Rm9udHNcIixcbiAgc2V0dXAodCkge1xuICAgIHJldHVybiAoZSwgbikgPT4gKFooKSwga2UoWmwoXCJzdHlsZVwiKSwgeyBpbm5lckhUTUw6IFIoeVIpIH0sIG51bGwsIDgsIFtcImlubmVySFRNTFwiXSkpO1xuICB9XG59KSwgd1IgPSAvKiBAX19QVVJFX18gKi8gbGUoe1xuICBfX25hbWU6IFwiVGhlbWVTdHlsZXNcIixcbiAgcHJvcHM6IHtcbiAgICBpZDoge30sXG4gICAgd2l0aERlZmF1bHRGb250czogeyB0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiAhMCB9XG4gIH0sXG4gIHNldHVwKHQpIHtcbiAgICByZXR1cm4gKGUsIG4pID0+IChaKCksIG5lKFBlLCBudWxsLCBbXG4gICAgICBlLndpdGhEZWZhdWx0Rm9udHMgPyAoWigpLCBrZShTUiwgeyBrZXk6IDAgfSkpIDogc3QoXCJcIiwgITApLFxuICAgICAgZS5pZCAhPT0gXCJub25lXCIgPyAoWigpLCBrZShabChcInN0eWxlXCIpLCB7IGtleTogMSB9LCB7XG4gICAgICAgIGRlZmF1bHQ6IGNlKCgpID0+IFtcbiAgICAgICAgICBIZShEZShSKFFSKShlLmlkLCB7IGxheWVyOiBcInNjYWxhci10aGVtZVwiIH0pKSwgMSlcbiAgICAgICAgXSksXG4gICAgICAgIF86IDFcbiAgICAgIH0pKSA6IHN0KFwiXCIsICEwKVxuICAgIF0sIDY0KSk7XG4gIH1cbn0pO1xuZnVuY3Rpb24ga1IodCwgZSkge1xuICBldCgoKSA9PiB7XG4gICAgaWYgKCFkb2N1bWVudC5ib2R5KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG4gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHQpO1xuICAgIG4gPT0gbnVsbCB8fCBuLmNsYXNzTGlzdC5hZGQoZSk7XG4gIH0pO1xufVxuY29uc3QgeFIgPSAvKiBAX19QVVJFX18gKi8gbGUoe1xuICBfX25hbWU6IFwiUmVzZXRTdHlsZXNcIixcbiAgc2V0dXAodCkge1xuICAgIGNvbnN0IHsgcmVzZXQ6IGUgfSA9IEoxKCk7XG4gICAgcmV0dXJuIGtSKFwiI2hlYWRsZXNzdWktcG9ydGFsLXJvb3RcIiwgZSksIChuLCByKSA9PiBwdChuLiRzbG90cywgXCJkZWZhdWx0XCIsIHsgc3R5bGVzOiBSKGUpIH0pO1xuICB9XG59KSwgUFIgPSBcIl9yZXNldF8xMnZoY18zXCIsIF9SID0ge1xuICByZXNldDogUFJcbn0sIGN0ID0gKHQsIGUpID0+IHtcbiAgY29uc3QgbiA9IHQuX192Y2NPcHRzIHx8IHQ7XG4gIGZvciAoY29uc3QgW3IsIGldIG9mIGUpXG4gICAgbltyXSA9IGk7XG4gIHJldHVybiBuO1xufSwgVFIgPSB7XG4gICRzdHlsZTogX1Jcbn0sIEVSID0gLyogQF9fUFVSRV9fICovIGN0KHhSLCBbW1wiX19jc3NNb2R1bGVzXCIsIFRSXV0pLCAkUiA9IHtcbiAgYWx0ZXJuYXRlOiBkUixcbiAgZGVmYXVsdDogVHcsXG4gIG1vb246IGdSLFxuICBwdXJwbGU6IG1SLFxuICBzb2xhcml6ZWQ6IHZSLFxuICBibHVlUGxhbmV0OiBmUixcbiAgZGVlcFNwYWNlOiBoUixcbiAgc2F0dXJuOiBiUixcbiAga2VwbGVyOiBwUixcbiAgbWFyczogT1Jcbn0sIFFSID0gKHQsIGUpID0+IHtcbiAgaWYgKHQgPT09IFwibm9uZVwiKVxuICAgIHJldHVybiBcIlwiO1xuICBjb25zdCBuID0gJFJbdCB8fCBcImRlZmF1bHRcIl0gPz8gVHc7XG4gIHJldHVybiBlICE9IG51bGwgJiYgZS5sYXllciA/IGBAbGF5ZXIgJHtlLmxheWVyfSB7XG4ke259fWAgOiBuO1xufTtcbmZ1bmN0aW9uIENSKCkge1xuICByZXR1cm4ge1xuICAgIHNob3dBcGlDbGllbnQ6ICExLFxuICAgIGFjdGl2ZUFwaUNsaWVudEVuZHBvaW50SWQ6IFwiXCIsXG4gICAgYWN0aXZlSXRlbToge30sXG4gICAgc25pcHBldFR5cGU6IFwiamF2YXNjcmlwdFwiXG4gIH07XG59XG5YbihDUigpKTtcbmNvbnN0IEFSID0gKHQpID0+IHtcbiAgbGV0IGUgPSAwLCBuID0gMCwgciA9IDA7XG4gIGlmICghKHQgIT0gbnVsbCAmJiB0Lmxlbmd0aCkpXG4gICAgcmV0dXJuIG47XG4gIGZvciAociA9IDA7IHIgPCB0Lmxlbmd0aDsgcisrKVxuICAgIGUgPSB0LmNoYXJDb2RlQXQociksIG4gPSAobiA8PCA1KSAtIG4gKyBlLCBuIHw9IDA7XG4gIHJldHVybiBuO1xufTtcbmxldCBDYjtcbnRyeSB7XG4gIENiID0gbmV3IFJlZ0V4cChgKF58KD88IVxuKSlcbisoPyFcbnwkKWAsIFwiZ1wiKTtcbn0gY2F0Y2gge1xuICBDYiA9IC9cXG4rKD8hXFxufCQpL2c7XG59XG5jb25zdCBFdyA9IHtcbiAgLyoqIFBhcnNlIGFuZCB0aHJvdyBpZiB0aGUgcmV0dXJuIHZhbHVlIGlzIG5vdCBhbiBvYmplY3QgKi9cbiAgcGFyc2U6ICh0KSA9PiB7XG4gICAgY29uc3QgZSA9IEpTT04ucGFyc2UodCk7XG4gICAgaWYgKHR5cGVvZiBlICE9IFwib2JqZWN0XCIpXG4gICAgICB0aHJvdyBFcnJvcihcIkludmFsaWQgSlNPTiBvYmplY3RcIik7XG4gICAgcmV0dXJuIGU7XG4gIH0sXG4gIC8qKiBQYXJzZSBhbmQgcmV0dXJuIGEgZmFsbGJhY2sgb24gZmFpbHVyZSAqL1xuICBwYXJzZVNhZmUodCwgZSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gRXcucGFyc2UodCk7XG4gICAgfSBjYXRjaCAobikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiA/IGUobikgOiBlO1xuICAgIH1cbiAgfSxcbiAgc3RyaW5naWZ5OiAodCkgPT4gSlNPTi5zdHJpbmdpZnkodClcbn0sIFhoID0gKHQpID0+IHR5cGVvZiB0ICE9IFwic3RyaW5nXCIgPyAhMSA6ICEhRXcucGFyc2VTYWZlKHQsICExKSwgUlIgPSB7XG4gIDEwMDoge1xuICAgIG5hbWU6IFwiQ29udGludWVcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9TdGF0dXMvMTAwXCJcbiAgfSxcbiAgMTAxOiB7XG4gICAgbmFtZTogXCJTd2l0Y2hpbmcgUHJvdG9jb2xzXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvU3RhdHVzLzEwMVwiXG4gIH0sXG4gIDEwMjoge1xuICAgIG5hbWU6IFwiUHJvY2Vzc2luZ1wiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL1N0YXR1cy8xMDJcIlxuICB9LFxuICAxMDM6IHtcbiAgICBuYW1lOiBcIkVhcmx5IEhpbnRzXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvU3RhdHVzLzEwM1wiXG4gIH0sXG4gIDIwMDoge1xuICAgIG5hbWU6IFwiT0tcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9TdGF0dXMvMjAwXCJcbiAgfSxcbiAgMjAxOiB7XG4gICAgbmFtZTogXCJDcmVhdGVkXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvU3RhdHVzLzIwMVwiXG4gIH0sXG4gIDIwMjoge1xuICAgIG5hbWU6IFwiQWNjZXB0ZWRcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9TdGF0dXMvMjAyXCJcbiAgfSxcbiAgMjAzOiB7XG4gICAgbmFtZTogXCJOb24tQXV0aG9yaXRhdGl2ZSBJbmZvcm1hdGlvblwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL1N0YXR1cy8yMDNcIlxuICB9LFxuICAyMDQ6IHtcbiAgICBuYW1lOiBcIk5vIENvbnRlbnRcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9TdGF0dXMvMjA0XCJcbiAgfSxcbiAgMjA1OiB7XG4gICAgbmFtZTogXCJSZXNldCBDb250ZW50XCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvU3RhdHVzLzIwNVwiXG4gIH0sXG4gIDIwNjoge1xuICAgIG5hbWU6IFwiUGFydGlhbCBDb250ZW50XCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvU3RhdHVzLzIwNlwiXG4gIH0sXG4gIDIwNzoge1xuICAgIG5hbWU6IFwiTXVsdGktU3RhdHVzXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvU3RhdHVzLzIwN1wiXG4gIH0sXG4gIDIwODoge1xuICAgIG5hbWU6IFwiQWxyZWFkeSBSZXBvcnRlZFwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL1N0YXR1cy8yMDhcIlxuICB9LFxuICAyMjY6IHtcbiAgICBuYW1lOiBcIklNIFVzZWRcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9TdGF0dXMvMjI2XCJcbiAgfSxcbiAgMzAwOiB7XG4gICAgbmFtZTogXCJNdWx0aXBsZSBDaG9pY2VzXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvU3RhdHVzLzMwMFwiXG4gIH0sXG4gIDMwMToge1xuICAgIG5hbWU6IFwiTW92ZWQgUGVybWFuZW50bHlcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9TdGF0dXMvMzAxXCJcbiAgfSxcbiAgMzAyOiB7XG4gICAgbmFtZTogXCJGb3VuZFwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL1N0YXR1cy8zMDJcIlxuICB9LFxuICAzMDM6IHtcbiAgICBuYW1lOiBcIlNlZSBPdGhlclwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL1N0YXR1cy8zMDNcIlxuICB9LFxuICAzMDQ6IHtcbiAgICBuYW1lOiBcIk5vdCBNb2RpZmllZFwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL1N0YXR1cy8zMDRcIlxuICB9LFxuICAzMDU6IHtcbiAgICBuYW1lOiBcIlVzZSBQcm94eVwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL1N0YXR1cy8zMDVcIlxuICB9LFxuICAzMDY6IHtcbiAgICBuYW1lOiBcIihVbnVzZWQpXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvU3RhdHVzLzMwNlwiXG4gIH0sXG4gIDMwNzoge1xuICAgIG5hbWU6IFwiVGVtcG9yYXJ5IFJlZGlyZWN0XCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvU3RhdHVzLzMwN1wiXG4gIH0sXG4gIDMwODoge1xuICAgIG5hbWU6IFwiUGVybWFuZW50IFJlZGlyZWN0XCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvU3RhdHVzLzMwOFwiXG4gIH0sXG4gIDQwMDoge1xuICAgIG5hbWU6IFwiQmFkIFJlcXVlc3RcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9TdGF0dXMvNDAwXCJcbiAgfSxcbiAgNDAxOiB7XG4gICAgbmFtZTogXCJVbmF1dGhvcml6ZWRcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9TdGF0dXMvNDAxXCJcbiAgfSxcbiAgNDAyOiB7XG4gICAgbmFtZTogXCJQYXltZW50IFJlcXVpcmVkXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvU3RhdHVzLzQwMlwiXG4gIH0sXG4gIDQwMzoge1xuICAgIG5hbWU6IFwiRm9yYmlkZGVuXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvU3RhdHVzLzQwM1wiXG4gIH0sXG4gIDQwNDoge1xuICAgIG5hbWU6IFwiTm90IEZvdW5kXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvU3RhdHVzLzQwNFwiXG4gIH0sXG4gIDQwNToge1xuICAgIG5hbWU6IFwiTWV0aG9kIE5vdCBBbGxvd2VkXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvU3RhdHVzLzQwNVwiXG4gIH0sXG4gIDQwNjoge1xuICAgIG5hbWU6IFwiTm90IEFjY2VwdGFibGVcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9TdGF0dXMvNDA2XCJcbiAgfSxcbiAgNDA3OiB7XG4gICAgbmFtZTogXCJQcm94eSBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZFwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL1N0YXR1cy80MDdcIlxuICB9LFxuICA0MDg6IHtcbiAgICBuYW1lOiBcIlJlcXVlc3QgVGltZW91dFwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL1N0YXR1cy80MDhcIlxuICB9LFxuICA0MDk6IHtcbiAgICBuYW1lOiBcIkNvbmZsaWN0XCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvU3RhdHVzLzQwOVwiXG4gIH0sXG4gIDQxMDoge1xuICAgIG5hbWU6IFwiR29uZVwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL1N0YXR1cy80MTBcIlxuICB9LFxuICA0MTE6IHtcbiAgICBuYW1lOiBcIkxlbmd0aCBSZXF1aXJlZFwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL1N0YXR1cy80MTFcIlxuICB9LFxuICA0MTI6IHtcbiAgICBuYW1lOiBcIlByZWNvbmRpdGlvbiBGYWlsZWRcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9TdGF0dXMvNDEyXCJcbiAgfSxcbiAgNDEzOiB7XG4gICAgbmFtZTogXCJDb250ZW50IFRvbyBMYXJnZVwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL1N0YXR1cy80MTNcIlxuICB9LFxuICA0MTQ6IHtcbiAgICBuYW1lOiBcIlVSSSBUb28gTG9uZ1wiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL1N0YXR1cy80MTRcIlxuICB9LFxuICA0MTU6IHtcbiAgICBuYW1lOiBcIlVuc3VwcG9ydGVkIE1lZGlhIFR5cGVcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9TdGF0dXMvNDE1XCJcbiAgfSxcbiAgNDE2OiB7XG4gICAgbmFtZTogXCJSYW5nZSBOb3QgU2F0aXNmaWFibGVcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9TdGF0dXMvNDE2XCJcbiAgfSxcbiAgNDE3OiB7XG4gICAgbmFtZTogXCJFeHBlY3RhdGlvbiBGYWlsZWRcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9TdGF0dXMvNDE3XCJcbiAgfSxcbiAgNDIxOiB7XG4gICAgbmFtZTogXCJNaXNkaXJlY3RlZCBSZXF1ZXN0XCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvU3RhdHVzLzQyMVwiXG4gIH0sXG4gIDQyMjoge1xuICAgIG5hbWU6IFwiVW5wcm9jZXNzYWJsZSBDb250ZW50XCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvU3RhdHVzLzQyMlwiXG4gIH0sXG4gIDQyMzoge1xuICAgIG5hbWU6IFwiTG9ja2VkXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvU3RhdHVzLzQyM1wiXG4gIH0sXG4gIDQyNDoge1xuICAgIG5hbWU6IFwiRmFpbGVkIERlcGVuZGVuY3lcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9TdGF0dXMvNDI0XCJcbiAgfSxcbiAgNDI1OiB7XG4gICAgbmFtZTogXCJUb28gRWFybHlcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9TdGF0dXMvNDI1XCJcbiAgfSxcbiAgNDI2OiB7XG4gICAgbmFtZTogXCJVcGdyYWRlIFJlcXVpcmVkXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvU3RhdHVzLzQyNlwiXG4gIH0sXG4gIDQyODoge1xuICAgIG5hbWU6IFwiUHJlY29uZGl0aW9uIFJlcXVpcmVkXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvU3RhdHVzLzQyOFwiXG4gIH0sXG4gIDQyOToge1xuICAgIG5hbWU6IFwiVG9vIE1hbnkgUmVxdWVzdHNcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9TdGF0dXMvNDI5XCJcbiAgfSxcbiAgNDMxOiB7XG4gICAgbmFtZTogXCJSZXF1ZXN0IEhlYWRlciBGaWVsZHMgVG9vIExhcmdlXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvU3RhdHVzLzQzMVwiXG4gIH0sXG4gIDQ1MToge1xuICAgIG5hbWU6IFwiVW5hdmFpbGFibGUgRm9yIExlZ2FsIFJlYXNvbnNcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9TdGF0dXMvNDUxXCJcbiAgfSxcbiAgNTAwOiB7XG4gICAgbmFtZTogXCJJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9TdGF0dXMvNTAwXCJcbiAgfSxcbiAgNTAxOiB7XG4gICAgbmFtZTogXCJOb3QgSW1wbGVtZW50ZWRcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9TdGF0dXMvNTAxXCJcbiAgfSxcbiAgNTAyOiB7XG4gICAgbmFtZTogXCJCYWQgR2F0ZXdheVwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL1N0YXR1cy81MDJcIlxuICB9LFxuICA1MDM6IHtcbiAgICBuYW1lOiBcIlNlcnZpY2UgVW5hdmFpbGFibGVcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9TdGF0dXMvNTAzXCJcbiAgfSxcbiAgNTA0OiB7XG4gICAgbmFtZTogXCJHYXRld2F5IFRpbWVvdXRcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9TdGF0dXMvNTA0XCJcbiAgfSxcbiAgNTA1OiB7XG4gICAgbmFtZTogXCJIVFRQIFZlcnNpb24gTm90IFN1cHBvcnRlZFwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL1N0YXR1cy81MDVcIlxuICB9LFxuICA1MDY6IHtcbiAgICBuYW1lOiBcIlZhcmlhbnQgQWxzbyBOZWdvdGlhdGVzXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvU3RhdHVzLzUwNlwiXG4gIH0sXG4gIDUwNzoge1xuICAgIG5hbWU6IFwiSW5zdWZmaWNpZW50IFN0b3JhZ2VcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9TdGF0dXMvNTA3XCJcbiAgfSxcbiAgNTA4OiB7XG4gICAgbmFtZTogXCJMb29wIERldGVjdGVkXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvU3RhdHVzLzUwOFwiXG4gIH0sXG4gIDUxMDoge1xuICAgIG5hbWU6IFwiTm90IEV4dGVuZGVkXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvU3RhdHVzLzUxMFwiXG4gIH0sXG4gIDUxMToge1xuICAgIG5hbWU6IFwiTmV0d29yayBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZFwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL1N0YXR1cy81MTFcIlxuICB9XG59LCBBYiA9ICgpID0+ICh7fSksICR3ID0gdHlwZW9mIHdpbmRvdyA8IFwidVwiID8gd2luZG93Ll9fU0NBTEFSX18gPz8gQWIoKSA6IEFiKCksIE5SID0gKCkgPT4gKHtcbiAgcHJlZmVycmVkU2VjdXJpdHlTY2hlbWU6IG51bGwsXG4gIC8vIEluIGNhc2UgdGhlIHNwZWMgaGFzIG5vIHNlY3VyaXR5IGFuZCB0aGUgdXNlciB3b3VsZCBsaWtlIHRvIGFkZCBzb21lXG4gIGN1c3RvbVNlY3VyaXR5OiAhMSxcbiAgaHR0cDoge1xuICAgIGJhc2ljOiB7XG4gICAgICB1c2VybmFtZTogXCJcIixcbiAgICAgIHBhc3N3b3JkOiBcIlwiXG4gICAgfSxcbiAgICBiZWFyZXI6IHtcbiAgICAgIHRva2VuOiBcIlwiXG4gICAgfVxuICB9LFxuICBhcGlLZXk6IHtcbiAgICB0b2tlbjogXCJcIlxuICB9LFxuICBvQXV0aDI6IHtcbiAgICBjbGllbnRJZDogXCJcIixcbiAgICBzY29wZXM6IFtdLFxuICAgIGFjY2Vzc1Rva2VuOiBcIlwiLFxuICAgIHN0YXRlOiBcIlwiXG4gIH1cbn0pLCBRdyA9IFhuKFxuICAkd1tcInVzZUdsb2JhbFN0b3JlLWF1dGhlbnRpY2F0aW9uXCJdID8/IE5SKClcbiksIERSID0gKHQpID0+IE9iamVjdC5hc3NpZ24oUXcsIHQpLCBZbCA9ICgpID0+ICh7XG4gIGF1dGhlbnRpY2F0aW9uOiBRdyxcbiAgc2V0QXV0aGVudGljYXRpb246IERSXG59KSwgWlIgPSAoKSA9PiAoe1xuICAvLyBAdHMtaWdub3JlXG4gIG9wZXJhdGlvbjoge30sXG4gIGdsb2JhbFNlY3VyaXR5OiBbXVxufSksIGRsID0gWG4oWlIoKSksIFZSID0gKHQpID0+IHtcbiAgT2JqZWN0LmFzc2lnbihkbCwge1xuICAgIC4uLmRsLFxuICAgIG9wZXJhdGlvbjogdFxuICB9KTtcbn0sIElSID0gKHQpID0+IHtcbiAgT2JqZWN0LmFzc2lnbihkbCwge1xuICAgIC4uLmRsLFxuICAgIGdsb2JhbFNlY3VyaXR5OiB0XG4gIH0pO1xufSwgQ3cgPSAoKSA9PiAoe1xuICBvcGVuQXBpOiBkbCxcbiAgc2V0T3BlcmF0aW9uOiBWUixcbiAgc2V0R2xvYmFsU2VjdXJpdHk6IElSXG59KSwgV1IgPSAoKSA9PiAoe1xuICBuYW1lOiBcIlwiLFxuICB1cmw6IFwiXCIsXG4gIHR5cGU6IFwiR0VUXCIsXG4gIHBhdGg6IFwiXCIsXG4gIHZhcmlhYmxlczogW10sXG4gIGhlYWRlcnM6IFtdLFxuICBxdWVyeTogW10sXG4gIGJvZHk6IFwiXCIsXG4gIGZvcm1EYXRhOiBbXVxufSksIEJkID0gWG4oe30pLCBBdyA9IEcoW10pLCBNbyA9IEcoXCJcIiksIGVnID0gWG4oV1IoKSksIE1SID0gKHQpID0+IHtcbiAgQmRbdC5yZXNwb25zZUlkXSA9IHQsIE1vLnZhbHVlID0gdC5yZXNwb25zZUlkLCBBdy52YWx1ZS51bnNoaWZ0KHQucmVzcG9uc2VJZCk7XG59LCBYUiA9ICh0KSA9PiB7XG4gIE1vLnZhbHVlID0gdDtcbiAgY29uc3QgeyByZXF1ZXN0OiBlIH0gPSBCZFt0XSwgbiA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZSkpO1xuICBuLmJvZHkgPSBKU09OLnN0cmluZ2lmeShlLmJvZHksIG51bGwsIDIpLCBPYmplY3QuYXNzaWduKGVnLCBuKTtcbn0sIGpSID0gaihcbiAgKCkgPT4gTW8udmFsdWUgPyBCZFtNby52YWx1ZV0ucmVzcG9uc2UgOiBudWxsXG4pLCBCUiA9ICh0KSA9PiB7XG4gIE9iamVjdC5hc3NpZ24oZWcsIHQpO1xufSwgTFIgPSAoKSA9PiB7XG4gIE1vLnZhbHVlID0gXCJcIjtcbn0sIFVSID0gRyghMCksIHNyID0gKCkgPT4gKHtcbiAgcmVhZE9ubHk6IFVSLFxuICBhY3RpdmVSZXF1ZXN0OiBlZyxcbiAgYWN0aXZlUmVzcG9uc2U6IGpSLFxuICByZXF1ZXN0SGlzdG9yeTogQmQsXG4gIHJlcXVlc3RIaXN0b3J5T3JkZXI6IEF3LFxuICBhY3RpdmVSZXF1ZXN0SWQ6IE1vLFxuICBzZXRBY3RpdmVSZXNwb25zZTogWFIsXG4gIHJlc2V0QWN0aXZlUmVzcG9uc2U6IExSLFxuICBhZGRSZXF1ZXN0VG9IaXN0b3J5OiBNUixcbiAgc2V0QWN0aXZlUmVxdWVzdDogQlJcbn0pLCBxUiA9IFtcbiAge1xuICAgIG5hbWU6IFwiQWNjZXB0XCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9BY2NlcHRcIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJBY2NlcHQtQ0hcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0FjY2VwdC1DSFwiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIkFjY2VwdC1DSC1MaWZldGltZVwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvQWNjZXB0LUNILUxpZmV0aW1lXCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiQWNjZXB0LUNoYXJzZXRcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0FjY2VwdC1DaGFyc2V0XCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiQWNjZXB0LUVuY29kaW5nXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9BY2NlcHQtRW5jb2RpbmdcIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJBY2NlcHQtTGFuZ3VhZ2VcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0FjY2VwdC1MYW5ndWFnZVwiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIkFjY2VwdC1QYXRjaFwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvQWNjZXB0LVBhdGNoXCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiQWNjZXB0LVBvc3RcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0FjY2VwdC1Qb3N0XCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiQWNjZXB0LVJhbmdlc1wiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvQWNjZXB0LVJhbmdlc1wiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIkFjY2Vzcy1Db250cm9sLUFsbG93LUNyZWRlbnRpYWxzXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9BY2Nlc3MtQ29udHJvbC1BbGxvdy1DcmVkZW50aWFsc1wiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIkFjY2Vzcy1Db250cm9sLUFsbG93LUhlYWRlcnNcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0FjY2Vzcy1Db250cm9sLUFsbG93LUhlYWRlcnNcIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJBY2Nlc3MtQ29udHJvbC1BbGxvdy1NZXRob2RzXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9BY2Nlc3MtQ29udHJvbC1BbGxvdy1NZXRob2RzXCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9BY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW5cIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJBY2Nlc3MtQ29udHJvbC1FeHBvc2UtSGVhZGVyc1wiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvQWNjZXNzLUNvbnRyb2wtRXhwb3NlLUhlYWRlcnNcIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJBY2Nlc3MtQ29udHJvbC1NYXgtQWdlXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9BY2Nlc3MtQ29udHJvbC1NYXgtQWdlXCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiQWNjZXNzLUNvbnRyb2wtUmVxdWVzdC1IZWFkZXJzXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9BY2Nlc3MtQ29udHJvbC1SZXF1ZXN0LUhlYWRlcnNcIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJBY2Nlc3MtQ29udHJvbC1SZXF1ZXN0LU1ldGhvZFwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvQWNjZXNzLUNvbnRyb2wtUmVxdWVzdC1NZXRob2RcIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJBZ2VcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0FnZVwiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIkFsbG93XCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9BbGxvd1wiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIkFsdC1TdmNcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0FsdC1TdmNcIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJBbHQtVXNlZFwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvQWx0LVVzZWRcIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJBdXRob3JpemF0aW9uXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9BdXRob3JpemF0aW9uXCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiQ2FjaGUtQ29udHJvbFwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvQ2FjaGUtQ29udHJvbFwiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIkNsZWFyLVNpdGUtRGF0YVwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvQ2xlYXItU2l0ZS1EYXRhXCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiQ29ubmVjdGlvblwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvQ29ubmVjdGlvblwiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIkNvbnRlbnQtRGlzcG9zaXRpb25cIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0NvbnRlbnQtRGlzcG9zaXRpb25cIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJDb250ZW50LURQUlwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvQ29udGVudC1EUFJcIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJDb250ZW50LUVuY29kaW5nXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9Db250ZW50LUVuY29kaW5nXCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiQ29udGVudC1MYW5ndWFnZVwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvQ29udGVudC1MYW5ndWFnZVwiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIkNvbnRlbnQtTGVuZ3RoXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9Db250ZW50LUxlbmd0aFwiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIkNvbnRlbnQtTG9jYXRpb25cIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0NvbnRlbnQtTG9jYXRpb25cIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJDb250ZW50LVJhbmdlXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9Db250ZW50LVJhbmdlXCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiQ29udGVudC1TZWN1cml0eS1Qb2xpY3lcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0NvbnRlbnQtU2VjdXJpdHktUG9saWN5XCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiQ29udGVudC1TZWN1cml0eS1Qb2xpY3ktUmVwb3J0LU9ubHlcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0NvbnRlbnQtU2VjdXJpdHktUG9saWN5LVJlcG9ydC1Pbmx5XCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiQ29udGVudC1UeXBlXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9Db250ZW50LVR5cGVcIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJDb29raWVcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0Nvb2tpZVwiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIkNyaXRpY2FsLUNIXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9Dcml0aWNhbC1DSFwiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIkNyb3NzLU9yaWdpbi1FbWJlZGRlci1Qb2xpY3lcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0Nyb3NzLU9yaWdpbi1FbWJlZGRlci1Qb2xpY3lcIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJDcm9zcy1PcmlnaW4tT3BlbmVyLVBvbGljeVwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvQ3Jvc3MtT3JpZ2luLU9wZW5lci1Qb2xpY3lcIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJDcm9zcy1PcmlnaW4tUmVzb3VyY2UtUG9saWN5XCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9Dcm9zcy1PcmlnaW4tUmVzb3VyY2UtUG9saWN5XCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiRGF0ZVwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvRGF0ZVwiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIkRldmljZS1NZW1vcnlcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0RldmljZS1NZW1vcnlcIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJEaWdlc3RcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0RpZ2VzdFwiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIkROVFwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvRE5UXCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiRG93bmxpbmtcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0Rvd25saW5rXCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiRFBSXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9EUFJcIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJFYXJseS1EYXRhXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9FYXJseS1EYXRhXCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiRUNUXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9FQ1RcIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJFVGFnXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9FVGFnXCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiRXhwZWN0XCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9FeHBlY3RcIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJFeHBlY3QtQ1RcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0V4cGVjdC1DVFwiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIkV4cGlyZXNcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0V4cGlyZXNcIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJGb3J3YXJkZWRcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0ZvcndhcmRlZFwiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIkZyb21cIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0Zyb21cIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJIb3N0XCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9Ib3N0XCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiSWYtTWF0Y2hcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0lmLU1hdGNoXCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiSWYtTW9kaWZpZWQtU2luY2VcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0lmLU1vZGlmaWVkLVNpbmNlXCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiSWYtTm9uZS1NYXRjaFwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvSWYtTm9uZS1NYXRjaFwiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIklmLVJhbmdlXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9JZi1SYW5nZVwiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIklmLVVubW9kaWZpZWQtU2luY2VcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0lmLVVubW9kaWZpZWQtU2luY2VcIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJLZWVwLUFsaXZlXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9LZWVwLUFsaXZlXCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiTGFyZ2UtQWxsb2NhdGlvblwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvTGFyZ2UtQWxsb2NhdGlvblwiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIkxhc3QtTW9kaWZpZWRcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0xhc3QtTW9kaWZpZWRcIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJMaW5rXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9MaW5rXCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiTG9jYXRpb25cIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL0xvY2F0aW9uXCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiTWF4LUZvcndhcmRzXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9NYXgtRm9yd2FyZHNcIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJORUxcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL05FTFwiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIk9yaWdpblwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvT3JpZ2luXCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiUGVybWlzc2lvbnMtUG9saWN5XCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9QZXJtaXNzaW9ucy1Qb2xpY3lcIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJQcmFnbWFcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL1ByYWdtYVwiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIlByb3h5LUF1dGhlbnRpY2F0ZVwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvUHJveHktQXV0aGVudGljYXRlXCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiUHJveHktQXV0aG9yaXphdGlvblwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvUHJveHktQXV0aG9yaXphdGlvblwiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIlJhbmdlXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9SYW5nZVwiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIlJlZmVyZXJcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL1JlZmVyZXJcIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJSZWZlcnJlci1Qb2xpY3lcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL1JlZmVycmVyLVBvbGljeVwiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIlJldHJ5LUFmdGVyXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9SZXRyeS1BZnRlclwiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIlJUVFwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvUlRUXCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiU2F2ZS1EYXRhXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9TYXZlLURhdGFcIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJTZWMtQ0gtUHJlZmVycy1SZWR1Y2VkLU1vdGlvblwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvU2VjLUNILVByZWZlcnMtUmVkdWNlZC1Nb3Rpb25cIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJTZWMtQ0gtUHJlZmVycy1SZWR1Y2VkLVRyYW5zcGFyZW5jeVwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvU2VjLUNILVByZWZlcnMtUmVkdWNlZC1UcmFuc3BhcmVuY3lcIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJTZWMtQ0gtVUFcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL1NlYy1DSC1VQVwiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIlNlYy1DSC1VQS1BcmNoXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9TZWMtQ0gtVUEtQXJjaFwiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIlNlYy1DSC1VQS1CaXRuZXNzXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9TZWMtQ0gtVUEtQml0bmVzc1wiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIlNlYy1DSC1VQS1GdWxsLVZlcnNpb25cIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL1NlYy1DSC1VQS1GdWxsLVZlcnNpb25cIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJTZWMtQ0gtVUEtRnVsbC1WZXJzaW9uLUxpc3RcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL1NlYy1DSC1VQS1GdWxsLVZlcnNpb24tTGlzdFwiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIlNlYy1DSC1VQS1Nb2JpbGVcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL1NlYy1DSC1VQS1Nb2JpbGVcIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJTZWMtQ0gtVUEtTW9kZWxcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL1NlYy1DSC1VQS1Nb2RlbFwiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIlNlYy1DSC1VQS1QbGF0Zm9ybVwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvU2VjLUNILVVBLVBsYXRmb3JtXCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiU2VjLUNILVVBLVBsYXRmb3JtLVZlcnNpb25cIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL1NlYy1DSC1VQS1QbGF0Zm9ybS1WZXJzaW9uXCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiU2VjLUZldGNoLURlc3RcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL1NlYy1GZXRjaC1EZXN0XCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiU2VjLUZldGNoLU1vZGVcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL1NlYy1GZXRjaC1Nb2RlXCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiU2VjLUZldGNoLVNpdGVcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL1NlYy1GZXRjaC1TaXRlXCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiU2VjLUZldGNoLVVzZXJcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL1NlYy1GZXRjaC1Vc2VyXCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiU2VjLUdQQ1wiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvU2VjLUdQQ1wiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIlNlYy1QdXJwb3NlXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9TZWMtUHVycG9zZVwiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIlNlYy1XZWJTb2NrZXQtQWNjZXB0XCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9TZWMtV2ViU29ja2V0LUFjY2VwdFwiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIlNlcnZlclwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvU2VydmVyXCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiU2VydmVyLVRpbWluZ1wiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvU2VydmVyLVRpbWluZ1wiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIlNlcnZpY2UtV29ya2VyLU5hdmlnYXRpb24tUHJlbG9hZFwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvU2VydmljZS1Xb3JrZXItTmF2aWdhdGlvbi1QcmVsb2FkXCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiU2V0LUNvb2tpZVwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvU2V0LUNvb2tpZVwiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIlNvdXJjZU1hcFwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvU291cmNlTWFwXCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiU3RyaWN0LVRyYW5zcG9ydC1TZWN1cml0eVwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvU3RyaWN0LVRyYW5zcG9ydC1TZWN1cml0eVwiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIlRFXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9URVwiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIlRpbWluZy1BbGxvdy1PcmlnaW5cIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL1RpbWluZy1BbGxvdy1PcmlnaW5cIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJUa1wiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvVGtcIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJUcmFpbGVyXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9UcmFpbGVyXCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiVHJhbnNmZXItRW5jb2RpbmdcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL1RyYW5zZmVyLUVuY29kaW5nXCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiVXBncmFkZVwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvVXBncmFkZVwiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIlVwZ3JhZGUtSW5zZWN1cmUtUmVxdWVzdHNcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL1VwZ3JhZGUtSW5zZWN1cmUtUmVxdWVzdHNcIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJVc2VyLUFnZW50XCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9Vc2VyLUFnZW50XCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiVmFyeVwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvVmFyeVwiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIlZpYVwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvVmlhXCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiVmlld3BvcnQtV2lkdGhcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL1ZpZXdwb3J0LVdpZHRoXCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiV2FudC1EaWdlc3RcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL1dhbnQtRGlnZXN0XCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiV2FybmluZ1wiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvV2FybmluZ1wiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIldpZHRoXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9XaWR0aFwiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIldXVy1BdXRoZW50aWNhdGVcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL1dXVy1BdXRoZW50aWNhdGVcIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJYLUNvbnRlbnQtVHlwZS1PcHRpb25zXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9YLUNvbnRlbnQtVHlwZS1PcHRpb25zXCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiWC1ETlMtUHJlZmV0Y2gtQ29udHJvbFwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvWC1ETlMtUHJlZmV0Y2gtQ29udHJvbFwiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIk5vbi1zdGFuZGFyZFwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvTm9uLXN0YW5kYXJkXCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiWC1Gb3J3YXJkZWQtRm9yXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9YLUZvcndhcmRlZC1Gb3JcIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJOb24tc3RhbmRhcmRcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL05vbi1zdGFuZGFyZFwiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIlgtRm9yd2FyZGVkLUhvc3RcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL1gtRm9yd2FyZGVkLUhvc3RcIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJOb24tc3RhbmRhcmRcIixcbiAgICB1cmw6IFwiaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRUUC9IZWFkZXJzL05vbi1zdGFuZGFyZFwiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIlgtRm9yd2FyZGVkLVByb3RvXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9YLUZvcndhcmRlZC1Qcm90b1wiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIk5vbi1zdGFuZGFyZFwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvTm9uLXN0YW5kYXJkXCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiWC1GcmFtZS1PcHRpb25zXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9YLUZyYW1lLU9wdGlvbnNcIlxuICB9LFxuICB7XG4gICAgbmFtZTogXCJYLVhTUy1Qcm90ZWN0aW9uXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9YLVhTUy1Qcm90ZWN0aW9uXCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiQ2YtQ2FjaGUtU3RhdHVzXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVycy5jbG91ZGZsYXJlLmNvbS9jYWNoZS9jb25jZXB0cy9kZWZhdWx0LWNhY2hlLWJlaGF2aW9yLyNjbG91ZGZsYXJlLWNhY2hlLXJlc3BvbnNlc1wiXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBcIkNmLVJheVwiLFxuICAgIHVybDogXCJodHRwczovL2RldmVsb3BlcnMuY2xvdWRmbGFyZS5jb20vZnVuZGFtZW50YWxzL2dldC1zdGFydGVkL3JlZmVyZW5jZS9odHRwLXJlcXVlc3QtaGVhZGVycy8jY2YtcmF5XCJcbiAgfSxcbiAge1xuICAgIG5hbWU6IFwiUmVwb3J0LVRvXCIsXG4gICAgdXJsOiBcImh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUVFAvSGVhZGVycy9Db250ZW50LVNlY3VyaXR5LVBvbGljeS9yZXBvcnQtdG9cIlxuICB9XG5dLCBZUiA9IFtcbiAgXCJHRVRcIixcbiAgXCJQT1NUXCIsXG4gIFwiUFVUXCIsXG4gIFwiSEVBRFwiLFxuICBcIkRFTEVURVwiLFxuICBcIlBBVENIXCIsXG4gIFwiT1BUSU9OU1wiLFxuICBcIkNPTk5FQ1RcIixcbiAgXCJUUkFDRVwiXG5dO1xuZnVuY3Rpb24gamgodCkge1xuICByZXR1cm4gWVIuaW5jbHVkZXModCk7XG59XG5jb25zdCB6UiA9IHtcbiAgUE9TVDogXCJ2YXIoLS1zY2FsYXItY29sb3ItZ3JlZW4pXCIsXG4gIERFTEVURTogXCJ2YXIoLS1zY2FsYXItY29sb3ItcmVkKVwiLFxuICBQQVRDSDogXCJ2YXIoLS1zY2FsYXItY29sb3IteWVsbG93KVwiLFxuICBHRVQ6IFwidmFyKC0tc2NhbGFyLWNvbG9yLWJsdWUpXCIsXG4gIFBVVDogXCJ2YXIoLS1zY2FsYXItY29sb3Itb3JhbmdlKVwiLFxuICBPUFRJT05TOiBcInZhcigtLXNjYWxhci1jb2xvci1wdXJwbGUpXCIsXG4gIEhFQUQ6IFwidmFyKC0tc2NhbGFyLWNvbG9yLTIpXCIsXG4gIENPTk5FQ1Q6IFwidmFyKC0tc2NhbGFyLWNvbG9yLTIpXCIsXG4gIFRSQUNFOiBcInZhcigtLXNjYWxhci1jb2xvci0yKVwiXG59LCBIUiA9IHtcbiAgUE9TVDogXCJQT1NUXCIsXG4gIERFTEVURTogXCJERUxcIixcbiAgUEFUQ0g6IFwiUEFUQ0hcIixcbiAgR0VUOiBcIkdFVFwiLFxuICBQVVQ6IFwiUFVUXCIsXG4gIE9QVElPTlM6IFwiT1BUU1wiLFxuICBIRUFEOiBcIkhFQURcIixcbiAgQ09OTkVDVDogXCJDT05OXCIsXG4gIFRSQUNFOiBcIlRSQUNFXCJcbn0sIEZSID0gLyogQF9fUFVSRV9fICovIGxlKHtcbiAgX19uYW1lOiBcIkh0dHBNZXRob2RcIixcbiAgcHJvcHM6IHtcbiAgICBhczoge30sXG4gICAgcHJvcGVydHk6IHt9LFxuICAgIHNob3J0OiB7IHR5cGU6IEJvb2xlYW4gfSxcbiAgICBtZXRob2Q6IHt9XG4gIH0sXG4gIHNldHVwKHQpIHtcbiAgICBjb25zdCBlID0gdCwgbiA9IGooKCkgPT4gZS5tZXRob2QudHJpbSgpLnRvVXBwZXJDYXNlKCkpLCByID0gaigoKSA9PiBqaChuLnZhbHVlKSA/IEhSW24udmFsdWVdIDogbi52YWx1ZS5zbGljZSgwLCA0KSksIGkgPSBqKCgpID0+IGpoKG4udmFsdWUpID8gelJbbi52YWx1ZV0gOiBcInZhcigtLXNjYWxhci1jb2xvci1naG9zdClcIik7XG4gICAgcmV0dXJuIChzLCBvKSA9PiAoWigpLCBrZShabChzLmFzID8/IFwic3BhblwiKSwge1xuICAgICAgc3R5bGU6IEJyKHsgW3MucHJvcGVydHkgfHwgXCJjb2xvclwiXTogaS52YWx1ZSB9KVxuICAgIH0sIHtcbiAgICAgIGRlZmF1bHQ6IGNlKCgpID0+IFtcbiAgICAgICAgcHQocy4kc2xvdHMsIFwiZGVmYXVsdFwiLCBteShFTyh7IG5vcm1hbGl6ZWQ6IG4udmFsdWUsIGFiYnJldmlhdGVkOiByLnZhbHVlLCBjb2xvcjogaS52YWx1ZSB9KSksICgpID0+IFtcbiAgICAgICAgICBIZShEZShzLnNob3J0ID8gci52YWx1ZSA6IG4udmFsdWUpLCAxKVxuICAgICAgICBdKVxuICAgICAgXSksXG4gICAgICBfOiAzXG4gICAgfSwgOCwgW1wic3R5bGVcIl0pKTtcbiAgfVxufSk7XG5jbGFzcyBGZSB7XG4gIC8qKlxuICBHZXQgdGhlIGxpbmUgZGVzY3JpcHRpb24gYXJvdW5kIHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgKi9cbiAgbGluZUF0KGUpIHtcbiAgICBpZiAoZSA8IDAgfHwgZSA+IHRoaXMubGVuZ3RoKVxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgcG9zaXRpb24gJHtlfSBpbiBkb2N1bWVudCBvZiBsZW5ndGggJHt0aGlzLmxlbmd0aH1gKTtcbiAgICByZXR1cm4gdGhpcy5saW5lSW5uZXIoZSwgITEsIDEsIDApO1xuICB9XG4gIC8qKlxuICBHZXQgdGhlIGRlc2NyaXB0aW9uIGZvciB0aGUgZ2l2ZW4gKDEtYmFzZWQpIGxpbmUgbnVtYmVyLlxuICAqL1xuICBsaW5lKGUpIHtcbiAgICBpZiAoZSA8IDEgfHwgZSA+IHRoaXMubGluZXMpXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBsaW5lIG51bWJlciAke2V9IGluICR7dGhpcy5saW5lc30tbGluZSBkb2N1bWVudGApO1xuICAgIHJldHVybiB0aGlzLmxpbmVJbm5lcihlLCAhMCwgMSwgMCk7XG4gIH1cbiAgLyoqXG4gIFJlcGxhY2UgYSByYW5nZSBvZiB0aGUgdGV4dCB3aXRoIHRoZSBnaXZlbiBjb250ZW50LlxuICAqL1xuICByZXBsYWNlKGUsIG4sIHIpIHtcbiAgICBbZSwgbl0gPSBYbyh0aGlzLCBlLCBuKTtcbiAgICBsZXQgaSA9IFtdO1xuICAgIHJldHVybiB0aGlzLmRlY29tcG9zZShcbiAgICAgIDAsXG4gICAgICBlLFxuICAgICAgaSxcbiAgICAgIDJcbiAgICAgIC8qIE9wZW4uVG8gKi9cbiAgICApLCByLmxlbmd0aCAmJiByLmRlY29tcG9zZShcbiAgICAgIDAsXG4gICAgICByLmxlbmd0aCxcbiAgICAgIGksXG4gICAgICAzXG4gICAgICAvKiBPcGVuLlRvICovXG4gICAgKSwgdGhpcy5kZWNvbXBvc2UoXG4gICAgICBuLFxuICAgICAgdGhpcy5sZW5ndGgsXG4gICAgICBpLFxuICAgICAgMVxuICAgICAgLyogT3Blbi5Gcm9tICovXG4gICAgKSwgUXIuZnJvbShpLCB0aGlzLmxlbmd0aCAtIChuIC0gZSkgKyByLmxlbmd0aCk7XG4gIH1cbiAgLyoqXG4gIEFwcGVuZCBhbm90aGVyIGRvY3VtZW50IHRvIHRoaXMgb25lLlxuICAqL1xuICBhcHBlbmQoZSkge1xuICAgIHJldHVybiB0aGlzLnJlcGxhY2UodGhpcy5sZW5ndGgsIHRoaXMubGVuZ3RoLCBlKTtcbiAgfVxuICAvKipcbiAgUmV0cmlldmUgdGhlIHRleHQgYmV0d2VlbiB0aGUgZ2l2ZW4gcG9pbnRzLlxuICAqL1xuICBzbGljZShlLCBuID0gdGhpcy5sZW5ndGgpIHtcbiAgICBbZSwgbl0gPSBYbyh0aGlzLCBlLCBuKTtcbiAgICBsZXQgciA9IFtdO1xuICAgIHJldHVybiB0aGlzLmRlY29tcG9zZShlLCBuLCByLCAwKSwgUXIuZnJvbShyLCBuIC0gZSk7XG4gIH1cbiAgLyoqXG4gIFRlc3Qgd2hldGhlciB0aGlzIHRleHQgaXMgZXF1YWwgdG8gYW5vdGhlciBpbnN0YW5jZS5cbiAgKi9cbiAgZXEoZSkge1xuICAgIGlmIChlID09IHRoaXMpXG4gICAgICByZXR1cm4gITA7XG4gICAgaWYgKGUubGVuZ3RoICE9IHRoaXMubGVuZ3RoIHx8IGUubGluZXMgIT0gdGhpcy5saW5lcylcbiAgICAgIHJldHVybiAhMTtcbiAgICBsZXQgbiA9IHRoaXMuc2NhbklkZW50aWNhbChlLCAxKSwgciA9IHRoaXMubGVuZ3RoIC0gdGhpcy5zY2FuSWRlbnRpY2FsKGUsIC0xKSwgaSA9IG5ldyBxYSh0aGlzKSwgcyA9IG5ldyBxYShlKTtcbiAgICBmb3IgKGxldCBvID0gbiwgYSA9IG47IDsgKSB7XG4gICAgICBpZiAoaS5uZXh0KG8pLCBzLm5leHQobyksIG8gPSAwLCBpLmxpbmVCcmVhayAhPSBzLmxpbmVCcmVhayB8fCBpLmRvbmUgIT0gcy5kb25lIHx8IGkudmFsdWUgIT0gcy52YWx1ZSlcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgaWYgKGEgKz0gaS52YWx1ZS5sZW5ndGgsIGkuZG9uZSB8fCBhID49IHIpXG4gICAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gIEl0ZXJhdGUgb3ZlciB0aGUgdGV4dC4gV2hlbiBgZGlyYCBpcyBgLTFgLCBpdGVyYXRpb24gaGFwcGVuc1xuICBmcm9tIGVuZCB0byBzdGFydC4gVGhpcyB3aWxsIHJldHVybiBsaW5lcyBhbmQgdGhlIGJyZWFrcyBiZXR3ZWVuXG4gIHRoZW0gYXMgc2VwYXJhdGUgc3RyaW5ncy5cbiAgKi9cbiAgaXRlcihlID0gMSkge1xuICAgIHJldHVybiBuZXcgcWEodGhpcywgZSk7XG4gIH1cbiAgLyoqXG4gIEl0ZXJhdGUgb3ZlciBhIHJhbmdlIG9mIHRoZSB0ZXh0LiBXaGVuIGBmcm9tYCA+IGB0b2AsIHRoZVxuICBpdGVyYXRvciB3aWxsIHJ1biBpbiByZXZlcnNlLlxuICAqL1xuICBpdGVyUmFuZ2UoZSwgbiA9IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyBSdyh0aGlzLCBlLCBuKTtcbiAgfVxuICAvKipcbiAgUmV0dXJuIGEgY3Vyc29yIHRoYXQgaXRlcmF0ZXMgb3ZlciB0aGUgZ2l2ZW4gcmFuZ2Ugb2YgbGluZXMsXG4gIF93aXRob3V0XyByZXR1cm5pbmcgdGhlIGxpbmUgYnJlYWtzIGJldHdlZW4sIGFuZCB5aWVsZGluZyBlbXB0eVxuICBzdHJpbmdzIGZvciBlbXB0eSBsaW5lcy5cbiAgXG4gIFdoZW4gYGZyb21gIGFuZCBgdG9gIGFyZSBnaXZlbiwgdGhleSBzaG91bGQgYmUgMS1iYXNlZCBsaW5lIG51bWJlcnMuXG4gICovXG4gIGl0ZXJMaW5lcyhlLCBuKSB7XG4gICAgbGV0IHI7XG4gICAgaWYgKGUgPT0gbnVsbClcbiAgICAgIHIgPSB0aGlzLml0ZXIoKTtcbiAgICBlbHNlIHtcbiAgICAgIG4gPT0gbnVsbCAmJiAobiA9IHRoaXMubGluZXMgKyAxKTtcbiAgICAgIGxldCBpID0gdGhpcy5saW5lKGUpLmZyb207XG4gICAgICByID0gdGhpcy5pdGVyUmFuZ2UoaSwgTWF0aC5tYXgoaSwgbiA9PSB0aGlzLmxpbmVzICsgMSA/IHRoaXMubGVuZ3RoIDogbiA8PSAxID8gMCA6IHRoaXMubGluZShuIC0gMSkudG8pKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBOdyhyKTtcbiAgfVxuICAvKipcbiAgUmV0dXJuIHRoZSBkb2N1bWVudCBhcyBhIHN0cmluZywgdXNpbmcgbmV3bGluZSBjaGFyYWN0ZXJzIHRvXG4gIHNlcGFyYXRlIGxpbmVzLlxuICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5zbGljZVN0cmluZygwKTtcbiAgfVxuICAvKipcbiAgQ29udmVydCB0aGUgZG9jdW1lbnQgdG8gYW4gYXJyYXkgb2YgbGluZXMgKHdoaWNoIGNhbiBiZVxuICBkZXNlcmlhbGl6ZWQgYWdhaW4gdmlhIFtgVGV4dC5vZmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVGV4dF5vZikpLlxuICAqL1xuICB0b0pTT04oKSB7XG4gICAgbGV0IGUgPSBbXTtcbiAgICByZXR1cm4gdGhpcy5mbGF0dGVuKGUpLCBlO1xuICB9XG4gIC8qKlxuICBAaW50ZXJuYWxcbiAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gIH1cbiAgLyoqXG4gIENyZWF0ZSBhIGBUZXh0YCBpbnN0YW5jZSBmb3IgdGhlIGdpdmVuIGFycmF5IG9mIGxpbmVzLlxuICAqL1xuICBzdGF0aWMgb2YoZSkge1xuICAgIGlmIChlLmxlbmd0aCA9PSAwKVxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBIGRvY3VtZW50IG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgbGluZVwiKTtcbiAgICByZXR1cm4gZS5sZW5ndGggPT0gMSAmJiAhZVswXSA/IEZlLmVtcHR5IDogZS5sZW5ndGggPD0gMzIgPyBuZXcgd3QoZSkgOiBRci5mcm9tKHd0LnNwbGl0KGUsIFtdKSk7XG4gIH1cbn1cbmNsYXNzIHd0IGV4dGVuZHMgRmUge1xuICBjb25zdHJ1Y3RvcihlLCBuID0gR1IoZSkpIHtcbiAgICBzdXBlcigpLCB0aGlzLnRleHQgPSBlLCB0aGlzLmxlbmd0aCA9IG47XG4gIH1cbiAgZ2V0IGxpbmVzKCkge1xuICAgIHJldHVybiB0aGlzLnRleHQubGVuZ3RoO1xuICB9XG4gIGdldCBjaGlsZHJlbigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBsaW5lSW5uZXIoZSwgbiwgciwgaSkge1xuICAgIGZvciAobGV0IHMgPSAwOyA7IHMrKykge1xuICAgICAgbGV0IG8gPSB0aGlzLnRleHRbc10sIGEgPSBpICsgby5sZW5ndGg7XG4gICAgICBpZiAoKG4gPyByIDogYSkgPj0gZSlcbiAgICAgICAgcmV0dXJuIG5ldyBLUihpLCBhLCByLCBvKTtcbiAgICAgIGkgPSBhICsgMSwgcisrO1xuICAgIH1cbiAgfVxuICBkZWNvbXBvc2UoZSwgbiwgciwgaSkge1xuICAgIGxldCBzID0gZSA8PSAwICYmIG4gPj0gdGhpcy5sZW5ndGggPyB0aGlzIDogbmV3IHd0KFJiKHRoaXMudGV4dCwgZSwgbiksIE1hdGgubWluKG4sIHRoaXMubGVuZ3RoKSAtIE1hdGgubWF4KDAsIGUpKTtcbiAgICBpZiAoaSAmIDEpIHtcbiAgICAgIGxldCBvID0gci5wb3AoKSwgYSA9IHR1KHMudGV4dCwgby50ZXh0LnNsaWNlKCksIDAsIHMubGVuZ3RoKTtcbiAgICAgIGlmIChhLmxlbmd0aCA8PSAzMilcbiAgICAgICAgci5wdXNoKG5ldyB3dChhLCBvLmxlbmd0aCArIHMubGVuZ3RoKSk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgbGV0IGwgPSBhLmxlbmd0aCA+PiAxO1xuICAgICAgICByLnB1c2gobmV3IHd0KGEuc2xpY2UoMCwgbCkpLCBuZXcgd3QoYS5zbGljZShsKSkpO1xuICAgICAgfVxuICAgIH0gZWxzZVxuICAgICAgci5wdXNoKHMpO1xuICB9XG4gIHJlcGxhY2UoZSwgbiwgcikge1xuICAgIGlmICghKHIgaW5zdGFuY2VvZiB3dCkpXG4gICAgICByZXR1cm4gc3VwZXIucmVwbGFjZShlLCBuLCByKTtcbiAgICBbZSwgbl0gPSBYbyh0aGlzLCBlLCBuKTtcbiAgICBsZXQgaSA9IHR1KHRoaXMudGV4dCwgdHUoci50ZXh0LCBSYih0aGlzLnRleHQsIDAsIGUpKSwgbiksIHMgPSB0aGlzLmxlbmd0aCArIHIubGVuZ3RoIC0gKG4gLSBlKTtcbiAgICByZXR1cm4gaS5sZW5ndGggPD0gMzIgPyBuZXcgd3QoaSwgcykgOiBRci5mcm9tKHd0LnNwbGl0KGksIFtdKSwgcyk7XG4gIH1cbiAgc2xpY2VTdHJpbmcoZSwgbiA9IHRoaXMubGVuZ3RoLCByID0gYFxuYCkge1xuICAgIFtlLCBuXSA9IFhvKHRoaXMsIGUsIG4pO1xuICAgIGxldCBpID0gXCJcIjtcbiAgICBmb3IgKGxldCBzID0gMCwgbyA9IDA7IHMgPD0gbiAmJiBvIDwgdGhpcy50ZXh0Lmxlbmd0aDsgbysrKSB7XG4gICAgICBsZXQgYSA9IHRoaXMudGV4dFtvXSwgbCA9IHMgKyBhLmxlbmd0aDtcbiAgICAgIHMgPiBlICYmIG8gJiYgKGkgKz0gciksIGUgPCBsICYmIG4gPiBzICYmIChpICs9IGEuc2xpY2UoTWF0aC5tYXgoMCwgZSAtIHMpLCBuIC0gcykpLCBzID0gbCArIDE7XG4gICAgfVxuICAgIHJldHVybiBpO1xuICB9XG4gIGZsYXR0ZW4oZSkge1xuICAgIGZvciAobGV0IG4gb2YgdGhpcy50ZXh0KVxuICAgICAgZS5wdXNoKG4pO1xuICB9XG4gIHNjYW5JZGVudGljYWwoKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgc3RhdGljIHNwbGl0KGUsIG4pIHtcbiAgICBsZXQgciA9IFtdLCBpID0gLTE7XG4gICAgZm9yIChsZXQgcyBvZiBlKVxuICAgICAgci5wdXNoKHMpLCBpICs9IHMubGVuZ3RoICsgMSwgci5sZW5ndGggPT0gMzIgJiYgKG4ucHVzaChuZXcgd3QociwgaSkpLCByID0gW10sIGkgPSAtMSk7XG4gICAgcmV0dXJuIGkgPiAtMSAmJiBuLnB1c2gobmV3IHd0KHIsIGkpKSwgbjtcbiAgfVxufVxuY2xhc3MgUXIgZXh0ZW5kcyBGZSB7XG4gIGNvbnN0cnVjdG9yKGUsIG4pIHtcbiAgICBzdXBlcigpLCB0aGlzLmNoaWxkcmVuID0gZSwgdGhpcy5sZW5ndGggPSBuLCB0aGlzLmxpbmVzID0gMDtcbiAgICBmb3IgKGxldCByIG9mIGUpXG4gICAgICB0aGlzLmxpbmVzICs9IHIubGluZXM7XG4gIH1cbiAgbGluZUlubmVyKGUsIG4sIHIsIGkpIHtcbiAgICBmb3IgKGxldCBzID0gMDsgOyBzKyspIHtcbiAgICAgIGxldCBvID0gdGhpcy5jaGlsZHJlbltzXSwgYSA9IGkgKyBvLmxlbmd0aCwgbCA9IHIgKyBvLmxpbmVzIC0gMTtcbiAgICAgIGlmICgobiA/IGwgOiBhKSA+PSBlKVxuICAgICAgICByZXR1cm4gby5saW5lSW5uZXIoZSwgbiwgciwgaSk7XG4gICAgICBpID0gYSArIDEsIHIgPSBsICsgMTtcbiAgICB9XG4gIH1cbiAgZGVjb21wb3NlKGUsIG4sIHIsIGkpIHtcbiAgICBmb3IgKGxldCBzID0gMCwgbyA9IDA7IG8gPD0gbiAmJiBzIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IHMrKykge1xuICAgICAgbGV0IGEgPSB0aGlzLmNoaWxkcmVuW3NdLCBsID0gbyArIGEubGVuZ3RoO1xuICAgICAgaWYgKGUgPD0gbCAmJiBuID49IG8pIHtcbiAgICAgICAgbGV0IGMgPSBpICYgKChvIDw9IGUgPyAxIDogMCkgfCAobCA+PSBuID8gMiA6IDApKTtcbiAgICAgICAgbyA+PSBlICYmIGwgPD0gbiAmJiAhYyA/IHIucHVzaChhKSA6IGEuZGVjb21wb3NlKGUgLSBvLCBuIC0gbywgciwgYyk7XG4gICAgICB9XG4gICAgICBvID0gbCArIDE7XG4gICAgfVxuICB9XG4gIHJlcGxhY2UoZSwgbiwgcikge1xuICAgIGlmIChbZSwgbl0gPSBYbyh0aGlzLCBlLCBuKSwgci5saW5lcyA8IHRoaXMubGluZXMpXG4gICAgICBmb3IgKGxldCBpID0gMCwgcyA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBvID0gdGhpcy5jaGlsZHJlbltpXSwgYSA9IHMgKyBvLmxlbmd0aDtcbiAgICAgICAgaWYgKGUgPj0gcyAmJiBuIDw9IGEpIHtcbiAgICAgICAgICBsZXQgbCA9IG8ucmVwbGFjZShlIC0gcywgbiAtIHMsIHIpLCBjID0gdGhpcy5saW5lcyAtIG8ubGluZXMgKyBsLmxpbmVzO1xuICAgICAgICAgIGlmIChsLmxpbmVzIDwgYyA+PiA0ICYmIGwubGluZXMgPiBjID4+IDYpIHtcbiAgICAgICAgICAgIGxldCB1ID0gdGhpcy5jaGlsZHJlbi5zbGljZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHVbaV0gPSBsLCBuZXcgUXIodSwgdGhpcy5sZW5ndGggLSAobiAtIGUpICsgci5sZW5ndGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3VwZXIucmVwbGFjZShzLCBhLCBsKTtcbiAgICAgICAgfVxuICAgICAgICBzID0gYSArIDE7XG4gICAgICB9XG4gICAgcmV0dXJuIHN1cGVyLnJlcGxhY2UoZSwgbiwgcik7XG4gIH1cbiAgc2xpY2VTdHJpbmcoZSwgbiA9IHRoaXMubGVuZ3RoLCByID0gYFxuYCkge1xuICAgIFtlLCBuXSA9IFhvKHRoaXMsIGUsIG4pO1xuICAgIGxldCBpID0gXCJcIjtcbiAgICBmb3IgKGxldCBzID0gMCwgbyA9IDA7IHMgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aCAmJiBvIDw9IG47IHMrKykge1xuICAgICAgbGV0IGEgPSB0aGlzLmNoaWxkcmVuW3NdLCBsID0gbyArIGEubGVuZ3RoO1xuICAgICAgbyA+IGUgJiYgcyAmJiAoaSArPSByKSwgZSA8IGwgJiYgbiA+IG8gJiYgKGkgKz0gYS5zbGljZVN0cmluZyhlIC0gbywgbiAtIG8sIHIpKSwgbyA9IGwgKyAxO1xuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfVxuICBmbGF0dGVuKGUpIHtcbiAgICBmb3IgKGxldCBuIG9mIHRoaXMuY2hpbGRyZW4pXG4gICAgICBuLmZsYXR0ZW4oZSk7XG4gIH1cbiAgc2NhbklkZW50aWNhbChlLCBuKSB7XG4gICAgaWYgKCEoZSBpbnN0YW5jZW9mIFFyKSlcbiAgICAgIHJldHVybiAwO1xuICAgIGxldCByID0gMCwgW2ksIHMsIG8sIGFdID0gbiA+IDAgPyBbMCwgMCwgdGhpcy5jaGlsZHJlbi5sZW5ndGgsIGUuY2hpbGRyZW4ubGVuZ3RoXSA6IFt0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDEsIGUuY2hpbGRyZW4ubGVuZ3RoIC0gMSwgLTEsIC0xXTtcbiAgICBmb3IgKDsgOyBpICs9IG4sIHMgKz0gbikge1xuICAgICAgaWYgKGkgPT0gbyB8fCBzID09IGEpXG4gICAgICAgIHJldHVybiByO1xuICAgICAgbGV0IGwgPSB0aGlzLmNoaWxkcmVuW2ldLCBjID0gZS5jaGlsZHJlbltzXTtcbiAgICAgIGlmIChsICE9IGMpXG4gICAgICAgIHJldHVybiByICsgbC5zY2FuSWRlbnRpY2FsKGMsIG4pO1xuICAgICAgciArPSBsLmxlbmd0aCArIDE7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBmcm9tKGUsIG4gPSBlLnJlZHVjZSgociwgaSkgPT4gciArIGkubGVuZ3RoICsgMSwgLTEpKSB7XG4gICAgbGV0IHIgPSAwO1xuICAgIGZvciAobGV0IGggb2YgZSlcbiAgICAgIHIgKz0gaC5saW5lcztcbiAgICBpZiAociA8IDMyKSB7XG4gICAgICBsZXQgaCA9IFtdO1xuICAgICAgZm9yIChsZXQgcCBvZiBlKVxuICAgICAgICBwLmZsYXR0ZW4oaCk7XG4gICAgICByZXR1cm4gbmV3IHd0KGgsIG4pO1xuICAgIH1cbiAgICBsZXQgaSA9IE1hdGgubWF4KFxuICAgICAgMzIsXG4gICAgICByID4+IDVcbiAgICAgIC8qIFRyZWUuQnJhbmNoU2hpZnQgKi9cbiAgICApLCBzID0gaSA8PCAxLCBvID0gaSA+PiAxLCBhID0gW10sIGwgPSAwLCBjID0gLTEsIHUgPSBbXTtcbiAgICBmdW5jdGlvbiBkKGgpIHtcbiAgICAgIGxldCBwO1xuICAgICAgaWYgKGgubGluZXMgPiBzICYmIGggaW5zdGFuY2VvZiBRcilcbiAgICAgICAgZm9yIChsZXQgTyBvZiBoLmNoaWxkcmVuKVxuICAgICAgICAgIGQoTyk7XG4gICAgICBlbHNlXG4gICAgICAgIGgubGluZXMgPiBvICYmIChsID4gbyB8fCAhbCkgPyAoZigpLCBhLnB1c2goaCkpIDogaCBpbnN0YW5jZW9mIHd0ICYmIGwgJiYgKHAgPSB1W3UubGVuZ3RoIC0gMV0pIGluc3RhbmNlb2Ygd3QgJiYgaC5saW5lcyArIHAubGluZXMgPD0gMzIgPyAobCArPSBoLmxpbmVzLCBjICs9IGgubGVuZ3RoICsgMSwgdVt1Lmxlbmd0aCAtIDFdID0gbmV3IHd0KHAudGV4dC5jb25jYXQoaC50ZXh0KSwgcC5sZW5ndGggKyAxICsgaC5sZW5ndGgpKSA6IChsICsgaC5saW5lcyA+IGkgJiYgZigpLCBsICs9IGgubGluZXMsIGMgKz0gaC5sZW5ndGggKyAxLCB1LnB1c2goaCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmKCkge1xuICAgICAgbCAhPSAwICYmIChhLnB1c2godS5sZW5ndGggPT0gMSA/IHVbMF0gOiBRci5mcm9tKHUsIGMpKSwgYyA9IC0xLCBsID0gdS5sZW5ndGggPSAwKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaCBvZiBlKVxuICAgICAgZChoKTtcbiAgICByZXR1cm4gZigpLCBhLmxlbmd0aCA9PSAxID8gYVswXSA6IG5ldyBRcihhLCBuKTtcbiAgfVxufVxuRmUuZW1wdHkgPSAvKiBAX19QVVJFX18gKi8gbmV3IHd0KFtcIlwiXSwgMCk7XG5mdW5jdGlvbiBHUih0KSB7XG4gIGxldCBlID0gLTE7XG4gIGZvciAobGV0IG4gb2YgdClcbiAgICBlICs9IG4ubGVuZ3RoICsgMTtcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiB0dSh0LCBlLCBuID0gMCwgciA9IDFlOSkge1xuICBmb3IgKGxldCBpID0gMCwgcyA9IDAsIG8gPSAhMDsgcyA8IHQubGVuZ3RoICYmIGkgPD0gcjsgcysrKSB7XG4gICAgbGV0IGEgPSB0W3NdLCBsID0gaSArIGEubGVuZ3RoO1xuICAgIGwgPj0gbiAmJiAobCA+IHIgJiYgKGEgPSBhLnNsaWNlKDAsIHIgLSBpKSksIGkgPCBuICYmIChhID0gYS5zbGljZShuIC0gaSkpLCBvID8gKGVbZS5sZW5ndGggLSAxXSArPSBhLCBvID0gITEpIDogZS5wdXNoKGEpKSwgaSA9IGwgKyAxO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gUmIodCwgZSwgbikge1xuICByZXR1cm4gdHUodCwgW1wiXCJdLCBlLCBuKTtcbn1cbmNsYXNzIHFhIHtcbiAgY29uc3RydWN0b3IoZSwgbiA9IDEpIHtcbiAgICB0aGlzLmRpciA9IG4sIHRoaXMuZG9uZSA9ICExLCB0aGlzLmxpbmVCcmVhayA9ICExLCB0aGlzLnZhbHVlID0gXCJcIiwgdGhpcy5ub2RlcyA9IFtlXSwgdGhpcy5vZmZzZXRzID0gW24gPiAwID8gMSA6IChlIGluc3RhbmNlb2Ygd3QgPyBlLnRleHQubGVuZ3RoIDogZS5jaGlsZHJlbi5sZW5ndGgpIDw8IDFdO1xuICB9XG4gIG5leHRJbm5lcihlLCBuKSB7XG4gICAgZm9yICh0aGlzLmRvbmUgPSB0aGlzLmxpbmVCcmVhayA9ICExOyA7ICkge1xuICAgICAgbGV0IHIgPSB0aGlzLm5vZGVzLmxlbmd0aCAtIDEsIGkgPSB0aGlzLm5vZGVzW3JdLCBzID0gdGhpcy5vZmZzZXRzW3JdLCBvID0gcyA+PiAxLCBhID0gaSBpbnN0YW5jZW9mIHd0ID8gaS50ZXh0Lmxlbmd0aCA6IGkuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgaWYgKG8gPT0gKG4gPiAwID8gYSA6IDApKSB7XG4gICAgICAgIGlmIChyID09IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZG9uZSA9ICEwLCB0aGlzLnZhbHVlID0gXCJcIiwgdGhpcztcbiAgICAgICAgbiA+IDAgJiYgdGhpcy5vZmZzZXRzW3IgLSAxXSsrLCB0aGlzLm5vZGVzLnBvcCgpLCB0aGlzLm9mZnNldHMucG9wKCk7XG4gICAgICB9IGVsc2UgaWYgKChzICYgMSkgPT0gKG4gPiAwID8gMCA6IDEpKSB7XG4gICAgICAgIGlmICh0aGlzLm9mZnNldHNbcl0gKz0gbiwgZSA9PSAwKVxuICAgICAgICAgIHJldHVybiB0aGlzLmxpbmVCcmVhayA9ICEwLCB0aGlzLnZhbHVlID0gYFxuYCwgdGhpcztcbiAgICAgICAgZS0tO1xuICAgICAgfSBlbHNlIGlmIChpIGluc3RhbmNlb2Ygd3QpIHtcbiAgICAgICAgbGV0IGwgPSBpLnRleHRbbyArIChuIDwgMCA/IC0xIDogMCldO1xuICAgICAgICBpZiAodGhpcy5vZmZzZXRzW3JdICs9IG4sIGwubGVuZ3RoID4gTWF0aC5tYXgoMCwgZSkpXG4gICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPSBlID09IDAgPyBsIDogbiA+IDAgPyBsLnNsaWNlKGUpIDogbC5zbGljZSgwLCBsLmxlbmd0aCAtIGUpLCB0aGlzO1xuICAgICAgICBlIC09IGwubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGwgPSBpLmNoaWxkcmVuW28gKyAobiA8IDAgPyAtMSA6IDApXTtcbiAgICAgICAgZSA+IGwubGVuZ3RoID8gKGUgLT0gbC5sZW5ndGgsIHRoaXMub2Zmc2V0c1tyXSArPSBuKSA6IChuIDwgMCAmJiB0aGlzLm9mZnNldHNbcl0tLSwgdGhpcy5ub2Rlcy5wdXNoKGwpLCB0aGlzLm9mZnNldHMucHVzaChuID4gMCA/IDEgOiAobCBpbnN0YW5jZW9mIHd0ID8gbC50ZXh0Lmxlbmd0aCA6IGwuY2hpbGRyZW4ubGVuZ3RoKSA8PCAxKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG5leHQoZSA9IDApIHtcbiAgICByZXR1cm4gZSA8IDAgJiYgKHRoaXMubmV4dElubmVyKC1lLCAtdGhpcy5kaXIpLCBlID0gdGhpcy52YWx1ZS5sZW5ndGgpLCB0aGlzLm5leHRJbm5lcihlLCB0aGlzLmRpcik7XG4gIH1cbn1cbmNsYXNzIFJ3IHtcbiAgY29uc3RydWN0b3IoZSwgbiwgcikge1xuICAgIHRoaXMudmFsdWUgPSBcIlwiLCB0aGlzLmRvbmUgPSAhMSwgdGhpcy5jdXJzb3IgPSBuZXcgcWEoZSwgbiA+IHIgPyAtMSA6IDEpLCB0aGlzLnBvcyA9IG4gPiByID8gZS5sZW5ndGggOiAwLCB0aGlzLmZyb20gPSBNYXRoLm1pbihuLCByKSwgdGhpcy50byA9IE1hdGgubWF4KG4sIHIpO1xuICB9XG4gIG5leHRJbm5lcihlLCBuKSB7XG4gICAgaWYgKG4gPCAwID8gdGhpcy5wb3MgPD0gdGhpcy5mcm9tIDogdGhpcy5wb3MgPj0gdGhpcy50bylcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlID0gXCJcIiwgdGhpcy5kb25lID0gITAsIHRoaXM7XG4gICAgZSArPSBNYXRoLm1heCgwLCBuIDwgMCA/IHRoaXMucG9zIC0gdGhpcy50byA6IHRoaXMuZnJvbSAtIHRoaXMucG9zKTtcbiAgICBsZXQgciA9IG4gPCAwID8gdGhpcy5wb3MgLSB0aGlzLmZyb20gOiB0aGlzLnRvIC0gdGhpcy5wb3M7XG4gICAgZSA+IHIgJiYgKGUgPSByKSwgciAtPSBlO1xuICAgIGxldCB7IHZhbHVlOiBpIH0gPSB0aGlzLmN1cnNvci5uZXh0KGUpO1xuICAgIHJldHVybiB0aGlzLnBvcyArPSAoaS5sZW5ndGggKyBlKSAqIG4sIHRoaXMudmFsdWUgPSBpLmxlbmd0aCA8PSByID8gaSA6IG4gPCAwID8gaS5zbGljZShpLmxlbmd0aCAtIHIpIDogaS5zbGljZSgwLCByKSwgdGhpcy5kb25lID0gIXRoaXMudmFsdWUsIHRoaXM7XG4gIH1cbiAgbmV4dChlID0gMCkge1xuICAgIHJldHVybiBlIDwgMCA/IGUgPSBNYXRoLm1heChlLCB0aGlzLmZyb20gLSB0aGlzLnBvcykgOiBlID4gMCAmJiAoZSA9IE1hdGgubWluKGUsIHRoaXMudG8gLSB0aGlzLnBvcykpLCB0aGlzLm5leHRJbm5lcihlLCB0aGlzLmN1cnNvci5kaXIpO1xuICB9XG4gIGdldCBsaW5lQnJlYWsoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3Vyc29yLmxpbmVCcmVhayAmJiB0aGlzLnZhbHVlICE9IFwiXCI7XG4gIH1cbn1cbmNsYXNzIE53IHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMuaW5uZXIgPSBlLCB0aGlzLmFmdGVyQnJlYWsgPSAhMCwgdGhpcy52YWx1ZSA9IFwiXCIsIHRoaXMuZG9uZSA9ICExO1xuICB9XG4gIG5leHQoZSA9IDApIHtcbiAgICBsZXQgeyBkb25lOiBuLCBsaW5lQnJlYWs6IHIsIHZhbHVlOiBpIH0gPSB0aGlzLmlubmVyLm5leHQoZSk7XG4gICAgcmV0dXJuIG4gJiYgdGhpcy5hZnRlckJyZWFrID8gKHRoaXMudmFsdWUgPSBcIlwiLCB0aGlzLmFmdGVyQnJlYWsgPSAhMSkgOiBuID8gKHRoaXMuZG9uZSA9ICEwLCB0aGlzLnZhbHVlID0gXCJcIikgOiByID8gdGhpcy5hZnRlckJyZWFrID8gdGhpcy52YWx1ZSA9IFwiXCIgOiAodGhpcy5hZnRlckJyZWFrID0gITAsIHRoaXMubmV4dCgpKSA6ICh0aGlzLnZhbHVlID0gaSwgdGhpcy5hZnRlckJyZWFrID0gITEpLCB0aGlzO1xuICB9XG4gIGdldCBsaW5lQnJlYWsoKSB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG50eXBlb2YgU3ltYm9sIDwgXCJ1XCIgJiYgKEZlLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLml0ZXIoKTtcbn0sIHFhLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gUncucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBOdy5wcm90b3R5cGVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcztcbn0pO1xuY2xhc3MgS1Ige1xuICAvKipcbiAgQGludGVybmFsXG4gICovXG4gIGNvbnN0cnVjdG9yKGUsIG4sIHIsIGkpIHtcbiAgICB0aGlzLmZyb20gPSBlLCB0aGlzLnRvID0gbiwgdGhpcy5udW1iZXIgPSByLCB0aGlzLnRleHQgPSBpO1xuICB9XG4gIC8qKlxuICBUaGUgbGVuZ3RoIG9mIHRoZSBsaW5lIChub3QgaW5jbHVkaW5nIGFueSBsaW5lIGJyZWFrIGFmdGVyIGl0KS5cbiAgKi9cbiAgZ2V0IGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy50byAtIHRoaXMuZnJvbTtcbiAgfVxufVxuZnVuY3Rpb24gWG8odCwgZSwgbikge1xuICByZXR1cm4gZSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHQubGVuZ3RoLCBlKSksIFtlLCBNYXRoLm1heChlLCBNYXRoLm1pbih0Lmxlbmd0aCwgbikpXTtcbn1cbmxldCBQbyA9IC8qIEBfX1BVUkVfXyAqLyBcImxjLDM0LDduLDcsN2IsMTksLCwsMiwsMiwsLDIwLGIsMWMsbCxnLCwydCw3LDIsNiwyLDIsLDQseiwsdSxyLDJqLGIsMW0sOSw5LCxvLDQsLDksLDMsLDUsMTcsMywzYixmLCx3LDFqLCwsLDQsOCw0LCwzLDcsYSwyLHQsLDFtLCwsLDIsNCw4LCw5LCxhLDIscSwsMiwyLDFsLCw0LDIsNCwyLDIsMywzLCx1LDIsMywsYiwyLDFsLCw0LDUsLDIsNCwsaywyLG0sNiwsLDFtLCwsMiwsNCw4LCw3LDMsYSwyLHUsLDFuLCwsLGMsLDksLDE0LCwzLCwxbCwzLDUsMywsNCw3LDIsYiwyLHQsLDFtLCwyLCwyLCwzLCw1LDIsNywyLGIsMixzLDIsMWwsMiwsLDIsNCw4LCw5LCxhLDIsdCwsMjAsLDQsLDIsMywsLDgsLDI5LCwyLDcsYyw4LDJxLCwyLDksYiw2LDIyLDIsciwsLCwsLDFqLGUsLDUsLDIsNSxiLCwxMCw5LCwydSw0LCw2LCwyLDIsMixwLDIsNCwzLGcsNCxkLCwyLDIsNiwsZiwsamosMyxxYSwzLHQsMyx0LDIsdSwyLDFzLDIsLDcsOCwsMixiLDksLDE5LDMsM2IsMix5LCwzYSwzLDQsMiw5LCw2LDMsNjMsMiwyLCwxbSwsLDcsLCwsLDIsOCw2LGEsMiwsMWMsaCwxciw0LDFjLDcsLCw1LCwxNCw5LGMsMix3LDQsMiwyLCwzLDFrLCwsMiwzLCwsMywxbSw4LDIsMiw0OCwzLCxkLCw3LDQsLDYsLDMsMiw1aSwxbSwsNSxlaywsNWYseCwyZGEsMywzeCwsMm8sdyxmZSw2LDJ4LDIsbjl3LDQsLGEsdywyLDI4LDIsN2ssLDMsLDQsLHAsMiw1LCw0NywyLHEsaSxkLCwxMiw4LHAsYiwxYSwzLDFjLCwyLDQsMiwyLDEzLCwxdiw2LDIsMiwyLDIsYywsOCwsMWIsLDFmLCwsMywyLDIsNSwyLCwsMTYsMiw4LCw2bSwsMiwsNCwsZm40LCxraCxnLGcsZyxhNiwyLGd0LCw2YSwsNDUsNSwxYWUsMywsMiw1LDQsMTQsMyw0LCw0bCwyLGZ4LDQsYXIsMiw0OSxiLDR3LCwxaSxmLDFrLDMsMWQsNCwyLDIsMXgsMywxMCw1LCw4LDFxLCxjLDIsMWcsOSxhLDQsMiwsMm4sMywyLCwsMiw2LCw0ZywsMyw4LGwsMiwxbCwyLCwsLCxtLCxlLDcsMyw1LDVmLDgsMiwzLCwsbiwsMjksLDIsNiwsLDIsLCwyLCwyLDZqLCwyLDQsNiwyLCwyLHIsMiwyZCw4LDIsLCwyLDJ5LCwsLDIsNiwsLDJ0LDMsMiw0LCw1LDc3LDksLDIsNnQsLGEsMiwsLDQsLDQwLDQsMiwyLDQsLHcsYSwxNCw2LDIsNCw4LCw5LDYsMiwzLDFhLGQsLDIsYmEsNywsNiwsLDJhLG0sMiw3LCwyLCwyLDNlLDYsMywsLDIsLDcsLCwyMCwyLDMsLCwsOW4sMixmMGIsNSwxbiw3LHQ0LCwxciw0LDI5LCxmNWssMiw0M3EsLCwzLDQsNSw4LDgsMiw3LHUsNCw0NCwzLDFpeiwxaiw0LDFlLDgsLGUsLG0sNSwsZiwxMXMsNywsaCwyLDcsLDIsLDUsNzksNyxjNSw0LDE1cyw3LDMxLDcsMjQwLDUsZ3g3aywybywzayw2b1wiLnNwbGl0KFwiLFwiKS5tYXAoKHQpID0+IHQgPyBwYXJzZUludCh0LCAzNikgOiAxKTtcbmZvciAobGV0IHQgPSAxOyB0IDwgUG8ubGVuZ3RoOyB0KyspXG4gIFBvW3RdICs9IFBvW3QgLSAxXTtcbmZ1bmN0aW9uIEpSKHQpIHtcbiAgZm9yIChsZXQgZSA9IDE7IGUgPCBQby5sZW5ndGg7IGUgKz0gMilcbiAgICBpZiAoUG9bZV0gPiB0KVxuICAgICAgcmV0dXJuIFBvW2UgLSAxXSA8PSB0O1xuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBOYih0KSB7XG4gIHJldHVybiB0ID49IDEyNzQ2MiAmJiB0IDw9IDEyNzQ4Nztcbn1cbmNvbnN0IERiID0gODIwNTtcbmZ1bmN0aW9uIFJyKHQsIGUsIG4gPSAhMCwgciA9ICEwKSB7XG4gIHJldHVybiAobiA/IER3IDogZU4pKHQsIGUsIHIpO1xufVxuZnVuY3Rpb24gRHcodCwgZSwgbikge1xuICBpZiAoZSA9PSB0Lmxlbmd0aClcbiAgICByZXR1cm4gZTtcbiAgZSAmJiBadyh0LmNoYXJDb2RlQXQoZSkpICYmIFZ3KHQuY2hhckNvZGVBdChlIC0gMSkpICYmIGUtLTtcbiAgbGV0IHIgPSBubih0LCBlKTtcbiAgZm9yIChlICs9IGNyKHIpOyBlIDwgdC5sZW5ndGg7ICkge1xuICAgIGxldCBpID0gbm4odCwgZSk7XG4gICAgaWYgKHIgPT0gRGIgfHwgaSA9PSBEYiB8fCBuICYmIEpSKGkpKVxuICAgICAgZSArPSBjcihpKSwgciA9IGk7XG4gICAgZWxzZSBpZiAoTmIoaSkpIHtcbiAgICAgIGxldCBzID0gMCwgbyA9IGUgLSAyO1xuICAgICAgZm9yICg7IG8gPj0gMCAmJiBOYihubih0LCBvKSk7IClcbiAgICAgICAgcysrLCBvIC09IDI7XG4gICAgICBpZiAocyAlIDIgPT0gMClcbiAgICAgICAgYnJlYWs7XG4gICAgICBlICs9IDI7XG4gICAgfSBlbHNlXG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIGVOKHQsIGUsIG4pIHtcbiAgZm9yICg7IGUgPiAwOyApIHtcbiAgICBsZXQgciA9IER3KHQsIGUgLSAyLCBuKTtcbiAgICBpZiAociA8IGUpXG4gICAgICByZXR1cm4gcjtcbiAgICBlLS07XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBadyh0KSB7XG4gIHJldHVybiB0ID49IDU2MzIwICYmIHQgPCA1NzM0NDtcbn1cbmZ1bmN0aW9uIFZ3KHQpIHtcbiAgcmV0dXJuIHQgPj0gNTUyOTYgJiYgdCA8IDU2MzIwO1xufVxuZnVuY3Rpb24gbm4odCwgZSkge1xuICBsZXQgbiA9IHQuY2hhckNvZGVBdChlKTtcbiAgaWYgKCFWdyhuKSB8fCBlICsgMSA9PSB0Lmxlbmd0aClcbiAgICByZXR1cm4gbjtcbiAgbGV0IHIgPSB0LmNoYXJDb2RlQXQoZSArIDEpO1xuICByZXR1cm4gWncocikgPyAobiAtIDU1Mjk2IDw8IDEwKSArIChyIC0gNTYzMjApICsgNjU1MzYgOiBuO1xufVxuZnVuY3Rpb24gSXcodCkge1xuICByZXR1cm4gdCA8PSA2NTUzNSA/IFN0cmluZy5mcm9tQ2hhckNvZGUodCkgOiAodCAtPSA2NTUzNiwgU3RyaW5nLmZyb21DaGFyQ29kZSgodCA+PiAxMCkgKyA1NTI5NiwgKHQgJiAxMDIzKSArIDU2MzIwKSk7XG59XG5mdW5jdGlvbiBjcih0KSB7XG4gIHJldHVybiB0IDwgNjU1MzYgPyAxIDogMjtcbn1cbmNvbnN0IEJoID0gL1xcclxcbj98XFxuLztcbnZhciBvbiA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbih0KSB7XG4gIHJldHVybiB0W3QuU2ltcGxlID0gMF0gPSBcIlNpbXBsZVwiLCB0W3QuVHJhY2tEZWwgPSAxXSA9IFwiVHJhY2tEZWxcIiwgdFt0LlRyYWNrQmVmb3JlID0gMl0gPSBcIlRyYWNrQmVmb3JlXCIsIHRbdC5UcmFja0FmdGVyID0gM10gPSBcIlRyYWNrQWZ0ZXJcIiwgdDtcbn0ob24gfHwgKG9uID0ge30pKTtcbmNsYXNzIGlpIHtcbiAgLy8gU2VjdGlvbnMgYXJlIGVuY29kZWQgYXMgcGFpcnMgb2YgaW50ZWdlcnMuIFRoZSBmaXJzdCBpcyB0aGVcbiAgLy8gbGVuZ3RoIGluIHRoZSBjdXJyZW50IGRvY3VtZW50LCBhbmQgdGhlIHNlY29uZCBpcyAtMSBmb3JcbiAgLy8gdW5hZmZlY3RlZCBzZWN0aW9ucywgYW5kIHRoZSBsZW5ndGggb2YgdGhlIHJlcGxhY2VtZW50IGNvbnRlbnRcbiAgLy8gb3RoZXJ3aXNlLiBTbyBhbiBpbnNlcnRpb24gd291bGQgYmUgKDAsIG4+MCksIGEgZGVsZXRpb24gKG4+MCxcbiAgLy8gMCksIGFuZCBhIHJlcGxhY2VtZW50IHR3byBwb3NpdGl2ZSBudW1iZXJzLlxuICAvKipcbiAgQGludGVybmFsXG4gICovXG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLnNlY3Rpb25zID0gZTtcbiAgfVxuICAvKipcbiAgVGhlIGxlbmd0aCBvZiB0aGUgZG9jdW1lbnQgYmVmb3JlIHRoZSBjaGFuZ2UuXG4gICovXG4gIGdldCBsZW5ndGgoKSB7XG4gICAgbGV0IGUgPSAwO1xuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGg7IG4gKz0gMilcbiAgICAgIGUgKz0gdGhpcy5zZWN0aW9uc1tuXTtcbiAgICByZXR1cm4gZTtcbiAgfVxuICAvKipcbiAgVGhlIGxlbmd0aCBvZiB0aGUgZG9jdW1lbnQgYWZ0ZXIgdGhlIGNoYW5nZS5cbiAgKi9cbiAgZ2V0IG5ld0xlbmd0aCgpIHtcbiAgICBsZXQgZSA9IDA7XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDsgbiArPSAyKSB7XG4gICAgICBsZXQgciA9IHRoaXMuc2VjdGlvbnNbbiArIDFdO1xuICAgICAgZSArPSByIDwgMCA/IHRoaXMuc2VjdGlvbnNbbl0gOiByO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfVxuICAvKipcbiAgRmFsc2Ugd2hlbiB0aGVyZSBhcmUgYWN0dWFsIGNoYW5nZXMgaW4gdGhpcyBzZXQuXG4gICovXG4gIGdldCBlbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5zZWN0aW9ucy5sZW5ndGggPT0gMCB8fCB0aGlzLnNlY3Rpb25zLmxlbmd0aCA9PSAyICYmIHRoaXMuc2VjdGlvbnNbMV0gPCAwO1xuICB9XG4gIC8qKlxuICBJdGVyYXRlIG92ZXIgdGhlIHVuY2hhbmdlZCBwYXJ0cyBsZWZ0IGJ5IHRoZXNlIGNoYW5nZXMuIGBwb3NBYFxuICBwcm92aWRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIHJhbmdlIGluIHRoZSBvbGQgZG9jdW1lbnQsIGBwb3NCYFxuICB0aGUgbmV3IHBvc2l0aW9uIGluIHRoZSBjaGFuZ2VkIGRvY3VtZW50LlxuICAqL1xuICBpdGVyR2FwcyhlKSB7XG4gICAgZm9yIChsZXQgbiA9IDAsIHIgPSAwLCBpID0gMDsgbiA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOyApIHtcbiAgICAgIGxldCBzID0gdGhpcy5zZWN0aW9uc1tuKytdLCBvID0gdGhpcy5zZWN0aW9uc1tuKytdO1xuICAgICAgbyA8IDAgPyAoZShyLCBpLCBzKSwgaSArPSBzKSA6IGkgKz0gbywgciArPSBzO1xuICAgIH1cbiAgfVxuICAvKipcbiAgSXRlcmF0ZSBvdmVyIHRoZSByYW5nZXMgY2hhbmdlZCBieSB0aGVzZSBjaGFuZ2VzLiAoU2VlXG4gIFtgQ2hhbmdlU2V0Lml0ZXJDaGFuZ2VzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VTZXQuaXRlckNoYW5nZXMpIGZvciBhXG4gIHZhcmlhbnQgdGhhdCBhbHNvIHByb3ZpZGVzIHlvdSB3aXRoIHRoZSBpbnNlcnRlZCB0ZXh0LilcbiAgYGZyb21BYC9gdG9BYCBwcm92aWRlcyB0aGUgZXh0ZW50IG9mIHRoZSBjaGFuZ2UgaW4gdGhlIHN0YXJ0aW5nXG4gIGRvY3VtZW50LCBgZnJvbUJgL2B0b0JgIHRoZSBleHRlbnQgb2YgdGhlIHJlcGxhY2VtZW50IGluIHRoZVxuICBjaGFuZ2VkIGRvY3VtZW50LlxuICBcbiAgV2hlbiBgaW5kaXZpZHVhbGAgaXMgdHJ1ZSwgYWRqYWNlbnQgY2hhbmdlcyAod2hpY2ggYXJlIGtlcHRcbiAgc2VwYXJhdGUgZm9yIFtwb3NpdGlvbiBtYXBwaW5nXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZURlc2MubWFwUG9zKSkgYXJlXG4gIHJlcG9ydGVkIHNlcGFyYXRlbHkuXG4gICovXG4gIGl0ZXJDaGFuZ2VkUmFuZ2VzKGUsIG4gPSAhMSkge1xuICAgIExoKHRoaXMsIGUsIG4pO1xuICB9XG4gIC8qKlxuICBHZXQgYSBkZXNjcmlwdGlvbiBvZiB0aGUgaW52ZXJ0ZWQgZm9ybSBvZiB0aGVzZSBjaGFuZ2VzLlxuICAqL1xuICBnZXQgaW52ZXJ0ZWREZXNjKCkge1xuICAgIGxldCBlID0gW107XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDsgKSB7XG4gICAgICBsZXQgciA9IHRoaXMuc2VjdGlvbnNbbisrXSwgaSA9IHRoaXMuc2VjdGlvbnNbbisrXTtcbiAgICAgIGkgPCAwID8gZS5wdXNoKHIsIGkpIDogZS5wdXNoKGksIHIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IGlpKGUpO1xuICB9XG4gIC8qKlxuICBDb21wdXRlIHRoZSBjb21iaW5lZCBlZmZlY3Qgb2YgYXBwbHlpbmcgYW5vdGhlciBzZXQgb2YgY2hhbmdlc1xuICBhZnRlciB0aGlzIG9uZS4gVGhlIGxlbmd0aCBvZiB0aGUgZG9jdW1lbnQgYWZ0ZXIgdGhpcyBzZXQgc2hvdWxkXG4gIG1hdGNoIHRoZSBsZW5ndGggYmVmb3JlIGBvdGhlcmAuXG4gICovXG4gIGNvbXBvc2VEZXNjKGUpIHtcbiAgICByZXR1cm4gdGhpcy5lbXB0eSA/IGUgOiBlLmVtcHR5ID8gdGhpcyA6IFd3KHRoaXMsIGUpO1xuICB9XG4gIC8qKlxuICBNYXAgdGhpcyBkZXNjcmlwdGlvbiwgd2hpY2ggc2hvdWxkIHN0YXJ0IHdpdGggdGhlIHNhbWUgZG9jdW1lbnRcbiAgYXMgYG90aGVyYCwgb3ZlciBhbm90aGVyIHNldCBvZiBjaGFuZ2VzLCBzbyB0aGF0IGl0IGNhbiBiZVxuICBhcHBsaWVkIGFmdGVyIGl0LiBXaGVuIGBiZWZvcmVgIGlzIHRydWUsIG1hcCBhcyBpZiB0aGUgY2hhbmdlc1xuICBpbiBgb3RoZXJgIGhhcHBlbmVkIGJlZm9yZSB0aGUgb25lcyBpbiBgdGhpc2AuXG4gICovXG4gIG1hcERlc2MoZSwgbiA9ICExKSB7XG4gICAgcmV0dXJuIGUuZW1wdHkgPyB0aGlzIDogVWgodGhpcywgZSwgbik7XG4gIH1cbiAgbWFwUG9zKGUsIG4gPSAtMSwgciA9IG9uLlNpbXBsZSkge1xuICAgIGxldCBpID0gMCwgcyA9IDA7XG4gICAgZm9yIChsZXQgbyA9IDA7IG8gPCB0aGlzLnNlY3Rpb25zLmxlbmd0aDsgKSB7XG4gICAgICBsZXQgYSA9IHRoaXMuc2VjdGlvbnNbbysrXSwgbCA9IHRoaXMuc2VjdGlvbnNbbysrXSwgYyA9IGkgKyBhO1xuICAgICAgaWYgKGwgPCAwKSB7XG4gICAgICAgIGlmIChjID4gZSlcbiAgICAgICAgICByZXR1cm4gcyArIChlIC0gaSk7XG4gICAgICAgIHMgKz0gYTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyICE9IG9uLlNpbXBsZSAmJiBjID49IGUgJiYgKHIgPT0gb24uVHJhY2tEZWwgJiYgaSA8IGUgJiYgYyA+IGUgfHwgciA9PSBvbi5UcmFja0JlZm9yZSAmJiBpIDwgZSB8fCByID09IG9uLlRyYWNrQWZ0ZXIgJiYgYyA+IGUpKVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoYyA+IGUgfHwgYyA9PSBlICYmIG4gPCAwICYmICFhKVxuICAgICAgICAgIHJldHVybiBlID09IGkgfHwgbiA8IDAgPyBzIDogcyArIGw7XG4gICAgICAgIHMgKz0gbDtcbiAgICAgIH1cbiAgICAgIGkgPSBjO1xuICAgIH1cbiAgICBpZiAoZSA+IGkpXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgUG9zaXRpb24gJHtlfSBpcyBvdXQgb2YgcmFuZ2UgZm9yIGNoYW5nZXNldCBvZiBsZW5ndGggJHtpfWApO1xuICAgIHJldHVybiBzO1xuICB9XG4gIC8qKlxuICBDaGVjayB3aGV0aGVyIHRoZXNlIGNoYW5nZXMgdG91Y2ggYSBnaXZlbiByYW5nZS4gV2hlbiBvbmUgb2YgdGhlXG4gIGNoYW5nZXMgZW50aXJlbHkgY292ZXJzIHRoZSByYW5nZSwgdGhlIHN0cmluZyBgXCJjb3ZlclwiYCBpc1xuICByZXR1cm5lZC5cbiAgKi9cbiAgdG91Y2hlc1JhbmdlKGUsIG4gPSBlKSB7XG4gICAgZm9yIChsZXQgciA9IDAsIGkgPSAwOyByIDwgdGhpcy5zZWN0aW9ucy5sZW5ndGggJiYgaSA8PSBuOyApIHtcbiAgICAgIGxldCBzID0gdGhpcy5zZWN0aW9uc1tyKytdLCBvID0gdGhpcy5zZWN0aW9uc1tyKytdLCBhID0gaSArIHM7XG4gICAgICBpZiAobyA+PSAwICYmIGkgPD0gbiAmJiBhID49IGUpXG4gICAgICAgIHJldHVybiBpIDwgZSAmJiBhID4gbiA/IFwiY292ZXJcIiA6ICEwO1xuICAgICAgaSA9IGE7XG4gICAgfVxuICAgIHJldHVybiAhMTtcbiAgfVxuICAvKipcbiAgQGludGVybmFsXG4gICovXG4gIHRvU3RyaW5nKCkge1xuICAgIGxldCBlID0gXCJcIjtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOyApIHtcbiAgICAgIGxldCByID0gdGhpcy5zZWN0aW9uc1tuKytdLCBpID0gdGhpcy5zZWN0aW9uc1tuKytdO1xuICAgICAgZSArPSAoZSA/IFwiIFwiIDogXCJcIikgKyByICsgKGkgPj0gMCA/IFwiOlwiICsgaSA6IFwiXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfVxuICAvKipcbiAgU2VyaWFsaXplIHRoaXMgY2hhbmdlIGRlc2MgdG8gYSBKU09OLXJlcHJlc2VudGFibGUgdmFsdWUuXG4gICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5zZWN0aW9ucztcbiAgfVxuICAvKipcbiAgQ3JlYXRlIGEgY2hhbmdlIGRlc2MgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbiAoYXMgcHJvZHVjZWRcbiAgYnkgW2B0b0pTT05gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkNoYW5nZURlc2MudG9KU09OKS5cbiAgKi9cbiAgc3RhdGljIGZyb21KU09OKGUpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZSkgfHwgZS5sZW5ndGggJSAyIHx8IGUuc29tZSgobikgPT4gdHlwZW9mIG4gIT0gXCJudW1iZXJcIikpXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBDaGFuZ2VEZXNjXCIpO1xuICAgIHJldHVybiBuZXcgaWkoZSk7XG4gIH1cbiAgLyoqXG4gIEBpbnRlcm5hbFxuICAqL1xuICBzdGF0aWMgY3JlYXRlKGUpIHtcbiAgICByZXR1cm4gbmV3IGlpKGUpO1xuICB9XG59XG5jbGFzcyBNdCBleHRlbmRzIGlpIHtcbiAgY29uc3RydWN0b3IoZSwgbikge1xuICAgIHN1cGVyKGUpLCB0aGlzLmluc2VydGVkID0gbjtcbiAgfVxuICAvKipcbiAgQXBwbHkgdGhlIGNoYW5nZXMgdG8gYSBkb2N1bWVudCwgcmV0dXJuaW5nIHRoZSBtb2RpZmllZFxuICBkb2N1bWVudC5cbiAgKi9cbiAgYXBwbHkoZSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCAhPSBlLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQXBwbHlpbmcgY2hhbmdlIHNldCB0byBhIGRvY3VtZW50IHdpdGggdGhlIHdyb25nIGxlbmd0aFwiKTtcbiAgICByZXR1cm4gTGgodGhpcywgKG4sIHIsIGksIHMsIG8pID0+IGUgPSBlLnJlcGxhY2UoaSwgaSArIChyIC0gbiksIG8pLCAhMSksIGU7XG4gIH1cbiAgbWFwRGVzYyhlLCBuID0gITEpIHtcbiAgICByZXR1cm4gVWgodGhpcywgZSwgbiwgITApO1xuICB9XG4gIC8qKlxuICBHaXZlbiB0aGUgZG9jdW1lbnQgYXMgaXQgZXhpc3RlZCBfYmVmb3JlXyB0aGUgY2hhbmdlcywgcmV0dXJuIGFcbiAgY2hhbmdlIHNldCB0aGF0IHJlcHJlc2VudHMgdGhlIGludmVyc2Ugb2YgdGhpcyBzZXQsIHdoaWNoIGNvdWxkXG4gIGJlIHVzZWQgdG8gZ28gZnJvbSB0aGUgZG9jdW1lbnQgY3JlYXRlZCBieSB0aGUgY2hhbmdlcyBiYWNrIHRvXG4gIHRoZSBkb2N1bWVudCBhcyBpdCBleGlzdGVkIGJlZm9yZSB0aGUgY2hhbmdlcy5cbiAgKi9cbiAgaW52ZXJ0KGUpIHtcbiAgICBsZXQgbiA9IHRoaXMuc2VjdGlvbnMuc2xpY2UoKSwgciA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBzID0gMDsgaSA8IG4ubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIGxldCBvID0gbltpXSwgYSA9IG5baSArIDFdO1xuICAgICAgaWYgKGEgPj0gMCkge1xuICAgICAgICBuW2ldID0gYSwgbltpICsgMV0gPSBvO1xuICAgICAgICBsZXQgbCA9IGkgPj4gMTtcbiAgICAgICAgZm9yICg7IHIubGVuZ3RoIDwgbDsgKVxuICAgICAgICAgIHIucHVzaChGZS5lbXB0eSk7XG4gICAgICAgIHIucHVzaChvID8gZS5zbGljZShzLCBzICsgbykgOiBGZS5lbXB0eSk7XG4gICAgICB9XG4gICAgICBzICs9IG87XG4gICAgfVxuICAgIHJldHVybiBuZXcgTXQobiwgcik7XG4gIH1cbiAgLyoqXG4gIENvbWJpbmUgdHdvIHN1YnNlcXVlbnQgY2hhbmdlIHNldHMgaW50byBhIHNpbmdsZSBzZXQuIGBvdGhlcmBcbiAgbXVzdCBzdGFydCBpbiB0aGUgZG9jdW1lbnQgcHJvZHVjZWQgYnkgYHRoaXNgLiBJZiBgdGhpc2AgZ29lc1xuICBgZG9jQWAg4oaSIGBkb2NCYCBhbmQgYG90aGVyYCByZXByZXNlbnRzIGBkb2NCYCDihpIgYGRvY0NgLCB0aGVcbiAgcmV0dXJuZWQgdmFsdWUgd2lsbCByZXByZXNlbnQgdGhlIGNoYW5nZSBgZG9jQWAg4oaSIGBkb2NDYC5cbiAgKi9cbiAgY29tcG9zZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuZW1wdHkgPyBlIDogZS5lbXB0eSA/IHRoaXMgOiBXdyh0aGlzLCBlLCAhMCk7XG4gIH1cbiAgLyoqXG4gIEdpdmVuIGFub3RoZXIgY2hhbmdlIHNldCBzdGFydGluZyBpbiB0aGUgc2FtZSBkb2N1bWVudCwgbWFwcyB0aGlzXG4gIGNoYW5nZSBzZXQgb3ZlciB0aGUgb3RoZXIsIHByb2R1Y2luZyBhIG5ldyBjaGFuZ2Ugc2V0IHRoYXQgY2FuIGJlXG4gIGFwcGxpZWQgdG8gdGhlIGRvY3VtZW50IHByb2R1Y2VkIGJ5IGFwcGx5aW5nIGBvdGhlcmAuIFdoZW5cbiAgYGJlZm9yZWAgaXMgYHRydWVgLCBvcmRlciBjaGFuZ2VzIGFzIGlmIGB0aGlzYCBjb21lcyBiZWZvcmVcbiAgYG90aGVyYCwgb3RoZXJ3aXNlICh0aGUgZGVmYXVsdCkgdHJlYXQgYG90aGVyYCBhcyBjb21pbmcgZmlyc3QuXG4gIFxuICBHaXZlbiB0d28gY2hhbmdlcyBgQWAgYW5kIGBCYCwgYEEuY29tcG9zZShCLm1hcChBKSlgIGFuZFxuICBgQi5jb21wb3NlKEEubWFwKEIsIHRydWUpKWAgd2lsbCBwcm9kdWNlIHRoZSBzYW1lIGRvY3VtZW50LiBUaGlzXG4gIHByb3ZpZGVzIGEgYmFzaWMgZm9ybSBvZiBbb3BlcmF0aW9uYWxcbiAgdHJhbnNmb3JtYXRpb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL09wZXJhdGlvbmFsX3RyYW5zZm9ybWF0aW9uKSxcbiAgYW5kIGNhbiBiZSB1c2VkIGZvciBjb2xsYWJvcmF0aXZlIGVkaXRpbmcuXG4gICovXG4gIG1hcChlLCBuID0gITEpIHtcbiAgICByZXR1cm4gZS5lbXB0eSA/IHRoaXMgOiBVaCh0aGlzLCBlLCBuLCAhMCk7XG4gIH1cbiAgLyoqXG4gIEl0ZXJhdGUgb3ZlciB0aGUgY2hhbmdlZCByYW5nZXMgaW4gdGhlIGRvY3VtZW50LCBjYWxsaW5nIGBmYCBmb3JcbiAgZWFjaCwgd2l0aCB0aGUgcmFuZ2UgaW4gdGhlIG9yaWdpbmFsIGRvY3VtZW50IChgZnJvbUFgLWB0b0FgKVxuICBhbmQgdGhlIHJhbmdlIHRoYXQgcmVwbGFjZXMgaXQgaW4gdGhlIG5ldyBkb2N1bWVudFxuICAoYGZyb21CYC1gdG9CYCkuXG4gIFxuICBXaGVuIGBpbmRpdmlkdWFsYCBpcyB0cnVlLCBhZGphY2VudCBjaGFuZ2VzIGFyZSByZXBvcnRlZFxuICBzZXBhcmF0ZWx5LlxuICAqL1xuICBpdGVyQ2hhbmdlcyhlLCBuID0gITEpIHtcbiAgICBMaCh0aGlzLCBlLCBuKTtcbiAgfVxuICAvKipcbiAgR2V0IGEgW2NoYW5nZSBkZXNjcmlwdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFuZ2VEZXNjKSBmb3IgdGhpcyBjaGFuZ2VcbiAgc2V0LlxuICAqL1xuICBnZXQgZGVzYygpIHtcbiAgICByZXR1cm4gaWkuY3JlYXRlKHRoaXMuc2VjdGlvbnMpO1xuICB9XG4gIC8qKlxuICBAaW50ZXJuYWxcbiAgKi9cbiAgZmlsdGVyKGUpIHtcbiAgICBsZXQgbiA9IFtdLCByID0gW10sIGkgPSBbXSwgcyA9IG5ldyBmbCh0aGlzKTtcbiAgICBlOlxuICAgICAgZm9yIChsZXQgbyA9IDAsIGEgPSAwOyA7ICkge1xuICAgICAgICBsZXQgbCA9IG8gPT0gZS5sZW5ndGggPyAxZTkgOiBlW28rK107XG4gICAgICAgIGZvciAoOyBhIDwgbCB8fCBhID09IGwgJiYgcy5sZW4gPT0gMDsgKSB7XG4gICAgICAgICAgaWYgKHMuZG9uZSlcbiAgICAgICAgICAgIGJyZWFrIGU7XG4gICAgICAgICAgbGV0IHUgPSBNYXRoLm1pbihzLmxlbiwgbCAtIGEpO1xuICAgICAgICAgIHRuKGksIHUsIC0xKTtcbiAgICAgICAgICBsZXQgZCA9IHMuaW5zID09IC0xID8gLTEgOiBzLm9mZiA9PSAwID8gcy5pbnMgOiAwO1xuICAgICAgICAgIHRuKG4sIHUsIGQpLCBkID4gMCAmJiBqaShyLCBuLCBzLnRleHQpLCBzLmZvcndhcmQodSksIGEgKz0gdTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYyA9IGVbbysrXTtcbiAgICAgICAgZm9yICg7IGEgPCBjOyApIHtcbiAgICAgICAgICBpZiAocy5kb25lKVxuICAgICAgICAgICAgYnJlYWsgZTtcbiAgICAgICAgICBsZXQgdSA9IE1hdGgubWluKHMubGVuLCBjIC0gYSk7XG4gICAgICAgICAgdG4obiwgdSwgLTEpLCB0bihpLCB1LCBzLmlucyA9PSAtMSA/IC0xIDogcy5vZmYgPT0gMCA/IHMuaW5zIDogMCksIHMuZm9yd2FyZCh1KSwgYSArPSB1O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNoYW5nZXM6IG5ldyBNdChuLCByKSxcbiAgICAgIGZpbHRlcmVkOiBpaS5jcmVhdGUoaSlcbiAgICB9O1xuICB9XG4gIC8qKlxuICBTZXJpYWxpemUgdGhpcyBjaGFuZ2Ugc2V0IHRvIGEgSlNPTi1yZXByZXNlbnRhYmxlIHZhbHVlLlxuICAqL1xuICB0b0pTT04oKSB7XG4gICAgbGV0IGUgPSBbXTtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IHRoaXMuc2VjdGlvbnMubGVuZ3RoOyBuICs9IDIpIHtcbiAgICAgIGxldCByID0gdGhpcy5zZWN0aW9uc1tuXSwgaSA9IHRoaXMuc2VjdGlvbnNbbiArIDFdO1xuICAgICAgaSA8IDAgPyBlLnB1c2gocikgOiBpID09IDAgPyBlLnB1c2goW3JdKSA6IGUucHVzaChbcl0uY29uY2F0KHRoaXMuaW5zZXJ0ZWRbbiA+PiAxXS50b0pTT04oKSkpO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfVxuICAvKipcbiAgQ3JlYXRlIGEgY2hhbmdlIHNldCBmb3IgdGhlIGdpdmVuIGNoYW5nZXMsIGZvciBhIGRvY3VtZW50IG9mIHRoZVxuICBnaXZlbiBsZW5ndGgsIHVzaW5nIGBsaW5lU2VwYCBhcyBsaW5lIHNlcGFyYXRvci5cbiAgKi9cbiAgc3RhdGljIG9mKGUsIG4sIHIpIHtcbiAgICBsZXQgaSA9IFtdLCBzID0gW10sIG8gPSAwLCBhID0gbnVsbDtcbiAgICBmdW5jdGlvbiBsKHUgPSAhMSkge1xuICAgICAgaWYgKCF1ICYmICFpLmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbyA8IG4gJiYgdG4oaSwgbiAtIG8sIC0xKTtcbiAgICAgIGxldCBkID0gbmV3IE10KGksIHMpO1xuICAgICAgYSA9IGEgPyBhLmNvbXBvc2UoZC5tYXAoYSkpIDogZCwgaSA9IFtdLCBzID0gW10sIG8gPSAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjKHUpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHUpKVxuICAgICAgICBmb3IgKGxldCBkIG9mIHUpXG4gICAgICAgICAgYyhkKTtcbiAgICAgIGVsc2UgaWYgKHUgaW5zdGFuY2VvZiBNdCkge1xuICAgICAgICBpZiAodS5sZW5ndGggIT0gbilcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgTWlzbWF0Y2hlZCBjaGFuZ2Ugc2V0IGxlbmd0aCAoZ290ICR7dS5sZW5ndGh9LCBleHBlY3RlZCAke259KWApO1xuICAgICAgICBsKCksIGEgPSBhID8gYS5jb21wb3NlKHUubWFwKGEpKSA6IHU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgeyBmcm9tOiBkLCB0bzogZiA9IGQsIGluc2VydDogaCB9ID0gdTtcbiAgICAgICAgaWYgKGQgPiBmIHx8IGQgPCAwIHx8IGYgPiBuKVxuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIGNoYW5nZSByYW5nZSAke2R9IHRvICR7Zn0gKGluIGRvYyBvZiBsZW5ndGggJHtufSlgKTtcbiAgICAgICAgbGV0IHAgPSBoID8gdHlwZW9mIGggPT0gXCJzdHJpbmdcIiA/IEZlLm9mKGguc3BsaXQociB8fCBCaCkpIDogaCA6IEZlLmVtcHR5LCBPID0gcC5sZW5ndGg7XG4gICAgICAgIGlmIChkID09IGYgJiYgTyA9PSAwKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZCA8IG8gJiYgbCgpLCBkID4gbyAmJiB0bihpLCBkIC0gbywgLTEpLCB0bihpLCBmIC0gZCwgTyksIGppKHMsIGksIHApLCBvID0gZjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGMoZSksIGwoIWEpLCBhO1xuICB9XG4gIC8qKlxuICBDcmVhdGUgYW4gZW1wdHkgY2hhbmdlc2V0IG9mIHRoZSBnaXZlbiBsZW5ndGguXG4gICovXG4gIHN0YXRpYyBlbXB0eShlKSB7XG4gICAgcmV0dXJuIG5ldyBNdChlID8gW2UsIC0xXSA6IFtdLCBbXSk7XG4gIH1cbiAgLyoqXG4gIENyZWF0ZSBhIGNoYW5nZXNldCBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uIChhcyBwcm9kdWNlZCBieVxuICBbYHRvSlNPTmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlU2V0LnRvSlNPTikuXG4gICovXG4gIHN0YXRpYyBmcm9tSlNPTihlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGUpKVxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gb2YgQ2hhbmdlU2V0XCIpO1xuICAgIGxldCBuID0gW10sIHIgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBzID0gZVtpXTtcbiAgICAgIGlmICh0eXBlb2YgcyA9PSBcIm51bWJlclwiKVxuICAgICAgICBuLnB1c2gocywgLTEpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzKSB8fCB0eXBlb2Ygc1swXSAhPSBcIm51bWJlclwiIHx8IHMuc29tZSgobywgYSkgPT4gYSAmJiB0eXBlb2YgbyAhPSBcInN0cmluZ1wiKSlcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBDaGFuZ2VTZXRcIik7XG4gICAgICAgIGlmIChzLmxlbmd0aCA9PSAxKVxuICAgICAgICAgIG4ucHVzaChzWzBdLCAwKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZm9yICg7IHIubGVuZ3RoIDwgaTsgKVxuICAgICAgICAgICAgci5wdXNoKEZlLmVtcHR5KTtcbiAgICAgICAgICByW2ldID0gRmUub2Yocy5zbGljZSgxKSksIG4ucHVzaChzWzBdLCByW2ldLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBNdChuLCByKTtcbiAgfVxuICAvKipcbiAgQGludGVybmFsXG4gICovXG4gIHN0YXRpYyBjcmVhdGVTZXQoZSwgbikge1xuICAgIHJldHVybiBuZXcgTXQoZSwgbik7XG4gIH1cbn1cbmZ1bmN0aW9uIHRuKHQsIGUsIG4sIHIgPSAhMSkge1xuICBpZiAoZSA9PSAwICYmIG4gPD0gMClcbiAgICByZXR1cm47XG4gIGxldCBpID0gdC5sZW5ndGggLSAyO1xuICBpID49IDAgJiYgbiA8PSAwICYmIG4gPT0gdFtpICsgMV0gPyB0W2ldICs9IGUgOiBlID09IDAgJiYgdFtpXSA9PSAwID8gdFtpICsgMV0gKz0gbiA6IHIgPyAodFtpXSArPSBlLCB0W2kgKyAxXSArPSBuKSA6IHQucHVzaChlLCBuKTtcbn1cbmZ1bmN0aW9uIGppKHQsIGUsIG4pIHtcbiAgaWYgKG4ubGVuZ3RoID09IDApXG4gICAgcmV0dXJuO1xuICBsZXQgciA9IGUubGVuZ3RoIC0gMiA+PiAxO1xuICBpZiAociA8IHQubGVuZ3RoKVxuICAgIHRbdC5sZW5ndGggLSAxXSA9IHRbdC5sZW5ndGggLSAxXS5hcHBlbmQobik7XG4gIGVsc2Uge1xuICAgIGZvciAoOyB0Lmxlbmd0aCA8IHI7IClcbiAgICAgIHQucHVzaChGZS5lbXB0eSk7XG4gICAgdC5wdXNoKG4pO1xuICB9XG59XG5mdW5jdGlvbiBMaCh0LCBlLCBuKSB7XG4gIGxldCByID0gdC5pbnNlcnRlZDtcbiAgZm9yIChsZXQgaSA9IDAsIHMgPSAwLCBvID0gMDsgbyA8IHQuc2VjdGlvbnMubGVuZ3RoOyApIHtcbiAgICBsZXQgYSA9IHQuc2VjdGlvbnNbbysrXSwgbCA9IHQuc2VjdGlvbnNbbysrXTtcbiAgICBpZiAobCA8IDApXG4gICAgICBpICs9IGEsIHMgKz0gYTtcbiAgICBlbHNlIHtcbiAgICAgIGxldCBjID0gaSwgdSA9IHMsIGQgPSBGZS5lbXB0eTtcbiAgICAgIGZvciAoOyBjICs9IGEsIHUgKz0gbCwgbCAmJiByICYmIChkID0gZC5hcHBlbmQocltvIC0gMiA+PiAxXSkpLCAhKG4gfHwgbyA9PSB0LnNlY3Rpb25zLmxlbmd0aCB8fCB0LnNlY3Rpb25zW28gKyAxXSA8IDApOyApXG4gICAgICAgIGEgPSB0LnNlY3Rpb25zW28rK10sIGwgPSB0LnNlY3Rpb25zW28rK107XG4gICAgICBlKGksIGMsIHMsIHUsIGQpLCBpID0gYywgcyA9IHU7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBVaCh0LCBlLCBuLCByID0gITEpIHtcbiAgbGV0IGkgPSBbXSwgcyA9IHIgPyBbXSA6IG51bGwsIG8gPSBuZXcgZmwodCksIGEgPSBuZXcgZmwoZSk7XG4gIGZvciAobGV0IGwgPSAtMTsgOyApXG4gICAgaWYgKG8uaW5zID09IC0xICYmIGEuaW5zID09IC0xKSB7XG4gICAgICBsZXQgYyA9IE1hdGgubWluKG8ubGVuLCBhLmxlbik7XG4gICAgICB0bihpLCBjLCAtMSksIG8uZm9yd2FyZChjKSwgYS5mb3J3YXJkKGMpO1xuICAgIH0gZWxzZSBpZiAoYS5pbnMgPj0gMCAmJiAoby5pbnMgPCAwIHx8IGwgPT0gby5pIHx8IG8ub2ZmID09IDAgJiYgKGEubGVuIDwgby5sZW4gfHwgYS5sZW4gPT0gby5sZW4gJiYgIW4pKSkge1xuICAgICAgbGV0IGMgPSBhLmxlbjtcbiAgICAgIGZvciAodG4oaSwgYS5pbnMsIC0xKTsgYzsgKSB7XG4gICAgICAgIGxldCB1ID0gTWF0aC5taW4oby5sZW4sIGMpO1xuICAgICAgICBvLmlucyA+PSAwICYmIGwgPCBvLmkgJiYgby5sZW4gPD0gdSAmJiAodG4oaSwgMCwgby5pbnMpLCBzICYmIGppKHMsIGksIG8udGV4dCksIGwgPSBvLmkpLCBvLmZvcndhcmQodSksIGMgLT0gdTtcbiAgICAgIH1cbiAgICAgIGEubmV4dCgpO1xuICAgIH0gZWxzZSBpZiAoby5pbnMgPj0gMCkge1xuICAgICAgbGV0IGMgPSAwLCB1ID0gby5sZW47XG4gICAgICBmb3IgKDsgdTsgKVxuICAgICAgICBpZiAoYS5pbnMgPT0gLTEpIHtcbiAgICAgICAgICBsZXQgZCA9IE1hdGgubWluKHUsIGEubGVuKTtcbiAgICAgICAgICBjICs9IGQsIHUgLT0gZCwgYS5mb3J3YXJkKGQpO1xuICAgICAgICB9IGVsc2UgaWYgKGEuaW5zID09IDAgJiYgYS5sZW4gPCB1KVxuICAgICAgICAgIHUgLT0gYS5sZW4sIGEubmV4dCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB0bihpLCBjLCBsIDwgby5pID8gby5pbnMgOiAwKSwgcyAmJiBsIDwgby5pICYmIGppKHMsIGksIG8udGV4dCksIGwgPSBvLmksIG8uZm9yd2FyZChvLmxlbiAtIHUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoby5kb25lICYmIGEuZG9uZSlcbiAgICAgICAgcmV0dXJuIHMgPyBNdC5jcmVhdGVTZXQoaSwgcykgOiBpaS5jcmVhdGUoaSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNtYXRjaGVkIGNoYW5nZSBzZXQgbGVuZ3Roc1wiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBXdyh0LCBlLCBuID0gITEpIHtcbiAgbGV0IHIgPSBbXSwgaSA9IG4gPyBbXSA6IG51bGwsIHMgPSBuZXcgZmwodCksIG8gPSBuZXcgZmwoZSk7XG4gIGZvciAobGV0IGEgPSAhMTsgOyApIHtcbiAgICBpZiAocy5kb25lICYmIG8uZG9uZSlcbiAgICAgIHJldHVybiBpID8gTXQuY3JlYXRlU2V0KHIsIGkpIDogaWkuY3JlYXRlKHIpO1xuICAgIGlmIChzLmlucyA9PSAwKVxuICAgICAgdG4ociwgcy5sZW4sIDAsIGEpLCBzLm5leHQoKTtcbiAgICBlbHNlIGlmIChvLmxlbiA9PSAwICYmICFvLmRvbmUpXG4gICAgICB0bihyLCAwLCBvLmlucywgYSksIGkgJiYgamkoaSwgciwgby50ZXh0KSwgby5uZXh0KCk7XG4gICAgZWxzZSB7XG4gICAgICBpZiAocy5kb25lIHx8IG8uZG9uZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzbWF0Y2hlZCBjaGFuZ2Ugc2V0IGxlbmd0aHNcIik7XG4gICAgICB7XG4gICAgICAgIGxldCBsID0gTWF0aC5taW4ocy5sZW4yLCBvLmxlbiksIGMgPSByLmxlbmd0aDtcbiAgICAgICAgaWYgKHMuaW5zID09IC0xKSB7XG4gICAgICAgICAgbGV0IHUgPSBvLmlucyA9PSAtMSA/IC0xIDogby5vZmYgPyAwIDogby5pbnM7XG4gICAgICAgICAgdG4ociwgbCwgdSwgYSksIGkgJiYgdSAmJiBqaShpLCByLCBvLnRleHQpO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBvLmlucyA9PSAtMSA/ICh0bihyLCBzLm9mZiA/IDAgOiBzLmxlbiwgbCwgYSksIGkgJiYgamkoaSwgciwgcy50ZXh0Qml0KGwpKSkgOiAodG4ociwgcy5vZmYgPyAwIDogcy5sZW4sIG8ub2ZmID8gMCA6IG8uaW5zLCBhKSwgaSAmJiAhby5vZmYgJiYgamkoaSwgciwgby50ZXh0KSk7XG4gICAgICAgIGEgPSAocy5pbnMgPiBsIHx8IG8uaW5zID49IDAgJiYgby5sZW4gPiBsKSAmJiAoYSB8fCByLmxlbmd0aCA+IGMpLCBzLmZvcndhcmQyKGwpLCBvLmZvcndhcmQobCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5jbGFzcyBmbCB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLnNldCA9IGUsIHRoaXMuaSA9IDAsIHRoaXMubmV4dCgpO1xuICB9XG4gIG5leHQoKSB7XG4gICAgbGV0IHsgc2VjdGlvbnM6IGUgfSA9IHRoaXMuc2V0O1xuICAgIHRoaXMuaSA8IGUubGVuZ3RoID8gKHRoaXMubGVuID0gZVt0aGlzLmkrK10sIHRoaXMuaW5zID0gZVt0aGlzLmkrK10pIDogKHRoaXMubGVuID0gMCwgdGhpcy5pbnMgPSAtMiksIHRoaXMub2ZmID0gMDtcbiAgfVxuICBnZXQgZG9uZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnMgPT0gLTI7XG4gIH1cbiAgZ2V0IGxlbjIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zIDwgMCA/IHRoaXMubGVuIDogdGhpcy5pbnM7XG4gIH1cbiAgZ2V0IHRleHQoKSB7XG4gICAgbGV0IHsgaW5zZXJ0ZWQ6IGUgfSA9IHRoaXMuc2V0LCBuID0gdGhpcy5pIC0gMiA+PiAxO1xuICAgIHJldHVybiBuID49IGUubGVuZ3RoID8gRmUuZW1wdHkgOiBlW25dO1xuICB9XG4gIHRleHRCaXQoZSkge1xuICAgIGxldCB7IGluc2VydGVkOiBuIH0gPSB0aGlzLnNldCwgciA9IHRoaXMuaSAtIDIgPj4gMTtcbiAgICByZXR1cm4gciA+PSBuLmxlbmd0aCAmJiAhZSA/IEZlLmVtcHR5IDogbltyXS5zbGljZSh0aGlzLm9mZiwgZSA9PSBudWxsID8gdm9pZCAwIDogdGhpcy5vZmYgKyBlKTtcbiAgfVxuICBmb3J3YXJkKGUpIHtcbiAgICBlID09IHRoaXMubGVuID8gdGhpcy5uZXh0KCkgOiAodGhpcy5sZW4gLT0gZSwgdGhpcy5vZmYgKz0gZSk7XG4gIH1cbiAgZm9yd2FyZDIoZSkge1xuICAgIHRoaXMuaW5zID09IC0xID8gdGhpcy5mb3J3YXJkKGUpIDogZSA9PSB0aGlzLmlucyA/IHRoaXMubmV4dCgpIDogKHRoaXMuaW5zIC09IGUsIHRoaXMub2ZmICs9IGUpO1xuICB9XG59XG5jbGFzcyB4cyB7XG4gIGNvbnN0cnVjdG9yKGUsIG4sIHIpIHtcbiAgICB0aGlzLmZyb20gPSBlLCB0aGlzLnRvID0gbiwgdGhpcy5mbGFncyA9IHI7XG4gIH1cbiAgLyoqXG4gIFRoZSBhbmNob3Igb2YgdGhlIHJhbmdl4oCUdGhlIHNpZGUgdGhhdCBkb2Vzbid0IG1vdmUgd2hlbiB5b3VcbiAgZXh0ZW5kIGl0LlxuICAqL1xuICBnZXQgYW5jaG9yKCkge1xuICAgIHJldHVybiB0aGlzLmZsYWdzICYgMzIgPyB0aGlzLnRvIDogdGhpcy5mcm9tO1xuICB9XG4gIC8qKlxuICBUaGUgaGVhZCBvZiB0aGUgcmFuZ2UsIHdoaWNoIGlzIG1vdmVkIHdoZW4gdGhlIHJhbmdlIGlzXG4gIFtleHRlbmRlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TZWxlY3Rpb25SYW5nZS5leHRlbmQpLlxuICAqL1xuICBnZXQgaGVhZCgpIHtcbiAgICByZXR1cm4gdGhpcy5mbGFncyAmIDMyID8gdGhpcy5mcm9tIDogdGhpcy50bztcbiAgfVxuICAvKipcbiAgVHJ1ZSB3aGVuIGBhbmNob3JgIGFuZCBgaGVhZGAgYXJlIGF0IHRoZSBzYW1lIHBvc2l0aW9uLlxuICAqL1xuICBnZXQgZW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZnJvbSA9PSB0aGlzLnRvO1xuICB9XG4gIC8qKlxuICBJZiB0aGlzIGlzIGEgY3Vyc29yIHRoYXQgaXMgZXhwbGljaXRseSBhc3NvY2lhdGVkIHdpdGggdGhlXG4gIGNoYXJhY3RlciBvbiBvbmUgb2YgaXRzIHNpZGVzLCB0aGlzIHJldHVybnMgdGhlIHNpZGUuIC0xIG1lYW5zXG4gIHRoZSBjaGFyYWN0ZXIgYmVmb3JlIGl0cyBwb3NpdGlvbiwgMSB0aGUgY2hhcmFjdGVyIGFmdGVyLCBhbmQgMFxuICBtZWFucyBubyBhc3NvY2lhdGlvbi5cbiAgKi9cbiAgZ2V0IGFzc29jKCkge1xuICAgIHJldHVybiB0aGlzLmZsYWdzICYgOCA/IC0xIDogdGhpcy5mbGFncyAmIDE2ID8gMSA6IDA7XG4gIH1cbiAgLyoqXG4gIFRoZSBiaWRpcmVjdGlvbmFsIHRleHQgbGV2ZWwgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY3Vyc29yLCBpZlxuICBhbnkuXG4gICovXG4gIGdldCBiaWRpTGV2ZWwoKSB7XG4gICAgbGV0IGUgPSB0aGlzLmZsYWdzICYgNztcbiAgICByZXR1cm4gZSA9PSA3ID8gbnVsbCA6IGU7XG4gIH1cbiAgLyoqXG4gIFRoZSBnb2FsIGNvbHVtbiAoc3RvcmVkIHZlcnRpY2FsIG9mZnNldCkgYXNzb2NpYXRlZCB3aXRoIGFcbiAgY3Vyc29yLiBUaGlzIGlzIHVzZWQgdG8gcHJlc2VydmUgdGhlIHZlcnRpY2FsIHBvc2l0aW9uIHdoZW5cbiAgW21vdmluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubW92ZVZlcnRpY2FsbHkpIGFjcm9zc1xuICBsaW5lcyBvZiBkaWZmZXJlbnQgbGVuZ3RoLlxuICAqL1xuICBnZXQgZ29hbENvbHVtbigpIHtcbiAgICBsZXQgZSA9IHRoaXMuZmxhZ3MgPj4gNjtcbiAgICByZXR1cm4gZSA9PSAxNjc3NzIxNSA/IHZvaWQgMCA6IGU7XG4gIH1cbiAgLyoqXG4gIE1hcCB0aGlzIHJhbmdlIHRocm91Z2ggYSBjaGFuZ2UsIHByb2R1Y2luZyBhIHZhbGlkIHJhbmdlIGluIHRoZVxuICB1cGRhdGVkIGRvY3VtZW50LlxuICAqL1xuICBtYXAoZSwgbiA9IC0xKSB7XG4gICAgbGV0IHIsIGk7XG4gICAgcmV0dXJuIHRoaXMuZW1wdHkgPyByID0gaSA9IGUubWFwUG9zKHRoaXMuZnJvbSwgbikgOiAociA9IGUubWFwUG9zKHRoaXMuZnJvbSwgMSksIGkgPSBlLm1hcFBvcyh0aGlzLnRvLCAtMSkpLCByID09IHRoaXMuZnJvbSAmJiBpID09IHRoaXMudG8gPyB0aGlzIDogbmV3IHhzKHIsIGksIHRoaXMuZmxhZ3MpO1xuICB9XG4gIC8qKlxuICBFeHRlbmQgdGhpcyByYW5nZSB0byBjb3ZlciBhdCBsZWFzdCBgZnJvbWAgdG8gYHRvYC5cbiAgKi9cbiAgZXh0ZW5kKGUsIG4gPSBlKSB7XG4gICAgaWYgKGUgPD0gdGhpcy5hbmNob3IgJiYgbiA+PSB0aGlzLmFuY2hvcilcbiAgICAgIHJldHVybiBhZS5yYW5nZShlLCBuKTtcbiAgICBsZXQgciA9IE1hdGguYWJzKGUgLSB0aGlzLmFuY2hvcikgPiBNYXRoLmFicyhuIC0gdGhpcy5hbmNob3IpID8gZSA6IG47XG4gICAgcmV0dXJuIGFlLnJhbmdlKHRoaXMuYW5jaG9yLCByKTtcbiAgfVxuICAvKipcbiAgQ29tcGFyZSB0aGlzIHJhbmdlIHRvIGFub3RoZXIgcmFuZ2UuXG4gICovXG4gIGVxKGUsIG4gPSAhMSkge1xuICAgIHJldHVybiB0aGlzLmFuY2hvciA9PSBlLmFuY2hvciAmJiB0aGlzLmhlYWQgPT0gZS5oZWFkICYmICghbiB8fCAhdGhpcy5lbXB0eSB8fCB0aGlzLmFzc29jID09IGUuYXNzb2MpO1xuICB9XG4gIC8qKlxuICBSZXR1cm4gYSBKU09OLXNlcmlhbGl6YWJsZSBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSByYW5nZS5cbiAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7IGFuY2hvcjogdGhpcy5hbmNob3IsIGhlYWQ6IHRoaXMuaGVhZCB9O1xuICB9XG4gIC8qKlxuICBDb252ZXJ0IGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiBhIHJhbmdlIHRvIGEgYFNlbGVjdGlvblJhbmdlYFxuICBpbnN0YW5jZS5cbiAgKi9cbiAgc3RhdGljIGZyb21KU09OKGUpIHtcbiAgICBpZiAoIWUgfHwgdHlwZW9mIGUuYW5jaG9yICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGUuaGVhZCAhPSBcIm51bWJlclwiKVxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gcmVwcmVzZW50YXRpb24gZm9yIFNlbGVjdGlvblJhbmdlXCIpO1xuICAgIHJldHVybiBhZS5yYW5nZShlLmFuY2hvciwgZS5oZWFkKTtcbiAgfVxuICAvKipcbiAgQGludGVybmFsXG4gICovXG4gIHN0YXRpYyBjcmVhdGUoZSwgbiwgcikge1xuICAgIHJldHVybiBuZXcgeHMoZSwgbiwgcik7XG4gIH1cbn1cbmNsYXNzIGFlIHtcbiAgY29uc3RydWN0b3IoZSwgbikge1xuICAgIHRoaXMucmFuZ2VzID0gZSwgdGhpcy5tYWluSW5kZXggPSBuO1xuICB9XG4gIC8qKlxuICBNYXAgYSBzZWxlY3Rpb24gdGhyb3VnaCBhIGNoYW5nZS4gVXNlZCB0byBhZGp1c3QgdGhlIHNlbGVjdGlvblxuICBwb3NpdGlvbiBmb3IgY2hhbmdlcy5cbiAgKi9cbiAgbWFwKGUsIG4gPSAtMSkge1xuICAgIHJldHVybiBlLmVtcHR5ID8gdGhpcyA6IGFlLmNyZWF0ZSh0aGlzLnJhbmdlcy5tYXAoKHIpID0+IHIubWFwKGUsIG4pKSwgdGhpcy5tYWluSW5kZXgpO1xuICB9XG4gIC8qKlxuICBDb21wYXJlIHRoaXMgc2VsZWN0aW9uIHRvIGFub3RoZXIgc2VsZWN0aW9uLiBCeSBkZWZhdWx0LCByYW5nZXNcbiAgYXJlIGNvbXBhcmVkIG9ubHkgYnkgcG9zaXRpb24uIFdoZW4gYGluY2x1ZGVBc3NvY2AgaXMgdHJ1ZSxcbiAgY3Vyc29yIHJhbmdlcyBtdXN0IGFsc28gaGF2ZSB0aGUgc2FtZVxuICBbYGFzc29jYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TZWxlY3Rpb25SYW5nZS5hc3NvYykgdmFsdWUuXG4gICovXG4gIGVxKGUsIG4gPSAhMSkge1xuICAgIGlmICh0aGlzLnJhbmdlcy5sZW5ndGggIT0gZS5yYW5nZXMubGVuZ3RoIHx8IHRoaXMubWFpbkluZGV4ICE9IGUubWFpbkluZGV4KVxuICAgICAgcmV0dXJuICExO1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyByKyspXG4gICAgICBpZiAoIXRoaXMucmFuZ2VzW3JdLmVxKGUucmFuZ2VzW3JdLCBuKSlcbiAgICAgICAgcmV0dXJuICExO1xuICAgIHJldHVybiAhMDtcbiAgfVxuICAvKipcbiAgR2V0IHRoZSBwcmltYXJ5IHNlbGVjdGlvbiByYW5nZS4gVXN1YWxseSwgeW91IHNob3VsZCBtYWtlIHN1cmVcbiAgeW91ciBjb2RlIGFwcGxpZXMgdG8gX2FsbF8gcmFuZ2VzLCBieSB1c2luZyBtZXRob2RzIGxpa2VcbiAgW2BjaGFuZ2VCeVJhbmdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5jaGFuZ2VCeVJhbmdlKS5cbiAgKi9cbiAgZ2V0IG1haW4oKSB7XG4gICAgcmV0dXJuIHRoaXMucmFuZ2VzW3RoaXMubWFpbkluZGV4XTtcbiAgfVxuICAvKipcbiAgTWFrZSBzdXJlIHRoZSBzZWxlY3Rpb24gb25seSBoYXMgb25lIHJhbmdlLiBSZXR1cm5zIGEgc2VsZWN0aW9uXG4gIGhvbGRpbmcgb25seSB0aGUgbWFpbiByYW5nZSBmcm9tIHRoaXMgc2VsZWN0aW9uLlxuICAqL1xuICBhc1NpbmdsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yYW5nZXMubGVuZ3RoID09IDEgPyB0aGlzIDogbmV3IGFlKFt0aGlzLm1haW5dLCAwKTtcbiAgfVxuICAvKipcbiAgRXh0ZW5kIHRoaXMgc2VsZWN0aW9uIHdpdGggYW4gZXh0cmEgcmFuZ2UuXG4gICovXG4gIGFkZFJhbmdlKGUsIG4gPSAhMCkge1xuICAgIHJldHVybiBhZS5jcmVhdGUoW2VdLmNvbmNhdCh0aGlzLnJhbmdlcyksIG4gPyAwIDogdGhpcy5tYWluSW5kZXggKyAxKTtcbiAgfVxuICAvKipcbiAgUmVwbGFjZSBhIGdpdmVuIHJhbmdlIHdpdGggYW5vdGhlciByYW5nZSwgYW5kIHRoZW4gbm9ybWFsaXplIHRoZVxuICBzZWxlY3Rpb24gdG8gbWVyZ2UgYW5kIHNvcnQgcmFuZ2VzIGlmIG5lY2Vzc2FyeS5cbiAgKi9cbiAgcmVwbGFjZVJhbmdlKGUsIG4gPSB0aGlzLm1haW5JbmRleCkge1xuICAgIGxldCByID0gdGhpcy5yYW5nZXMuc2xpY2UoKTtcbiAgICByZXR1cm4gcltuXSA9IGUsIGFlLmNyZWF0ZShyLCB0aGlzLm1haW5JbmRleCk7XG4gIH1cbiAgLyoqXG4gIENvbnZlcnQgdGhpcyBzZWxlY3Rpb24gdG8gYW4gb2JqZWN0IHRoYXQgY2FuIGJlIHNlcmlhbGl6ZWQgdG9cbiAgSlNPTi5cbiAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7IHJhbmdlczogdGhpcy5yYW5nZXMubWFwKChlKSA9PiBlLnRvSlNPTigpKSwgbWFpbjogdGhpcy5tYWluSW5kZXggfTtcbiAgfVxuICAvKipcbiAgQ3JlYXRlIGEgc2VsZWN0aW9uIGZyb20gYSBKU09OIHJlcHJlc2VudGF0aW9uLlxuICAqL1xuICBzdGF0aWMgZnJvbUpTT04oZSkge1xuICAgIGlmICghZSB8fCAhQXJyYXkuaXNBcnJheShlLnJhbmdlcykgfHwgdHlwZW9mIGUubWFpbiAhPSBcIm51bWJlclwiIHx8IGUubWFpbiA+PSBlLnJhbmdlcy5sZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiByZXByZXNlbnRhdGlvbiBmb3IgRWRpdG9yU2VsZWN0aW9uXCIpO1xuICAgIHJldHVybiBuZXcgYWUoZS5yYW5nZXMubWFwKChuKSA9PiB4cy5mcm9tSlNPTihuKSksIGUubWFpbik7XG4gIH1cbiAgLyoqXG4gIENyZWF0ZSBhIHNlbGVjdGlvbiBob2xkaW5nIGEgc2luZ2xlIHJhbmdlLlxuICAqL1xuICBzdGF0aWMgc2luZ2xlKGUsIG4gPSBlKSB7XG4gICAgcmV0dXJuIG5ldyBhZShbYWUucmFuZ2UoZSwgbildLCAwKTtcbiAgfVxuICAvKipcbiAgU29ydCBhbmQgbWVyZ2UgdGhlIGdpdmVuIHNldCBvZiByYW5nZXMsIGNyZWF0aW5nIGEgdmFsaWRcbiAgc2VsZWN0aW9uLlxuICAqL1xuICBzdGF0aWMgY3JlYXRlKGUsIG4gPSAwKSB7XG4gICAgaWYgKGUubGVuZ3RoID09IDApXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkEgc2VsZWN0aW9uIG5lZWRzIGF0IGxlYXN0IG9uZSByYW5nZVwiKTtcbiAgICBmb3IgKGxldCByID0gMCwgaSA9IDA7IGkgPCBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgcyA9IGVbaV07XG4gICAgICBpZiAocy5lbXB0eSA/IHMuZnJvbSA8PSByIDogcy5mcm9tIDwgcilcbiAgICAgICAgcmV0dXJuIGFlLm5vcm1hbGl6ZWQoZS5zbGljZSgpLCBuKTtcbiAgICAgIHIgPSBzLnRvO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IGFlKGUsIG4pO1xuICB9XG4gIC8qKlxuICBDcmVhdGUgYSBjdXJzb3Igc2VsZWN0aW9uIHJhbmdlIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi4gWW91IGNhblxuICBzYWZlbHkgaWdub3JlIHRoZSBvcHRpb25hbCBhcmd1bWVudHMgaW4gbW9zdCBzaXR1YXRpb25zLlxuICAqL1xuICBzdGF0aWMgY3Vyc29yKGUsIG4gPSAwLCByLCBpKSB7XG4gICAgcmV0dXJuIHhzLmNyZWF0ZShlLCBlLCAobiA9PSAwID8gMCA6IG4gPCAwID8gOCA6IDE2KSB8IChyID09IG51bGwgPyA3IDogTWF0aC5taW4oNiwgcikpIHwgKGkgPz8gMTY3NzcyMTUpIDw8IDYpO1xuICB9XG4gIC8qKlxuICBDcmVhdGUgYSBzZWxlY3Rpb24gcmFuZ2UuXG4gICovXG4gIHN0YXRpYyByYW5nZShlLCBuLCByLCBpKSB7XG4gICAgbGV0IHMgPSAociA/PyAxNjc3NzIxNSkgPDwgNiB8IChpID09IG51bGwgPyA3IDogTWF0aC5taW4oNiwgaSkpO1xuICAgIHJldHVybiBuIDwgZSA/IHhzLmNyZWF0ZShuLCBlLCA0OCB8IHMpIDogeHMuY3JlYXRlKGUsIG4sIChuID4gZSA/IDggOiAwKSB8IHMpO1xuICB9XG4gIC8qKlxuICBAaW50ZXJuYWxcbiAgKi9cbiAgc3RhdGljIG5vcm1hbGl6ZWQoZSwgbiA9IDApIHtcbiAgICBsZXQgciA9IGVbbl07XG4gICAgZS5zb3J0KChpLCBzKSA9PiBpLmZyb20gLSBzLmZyb20pLCBuID0gZS5pbmRleE9mKHIpO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgZS5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHMgPSBlW2ldLCBvID0gZVtpIC0gMV07XG4gICAgICBpZiAocy5lbXB0eSA/IHMuZnJvbSA8PSBvLnRvIDogcy5mcm9tIDwgby50bykge1xuICAgICAgICBsZXQgYSA9IG8uZnJvbSwgbCA9IE1hdGgubWF4KHMudG8sIG8udG8pO1xuICAgICAgICBpIDw9IG4gJiYgbi0tLCBlLnNwbGljZSgtLWksIDIsIHMuYW5jaG9yID4gcy5oZWFkID8gYWUucmFuZ2UobCwgYSkgOiBhZS5yYW5nZShhLCBsKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgYWUoZSwgbik7XG4gIH1cbn1cbmZ1bmN0aW9uIE13KHQsIGUpIHtcbiAgZm9yIChsZXQgbiBvZiB0LnJhbmdlcylcbiAgICBpZiAobi50byA+IGUpXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlNlbGVjdGlvbiBwb2ludHMgb3V0c2lkZSBvZiBkb2N1bWVudFwiKTtcbn1cbmxldCB0ZyA9IDA7XG5jbGFzcyB2ZSB7XG4gIGNvbnN0cnVjdG9yKGUsIG4sIHIsIGksIHMpIHtcbiAgICB0aGlzLmNvbWJpbmUgPSBlLCB0aGlzLmNvbXBhcmVJbnB1dCA9IG4sIHRoaXMuY29tcGFyZSA9IHIsIHRoaXMuaXNTdGF0aWMgPSBpLCB0aGlzLmlkID0gdGcrKywgdGhpcy5kZWZhdWx0ID0gZShbXSksIHRoaXMuZXh0ZW5zaW9ucyA9IHR5cGVvZiBzID09IFwiZnVuY3Rpb25cIiA/IHModGhpcykgOiBzO1xuICB9XG4gIC8qKlxuICBSZXR1cm5zIGEgZmFjZXQgcmVhZGVyIGZvciB0aGlzIGZhY2V0LCB3aGljaCBjYW4gYmUgdXNlZCB0b1xuICBbcmVhZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5mYWNldCkgaXQgYnV0IG5vdCB0byBkZWZpbmUgdmFsdWVzIGZvciBpdC5cbiAgKi9cbiAgZ2V0IHJlYWRlcigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgRGVmaW5lIGEgbmV3IGZhY2V0LlxuICAqL1xuICBzdGF0aWMgZGVmaW5lKGUgPSB7fSkge1xuICAgIHJldHVybiBuZXcgdmUoZS5jb21iaW5lIHx8ICgobikgPT4gbiksIGUuY29tcGFyZUlucHV0IHx8ICgobiwgcikgPT4gbiA9PT0gciksIGUuY29tcGFyZSB8fCAoZS5jb21iaW5lID8gKG4sIHIpID0+IG4gPT09IHIgOiBuZyksICEhZS5zdGF0aWMsIGUuZW5hYmxlcyk7XG4gIH1cbiAgLyoqXG4gIFJldHVybnMgYW4gZXh0ZW5zaW9uIHRoYXQgYWRkcyB0aGUgZ2l2ZW4gdmFsdWUgdG8gdGhpcyBmYWNldC5cbiAgKi9cbiAgb2YoZSkge1xuICAgIHJldHVybiBuZXcgbnUoW10sIHRoaXMsIDAsIGUpO1xuICB9XG4gIC8qKlxuICBDcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgY29tcHV0ZXMgYSB2YWx1ZSBmb3IgdGhlIGZhY2V0IGZyb20gYVxuICBzdGF0ZS4gWW91IG11c3QgdGFrZSBjYXJlIHRvIGRlY2xhcmUgdGhlIHBhcnRzIG9mIHRoZSBzdGF0ZSB0aGF0XG4gIHRoaXMgdmFsdWUgZGVwZW5kcyBvbiwgc2luY2UgeW91ciBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZCBhZ2FpblxuICBmb3IgYSBuZXcgc3RhdGUgd2hlbiBvbmUgb2YgdGhvc2UgcGFydHMgY2hhbmdlZC5cbiAgXG4gIEluIGNhc2VzIHdoZXJlIHlvdXIgdmFsdWUgZGVwZW5kcyBvbmx5IG9uIGEgc2luZ2xlIGZpZWxkLCB5b3UnbGxcbiAgd2FudCB0byB1c2UgdGhlIFtgZnJvbWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRmFjZXQuZnJvbSkgbWV0aG9kIGluc3RlYWQuXG4gICovXG4gIGNvbXB1dGUoZSwgbikge1xuICAgIGlmICh0aGlzLmlzU3RhdGljKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgY29tcHV0ZSBhIHN0YXRpYyBmYWNldFwiKTtcbiAgICByZXR1cm4gbmV3IG51KGUsIHRoaXMsIDEsIG4pO1xuICB9XG4gIC8qKlxuICBDcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgY29tcHV0ZXMgemVybyBvciBtb3JlIHZhbHVlcyBmb3IgdGhpc1xuICBmYWNldCBmcm9tIGEgc3RhdGUuXG4gICovXG4gIGNvbXB1dGVOKGUsIG4pIHtcbiAgICBpZiAodGhpcy5pc1N0YXRpYylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGNvbXB1dGUgYSBzdGF0aWMgZmFjZXRcIik7XG4gICAgcmV0dXJuIG5ldyBudShlLCB0aGlzLCAyLCBuKTtcbiAgfVxuICBmcm9tKGUsIG4pIHtcbiAgICByZXR1cm4gbiB8fCAobiA9IChyKSA9PiByKSwgdGhpcy5jb21wdXRlKFtlXSwgKHIpID0+IG4oci5maWVsZChlKSkpO1xuICB9XG59XG5mdW5jdGlvbiBuZyh0LCBlKSB7XG4gIHJldHVybiB0ID09IGUgfHwgdC5sZW5ndGggPT0gZS5sZW5ndGggJiYgdC5ldmVyeSgobiwgcikgPT4gbiA9PT0gZVtyXSk7XG59XG5jbGFzcyBudSB7XG4gIGNvbnN0cnVjdG9yKGUsIG4sIHIsIGkpIHtcbiAgICB0aGlzLmRlcGVuZGVuY2llcyA9IGUsIHRoaXMuZmFjZXQgPSBuLCB0aGlzLnR5cGUgPSByLCB0aGlzLnZhbHVlID0gaSwgdGhpcy5pZCA9IHRnKys7XG4gIH1cbiAgZHluYW1pY1Nsb3QoZSkge1xuICAgIHZhciBuO1xuICAgIGxldCByID0gdGhpcy52YWx1ZSwgaSA9IHRoaXMuZmFjZXQuY29tcGFyZUlucHV0LCBzID0gdGhpcy5pZCwgbyA9IGVbc10gPj4gMSwgYSA9IHRoaXMudHlwZSA9PSAyLCBsID0gITEsIGMgPSAhMSwgdSA9IFtdO1xuICAgIGZvciAobGV0IGQgb2YgdGhpcy5kZXBlbmRlbmNpZXMpXG4gICAgICBkID09IFwiZG9jXCIgPyBsID0gITAgOiBkID09IFwic2VsZWN0aW9uXCIgPyBjID0gITAgOiAoKG4gPSBlW2QuaWRdKSAhPT0gbnVsbCAmJiBuICE9PSB2b2lkIDAgPyBuIDogMSkgJiAxIHx8IHUucHVzaChlW2QuaWRdKTtcbiAgICByZXR1cm4ge1xuICAgICAgY3JlYXRlKGQpIHtcbiAgICAgICAgcmV0dXJuIGQudmFsdWVzW29dID0gcihkKSwgMTtcbiAgICAgIH0sXG4gICAgICB1cGRhdGUoZCwgZikge1xuICAgICAgICBpZiAobCAmJiBmLmRvY0NoYW5nZWQgfHwgYyAmJiAoZi5kb2NDaGFuZ2VkIHx8IGYuc2VsZWN0aW9uKSB8fCBxaChkLCB1KSkge1xuICAgICAgICAgIGxldCBoID0gcihkKTtcbiAgICAgICAgICBpZiAoYSA/ICFaYihoLCBkLnZhbHVlc1tvXSwgaSkgOiAhaShoLCBkLnZhbHVlc1tvXSkpXG4gICAgICAgICAgICByZXR1cm4gZC52YWx1ZXNbb10gPSBoLCAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSxcbiAgICAgIHJlY29uZmlndXJlOiAoZCwgZikgPT4ge1xuICAgICAgICBsZXQgaCwgcCA9IGYuY29uZmlnLmFkZHJlc3Nbc107XG4gICAgICAgIGlmIChwICE9IG51bGwpIHtcbiAgICAgICAgICBsZXQgTyA9IFZ1KGYsIHApO1xuICAgICAgICAgIGlmICh0aGlzLmRlcGVuZGVuY2llcy5ldmVyeSgobSkgPT4gbSBpbnN0YW5jZW9mIHZlID8gZi5mYWNldChtKSA9PT0gZC5mYWNldChtKSA6IG0gaW5zdGFuY2VvZiB5ciA/IGYuZmllbGQobSwgITEpID09IGQuZmllbGQobSwgITEpIDogITApIHx8IChhID8gWmIoaCA9IHIoZCksIE8sIGkpIDogaShoID0gcihkKSwgTykpKVxuICAgICAgICAgICAgcmV0dXJuIGQudmFsdWVzW29dID0gTywgMDtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgaCA9IHIoZCk7XG4gICAgICAgIHJldHVybiBkLnZhbHVlc1tvXSA9IGgsIDE7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gWmIodCwgZSwgbikge1xuICBpZiAodC5sZW5ndGggIT0gZS5sZW5ndGgpXG4gICAgcmV0dXJuICExO1xuICBmb3IgKGxldCByID0gMDsgciA8IHQubGVuZ3RoOyByKyspXG4gICAgaWYgKCFuKHRbcl0sIGVbcl0pKVxuICAgICAgcmV0dXJuICExO1xuICByZXR1cm4gITA7XG59XG5mdW5jdGlvbiBxaCh0LCBlKSB7XG4gIGxldCBuID0gITE7XG4gIGZvciAobGV0IHIgb2YgZSlcbiAgICBZYSh0LCByKSAmIDEgJiYgKG4gPSAhMCk7XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gdE4odCwgZSwgbikge1xuICBsZXQgciA9IG4ubWFwKChsKSA9PiB0W2wuaWRdKSwgaSA9IG4ubWFwKChsKSA9PiBsLnR5cGUpLCBzID0gci5maWx0ZXIoKGwpID0+ICEobCAmIDEpKSwgbyA9IHRbZS5pZF0gPj4gMTtcbiAgZnVuY3Rpb24gYShsKSB7XG4gICAgbGV0IGMgPSBbXTtcbiAgICBmb3IgKGxldCB1ID0gMDsgdSA8IHIubGVuZ3RoOyB1KyspIHtcbiAgICAgIGxldCBkID0gVnUobCwgclt1XSk7XG4gICAgICBpZiAoaVt1XSA9PSAyKVxuICAgICAgICBmb3IgKGxldCBmIG9mIGQpXG4gICAgICAgICAgYy5wdXNoKGYpO1xuICAgICAgZWxzZVxuICAgICAgICBjLnB1c2goZCk7XG4gICAgfVxuICAgIHJldHVybiBlLmNvbWJpbmUoYyk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjcmVhdGUobCkge1xuICAgICAgZm9yIChsZXQgYyBvZiByKVxuICAgICAgICBZYShsLCBjKTtcbiAgICAgIHJldHVybiBsLnZhbHVlc1tvXSA9IGEobCksIDE7XG4gICAgfSxcbiAgICB1cGRhdGUobCwgYykge1xuICAgICAgaWYgKCFxaChsLCBzKSlcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICBsZXQgdSA9IGEobCk7XG4gICAgICByZXR1cm4gZS5jb21wYXJlKHUsIGwudmFsdWVzW29dKSA/IDAgOiAobC52YWx1ZXNbb10gPSB1LCAxKTtcbiAgICB9LFxuICAgIHJlY29uZmlndXJlKGwsIGMpIHtcbiAgICAgIGxldCB1ID0gcWgobCwgciksIGQgPSBjLmNvbmZpZy5mYWNldHNbZS5pZF0sIGYgPSBjLmZhY2V0KGUpO1xuICAgICAgaWYgKGQgJiYgIXUgJiYgbmcobiwgZCkpXG4gICAgICAgIHJldHVybiBsLnZhbHVlc1tvXSA9IGYsIDA7XG4gICAgICBsZXQgaCA9IGEobCk7XG4gICAgICByZXR1cm4gZS5jb21wYXJlKGgsIGYpID8gKGwudmFsdWVzW29dID0gZiwgMCkgOiAobC52YWx1ZXNbb10gPSBoLCAxKTtcbiAgICB9XG4gIH07XG59XG5jb25zdCBWYiA9IC8qIEBfX1BVUkVfXyAqLyB2ZS5kZWZpbmUoeyBzdGF0aWM6ICEwIH0pO1xuY2xhc3MgeXIge1xuICBjb25zdHJ1Y3RvcihlLCBuLCByLCBpLCBzKSB7XG4gICAgdGhpcy5pZCA9IGUsIHRoaXMuY3JlYXRlRiA9IG4sIHRoaXMudXBkYXRlRiA9IHIsIHRoaXMuY29tcGFyZUYgPSBpLCB0aGlzLnNwZWMgPSBzLCB0aGlzLnByb3ZpZGVzID0gdm9pZCAwO1xuICB9XG4gIC8qKlxuICBEZWZpbmUgYSBzdGF0ZSBmaWVsZC5cbiAgKi9cbiAgc3RhdGljIGRlZmluZShlKSB7XG4gICAgbGV0IG4gPSBuZXcgeXIodGcrKywgZS5jcmVhdGUsIGUudXBkYXRlLCBlLmNvbXBhcmUgfHwgKChyLCBpKSA9PiByID09PSBpKSwgZSk7XG4gICAgcmV0dXJuIGUucHJvdmlkZSAmJiAobi5wcm92aWRlcyA9IGUucHJvdmlkZShuKSksIG47XG4gIH1cbiAgY3JlYXRlKGUpIHtcbiAgICBsZXQgbiA9IGUuZmFjZXQoVmIpLmZpbmQoKHIpID0+IHIuZmllbGQgPT0gdGhpcyk7XG4gICAgcmV0dXJuICgobiA9PSBudWxsID8gdm9pZCAwIDogbi5jcmVhdGUpIHx8IHRoaXMuY3JlYXRlRikoZSk7XG4gIH1cbiAgLyoqXG4gIEBpbnRlcm5hbFxuICAqL1xuICBzbG90KGUpIHtcbiAgICBsZXQgbiA9IGVbdGhpcy5pZF0gPj4gMTtcbiAgICByZXR1cm4ge1xuICAgICAgY3JlYXRlOiAocikgPT4gKHIudmFsdWVzW25dID0gdGhpcy5jcmVhdGUociksIDEpLFxuICAgICAgdXBkYXRlOiAociwgaSkgPT4ge1xuICAgICAgICBsZXQgcyA9IHIudmFsdWVzW25dLCBvID0gdGhpcy51cGRhdGVGKHMsIGkpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wYXJlRihzLCBvKSA/IDAgOiAoci52YWx1ZXNbbl0gPSBvLCAxKTtcbiAgICAgIH0sXG4gICAgICByZWNvbmZpZ3VyZTogKHIsIGkpID0+IGkuY29uZmlnLmFkZHJlc3NbdGhpcy5pZF0gIT0gbnVsbCA/IChyLnZhbHVlc1tuXSA9IGkuZmllbGQodGhpcyksIDApIDogKHIudmFsdWVzW25dID0gdGhpcy5jcmVhdGUociksIDEpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBlbmFibGVzIHRoaXMgZmllbGQgYW5kIG92ZXJyaWRlcyB0aGVcbiAgd2F5IGl0IGlzIGluaXRpYWxpemVkLiBDYW4gYmUgdXNlZnVsIHdoZW4geW91IG5lZWQgdG8gcHJvdmlkZSBhXG4gIG5vbi1kZWZhdWx0IHN0YXJ0aW5nIHZhbHVlIGZvciB0aGUgZmllbGQuXG4gICovXG4gIGluaXQoZSkge1xuICAgIHJldHVybiBbdGhpcywgVmIub2YoeyBmaWVsZDogdGhpcywgY3JlYXRlOiBlIH0pXTtcbiAgfVxuICAvKipcbiAgU3RhdGUgZmllbGQgaW5zdGFuY2VzIGNhbiBiZSB1c2VkIGFzXG4gIFtgRXh0ZW5zaW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FeHRlbnNpb24pIHZhbHVlcyB0byBlbmFibGUgdGhlIGZpZWxkIGluIGFcbiAgZ2l2ZW4gc3RhdGUuXG4gICovXG4gIGdldCBleHRlbnNpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cbmNvbnN0IFNzID0geyBsb3dlc3Q6IDQsIGxvdzogMywgZGVmYXVsdDogMiwgaGlnaDogMSwgaGlnaGVzdDogMCB9O1xuZnVuY3Rpb24gYmEodCkge1xuICByZXR1cm4gKGUpID0+IG5ldyBYdyhlLCB0KTtcbn1cbmNvbnN0IHpsID0ge1xuICAvKipcbiAgVGhlIGhpZ2hlc3QgcHJlY2VkZW5jZSBsZXZlbCwgZm9yIGV4dGVuc2lvbnMgdGhhdCBzaG91bGQgZW5kIHVwXG4gIG5lYXIgdGhlIHN0YXJ0IG9mIHRoZSBwcmVjZWRlbmNlIG9yZGVyaW5nLlxuICAqL1xuICBoaWdoZXN0OiAvKiBAX19QVVJFX18gKi8gYmEoU3MuaGlnaGVzdCksXG4gIC8qKlxuICBBIGhpZ2hlci10aGFuLWRlZmF1bHQgcHJlY2VkZW5jZSwgZm9yIGV4dGVuc2lvbnMgdGhhdCBzaG91bGRcbiAgY29tZSBiZWZvcmUgdGhvc2Ugd2l0aCBkZWZhdWx0IHByZWNlZGVuY2UuXG4gICovXG4gIGhpZ2g6IC8qIEBfX1BVUkVfXyAqLyBiYShTcy5oaWdoKSxcbiAgLyoqXG4gIFRoZSBkZWZhdWx0IHByZWNlZGVuY2UsIHdoaWNoIGlzIGFsc28gdXNlZCBmb3IgZXh0ZW5zaW9uc1xuICB3aXRob3V0IGFuIGV4cGxpY2l0IHByZWNlZGVuY2UuXG4gICovXG4gIGRlZmF1bHQ6IC8qIEBfX1BVUkVfXyAqLyBiYShTcy5kZWZhdWx0KSxcbiAgLyoqXG4gIEEgbG93ZXItdGhhbi1kZWZhdWx0IHByZWNlZGVuY2UuXG4gICovXG4gIGxvdzogLyogQF9fUFVSRV9fICovIGJhKFNzLmxvdyksXG4gIC8qKlxuICBUaGUgbG93ZXN0IHByZWNlZGVuY2UgbGV2ZWwuIE1lYW50IGZvciB0aGluZ3MgdGhhdCBzaG91bGQgZW5kIHVwXG4gIG5lYXIgdGhlIGVuZCBvZiB0aGUgZXh0ZW5zaW9uIG9yZGVyLlxuICAqL1xuICBsb3dlc3Q6IC8qIEBfX1BVUkVfXyAqLyBiYShTcy5sb3dlc3QpXG59O1xuY2xhc3MgWHcge1xuICBjb25zdHJ1Y3RvcihlLCBuKSB7XG4gICAgdGhpcy5pbm5lciA9IGUsIHRoaXMucHJlYyA9IG47XG4gIH1cbn1cbmNsYXNzIExkIHtcbiAgLyoqXG4gIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiB0aGlzIGNvbXBhcnRtZW50IHRvIGFkZCB0byB5b3VyIFtzdGF0ZVxuICBjb25maWd1cmF0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlQ29uZmlnLmV4dGVuc2lvbnMpLlxuICAqL1xuICBvZihlKSB7XG4gICAgcmV0dXJuIG5ldyBZaCh0aGlzLCBlKTtcbiAgfVxuICAvKipcbiAgQ3JlYXRlIGFuIFtlZmZlY3RdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmVmZmVjdHMpIHRoYXRcbiAgcmVjb25maWd1cmVzIHRoaXMgY29tcGFydG1lbnQuXG4gICovXG4gIHJlY29uZmlndXJlKGUpIHtcbiAgICByZXR1cm4gTGQucmVjb25maWd1cmUub2YoeyBjb21wYXJ0bWVudDogdGhpcywgZXh0ZW5zaW9uOiBlIH0pO1xuICB9XG4gIC8qKlxuICBHZXQgdGhlIGN1cnJlbnQgY29udGVudCBvZiB0aGUgY29tcGFydG1lbnQgaW4gdGhlIHN0YXRlLCBvclxuICBgdW5kZWZpbmVkYCBpZiBpdCBpc24ndCBwcmVzZW50LlxuICAqL1xuICBnZXQoZSkge1xuICAgIHJldHVybiBlLmNvbmZpZy5jb21wYXJ0bWVudHMuZ2V0KHRoaXMpO1xuICB9XG59XG5jbGFzcyBZaCB7XG4gIGNvbnN0cnVjdG9yKGUsIG4pIHtcbiAgICB0aGlzLmNvbXBhcnRtZW50ID0gZSwgdGhpcy5pbm5lciA9IG47XG4gIH1cbn1cbmNsYXNzIFp1IHtcbiAgY29uc3RydWN0b3IoZSwgbiwgciwgaSwgcywgbykge1xuICAgIGZvciAodGhpcy5iYXNlID0gZSwgdGhpcy5jb21wYXJ0bWVudHMgPSBuLCB0aGlzLmR5bmFtaWNTbG90cyA9IHIsIHRoaXMuYWRkcmVzcyA9IGksIHRoaXMuc3RhdGljVmFsdWVzID0gcywgdGhpcy5mYWNldHMgPSBvLCB0aGlzLnN0YXR1c1RlbXBsYXRlID0gW107IHRoaXMuc3RhdHVzVGVtcGxhdGUubGVuZ3RoIDwgci5sZW5ndGg7IClcbiAgICAgIHRoaXMuc3RhdHVzVGVtcGxhdGUucHVzaChcbiAgICAgICAgMFxuICAgICAgICAvKiBTbG90U3RhdHVzLlVucmVzb2x2ZWQgKi9cbiAgICAgICk7XG4gIH1cbiAgc3RhdGljRmFjZXQoZSkge1xuICAgIGxldCBuID0gdGhpcy5hZGRyZXNzW2UuaWRdO1xuICAgIHJldHVybiBuID09IG51bGwgPyBlLmRlZmF1bHQgOiB0aGlzLnN0YXRpY1ZhbHVlc1tuID4+IDFdO1xuICB9XG4gIHN0YXRpYyByZXNvbHZlKGUsIG4sIHIpIHtcbiAgICBsZXQgaSA9IFtdLCBzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIG8gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIGZvciAobGV0IGYgb2Ygbk4oZSwgbiwgbykpXG4gICAgICBmIGluc3RhbmNlb2YgeXIgPyBpLnB1c2goZikgOiAoc1tmLmZhY2V0LmlkXSB8fCAoc1tmLmZhY2V0LmlkXSA9IFtdKSkucHVzaChmKTtcbiAgICBsZXQgYSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCBsID0gW10sIGMgPSBbXTtcbiAgICBmb3IgKGxldCBmIG9mIGkpXG4gICAgICBhW2YuaWRdID0gYy5sZW5ndGggPDwgMSwgYy5wdXNoKChoKSA9PiBmLnNsb3QoaCkpO1xuICAgIGxldCB1ID0gciA9PSBudWxsID8gdm9pZCAwIDogci5jb25maWcuZmFjZXRzO1xuICAgIGZvciAobGV0IGYgaW4gcykge1xuICAgICAgbGV0IGggPSBzW2ZdLCBwID0gaFswXS5mYWNldCwgTyA9IHUgJiYgdVtmXSB8fCBbXTtcbiAgICAgIGlmIChoLmV2ZXJ5KFxuICAgICAgICAobSkgPT4gbS50eXBlID09IDBcbiAgICAgICAgLyogUHJvdmlkZXIuU3RhdGljICovXG4gICAgICApKVxuICAgICAgICBpZiAoYVtwLmlkXSA9IGwubGVuZ3RoIDw8IDEgfCAxLCBuZyhPLCBoKSlcbiAgICAgICAgICBsLnB1c2goci5mYWNldChwKSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGxldCBtID0gcC5jb21iaW5lKGgubWFwKCh5KSA9PiB5LnZhbHVlKSk7XG4gICAgICAgICAgbC5wdXNoKHIgJiYgcC5jb21wYXJlKG0sIHIuZmFjZXQocCkpID8gci5mYWNldChwKSA6IG0pO1xuICAgICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgZm9yIChsZXQgbSBvZiBoKVxuICAgICAgICAgIG0udHlwZSA9PSAwID8gKGFbbS5pZF0gPSBsLmxlbmd0aCA8PCAxIHwgMSwgbC5wdXNoKG0udmFsdWUpKSA6IChhW20uaWRdID0gYy5sZW5ndGggPDwgMSwgYy5wdXNoKCh5KSA9PiBtLmR5bmFtaWNTbG90KHkpKSk7XG4gICAgICAgIGFbcC5pZF0gPSBjLmxlbmd0aCA8PCAxLCBjLnB1c2goKG0pID0+IHROKG0sIHAsIGgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGQgPSBjLm1hcCgoZikgPT4gZihhKSk7XG4gICAgcmV0dXJuIG5ldyBadShlLCBvLCBkLCBhLCBsLCBzKTtcbiAgfVxufVxuZnVuY3Rpb24gbk4odCwgZSwgbikge1xuICBsZXQgciA9IFtbXSwgW10sIFtdLCBbXSwgW11dLCBpID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZnVuY3Rpb24gcyhvLCBhKSB7XG4gICAgbGV0IGwgPSBpLmdldChvKTtcbiAgICBpZiAobCAhPSBudWxsKSB7XG4gICAgICBpZiAobCA8PSBhKVxuICAgICAgICByZXR1cm47XG4gICAgICBsZXQgYyA9IHJbbF0uaW5kZXhPZihvKTtcbiAgICAgIGMgPiAtMSAmJiByW2xdLnNwbGljZShjLCAxKSwgbyBpbnN0YW5jZW9mIFloICYmIG4uZGVsZXRlKG8uY29tcGFydG1lbnQpO1xuICAgIH1cbiAgICBpZiAoaS5zZXQobywgYSksIEFycmF5LmlzQXJyYXkobykpXG4gICAgICBmb3IgKGxldCBjIG9mIG8pXG4gICAgICAgIHMoYywgYSk7XG4gICAgZWxzZSBpZiAobyBpbnN0YW5jZW9mIFloKSB7XG4gICAgICBpZiAobi5oYXMoby5jb21wYXJ0bWVudCkpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRHVwbGljYXRlIHVzZSBvZiBjb21wYXJ0bWVudCBpbiBleHRlbnNpb25zXCIpO1xuICAgICAgbGV0IGMgPSBlLmdldChvLmNvbXBhcnRtZW50KSB8fCBvLmlubmVyO1xuICAgICAgbi5zZXQoby5jb21wYXJ0bWVudCwgYyksIHMoYywgYSk7XG4gICAgfSBlbHNlIGlmIChvIGluc3RhbmNlb2YgWHcpXG4gICAgICBzKG8uaW5uZXIsIG8ucHJlYyk7XG4gICAgZWxzZSBpZiAobyBpbnN0YW5jZW9mIHlyKVxuICAgICAgclthXS5wdXNoKG8pLCBvLnByb3ZpZGVzICYmIHMoby5wcm92aWRlcywgYSk7XG4gICAgZWxzZSBpZiAobyBpbnN0YW5jZW9mIG51KVxuICAgICAgclthXS5wdXNoKG8pLCBvLmZhY2V0LmV4dGVuc2lvbnMgJiYgcyhvLmZhY2V0LmV4dGVuc2lvbnMsIFNzLmRlZmF1bHQpO1xuICAgIGVsc2Uge1xuICAgICAgbGV0IGMgPSBvLmV4dGVuc2lvbjtcbiAgICAgIGlmICghYylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgZXh0ZW5zaW9uIHZhbHVlIGluIGV4dGVuc2lvbiBzZXQgKCR7b30pLiBUaGlzIHNvbWV0aW1lcyBoYXBwZW5zIGJlY2F1c2UgbXVsdGlwbGUgaW5zdGFuY2VzIG9mIEBjb2RlbWlycm9yL3N0YXRlIGFyZSBsb2FkZWQsIGJyZWFraW5nIGluc3RhbmNlb2YgY2hlY2tzLmApO1xuICAgICAgcyhjLCBhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHModCwgU3MuZGVmYXVsdCksIHIucmVkdWNlKChvLCBhKSA9PiBvLmNvbmNhdChhKSk7XG59XG5mdW5jdGlvbiBZYSh0LCBlKSB7XG4gIGlmIChlICYgMSlcbiAgICByZXR1cm4gMjtcbiAgbGV0IG4gPSBlID4+IDEsIHIgPSB0LnN0YXR1c1tuXTtcbiAgaWYgKHIgPT0gNClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDeWNsaWMgZGVwZW5kZW5jeSBiZXR3ZWVuIGZpZWxkcyBhbmQvb3IgZmFjZXRzXCIpO1xuICBpZiAociAmIDIpXG4gICAgcmV0dXJuIHI7XG4gIHQuc3RhdHVzW25dID0gNDtcbiAgbGV0IGkgPSB0LmNvbXB1dGVTbG90KHQsIHQuY29uZmlnLmR5bmFtaWNTbG90c1tuXSk7XG4gIHJldHVybiB0LnN0YXR1c1tuXSA9IDIgfCBpO1xufVxuZnVuY3Rpb24gVnUodCwgZSkge1xuICByZXR1cm4gZSAmIDEgPyB0LmNvbmZpZy5zdGF0aWNWYWx1ZXNbZSA+PiAxXSA6IHQudmFsdWVzW2UgPj4gMV07XG59XG5jb25zdCBqdyA9IC8qIEBfX1BVUkVfXyAqLyB2ZS5kZWZpbmUoKSwgemggPSAvKiBAX19QVVJFX18gKi8gdmUuZGVmaW5lKHtcbiAgY29tYmluZTogKHQpID0+IHQuc29tZSgoZSkgPT4gZSksXG4gIHN0YXRpYzogITBcbn0pLCBCdyA9IC8qIEBfX1BVUkVfXyAqLyB2ZS5kZWZpbmUoe1xuICBjb21iaW5lOiAodCkgPT4gdC5sZW5ndGggPyB0WzBdIDogdm9pZCAwLFxuICBzdGF0aWM6ICEwXG59KSwgTHcgPSAvKiBAX19QVVJFX18gKi8gdmUuZGVmaW5lKCksIFV3ID0gLyogQF9fUFVSRV9fICovIHZlLmRlZmluZSgpLCBxdyA9IC8qIEBfX1BVUkVfXyAqLyB2ZS5kZWZpbmUoKSwgWXcgPSAvKiBAX19QVVJFX18gKi8gdmUuZGVmaW5lKHtcbiAgY29tYmluZTogKHQpID0+IHQubGVuZ3RoID8gdFswXSA6ICExXG59KTtcbmNsYXNzIG5vIHtcbiAgLyoqXG4gIEBpbnRlcm5hbFxuICAqL1xuICBjb25zdHJ1Y3RvcihlLCBuKSB7XG4gICAgdGhpcy50eXBlID0gZSwgdGhpcy52YWx1ZSA9IG47XG4gIH1cbiAgLyoqXG4gIERlZmluZSBhIG5ldyB0eXBlIG9mIGFubm90YXRpb24uXG4gICovXG4gIHN0YXRpYyBkZWZpbmUoKSB7XG4gICAgcmV0dXJuIG5ldyByTigpO1xuICB9XG59XG5jbGFzcyByTiB7XG4gIC8qKlxuICBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgdGhpcyBhbm5vdGF0aW9uLlxuICAqL1xuICBvZihlKSB7XG4gICAgcmV0dXJuIG5ldyBubyh0aGlzLCBlKTtcbiAgfVxufVxuY2xhc3MgaU4ge1xuICAvKipcbiAgQGludGVybmFsXG4gICovXG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLm1hcCA9IGU7XG4gIH1cbiAgLyoqXG4gIENyZWF0ZSBhIFtzdGF0ZSBlZmZlY3RdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3QpIGluc3RhbmNlIG9mIHRoaXNcbiAgdHlwZS5cbiAgKi9cbiAgb2YoZSkge1xuICAgIHJldHVybiBuZXcgb3QodGhpcywgZSk7XG4gIH1cbn1cbmNsYXNzIG90IHtcbiAgLyoqXG4gIEBpbnRlcm5hbFxuICAqL1xuICBjb25zdHJ1Y3RvcihlLCBuKSB7XG4gICAgdGhpcy50eXBlID0gZSwgdGhpcy52YWx1ZSA9IG47XG4gIH1cbiAgLyoqXG4gIE1hcCB0aGlzIGVmZmVjdCB0aHJvdWdoIGEgcG9zaXRpb24gbWFwcGluZy4gV2lsbCByZXR1cm5cbiAgYHVuZGVmaW5lZGAgd2hlbiB0aGF0IGVuZHMgdXAgZGVsZXRpbmcgdGhlIGVmZmVjdC5cbiAgKi9cbiAgbWFwKGUpIHtcbiAgICBsZXQgbiA9IHRoaXMudHlwZS5tYXAodGhpcy52YWx1ZSwgZSk7XG4gICAgcmV0dXJuIG4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG4gPT0gdGhpcy52YWx1ZSA/IHRoaXMgOiBuZXcgb3QodGhpcy50eXBlLCBuKTtcbiAgfVxuICAvKipcbiAgVGVsbHMgeW91IHdoZXRoZXIgdGhpcyBlZmZlY3Qgb2JqZWN0IGlzIG9mIGEgZ2l2ZW5cbiAgW3R5cGVdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3RUeXBlKS5cbiAgKi9cbiAgaXMoZSkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgPT0gZTtcbiAgfVxuICAvKipcbiAgRGVmaW5lIGEgbmV3IGVmZmVjdCB0eXBlLiBUaGUgdHlwZSBwYXJhbWV0ZXIgaW5kaWNhdGVzIHRoZSB0eXBlXG4gIG9mIHZhbHVlcyB0aGF0IGhpcyBlZmZlY3QgaG9sZHMuIEl0IHNob3VsZCBiZSBhIHR5cGUgdGhhdFxuICBkb2Vzbid0IGluY2x1ZGUgYHVuZGVmaW5lZGAsIHNpbmNlIHRoYXQgaXMgdXNlZCBpblxuICBbbWFwcGluZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5TdGF0ZUVmZmVjdC5tYXApIHRvIGluZGljYXRlIHRoYXQgYW4gZWZmZWN0IGlzXG4gIHJlbW92ZWQuXG4gICovXG4gIHN0YXRpYyBkZWZpbmUoZSA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBpTihlLm1hcCB8fCAoKG4pID0+IG4pKTtcbiAgfVxuICAvKipcbiAgTWFwIGFuIGFycmF5IG9mIGVmZmVjdHMgdGhyb3VnaCBhIGNoYW5nZSBzZXQuXG4gICovXG4gIHN0YXRpYyBtYXBFZmZlY3RzKGUsIG4pIHtcbiAgICBpZiAoIWUubGVuZ3RoKVxuICAgICAgcmV0dXJuIGU7XG4gICAgbGV0IHIgPSBbXTtcbiAgICBmb3IgKGxldCBpIG9mIGUpIHtcbiAgICAgIGxldCBzID0gaS5tYXAobik7XG4gICAgICBzICYmIHIucHVzaChzKTtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbn1cbm90LnJlY29uZmlndXJlID0gLyogQF9fUFVSRV9fICovIG90LmRlZmluZSgpO1xub3QuYXBwZW5kQ29uZmlnID0gLyogQF9fUFVSRV9fICovIG90LmRlZmluZSgpO1xuY2xhc3MgR3Qge1xuICBjb25zdHJ1Y3RvcihlLCBuLCByLCBpLCBzLCBvKSB7XG4gICAgdGhpcy5zdGFydFN0YXRlID0gZSwgdGhpcy5jaGFuZ2VzID0gbiwgdGhpcy5zZWxlY3Rpb24gPSByLCB0aGlzLmVmZmVjdHMgPSBpLCB0aGlzLmFubm90YXRpb25zID0gcywgdGhpcy5zY3JvbGxJbnRvVmlldyA9IG8sIHRoaXMuX2RvYyA9IG51bGwsIHRoaXMuX3N0YXRlID0gbnVsbCwgciAmJiBNdyhyLCBuLm5ld0xlbmd0aCksIHMuc29tZSgoYSkgPT4gYS50eXBlID09IEd0LnRpbWUpIHx8ICh0aGlzLmFubm90YXRpb25zID0gcy5jb25jYXQoR3QudGltZS5vZihEYXRlLm5vdygpKSkpO1xuICB9XG4gIC8qKlxuICBAaW50ZXJuYWxcbiAgKi9cbiAgc3RhdGljIGNyZWF0ZShlLCBuLCByLCBpLCBzLCBvKSB7XG4gICAgcmV0dXJuIG5ldyBHdChlLCBuLCByLCBpLCBzLCBvKTtcbiAgfVxuICAvKipcbiAgVGhlIG5ldyBkb2N1bWVudCBwcm9kdWNlZCBieSB0aGUgdHJhbnNhY3Rpb24uIENvbnRyYXJ5IHRvXG4gIFtgLnN0YXRlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5zdGF0ZSlgLmRvY2AsIGFjY2Vzc2luZyB0aGlzIHdvbid0XG4gIGZvcmNlIHRoZSBlbnRpcmUgbmV3IHN0YXRlIHRvIGJlIGNvbXB1dGVkIHJpZ2h0IGF3YXksIHNvIGl0IGlzXG4gIHJlY29tbWVuZGVkIHRoYXQgW3RyYW5zYWN0aW9uXG4gIGZpbHRlcnNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVedHJhbnNhY3Rpb25GaWx0ZXIpIHVzZSB0aGlzIGdldHRlclxuICB3aGVuIHRoZXkgbmVlZCB0byBsb29rIGF0IHRoZSBuZXcgZG9jdW1lbnQuXG4gICovXG4gIGdldCBuZXdEb2MoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RvYyB8fCAodGhpcy5fZG9jID0gdGhpcy5jaGFuZ2VzLmFwcGx5KHRoaXMuc3RhcnRTdGF0ZS5kb2MpKTtcbiAgfVxuICAvKipcbiAgVGhlIG5ldyBzZWxlY3Rpb24gcHJvZHVjZWQgYnkgdGhlIHRyYW5zYWN0aW9uLiBJZlxuICBbYHRoaXMuc2VsZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5zZWxlY3Rpb24pIGlzIHVuZGVmaW5lZCxcbiAgdGhpcyB3aWxsIFttYXBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU2VsZWN0aW9uLm1hcCkgdGhlIHN0YXJ0IHN0YXRlJ3NcbiAgY3VycmVudCBzZWxlY3Rpb24gdGhyb3VnaCB0aGUgY2hhbmdlcyBtYWRlIGJ5IHRoZSB0cmFuc2FjdGlvbi5cbiAgKi9cbiAgZ2V0IG5ld1NlbGVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24gfHwgdGhpcy5zdGFydFN0YXRlLnNlbGVjdGlvbi5tYXAodGhpcy5jaGFuZ2VzKTtcbiAgfVxuICAvKipcbiAgVGhlIG5ldyBzdGF0ZSBjcmVhdGVkIGJ5IHRoZSB0cmFuc2FjdGlvbi4gQ29tcHV0ZWQgb24gZGVtYW5kXG4gIChidXQgcmV0YWluZWQgZm9yIHN1YnNlcXVlbnQgYWNjZXNzKSwgc28gaXQgaXMgcmVjb21tZW5kZWQgbm90IHRvXG4gIGFjY2VzcyBpdCBpbiBbdHJhbnNhY3Rpb25cbiAgZmlsdGVyc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV50cmFuc2FjdGlvbkZpbHRlcikgd2hlbiBwb3NzaWJsZS5cbiAgKi9cbiAgZ2V0IHN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZSB8fCB0aGlzLnN0YXJ0U3RhdGUuYXBwbHlUcmFuc2FjdGlvbih0aGlzKSwgdGhpcy5fc3RhdGU7XG4gIH1cbiAgLyoqXG4gIEdldCB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIGFubm90YXRpb24gdHlwZSwgaWYgYW55LlxuICAqL1xuICBhbm5vdGF0aW9uKGUpIHtcbiAgICBmb3IgKGxldCBuIG9mIHRoaXMuYW5ub3RhdGlvbnMpXG4gICAgICBpZiAobi50eXBlID09IGUpXG4gICAgICAgIHJldHVybiBuLnZhbHVlO1xuICB9XG4gIC8qKlxuICBJbmRpY2F0ZXMgd2hldGhlciB0aGUgdHJhbnNhY3Rpb24gY2hhbmdlZCB0aGUgZG9jdW1lbnQuXG4gICovXG4gIGdldCBkb2NDaGFuZ2VkKCkge1xuICAgIHJldHVybiAhdGhpcy5jaGFuZ2VzLmVtcHR5O1xuICB9XG4gIC8qKlxuICBJbmRpY2F0ZXMgd2hldGhlciB0aGlzIHRyYW5zYWN0aW9uIHJlY29uZmlndXJlcyB0aGUgc3RhdGVcbiAgKHRocm91Z2ggYSBbY29uZmlndXJhdGlvbiBjb21wYXJ0bWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5Db21wYXJ0bWVudCkgb3JcbiAgd2l0aCBhIHRvcC1sZXZlbCBjb25maWd1cmF0aW9uXG4gIFtlZmZlY3RdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuU3RhdGVFZmZlY3RecmVjb25maWd1cmUpLlxuICAqL1xuICBnZXQgcmVjb25maWd1cmVkKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXJ0U3RhdGUuY29uZmlnICE9IHRoaXMuc3RhdGUuY29uZmlnO1xuICB9XG4gIC8qKlxuICBSZXR1cm5zIHRydWUgaWYgdGhlIHRyYW5zYWN0aW9uIGhhcyBhIFt1c2VyXG4gIGV2ZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uXnVzZXJFdmVudCkgYW5ub3RhdGlvbiB0aGF0IGlzIGVxdWFsIHRvXG4gIG9yIG1vcmUgc3BlY2lmaWMgdGhhbiBgZXZlbnRgLiBGb3IgZXhhbXBsZSwgaWYgdGhlIHRyYW5zYWN0aW9uXG4gIGhhcyBgXCJzZWxlY3QucG9pbnRlclwiYCBhcyB1c2VyIGV2ZW50LCBgXCJzZWxlY3RcImAgYW5kXG4gIGBcInNlbGVjdC5wb2ludGVyXCJgIHdpbGwgbWF0Y2ggaXQuXG4gICovXG4gIGlzVXNlckV2ZW50KGUpIHtcbiAgICBsZXQgbiA9IHRoaXMuYW5ub3RhdGlvbihHdC51c2VyRXZlbnQpO1xuICAgIHJldHVybiAhIShuICYmIChuID09IGUgfHwgbi5sZW5ndGggPiBlLmxlbmd0aCAmJiBuLnNsaWNlKDAsIGUubGVuZ3RoKSA9PSBlICYmIG5bZS5sZW5ndGhdID09IFwiLlwiKSk7XG4gIH1cbn1cbkd0LnRpbWUgPSAvKiBAX19QVVJFX18gKi8gbm8uZGVmaW5lKCk7XG5HdC51c2VyRXZlbnQgPSAvKiBAX19QVVJFX18gKi8gbm8uZGVmaW5lKCk7XG5HdC5hZGRUb0hpc3RvcnkgPSAvKiBAX19QVVJFX18gKi8gbm8uZGVmaW5lKCk7XG5HdC5yZW1vdGUgPSAvKiBAX19QVVJFX18gKi8gbm8uZGVmaW5lKCk7XG5mdW5jdGlvbiBzTih0LCBlKSB7XG4gIGxldCBuID0gW107XG4gIGZvciAobGV0IHIgPSAwLCBpID0gMDsgOyApIHtcbiAgICBsZXQgcywgbztcbiAgICBpZiAociA8IHQubGVuZ3RoICYmIChpID09IGUubGVuZ3RoIHx8IGVbaV0gPj0gdFtyXSkpXG4gICAgICBzID0gdFtyKytdLCBvID0gdFtyKytdO1xuICAgIGVsc2UgaWYgKGkgPCBlLmxlbmd0aClcbiAgICAgIHMgPSBlW2krK10sIG8gPSBlW2krK107XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIG47XG4gICAgIW4ubGVuZ3RoIHx8IG5bbi5sZW5ndGggLSAxXSA8IHMgPyBuLnB1c2gocywgbykgOiBuW24ubGVuZ3RoIC0gMV0gPCBvICYmIChuW24ubGVuZ3RoIC0gMV0gPSBvKTtcbiAgfVxufVxuZnVuY3Rpb24gencodCwgZSwgbikge1xuICB2YXIgcjtcbiAgbGV0IGksIHMsIG87XG4gIHJldHVybiBuID8gKGkgPSBlLmNoYW5nZXMsIHMgPSBNdC5lbXB0eShlLmNoYW5nZXMubGVuZ3RoKSwgbyA9IHQuY2hhbmdlcy5jb21wb3NlKGUuY2hhbmdlcykpIDogKGkgPSBlLmNoYW5nZXMubWFwKHQuY2hhbmdlcyksIHMgPSB0LmNoYW5nZXMubWFwRGVzYyhlLmNoYW5nZXMsICEwKSwgbyA9IHQuY2hhbmdlcy5jb21wb3NlKGkpKSwge1xuICAgIGNoYW5nZXM6IG8sXG4gICAgc2VsZWN0aW9uOiBlLnNlbGVjdGlvbiA/IGUuc2VsZWN0aW9uLm1hcChzKSA6IChyID0gdC5zZWxlY3Rpb24pID09PSBudWxsIHx8IHIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHIubWFwKGkpLFxuICAgIGVmZmVjdHM6IG90Lm1hcEVmZmVjdHModC5lZmZlY3RzLCBpKS5jb25jYXQob3QubWFwRWZmZWN0cyhlLmVmZmVjdHMsIHMpKSxcbiAgICBhbm5vdGF0aW9uczogdC5hbm5vdGF0aW9ucy5sZW5ndGggPyB0LmFubm90YXRpb25zLmNvbmNhdChlLmFubm90YXRpb25zKSA6IGUuYW5ub3RhdGlvbnMsXG4gICAgc2Nyb2xsSW50b1ZpZXc6IHQuc2Nyb2xsSW50b1ZpZXcgfHwgZS5zY3JvbGxJbnRvVmlld1xuICB9O1xufVxuZnVuY3Rpb24gSGgodCwgZSwgbikge1xuICBsZXQgciA9IGUuc2VsZWN0aW9uLCBpID0gX28oZS5hbm5vdGF0aW9ucyk7XG4gIHJldHVybiBlLnVzZXJFdmVudCAmJiAoaSA9IGkuY29uY2F0KEd0LnVzZXJFdmVudC5vZihlLnVzZXJFdmVudCkpKSwge1xuICAgIGNoYW5nZXM6IGUuY2hhbmdlcyBpbnN0YW5jZW9mIE10ID8gZS5jaGFuZ2VzIDogTXQub2YoZS5jaGFuZ2VzIHx8IFtdLCBuLCB0LmZhY2V0KEJ3KSksXG4gICAgc2VsZWN0aW9uOiByICYmIChyIGluc3RhbmNlb2YgYWUgPyByIDogYWUuc2luZ2xlKHIuYW5jaG9yLCByLmhlYWQpKSxcbiAgICBlZmZlY3RzOiBfbyhlLmVmZmVjdHMpLFxuICAgIGFubm90YXRpb25zOiBpLFxuICAgIHNjcm9sbEludG9WaWV3OiAhIWUuc2Nyb2xsSW50b1ZpZXdcbiAgfTtcbn1cbmZ1bmN0aW9uIEh3KHQsIGUsIG4pIHtcbiAgbGV0IHIgPSBIaCh0LCBlLmxlbmd0aCA/IGVbMF0gOiB7fSwgdC5kb2MubGVuZ3RoKTtcbiAgZS5sZW5ndGggJiYgZVswXS5maWx0ZXIgPT09ICExICYmIChuID0gITEpO1xuICBmb3IgKGxldCBzID0gMTsgcyA8IGUubGVuZ3RoOyBzKyspIHtcbiAgICBlW3NdLmZpbHRlciA9PT0gITEgJiYgKG4gPSAhMSk7XG4gICAgbGV0IG8gPSAhIWVbc10uc2VxdWVudGlhbDtcbiAgICByID0gencociwgSGgodCwgZVtzXSwgbyA/IHIuY2hhbmdlcy5uZXdMZW5ndGggOiB0LmRvYy5sZW5ndGgpLCBvKTtcbiAgfVxuICBsZXQgaSA9IEd0LmNyZWF0ZSh0LCByLmNoYW5nZXMsIHIuc2VsZWN0aW9uLCByLmVmZmVjdHMsIHIuYW5ub3RhdGlvbnMsIHIuc2Nyb2xsSW50b1ZpZXcpO1xuICByZXR1cm4gYU4obiA/IG9OKGkpIDogaSk7XG59XG5mdW5jdGlvbiBvTih0KSB7XG4gIGxldCBlID0gdC5zdGFydFN0YXRlLCBuID0gITA7XG4gIGZvciAobGV0IGkgb2YgZS5mYWNldChMdykpIHtcbiAgICBsZXQgcyA9IGkodCk7XG4gICAgaWYgKHMgPT09ICExKSB7XG4gICAgICBuID0gITE7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgQXJyYXkuaXNBcnJheShzKSAmJiAobiA9IG4gPT09ICEwID8gcyA6IHNOKG4sIHMpKTtcbiAgfVxuICBpZiAobiAhPT0gITApIHtcbiAgICBsZXQgaSwgcztcbiAgICBpZiAobiA9PT0gITEpXG4gICAgICBzID0gdC5jaGFuZ2VzLmludmVydGVkRGVzYywgaSA9IE10LmVtcHR5KGUuZG9jLmxlbmd0aCk7XG4gICAgZWxzZSB7XG4gICAgICBsZXQgbyA9IHQuY2hhbmdlcy5maWx0ZXIobik7XG4gICAgICBpID0gby5jaGFuZ2VzLCBzID0gby5maWx0ZXJlZC5tYXBEZXNjKG8uY2hhbmdlcykuaW52ZXJ0ZWREZXNjO1xuICAgIH1cbiAgICB0ID0gR3QuY3JlYXRlKGUsIGksIHQuc2VsZWN0aW9uICYmIHQuc2VsZWN0aW9uLm1hcChzKSwgb3QubWFwRWZmZWN0cyh0LmVmZmVjdHMsIHMpLCB0LmFubm90YXRpb25zLCB0LnNjcm9sbEludG9WaWV3KTtcbiAgfVxuICBsZXQgciA9IGUuZmFjZXQoVXcpO1xuICBmb3IgKGxldCBpID0gci5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGxldCBzID0gcltpXSh0KTtcbiAgICBzIGluc3RhbmNlb2YgR3QgPyB0ID0gcyA6IEFycmF5LmlzQXJyYXkocykgJiYgcy5sZW5ndGggPT0gMSAmJiBzWzBdIGluc3RhbmNlb2YgR3QgPyB0ID0gc1swXSA6IHQgPSBIdyhlLCBfbyhzKSwgITEpO1xuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gYU4odCkge1xuICBsZXQgZSA9IHQuc3RhcnRTdGF0ZSwgbiA9IGUuZmFjZXQocXcpLCByID0gdDtcbiAgZm9yIChsZXQgaSA9IG4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBsZXQgcyA9IG5baV0odCk7XG4gICAgcyAmJiBPYmplY3Qua2V5cyhzKS5sZW5ndGggJiYgKHIgPSB6dyhyLCBIaChlLCBzLCB0LmNoYW5nZXMubmV3TGVuZ3RoKSwgITApKTtcbiAgfVxuICByZXR1cm4gciA9PSB0ID8gdCA6IEd0LmNyZWF0ZShlLCB0LmNoYW5nZXMsIHQuc2VsZWN0aW9uLCByLmVmZmVjdHMsIHIuYW5ub3RhdGlvbnMsIHIuc2Nyb2xsSW50b1ZpZXcpO1xufVxuY29uc3QgbE4gPSBbXTtcbmZ1bmN0aW9uIF9vKHQpIHtcbiAgcmV0dXJuIHQgPT0gbnVsbCA/IGxOIDogQXJyYXkuaXNBcnJheSh0KSA/IHQgOiBbdF07XG59XG52YXIgSG4gPSAvKiBAX19QVVJFX18gKi8gZnVuY3Rpb24odCkge1xuICByZXR1cm4gdFt0LldvcmQgPSAwXSA9IFwiV29yZFwiLCB0W3QuU3BhY2UgPSAxXSA9IFwiU3BhY2VcIiwgdFt0Lk90aGVyID0gMl0gPSBcIk90aGVyXCIsIHQ7XG59KEhuIHx8IChIbiA9IHt9KSk7XG5jb25zdCBjTiA9IC9bXFx1MDBkZlxcdTA1ODdcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUzMDQwLVxcdTMwOWZcXHUzMGEwLVxcdTMwZmZcXHUzNDAwLVxcdTRkYjVcXHU0ZTAwLVxcdTlmY2NcXHVhYzAwLVxcdWQ3YWZdLztcbmxldCBGaDtcbnRyeSB7XG4gIEZoID0gLyogQF9fUFVSRV9fICovIG5ldyBSZWdFeHAoXCJbXFxcXHB7QWxwaGFiZXRpY31cXFxccHtOdW1iZXJ9X11cIiwgXCJ1XCIpO1xufSBjYXRjaCB7XG59XG5mdW5jdGlvbiB1Tih0KSB7XG4gIGlmIChGaClcbiAgICByZXR1cm4gRmgudGVzdCh0KTtcbiAgZm9yIChsZXQgZSA9IDA7IGUgPCB0Lmxlbmd0aDsgZSsrKSB7XG4gICAgbGV0IG4gPSB0W2VdO1xuICAgIGlmICgvXFx3Ly50ZXN0KG4pIHx8IG4gPiBcIsKAXCIgJiYgKG4udG9VcHBlckNhc2UoKSAhPSBuLnRvTG93ZXJDYXNlKCkgfHwgY04udGVzdChuKSkpXG4gICAgICByZXR1cm4gITA7XG4gIH1cbiAgcmV0dXJuICExO1xufVxuZnVuY3Rpb24gZE4odCkge1xuICByZXR1cm4gKGUpID0+IHtcbiAgICBpZiAoIS9cXFMvLnRlc3QoZSkpXG4gICAgICByZXR1cm4gSG4uU3BhY2U7XG4gICAgaWYgKHVOKGUpKVxuICAgICAgcmV0dXJuIEhuLldvcmQ7XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCB0Lmxlbmd0aDsgbisrKVxuICAgICAgaWYgKGUuaW5kZXhPZih0W25dKSA+IC0xKVxuICAgICAgICByZXR1cm4gSG4uV29yZDtcbiAgICByZXR1cm4gSG4uT3RoZXI7XG4gIH07XG59XG5jbGFzcyBZZSB7XG4gIGNvbnN0cnVjdG9yKGUsIG4sIHIsIGksIHMsIG8pIHtcbiAgICB0aGlzLmNvbmZpZyA9IGUsIHRoaXMuZG9jID0gbiwgdGhpcy5zZWxlY3Rpb24gPSByLCB0aGlzLnZhbHVlcyA9IGksIHRoaXMuc3RhdHVzID0gZS5zdGF0dXNUZW1wbGF0ZS5zbGljZSgpLCB0aGlzLmNvbXB1dGVTbG90ID0gcywgbyAmJiAoby5fc3RhdGUgPSB0aGlzKTtcbiAgICBmb3IgKGxldCBhID0gMDsgYSA8IHRoaXMuY29uZmlnLmR5bmFtaWNTbG90cy5sZW5ndGg7IGErKylcbiAgICAgIFlhKHRoaXMsIGEgPDwgMSk7XG4gICAgdGhpcy5jb21wdXRlU2xvdCA9IG51bGw7XG4gIH1cbiAgZmllbGQoZSwgbiA9ICEwKSB7XG4gICAgbGV0IHIgPSB0aGlzLmNvbmZpZy5hZGRyZXNzW2UuaWRdO1xuICAgIGlmIChyID09IG51bGwpIHtcbiAgICAgIGlmIChuKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkZpZWxkIGlzIG5vdCBwcmVzZW50IGluIHRoaXMgc3RhdGVcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBZYSh0aGlzLCByKSwgVnUodGhpcywgcik7XG4gIH1cbiAgLyoqXG4gIENyZWF0ZSBhIFt0cmFuc2FjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbikgdGhhdCB1cGRhdGVzIHRoaXNcbiAgc3RhdGUuIEFueSBudW1iZXIgb2YgW3RyYW5zYWN0aW9uIHNwZWNzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYylcbiAgY2FuIGJlIHBhc3NlZC4gVW5sZXNzXG4gIFtgc2VxdWVudGlhbGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLnNlcXVlbnRpYWwpIGlzIHNldCwgdGhlXG4gIFtjaGFuZ2VzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5jaGFuZ2VzKSAoaWYgYW55KSBvZiBlYWNoIHNwZWNcbiAgYXJlIGFzc3VtZWQgdG8gc3RhcnQgaW4gdGhlIF9jdXJyZW50XyBkb2N1bWVudCAobm90IHRoZSBkb2N1bWVudFxuICBwcm9kdWNlZCBieSBwcmV2aW91cyBzcGVjcyksIGFuZCBpdHNcbiAgW3NlbGVjdGlvbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuc2VsZWN0aW9uKSBhbmRcbiAgW2VmZmVjdHNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjLmVmZmVjdHMpIGFyZSBhc3N1bWVkIHRvIHJlZmVyXG4gIHRvIHRoZSBkb2N1bWVudCBjcmVhdGVkIGJ5IGl0cyBfb3duXyBjaGFuZ2VzLiBUaGUgcmVzdWx0aW5nXG4gIHRyYW5zYWN0aW9uIGNvbnRhaW5zIHRoZSBjb21iaW5lZCBlZmZlY3Qgb2YgYWxsIHRoZSBkaWZmZXJlbnRcbiAgc3BlY3MuIEZvciBbc2VsZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uU3BlYy5zZWxlY3Rpb24pLCBsYXRlclxuICBzcGVjcyB0YWtlIHByZWNlZGVuY2Ugb3ZlciBlYXJsaWVyIG9uZXMuXG4gICovXG4gIHVwZGF0ZSguLi5lKSB7XG4gICAgcmV0dXJuIEh3KHRoaXMsIGUsICEwKTtcbiAgfVxuICAvKipcbiAgQGludGVybmFsXG4gICovXG4gIGFwcGx5VHJhbnNhY3Rpb24oZSkge1xuICAgIGxldCBuID0gdGhpcy5jb25maWcsIHsgYmFzZTogciwgY29tcGFydG1lbnRzOiBpIH0gPSBuO1xuICAgIGZvciAobGV0IGEgb2YgZS5lZmZlY3RzKVxuICAgICAgYS5pcyhMZC5yZWNvbmZpZ3VyZSkgPyAobiAmJiAoaSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIG4uY29tcGFydG1lbnRzLmZvckVhY2goKGwsIGMpID0+IGkuc2V0KGMsIGwpKSwgbiA9IG51bGwpLCBpLnNldChhLnZhbHVlLmNvbXBhcnRtZW50LCBhLnZhbHVlLmV4dGVuc2lvbikpIDogYS5pcyhvdC5yZWNvbmZpZ3VyZSkgPyAobiA9IG51bGwsIHIgPSBhLnZhbHVlKSA6IGEuaXMob3QuYXBwZW5kQ29uZmlnKSAmJiAobiA9IG51bGwsIHIgPSBfbyhyKS5jb25jYXQoYS52YWx1ZSkpO1xuICAgIGxldCBzO1xuICAgIG4gPyBzID0gZS5zdGFydFN0YXRlLnZhbHVlcy5zbGljZSgpIDogKG4gPSBadS5yZXNvbHZlKHIsIGksIHRoaXMpLCBzID0gbmV3IFllKG4sIHRoaXMuZG9jLCB0aGlzLnNlbGVjdGlvbiwgbi5keW5hbWljU2xvdHMubWFwKCgpID0+IG51bGwpLCAobCwgYykgPT4gYy5yZWNvbmZpZ3VyZShsLCB0aGlzKSwgbnVsbCkudmFsdWVzKTtcbiAgICBsZXQgbyA9IGUuc3RhcnRTdGF0ZS5mYWNldCh6aCkgPyBlLm5ld1NlbGVjdGlvbiA6IGUubmV3U2VsZWN0aW9uLmFzU2luZ2xlKCk7XG4gICAgbmV3IFllKG4sIGUubmV3RG9jLCBvLCBzLCAoYSwgbCkgPT4gbC51cGRhdGUoYSwgZSksIGUpO1xuICB9XG4gIC8qKlxuICBDcmVhdGUgYSBbdHJhbnNhY3Rpb24gc3BlY10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMpIHRoYXRcbiAgcmVwbGFjZXMgZXZlcnkgc2VsZWN0aW9uIHJhbmdlIHdpdGggdGhlIGdpdmVuIGNvbnRlbnQuXG4gICovXG4gIHJlcGxhY2VTZWxlY3Rpb24oZSkge1xuICAgIHJldHVybiB0eXBlb2YgZSA9PSBcInN0cmluZ1wiICYmIChlID0gdGhpcy50b1RleHQoZSkpLCB0aGlzLmNoYW5nZUJ5UmFuZ2UoKG4pID0+ICh7XG4gICAgICBjaGFuZ2VzOiB7IGZyb206IG4uZnJvbSwgdG86IG4udG8sIGluc2VydDogZSB9LFxuICAgICAgcmFuZ2U6IGFlLmN1cnNvcihuLmZyb20gKyBlLmxlbmd0aClcbiAgICB9KSk7XG4gIH1cbiAgLyoqXG4gIENyZWF0ZSBhIHNldCBvZiBjaGFuZ2VzIGFuZCBhIG5ldyBzZWxlY3Rpb24gYnkgcnVubmluZyB0aGUgZ2l2ZW5cbiAgZnVuY3Rpb24gZm9yIGVhY2ggcmFuZ2UgaW4gdGhlIGFjdGl2ZSBzZWxlY3Rpb24uIFRoZSBmdW5jdGlvblxuICBjYW4gcmV0dXJuIGFuIG9wdGlvbmFsIHNldCBvZiBjaGFuZ2VzIChpbiB0aGUgY29vcmRpbmF0ZSBzcGFjZVxuICBvZiB0aGUgc3RhcnQgZG9jdW1lbnQpLCBwbHVzIGFuIHVwZGF0ZWQgcmFuZ2UgKGluIHRoZSBjb29yZGluYXRlXG4gIHNwYWNlIG9mIHRoZSBkb2N1bWVudCBwcm9kdWNlZCBieSB0aGUgY2FsbCdzIG93biBjaGFuZ2VzKS4gVGhpc1xuICBtZXRob2Qgd2lsbCBtZXJnZSBhbGwgdGhlIGNoYW5nZXMgYW5kIHJhbmdlcyBpbnRvIGEgc2luZ2xlXG4gIGNoYW5nZXNldCBhbmQgc2VsZWN0aW9uLCBhbmQgcmV0dXJuIGl0IGFzIGEgW3RyYW5zYWN0aW9uXG4gIHNwZWNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuVHJhbnNhY3Rpb25TcGVjKSwgd2hpY2ggY2FuIGJlIHBhc3NlZCB0b1xuICBbYHVwZGF0ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudXBkYXRlKS5cbiAgKi9cbiAgY2hhbmdlQnlSYW5nZShlKSB7XG4gICAgbGV0IG4gPSB0aGlzLnNlbGVjdGlvbiwgciA9IGUobi5yYW5nZXNbMF0pLCBpID0gdGhpcy5jaGFuZ2VzKHIuY2hhbmdlcyksIHMgPSBbci5yYW5nZV0sIG8gPSBfbyhyLmVmZmVjdHMpO1xuICAgIGZvciAobGV0IGEgPSAxOyBhIDwgbi5yYW5nZXMubGVuZ3RoOyBhKyspIHtcbiAgICAgIGxldCBsID0gZShuLnJhbmdlc1thXSksIGMgPSB0aGlzLmNoYW5nZXMobC5jaGFuZ2VzKSwgdSA9IGMubWFwKGkpO1xuICAgICAgZm9yIChsZXQgZiA9IDA7IGYgPCBhOyBmKyspXG4gICAgICAgIHNbZl0gPSBzW2ZdLm1hcCh1KTtcbiAgICAgIGxldCBkID0gaS5tYXBEZXNjKGMsICEwKTtcbiAgICAgIHMucHVzaChsLnJhbmdlLm1hcChkKSksIGkgPSBpLmNvbXBvc2UodSksIG8gPSBvdC5tYXBFZmZlY3RzKG8sIHUpLmNvbmNhdChvdC5tYXBFZmZlY3RzKF9vKGwuZWZmZWN0cyksIGQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNoYW5nZXM6IGksXG4gICAgICBzZWxlY3Rpb246IGFlLmNyZWF0ZShzLCBuLm1haW5JbmRleCksXG4gICAgICBlZmZlY3RzOiBvXG4gICAgfTtcbiAgfVxuICAvKipcbiAgQ3JlYXRlIGEgW2NoYW5nZSBzZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuQ2hhbmdlU2V0KSBmcm9tIHRoZSBnaXZlbiBjaGFuZ2VcbiAgZGVzY3JpcHRpb24sIHRha2luZyB0aGUgc3RhdGUncyBkb2N1bWVudCBsZW5ndGggYW5kIGxpbmVcbiAgc2VwYXJhdG9yIGludG8gYWNjb3VudC5cbiAgKi9cbiAgY2hhbmdlcyhlID0gW10pIHtcbiAgICByZXR1cm4gZSBpbnN0YW5jZW9mIE10ID8gZSA6IE10Lm9mKGUsIHRoaXMuZG9jLmxlbmd0aCwgdGhpcy5mYWNldChZZS5saW5lU2VwYXJhdG9yKSk7XG4gIH1cbiAgLyoqXG4gIFVzaW5nIHRoZSBzdGF0ZSdzIFtsaW5lXG4gIHNlcGFyYXRvcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5saW5lU2VwYXJhdG9yKSwgY3JlYXRlIGFcbiAgW2BUZXh0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UZXh0KSBpbnN0YW5jZSBmcm9tIHRoZSBnaXZlbiBzdHJpbmcuXG4gICovXG4gIHRvVGV4dChlKSB7XG4gICAgcmV0dXJuIEZlLm9mKGUuc3BsaXQodGhpcy5mYWNldChZZS5saW5lU2VwYXJhdG9yKSB8fCBCaCkpO1xuICB9XG4gIC8qKlxuICBSZXR1cm4gdGhlIGdpdmVuIHJhbmdlIG9mIHRoZSBkb2N1bWVudCBhcyBhIHN0cmluZy5cbiAgKi9cbiAgc2xpY2VEb2MoZSA9IDAsIG4gPSB0aGlzLmRvYy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5kb2Muc2xpY2VTdHJpbmcoZSwgbiwgdGhpcy5saW5lQnJlYWspO1xuICB9XG4gIC8qKlxuICBHZXQgdGhlIHZhbHVlIG9mIGEgc3RhdGUgW2ZhY2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkZhY2V0KS5cbiAgKi9cbiAgZmFjZXQoZSkge1xuICAgIGxldCBuID0gdGhpcy5jb25maWcuYWRkcmVzc1tlLmlkXTtcbiAgICByZXR1cm4gbiA9PSBudWxsID8gZS5kZWZhdWx0IDogKFlhKHRoaXMsIG4pLCBWdSh0aGlzLCBuKSk7XG4gIH1cbiAgLyoqXG4gIENvbnZlcnQgdGhpcyBzdGF0ZSB0byBhIEpTT04tc2VyaWFsaXphYmxlIG9iamVjdC4gV2hlbiBjdXN0b21cbiAgZmllbGRzIHNob3VsZCBiZSBzZXJpYWxpemVkLCB5b3UgY2FuIHBhc3MgdGhlbSBpbiBhcyBhbiBvYmplY3RcbiAgbWFwcGluZyBwcm9wZXJ0eSBuYW1lcyAoaW4gdGhlIHJlc3VsdGluZyBvYmplY3QsIHdoaWNoIHNob3VsZFxuICBub3QgdXNlIGBkb2NgIG9yIGBzZWxlY3Rpb25gKSB0byBmaWVsZHMuXG4gICovXG4gIHRvSlNPTihlKSB7XG4gICAgbGV0IG4gPSB7XG4gICAgICBkb2M6IHRoaXMuc2xpY2VEb2MoKSxcbiAgICAgIHNlbGVjdGlvbjogdGhpcy5zZWxlY3Rpb24udG9KU09OKClcbiAgICB9O1xuICAgIGlmIChlKVxuICAgICAgZm9yIChsZXQgciBpbiBlKSB7XG4gICAgICAgIGxldCBpID0gZVtyXTtcbiAgICAgICAgaSBpbnN0YW5jZW9mIHlyICYmIHRoaXMuY29uZmlnLmFkZHJlc3NbaS5pZF0gIT0gbnVsbCAmJiAobltyXSA9IGkuc3BlYy50b0pTT04odGhpcy5maWVsZChlW3JdKSwgdGhpcykpO1xuICAgICAgfVxuICAgIHJldHVybiBuO1xuICB9XG4gIC8qKlxuICBEZXNlcmlhbGl6ZSBhIHN0YXRlIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uIFdoZW4gY3VzdG9tXG4gIGZpZWxkcyBzaG91bGQgYmUgZGVzZXJpYWxpemVkLCBwYXNzIHRoZSBzYW1lIG9iamVjdCB5b3UgcGFzc2VkXG4gIHRvIFtgdG9KU09OYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS50b0pTT04pIHdoZW4gc2VyaWFsaXppbmcgYXNcbiAgdGhpcmQgYXJndW1lbnQuXG4gICovXG4gIHN0YXRpYyBmcm9tSlNPTihlLCBuID0ge30sIHIpIHtcbiAgICBpZiAoIWUgfHwgdHlwZW9mIGUuZG9jICE9IFwic3RyaW5nXCIpXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgSlNPTiByZXByZXNlbnRhdGlvbiBmb3IgRWRpdG9yU3RhdGVcIik7XG4gICAgbGV0IGkgPSBbXTtcbiAgICBpZiAocikge1xuICAgICAgZm9yIChsZXQgcyBpbiByKVxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIHMpKSB7XG4gICAgICAgICAgbGV0IG8gPSByW3NdLCBhID0gZVtzXTtcbiAgICAgICAgICBpLnB1c2goby5pbml0KChsKSA9PiBvLnNwZWMuZnJvbUpTT04oYSwgbCkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gWWUuY3JlYXRlKHtcbiAgICAgIGRvYzogZS5kb2MsXG4gICAgICBzZWxlY3Rpb246IGFlLmZyb21KU09OKGUuc2VsZWN0aW9uKSxcbiAgICAgIGV4dGVuc2lvbnM6IG4uZXh0ZW5zaW9ucyA/IGkuY29uY2F0KFtuLmV4dGVuc2lvbnNdKSA6IGlcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgQ3JlYXRlIGEgbmV3IHN0YXRlLiBZb3UnbGwgdXN1YWxseSBvbmx5IG5lZWQgdGhpcyB3aGVuXG4gIGluaXRpYWxpemluZyBhbiBlZGl0b3LigJR1cGRhdGVkIHN0YXRlcyBhcmUgY3JlYXRlZCBieSBhcHBseWluZ1xuICB0cmFuc2FjdGlvbnMuXG4gICovXG4gIHN0YXRpYyBjcmVhdGUoZSA9IHt9KSB7XG4gICAgbGV0IG4gPSBadS5yZXNvbHZlKGUuZXh0ZW5zaW9ucyB8fCBbXSwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSksIHIgPSBlLmRvYyBpbnN0YW5jZW9mIEZlID8gZS5kb2MgOiBGZS5vZigoZS5kb2MgfHwgXCJcIikuc3BsaXQobi5zdGF0aWNGYWNldChZZS5saW5lU2VwYXJhdG9yKSB8fCBCaCkpLCBpID0gZS5zZWxlY3Rpb24gPyBlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIGFlID8gZS5zZWxlY3Rpb24gOiBhZS5zaW5nbGUoZS5zZWxlY3Rpb24uYW5jaG9yLCBlLnNlbGVjdGlvbi5oZWFkKSA6IGFlLnNpbmdsZSgwKTtcbiAgICByZXR1cm4gTXcoaSwgci5sZW5ndGgpLCBuLnN0YXRpY0ZhY2V0KHpoKSB8fCAoaSA9IGkuYXNTaW5nbGUoKSksIG5ldyBZZShuLCByLCBpLCBuLmR5bmFtaWNTbG90cy5tYXAoKCkgPT4gbnVsbCksIChzLCBvKSA9PiBvLmNyZWF0ZShzKSwgbnVsbCk7XG4gIH1cbiAgLyoqXG4gIFRoZSBzaXplIChpbiBjb2x1bW5zKSBvZiBhIHRhYiBpbiB0aGUgZG9jdW1lbnQsIGRldGVybWluZWQgYnlcbiAgdGhlIFtgdGFiU2l6ZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVedGFiU2l6ZSkgZmFjZXQuXG4gICovXG4gIGdldCB0YWJTaXplKCkge1xuICAgIHJldHVybiB0aGlzLmZhY2V0KFllLnRhYlNpemUpO1xuICB9XG4gIC8qKlxuICBHZXQgdGhlIHByb3BlciBbbGluZS1icmVha10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5saW5lU2VwYXJhdG9yKVxuICBzdHJpbmcgZm9yIHRoaXMgc3RhdGUuXG4gICovXG4gIGdldCBsaW5lQnJlYWsoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmFjZXQoWWUubGluZVNlcGFyYXRvcikgfHwgYFxuYDtcbiAgfVxuICAvKipcbiAgUmV0dXJucyB0cnVlIHdoZW4gdGhlIGVkaXRvciBpc1xuICBbY29uZmlndXJlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5yZWFkT25seSkgdG8gYmUgcmVhZC1vbmx5LlxuICAqL1xuICBnZXQgcmVhZE9ubHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmFjZXQoWXcpO1xuICB9XG4gIC8qKlxuICBMb29rIHVwIGEgdHJhbnNsYXRpb24gZm9yIHRoZSBnaXZlbiBwaHJhc2UgKHZpYSB0aGVcbiAgW2BwaHJhc2VzYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5waHJhc2VzKSBmYWNldCksIG9yIHJldHVybiB0aGVcbiAgb3JpZ2luYWwgc3RyaW5nIGlmIG5vIHRyYW5zbGF0aW9uIGlzIGZvdW5kLlxuICBcbiAgSWYgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlIHBhc3NlZCwgdGhleSB3aWxsIGJlIGluc2VydGVkIGluXG4gIHBsYWNlIG9mIG1hcmtlcnMgbGlrZSBgJDFgIChmb3IgdGhlIGZpcnN0IHZhbHVlKSBhbmQgYCQyYCwgZXRjLlxuICBBIHNpbmdsZSBgJGAgaXMgZXF1aXZhbGVudCB0byBgJDFgLCBhbmQgYCQkYCB3aWxsIHByb2R1Y2UgYVxuICBsaXRlcmFsIGRvbGxhciBzaWduLlxuICAqL1xuICBwaHJhc2UoZSwgLi4ubikge1xuICAgIGZvciAobGV0IHIgb2YgdGhpcy5mYWNldChZZS5waHJhc2VzKSlcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwociwgZSkpIHtcbiAgICAgICAgZSA9IHJbZV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIHJldHVybiBuLmxlbmd0aCAmJiAoZSA9IGUucmVwbGFjZSgvXFwkKFxcJHxcXGQqKS9nLCAociwgaSkgPT4ge1xuICAgICAgaWYgKGkgPT0gXCIkXCIpXG4gICAgICAgIHJldHVybiBcIiRcIjtcbiAgICAgIGxldCBzID0gKyhpIHx8IDEpO1xuICAgICAgcmV0dXJuICFzIHx8IHMgPiBuLmxlbmd0aCA/IHIgOiBuW3MgLSAxXTtcbiAgICB9KSksIGU7XG4gIH1cbiAgLyoqXG4gIEZpbmQgdGhlIHZhbHVlcyBmb3IgYSBnaXZlbiBsYW5ndWFnZSBkYXRhIGZpZWxkLCBwcm92aWRlZCBieSB0aGVcbiAgdGhlIFtgbGFuZ3VhZ2VEYXRhYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV5sYW5ndWFnZURhdGEpIGZhY2V0LlxuICBcbiAgRXhhbXBsZXMgb2YgbGFuZ3VhZ2UgZGF0YSBmaWVsZHMgYXJlLi4uXG4gIFxuICAtIFtgXCJjb21tZW50VG9rZW5zXCJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2NvbW1hbmRzLkNvbW1lbnRUb2tlbnMpIGZvciBzcGVjaWZ5aW5nXG4gICAgY29tbWVudCBzeW50YXguXG4gIC0gW2BcImF1dG9jb21wbGV0ZVwiYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNhdXRvY29tcGxldGUuYXV0b2NvbXBsZXRpb25eY29uZmlnLm92ZXJyaWRlKVxuICAgIGZvciBwcm92aWRpbmcgbGFuZ3VhZ2Utc3BlY2lmaWMgY29tcGxldGlvbiBzb3VyY2VzLlxuICAtIFtgXCJ3b3JkQ2hhcnNcImBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuY2hhckNhdGVnb3JpemVyKSBmb3IgYWRkaW5nXG4gICAgY2hhcmFjdGVycyB0aGF0IHNob3VsZCBiZSBjb25zaWRlcmVkIHBhcnQgb2Ygd29yZHMgaW4gdGhpc1xuICAgIGxhbmd1YWdlLlxuICAtIFtgXCJjbG9zZUJyYWNrZXRzXCJgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5DbG9zZUJyYWNrZXRDb25maWcpIGNvbnRyb2xzXG4gICAgYnJhY2tldCBjbG9zaW5nIGJlaGF2aW9yLlxuICAqL1xuICBsYW5ndWFnZURhdGFBdChlLCBuLCByID0gLTEpIHtcbiAgICBsZXQgaSA9IFtdO1xuICAgIGZvciAobGV0IHMgb2YgdGhpcy5mYWNldChqdykpXG4gICAgICBmb3IgKGxldCBvIG9mIHModGhpcywgbiwgcikpXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBlKSAmJiBpLnB1c2gob1tlXSk7XG4gICAgcmV0dXJuIGk7XG4gIH1cbiAgLyoqXG4gIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgY2FuIGNhdGVnb3JpemUgc3RyaW5ncyAoZXhwZWN0ZWQgdG9cbiAgcmVwcmVzZW50IGEgc2luZ2xlIFtncmFwaGVtZSBjbHVzdGVyXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLmZpbmRDbHVzdGVyQnJlYWspKVxuICBpbnRvIG9uZSBvZjpcbiAgXG4gICAtIFdvcmQgKGNvbnRhaW5zIGFuIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXIgb3IgYSBjaGFyYWN0ZXJcbiAgICAgZXhwbGljaXRseSBsaXN0ZWQgaW4gdGhlIGxvY2FsIGxhbmd1YWdlJ3MgYFwid29yZENoYXJzXCJgXG4gICAgIGxhbmd1YWdlIGRhdGEsIHdoaWNoIHNob3VsZCBiZSBhIHN0cmluZylcbiAgIC0gU3BhY2UgKGNvbnRhaW5zIG9ubHkgd2hpdGVzcGFjZSlcbiAgIC0gT3RoZXIgKGFueXRoaW5nIGVsc2UpXG4gICovXG4gIGNoYXJDYXRlZ29yaXplcihlKSB7XG4gICAgcmV0dXJuIGROKHRoaXMubGFuZ3VhZ2VEYXRhQXQoXCJ3b3JkQ2hhcnNcIiwgZSkuam9pbihcIlwiKSk7XG4gIH1cbiAgLyoqXG4gIEZpbmQgdGhlIHdvcmQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLCBtZWFuaW5nIHRoZSByYW5nZVxuICBjb250YWluaW5nIGFsbCBbd29yZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5DaGFyQ2F0ZWdvcnkuV29yZCkgY2hhcmFjdGVyc1xuICBhcm91bmQgaXQuIElmIG5vIHdvcmQgY2hhcmFjdGVycyBhcmUgYWRqYWNlbnQgdG8gdGhlIHBvc2l0aW9uLFxuICB0aGlzIHJldHVybnMgbnVsbC5cbiAgKi9cbiAgd29yZEF0KGUpIHtcbiAgICBsZXQgeyB0ZXh0OiBuLCBmcm9tOiByLCBsZW5ndGg6IGkgfSA9IHRoaXMuZG9jLmxpbmVBdChlKSwgcyA9IHRoaXMuY2hhckNhdGVnb3JpemVyKGUpLCBvID0gZSAtIHIsIGEgPSBlIC0gcjtcbiAgICBmb3IgKDsgbyA+IDA7ICkge1xuICAgICAgbGV0IGwgPSBScihuLCBvLCAhMSk7XG4gICAgICBpZiAocyhuLnNsaWNlKGwsIG8pKSAhPSBIbi5Xb3JkKVxuICAgICAgICBicmVhaztcbiAgICAgIG8gPSBsO1xuICAgIH1cbiAgICBmb3IgKDsgYSA8IGk7ICkge1xuICAgICAgbGV0IGwgPSBScihuLCBhKTtcbiAgICAgIGlmIChzKG4uc2xpY2UoYSwgbCkpICE9IEhuLldvcmQpXG4gICAgICAgIGJyZWFrO1xuICAgICAgYSA9IGw7XG4gICAgfVxuICAgIHJldHVybiBvID09IGEgPyBudWxsIDogYWUucmFuZ2UobyArIHIsIGEgKyByKTtcbiAgfVxufVxuWWUuYWxsb3dNdWx0aXBsZVNlbGVjdGlvbnMgPSB6aDtcblllLnRhYlNpemUgPSAvKiBAX19QVVJFX18gKi8gdmUuZGVmaW5lKHtcbiAgY29tYmluZTogKHQpID0+IHQubGVuZ3RoID8gdFswXSA6IDRcbn0pO1xuWWUubGluZVNlcGFyYXRvciA9IEJ3O1xuWWUucmVhZE9ubHkgPSBZdztcblllLnBocmFzZXMgPSAvKiBAX19QVVJFX18gKi8gdmUuZGVmaW5lKHtcbiAgY29tcGFyZSh0LCBlKSB7XG4gICAgbGV0IG4gPSBPYmplY3Qua2V5cyh0KSwgciA9IE9iamVjdC5rZXlzKGUpO1xuICAgIHJldHVybiBuLmxlbmd0aCA9PSByLmxlbmd0aCAmJiBuLmV2ZXJ5KChpKSA9PiB0W2ldID09IGVbaV0pO1xuICB9XG59KTtcblllLmxhbmd1YWdlRGF0YSA9IGp3O1xuWWUuY2hhbmdlRmlsdGVyID0gTHc7XG5ZZS50cmFuc2FjdGlvbkZpbHRlciA9IFV3O1xuWWUudHJhbnNhY3Rpb25FeHRlbmRlciA9IHF3O1xuTGQucmVjb25maWd1cmUgPSAvKiBAX19QVVJFX18gKi8gb3QuZGVmaW5lKCk7XG5mdW5jdGlvbiBVZCh0LCBlLCBuID0ge30pIHtcbiAgbGV0IHIgPSB7fTtcbiAgZm9yIChsZXQgaSBvZiB0KVxuICAgIGZvciAobGV0IHMgb2YgT2JqZWN0LmtleXMoaSkpIHtcbiAgICAgIGxldCBvID0gaVtzXSwgYSA9IHJbc107XG4gICAgICBpZiAoYSA9PT0gdm9pZCAwKVxuICAgICAgICByW3NdID0gbztcbiAgICAgIGVsc2UgaWYgKCEoYSA9PT0gbyB8fCBvID09PSB2b2lkIDApKVxuICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobiwgcykpXG4gICAgICAgICAgcltzXSA9IG5bc10oYSwgbyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb25maWcgbWVyZ2UgY29uZmxpY3QgZm9yIGZpZWxkIFwiICsgcyk7XG4gICAgfVxuICBmb3IgKGxldCBpIGluIGUpXG4gICAgcltpXSA9PT0gdm9pZCAwICYmIChyW2ldID0gZVtpXSk7XG4gIHJldHVybiByO1xufVxuY2xhc3MgcXMge1xuICAvKipcbiAgQ29tcGFyZSB0aGlzIHZhbHVlIHdpdGggYW5vdGhlciB2YWx1ZS4gVXNlZCB3aGVuIGNvbXBhcmluZ1xuICByYW5nZXNldHMuIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGNvbXBhcmVzIGJ5IGlkZW50aXR5LlxuICBVbmxlc3MgeW91IGFyZSBvbmx5IGNyZWF0aW5nIGEgZml4ZWQgbnVtYmVyIG9mIHVuaXF1ZSBpbnN0YW5jZXNcbiAgb2YgeW91ciB2YWx1ZSB0eXBlLCBpdCBpcyBhIGdvb2QgaWRlYSB0byBpbXBsZW1lbnQgdGhpc1xuICBwcm9wZXJseS5cbiAgKi9cbiAgZXEoZSkge1xuICAgIHJldHVybiB0aGlzID09IGU7XG4gIH1cbiAgLyoqXG4gIENyZWF0ZSBhIFtyYW5nZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5SYW5nZSkgd2l0aCB0aGlzIHZhbHVlLlxuICAqL1xuICByYW5nZShlLCBuID0gZSkge1xuICAgIHJldHVybiBHaC5jcmVhdGUoZSwgbiwgdGhpcyk7XG4gIH1cbn1cbnFzLnByb3RvdHlwZS5zdGFydFNpZGUgPSBxcy5wcm90b3R5cGUuZW5kU2lkZSA9IDA7XG5xcy5wcm90b3R5cGUucG9pbnQgPSAhMTtcbnFzLnByb3RvdHlwZS5tYXBNb2RlID0gb24uVHJhY2tEZWw7XG5sZXQgR2ggPSBjbGFzcyBGdyB7XG4gIGNvbnN0cnVjdG9yKGUsIG4sIHIpIHtcbiAgICB0aGlzLmZyb20gPSBlLCB0aGlzLnRvID0gbiwgdGhpcy52YWx1ZSA9IHI7XG4gIH1cbiAgLyoqXG4gIEBpbnRlcm5hbFxuICAqL1xuICBzdGF0aWMgY3JlYXRlKGUsIG4sIHIpIHtcbiAgICByZXR1cm4gbmV3IEZ3KGUsIG4sIHIpO1xuICB9XG59O1xuZnVuY3Rpb24gS2godCwgZSkge1xuICByZXR1cm4gdC5mcm9tIC0gZS5mcm9tIHx8IHQudmFsdWUuc3RhcnRTaWRlIC0gZS52YWx1ZS5zdGFydFNpZGU7XG59XG5jbGFzcyByZyB7XG4gIGNvbnN0cnVjdG9yKGUsIG4sIHIsIGkpIHtcbiAgICB0aGlzLmZyb20gPSBlLCB0aGlzLnRvID0gbiwgdGhpcy52YWx1ZSA9IHIsIHRoaXMubWF4UG9pbnQgPSBpO1xuICB9XG4gIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9bdGhpcy50by5sZW5ndGggLSAxXTtcbiAgfVxuICAvLyBGaW5kIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIHNpZGUuIFVzZSB0aGUgcmFuZ2VzJ1xuICAvLyBgZnJvbWAgcG9zIHdoZW4gYGVuZCA9PSBmYWxzZWAsIGB0b2Agd2hlbiBgZW5kID09IHRydWVgLlxuICBmaW5kSW5kZXgoZSwgbiwgciwgaSA9IDApIHtcbiAgICBsZXQgcyA9IHIgPyB0aGlzLnRvIDogdGhpcy5mcm9tO1xuICAgIGZvciAobGV0IG8gPSBpLCBhID0gcy5sZW5ndGg7IDsgKSB7XG4gICAgICBpZiAobyA9PSBhKVxuICAgICAgICByZXR1cm4gbztcbiAgICAgIGxldCBsID0gbyArIGEgPj4gMSwgYyA9IHNbbF0gLSBlIHx8IChyID8gdGhpcy52YWx1ZVtsXS5lbmRTaWRlIDogdGhpcy52YWx1ZVtsXS5zdGFydFNpZGUpIC0gbjtcbiAgICAgIGlmIChsID09IG8pXG4gICAgICAgIHJldHVybiBjID49IDAgPyBvIDogYTtcbiAgICAgIGMgPj0gMCA/IGEgPSBsIDogbyA9IGwgKyAxO1xuICAgIH1cbiAgfVxuICBiZXR3ZWVuKGUsIG4sIHIsIGkpIHtcbiAgICBmb3IgKGxldCBzID0gdGhpcy5maW5kSW5kZXgobiwgLTFlOSwgITApLCBvID0gdGhpcy5maW5kSW5kZXgociwgMWU5LCAhMSwgcyk7IHMgPCBvOyBzKyspXG4gICAgICBpZiAoaSh0aGlzLmZyb21bc10gKyBlLCB0aGlzLnRvW3NdICsgZSwgdGhpcy52YWx1ZVtzXSkgPT09ICExKVxuICAgICAgICByZXR1cm4gITE7XG4gIH1cbiAgbWFwKGUsIG4pIHtcbiAgICBsZXQgciA9IFtdLCBpID0gW10sIHMgPSBbXSwgbyA9IC0xLCBhID0gLTE7XG4gICAgZm9yIChsZXQgbCA9IDA7IGwgPCB0aGlzLnZhbHVlLmxlbmd0aDsgbCsrKSB7XG4gICAgICBsZXQgYyA9IHRoaXMudmFsdWVbbF0sIHUgPSB0aGlzLmZyb21bbF0gKyBlLCBkID0gdGhpcy50b1tsXSArIGUsIGYsIGg7XG4gICAgICBpZiAodSA9PSBkKSB7XG4gICAgICAgIGxldCBwID0gbi5tYXBQb3ModSwgYy5zdGFydFNpZGUsIGMubWFwTW9kZSk7XG4gICAgICAgIGlmIChwID09IG51bGwgfHwgKGYgPSBoID0gcCwgYy5zdGFydFNpZGUgIT0gYy5lbmRTaWRlICYmIChoID0gbi5tYXBQb3ModSwgYy5lbmRTaWRlKSwgaCA8IGYpKSlcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAoZiA9IG4ubWFwUG9zKHUsIGMuc3RhcnRTaWRlKSwgaCA9IG4ubWFwUG9zKGQsIGMuZW5kU2lkZSksIGYgPiBoIHx8IGYgPT0gaCAmJiBjLnN0YXJ0U2lkZSA+IDAgJiYgYy5lbmRTaWRlIDw9IDApXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgKGggLSBmIHx8IGMuZW5kU2lkZSAtIGMuc3RhcnRTaWRlKSA8IDAgfHwgKG8gPCAwICYmIChvID0gZiksIGMucG9pbnQgJiYgKGEgPSBNYXRoLm1heChhLCBoIC0gZikpLCByLnB1c2goYyksIGkucHVzaChmIC0gbyksIHMucHVzaChoIC0gbykpO1xuICAgIH1cbiAgICByZXR1cm4geyBtYXBwZWQ6IHIubGVuZ3RoID8gbmV3IHJnKGksIHMsIHIsIGEpIDogbnVsbCwgcG9zOiBvIH07XG4gIH1cbn1cbmNsYXNzIHplIHtcbiAgY29uc3RydWN0b3IoZSwgbiwgciwgaSkge1xuICAgIHRoaXMuY2h1bmtQb3MgPSBlLCB0aGlzLmNodW5rID0gbiwgdGhpcy5uZXh0TGF5ZXIgPSByLCB0aGlzLm1heFBvaW50ID0gaTtcbiAgfVxuICAvKipcbiAgQGludGVybmFsXG4gICovXG4gIHN0YXRpYyBjcmVhdGUoZSwgbiwgciwgaSkge1xuICAgIHJldHVybiBuZXcgemUoZSwgbiwgciwgaSk7XG4gIH1cbiAgLyoqXG4gIEBpbnRlcm5hbFxuICAqL1xuICBnZXQgbGVuZ3RoKCkge1xuICAgIGxldCBlID0gdGhpcy5jaHVuay5sZW5ndGggLSAxO1xuICAgIHJldHVybiBlIDwgMCA/IDAgOiBNYXRoLm1heCh0aGlzLmNodW5rRW5kKGUpLCB0aGlzLm5leHRMYXllci5sZW5ndGgpO1xuICB9XG4gIC8qKlxuICBUaGUgbnVtYmVyIG9mIHJhbmdlcyBpbiB0aGUgc2V0LlxuICAqL1xuICBnZXQgc2l6ZSgpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KVxuICAgICAgcmV0dXJuIDA7XG4gICAgbGV0IGUgPSB0aGlzLm5leHRMYXllci5zaXplO1xuICAgIGZvciAobGV0IG4gb2YgdGhpcy5jaHVuaylcbiAgICAgIGUgKz0gbi52YWx1ZS5sZW5ndGg7XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgLyoqXG4gIEBpbnRlcm5hbFxuICAqL1xuICBjaHVua0VuZChlKSB7XG4gICAgcmV0dXJuIHRoaXMuY2h1bmtQb3NbZV0gKyB0aGlzLmNodW5rW2VdLmxlbmd0aDtcbiAgfVxuICAvKipcbiAgVXBkYXRlIHRoZSByYW5nZSBzZXQsIG9wdGlvbmFsbHkgYWRkaW5nIG5ldyByYW5nZXMgb3IgZmlsdGVyaW5nXG4gIG91dCBleGlzdGluZyBvbmVzLlxuICBcbiAgKE5vdGU6IFRoZSB0eXBlIHBhcmFtZXRlciBpcyBqdXN0IHRoZXJlIGFzIGEga2x1ZGdlIHRvIHdvcmtcbiAgYXJvdW5kIFR5cGVTY3JpcHQgdmFyaWFuY2UgaXNzdWVzIHRoYXQgcHJldmVudGVkIGBSYW5nZVNldDxYPmBcbiAgZnJvbSBiZWluZyBhIHN1YnR5cGUgb2YgYFJhbmdlU2V0PFk+YCB3aGVuIGBYYCBpcyBhIHN1YnR5cGUgb2ZcbiAgYFlgLilcbiAgKi9cbiAgdXBkYXRlKGUpIHtcbiAgICBsZXQgeyBhZGQ6IG4gPSBbXSwgc29ydDogciA9ICExLCBmaWx0ZXJGcm9tOiBpID0gMCwgZmlsdGVyVG86IHMgPSB0aGlzLmxlbmd0aCB9ID0gZSwgbyA9IGUuZmlsdGVyO1xuICAgIGlmIChuLmxlbmd0aCA9PSAwICYmICFvKVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgaWYgKHIgJiYgKG4gPSBuLnNsaWNlKCkuc29ydChLaCkpLCB0aGlzLmlzRW1wdHkpXG4gICAgICByZXR1cm4gbi5sZW5ndGggPyB6ZS5vZihuKSA6IHRoaXM7XG4gICAgbGV0IGEgPSBuZXcgR3codGhpcywgbnVsbCwgLTEpLmdvdG8oMCksIGwgPSAwLCBjID0gW10sIHUgPSBuZXcgam8oKTtcbiAgICBmb3IgKDsgYS52YWx1ZSB8fCBsIDwgbi5sZW5ndGg7IClcbiAgICAgIGlmIChsIDwgbi5sZW5ndGggJiYgKGEuZnJvbSAtIG5bbF0uZnJvbSB8fCBhLnN0YXJ0U2lkZSAtIG5bbF0udmFsdWUuc3RhcnRTaWRlKSA+PSAwKSB7XG4gICAgICAgIGxldCBkID0gbltsKytdO1xuICAgICAgICB1LmFkZElubmVyKGQuZnJvbSwgZC50bywgZC52YWx1ZSkgfHwgYy5wdXNoKGQpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGEucmFuZ2VJbmRleCA9PSAxICYmIGEuY2h1bmtJbmRleCA8IHRoaXMuY2h1bmsubGVuZ3RoICYmIChsID09IG4ubGVuZ3RoIHx8IHRoaXMuY2h1bmtFbmQoYS5jaHVua0luZGV4KSA8IG5bbF0uZnJvbSkgJiYgKCFvIHx8IGkgPiB0aGlzLmNodW5rRW5kKGEuY2h1bmtJbmRleCkgfHwgcyA8IHRoaXMuY2h1bmtQb3NbYS5jaHVua0luZGV4XSkgJiYgdS5hZGRDaHVuayh0aGlzLmNodW5rUG9zW2EuY2h1bmtJbmRleF0sIHRoaXMuY2h1bmtbYS5jaHVua0luZGV4XSkgPyBhLm5leHRDaHVuaygpIDogKCghbyB8fCBpID4gYS50byB8fCBzIDwgYS5mcm9tIHx8IG8oYS5mcm9tLCBhLnRvLCBhLnZhbHVlKSkgJiYgKHUuYWRkSW5uZXIoYS5mcm9tLCBhLnRvLCBhLnZhbHVlKSB8fCBjLnB1c2goR2guY3JlYXRlKGEuZnJvbSwgYS50bywgYS52YWx1ZSkpKSwgYS5uZXh0KCkpO1xuICAgIHJldHVybiB1LmZpbmlzaElubmVyKHRoaXMubmV4dExheWVyLmlzRW1wdHkgJiYgIWMubGVuZ3RoID8gemUuZW1wdHkgOiB0aGlzLm5leHRMYXllci51cGRhdGUoeyBhZGQ6IGMsIGZpbHRlcjogbywgZmlsdGVyRnJvbTogaSwgZmlsdGVyVG86IHMgfSkpO1xuICB9XG4gIC8qKlxuICBNYXAgdGhpcyByYW5nZSBzZXQgdGhyb3VnaCBhIHNldCBvZiBjaGFuZ2VzLCByZXR1cm4gdGhlIG5ldyBzZXQuXG4gICovXG4gIG1hcChlKSB7XG4gICAgaWYgKGUuZW1wdHkgfHwgdGhpcy5pc0VtcHR5KVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgbGV0IG4gPSBbXSwgciA9IFtdLCBpID0gLTE7XG4gICAgZm9yIChsZXQgbyA9IDA7IG8gPCB0aGlzLmNodW5rLmxlbmd0aDsgbysrKSB7XG4gICAgICBsZXQgYSA9IHRoaXMuY2h1bmtQb3Nbb10sIGwgPSB0aGlzLmNodW5rW29dLCBjID0gZS50b3VjaGVzUmFuZ2UoYSwgYSArIGwubGVuZ3RoKTtcbiAgICAgIGlmIChjID09PSAhMSlcbiAgICAgICAgaSA9IE1hdGgubWF4KGksIGwubWF4UG9pbnQpLCBuLnB1c2gobCksIHIucHVzaChlLm1hcFBvcyhhKSk7XG4gICAgICBlbHNlIGlmIChjID09PSAhMCkge1xuICAgICAgICBsZXQgeyBtYXBwZWQ6IHUsIHBvczogZCB9ID0gbC5tYXAoYSwgZSk7XG4gICAgICAgIHUgJiYgKGkgPSBNYXRoLm1heChpLCB1Lm1heFBvaW50KSwgbi5wdXNoKHUpLCByLnB1c2goZCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgcyA9IHRoaXMubmV4dExheWVyLm1hcChlKTtcbiAgICByZXR1cm4gbi5sZW5ndGggPT0gMCA/IHMgOiBuZXcgemUociwgbiwgcyB8fCB6ZS5lbXB0eSwgaSk7XG4gIH1cbiAgLyoqXG4gIEl0ZXJhdGUgb3ZlciB0aGUgcmFuZ2VzIHRoYXQgdG91Y2ggdGhlIHJlZ2lvbiBgZnJvbWAgdG8gYHRvYCxcbiAgY2FsbGluZyBgZmAgZm9yIGVhY2guIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSByYW5nZXMgd2lsbFxuICBiZSByZXBvcnRlZCBpbiBhbnkgc3BlY2lmaWMgb3JkZXIuIFdoZW4gdGhlIGNhbGxiYWNrIHJldHVybnNcbiAgYGZhbHNlYCwgaXRlcmF0aW9uIHN0b3BzLlxuICAqL1xuICBiZXR3ZWVuKGUsIG4sIHIpIHtcbiAgICBpZiAoIXRoaXMuaXNFbXB0eSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNodW5rLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBzID0gdGhpcy5jaHVua1Bvc1tpXSwgbyA9IHRoaXMuY2h1bmtbaV07XG4gICAgICAgIGlmIChuID49IHMgJiYgZSA8PSBzICsgby5sZW5ndGggJiYgby5iZXR3ZWVuKHMsIGUgLSBzLCBuIC0gcywgcikgPT09ICExKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMubmV4dExheWVyLmJldHdlZW4oZSwgbiwgcik7XG4gICAgfVxuICB9XG4gIC8qKlxuICBJdGVyYXRlIG92ZXIgdGhlIHJhbmdlcyBpbiB0aGlzIHNldCwgaW4gb3JkZXIsIGluY2x1ZGluZyBhbGxcbiAgcmFuZ2VzIHRoYXQgZW5kIGF0IG9yIGFmdGVyIGBmcm9tYC5cbiAgKi9cbiAgaXRlcihlID0gMCkge1xuICAgIHJldHVybiBobC5mcm9tKFt0aGlzXSkuZ290byhlKTtcbiAgfVxuICAvKipcbiAgQGludGVybmFsXG4gICovXG4gIGdldCBpc0VtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLm5leHRMYXllciA9PSB0aGlzO1xuICB9XG4gIC8qKlxuICBJdGVyYXRlIG92ZXIgdGhlIHJhbmdlcyBpbiBhIGNvbGxlY3Rpb24gb2Ygc2V0cywgaW4gb3JkZXIsXG4gIHN0YXJ0aW5nIGZyb20gYGZyb21gLlxuICAqL1xuICBzdGF0aWMgaXRlcihlLCBuID0gMCkge1xuICAgIHJldHVybiBobC5mcm9tKGUpLmdvdG8obik7XG4gIH1cbiAgLyoqXG4gIEl0ZXJhdGUgb3ZlciB0d28gZ3JvdXBzIG9mIHNldHMsIGNhbGxpbmcgbWV0aG9kcyBvbiBgY29tcGFyYXRvcmBcbiAgdG8gbm90aWZ5IGl0IG9mIHBvc3NpYmxlIGRpZmZlcmVuY2VzLlxuICAqL1xuICBzdGF0aWMgY29tcGFyZShlLCBuLCByLCBpLCBzID0gLTEpIHtcbiAgICBsZXQgbyA9IGUuZmlsdGVyKChkKSA9PiBkLm1heFBvaW50ID4gMCB8fCAhZC5pc0VtcHR5ICYmIGQubWF4UG9pbnQgPj0gcyksIGEgPSBuLmZpbHRlcigoZCkgPT4gZC5tYXhQb2ludCA+IDAgfHwgIWQuaXNFbXB0eSAmJiBkLm1heFBvaW50ID49IHMpLCBsID0gSWIobywgYSwgciksIGMgPSBuZXcgdmEobywgbCwgcyksIHUgPSBuZXcgdmEoYSwgbCwgcyk7XG4gICAgci5pdGVyR2FwcygoZCwgZiwgaCkgPT4gV2IoYywgZCwgdSwgZiwgaCwgaSkpLCByLmVtcHR5ICYmIHIubGVuZ3RoID09IDAgJiYgV2IoYywgMCwgdSwgMCwgMCwgaSk7XG4gIH1cbiAgLyoqXG4gIENvbXBhcmUgdGhlIGNvbnRlbnRzIG9mIHR3byBncm91cHMgb2YgcmFuZ2Ugc2V0cywgcmV0dXJuaW5nIHRydWVcbiAgaWYgdGhleSBhcmUgZXF1aXZhbGVudCBpbiB0aGUgZ2l2ZW4gcmFuZ2UuXG4gICovXG4gIHN0YXRpYyBlcShlLCBuLCByID0gMCwgaSkge1xuICAgIGkgPT0gbnVsbCAmJiAoaSA9IDk5OTk5OTk5OSk7XG4gICAgbGV0IHMgPSBlLmZpbHRlcigodSkgPT4gIXUuaXNFbXB0eSAmJiBuLmluZGV4T2YodSkgPCAwKSwgbyA9IG4uZmlsdGVyKCh1KSA9PiAhdS5pc0VtcHR5ICYmIGUuaW5kZXhPZih1KSA8IDApO1xuICAgIGlmIChzLmxlbmd0aCAhPSBvLmxlbmd0aClcbiAgICAgIHJldHVybiAhMTtcbiAgICBpZiAoIXMubGVuZ3RoKVxuICAgICAgcmV0dXJuICEwO1xuICAgIGxldCBhID0gSWIocywgbyksIGwgPSBuZXcgdmEocywgYSwgMCkuZ290byhyKSwgYyA9IG5ldyB2YShvLCBhLCAwKS5nb3RvKHIpO1xuICAgIGZvciAoOyA7ICkge1xuICAgICAgaWYgKGwudG8gIT0gYy50byB8fCAhSmgobC5hY3RpdmUsIGMuYWN0aXZlKSB8fCBsLnBvaW50ICYmICghYy5wb2ludCB8fCAhbC5wb2ludC5lcShjLnBvaW50KSkpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGlmIChsLnRvID4gaSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgbC5uZXh0KCksIGMubmV4dCgpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgSXRlcmF0ZSBvdmVyIGEgZ3JvdXAgb2YgcmFuZ2Ugc2V0cyBhdCB0aGUgc2FtZSB0aW1lLCBub3RpZnlpbmdcbiAgdGhlIGl0ZXJhdG9yIGFib3V0IHRoZSByYW5nZXMgY292ZXJpbmcgZXZlcnkgZ2l2ZW4gcGllY2Ugb2ZcbiAgY29udGVudC4gUmV0dXJucyB0aGUgb3BlbiBjb3VudCAoc2VlXG4gIFtgU3Bhbkl0ZXJhdG9yLnNwYW5gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlNwYW5JdGVyYXRvci5zcGFuKSkgYXQgdGhlIGVuZFxuICBvZiB0aGUgaXRlcmF0aW9uLlxuICAqL1xuICBzdGF0aWMgc3BhbnMoZSwgbiwgciwgaSwgcyA9IC0xKSB7XG4gICAgbGV0IG8gPSBuZXcgdmEoZSwgbnVsbCwgcykuZ290byhuKSwgYSA9IG4sIGwgPSBvLm9wZW5TdGFydDtcbiAgICBmb3IgKDsgOyApIHtcbiAgICAgIGxldCBjID0gTWF0aC5taW4oby50bywgcik7XG4gICAgICBpZiAoby5wb2ludCkge1xuICAgICAgICBsZXQgdSA9IG8uYWN0aXZlRm9yUG9pbnQoby50byksIGQgPSBvLnBvaW50RnJvbSA8IG4gPyB1Lmxlbmd0aCArIDEgOiBvLnBvaW50LnN0YXJ0U2lkZSA8IDAgPyB1Lmxlbmd0aCA6IE1hdGgubWluKHUubGVuZ3RoLCBsKTtcbiAgICAgICAgaS5wb2ludChhLCBjLCBvLnBvaW50LCB1LCBkLCBvLnBvaW50UmFuayksIGwgPSBNYXRoLm1pbihvLm9wZW5FbmQoYyksIHUubGVuZ3RoKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBjID4gYSAmJiAoaS5zcGFuKGEsIGMsIG8uYWN0aXZlLCBsKSwgbCA9IG8ub3BlbkVuZChjKSk7XG4gICAgICBpZiAoby50byA+IHIpXG4gICAgICAgIHJldHVybiBsICsgKG8ucG9pbnQgJiYgby50byA+IHIgPyAxIDogMCk7XG4gICAgICBhID0gby50bywgby5uZXh0KCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICBDcmVhdGUgYSByYW5nZSBzZXQgZm9yIHRoZSBnaXZlbiByYW5nZSBvciBhcnJheSBvZiByYW5nZXMuIEJ5XG4gIGRlZmF1bHQsIHRoaXMgZXhwZWN0cyB0aGUgcmFuZ2VzIHRvIGJlIF9zb3J0ZWRfIChieSBzdGFydFxuICBwb3NpdGlvbiBhbmQsIGlmIHR3byBzdGFydCBhdCB0aGUgc2FtZSBwb3NpdGlvbixcbiAgYHZhbHVlLnN0YXJ0U2lkZWApLiBZb3UgY2FuIHBhc3MgYHRydWVgIGFzIHNlY29uZCBhcmd1bWVudCB0b1xuICBjYXVzZSB0aGUgbWV0aG9kIHRvIHNvcnQgdGhlbS5cbiAgKi9cbiAgc3RhdGljIG9mKGUsIG4gPSAhMSkge1xuICAgIGxldCByID0gbmV3IGpvKCk7XG4gICAgZm9yIChsZXQgaSBvZiBlIGluc3RhbmNlb2YgR2ggPyBbZV0gOiBuID8gZk4oZSkgOiBlKVxuICAgICAgci5hZGQoaS5mcm9tLCBpLnRvLCBpLnZhbHVlKTtcbiAgICByZXR1cm4gci5maW5pc2goKTtcbiAgfVxuICAvKipcbiAgSm9pbiBhbiBhcnJheSBvZiByYW5nZSBzZXRzIGludG8gYSBzaW5nbGUgc2V0LlxuICAqL1xuICBzdGF0aWMgam9pbihlKSB7XG4gICAgaWYgKCFlLmxlbmd0aClcbiAgICAgIHJldHVybiB6ZS5lbXB0eTtcbiAgICBsZXQgbiA9IGVbZS5sZW5ndGggLSAxXTtcbiAgICBmb3IgKGxldCByID0gZS5sZW5ndGggLSAyOyByID49IDA7IHItLSlcbiAgICAgIGZvciAobGV0IGkgPSBlW3JdOyBpICE9IHplLmVtcHR5OyBpID0gaS5uZXh0TGF5ZXIpXG4gICAgICAgIG4gPSBuZXcgemUoaS5jaHVua1BvcywgaS5jaHVuaywgbiwgTWF0aC5tYXgoaS5tYXhQb2ludCwgbi5tYXhQb2ludCkpO1xuICAgIHJldHVybiBuO1xuICB9XG59XG56ZS5lbXB0eSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgemUoW10sIFtdLCBudWxsLCAtMSk7XG5mdW5jdGlvbiBmTih0KSB7XG4gIGlmICh0Lmxlbmd0aCA+IDEpXG4gICAgZm9yIChsZXQgZSA9IHRbMF0sIG4gPSAxOyBuIDwgdC5sZW5ndGg7IG4rKykge1xuICAgICAgbGV0IHIgPSB0W25dO1xuICAgICAgaWYgKEtoKGUsIHIpID4gMClcbiAgICAgICAgcmV0dXJuIHQuc2xpY2UoKS5zb3J0KEtoKTtcbiAgICAgIGUgPSByO1xuICAgIH1cbiAgcmV0dXJuIHQ7XG59XG56ZS5lbXB0eS5uZXh0TGF5ZXIgPSB6ZS5lbXB0eTtcbmNsYXNzIGpvIHtcbiAgZmluaXNoQ2h1bmsoZSkge1xuICAgIHRoaXMuY2h1bmtzLnB1c2gobmV3IHJnKHRoaXMuZnJvbSwgdGhpcy50bywgdGhpcy52YWx1ZSwgdGhpcy5tYXhQb2ludCkpLCB0aGlzLmNodW5rUG9zLnB1c2godGhpcy5jaHVua1N0YXJ0KSwgdGhpcy5jaHVua1N0YXJ0ID0gLTEsIHRoaXMuc2V0TWF4UG9pbnQgPSBNYXRoLm1heCh0aGlzLnNldE1heFBvaW50LCB0aGlzLm1heFBvaW50KSwgdGhpcy5tYXhQb2ludCA9IC0xLCBlICYmICh0aGlzLmZyb20gPSBbXSwgdGhpcy50byA9IFtdLCB0aGlzLnZhbHVlID0gW10pO1xuICB9XG4gIC8qKlxuICBDcmVhdGUgYW4gZW1wdHkgYnVpbGRlci5cbiAgKi9cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5jaHVua3MgPSBbXSwgdGhpcy5jaHVua1BvcyA9IFtdLCB0aGlzLmNodW5rU3RhcnQgPSAtMSwgdGhpcy5sYXN0ID0gbnVsbCwgdGhpcy5sYXN0RnJvbSA9IC0xZTksIHRoaXMubGFzdFRvID0gLTFlOSwgdGhpcy5mcm9tID0gW10sIHRoaXMudG8gPSBbXSwgdGhpcy52YWx1ZSA9IFtdLCB0aGlzLm1heFBvaW50ID0gLTEsIHRoaXMuc2V0TWF4UG9pbnQgPSAtMSwgdGhpcy5uZXh0TGF5ZXIgPSBudWxsO1xuICB9XG4gIC8qKlxuICBBZGQgYSByYW5nZS4gUmFuZ2VzIHNob3VsZCBiZSBhZGRlZCBpbiBzb3J0ZWQgKGJ5IGBmcm9tYCBhbmRcbiAgYHZhbHVlLnN0YXJ0U2lkZWApIG9yZGVyLlxuICAqL1xuICBhZGQoZSwgbiwgcikge1xuICAgIHRoaXMuYWRkSW5uZXIoZSwgbiwgcikgfHwgKHRoaXMubmV4dExheWVyIHx8ICh0aGlzLm5leHRMYXllciA9IG5ldyBqbygpKSkuYWRkKGUsIG4sIHIpO1xuICB9XG4gIC8qKlxuICBAaW50ZXJuYWxcbiAgKi9cbiAgYWRkSW5uZXIoZSwgbiwgcikge1xuICAgIGxldCBpID0gZSAtIHRoaXMubGFzdFRvIHx8IHIuc3RhcnRTaWRlIC0gdGhpcy5sYXN0LmVuZFNpZGU7XG4gICAgaWYgKGkgPD0gMCAmJiAoZSAtIHRoaXMubGFzdEZyb20gfHwgci5zdGFydFNpZGUgLSB0aGlzLmxhc3Quc3RhcnRTaWRlKSA8IDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSYW5nZXMgbXVzdCBiZSBhZGRlZCBzb3J0ZWQgYnkgYGZyb21gIHBvc2l0aW9uIGFuZCBgc3RhcnRTaWRlYFwiKTtcbiAgICByZXR1cm4gaSA8IDAgPyAhMSA6ICh0aGlzLmZyb20ubGVuZ3RoID09IDI1MCAmJiB0aGlzLmZpbmlzaENodW5rKCEwKSwgdGhpcy5jaHVua1N0YXJ0IDwgMCAmJiAodGhpcy5jaHVua1N0YXJ0ID0gZSksIHRoaXMuZnJvbS5wdXNoKGUgLSB0aGlzLmNodW5rU3RhcnQpLCB0aGlzLnRvLnB1c2gobiAtIHRoaXMuY2h1bmtTdGFydCksIHRoaXMubGFzdCA9IHIsIHRoaXMubGFzdEZyb20gPSBlLCB0aGlzLmxhc3RUbyA9IG4sIHRoaXMudmFsdWUucHVzaChyKSwgci5wb2ludCAmJiAodGhpcy5tYXhQb2ludCA9IE1hdGgubWF4KHRoaXMubWF4UG9pbnQsIG4gLSBlKSksICEwKTtcbiAgfVxuICAvKipcbiAgQGludGVybmFsXG4gICovXG4gIGFkZENodW5rKGUsIG4pIHtcbiAgICBpZiAoKGUgLSB0aGlzLmxhc3RUbyB8fCBuLnZhbHVlWzBdLnN0YXJ0U2lkZSAtIHRoaXMubGFzdC5lbmRTaWRlKSA8IDApXG4gICAgICByZXR1cm4gITE7XG4gICAgdGhpcy5mcm9tLmxlbmd0aCAmJiB0aGlzLmZpbmlzaENodW5rKCEwKSwgdGhpcy5zZXRNYXhQb2ludCA9IE1hdGgubWF4KHRoaXMuc2V0TWF4UG9pbnQsIG4ubWF4UG9pbnQpLCB0aGlzLmNodW5rcy5wdXNoKG4pLCB0aGlzLmNodW5rUG9zLnB1c2goZSk7XG4gICAgbGV0IHIgPSBuLnZhbHVlLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuIHRoaXMubGFzdCA9IG4udmFsdWVbcl0sIHRoaXMubGFzdEZyb20gPSBuLmZyb21bcl0gKyBlLCB0aGlzLmxhc3RUbyA9IG4udG9bcl0gKyBlLCAhMDtcbiAgfVxuICAvKipcbiAgRmluaXNoIHRoZSByYW5nZSBzZXQuIFJldHVybnMgdGhlIG5ldyBzZXQuIFRoZSBidWlsZGVyIGNhbid0IGJlXG4gIHVzZWQgYW55bW9yZSBhZnRlciB0aGlzIGhhcyBiZWVuIGNhbGxlZC5cbiAgKi9cbiAgZmluaXNoKCkge1xuICAgIHJldHVybiB0aGlzLmZpbmlzaElubmVyKHplLmVtcHR5KTtcbiAgfVxuICAvKipcbiAgQGludGVybmFsXG4gICovXG4gIGZpbmlzaElubmVyKGUpIHtcbiAgICBpZiAodGhpcy5mcm9tLmxlbmd0aCAmJiB0aGlzLmZpbmlzaENodW5rKCExKSwgdGhpcy5jaHVua3MubGVuZ3RoID09IDApXG4gICAgICByZXR1cm4gZTtcbiAgICBsZXQgbiA9IHplLmNyZWF0ZSh0aGlzLmNodW5rUG9zLCB0aGlzLmNodW5rcywgdGhpcy5uZXh0TGF5ZXIgPyB0aGlzLm5leHRMYXllci5maW5pc2hJbm5lcihlKSA6IGUsIHRoaXMuc2V0TWF4UG9pbnQpO1xuICAgIHJldHVybiB0aGlzLmZyb20gPSBudWxsLCBuO1xuICB9XG59XG5mdW5jdGlvbiBJYih0LCBlLCBuKSB7XG4gIGxldCByID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgZm9yIChsZXQgcyBvZiB0KVxuICAgIGZvciAobGV0IG8gPSAwOyBvIDwgcy5jaHVuay5sZW5ndGg7IG8rKylcbiAgICAgIHMuY2h1bmtbb10ubWF4UG9pbnQgPD0gMCAmJiByLnNldChzLmNodW5rW29dLCBzLmNodW5rUG9zW29dKTtcbiAgbGV0IGkgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBmb3IgKGxldCBzIG9mIGUpXG4gICAgZm9yIChsZXQgbyA9IDA7IG8gPCBzLmNodW5rLmxlbmd0aDsgbysrKSB7XG4gICAgICBsZXQgYSA9IHIuZ2V0KHMuY2h1bmtbb10pO1xuICAgICAgYSAhPSBudWxsICYmIChuID8gbi5tYXBQb3MoYSkgOiBhKSA9PSBzLmNodW5rUG9zW29dICYmICEobiAhPSBudWxsICYmIG4udG91Y2hlc1JhbmdlKGEsIGEgKyBzLmNodW5rW29dLmxlbmd0aCkpICYmIGkuYWRkKHMuY2h1bmtbb10pO1xuICAgIH1cbiAgcmV0dXJuIGk7XG59XG5jbGFzcyBHdyB7XG4gIGNvbnN0cnVjdG9yKGUsIG4sIHIsIGkgPSAwKSB7XG4gICAgdGhpcy5sYXllciA9IGUsIHRoaXMuc2tpcCA9IG4sIHRoaXMubWluUG9pbnQgPSByLCB0aGlzLnJhbmsgPSBpO1xuICB9XG4gIGdldCBzdGFydFNpZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUgPyB0aGlzLnZhbHVlLnN0YXJ0U2lkZSA6IDA7XG4gIH1cbiAgZ2V0IGVuZFNpZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUgPyB0aGlzLnZhbHVlLmVuZFNpZGUgOiAwO1xuICB9XG4gIGdvdG8oZSwgbiA9IC0xZTkpIHtcbiAgICByZXR1cm4gdGhpcy5jaHVua0luZGV4ID0gdGhpcy5yYW5nZUluZGV4ID0gMCwgdGhpcy5nb3RvSW5uZXIoZSwgbiwgITEpLCB0aGlzO1xuICB9XG4gIGdvdG9Jbm5lcihlLCBuLCByKSB7XG4gICAgZm9yICg7IHRoaXMuY2h1bmtJbmRleCA8IHRoaXMubGF5ZXIuY2h1bmsubGVuZ3RoOyApIHtcbiAgICAgIGxldCBpID0gdGhpcy5sYXllci5jaHVua1t0aGlzLmNodW5rSW5kZXhdO1xuICAgICAgaWYgKCEodGhpcy5za2lwICYmIHRoaXMuc2tpcC5oYXMoaSkgfHwgdGhpcy5sYXllci5jaHVua0VuZCh0aGlzLmNodW5rSW5kZXgpIDwgZSB8fCBpLm1heFBvaW50IDwgdGhpcy5taW5Qb2ludCkpXG4gICAgICAgIGJyZWFrO1xuICAgICAgdGhpcy5jaHVua0luZGV4KyssIHIgPSAhMTtcbiAgICB9XG4gICAgaWYgKHRoaXMuY2h1bmtJbmRleCA8IHRoaXMubGF5ZXIuY2h1bmsubGVuZ3RoKSB7XG4gICAgICBsZXQgaSA9IHRoaXMubGF5ZXIuY2h1bmtbdGhpcy5jaHVua0luZGV4XS5maW5kSW5kZXgoZSAtIHRoaXMubGF5ZXIuY2h1bmtQb3NbdGhpcy5jaHVua0luZGV4XSwgbiwgITApO1xuICAgICAgKCFyIHx8IHRoaXMucmFuZ2VJbmRleCA8IGkpICYmIHRoaXMuc2V0UmFuZ2VJbmRleChpKTtcbiAgICB9XG4gICAgdGhpcy5uZXh0KCk7XG4gIH1cbiAgZm9yd2FyZChlLCBuKSB7XG4gICAgKHRoaXMudG8gLSBlIHx8IHRoaXMuZW5kU2lkZSAtIG4pIDwgMCAmJiB0aGlzLmdvdG9Jbm5lcihlLCBuLCAhMCk7XG4gIH1cbiAgbmV4dCgpIHtcbiAgICBmb3IgKDsgOyApXG4gICAgICBpZiAodGhpcy5jaHVua0luZGV4ID09IHRoaXMubGF5ZXIuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IHRoaXMudG8gPSAxZTksIHRoaXMudmFsdWUgPSBudWxsO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBlID0gdGhpcy5sYXllci5jaHVua1Bvc1t0aGlzLmNodW5rSW5kZXhdLCBuID0gdGhpcy5sYXllci5jaHVua1t0aGlzLmNodW5rSW5kZXhdLCByID0gZSArIG4uZnJvbVt0aGlzLnJhbmdlSW5kZXhdO1xuICAgICAgICBpZiAodGhpcy5mcm9tID0gciwgdGhpcy50byA9IGUgKyBuLnRvW3RoaXMucmFuZ2VJbmRleF0sIHRoaXMudmFsdWUgPSBuLnZhbHVlW3RoaXMucmFuZ2VJbmRleF0sIHRoaXMuc2V0UmFuZ2VJbmRleCh0aGlzLnJhbmdlSW5kZXggKyAxKSwgdGhpcy5taW5Qb2ludCA8IDAgfHwgdGhpcy52YWx1ZS5wb2ludCAmJiB0aGlzLnRvIC0gdGhpcy5mcm9tID49IHRoaXMubWluUG9pbnQpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbiAgc2V0UmFuZ2VJbmRleChlKSB7XG4gICAgaWYgKGUgPT0gdGhpcy5sYXllci5jaHVua1t0aGlzLmNodW5rSW5kZXhdLnZhbHVlLmxlbmd0aCkge1xuICAgICAgaWYgKHRoaXMuY2h1bmtJbmRleCsrLCB0aGlzLnNraXApXG4gICAgICAgIGZvciAoOyB0aGlzLmNodW5rSW5kZXggPCB0aGlzLmxheWVyLmNodW5rLmxlbmd0aCAmJiB0aGlzLnNraXAuaGFzKHRoaXMubGF5ZXIuY2h1bmtbdGhpcy5jaHVua0luZGV4XSk7IClcbiAgICAgICAgICB0aGlzLmNodW5rSW5kZXgrKztcbiAgICAgIHRoaXMucmFuZ2VJbmRleCA9IDA7XG4gICAgfSBlbHNlXG4gICAgICB0aGlzLnJhbmdlSW5kZXggPSBlO1xuICB9XG4gIG5leHRDaHVuaygpIHtcbiAgICB0aGlzLmNodW5rSW5kZXgrKywgdGhpcy5yYW5nZUluZGV4ID0gMCwgdGhpcy5uZXh0KCk7XG4gIH1cbiAgY29tcGFyZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuZnJvbSAtIGUuZnJvbSB8fCB0aGlzLnN0YXJ0U2lkZSAtIGUuc3RhcnRTaWRlIHx8IHRoaXMucmFuayAtIGUucmFuayB8fCB0aGlzLnRvIC0gZS50byB8fCB0aGlzLmVuZFNpZGUgLSBlLmVuZFNpZGU7XG4gIH1cbn1cbmNsYXNzIGhsIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMuaGVhcCA9IGU7XG4gIH1cbiAgc3RhdGljIGZyb20oZSwgbiA9IG51bGwsIHIgPSAtMSkge1xuICAgIGxldCBpID0gW107XG4gICAgZm9yIChsZXQgcyA9IDA7IHMgPCBlLmxlbmd0aDsgcysrKVxuICAgICAgZm9yIChsZXQgbyA9IGVbc107ICFvLmlzRW1wdHk7IG8gPSBvLm5leHRMYXllcilcbiAgICAgICAgby5tYXhQb2ludCA+PSByICYmIGkucHVzaChuZXcgR3cobywgbiwgciwgcykpO1xuICAgIHJldHVybiBpLmxlbmd0aCA9PSAxID8gaVswXSA6IG5ldyBobChpKTtcbiAgfVxuICBnZXQgc3RhcnRTaWRlKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlID8gdGhpcy52YWx1ZS5zdGFydFNpZGUgOiAwO1xuICB9XG4gIGdvdG8oZSwgbiA9IC0xZTkpIHtcbiAgICBmb3IgKGxldCByIG9mIHRoaXMuaGVhcClcbiAgICAgIHIuZ290byhlLCBuKTtcbiAgICBmb3IgKGxldCByID0gdGhpcy5oZWFwLmxlbmd0aCA+PiAxOyByID49IDA7IHItLSlcbiAgICAgIHdmKHRoaXMuaGVhcCwgcik7XG4gICAgcmV0dXJuIHRoaXMubmV4dCgpLCB0aGlzO1xuICB9XG4gIGZvcndhcmQoZSwgbikge1xuICAgIGZvciAobGV0IHIgb2YgdGhpcy5oZWFwKVxuICAgICAgci5mb3J3YXJkKGUsIG4pO1xuICAgIGZvciAobGV0IHIgPSB0aGlzLmhlYXAubGVuZ3RoID4+IDE7IHIgPj0gMDsgci0tKVxuICAgICAgd2YodGhpcy5oZWFwLCByKTtcbiAgICAodGhpcy50byAtIGUgfHwgdGhpcy52YWx1ZS5lbmRTaWRlIC0gbikgPCAwICYmIHRoaXMubmV4dCgpO1xuICB9XG4gIG5leHQoKSB7XG4gICAgaWYgKHRoaXMuaGVhcC5sZW5ndGggPT0gMClcbiAgICAgIHRoaXMuZnJvbSA9IHRoaXMudG8gPSAxZTksIHRoaXMudmFsdWUgPSBudWxsLCB0aGlzLnJhbmsgPSAtMTtcbiAgICBlbHNlIHtcbiAgICAgIGxldCBlID0gdGhpcy5oZWFwWzBdO1xuICAgICAgdGhpcy5mcm9tID0gZS5mcm9tLCB0aGlzLnRvID0gZS50bywgdGhpcy52YWx1ZSA9IGUudmFsdWUsIHRoaXMucmFuayA9IGUucmFuaywgZS52YWx1ZSAmJiBlLm5leHQoKSwgd2YodGhpcy5oZWFwLCAwKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHdmKHQsIGUpIHtcbiAgZm9yIChsZXQgbiA9IHRbZV07IDsgKSB7XG4gICAgbGV0IHIgPSAoZSA8PCAxKSArIDE7XG4gICAgaWYgKHIgPj0gdC5sZW5ndGgpXG4gICAgICBicmVhaztcbiAgICBsZXQgaSA9IHRbcl07XG4gICAgaWYgKHIgKyAxIDwgdC5sZW5ndGggJiYgaS5jb21wYXJlKHRbciArIDFdKSA+PSAwICYmIChpID0gdFtyICsgMV0sIHIrKyksIG4uY29tcGFyZShpKSA8IDApXG4gICAgICBicmVhaztcbiAgICB0W3JdID0gbiwgdFtlXSA9IGksIGUgPSByO1xuICB9XG59XG5jbGFzcyB2YSB7XG4gIGNvbnN0cnVjdG9yKGUsIG4sIHIpIHtcbiAgICB0aGlzLm1pblBvaW50ID0gciwgdGhpcy5hY3RpdmUgPSBbXSwgdGhpcy5hY3RpdmVUbyA9IFtdLCB0aGlzLmFjdGl2ZVJhbmsgPSBbXSwgdGhpcy5taW5BY3RpdmUgPSAtMSwgdGhpcy5wb2ludCA9IG51bGwsIHRoaXMucG9pbnRGcm9tID0gMCwgdGhpcy5wb2ludFJhbmsgPSAwLCB0aGlzLnRvID0gLTFlOSwgdGhpcy5lbmRTaWRlID0gMCwgdGhpcy5vcGVuU3RhcnQgPSAtMSwgdGhpcy5jdXJzb3IgPSBobC5mcm9tKGUsIG4sIHIpO1xuICB9XG4gIGdvdG8oZSwgbiA9IC0xZTkpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJzb3IuZ290byhlLCBuKSwgdGhpcy5hY3RpdmUubGVuZ3RoID0gdGhpcy5hY3RpdmVUby5sZW5ndGggPSB0aGlzLmFjdGl2ZVJhbmsubGVuZ3RoID0gMCwgdGhpcy5taW5BY3RpdmUgPSAtMSwgdGhpcy50byA9IGUsIHRoaXMuZW5kU2lkZSA9IG4sIHRoaXMub3BlblN0YXJ0ID0gLTEsIHRoaXMubmV4dCgpLCB0aGlzO1xuICB9XG4gIGZvcndhcmQoZSwgbikge1xuICAgIGZvciAoOyB0aGlzLm1pbkFjdGl2ZSA+IC0xICYmICh0aGlzLmFjdGl2ZVRvW3RoaXMubWluQWN0aXZlXSAtIGUgfHwgdGhpcy5hY3RpdmVbdGhpcy5taW5BY3RpdmVdLmVuZFNpZGUgLSBuKSA8IDA7IClcbiAgICAgIHRoaXMucmVtb3ZlQWN0aXZlKHRoaXMubWluQWN0aXZlKTtcbiAgICB0aGlzLmN1cnNvci5mb3J3YXJkKGUsIG4pO1xuICB9XG4gIHJlbW92ZUFjdGl2ZShlKSB7XG4gICAga2ModGhpcy5hY3RpdmUsIGUpLCBrYyh0aGlzLmFjdGl2ZVRvLCBlKSwga2ModGhpcy5hY3RpdmVSYW5rLCBlKSwgdGhpcy5taW5BY3RpdmUgPSBNYih0aGlzLmFjdGl2ZSwgdGhpcy5hY3RpdmVUbyk7XG4gIH1cbiAgYWRkQWN0aXZlKGUpIHtcbiAgICBsZXQgbiA9IDAsIHsgdmFsdWU6IHIsIHRvOiBpLCByYW5rOiBzIH0gPSB0aGlzLmN1cnNvcjtcbiAgICBmb3IgKDsgbiA8IHRoaXMuYWN0aXZlUmFuay5sZW5ndGggJiYgKHMgLSB0aGlzLmFjdGl2ZVJhbmtbbl0gfHwgaSAtIHRoaXMuYWN0aXZlVG9bbl0pID4gMDsgKVxuICAgICAgbisrO1xuICAgIHhjKHRoaXMuYWN0aXZlLCBuLCByKSwgeGModGhpcy5hY3RpdmVUbywgbiwgaSksIHhjKHRoaXMuYWN0aXZlUmFuaywgbiwgcyksIGUgJiYgeGMoZSwgbiwgdGhpcy5jdXJzb3IuZnJvbSksIHRoaXMubWluQWN0aXZlID0gTWIodGhpcy5hY3RpdmUsIHRoaXMuYWN0aXZlVG8pO1xuICB9XG4gIC8vIEFmdGVyIGNhbGxpbmcgdGhpcywgaWYgYHRoaXMucG9pbnRgICE9IG51bGwsIHRoZSBuZXh0IHJhbmdlIGlzIGFcbiAgLy8gcG9pbnQuIE90aGVyd2lzZSwgaXQncyBhIHJlZ3VsYXIgcmFuZ2UsIGNvdmVyZWQgYnkgYHRoaXMuYWN0aXZlYC5cbiAgbmV4dCgpIHtcbiAgICBsZXQgZSA9IHRoaXMudG8sIG4gPSB0aGlzLnBvaW50O1xuICAgIHRoaXMucG9pbnQgPSBudWxsO1xuICAgIGxldCByID0gdGhpcy5vcGVuU3RhcnQgPCAwID8gW10gOiBudWxsO1xuICAgIGZvciAoOyA7ICkge1xuICAgICAgbGV0IGkgPSB0aGlzLm1pbkFjdGl2ZTtcbiAgICAgIGlmIChpID4gLTEgJiYgKHRoaXMuYWN0aXZlVG9baV0gLSB0aGlzLmN1cnNvci5mcm9tIHx8IHRoaXMuYWN0aXZlW2ldLmVuZFNpZGUgLSB0aGlzLmN1cnNvci5zdGFydFNpZGUpIDwgMCkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmVUb1tpXSA+IGUpIHtcbiAgICAgICAgICB0aGlzLnRvID0gdGhpcy5hY3RpdmVUb1tpXSwgdGhpcy5lbmRTaWRlID0gdGhpcy5hY3RpdmVbaV0uZW5kU2lkZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFjdGl2ZShpKSwgciAmJiBrYyhyLCBpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5jdXJzb3IudmFsdWUpXG4gICAgICAgIGlmICh0aGlzLmN1cnNvci5mcm9tID4gZSkge1xuICAgICAgICAgIHRoaXMudG8gPSB0aGlzLmN1cnNvci5mcm9tLCB0aGlzLmVuZFNpZGUgPSB0aGlzLmN1cnNvci5zdGFydFNpZGU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGV0IHMgPSB0aGlzLmN1cnNvci52YWx1ZTtcbiAgICAgICAgICBpZiAoIXMucG9pbnQpXG4gICAgICAgICAgICB0aGlzLmFkZEFjdGl2ZShyKSwgdGhpcy5jdXJzb3IubmV4dCgpO1xuICAgICAgICAgIGVsc2UgaWYgKG4gJiYgdGhpcy5jdXJzb3IudG8gPT0gdGhpcy50byAmJiB0aGlzLmN1cnNvci5mcm9tIDwgdGhpcy5jdXJzb3IudG8pXG4gICAgICAgICAgICB0aGlzLmN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBvaW50ID0gcywgdGhpcy5wb2ludEZyb20gPSB0aGlzLmN1cnNvci5mcm9tLCB0aGlzLnBvaW50UmFuayA9IHRoaXMuY3Vyc29yLnJhbmssIHRoaXMudG8gPSB0aGlzLmN1cnNvci50bywgdGhpcy5lbmRTaWRlID0gcy5lbmRTaWRlLCB0aGlzLmN1cnNvci5uZXh0KCksIHRoaXMuZm9yd2FyZCh0aGlzLnRvLCB0aGlzLmVuZFNpZGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy50byA9IHRoaXMuZW5kU2lkZSA9IDFlOTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChyKSB7XG4gICAgICB0aGlzLm9wZW5TdGFydCA9IDA7XG4gICAgICBmb3IgKGxldCBpID0gci5sZW5ndGggLSAxOyBpID49IDAgJiYgcltpXSA8IGU7IGktLSlcbiAgICAgICAgdGhpcy5vcGVuU3RhcnQrKztcbiAgICB9XG4gIH1cbiAgYWN0aXZlRm9yUG9pbnQoZSkge1xuICAgIGlmICghdGhpcy5hY3RpdmUubGVuZ3RoKVxuICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlO1xuICAgIGxldCBuID0gW107XG4gICAgZm9yIChsZXQgciA9IHRoaXMuYWN0aXZlLmxlbmd0aCAtIDE7IHIgPj0gMCAmJiAhKHRoaXMuYWN0aXZlUmFua1tyXSA8IHRoaXMucG9pbnRSYW5rKTsgci0tKVxuICAgICAgKHRoaXMuYWN0aXZlVG9bcl0gPiBlIHx8IHRoaXMuYWN0aXZlVG9bcl0gPT0gZSAmJiB0aGlzLmFjdGl2ZVtyXS5lbmRTaWRlID49IHRoaXMucG9pbnQuZW5kU2lkZSkgJiYgbi5wdXNoKHRoaXMuYWN0aXZlW3JdKTtcbiAgICByZXR1cm4gbi5yZXZlcnNlKCk7XG4gIH1cbiAgb3BlbkVuZChlKSB7XG4gICAgbGV0IG4gPSAwO1xuICAgIGZvciAobGV0IHIgPSB0aGlzLmFjdGl2ZVRvLmxlbmd0aCAtIDE7IHIgPj0gMCAmJiB0aGlzLmFjdGl2ZVRvW3JdID4gZTsgci0tKVxuICAgICAgbisrO1xuICAgIHJldHVybiBuO1xuICB9XG59XG5mdW5jdGlvbiBXYih0LCBlLCBuLCByLCBpLCBzKSB7XG4gIHQuZ290byhlKSwgbi5nb3RvKHIpO1xuICBsZXQgbyA9IHIgKyBpLCBhID0gciwgbCA9IHIgLSBlO1xuICBmb3IgKDsgOyApIHtcbiAgICBsZXQgYyA9IHQudG8gKyBsIC0gbi50byB8fCB0LmVuZFNpZGUgLSBuLmVuZFNpZGUsIHUgPSBjIDwgMCA/IHQudG8gKyBsIDogbi50bywgZCA9IE1hdGgubWluKHUsIG8pO1xuICAgIGlmICh0LnBvaW50IHx8IG4ucG9pbnQgPyB0LnBvaW50ICYmIG4ucG9pbnQgJiYgKHQucG9pbnQgPT0gbi5wb2ludCB8fCB0LnBvaW50LmVxKG4ucG9pbnQpKSAmJiBKaCh0LmFjdGl2ZUZvclBvaW50KHQudG8pLCBuLmFjdGl2ZUZvclBvaW50KG4udG8pKSB8fCBzLmNvbXBhcmVQb2ludChhLCBkLCB0LnBvaW50LCBuLnBvaW50KSA6IGQgPiBhICYmICFKaCh0LmFjdGl2ZSwgbi5hY3RpdmUpICYmIHMuY29tcGFyZVJhbmdlKGEsIGQsIHQuYWN0aXZlLCBuLmFjdGl2ZSksIHUgPiBvKVxuICAgICAgYnJlYWs7XG4gICAgYSA9IHUsIGMgPD0gMCAmJiB0Lm5leHQoKSwgYyA+PSAwICYmIG4ubmV4dCgpO1xuICB9XG59XG5mdW5jdGlvbiBKaCh0LCBlKSB7XG4gIGlmICh0Lmxlbmd0aCAhPSBlLmxlbmd0aClcbiAgICByZXR1cm4gITE7XG4gIGZvciAobGV0IG4gPSAwOyBuIDwgdC5sZW5ndGg7IG4rKylcbiAgICBpZiAodFtuXSAhPSBlW25dICYmICF0W25dLmVxKGVbbl0pKVxuICAgICAgcmV0dXJuICExO1xuICByZXR1cm4gITA7XG59XG5mdW5jdGlvbiBrYyh0LCBlKSB7XG4gIGZvciAobGV0IG4gPSBlLCByID0gdC5sZW5ndGggLSAxOyBuIDwgcjsgbisrKVxuICAgIHRbbl0gPSB0W24gKyAxXTtcbiAgdC5wb3AoKTtcbn1cbmZ1bmN0aW9uIHhjKHQsIGUsIG4pIHtcbiAgZm9yIChsZXQgciA9IHQubGVuZ3RoIC0gMTsgciA+PSBlOyByLS0pXG4gICAgdFtyICsgMV0gPSB0W3JdO1xuICB0W2VdID0gbjtcbn1cbmZ1bmN0aW9uIE1iKHQsIGUpIHtcbiAgbGV0IG4gPSAtMSwgciA9IDFlOTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlLmxlbmd0aDsgaSsrKVxuICAgIChlW2ldIC0gciB8fCB0W2ldLmVuZFNpZGUgLSB0W25dLmVuZFNpZGUpIDwgMCAmJiAobiA9IGksIHIgPSBlW2ldKTtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBpZyh0LCBlLCBuID0gdC5sZW5ndGgpIHtcbiAgbGV0IHIgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG47IClcbiAgICB0LmNoYXJDb2RlQXQoaSkgPT0gOSA/IChyICs9IGUgLSByICUgZSwgaSsrKSA6IChyKyssIGkgPSBScih0LCBpKSk7XG4gIHJldHVybiByO1xufVxuZnVuY3Rpb24gaE4odCwgZSwgbiwgcikge1xuICBmb3IgKGxldCBpID0gMCwgcyA9IDA7IDsgKSB7XG4gICAgaWYgKHMgPj0gZSlcbiAgICAgIHJldHVybiBpO1xuICAgIGlmIChpID09IHQubGVuZ3RoKVxuICAgICAgYnJlYWs7XG4gICAgcyArPSB0LmNoYXJDb2RlQXQoaSkgPT0gOSA/IG4gLSBzICUgbiA6IDEsIGkgPSBScih0LCBpKTtcbiAgfVxuICByZXR1cm4gciA9PT0gITAgPyAtMSA6IHQubGVuZ3RoO1xufVxuY29uc3QgZXAgPSBcIs28XCIsIFhiID0gdHlwZW9mIFN5bWJvbCA+IFwidVwiID8gXCJfX1wiICsgZXAgOiBTeW1ib2wuZm9yKGVwKSwgdHAgPSB0eXBlb2YgU3ltYm9sID4gXCJ1XCIgPyBcIl9fc3R5bGVTZXRcIiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDFlOCkgOiBTeW1ib2woXCJzdHlsZVNldFwiKSwgamIgPSB0eXBlb2YgZ2xvYmFsVGhpcyA8IFwidVwiID8gZ2xvYmFsVGhpcyA6IHR5cGVvZiB3aW5kb3cgPCBcInVcIiA/IHdpbmRvdyA6IHt9O1xuY2xhc3Mgc3Mge1xuICAvLyA6OiAoT2JqZWN0PFN0eWxlPiwgP3tmaW5pc2g6ID8oc3RyaW5nKSDihpIgc3RyaW5nfSlcbiAgLy8gQ3JlYXRlIGEgc3R5bGUgbW9kdWxlIGZyb20gdGhlIGdpdmVuIHNwZWMuXG4gIC8vXG4gIC8vIFdoZW4gYGZpbmlzaGAgaXMgZ2l2ZW4sIGl0IGlzIGNhbGxlZCBvbiByZWd1bGFyIChub24tYEBgKVxuICAvLyBzZWxlY3RvcnMgKGFmdGVyIGAmYCBleHBhbnNpb24pIHRvIGNvbXB1dGUgdGhlIGZpbmFsIHNlbGVjdG9yLlxuICBjb25zdHJ1Y3RvcihlLCBuKSB7XG4gICAgdGhpcy5ydWxlcyA9IFtdO1xuICAgIGxldCB7IGZpbmlzaDogciB9ID0gbiB8fCB7fTtcbiAgICBmdW5jdGlvbiBpKG8pIHtcbiAgICAgIHJldHVybiAvXkAvLnRlc3QobykgPyBbb10gOiBvLnNwbGl0KC8sXFxzKi8pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzKG8sIGEsIGwsIGMpIHtcbiAgICAgIGxldCB1ID0gW10sIGQgPSAvXkAoXFx3KylcXGIvLmV4ZWMob1swXSksIGYgPSBkICYmIGRbMV0gPT0gXCJrZXlmcmFtZXNcIjtcbiAgICAgIGlmIChkICYmIGEgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGwucHVzaChvWzBdICsgXCI7XCIpO1xuICAgICAgZm9yIChsZXQgaCBpbiBhKSB7XG4gICAgICAgIGxldCBwID0gYVtoXTtcbiAgICAgICAgaWYgKC8mLy50ZXN0KGgpKVxuICAgICAgICAgIHMoXG4gICAgICAgICAgICBoLnNwbGl0KC8sXFxzKi8pLm1hcCgoTykgPT4gby5tYXAoKG0pID0+IE8ucmVwbGFjZSgvJi8sIG0pKSkucmVkdWNlKChPLCBtKSA9PiBPLmNvbmNhdChtKSksXG4gICAgICAgICAgICBwLFxuICAgICAgICAgICAgbFxuICAgICAgICAgICk7XG4gICAgICAgIGVsc2UgaWYgKHAgJiYgdHlwZW9mIHAgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIGlmICghZClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgKFwiICsgaCArIFwiKSBzaG91bGQgYmUgYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICAgICAgICAgIHMoaShoKSwgcCwgdSwgZik7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIHAgIT0gbnVsbCAmJiB1LnB1c2goaC5yZXBsYWNlKC9fLiovLCBcIlwiKS5yZXBsYWNlKC9bQS1aXS9nLCAoTykgPT4gXCItXCIgKyBPLnRvTG93ZXJDYXNlKCkpICsgXCI6IFwiICsgcCArIFwiO1wiKTtcbiAgICAgIH1cbiAgICAgICh1Lmxlbmd0aCB8fCBmKSAmJiBsLnB1c2goKHIgJiYgIWQgJiYgIWMgPyBvLm1hcChyKSA6IG8pLmpvaW4oXCIsIFwiKSArIFwiIHtcIiArIHUuam9pbihcIiBcIikgKyBcIn1cIik7XG4gICAgfVxuICAgIGZvciAobGV0IG8gaW4gZSlcbiAgICAgIHMoaShvKSwgZVtvXSwgdGhpcy5ydWxlcyk7XG4gIH1cbiAgLy8gOjogKCkg4oaSIHN0cmluZ1xuICAvLyBSZXR1cm5zIGEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIG1vZHVsZSdzIENTUyBydWxlcy5cbiAgZ2V0UnVsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMucnVsZXMuam9pbihgXG5gKTtcbiAgfVxuICAvLyA6OiAoKSDihpIgc3RyaW5nXG4gIC8vIEdlbmVyYXRlIGEgbmV3IHVuaXF1ZSBDU1MgY2xhc3MgbmFtZS5cbiAgc3RhdGljIG5ld05hbWUoKSB7XG4gICAgbGV0IGUgPSBqYltYYl0gfHwgMTtcbiAgICByZXR1cm4gamJbWGJdID0gZSArIDEsIGVwICsgZS50b1N0cmluZygzNik7XG4gIH1cbiAgLy8gOjogKHVuaW9uPERvY3VtZW50LCBTaGFkb3dSb290PiwgdW5pb248W1N0eWxlTW9kdWxlXSwgU3R5bGVNb2R1bGU+LCA/e25vbmNlOiA/c3RyaW5nfSlcbiAgLy9cbiAgLy8gTW91bnQgdGhlIGdpdmVuIHNldCBvZiBtb2R1bGVzIGluIHRoZSBnaXZlbiBET00gcm9vdCwgd2hpY2ggZW5zdXJlc1xuICAvLyB0aGF0IHRoZSBDU1MgcnVsZXMgZGVmaW5lZCBieSB0aGUgbW9kdWxlIGFyZSBhdmFpbGFibGUgaW4gdGhhdFxuICAvLyBjb250ZXh0LlxuICAvL1xuICAvLyBSdWxlcyBhcmUgb25seSBhZGRlZCB0byB0aGUgZG9jdW1lbnQgb25jZSBwZXIgcm9vdC5cbiAgLy9cbiAgLy8gUnVsZSBvcmRlciB3aWxsIGZvbGxvdyB0aGUgb3JkZXIgb2YgdGhlIG1vZHVsZXMsIHNvIHRoYXQgcnVsZXMgZnJvbVxuICAvLyBtb2R1bGVzIGxhdGVyIGluIHRoZSBhcnJheSB0YWtlIHByZWNlZGVuY2Ugb2YgdGhvc2UgZnJvbSBlYXJsaWVyXG4gIC8vIG1vZHVsZXMuIElmIHlvdSBjYWxsIHRoaXMgZnVuY3Rpb24gbXVsdGlwbGUgdGltZXMgZm9yIHRoZSBzYW1lIHJvb3RcbiAgLy8gaW4gYSB3YXkgdGhhdCBjaGFuZ2VzIHRoZSBvcmRlciBvZiBhbHJlYWR5IG1vdW50ZWQgbW9kdWxlcywgdGhlIG9sZFxuICAvLyBvcmRlciB3aWxsIGJlIGNoYW5nZWQuXG4gIC8vXG4gIC8vIElmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgbm9uY2UgaXMgcHJvdmlkZWQsIGl0IGlzIGFkZGVkIHRvXG4gIC8vIHRoZSBgPHN0eWxlPmAgdGFnIGdlbmVyYXRlZCBieSB0aGUgbGlicmFyeS5cbiAgc3RhdGljIG1vdW50KGUsIG4sIHIpIHtcbiAgICBsZXQgaSA9IGVbdHBdLCBzID0gciAmJiByLm5vbmNlO1xuICAgIGkgPyBzICYmIGkuc2V0Tm9uY2UocykgOiBpID0gbmV3IHBOKGUsIHMpLCBpLm1vdW50KEFycmF5LmlzQXJyYXkobikgPyBuIDogW25dKTtcbiAgfVxufVxubGV0IEJiID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbmNsYXNzIHBOIHtcbiAgY29uc3RydWN0b3IoZSwgbikge1xuICAgIHRoaXMucm9vdCA9IGU7XG4gICAgbGV0IHIgPSBlLm93bmVyRG9jdW1lbnQgfHwgZSwgaSA9IHIuZGVmYXVsdFZpZXc7XG4gICAgaWYgKCFlLmhlYWQgJiYgZS5hZG9wdGVkU3R5bGVTaGVldHMgJiYgaS5DU1NTdHlsZVNoZWV0KSB7XG4gICAgICBsZXQgcyA9IEJiLmdldChyKTtcbiAgICAgIGlmIChzKVxuICAgICAgICByZXR1cm4gZVt0cF0gPSBzO1xuICAgICAgdGhpcy5zaGVldCA9IG5ldyBpLkNTU1N0eWxlU2hlZXQoKSwgQmIuc2V0KHIsIHRoaXMpO1xuICAgIH0gZWxzZVxuICAgICAgdGhpcy5zdHlsZVRhZyA9IHIuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpLCBuICYmIHRoaXMuc3R5bGVUYWcuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgbik7XG4gICAgdGhpcy5tb2R1bGVzID0gW10sIGVbdHBdID0gdGhpcztcbiAgfVxuICBtb3VudChlKSB7XG4gICAgbGV0IG4gPSB0aGlzLnNoZWV0LCByID0gMCwgaSA9IDA7XG4gICAgZm9yIChsZXQgcyA9IDA7IHMgPCBlLmxlbmd0aDsgcysrKSB7XG4gICAgICBsZXQgbyA9IGVbc10sIGEgPSB0aGlzLm1vZHVsZXMuaW5kZXhPZihvKTtcbiAgICAgIGlmIChhIDwgaSAmJiBhID4gLTEgJiYgKHRoaXMubW9kdWxlcy5zcGxpY2UoYSwgMSksIGktLSwgYSA9IC0xKSwgYSA9PSAtMSkge1xuICAgICAgICBpZiAodGhpcy5tb2R1bGVzLnNwbGljZShpKyssIDAsIG8pLCBuKVxuICAgICAgICAgIGZvciAobGV0IGwgPSAwOyBsIDwgby5ydWxlcy5sZW5ndGg7IGwrKylcbiAgICAgICAgICAgIG4uaW5zZXJ0UnVsZShvLnJ1bGVzW2xdLCByKyspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICg7IGkgPCBhOyApXG4gICAgICAgICAgciArPSB0aGlzLm1vZHVsZXNbaSsrXS5ydWxlcy5sZW5ndGg7XG4gICAgICAgIHIgKz0gby5ydWxlcy5sZW5ndGgsIGkrKztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG4pXG4gICAgICB0aGlzLnJvb3QuYWRvcHRlZFN0eWxlU2hlZXRzLmluZGV4T2YodGhpcy5zaGVldCkgPCAwICYmICh0aGlzLnJvb3QuYWRvcHRlZFN0eWxlU2hlZXRzID0gW3RoaXMuc2hlZXQsIC4uLnRoaXMucm9vdC5hZG9wdGVkU3R5bGVTaGVldHNdKTtcbiAgICBlbHNlIHtcbiAgICAgIGxldCBzID0gXCJcIjtcbiAgICAgIGZvciAobGV0IGEgPSAwOyBhIDwgdGhpcy5tb2R1bGVzLmxlbmd0aDsgYSsrKVxuICAgICAgICBzICs9IHRoaXMubW9kdWxlc1thXS5nZXRSdWxlcygpICsgYFxuYDtcbiAgICAgIHRoaXMuc3R5bGVUYWcudGV4dENvbnRlbnQgPSBzO1xuICAgICAgbGV0IG8gPSB0aGlzLnJvb3QuaGVhZCB8fCB0aGlzLnJvb3Q7XG4gICAgICB0aGlzLnN0eWxlVGFnLnBhcmVudE5vZGUgIT0gbyAmJiBvLmluc2VydEJlZm9yZSh0aGlzLnN0eWxlVGFnLCBvLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgfVxuICBzZXROb25jZShlKSB7XG4gICAgdGhpcy5zdHlsZVRhZyAmJiB0aGlzLnN0eWxlVGFnLmdldEF0dHJpYnV0ZShcIm5vbmNlXCIpICE9IGUgJiYgdGhpcy5zdHlsZVRhZy5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBlKTtcbiAgfVxufVxudmFyIG9zID0ge1xuICA4OiBcIkJhY2tzcGFjZVwiLFxuICA5OiBcIlRhYlwiLFxuICAxMDogXCJFbnRlclwiLFxuICAxMjogXCJOdW1Mb2NrXCIsXG4gIDEzOiBcIkVudGVyXCIsXG4gIDE2OiBcIlNoaWZ0XCIsXG4gIDE3OiBcIkNvbnRyb2xcIixcbiAgMTg6IFwiQWx0XCIsXG4gIDIwOiBcIkNhcHNMb2NrXCIsXG4gIDI3OiBcIkVzY2FwZVwiLFxuICAzMjogXCIgXCIsXG4gIDMzOiBcIlBhZ2VVcFwiLFxuICAzNDogXCJQYWdlRG93blwiLFxuICAzNTogXCJFbmRcIixcbiAgMzY6IFwiSG9tZVwiLFxuICAzNzogXCJBcnJvd0xlZnRcIixcbiAgMzg6IFwiQXJyb3dVcFwiLFxuICAzOTogXCJBcnJvd1JpZ2h0XCIsXG4gIDQwOiBcIkFycm93RG93blwiLFxuICA0NDogXCJQcmludFNjcmVlblwiLFxuICA0NTogXCJJbnNlcnRcIixcbiAgNDY6IFwiRGVsZXRlXCIsXG4gIDU5OiBcIjtcIixcbiAgNjE6IFwiPVwiLFxuICA5MTogXCJNZXRhXCIsXG4gIDkyOiBcIk1ldGFcIixcbiAgMTA2OiBcIipcIixcbiAgMTA3OiBcIitcIixcbiAgMTA4OiBcIixcIixcbiAgMTA5OiBcIi1cIixcbiAgMTEwOiBcIi5cIixcbiAgMTExOiBcIi9cIixcbiAgMTQ0OiBcIk51bUxvY2tcIixcbiAgMTQ1OiBcIlNjcm9sbExvY2tcIixcbiAgMTYwOiBcIlNoaWZ0XCIsXG4gIDE2MTogXCJTaGlmdFwiLFxuICAxNjI6IFwiQ29udHJvbFwiLFxuICAxNjM6IFwiQ29udHJvbFwiLFxuICAxNjQ6IFwiQWx0XCIsXG4gIDE2NTogXCJBbHRcIixcbiAgMTczOiBcIi1cIixcbiAgMTg2OiBcIjtcIixcbiAgMTg3OiBcIj1cIixcbiAgMTg4OiBcIixcIixcbiAgMTg5OiBcIi1cIixcbiAgMTkwOiBcIi5cIixcbiAgMTkxOiBcIi9cIixcbiAgMTkyOiBcImBcIixcbiAgMjE5OiBcIltcIixcbiAgMjIwOiBcIlxcXFxcIixcbiAgMjIxOiBcIl1cIixcbiAgMjIyOiBcIidcIlxufSwgcGwgPSB7XG4gIDQ4OiBcIilcIixcbiAgNDk6IFwiIVwiLFxuICA1MDogXCJAXCIsXG4gIDUxOiBcIiNcIixcbiAgNTI6IFwiJFwiLFxuICA1MzogXCIlXCIsXG4gIDU0OiBcIl5cIixcbiAgNTU6IFwiJlwiLFxuICA1NjogXCIqXCIsXG4gIDU3OiBcIihcIixcbiAgNTk6IFwiOlwiLFxuICA2MTogXCIrXCIsXG4gIDE3MzogXCJfXCIsXG4gIDE4NjogXCI6XCIsXG4gIDE4NzogXCIrXCIsXG4gIDE4ODogXCI8XCIsXG4gIDE4OTogXCJfXCIsXG4gIDE5MDogXCI+XCIsXG4gIDE5MTogXCI/XCIsXG4gIDE5MjogXCJ+XCIsXG4gIDIxOTogXCJ7XCIsXG4gIDIyMDogXCJ8XCIsXG4gIDIyMTogXCJ9XCIsXG4gIDIyMjogJ1wiJ1xufSwgT04gPSB0eXBlb2YgbmF2aWdhdG9yIDwgXCJ1XCIgJiYgL01hYy8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pLCBnTiA9IHR5cGVvZiBuYXZpZ2F0b3IgPCBcInVcIiAmJiAvTVNJRSBcXGR8VHJpZGVudFxcLyg/Ols3LTldfFxcZHsyLH0pXFwuLipydjooXFxkKykvLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG5mb3IgKHZhciBIdCA9IDA7IEh0IDwgMTA7IEh0KyspXG4gIG9zWzQ4ICsgSHRdID0gb3NbOTYgKyBIdF0gPSBTdHJpbmcoSHQpO1xuZm9yICh2YXIgSHQgPSAxOyBIdCA8PSAyNDsgSHQrKylcbiAgb3NbSHQgKyAxMTFdID0gXCJGXCIgKyBIdDtcbmZvciAodmFyIEh0ID0gNjU7IEh0IDw9IDkwOyBIdCsrKVxuICBvc1tIdF0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKEh0ICsgMzIpLCBwbFtIdF0gPSBTdHJpbmcuZnJvbUNoYXJDb2RlKEh0KTtcbmZvciAodmFyIGtmIGluIG9zKVxuICBwbC5oYXNPd25Qcm9wZXJ0eShrZikgfHwgKHBsW2tmXSA9IG9zW2tmXSk7XG5mdW5jdGlvbiBtTih0KSB7XG4gIHZhciBlID0gT04gJiYgdC5tZXRhS2V5ICYmIHQuc2hpZnRLZXkgJiYgIXQuY3RybEtleSAmJiAhdC5hbHRLZXkgfHwgZ04gJiYgdC5zaGlmdEtleSAmJiB0LmtleSAmJiB0LmtleS5sZW5ndGggPT0gMSB8fCB0LmtleSA9PSBcIlVuaWRlbnRpZmllZFwiLCBuID0gIWUgJiYgdC5rZXkgfHwgKHQuc2hpZnRLZXkgPyBwbCA6IG9zKVt0LmtleUNvZGVdIHx8IHQua2V5IHx8IFwiVW5pZGVudGlmaWVkXCI7XG4gIHJldHVybiBuID09IFwiRXNjXCIgJiYgKG4gPSBcIkVzY2FwZVwiKSwgbiA9PSBcIkRlbFwiICYmIChuID0gXCJEZWxldGVcIiksIG4gPT0gXCJMZWZ0XCIgJiYgKG4gPSBcIkFycm93TGVmdFwiKSwgbiA9PSBcIlVwXCIgJiYgKG4gPSBcIkFycm93VXBcIiksIG4gPT0gXCJSaWdodFwiICYmIChuID0gXCJBcnJvd1JpZ2h0XCIpLCBuID09IFwiRG93blwiICYmIChuID0gXCJBcnJvd0Rvd25cIiksIG47XG59XG5mdW5jdGlvbiBJdSh0KSB7XG4gIGxldCBlO1xuICByZXR1cm4gdC5ub2RlVHlwZSA9PSAxMSA/IGUgPSB0LmdldFNlbGVjdGlvbiA/IHQgOiB0Lm93bmVyRG9jdW1lbnQgOiBlID0gdCwgZS5nZXRTZWxlY3Rpb24oKTtcbn1cbmZ1bmN0aW9uIG5wKHQsIGUpIHtcbiAgcmV0dXJuIGUgPyB0ID09IGUgfHwgdC5jb250YWlucyhlLm5vZGVUeXBlICE9IDEgPyBlLnBhcmVudE5vZGUgOiBlKSA6ICExO1xufVxuZnVuY3Rpb24gYk4odCkge1xuICBsZXQgZSA9IHQuYWN0aXZlRWxlbWVudDtcbiAgZm9yICg7IGUgJiYgZS5zaGFkb3dSb290OyApXG4gICAgZSA9IGUuc2hhZG93Um9vdC5hY3RpdmVFbGVtZW50O1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIHJ1KHQsIGUpIHtcbiAgaWYgKCFlLmFuY2hvck5vZGUpXG4gICAgcmV0dXJuICExO1xuICB0cnkge1xuICAgIHJldHVybiBucCh0LCBlLmFuY2hvck5vZGUpO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbn1cbmZ1bmN0aW9uIE9sKHQpIHtcbiAgcmV0dXJuIHQubm9kZVR5cGUgPT0gMyA/IFlzKHQsIDAsIHQubm9kZVZhbHVlLmxlbmd0aCkuZ2V0Q2xpZW50UmVjdHMoKSA6IHQubm9kZVR5cGUgPT0gMSA/IHQuZ2V0Q2xpZW50UmVjdHMoKSA6IFtdO1xufVxuZnVuY3Rpb24gemEodCwgZSwgbiwgcikge1xuICByZXR1cm4gbiA/IExiKHQsIGUsIG4sIHIsIC0xKSB8fCBMYih0LCBlLCBuLCByLCAxKSA6ICExO1xufVxuZnVuY3Rpb24gZ2wodCkge1xuICBmb3IgKHZhciBlID0gMDsgOyBlKyspXG4gICAgaWYgKHQgPSB0LnByZXZpb3VzU2libGluZywgIXQpXG4gICAgICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIExiKHQsIGUsIG4sIHIsIGkpIHtcbiAgZm9yICg7IDsgKSB7XG4gICAgaWYgKHQgPT0gbiAmJiBlID09IHIpXG4gICAgICByZXR1cm4gITA7XG4gICAgaWYgKGUgPT0gKGkgPCAwID8gMCA6IGZpKHQpKSkge1xuICAgICAgaWYgKHQubm9kZU5hbWUgPT0gXCJESVZcIilcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgbGV0IHMgPSB0LnBhcmVudE5vZGU7XG4gICAgICBpZiAoIXMgfHwgcy5ub2RlVHlwZSAhPSAxKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBlID0gZ2wodCkgKyAoaSA8IDAgPyAwIDogMSksIHQgPSBzO1xuICAgIH0gZWxzZSBpZiAodC5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICBpZiAodCA9IHQuY2hpbGROb2Rlc1tlICsgKGkgPCAwID8gLTEgOiAwKV0sIHQubm9kZVR5cGUgPT0gMSAmJiB0LmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGUgPSBpIDwgMCA/IGZpKHQpIDogMDtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybiAhMTtcbiAgfVxufVxuZnVuY3Rpb24gZmkodCkge1xuICByZXR1cm4gdC5ub2RlVHlwZSA9PSAzID8gdC5ub2RlVmFsdWUubGVuZ3RoIDogdC5jaGlsZE5vZGVzLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIHNnKHQsIGUpIHtcbiAgbGV0IG4gPSBlID8gdC5sZWZ0IDogdC5yaWdodDtcbiAgcmV0dXJuIHsgbGVmdDogbiwgcmlnaHQ6IG4sIHRvcDogdC50b3AsIGJvdHRvbTogdC5ib3R0b20gfTtcbn1cbmZ1bmN0aW9uIHZOKHQpIHtcbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiAwLFxuICAgIHJpZ2h0OiB0LmlubmVyV2lkdGgsXG4gICAgdG9wOiAwLFxuICAgIGJvdHRvbTogdC5pbm5lckhlaWdodFxuICB9O1xufVxuZnVuY3Rpb24gS3codCwgZSkge1xuICBsZXQgbiA9IGUud2lkdGggLyB0Lm9mZnNldFdpZHRoLCByID0gZS5oZWlnaHQgLyB0Lm9mZnNldEhlaWdodDtcbiAgcmV0dXJuIChuID4gMC45OTUgJiYgbiA8IDEuMDA1IHx8ICFpc0Zpbml0ZShuKSB8fCBNYXRoLmFicyhlLndpZHRoIC0gdC5vZmZzZXRXaWR0aCkgPCAxKSAmJiAobiA9IDEpLCAociA+IDAuOTk1ICYmIHIgPCAxLjAwNSB8fCAhaXNGaW5pdGUocikgfHwgTWF0aC5hYnMoZS5oZWlnaHQgLSB0Lm9mZnNldEhlaWdodCkgPCAxKSAmJiAociA9IDEpLCB7IHNjYWxlWDogbiwgc2NhbGVZOiByIH07XG59XG5mdW5jdGlvbiB5Tih0LCBlLCBuLCByLCBpLCBzLCBvLCBhKSB7XG4gIGxldCBsID0gdC5vd25lckRvY3VtZW50LCBjID0gbC5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gIGZvciAobGV0IHUgPSB0LCBkID0gITE7IHUgJiYgIWQ7IClcbiAgICBpZiAodS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICBsZXQgZiwgaCA9IHUgPT0gbC5ib2R5LCBwID0gMSwgTyA9IDE7XG4gICAgICBpZiAoaClcbiAgICAgICAgZiA9IHZOKGMpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmICgvXihmaXhlZHxzdGlja3kpJC8udGVzdChnZXRDb21wdXRlZFN0eWxlKHUpLnBvc2l0aW9uKSAmJiAoZCA9ICEwKSwgdS5zY3JvbGxIZWlnaHQgPD0gdS5jbGllbnRIZWlnaHQgJiYgdS5zY3JvbGxXaWR0aCA8PSB1LmNsaWVudFdpZHRoKSB7XG4gICAgICAgICAgdSA9IHUuYXNzaWduZWRTbG90IHx8IHUucGFyZW50Tm9kZTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYiA9IHUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICh7IHNjYWxlWDogcCwgc2NhbGVZOiBPIH0gPSBLdyh1LCBiKSksIGYgPSB7XG4gICAgICAgICAgbGVmdDogYi5sZWZ0LFxuICAgICAgICAgIHJpZ2h0OiBiLmxlZnQgKyB1LmNsaWVudFdpZHRoICogcCxcbiAgICAgICAgICB0b3A6IGIudG9wLFxuICAgICAgICAgIGJvdHRvbTogYi50b3AgKyB1LmNsaWVudEhlaWdodCAqIE9cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGxldCBtID0gMCwgeSA9IDA7XG4gICAgICBpZiAoaSA9PSBcIm5lYXJlc3RcIilcbiAgICAgICAgZS50b3AgPCBmLnRvcCA/ICh5ID0gLShmLnRvcCAtIGUudG9wICsgbyksIG4gPiAwICYmIGUuYm90dG9tID4gZi5ib3R0b20gKyB5ICYmICh5ID0gZS5ib3R0b20gLSBmLmJvdHRvbSArIHkgKyBvKSkgOiBlLmJvdHRvbSA+IGYuYm90dG9tICYmICh5ID0gZS5ib3R0b20gLSBmLmJvdHRvbSArIG8sIG4gPCAwICYmIGUudG9wIC0geSA8IGYudG9wICYmICh5ID0gLShmLnRvcCArIHkgLSBlLnRvcCArIG8pKSk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgbGV0IGIgPSBlLmJvdHRvbSAtIGUudG9wLCBnID0gZi5ib3R0b20gLSBmLnRvcDtcbiAgICAgICAgeSA9IChpID09IFwiY2VudGVyXCIgJiYgYiA8PSBnID8gZS50b3AgKyBiIC8gMiAtIGcgLyAyIDogaSA9PSBcInN0YXJ0XCIgfHwgaSA9PSBcImNlbnRlclwiICYmIG4gPCAwID8gZS50b3AgLSBvIDogZS5ib3R0b20gLSBnICsgbykgLSBmLnRvcDtcbiAgICAgIH1cbiAgICAgIGlmIChyID09IFwibmVhcmVzdFwiID8gZS5sZWZ0IDwgZi5sZWZ0ID8gKG0gPSAtKGYubGVmdCAtIGUubGVmdCArIHMpLCBuID4gMCAmJiBlLnJpZ2h0ID4gZi5yaWdodCArIG0gJiYgKG0gPSBlLnJpZ2h0IC0gZi5yaWdodCArIG0gKyBzKSkgOiBlLnJpZ2h0ID4gZi5yaWdodCAmJiAobSA9IGUucmlnaHQgLSBmLnJpZ2h0ICsgcywgbiA8IDAgJiYgZS5sZWZ0IDwgZi5sZWZ0ICsgbSAmJiAobSA9IC0oZi5sZWZ0ICsgbSAtIGUubGVmdCArIHMpKSkgOiBtID0gKHIgPT0gXCJjZW50ZXJcIiA/IGUubGVmdCArIChlLnJpZ2h0IC0gZS5sZWZ0KSAvIDIgLSAoZi5yaWdodCAtIGYubGVmdCkgLyAyIDogciA9PSBcInN0YXJ0XCIgPT0gYSA/IGUubGVmdCAtIHMgOiBlLnJpZ2h0IC0gKGYucmlnaHQgLSBmLmxlZnQpICsgcykgLSBmLmxlZnQsIG0gfHwgeSlcbiAgICAgICAgaWYgKGgpXG4gICAgICAgICAgYy5zY3JvbGxCeShtLCB5KTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbGV0IGIgPSAwLCBnID0gMDtcbiAgICAgICAgICBpZiAoeSkge1xuICAgICAgICAgICAgbGV0IHYgPSB1LnNjcm9sbFRvcDtcbiAgICAgICAgICAgIHUuc2Nyb2xsVG9wICs9IHkgLyBPLCBnID0gKHUuc2Nyb2xsVG9wIC0gdikgKiBPO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgbGV0IHYgPSB1LnNjcm9sbExlZnQ7XG4gICAgICAgICAgICB1LnNjcm9sbExlZnQgKz0gbSAvIHAsIGIgPSAodS5zY3JvbGxMZWZ0IC0gdikgKiBwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlID0ge1xuICAgICAgICAgICAgbGVmdDogZS5sZWZ0IC0gYixcbiAgICAgICAgICAgIHRvcDogZS50b3AgLSBnLFxuICAgICAgICAgICAgcmlnaHQ6IGUucmlnaHQgLSBiLFxuICAgICAgICAgICAgYm90dG9tOiBlLmJvdHRvbSAtIGdcbiAgICAgICAgICB9LCBiICYmIE1hdGguYWJzKGIgLSBtKSA8IDEgJiYgKHIgPSBcIm5lYXJlc3RcIiksIGcgJiYgTWF0aC5hYnMoZyAtIHkpIDwgMSAmJiAoaSA9IFwibmVhcmVzdFwiKTtcbiAgICAgICAgfVxuICAgICAgaWYgKGgpXG4gICAgICAgIGJyZWFrO1xuICAgICAgdSA9IHUuYXNzaWduZWRTbG90IHx8IHUucGFyZW50Tm9kZTtcbiAgICB9IGVsc2UgaWYgKHUubm9kZVR5cGUgPT0gMTEpXG4gICAgICB1ID0gdS5ob3N0O1xuICAgIGVsc2VcbiAgICAgIGJyZWFrO1xufVxuZnVuY3Rpb24gU04odCkge1xuICBsZXQgZSA9IHQub3duZXJEb2N1bWVudDtcbiAgZm9yIChsZXQgbiA9IHQucGFyZW50Tm9kZTsgbiAmJiBuICE9IGUuYm9keTsgKVxuICAgIGlmIChuLm5vZGVUeXBlID09IDEpIHtcbiAgICAgIGlmIChuLnNjcm9sbEhlaWdodCA+IG4uY2xpZW50SGVpZ2h0IHx8IG4uc2Nyb2xsV2lkdGggPiBuLmNsaWVudFdpZHRoKVxuICAgICAgICByZXR1cm4gbjtcbiAgICAgIG4gPSBuLmFzc2lnbmVkU2xvdCB8fCBuLnBhcmVudE5vZGU7XG4gICAgfSBlbHNlIGlmIChuLm5vZGVUeXBlID09IDExKVxuICAgICAgbiA9IG4uaG9zdDtcbiAgICBlbHNlXG4gICAgICBicmVhaztcbiAgcmV0dXJuIG51bGw7XG59XG5jbGFzcyB3TiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYW5jaG9yTm9kZSA9IG51bGwsIHRoaXMuYW5jaG9yT2Zmc2V0ID0gMCwgdGhpcy5mb2N1c05vZGUgPSBudWxsLCB0aGlzLmZvY3VzT2Zmc2V0ID0gMDtcbiAgfVxuICBlcShlKSB7XG4gICAgcmV0dXJuIHRoaXMuYW5jaG9yTm9kZSA9PSBlLmFuY2hvck5vZGUgJiYgdGhpcy5hbmNob3JPZmZzZXQgPT0gZS5hbmNob3JPZmZzZXQgJiYgdGhpcy5mb2N1c05vZGUgPT0gZS5mb2N1c05vZGUgJiYgdGhpcy5mb2N1c09mZnNldCA9PSBlLmZvY3VzT2Zmc2V0O1xuICB9XG4gIHNldFJhbmdlKGUpIHtcbiAgICBsZXQgeyBhbmNob3JOb2RlOiBuLCBmb2N1c05vZGU6IHIgfSA9IGU7XG4gICAgdGhpcy5zZXQobiwgTWF0aC5taW4oZS5hbmNob3JPZmZzZXQsIG4gPyBmaShuKSA6IDApLCByLCBNYXRoLm1pbihlLmZvY3VzT2Zmc2V0LCByID8gZmkocikgOiAwKSk7XG4gIH1cbiAgc2V0KGUsIG4sIHIsIGkpIHtcbiAgICB0aGlzLmFuY2hvck5vZGUgPSBlLCB0aGlzLmFuY2hvck9mZnNldCA9IG4sIHRoaXMuZm9jdXNOb2RlID0gciwgdGhpcy5mb2N1c09mZnNldCA9IGk7XG4gIH1cbn1cbmxldCBvbyA9IG51bGw7XG5mdW5jdGlvbiBKdyh0KSB7XG4gIGlmICh0LnNldEFjdGl2ZSlcbiAgICByZXR1cm4gdC5zZXRBY3RpdmUoKTtcbiAgaWYgKG9vKVxuICAgIHJldHVybiB0LmZvY3VzKG9vKTtcbiAgbGV0IGUgPSBbXTtcbiAgZm9yIChsZXQgbiA9IHQ7IG4gJiYgKGUucHVzaChuLCBuLnNjcm9sbFRvcCwgbi5zY3JvbGxMZWZ0KSwgbiAhPSBuLm93bmVyRG9jdW1lbnQpOyBuID0gbi5wYXJlbnROb2RlKVxuICAgIDtcbiAgaWYgKHQuZm9jdXMob28gPT0gbnVsbCA/IHtcbiAgICBnZXQgcHJldmVudFNjcm9sbCgpIHtcbiAgICAgIHJldHVybiBvbyA9IHsgcHJldmVudFNjcm9sbDogITAgfSwgITA7XG4gICAgfVxuICB9IDogdm9pZCAwKSwgIW9vKSB7XG4gICAgb28gPSAhMTtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IGUubGVuZ3RoOyApIHtcbiAgICAgIGxldCByID0gZVtuKytdLCBpID0gZVtuKytdLCBzID0gZVtuKytdO1xuICAgICAgci5zY3JvbGxUb3AgIT0gaSAmJiAoci5zY3JvbGxUb3AgPSBpKSwgci5zY3JvbGxMZWZ0ICE9IHMgJiYgKHIuc2Nyb2xsTGVmdCA9IHMpO1xuICAgIH1cbiAgfVxufVxubGV0IFViO1xuZnVuY3Rpb24gWXModCwgZSwgbiA9IGUpIHtcbiAgbGV0IHIgPSBVYiB8fCAoVWIgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpKTtcbiAgcmV0dXJuIHIuc2V0RW5kKHQsIG4pLCByLnNldFN0YXJ0KHQsIGUpLCByO1xufVxuZnVuY3Rpb24gVG8odCwgZSwgbikge1xuICBsZXQgciA9IHsga2V5OiBlLCBjb2RlOiBlLCBrZXlDb2RlOiBuLCB3aGljaDogbiwgY2FuY2VsYWJsZTogITAgfSwgaSA9IG5ldyBLZXlib2FyZEV2ZW50KFwia2V5ZG93blwiLCByKTtcbiAgaS5zeW50aGV0aWMgPSAhMCwgdC5kaXNwYXRjaEV2ZW50KGkpO1xuICBsZXQgcyA9IG5ldyBLZXlib2FyZEV2ZW50KFwia2V5dXBcIiwgcik7XG4gIHJldHVybiBzLnN5bnRoZXRpYyA9ICEwLCB0LmRpc3BhdGNoRXZlbnQocyksIGkuZGVmYXVsdFByZXZlbnRlZCB8fCBzLmRlZmF1bHRQcmV2ZW50ZWQ7XG59XG5mdW5jdGlvbiBrTih0KSB7XG4gIGZvciAoOyB0OyApIHtcbiAgICBpZiAodCAmJiAodC5ub2RlVHlwZSA9PSA5IHx8IHQubm9kZVR5cGUgPT0gMTEgJiYgdC5ob3N0KSlcbiAgICAgIHJldHVybiB0O1xuICAgIHQgPSB0LmFzc2lnbmVkU2xvdCB8fCB0LnBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBlayh0KSB7XG4gIGZvciAoOyB0LmF0dHJpYnV0ZXMubGVuZ3RoOyApXG4gICAgdC5yZW1vdmVBdHRyaWJ1dGVOb2RlKHQuYXR0cmlidXRlc1swXSk7XG59XG5mdW5jdGlvbiB4Tih0LCBlKSB7XG4gIGxldCBuID0gZS5mb2N1c05vZGUsIHIgPSBlLmZvY3VzT2Zmc2V0O1xuICBpZiAoIW4gfHwgZS5hbmNob3JOb2RlICE9IG4gfHwgZS5hbmNob3JPZmZzZXQgIT0gcilcbiAgICByZXR1cm4gITE7XG4gIGZvciAociA9IE1hdGgubWluKHIsIGZpKG4pKTsgOyApXG4gICAgaWYgKHIpIHtcbiAgICAgIGlmIChuLm5vZGVUeXBlICE9IDEpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGxldCBpID0gbi5jaGlsZE5vZGVzW3IgLSAxXTtcbiAgICAgIGkuY29udGVudEVkaXRhYmxlID09IFwiZmFsc2VcIiA/IHItLSA6IChuID0gaSwgciA9IGZpKG4pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG4gPT0gdClcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgciA9IGdsKG4pLCBuID0gbi5wYXJlbnROb2RlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRrKHQpIHtcbiAgcmV0dXJuIHQuc2Nyb2xsVG9wID4gTWF0aC5tYXgoMSwgdC5zY3JvbGxIZWlnaHQgLSB0LmNsaWVudEhlaWdodCAtIDQpO1xufVxuY2xhc3MgYW4ge1xuICBjb25zdHJ1Y3RvcihlLCBuLCByID0gITApIHtcbiAgICB0aGlzLm5vZGUgPSBlLCB0aGlzLm9mZnNldCA9IG4sIHRoaXMucHJlY2lzZSA9IHI7XG4gIH1cbiAgc3RhdGljIGJlZm9yZShlLCBuKSB7XG4gICAgcmV0dXJuIG5ldyBhbihlLnBhcmVudE5vZGUsIGdsKGUpLCBuKTtcbiAgfVxuICBzdGF0aWMgYWZ0ZXIoZSwgbikge1xuICAgIHJldHVybiBuZXcgYW4oZS5wYXJlbnROb2RlLCBnbChlKSArIDEsIG4pO1xuICB9XG59XG5jb25zdCBvZyA9IFtdO1xuY2xhc3MgZnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnBhcmVudCA9IG51bGwsIHRoaXMuZG9tID0gbnVsbCwgdGhpcy5mbGFncyA9IDI7XG4gIH1cbiAgZ2V0IG92ZXJyaWRlRE9NVGV4dCgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnZXQgcG9zQXRTdGFydCgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5wb3NCZWZvcmUodGhpcykgOiAwO1xuICB9XG4gIGdldCBwb3NBdEVuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wb3NBdFN0YXJ0ICsgdGhpcy5sZW5ndGg7XG4gIH1cbiAgcG9zQmVmb3JlKGUpIHtcbiAgICBsZXQgbiA9IHRoaXMucG9zQXRTdGFydDtcbiAgICBmb3IgKGxldCByIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgIGlmIChyID09IGUpXG4gICAgICAgIHJldHVybiBuO1xuICAgICAgbiArPSByLmxlbmd0aCArIHIuYnJlYWtBZnRlcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGNoaWxkIGluIHBvc0JlZm9yZVwiKTtcbiAgfVxuICBwb3NBZnRlcihlKSB7XG4gICAgcmV0dXJuIHRoaXMucG9zQmVmb3JlKGUpICsgZS5sZW5ndGg7XG4gIH1cbiAgc3luYyhlLCBuKSB7XG4gICAgaWYgKHRoaXMuZmxhZ3MgJiAyKSB7XG4gICAgICBsZXQgciA9IHRoaXMuZG9tLCBpID0gbnVsbCwgcztcbiAgICAgIGZvciAobGV0IG8gb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgICBpZiAoby5mbGFncyAmIDcpIHtcbiAgICAgICAgICBpZiAoIW8uZG9tICYmIChzID0gaSA/IGkubmV4dFNpYmxpbmcgOiByLmZpcnN0Q2hpbGQpKSB7XG4gICAgICAgICAgICBsZXQgYSA9IGZ0LmdldChzKTtcbiAgICAgICAgICAgICghYSB8fCAhYS5wYXJlbnQgJiYgYS5jYW5SZXVzZURPTShvKSkgJiYgby5yZXVzZURPTShzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgby5zeW5jKGUsIG4pLCBvLmZsYWdzICY9IC04O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzID0gaSA/IGkubmV4dFNpYmxpbmcgOiByLmZpcnN0Q2hpbGQsIG4gJiYgIW4ud3JpdHRlbiAmJiBuLm5vZGUgPT0gciAmJiBzICE9IG8uZG9tICYmIChuLndyaXR0ZW4gPSAhMCksIG8uZG9tLnBhcmVudE5vZGUgPT0gcilcbiAgICAgICAgICBmb3IgKDsgcyAmJiBzICE9IG8uZG9tOyApXG4gICAgICAgICAgICBzID0gcWIocyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByLmluc2VydEJlZm9yZShvLmRvbSwgcyk7XG4gICAgICAgIGkgPSBvLmRvbTtcbiAgICAgIH1cbiAgICAgIGZvciAocyA9IGkgPyBpLm5leHRTaWJsaW5nIDogci5maXJzdENoaWxkLCBzICYmIG4gJiYgbi5ub2RlID09IHIgJiYgKG4ud3JpdHRlbiA9ICEwKTsgczsgKVxuICAgICAgICBzID0gcWIocyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmZsYWdzICYgMSlcbiAgICAgIGZvciAobGV0IHIgb2YgdGhpcy5jaGlsZHJlbilcbiAgICAgICAgci5mbGFncyAmIDcgJiYgKHIuc3luYyhlLCBuKSwgci5mbGFncyAmPSAtOCk7XG4gIH1cbiAgcmV1c2VET00oZSkge1xuICB9XG4gIGxvY2FsUG9zRnJvbURPTShlLCBuKSB7XG4gICAgbGV0IHI7XG4gICAgaWYgKGUgPT0gdGhpcy5kb20pXG4gICAgICByID0gdGhpcy5kb20uY2hpbGROb2Rlc1tuXTtcbiAgICBlbHNlIHtcbiAgICAgIGxldCBpID0gZmkoZSkgPT0gMCA/IDAgOiBuID09IDAgPyAtMSA6IDE7XG4gICAgICBmb3IgKDsgOyApIHtcbiAgICAgICAgbGV0IHMgPSBlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmIChzID09IHRoaXMuZG9tKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpID09IDAgJiYgcy5maXJzdENoaWxkICE9IHMubGFzdENoaWxkICYmIChlID09IHMuZmlyc3RDaGlsZCA/IGkgPSAtMSA6IGkgPSAxKSwgZSA9IHM7XG4gICAgICB9XG4gICAgICBpIDwgMCA/IHIgPSBlIDogciA9IGUubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIGlmIChyID09IHRoaXMuZG9tLmZpcnN0Q2hpbGQpXG4gICAgICByZXR1cm4gMDtcbiAgICBmb3IgKDsgciAmJiAhZnQuZ2V0KHIpOyApXG4gICAgICByID0gci5uZXh0U2libGluZztcbiAgICBpZiAoIXIpXG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDAsIHMgPSAwOyA7IGkrKykge1xuICAgICAgbGV0IG8gPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgaWYgKG8uZG9tID09IHIpXG4gICAgICAgIHJldHVybiBzO1xuICAgICAgcyArPSBvLmxlbmd0aCArIG8uYnJlYWtBZnRlcjtcbiAgICB9XG4gIH1cbiAgZG9tQm91bmRzQXJvdW5kKGUsIG4sIHIgPSAwKSB7XG4gICAgbGV0IGkgPSAtMSwgcyA9IC0xLCBvID0gLTEsIGEgPSAtMTtcbiAgICBmb3IgKGxldCBsID0gMCwgYyA9IHIsIHUgPSByOyBsIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGwrKykge1xuICAgICAgbGV0IGQgPSB0aGlzLmNoaWxkcmVuW2xdLCBmID0gYyArIGQubGVuZ3RoO1xuICAgICAgaWYgKGMgPCBlICYmIGYgPiBuKVxuICAgICAgICByZXR1cm4gZC5kb21Cb3VuZHNBcm91bmQoZSwgbiwgYyk7XG4gICAgICBpZiAoZiA+PSBlICYmIGkgPT0gLTEgJiYgKGkgPSBsLCBzID0gYyksIGMgPiBuICYmIGQuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5kb20pIHtcbiAgICAgICAgbyA9IGwsIGEgPSB1O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHUgPSBmLCBjID0gZiArIGQuYnJlYWtBZnRlcjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGZyb206IHMsXG4gICAgICB0bzogYSA8IDAgPyByICsgdGhpcy5sZW5ndGggOiBhLFxuICAgICAgc3RhcnRET006IChpID8gdGhpcy5jaGlsZHJlbltpIC0gMV0uZG9tLm5leHRTaWJsaW5nIDogbnVsbCkgfHwgdGhpcy5kb20uZmlyc3RDaGlsZCxcbiAgICAgIGVuZERPTTogbyA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoICYmIG8gPj0gMCA/IHRoaXMuY2hpbGRyZW5bb10uZG9tIDogbnVsbFxuICAgIH07XG4gIH1cbiAgbWFya0RpcnR5KGUgPSAhMSkge1xuICAgIHRoaXMuZmxhZ3MgfD0gMiwgdGhpcy5tYXJrUGFyZW50c0RpcnR5KGUpO1xuICB9XG4gIG1hcmtQYXJlbnRzRGlydHkoZSkge1xuICAgIGZvciAobGV0IG4gPSB0aGlzLnBhcmVudDsgbjsgbiA9IG4ucGFyZW50KSB7XG4gICAgICBpZiAoZSAmJiAobi5mbGFncyB8PSAyKSwgbi5mbGFncyAmIDEpXG4gICAgICAgIHJldHVybjtcbiAgICAgIG4uZmxhZ3MgfD0gMSwgZSA9ICExO1xuICAgIH1cbiAgfVxuICBzZXRQYXJlbnQoZSkge1xuICAgIHRoaXMucGFyZW50ICE9IGUgJiYgKHRoaXMucGFyZW50ID0gZSwgdGhpcy5mbGFncyAmIDcgJiYgdGhpcy5tYXJrUGFyZW50c0RpcnR5KCEwKSk7XG4gIH1cbiAgc2V0RE9NKGUpIHtcbiAgICB0aGlzLmRvbSAhPSBlICYmICh0aGlzLmRvbSAmJiAodGhpcy5kb20uY21WaWV3ID0gbnVsbCksIHRoaXMuZG9tID0gZSwgZS5jbVZpZXcgPSB0aGlzKTtcbiAgfVxuICBnZXQgcm9vdFZpZXcoKSB7XG4gICAgZm9yIChsZXQgZSA9IHRoaXM7IDsgKSB7XG4gICAgICBsZXQgbiA9IGUucGFyZW50O1xuICAgICAgaWYgKCFuKVxuICAgICAgICByZXR1cm4gZTtcbiAgICAgIGUgPSBuO1xuICAgIH1cbiAgfVxuICByZXBsYWNlQ2hpbGRyZW4oZSwgbiwgciA9IG9nKSB7XG4gICAgdGhpcy5tYXJrRGlydHkoKTtcbiAgICBmb3IgKGxldCBpID0gZTsgaSA8IG47IGkrKykge1xuICAgICAgbGV0IHMgPSB0aGlzLmNoaWxkcmVuW2ldO1xuICAgICAgcy5wYXJlbnQgPT0gdGhpcyAmJiByLmluZGV4T2YocykgPCAwICYmIHMuZGVzdHJveSgpO1xuICAgIH1cbiAgICB0aGlzLmNoaWxkcmVuLnNwbGljZShlLCBuIC0gZSwgLi4ucik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByLmxlbmd0aDsgaSsrKVxuICAgICAgcltpXS5zZXRQYXJlbnQodGhpcyk7XG4gIH1cbiAgaWdub3JlTXV0YXRpb24oZSkge1xuICAgIHJldHVybiAhMTtcbiAgfVxuICBpZ25vcmVFdmVudChlKSB7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIGNoaWxkQ3Vyc29yKGUgPSB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiBuZXcgbmsodGhpcy5jaGlsZHJlbiwgZSwgdGhpcy5jaGlsZHJlbi5sZW5ndGgpO1xuICB9XG4gIGNoaWxkUG9zKGUsIG4gPSAxKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRDdXJzb3IoKS5maW5kUG9zKGUsIG4pO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIGxldCBlID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lLnJlcGxhY2UoXCJWaWV3XCIsIFwiXCIpO1xuICAgIHJldHVybiBlICsgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID8gXCIoXCIgKyB0aGlzLmNoaWxkcmVuLmpvaW4oKSArIFwiKVwiIDogdGhpcy5sZW5ndGggPyBcIltcIiArIChlID09IFwiVGV4dFwiID8gdGhpcy50ZXh0IDogdGhpcy5sZW5ndGgpICsgXCJdXCIgOiBcIlwiKSArICh0aGlzLmJyZWFrQWZ0ZXIgPyBcIiNcIiA6IFwiXCIpO1xuICB9XG4gIHN0YXRpYyBnZXQoZSkge1xuICAgIHJldHVybiBlLmNtVmlldztcbiAgfVxuICBnZXQgaXNFZGl0YWJsZSgpIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgZ2V0IGlzV2lkZ2V0KCkge1xuICAgIHJldHVybiAhMTtcbiAgfVxuICBnZXQgaXNIaWRkZW4oKSB7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIG1lcmdlKGUsIG4sIHIsIGksIHMsIG8pIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbiAgYmVjb21lKGUpIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbiAgY2FuUmV1c2VET00oZSkge1xuICAgIHJldHVybiBlLmNvbnN0cnVjdG9yID09IHRoaXMuY29uc3RydWN0b3IgJiYgISgodGhpcy5mbGFncyB8IGUuZmxhZ3MpICYgOCk7XG4gIH1cbiAgLy8gV2hlbiB0aGlzIGlzIGEgemVyby1sZW5ndGggdmlldyB3aXRoIGEgc2lkZSwgdGhpcyBzaG91bGQgcmV0dXJuIGFcbiAgLy8gbnVtYmVyIDw9IDAgdG8gaW5kaWNhdGUgaXQgaXMgYmVmb3JlIGl0cyBwb3NpdGlvbiwgb3IgYVxuICAvLyBudW1iZXIgPiAwIHdoZW4gYWZ0ZXIgaXRzIHBvc2l0aW9uLlxuICBnZXRTaWRlKCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgZm9yIChsZXQgZSBvZiB0aGlzLmNoaWxkcmVuKVxuICAgICAgZS5wYXJlbnQgPT0gdGhpcyAmJiBlLmRlc3Ryb3koKTtcbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gIH1cbn1cbmZ0LnByb3RvdHlwZS5icmVha0FmdGVyID0gMDtcbmZ1bmN0aW9uIHFiKHQpIHtcbiAgbGV0IGUgPSB0Lm5leHRTaWJsaW5nO1xuICByZXR1cm4gdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHQpLCBlO1xufVxuY2xhc3Mgbmsge1xuICBjb25zdHJ1Y3RvcihlLCBuLCByKSB7XG4gICAgdGhpcy5jaGlsZHJlbiA9IGUsIHRoaXMucG9zID0gbiwgdGhpcy5pID0gciwgdGhpcy5vZmYgPSAwO1xuICB9XG4gIGZpbmRQb3MoZSwgbiA9IDEpIHtcbiAgICBmb3IgKDsgOyApIHtcbiAgICAgIGlmIChlID4gdGhpcy5wb3MgfHwgZSA9PSB0aGlzLnBvcyAmJiAobiA+IDAgfHwgdGhpcy5pID09IDAgfHwgdGhpcy5jaGlsZHJlblt0aGlzLmkgLSAxXS5icmVha0FmdGVyKSlcbiAgICAgICAgcmV0dXJuIHRoaXMub2ZmID0gZSAtIHRoaXMucG9zLCB0aGlzO1xuICAgICAgbGV0IHIgPSB0aGlzLmNoaWxkcmVuWy0tdGhpcy5pXTtcbiAgICAgIHRoaXMucG9zIC09IHIubGVuZ3RoICsgci5icmVha0FmdGVyO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmsodCwgZSwgbiwgciwgaSwgcywgbywgYSwgbCkge1xuICBsZXQgeyBjaGlsZHJlbjogYyB9ID0gdCwgdSA9IGMubGVuZ3RoID8gY1tlXSA6IG51bGwsIGQgPSBzLmxlbmd0aCA/IHNbcy5sZW5ndGggLSAxXSA6IG51bGwsIGYgPSBkID8gZC5icmVha0FmdGVyIDogbztcbiAgaWYgKCEoZSA9PSByICYmIHUgJiYgIW8gJiYgIWYgJiYgcy5sZW5ndGggPCAyICYmIHUubWVyZ2UobiwgaSwgcy5sZW5ndGggPyBkIDogbnVsbCwgbiA9PSAwLCBhLCBsKSkpIHtcbiAgICBpZiAociA8IGMubGVuZ3RoKSB7XG4gICAgICBsZXQgaCA9IGNbcl07XG4gICAgICBoICYmIChpIDwgaC5sZW5ndGggfHwgaC5icmVha0FmdGVyICYmIChkICE9IG51bGwgJiYgZC5icmVha0FmdGVyKSkgPyAoZSA9PSByICYmIChoID0gaC5zcGxpdChpKSwgaSA9IDApLCAhZiAmJiBkICYmIGgubWVyZ2UoMCwgaSwgZCwgITAsIDAsIGwpID8gc1tzLmxlbmd0aCAtIDFdID0gaCA6ICgoaSB8fCBoLmNoaWxkcmVuLmxlbmd0aCAmJiAhaC5jaGlsZHJlblswXS5sZW5ndGgpICYmIGgubWVyZ2UoMCwgaSwgbnVsbCwgITEsIDAsIGwpLCBzLnB1c2goaCkpKSA6IGggIT0gbnVsbCAmJiBoLmJyZWFrQWZ0ZXIgJiYgKGQgPyBkLmJyZWFrQWZ0ZXIgPSAxIDogbyA9IDEpLCByKys7XG4gICAgfVxuICAgIGZvciAodSAmJiAodS5icmVha0FmdGVyID0gbywgbiA+IDAgJiYgKCFvICYmIHMubGVuZ3RoICYmIHUubWVyZ2UobiwgdS5sZW5ndGgsIHNbMF0sICExLCBhLCAwKSA/IHUuYnJlYWtBZnRlciA9IHMuc2hpZnQoKS5icmVha0FmdGVyIDogKG4gPCB1Lmxlbmd0aCB8fCB1LmNoaWxkcmVuLmxlbmd0aCAmJiB1LmNoaWxkcmVuW3UuY2hpbGRyZW4ubGVuZ3RoIC0gMV0ubGVuZ3RoID09IDApICYmIHUubWVyZ2UobiwgdS5sZW5ndGgsIG51bGwsICExLCBhLCAwKSwgZSsrKSk7IGUgPCByICYmIHMubGVuZ3RoOyApXG4gICAgICBpZiAoY1tyIC0gMV0uYmVjb21lKHNbcy5sZW5ndGggLSAxXSkpXG4gICAgICAgIHItLSwgcy5wb3AoKSwgbCA9IHMubGVuZ3RoID8gMCA6IGE7XG4gICAgICBlbHNlIGlmIChjW2VdLmJlY29tZShzWzBdKSlcbiAgICAgICAgZSsrLCBzLnNoaWZ0KCksIGEgPSBzLmxlbmd0aCA/IDAgOiBsO1xuICAgICAgZWxzZVxuICAgICAgICBicmVhaztcbiAgICAhcy5sZW5ndGggJiYgZSAmJiByIDwgYy5sZW5ndGggJiYgIWNbZSAtIDFdLmJyZWFrQWZ0ZXIgJiYgY1tyXS5tZXJnZSgwLCAwLCBjW2UgLSAxXSwgITEsIGEsIGwpICYmIGUtLSwgKGUgPCByIHx8IHMubGVuZ3RoKSAmJiB0LnJlcGxhY2VDaGlsZHJlbihlLCByLCBzKTtcbiAgfVxufVxuZnVuY3Rpb24gaWsodCwgZSwgbiwgciwgaSwgcykge1xuICBsZXQgbyA9IHQuY2hpbGRDdXJzb3IoKSwgeyBpOiBhLCBvZmY6IGwgfSA9IG8uZmluZFBvcyhuLCAxKSwgeyBpOiBjLCBvZmY6IHUgfSA9IG8uZmluZFBvcyhlLCAtMSksIGQgPSBlIC0gbjtcbiAgZm9yIChsZXQgZiBvZiByKVxuICAgIGQgKz0gZi5sZW5ndGg7XG4gIHQubGVuZ3RoICs9IGQsIHJrKHQsIGMsIHUsIGEsIGwsIHIsIDAsIGksIHMpO1xufVxubGV0IFZuID0gdHlwZW9mIG5hdmlnYXRvciA8IFwidVwiID8gbmF2aWdhdG9yIDogeyB1c2VyQWdlbnQ6IFwiXCIsIHZlbmRvcjogXCJcIiwgcGxhdGZvcm06IFwiXCIgfSwgcnAgPSB0eXBlb2YgZG9jdW1lbnQgPCBcInVcIiA/IGRvY3VtZW50IDogeyBkb2N1bWVudEVsZW1lbnQ6IHsgc3R5bGU6IHt9IH0gfTtcbmNvbnN0IGlwID0gLyogQF9fUFVSRV9fICovIC9FZGdlXFwvKFxcZCspLy5leGVjKFZuLnVzZXJBZ2VudCksIHNrID0gLyogQF9fUFVSRV9fICovIC9NU0lFIFxcZC8udGVzdChWbi51c2VyQWdlbnQpLCBzcCA9IC8qIEBfX1BVUkVfXyAqLyAvVHJpZGVudFxcLyg/Ols3LTldfFxcZHsyLH0pXFwuLipydjooXFxkKykvLmV4ZWMoVm4udXNlckFnZW50KSwgcWQgPSAhIShzayB8fCBzcCB8fCBpcCksIFliID0gIXFkICYmIC8qIEBfX1BVUkVfXyAqLyAvZ2Vja29cXC8oXFxkKykvaS50ZXN0KFZuLnVzZXJBZ2VudCksIHhmID0gIXFkICYmIC8qIEBfX1BVUkVfXyAqLyAvQ2hyb21lXFwvKFxcZCspLy5leGVjKFZuLnVzZXJBZ2VudCksIHpiID0gXCJ3ZWJraXRGb250U21vb3RoaW5nXCIgaW4gcnAuZG9jdW1lbnRFbGVtZW50LnN0eWxlLCBvayA9ICFxZCAmJiAvKiBAX19QVVJFX18gKi8gL0FwcGxlIENvbXB1dGVyLy50ZXN0KFZuLnZlbmRvciksIEhiID0gb2sgJiYgKC8qIEBfX1BVUkVfXyAqLyAvTW9iaWxlXFwvXFx3Ky8udGVzdChWbi51c2VyQWdlbnQpIHx8IFZuLm1heFRvdWNoUG9pbnRzID4gMik7XG52YXIgZGUgPSB7XG4gIG1hYzogSGIgfHwgLyogQF9fUFVSRV9fICovIC9NYWMvLnRlc3QoVm4ucGxhdGZvcm0pLFxuICB3aW5kb3dzOiAvKiBAX19QVVJFX18gKi8gL1dpbi8udGVzdChWbi5wbGF0Zm9ybSksXG4gIGxpbnV4OiAvKiBAX19QVVJFX18gKi8gL0xpbnV4fFgxMS8udGVzdChWbi5wbGF0Zm9ybSksXG4gIGllOiBxZCxcbiAgaWVfdmVyc2lvbjogc2sgPyBycC5kb2N1bWVudE1vZGUgfHwgNiA6IHNwID8gK3NwWzFdIDogaXAgPyAraXBbMV0gOiAwLFxuICBnZWNrbzogWWIsXG4gIGdlY2tvX3ZlcnNpb246IFliID8gKygvKiBAX19QVVJFX18gKi8gL0ZpcmVmb3hcXC8oXFxkKykvLmV4ZWMoVm4udXNlckFnZW50KSB8fCBbMCwgMF0pWzFdIDogMCxcbiAgY2hyb21lOiAhIXhmLFxuICBjaHJvbWVfdmVyc2lvbjogeGYgPyAreGZbMV0gOiAwLFxuICBpb3M6IEhiLFxuICBhbmRyb2lkOiAvKiBAX19QVVJFX18gKi8gL0FuZHJvaWRcXGIvLnRlc3QoVm4udXNlckFnZW50KSxcbiAgd2Via2l0OiB6YixcbiAgc2FmYXJpOiBvayxcbiAgd2Via2l0X3ZlcnNpb246IHpiID8gKygvKiBAX19QVVJFX18gKi8gL1xcYkFwcGxlV2ViS2l0XFwvKFxcZCspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpIHx8IFswLCAwXSlbMV0gOiAwLFxuICB0YWJTaXplOiBycC5kb2N1bWVudEVsZW1lbnQuc3R5bGUudGFiU2l6ZSAhPSBudWxsID8gXCJ0YWItc2l6ZVwiIDogXCItbW96LXRhYi1zaXplXCJcbn07XG5jb25zdCBQTiA9IDI1NjtcbmNsYXNzIGhpIGV4dGVuZHMgZnQge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgc3VwZXIoKSwgdGhpcy50ZXh0ID0gZTtcbiAgfVxuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLnRleHQubGVuZ3RoO1xuICB9XG4gIGNyZWF0ZURPTShlKSB7XG4gICAgdGhpcy5zZXRET00oZSB8fCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLnRleHQpKTtcbiAgfVxuICBzeW5jKGUsIG4pIHtcbiAgICB0aGlzLmRvbSB8fCB0aGlzLmNyZWF0ZURPTSgpLCB0aGlzLmRvbS5ub2RlVmFsdWUgIT0gdGhpcy50ZXh0ICYmIChuICYmIG4ubm9kZSA9PSB0aGlzLmRvbSAmJiAobi53cml0dGVuID0gITApLCB0aGlzLmRvbS5ub2RlVmFsdWUgPSB0aGlzLnRleHQpO1xuICB9XG4gIHJldXNlRE9NKGUpIHtcbiAgICBlLm5vZGVUeXBlID09IDMgJiYgdGhpcy5jcmVhdGVET00oZSk7XG4gIH1cbiAgbWVyZ2UoZSwgbiwgcikge1xuICAgIHJldHVybiB0aGlzLmZsYWdzICYgOCB8fCByICYmICghKHIgaW5zdGFuY2VvZiBoaSkgfHwgdGhpcy5sZW5ndGggLSAobiAtIGUpICsgci5sZW5ndGggPiBQTiB8fCByLmZsYWdzICYgOCkgPyAhMSA6ICh0aGlzLnRleHQgPSB0aGlzLnRleHQuc2xpY2UoMCwgZSkgKyAociA/IHIudGV4dCA6IFwiXCIpICsgdGhpcy50ZXh0LnNsaWNlKG4pLCB0aGlzLm1hcmtEaXJ0eSgpLCAhMCk7XG4gIH1cbiAgc3BsaXQoZSkge1xuICAgIGxldCBuID0gbmV3IGhpKHRoaXMudGV4dC5zbGljZShlKSk7XG4gICAgcmV0dXJuIHRoaXMudGV4dCA9IHRoaXMudGV4dC5zbGljZSgwLCBlKSwgdGhpcy5tYXJrRGlydHkoKSwgbi5mbGFncyB8PSB0aGlzLmZsYWdzICYgOCwgbjtcbiAgfVxuICBsb2NhbFBvc0Zyb21ET00oZSwgbikge1xuICAgIHJldHVybiBlID09IHRoaXMuZG9tID8gbiA6IG4gPyB0aGlzLnRleHQubGVuZ3RoIDogMDtcbiAgfVxuICBkb21BdFBvcyhlKSB7XG4gICAgcmV0dXJuIG5ldyBhbih0aGlzLmRvbSwgZSk7XG4gIH1cbiAgZG9tQm91bmRzQXJvdW5kKGUsIG4sIHIpIHtcbiAgICByZXR1cm4geyBmcm9tOiByLCB0bzogciArIHRoaXMubGVuZ3RoLCBzdGFydERPTTogdGhpcy5kb20sIGVuZERPTTogdGhpcy5kb20ubmV4dFNpYmxpbmcgfTtcbiAgfVxuICBjb29yZHNBdChlLCBuKSB7XG4gICAgcmV0dXJuIF9OKHRoaXMuZG9tLCBlLCBuKTtcbiAgfVxufVxuY2xhc3MgcGkgZXh0ZW5kcyBmdCB7XG4gIGNvbnN0cnVjdG9yKGUsIG4gPSBbXSwgciA9IDApIHtcbiAgICBzdXBlcigpLCB0aGlzLm1hcmsgPSBlLCB0aGlzLmNoaWxkcmVuID0gbiwgdGhpcy5sZW5ndGggPSByO1xuICAgIGZvciAobGV0IGkgb2YgbilcbiAgICAgIGkuc2V0UGFyZW50KHRoaXMpO1xuICB9XG4gIHNldEF0dHJzKGUpIHtcbiAgICBpZiAoZWsoZSksIHRoaXMubWFyay5jbGFzcyAmJiAoZS5jbGFzc05hbWUgPSB0aGlzLm1hcmsuY2xhc3MpLCB0aGlzLm1hcmsuYXR0cnMpXG4gICAgICBmb3IgKGxldCBuIGluIHRoaXMubWFyay5hdHRycylcbiAgICAgICAgZS5zZXRBdHRyaWJ1dGUobiwgdGhpcy5tYXJrLmF0dHJzW25dKTtcbiAgICByZXR1cm4gZTtcbiAgfVxuICBjYW5SZXVzZURPTShlKSB7XG4gICAgcmV0dXJuIHN1cGVyLmNhblJldXNlRE9NKGUpICYmICEoKHRoaXMuZmxhZ3MgfCBlLmZsYWdzKSAmIDgpO1xuICB9XG4gIHJldXNlRE9NKGUpIHtcbiAgICBlLm5vZGVOYW1lID09IHRoaXMubWFyay50YWdOYW1lLnRvVXBwZXJDYXNlKCkgJiYgKHRoaXMuc2V0RE9NKGUpLCB0aGlzLmZsYWdzIHw9IDYpO1xuICB9XG4gIHN5bmMoZSwgbikge1xuICAgIHRoaXMuZG9tID8gdGhpcy5mbGFncyAmIDQgJiYgdGhpcy5zZXRBdHRycyh0aGlzLmRvbSkgOiB0aGlzLnNldERPTSh0aGlzLnNldEF0dHJzKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5tYXJrLnRhZ05hbWUpKSksIHN1cGVyLnN5bmMoZSwgbik7XG4gIH1cbiAgbWVyZ2UoZSwgbiwgciwgaSwgcywgbykge1xuICAgIHJldHVybiByICYmICghKHIgaW5zdGFuY2VvZiBwaSAmJiByLm1hcmsuZXEodGhpcy5tYXJrKSkgfHwgZSAmJiBzIDw9IDAgfHwgbiA8IHRoaXMubGVuZ3RoICYmIG8gPD0gMCkgPyAhMSA6IChpayh0aGlzLCBlLCBuLCByID8gci5jaGlsZHJlbi5zbGljZSgpIDogW10sIHMgLSAxLCBvIC0gMSksIHRoaXMubWFya0RpcnR5KCksICEwKTtcbiAgfVxuICBzcGxpdChlKSB7XG4gICAgbGV0IG4gPSBbXSwgciA9IDAsIGkgPSAtMSwgcyA9IDA7XG4gICAgZm9yIChsZXQgYSBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICBsZXQgbCA9IHIgKyBhLmxlbmd0aDtcbiAgICAgIGwgPiBlICYmIG4ucHVzaChyIDwgZSA/IGEuc3BsaXQoZSAtIHIpIDogYSksIGkgPCAwICYmIHIgPj0gZSAmJiAoaSA9IHMpLCByID0gbCwgcysrO1xuICAgIH1cbiAgICBsZXQgbyA9IHRoaXMubGVuZ3RoIC0gZTtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGggPSBlLCBpID4gLTEgJiYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID0gaSwgdGhpcy5tYXJrRGlydHkoKSksIG5ldyBwaSh0aGlzLm1hcmssIG4sIG8pO1xuICB9XG4gIGRvbUF0UG9zKGUpIHtcbiAgICByZXR1cm4gYWsodGhpcywgZSk7XG4gIH1cbiAgY29vcmRzQXQoZSwgbikge1xuICAgIHJldHVybiBjayh0aGlzLCBlLCBuKTtcbiAgfVxufVxuZnVuY3Rpb24gX04odCwgZSwgbikge1xuICBsZXQgciA9IHQubm9kZVZhbHVlLmxlbmd0aDtcbiAgZSA+IHIgJiYgKGUgPSByKTtcbiAgbGV0IGkgPSBlLCBzID0gZSwgbyA9IDA7XG4gIGUgPT0gMCAmJiBuIDwgMCB8fCBlID09IHIgJiYgbiA+PSAwID8gZGUuY2hyb21lIHx8IGRlLmdlY2tvIHx8IChlID8gKGktLSwgbyA9IDEpIDogcyA8IHIgJiYgKHMrKywgbyA9IC0xKSkgOiBuIDwgMCA/IGktLSA6IHMgPCByICYmIHMrKztcbiAgbGV0IGEgPSBZcyh0LCBpLCBzKS5nZXRDbGllbnRSZWN0cygpO1xuICBpZiAoIWEubGVuZ3RoKVxuICAgIHJldHVybiBudWxsO1xuICBsZXQgbCA9IGFbKG8gPyBvIDwgMCA6IG4gPj0gMCkgPyAwIDogYS5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIGRlLnNhZmFyaSAmJiAhbyAmJiBsLndpZHRoID09IDAgJiYgKGwgPSBBcnJheS5wcm90b3R5cGUuZmluZC5jYWxsKGEsIChjKSA9PiBjLndpZHRoKSB8fCBsKSwgbyA/IHNnKGwsIG8gPCAwKSA6IGwgfHwgbnVsbDtcbn1cbmNsYXNzIFBzIGV4dGVuZHMgZnQge1xuICBzdGF0aWMgY3JlYXRlKGUsIG4sIHIpIHtcbiAgICByZXR1cm4gbmV3IFBzKGUsIG4sIHIpO1xuICB9XG4gIGNvbnN0cnVjdG9yKGUsIG4sIHIpIHtcbiAgICBzdXBlcigpLCB0aGlzLndpZGdldCA9IGUsIHRoaXMubGVuZ3RoID0gbiwgdGhpcy5zaWRlID0gciwgdGhpcy5wcmV2V2lkZ2V0ID0gbnVsbDtcbiAgfVxuICBzcGxpdChlKSB7XG4gICAgbGV0IG4gPSBQcy5jcmVhdGUodGhpcy53aWRnZXQsIHRoaXMubGVuZ3RoIC0gZSwgdGhpcy5zaWRlKTtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGggLT0gZSwgbjtcbiAgfVxuICBzeW5jKGUpIHtcbiAgICAoIXRoaXMuZG9tIHx8ICF0aGlzLndpZGdldC51cGRhdGVET00odGhpcy5kb20sIGUpKSAmJiAodGhpcy5kb20gJiYgdGhpcy5wcmV2V2lkZ2V0ICYmIHRoaXMucHJldldpZGdldC5kZXN0cm95KHRoaXMuZG9tKSwgdGhpcy5wcmV2V2lkZ2V0ID0gbnVsbCwgdGhpcy5zZXRET00odGhpcy53aWRnZXQudG9ET00oZSkpLCB0aGlzLndpZGdldC5lZGl0YWJsZSB8fCAodGhpcy5kb20uY29udGVudEVkaXRhYmxlID0gXCJmYWxzZVwiKSk7XG4gIH1cbiAgZ2V0U2lkZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zaWRlO1xuICB9XG4gIG1lcmdlKGUsIG4sIHIsIGksIHMsIG8pIHtcbiAgICByZXR1cm4gciAmJiAoIShyIGluc3RhbmNlb2YgUHMpIHx8ICF0aGlzLndpZGdldC5jb21wYXJlKHIud2lkZ2V0KSB8fCBlID4gMCAmJiBzIDw9IDAgfHwgbiA8IHRoaXMubGVuZ3RoICYmIG8gPD0gMCkgPyAhMSA6ICh0aGlzLmxlbmd0aCA9IGUgKyAociA/IHIubGVuZ3RoIDogMCkgKyAodGhpcy5sZW5ndGggLSBuKSwgITApO1xuICB9XG4gIGJlY29tZShlKSB7XG4gICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBQcyAmJiBlLnNpZGUgPT0gdGhpcy5zaWRlICYmIHRoaXMud2lkZ2V0LmNvbnN0cnVjdG9yID09IGUud2lkZ2V0LmNvbnN0cnVjdG9yID8gKHRoaXMud2lkZ2V0LmNvbXBhcmUoZS53aWRnZXQpIHx8IHRoaXMubWFya0RpcnR5KCEwKSwgdGhpcy5kb20gJiYgIXRoaXMucHJldldpZGdldCAmJiAodGhpcy5wcmV2V2lkZ2V0ID0gdGhpcy53aWRnZXQpLCB0aGlzLndpZGdldCA9IGUud2lkZ2V0LCB0aGlzLmxlbmd0aCA9IGUubGVuZ3RoLCAhMCkgOiAhMTtcbiAgfVxuICBpZ25vcmVNdXRhdGlvbigpIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgaWdub3JlRXZlbnQoZSkge1xuICAgIHJldHVybiB0aGlzLndpZGdldC5pZ25vcmVFdmVudChlKTtcbiAgfVxuICBnZXQgb3ZlcnJpZGVET01UZXh0KCkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PSAwKVxuICAgICAgcmV0dXJuIEZlLmVtcHR5O1xuICAgIGxldCBlID0gdGhpcztcbiAgICBmb3IgKDsgZS5wYXJlbnQ7IClcbiAgICAgIGUgPSBlLnBhcmVudDtcbiAgICBsZXQgeyB2aWV3OiBuIH0gPSBlLCByID0gbiAmJiBuLnN0YXRlLmRvYywgaSA9IHRoaXMucG9zQXRTdGFydDtcbiAgICByZXR1cm4gciA/IHIuc2xpY2UoaSwgaSArIHRoaXMubGVuZ3RoKSA6IEZlLmVtcHR5O1xuICB9XG4gIGRvbUF0UG9zKGUpIHtcbiAgICByZXR1cm4gKHRoaXMubGVuZ3RoID8gZSA9PSAwIDogdGhpcy5zaWRlID4gMCkgPyBhbi5iZWZvcmUodGhpcy5kb20pIDogYW4uYWZ0ZXIodGhpcy5kb20sIGUgPT0gdGhpcy5sZW5ndGgpO1xuICB9XG4gIGRvbUJvdW5kc0Fyb3VuZCgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb29yZHNBdChlLCBuKSB7XG4gICAgbGV0IHIgPSB0aGlzLndpZGdldC5jb29yZHNBdCh0aGlzLmRvbSwgZSwgbik7XG4gICAgaWYgKHIpXG4gICAgICByZXR1cm4gcjtcbiAgICBsZXQgaSA9IHRoaXMuZG9tLmdldENsaWVudFJlY3RzKCksIHMgPSBudWxsO1xuICAgIGlmICghaS5sZW5ndGgpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgbyA9IHRoaXMuc2lkZSA/IHRoaXMuc2lkZSA8IDAgOiBlID4gMDtcbiAgICBmb3IgKGxldCBhID0gbyA/IGkubGVuZ3RoIC0gMSA6IDA7IHMgPSBpW2FdLCAhKGUgPiAwID8gYSA9PSAwIDogYSA9PSBpLmxlbmd0aCAtIDEgfHwgcy50b3AgPCBzLmJvdHRvbSk7IGEgKz0gbyA/IC0xIDogMSlcbiAgICAgIDtcbiAgICByZXR1cm4gc2cocywgIW8pO1xuICB9XG4gIGdldCBpc0VkaXRhYmxlKCkge1xuICAgIHJldHVybiAhMTtcbiAgfVxuICBnZXQgaXNXaWRnZXQoKSB7XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIGdldCBpc0hpZGRlbigpIHtcbiAgICByZXR1cm4gdGhpcy53aWRnZXQuaXNIaWRkZW47XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBzdXBlci5kZXN0cm95KCksIHRoaXMuZG9tICYmIHRoaXMud2lkZ2V0LmRlc3Ryb3kodGhpcy5kb20pO1xuICB9XG59XG5jbGFzcyBCbyBleHRlbmRzIGZ0IHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKCksIHRoaXMuc2lkZSA9IGU7XG4gIH1cbiAgZ2V0IGxlbmd0aCgpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBtZXJnZSgpIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbiAgYmVjb21lKGUpIHtcbiAgICByZXR1cm4gZSBpbnN0YW5jZW9mIEJvICYmIGUuc2lkZSA9PSB0aGlzLnNpZGU7XG4gIH1cbiAgc3BsaXQoKSB7XG4gICAgcmV0dXJuIG5ldyBCbyh0aGlzLnNpZGUpO1xuICB9XG4gIHN5bmMoKSB7XG4gICAgaWYgKCF0aGlzLmRvbSkge1xuICAgICAgbGV0IGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgZS5jbGFzc05hbWUgPSBcImNtLXdpZGdldEJ1ZmZlclwiLCBlLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKSwgdGhpcy5zZXRET00oZSk7XG4gICAgfVxuICB9XG4gIGdldFNpZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2lkZTtcbiAgfVxuICBkb21BdFBvcyhlKSB7XG4gICAgcmV0dXJuIHRoaXMuc2lkZSA+IDAgPyBhbi5iZWZvcmUodGhpcy5kb20pIDogYW4uYWZ0ZXIodGhpcy5kb20pO1xuICB9XG4gIGxvY2FsUG9zRnJvbURPTSgpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBkb21Cb3VuZHNBcm91bmQoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29vcmRzQXQoZSkge1xuICAgIHJldHVybiB0aGlzLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfVxuICBnZXQgb3ZlcnJpZGVET01UZXh0KCkge1xuICAgIHJldHVybiBGZS5lbXB0eTtcbiAgfVxuICBnZXQgaXNIaWRkZW4oKSB7XG4gICAgcmV0dXJuICEwO1xuICB9XG59XG5oaS5wcm90b3R5cGUuY2hpbGRyZW4gPSBQcy5wcm90b3R5cGUuY2hpbGRyZW4gPSBCby5wcm90b3R5cGUuY2hpbGRyZW4gPSBvZztcbmZ1bmN0aW9uIGFrKHQsIGUpIHtcbiAgbGV0IG4gPSB0LmRvbSwgeyBjaGlsZHJlbjogciB9ID0gdCwgaSA9IDA7XG4gIGZvciAobGV0IHMgPSAwOyBpIDwgci5sZW5ndGg7IGkrKykge1xuICAgIGxldCBvID0gcltpXSwgYSA9IHMgKyBvLmxlbmd0aDtcbiAgICBpZiAoIShhID09IHMgJiYgby5nZXRTaWRlKCkgPD0gMCkpIHtcbiAgICAgIGlmIChlID4gcyAmJiBlIDwgYSAmJiBvLmRvbS5wYXJlbnROb2RlID09IG4pXG4gICAgICAgIHJldHVybiBvLmRvbUF0UG9zKGUgLSBzKTtcbiAgICAgIGlmIChlIDw9IHMpXG4gICAgICAgIGJyZWFrO1xuICAgICAgcyA9IGE7XG4gICAgfVxuICB9XG4gIGZvciAobGV0IHMgPSBpOyBzID4gMDsgcy0tKSB7XG4gICAgbGV0IG8gPSByW3MgLSAxXTtcbiAgICBpZiAoby5kb20ucGFyZW50Tm9kZSA9PSBuKVxuICAgICAgcmV0dXJuIG8uZG9tQXRQb3Moby5sZW5ndGgpO1xuICB9XG4gIGZvciAobGV0IHMgPSBpOyBzIDwgci5sZW5ndGg7IHMrKykge1xuICAgIGxldCBvID0gcltzXTtcbiAgICBpZiAoby5kb20ucGFyZW50Tm9kZSA9PSBuKVxuICAgICAgcmV0dXJuIG8uZG9tQXRQb3MoMCk7XG4gIH1cbiAgcmV0dXJuIG5ldyBhbihuLCAwKTtcbn1cbmZ1bmN0aW9uIGxrKHQsIGUsIG4pIHtcbiAgbGV0IHIsIHsgY2hpbGRyZW46IGkgfSA9IHQ7XG4gIG4gPiAwICYmIGUgaW5zdGFuY2VvZiBwaSAmJiBpLmxlbmd0aCAmJiAociA9IGlbaS5sZW5ndGggLSAxXSkgaW5zdGFuY2VvZiBwaSAmJiByLm1hcmsuZXEoZS5tYXJrKSA/IGxrKHIsIGUuY2hpbGRyZW5bMF0sIG4gLSAxKSA6IChpLnB1c2goZSksIGUuc2V0UGFyZW50KHQpKSwgdC5sZW5ndGggKz0gZS5sZW5ndGg7XG59XG5mdW5jdGlvbiBjayh0LCBlLCBuKSB7XG4gIGxldCByID0gbnVsbCwgaSA9IC0xLCBzID0gbnVsbCwgbyA9IC0xO1xuICBmdW5jdGlvbiBhKGMsIHUpIHtcbiAgICBmb3IgKGxldCBkID0gMCwgZiA9IDA7IGQgPCBjLmNoaWxkcmVuLmxlbmd0aCAmJiBmIDw9IHU7IGQrKykge1xuICAgICAgbGV0IGggPSBjLmNoaWxkcmVuW2RdLCBwID0gZiArIGgubGVuZ3RoO1xuICAgICAgcCA+PSB1ICYmIChoLmNoaWxkcmVuLmxlbmd0aCA/IGEoaCwgdSAtIGYpIDogKCFzIHx8IHMuaXNIaWRkZW4gJiYgbiA+IDApICYmIChwID4gdSB8fCBmID09IHAgJiYgaC5nZXRTaWRlKCkgPiAwKSA/IChzID0gaCwgbyA9IHUgLSBmKSA6IChmIDwgdSB8fCBmID09IHAgJiYgaC5nZXRTaWRlKCkgPCAwICYmICFoLmlzSGlkZGVuKSAmJiAociA9IGgsIGkgPSB1IC0gZikpLCBmID0gcDtcbiAgICB9XG4gIH1cbiAgYSh0LCBlKTtcbiAgbGV0IGwgPSAobiA8IDAgPyByIDogcykgfHwgciB8fCBzO1xuICByZXR1cm4gbCA/IGwuY29vcmRzQXQoTWF0aC5tYXgoMCwgbCA9PSByID8gaSA6IG8pLCBuKSA6IFROKHQpO1xufVxuZnVuY3Rpb24gVE4odCkge1xuICBsZXQgZSA9IHQuZG9tLmxhc3RDaGlsZDtcbiAgaWYgKCFlKVxuICAgIHJldHVybiB0LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgbGV0IG4gPSBPbChlKTtcbiAgcmV0dXJuIG5bbi5sZW5ndGggLSAxXSB8fCBudWxsO1xufVxuZnVuY3Rpb24gb3AodCwgZSkge1xuICBmb3IgKGxldCBuIGluIHQpXG4gICAgbiA9PSBcImNsYXNzXCIgJiYgZS5jbGFzcyA/IGUuY2xhc3MgKz0gXCIgXCIgKyB0LmNsYXNzIDogbiA9PSBcInN0eWxlXCIgJiYgZS5zdHlsZSA/IGUuc3R5bGUgKz0gXCI7XCIgKyB0LnN0eWxlIDogZVtuXSA9IHRbbl07XG4gIHJldHVybiBlO1xufVxuY29uc3QgRmIgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGFnKHQsIGUsIG4pIHtcbiAgaWYgKHQgPT0gZSlcbiAgICByZXR1cm4gITA7XG4gIHQgfHwgKHQgPSBGYiksIGUgfHwgKGUgPSBGYik7XG4gIGxldCByID0gT2JqZWN0LmtleXModCksIGkgPSBPYmplY3Qua2V5cyhlKTtcbiAgaWYgKHIubGVuZ3RoIC0gKG4gJiYgci5pbmRleE9mKG4pID4gLTEgPyAxIDogMCkgIT0gaS5sZW5ndGggLSAobiAmJiBpLmluZGV4T2YobikgPiAtMSA/IDEgOiAwKSlcbiAgICByZXR1cm4gITE7XG4gIGZvciAobGV0IHMgb2YgcilcbiAgICBpZiAocyAhPSBuICYmIChpLmluZGV4T2YocykgPT0gLTEgfHwgdFtzXSAhPT0gZVtzXSkpXG4gICAgICByZXR1cm4gITE7XG4gIHJldHVybiAhMDtcbn1cbmZ1bmN0aW9uIGFwKHQsIGUsIG4pIHtcbiAgbGV0IHIgPSAhMTtcbiAgaWYgKGUpXG4gICAgZm9yIChsZXQgaSBpbiBlKVxuICAgICAgbiAmJiBpIGluIG4gfHwgKHIgPSAhMCwgaSA9PSBcInN0eWxlXCIgPyB0LnN0eWxlLmNzc1RleHQgPSBcIlwiIDogdC5yZW1vdmVBdHRyaWJ1dGUoaSkpO1xuICBpZiAobilcbiAgICBmb3IgKGxldCBpIGluIG4pXG4gICAgICBlICYmIGVbaV0gPT0gbltpXSB8fCAociA9ICEwLCBpID09IFwic3R5bGVcIiA/IHQuc3R5bGUuY3NzVGV4dCA9IG5baV0gOiB0LnNldEF0dHJpYnV0ZShpLCBuW2ldKSk7XG4gIHJldHVybiByO1xufVxuZnVuY3Rpb24gRU4odCkge1xuICBsZXQgZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmb3IgKGxldCBuID0gMDsgbiA8IHQuYXR0cmlidXRlcy5sZW5ndGg7IG4rKykge1xuICAgIGxldCByID0gdC5hdHRyaWJ1dGVzW25dO1xuICAgIGVbci5uYW1lXSA9IHIudmFsdWU7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5jbGFzcyBOdCBleHRlbmRzIGZ0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5jaGlsZHJlbiA9IFtdLCB0aGlzLmxlbmd0aCA9IDAsIHRoaXMucHJldkF0dHJzID0gdm9pZCAwLCB0aGlzLmF0dHJzID0gbnVsbCwgdGhpcy5icmVha0FmdGVyID0gMDtcbiAgfVxuICAvLyBDb25zdW1lcyBzb3VyY2VcbiAgbWVyZ2UoZSwgbiwgciwgaSwgcywgbykge1xuICAgIGlmIChyKSB7XG4gICAgICBpZiAoIShyIGluc3RhbmNlb2YgTnQpKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICB0aGlzLmRvbSB8fCByLnRyYW5zZmVyRE9NKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gaSAmJiB0aGlzLnNldERlY28ociA/IHIuYXR0cnMgOiBudWxsKSwgaWsodGhpcywgZSwgbiwgciA/IHIuY2hpbGRyZW4uc2xpY2UoKSA6IFtdLCBzLCBvKSwgITA7XG4gIH1cbiAgc3BsaXQoZSkge1xuICAgIGxldCBuID0gbmV3IE50KCk7XG4gICAgaWYgKG4uYnJlYWtBZnRlciA9IHRoaXMuYnJlYWtBZnRlciwgdGhpcy5sZW5ndGggPT0gMClcbiAgICAgIHJldHVybiBuO1xuICAgIGxldCB7IGk6IHIsIG9mZjogaSB9ID0gdGhpcy5jaGlsZFBvcyhlKTtcbiAgICBpICYmIChuLmFwcGVuZCh0aGlzLmNoaWxkcmVuW3JdLnNwbGl0KGkpLCAwKSwgdGhpcy5jaGlsZHJlbltyXS5tZXJnZShpLCB0aGlzLmNoaWxkcmVuW3JdLmxlbmd0aCwgbnVsbCwgITEsIDAsIDApLCByKyspO1xuICAgIGZvciAobGV0IHMgPSByOyBzIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IHMrKylcbiAgICAgIG4uYXBwZW5kKHRoaXMuY2hpbGRyZW5bc10sIDApO1xuICAgIGZvciAoOyByID4gMCAmJiB0aGlzLmNoaWxkcmVuW3IgLSAxXS5sZW5ndGggPT0gMDsgKVxuICAgICAgdGhpcy5jaGlsZHJlblstLXJdLmRlc3Ryb3koKTtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5sZW5ndGggPSByLCB0aGlzLm1hcmtEaXJ0eSgpLCB0aGlzLmxlbmd0aCA9IGUsIG47XG4gIH1cbiAgdHJhbnNmZXJET00oZSkge1xuICAgIHRoaXMuZG9tICYmICh0aGlzLm1hcmtEaXJ0eSgpLCBlLnNldERPTSh0aGlzLmRvbSksIGUucHJldkF0dHJzID0gdGhpcy5wcmV2QXR0cnMgPT09IHZvaWQgMCA/IHRoaXMuYXR0cnMgOiB0aGlzLnByZXZBdHRycywgdGhpcy5wcmV2QXR0cnMgPSB2b2lkIDAsIHRoaXMuZG9tID0gbnVsbCk7XG4gIH1cbiAgc2V0RGVjbyhlKSB7XG4gICAgYWcodGhpcy5hdHRycywgZSkgfHwgKHRoaXMuZG9tICYmICh0aGlzLnByZXZBdHRycyA9IHRoaXMuYXR0cnMsIHRoaXMubWFya0RpcnR5KCkpLCB0aGlzLmF0dHJzID0gZSk7XG4gIH1cbiAgYXBwZW5kKGUsIG4pIHtcbiAgICBsayh0aGlzLCBlLCBuKTtcbiAgfVxuICAvLyBPbmx5IGNhbGxlZCB3aGVuIGJ1aWxkaW5nIGEgbGluZSB2aWV3IGluIENvbnRlbnRCdWlsZGVyXG4gIGFkZExpbmVEZWNvKGUpIHtcbiAgICBsZXQgbiA9IGUuc3BlYy5hdHRyaWJ1dGVzLCByID0gZS5zcGVjLmNsYXNzO1xuICAgIG4gJiYgKHRoaXMuYXR0cnMgPSBvcChuLCB0aGlzLmF0dHJzIHx8IHt9KSksIHIgJiYgKHRoaXMuYXR0cnMgPSBvcCh7IGNsYXNzOiByIH0sIHRoaXMuYXR0cnMgfHwge30pKTtcbiAgfVxuICBkb21BdFBvcyhlKSB7XG4gICAgcmV0dXJuIGFrKHRoaXMsIGUpO1xuICB9XG4gIHJldXNlRE9NKGUpIHtcbiAgICBlLm5vZGVOYW1lID09IFwiRElWXCIgJiYgKHRoaXMuc2V0RE9NKGUpLCB0aGlzLmZsYWdzIHw9IDYpO1xuICB9XG4gIHN5bmMoZSwgbikge1xuICAgIHZhciByO1xuICAgIHRoaXMuZG9tID8gdGhpcy5mbGFncyAmIDQgJiYgKGVrKHRoaXMuZG9tKSwgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS1saW5lXCIsIHRoaXMucHJldkF0dHJzID0gdGhpcy5hdHRycyA/IG51bGwgOiB2b2lkIDApIDogKHRoaXMuc2V0RE9NKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpLCB0aGlzLmRvbS5jbGFzc05hbWUgPSBcImNtLWxpbmVcIiwgdGhpcy5wcmV2QXR0cnMgPSB0aGlzLmF0dHJzID8gbnVsbCA6IHZvaWQgMCksIHRoaXMucHJldkF0dHJzICE9PSB2b2lkIDAgJiYgKGFwKHRoaXMuZG9tLCB0aGlzLnByZXZBdHRycywgdGhpcy5hdHRycyksIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQoXCJjbS1saW5lXCIpLCB0aGlzLnByZXZBdHRycyA9IHZvaWQgMCksIHN1cGVyLnN5bmMoZSwgbik7XG4gICAgbGV0IGkgPSB0aGlzLmRvbS5sYXN0Q2hpbGQ7XG4gICAgZm9yICg7IGkgJiYgZnQuZ2V0KGkpIGluc3RhbmNlb2YgcGk7IClcbiAgICAgIGkgPSBpLmxhc3RDaGlsZDtcbiAgICBpZiAoIWkgfHwgIXRoaXMubGVuZ3RoIHx8IGkubm9kZU5hbWUgIT0gXCJCUlwiICYmICgociA9IGZ0LmdldChpKSkgPT09IG51bGwgfHwgciA9PT0gdm9pZCAwID8gdm9pZCAwIDogci5pc0VkaXRhYmxlKSA9PSAhMSAmJiAoIWRlLmlvcyB8fCAhdGhpcy5jaGlsZHJlbi5zb21lKChzKSA9PiBzIGluc3RhbmNlb2YgaGkpKSkge1xuICAgICAgbGV0IHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiQlJcIik7XG4gICAgICBzLmNtSWdub3JlID0gITAsIHRoaXMuZG9tLmFwcGVuZENoaWxkKHMpO1xuICAgIH1cbiAgfVxuICBtZWFzdXJlVGV4dFNpemUoKSB7XG4gICAgaWYgKHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09IDAgfHwgdGhpcy5sZW5ndGggPiAyMClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBlID0gMCwgbjtcbiAgICBmb3IgKGxldCByIG9mIHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgIGlmICghKHIgaW5zdGFuY2VvZiBoaSkgfHwgL1teIC1+XS8udGVzdChyLnRleHQpKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGxldCBpID0gT2woci5kb20pO1xuICAgICAgaWYgKGkubGVuZ3RoICE9IDEpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgZSArPSBpWzBdLndpZHRoLCBuID0gaVswXS5oZWlnaHQ7XG4gICAgfVxuICAgIHJldHVybiBlID8ge1xuICAgICAgbGluZUhlaWdodDogdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0LFxuICAgICAgY2hhcldpZHRoOiBlIC8gdGhpcy5sZW5ndGgsXG4gICAgICB0ZXh0SGVpZ2h0OiBuXG4gICAgfSA6IG51bGw7XG4gIH1cbiAgY29vcmRzQXQoZSwgbikge1xuICAgIGxldCByID0gY2sodGhpcywgZSwgbik7XG4gICAgaWYgKCF0aGlzLmNoaWxkcmVuLmxlbmd0aCAmJiByICYmIHRoaXMucGFyZW50KSB7XG4gICAgICBsZXQgeyBoZWlnaHRPcmFjbGU6IGkgfSA9IHRoaXMucGFyZW50LnZpZXcudmlld1N0YXRlLCBzID0gci5ib3R0b20gLSByLnRvcDtcbiAgICAgIGlmIChNYXRoLmFicyhzIC0gaS5saW5lSGVpZ2h0KSA8IDIgJiYgaS50ZXh0SGVpZ2h0IDwgcykge1xuICAgICAgICBsZXQgbyA9IChzIC0gaS50ZXh0SGVpZ2h0KSAvIDI7XG4gICAgICAgIHJldHVybiB7IHRvcDogci50b3AgKyBvLCBib3R0b206IHIuYm90dG9tIC0gbywgbGVmdDogci5sZWZ0LCByaWdodDogci5sZWZ0IH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIGJlY29tZShlKSB7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIGNvdmVycygpIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgc3RhdGljIGZpbmQoZSwgbikge1xuICAgIGZvciAobGV0IHIgPSAwLCBpID0gMDsgciA8IGUuY2hpbGRyZW4ubGVuZ3RoOyByKyspIHtcbiAgICAgIGxldCBzID0gZS5jaGlsZHJlbltyXSwgbyA9IGkgKyBzLmxlbmd0aDtcbiAgICAgIGlmIChvID49IG4pIHtcbiAgICAgICAgaWYgKHMgaW5zdGFuY2VvZiBOdClcbiAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgaWYgKG8gPiBuKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaSA9IG8gKyBzLmJyZWFrQWZ0ZXI7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5jbGFzcyBLaSBleHRlbmRzIGZ0IHtcbiAgY29uc3RydWN0b3IoZSwgbiwgcikge1xuICAgIHN1cGVyKCksIHRoaXMud2lkZ2V0ID0gZSwgdGhpcy5sZW5ndGggPSBuLCB0aGlzLmRlY28gPSByLCB0aGlzLmJyZWFrQWZ0ZXIgPSAwLCB0aGlzLnByZXZXaWRnZXQgPSBudWxsO1xuICB9XG4gIG1lcmdlKGUsIG4sIHIsIGksIHMsIG8pIHtcbiAgICByZXR1cm4gciAmJiAoIShyIGluc3RhbmNlb2YgS2kpIHx8ICF0aGlzLndpZGdldC5jb21wYXJlKHIud2lkZ2V0KSB8fCBlID4gMCAmJiBzIDw9IDAgfHwgbiA8IHRoaXMubGVuZ3RoICYmIG8gPD0gMCkgPyAhMSA6ICh0aGlzLmxlbmd0aCA9IGUgKyAociA/IHIubGVuZ3RoIDogMCkgKyAodGhpcy5sZW5ndGggLSBuKSwgITApO1xuICB9XG4gIGRvbUF0UG9zKGUpIHtcbiAgICByZXR1cm4gZSA9PSAwID8gYW4uYmVmb3JlKHRoaXMuZG9tKSA6IGFuLmFmdGVyKHRoaXMuZG9tLCBlID09IHRoaXMubGVuZ3RoKTtcbiAgfVxuICBzcGxpdChlKSB7XG4gICAgbGV0IG4gPSB0aGlzLmxlbmd0aCAtIGU7XG4gICAgdGhpcy5sZW5ndGggPSBlO1xuICAgIGxldCByID0gbmV3IEtpKHRoaXMud2lkZ2V0LCBuLCB0aGlzLmRlY28pO1xuICAgIHJldHVybiByLmJyZWFrQWZ0ZXIgPSB0aGlzLmJyZWFrQWZ0ZXIsIHI7XG4gIH1cbiAgZ2V0IGNoaWxkcmVuKCkge1xuICAgIHJldHVybiBvZztcbiAgfVxuICBzeW5jKGUpIHtcbiAgICAoIXRoaXMuZG9tIHx8ICF0aGlzLndpZGdldC51cGRhdGVET00odGhpcy5kb20sIGUpKSAmJiAodGhpcy5kb20gJiYgdGhpcy5wcmV2V2lkZ2V0ICYmIHRoaXMucHJldldpZGdldC5kZXN0cm95KHRoaXMuZG9tKSwgdGhpcy5wcmV2V2lkZ2V0ID0gbnVsbCwgdGhpcy5zZXRET00odGhpcy53aWRnZXQudG9ET00oZSkpLCB0aGlzLndpZGdldC5lZGl0YWJsZSB8fCAodGhpcy5kb20uY29udGVudEVkaXRhYmxlID0gXCJmYWxzZVwiKSk7XG4gIH1cbiAgZ2V0IG92ZXJyaWRlRE9NVGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC52aWV3LnN0YXRlLmRvYy5zbGljZSh0aGlzLnBvc0F0U3RhcnQsIHRoaXMucG9zQXRFbmQpIDogRmUuZW1wdHk7XG4gIH1cbiAgZG9tQm91bmRzQXJvdW5kKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGJlY29tZShlKSB7XG4gICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBLaSAmJiBlLndpZGdldC5jb25zdHJ1Y3RvciA9PSB0aGlzLndpZGdldC5jb25zdHJ1Y3RvciA/IChlLndpZGdldC5jb21wYXJlKHRoaXMud2lkZ2V0KSB8fCB0aGlzLm1hcmtEaXJ0eSghMCksIHRoaXMuZG9tICYmICF0aGlzLnByZXZXaWRnZXQgJiYgKHRoaXMucHJldldpZGdldCA9IHRoaXMud2lkZ2V0KSwgdGhpcy53aWRnZXQgPSBlLndpZGdldCwgdGhpcy5sZW5ndGggPSBlLmxlbmd0aCwgdGhpcy5kZWNvID0gZS5kZWNvLCB0aGlzLmJyZWFrQWZ0ZXIgPSBlLmJyZWFrQWZ0ZXIsICEwKSA6ICExO1xuICB9XG4gIGlnbm9yZU11dGF0aW9uKCkge1xuICAgIHJldHVybiAhMDtcbiAgfVxuICBpZ25vcmVFdmVudChlKSB7XG4gICAgcmV0dXJuIHRoaXMud2lkZ2V0Lmlnbm9yZUV2ZW50KGUpO1xuICB9XG4gIGdldCBpc0VkaXRhYmxlKCkge1xuICAgIHJldHVybiAhMTtcbiAgfVxuICBnZXQgaXNXaWRnZXQoKSB7XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIGNvb3Jkc0F0KGUsIG4pIHtcbiAgICByZXR1cm4gdGhpcy53aWRnZXQuY29vcmRzQXQodGhpcy5kb20sIGUsIG4pO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpLCB0aGlzLmRvbSAmJiB0aGlzLndpZGdldC5kZXN0cm95KHRoaXMuZG9tKTtcbiAgfVxuICBjb3ZlcnMoZSkge1xuICAgIGxldCB7IHN0YXJ0U2lkZTogbiwgZW5kU2lkZTogciB9ID0gdGhpcy5kZWNvO1xuICAgIHJldHVybiBuID09IHIgPyAhMSA6IGUgPCAwID8gbiA8IDAgOiByID4gMDtcbiAgfVxufVxuY2xhc3MgcmEge1xuICAvKipcbiAgQ29tcGFyZSB0aGlzIGluc3RhbmNlIHRvIGFub3RoZXIgaW5zdGFuY2Ugb2YgdGhlIHNhbWUgdHlwZS5cbiAgKFR5cGVTY3JpcHQgY2FuJ3QgZXhwcmVzcyB0aGlzLCBidXQgb25seSBpbnN0YW5jZXMgb2YgdGhlIHNhbWVcbiAgc3BlY2lmaWMgY2xhc3Mgd2lsbCBiZSBwYXNzZWQgdG8gdGhpcyBtZXRob2QuKSBUaGlzIGlzIHVzZWQgdG9cbiAgYXZvaWQgcmVkcmF3aW5nIHdpZGdldHMgd2hlbiB0aGV5IGFyZSByZXBsYWNlZCBieSBhIG5ld1xuICBkZWNvcmF0aW9uIG9mIHRoZSBzYW1lIHR5cGUuIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGp1c3RcbiAgcmV0dXJucyBgZmFsc2VgLCB3aGljaCB3aWxsIGNhdXNlIG5ldyBpbnN0YW5jZXMgb2YgdGhlIHdpZGdldCB0b1xuICBhbHdheXMgYmUgcmVkcmF3bi5cbiAgKi9cbiAgZXEoZSkge1xuICAgIHJldHVybiAhMTtcbiAgfVxuICAvKipcbiAgVXBkYXRlIGEgRE9NIGVsZW1lbnQgY3JlYXRlZCBieSBhIHdpZGdldCBvZiB0aGUgc2FtZSB0eXBlIChidXRcbiAgZGlmZmVyZW50LCBub24tYGVxYCBjb250ZW50KSB0byByZWZsZWN0IHRoaXMgd2lkZ2V0LiBNYXkgcmV0dXJuXG4gIHRydWUgdG8gaW5kaWNhdGUgdGhhdCBpdCBjb3VsZCB1cGRhdGUsIGZhbHNlIHRvIGluZGljYXRlIGl0XG4gIGNvdWxkbid0IChpbiB3aGljaCBjYXNlIHRoZSB3aWRnZXQgd2lsbCBiZSByZWRyYXduKS4gVGhlIGRlZmF1bHRcbiAgaW1wbGVtZW50YXRpb24ganVzdCByZXR1cm5zIGZhbHNlLlxuICAqL1xuICB1cGRhdGVET00oZSwgbikge1xuICAgIHJldHVybiAhMTtcbiAgfVxuICAvKipcbiAgQGludGVybmFsXG4gICovXG4gIGNvbXBhcmUoZSkge1xuICAgIHJldHVybiB0aGlzID09IGUgfHwgdGhpcy5jb25zdHJ1Y3RvciA9PSBlLmNvbnN0cnVjdG9yICYmIHRoaXMuZXEoZSk7XG4gIH1cbiAgLyoqXG4gIFRoZSBlc3RpbWF0ZWQgaGVpZ2h0IHRoaXMgd2lkZ2V0IHdpbGwgaGF2ZSwgdG8gYmUgdXNlZCB3aGVuXG4gIGVzdGltYXRpbmcgdGhlIGhlaWdodCBvZiBjb250ZW50IHRoYXQgaGFzbid0IGJlZW4gZHJhd24uIE1heVxuICByZXR1cm4gLTEgdG8gaW5kaWNhdGUgeW91IGRvbid0IGtub3cuIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uXG4gIHJldHVybnMgLTEuXG4gICovXG4gIGdldCBlc3RpbWF0ZWRIZWlnaHQoKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIC8qKlxuICBGb3IgaW5saW5lIHdpZGdldHMgdGhhdCBhcmUgZGlzcGxheWVkIGlubGluZSAoYXMgb3Bwb3NlZCB0b1xuICBgaW5saW5lLWJsb2NrYCkgYW5kIGludHJvZHVjZSBsaW5lIGJyZWFrcyAodGhyb3VnaCBgPGJyPmAgdGFnc1xuICBvciB0ZXh0dWFsIG5ld2xpbmVzKSwgdGhpcyBtdXN0IGluZGljYXRlIHRoZSBhbW91bnQgb2YgbGluZVxuICBicmVha3MgdGhleSBpbnRyb2R1Y2UuIERlZmF1bHRzIHRvIDAuXG4gICovXG4gIGdldCBsaW5lQnJlYWtzKCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIC8qKlxuICBDYW4gYmUgdXNlZCB0byBjb25maWd1cmUgd2hpY2gga2luZHMgb2YgZXZlbnRzIGluc2lkZSB0aGUgd2lkZ2V0XG4gIHNob3VsZCBiZSBpZ25vcmVkIGJ5IHRoZSBlZGl0b3IuIFRoZSBkZWZhdWx0IGlzIHRvIGlnbm9yZSBhbGxcbiAgZXZlbnRzLlxuICAqL1xuICBpZ25vcmVFdmVudChlKSB7XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIC8qKlxuICBPdmVycmlkZSB0aGUgd2F5IHNjcmVlbiBjb29yZGluYXRlcyBmb3IgcG9zaXRpb25zIGF0L2luIHRoZVxuICB3aWRnZXQgYXJlIGZvdW5kLiBgcG9zYCB3aWxsIGJlIHRoZSBvZmZzZXQgaW50byB0aGUgd2lkZ2V0LCBhbmRcbiAgYHNpZGVgIHRoZSBzaWRlIG9mIHRoZSBwb3NpdGlvbiB0aGF0IGlzIGJlaW5nIHF1ZXJpZWTigJRsZXNzIHRoYW5cbiAgemVybyBmb3IgYmVmb3JlLCBncmVhdGVyIHRoYW4gemVybyBmb3IgYWZ0ZXIsIGFuZCB6ZXJvIGZvclxuICBkaXJlY3RseSBhdCB0aGF0IHBvc2l0aW9uLlxuICAqL1xuICBjb29yZHNBdChlLCBuLCByKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLyoqXG4gIEBpbnRlcm5hbFxuICAqL1xuICBnZXQgaXNIaWRkZW4oKSB7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIC8qKlxuICBAaW50ZXJuYWxcbiAgKi9cbiAgZ2V0IGVkaXRhYmxlKCkge1xuICAgIHJldHVybiAhMTtcbiAgfVxuICAvKipcbiAgVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGUgYW4gaW5zdGFuY2Ugb2YgdGhlIHdpZGdldCBpcyByZW1vdmVkXG4gIGZyb20gdGhlIGVkaXRvciB2aWV3LlxuICAqL1xuICBkZXN0cm95KGUpIHtcbiAgfVxufVxudmFyIGZyID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIHRbdC5UZXh0ID0gMF0gPSBcIlRleHRcIiwgdFt0LldpZGdldEJlZm9yZSA9IDFdID0gXCJXaWRnZXRCZWZvcmVcIiwgdFt0LldpZGdldEFmdGVyID0gMl0gPSBcIldpZGdldEFmdGVyXCIsIHRbdC5XaWRnZXRSYW5nZSA9IDNdID0gXCJXaWRnZXRSYW5nZVwiLCB0O1xufShmciB8fCAoZnIgPSB7fSkpO1xuY2xhc3MgSmUgZXh0ZW5kcyBxcyB7XG4gIGNvbnN0cnVjdG9yKGUsIG4sIHIsIGkpIHtcbiAgICBzdXBlcigpLCB0aGlzLnN0YXJ0U2lkZSA9IGUsIHRoaXMuZW5kU2lkZSA9IG4sIHRoaXMud2lkZ2V0ID0gciwgdGhpcy5zcGVjID0gaTtcbiAgfVxuICAvKipcbiAgQGludGVybmFsXG4gICovXG4gIGdldCBoZWlnaHRSZWxldmFudCgpIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbiAgLyoqXG4gIENyZWF0ZSBhIG1hcmsgZGVjb3JhdGlvbiwgd2hpY2ggaW5mbHVlbmNlcyB0aGUgc3R5bGluZyBvZiB0aGVcbiAgY29udGVudCBpbiBpdHMgcmFuZ2UuIE5lc3RlZCBtYXJrIGRlY29yYXRpb25zIHdpbGwgY2F1c2UgbmVzdGVkXG4gIERPTSBlbGVtZW50cyB0byBiZSBjcmVhdGVkLiBOZXN0aW5nIG9yZGVyIGlzIGRldGVybWluZWQgYnlcbiAgcHJlY2VkZW5jZSBvZiB0aGUgW2ZhY2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15kZWNvcmF0aW9ucyksIHdpdGhcbiAgdGhlIGhpZ2hlci1wcmVjZWRlbmNlIGRlY29yYXRpb25zIGNyZWF0aW5nIHRoZSBpbm5lciBET00gbm9kZXMuXG4gIFN1Y2ggZWxlbWVudHMgYXJlIHNwbGl0IG9uIGxpbmUgYm91bmRhcmllcyBhbmQgb24gdGhlIGJvdW5kYXJpZXNcbiAgb2YgbG93ZXItcHJlY2VkZW5jZSBkZWNvcmF0aW9ucy5cbiAgKi9cbiAgc3RhdGljIG1hcmsoZSkge1xuICAgIHJldHVybiBuZXcgSGwoZSk7XG4gIH1cbiAgLyoqXG4gIENyZWF0ZSBhIHdpZGdldCBkZWNvcmF0aW9uLCB3aGljaCBkaXNwbGF5cyBhIERPTSBlbGVtZW50IGF0IHRoZVxuICBnaXZlbiBwb3NpdGlvbi5cbiAgKi9cbiAgc3RhdGljIHdpZGdldChlKSB7XG4gICAgbGV0IG4gPSBNYXRoLm1heCgtMWU0LCBNYXRoLm1pbigxZTQsIGUuc2lkZSB8fCAwKSksIHIgPSAhIWUuYmxvY2s7XG4gICAgcmV0dXJuIG4gKz0gciAmJiAhZS5pbmxpbmVPcmRlciA/IG4gPiAwID8gM2U4IDogLTRlOCA6IG4gPiAwID8gMWU4IDogLTFlOCwgbmV3IGFzKGUsIG4sIG4sIHIsIGUud2lkZ2V0IHx8IG51bGwsICExKTtcbiAgfVxuICAvKipcbiAgQ3JlYXRlIGEgcmVwbGFjZSBkZWNvcmF0aW9uIHdoaWNoIHJlcGxhY2VzIHRoZSBnaXZlbiByYW5nZSB3aXRoXG4gIGEgd2lkZ2V0LCBvciBzaW1wbHkgaGlkZXMgaXQuXG4gICovXG4gIHN0YXRpYyByZXBsYWNlKGUpIHtcbiAgICBsZXQgbiA9ICEhZS5ibG9jaywgciwgaTtcbiAgICBpZiAoZS5pc0Jsb2NrR2FwKVxuICAgICAgciA9IC01ZTgsIGkgPSA0ZTg7XG4gICAgZWxzZSB7XG4gICAgICBsZXQgeyBzdGFydDogcywgZW5kOiBvIH0gPSB1ayhlLCBuKTtcbiAgICAgIHIgPSAocyA/IG4gPyAtM2U4IDogLTEgOiA1ZTgpIC0gMSwgaSA9IChvID8gbiA/IDJlOCA6IDEgOiAtNmU4KSArIDE7XG4gICAgfVxuICAgIHJldHVybiBuZXcgYXMoZSwgciwgaSwgbiwgZS53aWRnZXQgfHwgbnVsbCwgITApO1xuICB9XG4gIC8qKlxuICBDcmVhdGUgYSBsaW5lIGRlY29yYXRpb24sIHdoaWNoIGNhbiBhZGQgRE9NIGF0dHJpYnV0ZXMgdG8gdGhlXG4gIGxpbmUgc3RhcnRpbmcgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAqL1xuICBzdGF0aWMgbGluZShlKSB7XG4gICAgcmV0dXJuIG5ldyBGbChlKTtcbiAgfVxuICAvKipcbiAgQnVpbGQgYSBbYERlY29yYXRpb25TZXRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvblNldCkgZnJvbSB0aGUgZ2l2ZW5cbiAgZGVjb3JhdGVkIHJhbmdlIG9yIHJhbmdlcy4gSWYgdGhlIHJhbmdlcyBhcmVuJ3QgYWxyZWFkeSBzb3J0ZWQsXG4gIHBhc3MgYHRydWVgIGZvciBgc29ydGAgdG8gbWFrZSB0aGUgbGlicmFyeSBzb3J0IHRoZW0gZm9yIHlvdS5cbiAgKi9cbiAgc3RhdGljIHNldChlLCBuID0gITEpIHtcbiAgICByZXR1cm4gemUub2YoZSwgbik7XG4gIH1cbiAgLyoqXG4gIEBpbnRlcm5hbFxuICAqL1xuICBoYXNIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMud2lkZ2V0ID8gdGhpcy53aWRnZXQuZXN0aW1hdGVkSGVpZ2h0ID4gLTEgOiAhMTtcbiAgfVxufVxuSmUubm9uZSA9IHplLmVtcHR5O1xuY2xhc3MgSGwgZXh0ZW5kcyBKZSB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBsZXQgeyBzdGFydDogbiwgZW5kOiByIH0gPSB1ayhlKTtcbiAgICBzdXBlcihuID8gLTEgOiA1ZTgsIHIgPyAxIDogLTZlOCwgbnVsbCwgZSksIHRoaXMudGFnTmFtZSA9IGUudGFnTmFtZSB8fCBcInNwYW5cIiwgdGhpcy5jbGFzcyA9IGUuY2xhc3MgfHwgXCJcIiwgdGhpcy5hdHRycyA9IGUuYXR0cmlidXRlcyB8fCBudWxsO1xuICB9XG4gIGVxKGUpIHtcbiAgICB2YXIgbiwgcjtcbiAgICByZXR1cm4gdGhpcyA9PSBlIHx8IGUgaW5zdGFuY2VvZiBIbCAmJiB0aGlzLnRhZ05hbWUgPT0gZS50YWdOYW1lICYmICh0aGlzLmNsYXNzIHx8ICgobiA9IHRoaXMuYXR0cnMpID09PSBudWxsIHx8IG4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG4uY2xhc3MpKSA9PSAoZS5jbGFzcyB8fCAoKHIgPSBlLmF0dHJzKSA9PT0gbnVsbCB8fCByID09PSB2b2lkIDAgPyB2b2lkIDAgOiByLmNsYXNzKSkgJiYgYWcodGhpcy5hdHRycywgZS5hdHRycywgXCJjbGFzc1wiKTtcbiAgfVxuICByYW5nZShlLCBuID0gZSkge1xuICAgIGlmIChlID49IG4pXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk1hcmsgZGVjb3JhdGlvbnMgbWF5IG5vdCBiZSBlbXB0eVwiKTtcbiAgICByZXR1cm4gc3VwZXIucmFuZ2UoZSwgbik7XG4gIH1cbn1cbkhsLnByb3RvdHlwZS5wb2ludCA9ICExO1xuY2xhc3MgRmwgZXh0ZW5kcyBKZSB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcigtMmU4LCAtMmU4LCBudWxsLCBlKTtcbiAgfVxuICBlcShlKSB7XG4gICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBGbCAmJiB0aGlzLnNwZWMuY2xhc3MgPT0gZS5zcGVjLmNsYXNzICYmIGFnKHRoaXMuc3BlYy5hdHRyaWJ1dGVzLCBlLnNwZWMuYXR0cmlidXRlcyk7XG4gIH1cbiAgcmFuZ2UoZSwgbiA9IGUpIHtcbiAgICBpZiAobiAhPSBlKVxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJMaW5lIGRlY29yYXRpb24gcmFuZ2VzIG11c3QgYmUgemVyby1sZW5ndGhcIik7XG4gICAgcmV0dXJuIHN1cGVyLnJhbmdlKGUsIG4pO1xuICB9XG59XG5GbC5wcm90b3R5cGUubWFwTW9kZSA9IG9uLlRyYWNrQmVmb3JlO1xuRmwucHJvdG90eXBlLnBvaW50ID0gITA7XG5jbGFzcyBhcyBleHRlbmRzIEplIHtcbiAgY29uc3RydWN0b3IoZSwgbiwgciwgaSwgcywgbykge1xuICAgIHN1cGVyKG4sIHIsIHMsIGUpLCB0aGlzLmJsb2NrID0gaSwgdGhpcy5pc1JlcGxhY2UgPSBvLCB0aGlzLm1hcE1vZGUgPSBpID8gbiA8PSAwID8gb24uVHJhY2tCZWZvcmUgOiBvbi5UcmFja0FmdGVyIDogb24uVHJhY2tEZWw7XG4gIH1cbiAgLy8gT25seSByZWxldmFudCB3aGVuIHRoaXMuYmxvY2sgPT0gdHJ1ZVxuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFydFNpZGUgIT0gdGhpcy5lbmRTaWRlID8gZnIuV2lkZ2V0UmFuZ2UgOiB0aGlzLnN0YXJ0U2lkZSA8PSAwID8gZnIuV2lkZ2V0QmVmb3JlIDogZnIuV2lkZ2V0QWZ0ZXI7XG4gIH1cbiAgZ2V0IGhlaWdodFJlbGV2YW50KCkge1xuICAgIHJldHVybiB0aGlzLmJsb2NrIHx8ICEhdGhpcy53aWRnZXQgJiYgKHRoaXMud2lkZ2V0LmVzdGltYXRlZEhlaWdodCA+PSA1IHx8IHRoaXMud2lkZ2V0LmxpbmVCcmVha3MgPiAwKTtcbiAgfVxuICBlcShlKSB7XG4gICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBhcyAmJiAkTih0aGlzLndpZGdldCwgZS53aWRnZXQpICYmIHRoaXMuYmxvY2sgPT0gZS5ibG9jayAmJiB0aGlzLnN0YXJ0U2lkZSA9PSBlLnN0YXJ0U2lkZSAmJiB0aGlzLmVuZFNpZGUgPT0gZS5lbmRTaWRlO1xuICB9XG4gIHJhbmdlKGUsIG4gPSBlKSB7XG4gICAgaWYgKHRoaXMuaXNSZXBsYWNlICYmIChlID4gbiB8fCBlID09IG4gJiYgdGhpcy5zdGFydFNpZGUgPiAwICYmIHRoaXMuZW5kU2lkZSA8PSAwKSlcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCByYW5nZSBmb3IgcmVwbGFjZW1lbnQgZGVjb3JhdGlvblwiKTtcbiAgICBpZiAoIXRoaXMuaXNSZXBsYWNlICYmIG4gIT0gZSlcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiV2lkZ2V0IGRlY29yYXRpb25zIGNhbiBvbmx5IGhhdmUgemVyby1sZW5ndGggcmFuZ2VzXCIpO1xuICAgIHJldHVybiBzdXBlci5yYW5nZShlLCBuKTtcbiAgfVxufVxuYXMucHJvdG90eXBlLnBvaW50ID0gITA7XG5mdW5jdGlvbiB1ayh0LCBlID0gITEpIHtcbiAgbGV0IHsgaW5jbHVzaXZlU3RhcnQ6IG4sIGluY2x1c2l2ZUVuZDogciB9ID0gdDtcbiAgcmV0dXJuIG4gPT0gbnVsbCAmJiAobiA9IHQuaW5jbHVzaXZlKSwgciA9PSBudWxsICYmIChyID0gdC5pbmNsdXNpdmUpLCB7IHN0YXJ0OiBuID8/IGUsIGVuZDogciA/PyBlIH07XG59XG5mdW5jdGlvbiAkTih0LCBlKSB7XG4gIHJldHVybiB0ID09IGUgfHwgISEodCAmJiBlICYmIHQuY29tcGFyZShlKSk7XG59XG5mdW5jdGlvbiBscCh0LCBlLCBuLCByID0gMCkge1xuICBsZXQgaSA9IG4ubGVuZ3RoIC0gMTtcbiAgaSA+PSAwICYmIG5baV0gKyByID49IHQgPyBuW2ldID0gTWF0aC5tYXgobltpXSwgZSkgOiBuLnB1c2godCwgZSk7XG59XG5jbGFzcyBIYSB7XG4gIGNvbnN0cnVjdG9yKGUsIG4sIHIsIGkpIHtcbiAgICB0aGlzLmRvYyA9IGUsIHRoaXMucG9zID0gbiwgdGhpcy5lbmQgPSByLCB0aGlzLmRpc2FsbG93QmxvY2tFZmZlY3RzRm9yID0gaSwgdGhpcy5jb250ZW50ID0gW10sIHRoaXMuY3VyTGluZSA9IG51bGwsIHRoaXMuYnJlYWtBdFN0YXJ0ID0gMCwgdGhpcy5wZW5kaW5nQnVmZmVyID0gMCwgdGhpcy5idWZmZXJNYXJrcyA9IFtdLCB0aGlzLmF0Q3Vyc29yUG9zID0gITAsIHRoaXMub3BlblN0YXJ0ID0gLTEsIHRoaXMub3BlbkVuZCA9IC0xLCB0aGlzLnRleHQgPSBcIlwiLCB0aGlzLnRleHRPZmYgPSAwLCB0aGlzLmN1cnNvciA9IGUuaXRlcigpLCB0aGlzLnNraXAgPSBuO1xuICB9XG4gIHBvc0NvdmVyZWQoKSB7XG4gICAgaWYgKHRoaXMuY29udGVudC5sZW5ndGggPT0gMClcbiAgICAgIHJldHVybiAhdGhpcy5icmVha0F0U3RhcnQgJiYgdGhpcy5kb2MubGluZUF0KHRoaXMucG9zKS5mcm9tICE9IHRoaXMucG9zO1xuICAgIGxldCBlID0gdGhpcy5jb250ZW50W3RoaXMuY29udGVudC5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gIShlLmJyZWFrQWZ0ZXIgfHwgZSBpbnN0YW5jZW9mIEtpICYmIGUuZGVjby5lbmRTaWRlIDwgMCk7XG4gIH1cbiAgZ2V0TGluZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJMaW5lIHx8ICh0aGlzLmNvbnRlbnQucHVzaCh0aGlzLmN1ckxpbmUgPSBuZXcgTnQoKSksIHRoaXMuYXRDdXJzb3JQb3MgPSAhMCksIHRoaXMuY3VyTGluZTtcbiAgfVxuICBmbHVzaEJ1ZmZlcihlID0gdGhpcy5idWZmZXJNYXJrcykge1xuICAgIHRoaXMucGVuZGluZ0J1ZmZlciAmJiAodGhpcy5jdXJMaW5lLmFwcGVuZChQYyhuZXcgQm8oLTEpLCBlKSwgZS5sZW5ndGgpLCB0aGlzLnBlbmRpbmdCdWZmZXIgPSAwKTtcbiAgfVxuICBhZGRCbG9ja1dpZGdldChlKSB7XG4gICAgdGhpcy5mbHVzaEJ1ZmZlcigpLCB0aGlzLmN1ckxpbmUgPSBudWxsLCB0aGlzLmNvbnRlbnQucHVzaChlKTtcbiAgfVxuICBmaW5pc2goZSkge1xuICAgIHRoaXMucGVuZGluZ0J1ZmZlciAmJiBlIDw9IHRoaXMuYnVmZmVyTWFya3MubGVuZ3RoID8gdGhpcy5mbHVzaEJ1ZmZlcigpIDogdGhpcy5wZW5kaW5nQnVmZmVyID0gMCwgIXRoaXMucG9zQ292ZXJlZCgpICYmICEoZSAmJiB0aGlzLmNvbnRlbnQubGVuZ3RoICYmIHRoaXMuY29udGVudFt0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMV0gaW5zdGFuY2VvZiBLaSkgJiYgdGhpcy5nZXRMaW5lKCk7XG4gIH1cbiAgYnVpbGRUZXh0KGUsIG4sIHIpIHtcbiAgICBmb3IgKDsgZSA+IDA7ICkge1xuICAgICAgaWYgKHRoaXMudGV4dE9mZiA9PSB0aGlzLnRleHQubGVuZ3RoKSB7XG4gICAgICAgIGxldCB7IHZhbHVlOiBzLCBsaW5lQnJlYWs6IG8sIGRvbmU6IGEgfSA9IHRoaXMuY3Vyc29yLm5leHQodGhpcy5za2lwKTtcbiAgICAgICAgaWYgKHRoaXMuc2tpcCA9IDAsIGEpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmFuIG91dCBvZiB0ZXh0IGNvbnRlbnQgd2hlbiBkcmF3aW5nIGlubGluZSB2aWV3c1wiKTtcbiAgICAgICAgaWYgKG8pIHtcbiAgICAgICAgICB0aGlzLnBvc0NvdmVyZWQoKSB8fCB0aGlzLmdldExpbmUoKSwgdGhpcy5jb250ZW50Lmxlbmd0aCA/IHRoaXMuY29udGVudFt0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMV0uYnJlYWtBZnRlciA9IDEgOiB0aGlzLmJyZWFrQXRTdGFydCA9IDEsIHRoaXMuZmx1c2hCdWZmZXIoKSwgdGhpcy5jdXJMaW5lID0gbnVsbCwgdGhpcy5hdEN1cnNvclBvcyA9ICEwLCBlLS07XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIHRoaXMudGV4dCA9IHMsIHRoaXMudGV4dE9mZiA9IDA7XG4gICAgICB9XG4gICAgICBsZXQgaSA9IE1hdGgubWluKFxuICAgICAgICB0aGlzLnRleHQubGVuZ3RoIC0gdGhpcy50ZXh0T2ZmLFxuICAgICAgICBlLFxuICAgICAgICA1MTJcbiAgICAgICAgLyogVC5DaHVuayAqL1xuICAgICAgKTtcbiAgICAgIHRoaXMuZmx1c2hCdWZmZXIobi5zbGljZShuLmxlbmd0aCAtIHIpKSwgdGhpcy5nZXRMaW5lKCkuYXBwZW5kKFBjKG5ldyBoaSh0aGlzLnRleHQuc2xpY2UodGhpcy50ZXh0T2ZmLCB0aGlzLnRleHRPZmYgKyBpKSksIG4pLCByKSwgdGhpcy5hdEN1cnNvclBvcyA9ICEwLCB0aGlzLnRleHRPZmYgKz0gaSwgZSAtPSBpLCByID0gMDtcbiAgICB9XG4gIH1cbiAgc3BhbihlLCBuLCByLCBpKSB7XG4gICAgdGhpcy5idWlsZFRleHQobiAtIGUsIHIsIGkpLCB0aGlzLnBvcyA9IG4sIHRoaXMub3BlblN0YXJ0IDwgMCAmJiAodGhpcy5vcGVuU3RhcnQgPSBpKTtcbiAgfVxuICBwb2ludChlLCBuLCByLCBpLCBzLCBvKSB7XG4gICAgaWYgKHRoaXMuZGlzYWxsb3dCbG9ja0VmZmVjdHNGb3Jbb10gJiYgciBpbnN0YW5jZW9mIGFzKSB7XG4gICAgICBpZiAoci5ibG9jaylcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCbG9jayBkZWNvcmF0aW9ucyBtYXkgbm90IGJlIHNwZWNpZmllZCB2aWEgcGx1Z2luc1wiKTtcbiAgICAgIGlmIChuID4gdGhpcy5kb2MubGluZUF0KHRoaXMucG9zKS50bylcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEZWNvcmF0aW9ucyB0aGF0IHJlcGxhY2UgbGluZSBicmVha3MgbWF5IG5vdCBiZSBzcGVjaWZpZWQgdmlhIHBsdWdpbnNcIik7XG4gICAgfVxuICAgIGxldCBhID0gbiAtIGU7XG4gICAgaWYgKHIgaW5zdGFuY2VvZiBhcylcbiAgICAgIGlmIChyLmJsb2NrKVxuICAgICAgICByLnN0YXJ0U2lkZSA+IDAgJiYgIXRoaXMucG9zQ292ZXJlZCgpICYmIHRoaXMuZ2V0TGluZSgpLCB0aGlzLmFkZEJsb2NrV2lkZ2V0KG5ldyBLaShyLndpZGdldCB8fCBuZXcgR2IoXCJkaXZcIiksIGEsIHIpKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBsZXQgbCA9IFBzLmNyZWF0ZShyLndpZGdldCB8fCBuZXcgR2IoXCJzcGFuXCIpLCBhLCBhID8gMCA6IHIuc3RhcnRTaWRlKSwgYyA9IHRoaXMuYXRDdXJzb3JQb3MgJiYgIWwuaXNFZGl0YWJsZSAmJiBzIDw9IGkubGVuZ3RoICYmIChlIDwgbiB8fCByLnN0YXJ0U2lkZSA+IDApLCB1ID0gIWwuaXNFZGl0YWJsZSAmJiAoZSA8IG4gfHwgcyA+IGkubGVuZ3RoIHx8IHIuc3RhcnRTaWRlIDw9IDApLCBkID0gdGhpcy5nZXRMaW5lKCk7XG4gICAgICAgIHRoaXMucGVuZGluZ0J1ZmZlciA9PSAyICYmICFjICYmICFsLmlzRWRpdGFibGUgJiYgKHRoaXMucGVuZGluZ0J1ZmZlciA9IDApLCB0aGlzLmZsdXNoQnVmZmVyKGkpLCBjICYmIChkLmFwcGVuZChQYyhuZXcgQm8oMSksIGkpLCBzKSwgcyA9IGkubGVuZ3RoICsgTWF0aC5tYXgoMCwgcyAtIGkubGVuZ3RoKSksIGQuYXBwZW5kKFBjKGwsIGkpLCBzKSwgdGhpcy5hdEN1cnNvclBvcyA9IHUsIHRoaXMucGVuZGluZ0J1ZmZlciA9IHUgPyBlIDwgbiB8fCBzID4gaS5sZW5ndGggPyAxIDogMiA6IDAsIHRoaXMucGVuZGluZ0J1ZmZlciAmJiAodGhpcy5idWZmZXJNYXJrcyA9IGkuc2xpY2UoKSk7XG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgdGhpcy5kb2MubGluZUF0KHRoaXMucG9zKS5mcm9tID09IHRoaXMucG9zICYmIHRoaXMuZ2V0TGluZSgpLmFkZExpbmVEZWNvKHIpO1xuICAgIGEgJiYgKHRoaXMudGV4dE9mZiArIGEgPD0gdGhpcy50ZXh0Lmxlbmd0aCA/IHRoaXMudGV4dE9mZiArPSBhIDogKHRoaXMuc2tpcCArPSBhIC0gKHRoaXMudGV4dC5sZW5ndGggLSB0aGlzLnRleHRPZmYpLCB0aGlzLnRleHQgPSBcIlwiLCB0aGlzLnRleHRPZmYgPSAwKSwgdGhpcy5wb3MgPSBuKSwgdGhpcy5vcGVuU3RhcnQgPCAwICYmICh0aGlzLm9wZW5TdGFydCA9IHMpO1xuICB9XG4gIHN0YXRpYyBidWlsZChlLCBuLCByLCBpLCBzKSB7XG4gICAgbGV0IG8gPSBuZXcgSGEoZSwgbiwgciwgcyk7XG4gICAgcmV0dXJuIG8ub3BlbkVuZCA9IHplLnNwYW5zKGksIG4sIHIsIG8pLCBvLm9wZW5TdGFydCA8IDAgJiYgKG8ub3BlblN0YXJ0ID0gby5vcGVuRW5kKSwgby5maW5pc2goby5vcGVuRW5kKSwgbztcbiAgfVxufVxuZnVuY3Rpb24gUGModCwgZSkge1xuICBmb3IgKGxldCBuIG9mIGUpXG4gICAgdCA9IG5ldyBwaShuLCBbdF0sIHQubGVuZ3RoKTtcbiAgcmV0dXJuIHQ7XG59XG5jbGFzcyBHYiBleHRlbmRzIHJhIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKCksIHRoaXMudGFnID0gZTtcbiAgfVxuICBlcShlKSB7XG4gICAgcmV0dXJuIGUudGFnID09IHRoaXMudGFnO1xuICB9XG4gIHRvRE9NKCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMudGFnKTtcbiAgfVxuICB1cGRhdGVET00oZSkge1xuICAgIHJldHVybiBlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT0gdGhpcy50YWc7XG4gIH1cbiAgZ2V0IGlzSGlkZGVuKCkge1xuICAgIHJldHVybiAhMDtcbiAgfVxufVxudmFyIFF0ID0gLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKHQpIHtcbiAgcmV0dXJuIHRbdC5MVFIgPSAwXSA9IFwiTFRSXCIsIHRbdC5SVEwgPSAxXSA9IFwiUlRMXCIsIHQ7XG59KFF0IHx8IChRdCA9IHt9KSk7XG5jb25zdCB6cyA9IFF0LkxUUiwgbGcgPSBRdC5SVEw7XG5mdW5jdGlvbiBkayh0KSB7XG4gIGxldCBlID0gW107XG4gIGZvciAobGV0IG4gPSAwOyBuIDwgdC5sZW5ndGg7IG4rKylcbiAgICBlLnB1c2goMSA8PCArdFtuXSk7XG4gIHJldHVybiBlO1xufVxuY29uc3QgUU4gPSAvKiBAX19QVVJFX18gKi8gZGsoXCI4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODY2Njg4ODg4ODc4NzgzMzMzMzMzMzMzNzg4ODg4ODAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwODg4ODg4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4Nzg2NjY2ODg4ODA4ODg4ODY2MzM4MDg4ODMwODg4ODgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwOFwiKSwgQ04gPSAvKiBAX19QVVJFX18gKi8gZGsoXCI0NDQ0NDQ4ODI2NjI3Mjg4OTk5OTk5OTk5OTkyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI5OTk5OTk5OTk5OTk5OTk5OTk5OTk0NDQ0NDQ0NDQ0NjQ0MjIyODIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyOTk5OTk5OTQ5OTk5OTk5MjI5OTg5OTk5MjIzMzMzMzMzMzMzXCIpLCBjcCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCB3ciA9IFtdO1xuZm9yIChsZXQgdCBvZiBbXCIoKVwiLCBcIltdXCIsIFwie31cIl0pIHtcbiAgbGV0IGUgPSAvKiBAX19QVVJFX18gKi8gdC5jaGFyQ29kZUF0KDApLCBuID0gLyogQF9fUFVSRV9fICovIHQuY2hhckNvZGVBdCgxKTtcbiAgY3BbZV0gPSBuLCBjcFtuXSA9IC1lO1xufVxuZnVuY3Rpb24gZmsodCkge1xuICByZXR1cm4gdCA8PSAyNDcgPyBRTlt0XSA6IDE0MjQgPD0gdCAmJiB0IDw9IDE1MjQgPyAyIDogMTUzNiA8PSB0ICYmIHQgPD0gMTc4NSA/IENOW3QgLSAxNTM2XSA6IDE3NzQgPD0gdCAmJiB0IDw9IDIyMjAgPyA0IDogODE5MiA8PSB0ICYmIHQgPD0gODIwNCA/IDI1NiA6IDY0MzM2IDw9IHQgJiYgdCA8PSA2NTAyMyA/IDQgOiAxO1xufVxuY29uc3QgQU4gPSAvW1xcdTA1OTAtXFx1MDVmNFxcdTA2MDAtXFx1MDZmZlxcdTA3MDAtXFx1MDhhY1xcdWZiNTAtXFx1ZmRmZl0vO1xuY2xhc3MgQmkge1xuICAvKipcbiAgVGhlIGRpcmVjdGlvbiBvZiB0aGlzIHNwYW4uXG4gICovXG4gIGdldCBkaXIoKSB7XG4gICAgcmV0dXJuIHRoaXMubGV2ZWwgJSAyID8gbGcgOiB6cztcbiAgfVxuICAvKipcbiAgQGludGVybmFsXG4gICovXG4gIGNvbnN0cnVjdG9yKGUsIG4sIHIpIHtcbiAgICB0aGlzLmZyb20gPSBlLCB0aGlzLnRvID0gbiwgdGhpcy5sZXZlbCA9IHI7XG4gIH1cbiAgLyoqXG4gIEBpbnRlcm5hbFxuICAqL1xuICBzaWRlKGUsIG4pIHtcbiAgICByZXR1cm4gdGhpcy5kaXIgPT0gbiA9PSBlID8gdGhpcy50byA6IHRoaXMuZnJvbTtcbiAgfVxuICAvKipcbiAgQGludGVybmFsXG4gICovXG4gIGZvcndhcmQoZSwgbikge1xuICAgIHJldHVybiBlID09ICh0aGlzLmRpciA9PSBuKTtcbiAgfVxuICAvKipcbiAgQGludGVybmFsXG4gICovXG4gIHN0YXRpYyBmaW5kKGUsIG4sIHIsIGkpIHtcbiAgICBsZXQgcyA9IC0xO1xuICAgIGZvciAobGV0IG8gPSAwOyBvIDwgZS5sZW5ndGg7IG8rKykge1xuICAgICAgbGV0IGEgPSBlW29dO1xuICAgICAgaWYgKGEuZnJvbSA8PSBuICYmIGEudG8gPj0gbikge1xuICAgICAgICBpZiAoYS5sZXZlbCA9PSByKVxuICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICAocyA8IDAgfHwgKGkgIT0gMCA/IGkgPCAwID8gYS5mcm9tIDwgbiA6IGEudG8gPiBuIDogZVtzXS5sZXZlbCA+IGEubGV2ZWwpKSAmJiAocyA9IG8pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocyA8IDApXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKTtcbiAgICByZXR1cm4gcztcbiAgfVxufVxuZnVuY3Rpb24gaGsodCwgZSkge1xuICBpZiAodC5sZW5ndGggIT0gZS5sZW5ndGgpXG4gICAgcmV0dXJuICExO1xuICBmb3IgKGxldCBuID0gMDsgbiA8IHQubGVuZ3RoOyBuKyspIHtcbiAgICBsZXQgciA9IHRbbl0sIGkgPSBlW25dO1xuICAgIGlmIChyLmZyb20gIT0gaS5mcm9tIHx8IHIudG8gIT0gaS50byB8fCByLmRpcmVjdGlvbiAhPSBpLmRpcmVjdGlvbiB8fCAhaGsoci5pbm5lciwgaS5pbm5lcikpXG4gICAgICByZXR1cm4gITE7XG4gIH1cbiAgcmV0dXJuICEwO1xufVxuY29uc3QgcnQgPSBbXTtcbmZ1bmN0aW9uIFJOKHQsIGUsIG4sIHIsIGkpIHtcbiAgZm9yIChsZXQgcyA9IDA7IHMgPD0gci5sZW5ndGg7IHMrKykge1xuICAgIGxldCBvID0gcyA/IHJbcyAtIDFdLnRvIDogZSwgYSA9IHMgPCByLmxlbmd0aCA/IHJbc10uZnJvbSA6IG4sIGwgPSBzID8gMjU2IDogaTtcbiAgICBmb3IgKGxldCBjID0gbywgdSA9IGwsIGQgPSBsOyBjIDwgYTsgYysrKSB7XG4gICAgICBsZXQgZiA9IGZrKHQuY2hhckNvZGVBdChjKSk7XG4gICAgICBmID09IDUxMiA/IGYgPSB1IDogZiA9PSA4ICYmIGQgPT0gNCAmJiAoZiA9IDE2KSwgcnRbY10gPSBmID09IDQgPyAyIDogZiwgZiAmIDcgJiYgKGQgPSBmKSwgdSA9IGY7XG4gICAgfVxuICAgIGZvciAobGV0IGMgPSBvLCB1ID0gbCwgZCA9IGw7IGMgPCBhOyBjKyspIHtcbiAgICAgIGxldCBmID0gcnRbY107XG4gICAgICBpZiAoZiA9PSAxMjgpXG4gICAgICAgIGMgPCBhIC0gMSAmJiB1ID09IHJ0W2MgKyAxXSAmJiB1ICYgMjQgPyBmID0gcnRbY10gPSB1IDogcnRbY10gPSAyNTY7XG4gICAgICBlbHNlIGlmIChmID09IDY0KSB7XG4gICAgICAgIGxldCBoID0gYyArIDE7XG4gICAgICAgIGZvciAoOyBoIDwgYSAmJiBydFtoXSA9PSA2NDsgKVxuICAgICAgICAgIGgrKztcbiAgICAgICAgbGV0IHAgPSBjICYmIHUgPT0gOCB8fCBoIDwgbiAmJiBydFtoXSA9PSA4ID8gZCA9PSAxID8gMSA6IDggOiAyNTY7XG4gICAgICAgIGZvciAobGV0IE8gPSBjOyBPIDwgaDsgTysrKVxuICAgICAgICAgIHJ0W09dID0gcDtcbiAgICAgICAgYyA9IGggLSAxO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGYgPT0gOCAmJiBkID09IDEgJiYgKHJ0W2NdID0gMSk7XG4gICAgICB1ID0gZiwgZiAmIDcgJiYgKGQgPSBmKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIE5OKHQsIGUsIG4sIHIsIGkpIHtcbiAgbGV0IHMgPSBpID09IDEgPyAyIDogMTtcbiAgZm9yIChsZXQgbyA9IDAsIGEgPSAwLCBsID0gMDsgbyA8PSByLmxlbmd0aDsgbysrKSB7XG4gICAgbGV0IGMgPSBvID8gcltvIC0gMV0udG8gOiBlLCB1ID0gbyA8IHIubGVuZ3RoID8gcltvXS5mcm9tIDogbjtcbiAgICBmb3IgKGxldCBkID0gYywgZiwgaCwgcDsgZCA8IHU7IGQrKylcbiAgICAgIGlmIChoID0gY3BbZiA9IHQuY2hhckNvZGVBdChkKV0pXG4gICAgICAgIGlmIChoIDwgMCkge1xuICAgICAgICAgIGZvciAobGV0IE8gPSBhIC0gMzsgTyA+PSAwOyBPIC09IDMpXG4gICAgICAgICAgICBpZiAod3JbTyArIDFdID09IC1oKSB7XG4gICAgICAgICAgICAgIGxldCBtID0gd3JbTyArIDJdLCB5ID0gbSAmIDIgPyBpIDogbSAmIDQgPyBtICYgMSA/IHMgOiBpIDogMDtcbiAgICAgICAgICAgICAgeSAmJiAocnRbZF0gPSBydFt3cltPXV0gPSB5KSwgYSA9IE87XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh3ci5sZW5ndGggPT0gMTg5KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgd3JbYSsrXSA9IGQsIHdyW2ErK10gPSBmLCB3clthKytdID0gbDtcbiAgICAgICAgfVxuICAgICAgZWxzZSBpZiAoKHAgPSBydFtkXSkgPT0gMiB8fCBwID09IDEpIHtcbiAgICAgICAgbGV0IE8gPSBwID09IGk7XG4gICAgICAgIGwgPSBPID8gMCA6IDE7XG4gICAgICAgIGZvciAobGV0IG0gPSBhIC0gMzsgbSA+PSAwOyBtIC09IDMpIHtcbiAgICAgICAgICBsZXQgeSA9IHdyW20gKyAyXTtcbiAgICAgICAgICBpZiAoeSAmIDIpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBpZiAoTylcbiAgICAgICAgICAgIHdyW20gKyAyXSB8PSAyO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHkgJiA0KVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHdyW20gKyAyXSB8PSA0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICB9XG59XG5mdW5jdGlvbiBETih0LCBlLCBuLCByKSB7XG4gIGZvciAobGV0IGkgPSAwLCBzID0gcjsgaSA8PSBuLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IG8gPSBpID8gbltpIC0gMV0udG8gOiB0LCBhID0gaSA8IG4ubGVuZ3RoID8gbltpXS5mcm9tIDogZTtcbiAgICBmb3IgKGxldCBsID0gbzsgbCA8IGE7ICkge1xuICAgICAgbGV0IGMgPSBydFtsXTtcbiAgICAgIGlmIChjID09IDI1Nikge1xuICAgICAgICBsZXQgdSA9IGwgKyAxO1xuICAgICAgICBmb3IgKDsgOyApXG4gICAgICAgICAgaWYgKHUgPT0gYSkge1xuICAgICAgICAgICAgaWYgKGkgPT0gbi5sZW5ndGgpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdSA9IG5baSsrXS50bywgYSA9IGkgPCBuLmxlbmd0aCA/IG5baV0uZnJvbSA6IGU7XG4gICAgICAgICAgfSBlbHNlIGlmIChydFt1XSA9PSAyNTYpXG4gICAgICAgICAgICB1Kys7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGxldCBkID0gcyA9PSAxLCBmID0gKHUgPCBlID8gcnRbdV0gOiByKSA9PSAxLCBoID0gZCA9PSBmID8gZCA/IDEgOiAyIDogcjtcbiAgICAgICAgZm9yIChsZXQgcCA9IHUsIE8gPSBpLCBtID0gTyA/IG5bTyAtIDFdLnRvIDogdDsgcCA+IGw7IClcbiAgICAgICAgICBwID09IG0gJiYgKHAgPSBuWy0tT10uZnJvbSwgbSA9IE8gPyBuW08gLSAxXS50byA6IHQpLCBydFstLXBdID0gaDtcbiAgICAgICAgbCA9IHU7XG4gICAgICB9IGVsc2VcbiAgICAgICAgcyA9IGMsIGwrKztcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHVwKHQsIGUsIG4sIHIsIGksIHMsIG8pIHtcbiAgbGV0IGEgPSByICUgMiA/IDIgOiAxO1xuICBpZiAociAlIDIgPT0gaSAlIDIpXG4gICAgZm9yIChsZXQgbCA9IGUsIGMgPSAwOyBsIDwgbjsgKSB7XG4gICAgICBsZXQgdSA9ICEwLCBkID0gITE7XG4gICAgICBpZiAoYyA9PSBzLmxlbmd0aCB8fCBsIDwgc1tjXS5mcm9tKSB7XG4gICAgICAgIGxldCBPID0gcnRbbF07XG4gICAgICAgIE8gIT0gYSAmJiAodSA9ICExLCBkID0gTyA9PSAxNik7XG4gICAgICB9XG4gICAgICBsZXQgZiA9ICF1ICYmIGEgPT0gMSA/IFtdIDogbnVsbCwgaCA9IHUgPyByIDogciArIDEsIHAgPSBsO1xuICAgICAgZTpcbiAgICAgICAgZm9yICg7IDsgKVxuICAgICAgICAgIGlmIChjIDwgcy5sZW5ndGggJiYgcCA9PSBzW2NdLmZyb20pIHtcbiAgICAgICAgICAgIGlmIChkKVxuICAgICAgICAgICAgICBicmVhayBlO1xuICAgICAgICAgICAgbGV0IE8gPSBzW2NdO1xuICAgICAgICAgICAgaWYgKCF1KVxuICAgICAgICAgICAgICBmb3IgKGxldCBtID0gTy50bywgeSA9IGMgKyAxOyA7ICkge1xuICAgICAgICAgICAgICAgIGlmIChtID09IG4pXG4gICAgICAgICAgICAgICAgICBicmVhayBlO1xuICAgICAgICAgICAgICAgIGlmICh5IDwgcy5sZW5ndGggJiYgc1t5XS5mcm9tID09IG0pXG4gICAgICAgICAgICAgICAgICBtID0gc1t5KytdLnRvO1xuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKHJ0W21dID09IGEpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrIGU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjKyssIGYpXG4gICAgICAgICAgICAgIGYucHVzaChPKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBPLmZyb20gPiBsICYmIG8ucHVzaChuZXcgQmkobCwgTy5mcm9tLCBoKSk7XG4gICAgICAgICAgICAgIGxldCBtID0gTy5kaXJlY3Rpb24gPT0genMgIT0gIShoICUgMik7XG4gICAgICAgICAgICAgIGRwKHQsIG0gPyByICsgMSA6IHIsIGksIE8uaW5uZXIsIE8uZnJvbSwgTy50bywgbyksIGwgPSBPLnRvO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcCA9IE8udG87XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwID09IG4gfHwgKHUgPyBydFtwXSAhPSBhIDogcnRbcF0gPT0gYSkpXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcCsrO1xuICAgICAgICAgIH1cbiAgICAgIGYgPyB1cCh0LCBsLCBwLCByICsgMSwgaSwgZiwgbykgOiBsIDwgcCAmJiBvLnB1c2gobmV3IEJpKGwsIHAsIGgpKSwgbCA9IHA7XG4gICAgfVxuICBlbHNlXG4gICAgZm9yIChsZXQgbCA9IG4sIGMgPSBzLmxlbmd0aDsgbCA+IGU7ICkge1xuICAgICAgbGV0IHUgPSAhMCwgZCA9ICExO1xuICAgICAgaWYgKCFjIHx8IGwgPiBzW2MgLSAxXS50bykge1xuICAgICAgICBsZXQgTyA9IHJ0W2wgLSAxXTtcbiAgICAgICAgTyAhPSBhICYmICh1ID0gITEsIGQgPSBPID09IDE2KTtcbiAgICAgIH1cbiAgICAgIGxldCBmID0gIXUgJiYgYSA9PSAxID8gW10gOiBudWxsLCBoID0gdSA/IHIgOiByICsgMSwgcCA9IGw7XG4gICAgICBlOlxuICAgICAgICBmb3IgKDsgOyApXG4gICAgICAgICAgaWYgKGMgJiYgcCA9PSBzW2MgLSAxXS50bykge1xuICAgICAgICAgICAgaWYgKGQpXG4gICAgICAgICAgICAgIGJyZWFrIGU7XG4gICAgICAgICAgICBsZXQgTyA9IHNbLS1jXTtcbiAgICAgICAgICAgIGlmICghdSlcbiAgICAgICAgICAgICAgZm9yIChsZXQgbSA9IE8uZnJvbSwgeSA9IGM7IDsgKSB7XG4gICAgICAgICAgICAgICAgaWYgKG0gPT0gZSlcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGU7XG4gICAgICAgICAgICAgICAgaWYgKHkgJiYgc1t5IC0gMV0udG8gPT0gbSlcbiAgICAgICAgICAgICAgICAgIG0gPSBzWy0teV0uZnJvbTtcbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlmIChydFttIC0gMV0gPT0gYSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWsgZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGYpXG4gICAgICAgICAgICAgIGYucHVzaChPKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBPLnRvIDwgbCAmJiBvLnB1c2gobmV3IEJpKE8udG8sIGwsIGgpKTtcbiAgICAgICAgICAgICAgbGV0IG0gPSBPLmRpcmVjdGlvbiA9PSB6cyAhPSAhKGggJSAyKTtcbiAgICAgICAgICAgICAgZHAodCwgbSA/IHIgKyAxIDogciwgaSwgTy5pbm5lciwgTy5mcm9tLCBPLnRvLCBvKSwgbCA9IE8uZnJvbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAgPSBPLmZyb207XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwID09IGUgfHwgKHUgPyBydFtwIC0gMV0gIT0gYSA6IHJ0W3AgLSAxXSA9PSBhKSlcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBwLS07XG4gICAgICAgICAgfVxuICAgICAgZiA/IHVwKHQsIHAsIGwsIHIgKyAxLCBpLCBmLCBvKSA6IHAgPCBsICYmIG8ucHVzaChuZXcgQmkocCwgbCwgaCkpLCBsID0gcDtcbiAgICB9XG59XG5mdW5jdGlvbiBkcCh0LCBlLCBuLCByLCBpLCBzLCBvKSB7XG4gIGxldCBhID0gZSAlIDIgPyAyIDogMTtcbiAgUk4odCwgaSwgcywgciwgYSksIE5OKHQsIGksIHMsIHIsIGEpLCBETihpLCBzLCByLCBhKSwgdXAodCwgaSwgcywgZSwgbiwgciwgbyk7XG59XG5mdW5jdGlvbiBaTih0LCBlLCBuKSB7XG4gIGlmICghdClcbiAgICByZXR1cm4gW25ldyBCaSgwLCAwLCBlID09IGxnID8gMSA6IDApXTtcbiAgaWYgKGUgPT0genMgJiYgIW4ubGVuZ3RoICYmICFBTi50ZXN0KHQpKVxuICAgIHJldHVybiBwayh0Lmxlbmd0aCk7XG4gIGlmIChuLmxlbmd0aClcbiAgICBmb3IgKDsgdC5sZW5ndGggPiBydC5sZW5ndGg7IClcbiAgICAgIHJ0W3J0Lmxlbmd0aF0gPSAyNTY7XG4gIGxldCByID0gW10sIGkgPSBlID09IHpzID8gMCA6IDE7XG4gIHJldHVybiBkcCh0LCBpLCBpLCBuLCAwLCB0Lmxlbmd0aCwgciksIHI7XG59XG5mdW5jdGlvbiBwayh0KSB7XG4gIHJldHVybiBbbmV3IEJpKDAsIHQsIDApXTtcbn1cbmxldCBPayA9IFwiXCI7XG5mdW5jdGlvbiBWTih0LCBlLCBuLCByLCBpKSB7XG4gIHZhciBzO1xuICBsZXQgbyA9IHIuaGVhZCAtIHQuZnJvbSwgYSA9IEJpLmZpbmQoZSwgbywgKHMgPSByLmJpZGlMZXZlbCkgIT09IG51bGwgJiYgcyAhPT0gdm9pZCAwID8gcyA6IC0xLCByLmFzc29jKSwgbCA9IGVbYV0sIGMgPSBsLnNpZGUoaSwgbik7XG4gIGlmIChvID09IGMpIHtcbiAgICBsZXQgZiA9IGEgKz0gaSA/IDEgOiAtMTtcbiAgICBpZiAoZiA8IDAgfHwgZiA+PSBlLmxlbmd0aClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGwgPSBlW2EgPSBmXSwgbyA9IGwuc2lkZSghaSwgbiksIGMgPSBsLnNpZGUoaSwgbik7XG4gIH1cbiAgbGV0IHUgPSBScih0LnRleHQsIG8sIGwuZm9yd2FyZChpLCBuKSk7XG4gICh1IDwgbC5mcm9tIHx8IHUgPiBsLnRvKSAmJiAodSA9IGMpLCBPayA9IHQudGV4dC5zbGljZShNYXRoLm1pbihvLCB1KSwgTWF0aC5tYXgobywgdSkpO1xuICBsZXQgZCA9IGEgPT0gKGkgPyBlLmxlbmd0aCAtIDEgOiAwKSA/IG51bGwgOiBlW2EgKyAoaSA/IDEgOiAtMSldO1xuICByZXR1cm4gZCAmJiB1ID09IGMgJiYgZC5sZXZlbCArIChpID8gMCA6IDEpIDwgbC5sZXZlbCA/IGFlLmN1cnNvcihkLnNpZGUoIWksIG4pICsgdC5mcm9tLCBkLmZvcndhcmQoaSwgbikgPyAxIDogLTEsIGQubGV2ZWwpIDogYWUuY3Vyc29yKHUgKyB0LmZyb20sIGwuZm9yd2FyZChpLCBuKSA/IC0xIDogMSwgbC5sZXZlbCk7XG59XG5mdW5jdGlvbiBJTih0LCBlLCBuKSB7XG4gIGZvciAobGV0IHIgPSBlOyByIDwgbjsgcisrKSB7XG4gICAgbGV0IGkgPSBmayh0LmNoYXJDb2RlQXQocikpO1xuICAgIGlmIChpID09IDEpXG4gICAgICByZXR1cm4genM7XG4gICAgaWYgKGkgPT0gMiB8fCBpID09IDQpXG4gICAgICByZXR1cm4gbGc7XG4gIH1cbiAgcmV0dXJuIHpzO1xufVxuY29uc3QgZ2sgPSAvKiBAX19QVVJFX18gKi8gdmUuZGVmaW5lKCksIG1rID0gLyogQF9fUFVSRV9fICovIHZlLmRlZmluZSgpLCBiayA9IC8qIEBfX1BVUkVfXyAqLyB2ZS5kZWZpbmUoKSwgdmsgPSAvKiBAX19QVVJFX18gKi8gdmUuZGVmaW5lKCksIGZwID0gLyogQF9fUFVSRV9fICovIHZlLmRlZmluZSgpLCB5ayA9IC8qIEBfX1BVUkVfXyAqLyB2ZS5kZWZpbmUoKSwgU2sgPSAvKiBAX19QVVJFX18gKi8gdmUuZGVmaW5lKCksIHdrID0gLyogQF9fUFVSRV9fICovIHZlLmRlZmluZSh7XG4gIGNvbWJpbmU6ICh0KSA9PiB0LnNvbWUoKGUpID0+IGUpXG59KSwgV04gPSAvKiBAX19QVVJFX18gKi8gdmUuZGVmaW5lKHtcbiAgY29tYmluZTogKHQpID0+IHQuc29tZSgoZSkgPT4gZSlcbn0pO1xuY2xhc3MgRW8ge1xuICBjb25zdHJ1Y3RvcihlLCBuID0gXCJuZWFyZXN0XCIsIHIgPSBcIm5lYXJlc3RcIiwgaSA9IDUsIHMgPSA1LCBvID0gITEpIHtcbiAgICB0aGlzLnJhbmdlID0gZSwgdGhpcy55ID0gbiwgdGhpcy54ID0gciwgdGhpcy55TWFyZ2luID0gaSwgdGhpcy54TWFyZ2luID0gcywgdGhpcy5pc1NuYXBzaG90ID0gbztcbiAgfVxuICBtYXAoZSkge1xuICAgIHJldHVybiBlLmVtcHR5ID8gdGhpcyA6IG5ldyBFbyh0aGlzLnJhbmdlLm1hcChlKSwgdGhpcy55LCB0aGlzLngsIHRoaXMueU1hcmdpbiwgdGhpcy54TWFyZ2luLCB0aGlzLmlzU25hcHNob3QpO1xuICB9XG4gIGNsaXAoZSkge1xuICAgIHJldHVybiB0aGlzLnJhbmdlLnRvIDw9IGUuZG9jLmxlbmd0aCA/IHRoaXMgOiBuZXcgRW8oYWUuY3Vyc29yKGUuZG9jLmxlbmd0aCksIHRoaXMueSwgdGhpcy54LCB0aGlzLnlNYXJnaW4sIHRoaXMueE1hcmdpbiwgdGhpcy5pc1NuYXBzaG90KTtcbiAgfVxufVxuY29uc3QgX2MgPSAvKiBAX19QVVJFX18gKi8gb3QuZGVmaW5lKHsgbWFwOiAodCwgZSkgPT4gdC5tYXAoZSkgfSk7XG5mdW5jdGlvbiBocih0LCBlLCBuKSB7XG4gIGxldCByID0gdC5mYWNldCh2ayk7XG4gIHIubGVuZ3RoID8gclswXShlKSA6IHdpbmRvdy5vbmVycm9yID8gd2luZG93Lm9uZXJyb3IoU3RyaW5nKGUpLCBuLCB2b2lkIDAsIHZvaWQgMCwgZSkgOiBuID8gY29uc29sZS5lcnJvcihuICsgXCI6XCIsIGUpIDogY29uc29sZS5lcnJvcihlKTtcbn1cbmNvbnN0IFlkID0gLyogQF9fUFVSRV9fICovIHZlLmRlZmluZSh7IGNvbWJpbmU6ICh0KSA9PiB0Lmxlbmd0aCA/IHRbMF0gOiAhMCB9KTtcbmxldCBNTiA9IDA7XG5jb25zdCBSYSA9IC8qIEBfX1BVUkVfXyAqLyB2ZS5kZWZpbmUoKTtcbmNsYXNzIHJyIHtcbiAgY29uc3RydWN0b3IoZSwgbiwgciwgaSwgcykge1xuICAgIHRoaXMuaWQgPSBlLCB0aGlzLmNyZWF0ZSA9IG4sIHRoaXMuZG9tRXZlbnRIYW5kbGVycyA9IHIsIHRoaXMuZG9tRXZlbnRPYnNlcnZlcnMgPSBpLCB0aGlzLmV4dGVuc2lvbiA9IHModGhpcyk7XG4gIH1cbiAgLyoqXG4gIERlZmluZSBhIHBsdWdpbiBmcm9tIGEgY29uc3RydWN0b3IgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIHRoZVxuICBwbHVnaW4ncyB2YWx1ZSwgZ2l2ZW4gYW4gZWRpdG9yIHZpZXcuXG4gICovXG4gIHN0YXRpYyBkZWZpbmUoZSwgbikge1xuICAgIGNvbnN0IHsgZXZlbnRIYW5kbGVyczogciwgZXZlbnRPYnNlcnZlcnM6IGksIHByb3ZpZGU6IHMsIGRlY29yYXRpb25zOiBvIH0gPSBuIHx8IHt9O1xuICAgIHJldHVybiBuZXcgcnIoTU4rKywgZSwgciwgaSwgKGEpID0+IHtcbiAgICAgIGxldCBsID0gW1JhLm9mKGEpXTtcbiAgICAgIHJldHVybiBvICYmIGwucHVzaChtbC5vZigoYykgPT4ge1xuICAgICAgICBsZXQgdSA9IGMucGx1Z2luKGEpO1xuICAgICAgICByZXR1cm4gdSA/IG8odSkgOiBKZS5ub25lO1xuICAgICAgfSkpLCBzICYmIGwucHVzaChzKGEpKSwgbDtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgQ3JlYXRlIGEgcGx1Z2luIGZvciBhIGNsYXNzIHdob3NlIGNvbnN0cnVjdG9yIHRha2VzIGEgc2luZ2xlXG4gIGVkaXRvciB2aWV3IGFzIGFyZ3VtZW50LlxuICAqL1xuICBzdGF0aWMgZnJvbUNsYXNzKGUsIG4pIHtcbiAgICByZXR1cm4gcnIuZGVmaW5lKChyKSA9PiBuZXcgZShyKSwgbik7XG4gIH1cbn1cbmNsYXNzIFBmIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMuc3BlYyA9IGUsIHRoaXMubXVzdFVwZGF0ZSA9IG51bGwsIHRoaXMudmFsdWUgPSBudWxsO1xuICB9XG4gIHVwZGF0ZShlKSB7XG4gICAgaWYgKHRoaXMudmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLm11c3RVcGRhdGUpIHtcbiAgICAgICAgbGV0IG4gPSB0aGlzLm11c3RVcGRhdGU7XG4gICAgICAgIGlmICh0aGlzLm11c3RVcGRhdGUgPSBudWxsLCB0aGlzLnZhbHVlLnVwZGF0ZSlcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZS51cGRhdGUobik7XG4gICAgICAgICAgfSBjYXRjaCAocikge1xuICAgICAgICAgICAgaWYgKGhyKG4uc3RhdGUsIHIsIFwiQ29kZU1pcnJvciBwbHVnaW4gY3Jhc2hlZFwiKSwgdGhpcy52YWx1ZS5kZXN0cm95KVxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUuZGVzdHJveSgpO1xuICAgICAgICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kZWFjdGl2YXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5zcGVjKVxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMuc3BlYy5jcmVhdGUoZSk7XG4gICAgICB9IGNhdGNoIChuKSB7XG4gICAgICAgIGhyKGUuc3RhdGUsIG4sIFwiQ29kZU1pcnJvciBwbHVnaW4gY3Jhc2hlZFwiKSwgdGhpcy5kZWFjdGl2YXRlKCk7XG4gICAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZGVzdHJveShlKSB7XG4gICAgdmFyIG47XG4gICAgaWYgKCEoKG4gPSB0aGlzLnZhbHVlKSA9PT0gbnVsbCB8fCBuID09PSB2b2lkIDApICYmIG4uZGVzdHJveSlcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMudmFsdWUuZGVzdHJveSgpO1xuICAgICAgfSBjYXRjaCAocikge1xuICAgICAgICBocihlLnN0YXRlLCByLCBcIkNvZGVNaXJyb3IgcGx1Z2luIGNyYXNoZWRcIik7XG4gICAgICB9XG4gIH1cbiAgZGVhY3RpdmF0ZSgpIHtcbiAgICB0aGlzLnNwZWMgPSB0aGlzLnZhbHVlID0gbnVsbDtcbiAgfVxufVxuY29uc3Qga2sgPSAvKiBAX19QVVJFX18gKi8gdmUuZGVmaW5lKCksIGNnID0gLyogQF9fUFVSRV9fICovIHZlLmRlZmluZSgpLCBtbCA9IC8qIEBfX1BVUkVfXyAqLyB2ZS5kZWZpbmUoKSwgeGsgPSAvKiBAX19QVVJFX18gKi8gdmUuZGVmaW5lKCksIHVnID0gLyogQF9fUFVSRV9fICovIHZlLmRlZmluZSgpLCBQayA9IC8qIEBfX1BVUkVfXyAqLyB2ZS5kZWZpbmUoKTtcbmZ1bmN0aW9uIEtiKHQsIGUpIHtcbiAgbGV0IG4gPSB0LnN0YXRlLmZhY2V0KFBrKTtcbiAgaWYgKCFuLmxlbmd0aClcbiAgICByZXR1cm4gbjtcbiAgbGV0IHIgPSBuLm1hcCgocykgPT4gcyBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gcyh0KSA6IHMpLCBpID0gW107XG4gIHJldHVybiB6ZS5zcGFucyhyLCBlLmZyb20sIGUudG8sIHtcbiAgICBwb2ludCgpIHtcbiAgICB9LFxuICAgIHNwYW4ocywgbywgYSwgbCkge1xuICAgICAgbGV0IGMgPSBzIC0gZS5mcm9tLCB1ID0gbyAtIGUuZnJvbSwgZCA9IGk7XG4gICAgICBmb3IgKGxldCBmID0gYS5sZW5ndGggLSAxOyBmID49IDA7IGYtLSwgbC0tKSB7XG4gICAgICAgIGxldCBoID0gYVtmXS5zcGVjLmJpZGlJc29sYXRlLCBwO1xuICAgICAgICBpZiAoaCA9PSBudWxsICYmIChoID0gSU4oZS50ZXh0LCBjLCB1KSksIGwgPiAwICYmIGQubGVuZ3RoICYmIChwID0gZFtkLmxlbmd0aCAtIDFdKS50byA9PSBjICYmIHAuZGlyZWN0aW9uID09IGgpXG4gICAgICAgICAgcC50byA9IHUsIGQgPSBwLmlubmVyO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBsZXQgTyA9IHsgZnJvbTogYywgdG86IHUsIGRpcmVjdGlvbjogaCwgaW5uZXI6IFtdIH07XG4gICAgICAgICAgZC5wdXNoKE8pLCBkID0gTy5pbm5lcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSksIGk7XG59XG5jb25zdCBfayA9IC8qIEBfX1BVUkVfXyAqLyB2ZS5kZWZpbmUoKTtcbmZ1bmN0aW9uIFRrKHQpIHtcbiAgbGV0IGUgPSAwLCBuID0gMCwgciA9IDAsIGkgPSAwO1xuICBmb3IgKGxldCBzIG9mIHQuc3RhdGUuZmFjZXQoX2spKSB7XG4gICAgbGV0IG8gPSBzKHQpO1xuICAgIG8gJiYgKG8ubGVmdCAhPSBudWxsICYmIChlID0gTWF0aC5tYXgoZSwgby5sZWZ0KSksIG8ucmlnaHQgIT0gbnVsbCAmJiAobiA9IE1hdGgubWF4KG4sIG8ucmlnaHQpKSwgby50b3AgIT0gbnVsbCAmJiAociA9IE1hdGgubWF4KHIsIG8udG9wKSksIG8uYm90dG9tICE9IG51bGwgJiYgKGkgPSBNYXRoLm1heChpLCBvLmJvdHRvbSkpKTtcbiAgfVxuICByZXR1cm4geyBsZWZ0OiBlLCByaWdodDogbiwgdG9wOiByLCBib3R0b206IGkgfTtcbn1cbmNvbnN0IE5hID0gLyogQF9fUFVSRV9fICovIHZlLmRlZmluZSgpO1xuY2xhc3MgdHIge1xuICBjb25zdHJ1Y3RvcihlLCBuLCByLCBpKSB7XG4gICAgdGhpcy5mcm9tQSA9IGUsIHRoaXMudG9BID0gbiwgdGhpcy5mcm9tQiA9IHIsIHRoaXMudG9CID0gaTtcbiAgfVxuICBqb2luKGUpIHtcbiAgICByZXR1cm4gbmV3IHRyKE1hdGgubWluKHRoaXMuZnJvbUEsIGUuZnJvbUEpLCBNYXRoLm1heCh0aGlzLnRvQSwgZS50b0EpLCBNYXRoLm1pbih0aGlzLmZyb21CLCBlLmZyb21CKSwgTWF0aC5tYXgodGhpcy50b0IsIGUudG9CKSk7XG4gIH1cbiAgYWRkVG9TZXQoZSkge1xuICAgIGxldCBuID0gZS5sZW5ndGgsIHIgPSB0aGlzO1xuICAgIGZvciAoOyBuID4gMDsgbi0tKSB7XG4gICAgICBsZXQgaSA9IGVbbiAtIDFdO1xuICAgICAgaWYgKCEoaS5mcm9tQSA+IHIudG9BKSkge1xuICAgICAgICBpZiAoaS50b0EgPCByLmZyb21BKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICByID0gci5qb2luKGkpLCBlLnNwbGljZShuIC0gMSwgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlLnNwbGljZShuLCAwLCByKSwgZTtcbiAgfVxuICBzdGF0aWMgZXh0ZW5kV2l0aFJhbmdlcyhlLCBuKSB7XG4gICAgaWYgKG4ubGVuZ3RoID09IDApXG4gICAgICByZXR1cm4gZTtcbiAgICBsZXQgciA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBzID0gMCwgbyA9IDAsIGEgPSAwOyA7IGkrKykge1xuICAgICAgbGV0IGwgPSBpID09IGUubGVuZ3RoID8gbnVsbCA6IGVbaV0sIGMgPSBvIC0gYSwgdSA9IGwgPyBsLmZyb21CIDogMWU5O1xuICAgICAgZm9yICg7IHMgPCBuLmxlbmd0aCAmJiBuW3NdIDwgdTsgKSB7XG4gICAgICAgIGxldCBkID0gbltzXSwgZiA9IG5bcyArIDFdLCBoID0gTWF0aC5tYXgoYSwgZCksIHAgPSBNYXRoLm1pbih1LCBmKTtcbiAgICAgICAgaWYgKGggPD0gcCAmJiBuZXcgdHIoaCArIGMsIHAgKyBjLCBoLCBwKS5hZGRUb1NldChyKSwgZiA+IHUpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIHMgKz0gMjtcbiAgICAgIH1cbiAgICAgIGlmICghbClcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICBuZXcgdHIobC5mcm9tQSwgbC50b0EsIGwuZnJvbUIsIGwudG9CKS5hZGRUb1NldChyKSwgbyA9IGwudG9BLCBhID0gbC50b0I7XG4gICAgfVxuICB9XG59XG5jbGFzcyBXdSB7XG4gIGNvbnN0cnVjdG9yKGUsIG4sIHIpIHtcbiAgICB0aGlzLnZpZXcgPSBlLCB0aGlzLnN0YXRlID0gbiwgdGhpcy50cmFuc2FjdGlvbnMgPSByLCB0aGlzLmZsYWdzID0gMCwgdGhpcy5zdGFydFN0YXRlID0gZS5zdGF0ZSwgdGhpcy5jaGFuZ2VzID0gTXQuZW1wdHkodGhpcy5zdGFydFN0YXRlLmRvYy5sZW5ndGgpO1xuICAgIGZvciAobGV0IHMgb2YgcilcbiAgICAgIHRoaXMuY2hhbmdlcyA9IHRoaXMuY2hhbmdlcy5jb21wb3NlKHMuY2hhbmdlcyk7XG4gICAgbGV0IGkgPSBbXTtcbiAgICB0aGlzLmNoYW5nZXMuaXRlckNoYW5nZWRSYW5nZXMoKHMsIG8sIGEsIGwpID0+IGkucHVzaChuZXcgdHIocywgbywgYSwgbCkpKSwgdGhpcy5jaGFuZ2VkUmFuZ2VzID0gaTtcbiAgfVxuICAvKipcbiAgQGludGVybmFsXG4gICovXG4gIHN0YXRpYyBjcmVhdGUoZSwgbiwgcikge1xuICAgIHJldHVybiBuZXcgV3UoZSwgbiwgcik7XG4gIH1cbiAgLyoqXG4gIFRlbGxzIHlvdSB3aGV0aGVyIHRoZSBbdmlld3BvcnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnZpZXdwb3J0KSBvclxuICBbdmlzaWJsZSByYW5nZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LnZpc2libGVSYW5nZXMpIGNoYW5nZWQgaW4gdGhpc1xuICB1cGRhdGUuXG4gICovXG4gIGdldCB2aWV3cG9ydENoYW5nZWQoKSB7XG4gICAgcmV0dXJuICh0aGlzLmZsYWdzICYgNCkgPiAwO1xuICB9XG4gIC8qKlxuICBJbmRpY2F0ZXMgd2hldGhlciB0aGUgaGVpZ2h0IG9mIGEgYmxvY2sgZWxlbWVudCBpbiB0aGUgZWRpdG9yXG4gIGNoYW5nZWQgaW4gdGhpcyB1cGRhdGUuXG4gICovXG4gIGdldCBoZWlnaHRDaGFuZ2VkKCkge1xuICAgIHJldHVybiAodGhpcy5mbGFncyAmIDIpID4gMDtcbiAgfVxuICAvKipcbiAgUmV0dXJucyB0cnVlIHdoZW4gdGhlIGRvY3VtZW50IHdhcyBtb2RpZmllZCBvciB0aGUgc2l6ZSBvZiB0aGVcbiAgZWRpdG9yLCBvciBlbGVtZW50cyB3aXRoaW4gdGhlIGVkaXRvciwgY2hhbmdlZC5cbiAgKi9cbiAgZ2V0IGdlb21ldHJ5Q2hhbmdlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5kb2NDaGFuZ2VkIHx8ICh0aGlzLmZsYWdzICYgMTApID4gMDtcbiAgfVxuICAvKipcbiAgVHJ1ZSB3aGVuIHRoaXMgdXBkYXRlIGluZGljYXRlcyBhIGZvY3VzIGNoYW5nZS5cbiAgKi9cbiAgZ2V0IGZvY3VzQ2hhbmdlZCgpIHtcbiAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiAxKSA+IDA7XG4gIH1cbiAgLyoqXG4gIFdoZXRoZXIgdGhlIGRvY3VtZW50IGNoYW5nZWQgaW4gdGhpcyB1cGRhdGUuXG4gICovXG4gIGdldCBkb2NDaGFuZ2VkKCkge1xuICAgIHJldHVybiAhdGhpcy5jaGFuZ2VzLmVtcHR5O1xuICB9XG4gIC8qKlxuICBXaGV0aGVyIHRoZSBzZWxlY3Rpb24gd2FzIGV4cGxpY2l0bHkgc2V0IGluIHRoaXMgdXBkYXRlLlxuICAqL1xuICBnZXQgc2VsZWN0aW9uU2V0KCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zYWN0aW9ucy5zb21lKChlKSA9PiBlLnNlbGVjdGlvbik7XG4gIH1cbiAgLyoqXG4gIEBpbnRlcm5hbFxuICAqL1xuICBnZXQgZW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmxhZ3MgPT0gMCAmJiB0aGlzLnRyYW5zYWN0aW9ucy5sZW5ndGggPT0gMDtcbiAgfVxufVxuY2xhc3MgSmIgZXh0ZW5kcyBmdCB7XG4gIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5zdGF0ZS5kb2MubGVuZ3RoO1xuICB9XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcigpLCB0aGlzLnZpZXcgPSBlLCB0aGlzLmRlY29yYXRpb25zID0gW10sIHRoaXMuZHluYW1pY0RlY29yYXRpb25NYXAgPSBbXSwgdGhpcy5kb21DaGFuZ2VkID0gbnVsbCwgdGhpcy5oYXNDb21wb3NpdGlvbiA9IG51bGwsIHRoaXMubWFya2VkRm9yQ29tcG9zaXRpb24gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLCB0aGlzLm1pbldpZHRoID0gMCwgdGhpcy5taW5XaWR0aEZyb20gPSAwLCB0aGlzLm1pbldpZHRoVG8gPSAwLCB0aGlzLmltcHJlY2lzZUFuY2hvciA9IG51bGwsIHRoaXMuaW1wcmVjaXNlSGVhZCA9IG51bGwsIHRoaXMuZm9yY2VTZWxlY3Rpb24gPSAhMSwgdGhpcy5sYXN0VXBkYXRlID0gRGF0ZS5ub3coKSwgdGhpcy5zZXRET00oZS5jb250ZW50RE9NKSwgdGhpcy5jaGlsZHJlbiA9IFtuZXcgTnQoKV0sIHRoaXMuY2hpbGRyZW5bMF0uc2V0UGFyZW50KHRoaXMpLCB0aGlzLnVwZGF0ZURlY28oKSwgdGhpcy51cGRhdGVJbm5lcihbbmV3IHRyKDAsIDAsIDAsIGUuc3RhdGUuZG9jLmxlbmd0aCldLCAwLCBudWxsKTtcbiAgfVxuICAvLyBVcGRhdGUgdGhlIGRvY3VtZW50IHZpZXcgdG8gYSBnaXZlbiBzdGF0ZS5cbiAgdXBkYXRlKGUpIHtcbiAgICB2YXIgbjtcbiAgICBsZXQgciA9IGUuY2hhbmdlZFJhbmdlcztcbiAgICB0aGlzLm1pbldpZHRoID4gMCAmJiByLmxlbmd0aCAmJiAoci5ldmVyeSgoeyBmcm9tQTogYywgdG9BOiB1IH0pID0+IHUgPCB0aGlzLm1pbldpZHRoRnJvbSB8fCBjID4gdGhpcy5taW5XaWR0aFRvKSA/ICh0aGlzLm1pbldpZHRoRnJvbSA9IGUuY2hhbmdlcy5tYXBQb3ModGhpcy5taW5XaWR0aEZyb20sIDEpLCB0aGlzLm1pbldpZHRoVG8gPSBlLmNoYW5nZXMubWFwUG9zKHRoaXMubWluV2lkdGhUbywgMSkpIDogdGhpcy5taW5XaWR0aCA9IHRoaXMubWluV2lkdGhGcm9tID0gdGhpcy5taW5XaWR0aFRvID0gMCk7XG4gICAgbGV0IGkgPSAtMTtcbiAgICB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPj0gMCAmJiAoISgobiA9IHRoaXMuZG9tQ2hhbmdlZCkgPT09IG51bGwgfHwgbiA9PT0gdm9pZCAwKSAmJiBuLm5ld1NlbCA/IGkgPSB0aGlzLmRvbUNoYW5nZWQubmV3U2VsLmhlYWQgOiAhWU4oZS5jaGFuZ2VzLCB0aGlzLmhhc0NvbXBvc2l0aW9uKSAmJiAhZS5zZWxlY3Rpb25TZXQgJiYgKGkgPSBlLnN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpKTtcbiAgICBsZXQgcyA9IGkgPiAtMSA/IGpOKHRoaXMudmlldywgZS5jaGFuZ2VzLCBpKSA6IG51bGw7XG4gICAgaWYgKHRoaXMuZG9tQ2hhbmdlZCA9IG51bGwsIHRoaXMuaGFzQ29tcG9zaXRpb24pIHtcbiAgICAgIHRoaXMubWFya2VkRm9yQ29tcG9zaXRpb24uY2xlYXIoKTtcbiAgICAgIGxldCB7IGZyb206IGMsIHRvOiB1IH0gPSB0aGlzLmhhc0NvbXBvc2l0aW9uO1xuICAgICAgciA9IG5ldyB0cihjLCB1LCBlLmNoYW5nZXMubWFwUG9zKGMsIC0xKSwgZS5jaGFuZ2VzLm1hcFBvcyh1LCAxKSkuYWRkVG9TZXQoci5zbGljZSgpKTtcbiAgICB9XG4gICAgdGhpcy5oYXNDb21wb3NpdGlvbiA9IHMgPyB7IGZyb206IHMucmFuZ2UuZnJvbUIsIHRvOiBzLnJhbmdlLnRvQiB9IDogbnVsbCwgKGRlLmllIHx8IGRlLmNocm9tZSkgJiYgIXMgJiYgZSAmJiBlLnN0YXRlLmRvYy5saW5lcyAhPSBlLnN0YXJ0U3RhdGUuZG9jLmxpbmVzICYmICh0aGlzLmZvcmNlU2VsZWN0aW9uID0gITApO1xuICAgIGxldCBvID0gdGhpcy5kZWNvcmF0aW9ucywgYSA9IHRoaXMudXBkYXRlRGVjbygpLCBsID0gVU4obywgYSwgZS5jaGFuZ2VzKTtcbiAgICByZXR1cm4gciA9IHRyLmV4dGVuZFdpdGhSYW5nZXMociwgbCksICEodGhpcy5mbGFncyAmIDcpICYmIHIubGVuZ3RoID09IDAgPyAhMSA6ICh0aGlzLnVwZGF0ZUlubmVyKHIsIGUuc3RhcnRTdGF0ZS5kb2MubGVuZ3RoLCBzKSwgZS50cmFuc2FjdGlvbnMubGVuZ3RoICYmICh0aGlzLmxhc3RVcGRhdGUgPSBEYXRlLm5vdygpKSwgITApO1xuICB9XG4gIC8vIFVzZWQgYnkgdXBkYXRlIGFuZCB0aGUgY29uc3RydWN0b3IgZG8gcGVyZm9ybSB0aGUgYWN0dWFsIERPTVxuICAvLyB1cGRhdGVcbiAgdXBkYXRlSW5uZXIoZSwgbiwgcikge1xuICAgIHRoaXMudmlldy52aWV3U3RhdGUubXVzdE1lYXN1cmVDb250ZW50ID0gITAsIHRoaXMudXBkYXRlQ2hpbGRyZW4oZSwgbiwgcik7XG4gICAgbGV0IHsgb2JzZXJ2ZXI6IGkgfSA9IHRoaXMudmlldztcbiAgICBpLmlnbm9yZSgoKSA9PiB7XG4gICAgICB0aGlzLmRvbS5zdHlsZS5oZWlnaHQgPSB0aGlzLnZpZXcudmlld1N0YXRlLmNvbnRlbnRIZWlnaHQgLyB0aGlzLnZpZXcuc2NhbGVZICsgXCJweFwiLCB0aGlzLmRvbS5zdHlsZS5mbGV4QmFzaXMgPSB0aGlzLm1pbldpZHRoID8gdGhpcy5taW5XaWR0aCArIFwicHhcIiA6IFwiXCI7XG4gICAgICBsZXQgbyA9IGRlLmNocm9tZSB8fCBkZS5pb3MgPyB7IG5vZGU6IGkuc2VsZWN0aW9uUmFuZ2UuZm9jdXNOb2RlLCB3cml0dGVuOiAhMSB9IDogdm9pZCAwO1xuICAgICAgdGhpcy5zeW5jKHRoaXMudmlldywgbyksIHRoaXMuZmxhZ3MgJj0gLTgsIG8gJiYgKG8ud3JpdHRlbiB8fCBpLnNlbGVjdGlvblJhbmdlLmZvY3VzTm9kZSAhPSBvLm5vZGUpICYmICh0aGlzLmZvcmNlU2VsZWN0aW9uID0gITApLCB0aGlzLmRvbS5zdHlsZS5oZWlnaHQgPSBcIlwiO1xuICAgIH0pLCB0aGlzLm1hcmtlZEZvckNvbXBvc2l0aW9uLmZvckVhY2goXG4gICAgICAobykgPT4gby5mbGFncyAmPSAtOVxuICAgICAgLyogVmlld0ZsYWcuQ29tcG9zaXRpb24gKi9cbiAgICApO1xuICAgIGxldCBzID0gW107XG4gICAgaWYgKHRoaXMudmlldy52aWV3cG9ydC5mcm9tIHx8IHRoaXMudmlldy52aWV3cG9ydC50byA8IHRoaXMudmlldy5zdGF0ZS5kb2MubGVuZ3RoKVxuICAgICAgZm9yIChsZXQgbyBvZiB0aGlzLmNoaWxkcmVuKVxuICAgICAgICBvIGluc3RhbmNlb2YgS2kgJiYgby53aWRnZXQgaW5zdGFuY2VvZiBldiAmJiBzLnB1c2goby5kb20pO1xuICAgIGkudXBkYXRlR2FwcyhzKTtcbiAgfVxuICB1cGRhdGVDaGlsZHJlbihlLCBuLCByKSB7XG4gICAgbGV0IGkgPSByID8gci5yYW5nZS5hZGRUb1NldChlLnNsaWNlKCkpIDogZSwgcyA9IHRoaXMuY2hpbGRDdXJzb3Iobik7XG4gICAgZm9yIChsZXQgbyA9IGkubGVuZ3RoIC0gMTsgOyBvLS0pIHtcbiAgICAgIGxldCBhID0gbyA+PSAwID8gaVtvXSA6IG51bGw7XG4gICAgICBpZiAoIWEpXG4gICAgICAgIGJyZWFrO1xuICAgICAgbGV0IHsgZnJvbUE6IGwsIHRvQTogYywgZnJvbUI6IHUsIHRvQjogZCB9ID0gYSwgZiwgaCwgcCwgTztcbiAgICAgIGlmIChyICYmIHIucmFuZ2UuZnJvbUIgPCBkICYmIHIucmFuZ2UudG9CID4gdSkge1xuICAgICAgICBsZXQgdiA9IEhhLmJ1aWxkKHRoaXMudmlldy5zdGF0ZS5kb2MsIHUsIHIucmFuZ2UuZnJvbUIsIHRoaXMuZGVjb3JhdGlvbnMsIHRoaXMuZHluYW1pY0RlY29yYXRpb25NYXApLCBTID0gSGEuYnVpbGQodGhpcy52aWV3LnN0YXRlLmRvYywgci5yYW5nZS50b0IsIGQsIHRoaXMuZGVjb3JhdGlvbnMsIHRoaXMuZHluYW1pY0RlY29yYXRpb25NYXApO1xuICAgICAgICBoID0gdi5icmVha0F0U3RhcnQsIHAgPSB2Lm9wZW5TdGFydCwgTyA9IFMub3BlbkVuZDtcbiAgICAgICAgbGV0IHcgPSB0aGlzLmNvbXBvc2l0aW9uVmlldyhyKTtcbiAgICAgICAgUy5icmVha0F0U3RhcnQgPyB3LmJyZWFrQWZ0ZXIgPSAxIDogUy5jb250ZW50Lmxlbmd0aCAmJiB3Lm1lcmdlKHcubGVuZ3RoLCB3Lmxlbmd0aCwgUy5jb250ZW50WzBdLCAhMSwgUy5vcGVuU3RhcnQsIDApICYmICh3LmJyZWFrQWZ0ZXIgPSBTLmNvbnRlbnRbMF0uYnJlYWtBZnRlciwgUy5jb250ZW50LnNoaWZ0KCkpLCB2LmNvbnRlbnQubGVuZ3RoICYmIHcubWVyZ2UoMCwgMCwgdi5jb250ZW50W3YuY29udGVudC5sZW5ndGggLSAxXSwgITAsIDAsIHYub3BlbkVuZCkgJiYgdi5jb250ZW50LnBvcCgpLCBmID0gdi5jb250ZW50LmNvbmNhdCh3KS5jb25jYXQoUy5jb250ZW50KTtcbiAgICAgIH0gZWxzZVxuICAgICAgICAoeyBjb250ZW50OiBmLCBicmVha0F0U3RhcnQ6IGgsIG9wZW5TdGFydDogcCwgb3BlbkVuZDogTyB9ID0gSGEuYnVpbGQodGhpcy52aWV3LnN0YXRlLmRvYywgdSwgZCwgdGhpcy5kZWNvcmF0aW9ucywgdGhpcy5keW5hbWljRGVjb3JhdGlvbk1hcCkpO1xuICAgICAgbGV0IHsgaTogbSwgb2ZmOiB5IH0gPSBzLmZpbmRQb3MoYywgMSksIHsgaTogYiwgb2ZmOiBnIH0gPSBzLmZpbmRQb3MobCwgLTEpO1xuICAgICAgcmsodGhpcywgYiwgZywgbSwgeSwgZiwgaCwgcCwgTyk7XG4gICAgfVxuICAgIHIgJiYgdGhpcy5maXhDb21wb3NpdGlvbkRPTShyKTtcbiAgfVxuICBjb21wb3NpdGlvblZpZXcoZSkge1xuICAgIGxldCBuID0gbmV3IGhpKGUudGV4dC5ub2RlVmFsdWUpO1xuICAgIG4uZmxhZ3MgfD0gODtcbiAgICBmb3IgKGxldCB7IGRlY286IGkgfSBvZiBlLm1hcmtzKVxuICAgICAgbiA9IG5ldyBwaShpLCBbbl0sIG4ubGVuZ3RoKTtcbiAgICBsZXQgciA9IG5ldyBOdCgpO1xuICAgIHJldHVybiByLmFwcGVuZChuLCAwKSwgcjtcbiAgfVxuICBmaXhDb21wb3NpdGlvbkRPTShlKSB7XG4gICAgbGV0IG4gPSAocywgbykgPT4ge1xuICAgICAgby5mbGFncyB8PSA4IHwgKG8uY2hpbGRyZW4uc29tZShcbiAgICAgICAgKGwpID0+IGwuZmxhZ3MgJiA3XG4gICAgICAgIC8qIFZpZXdGbGFnLkRpcnR5ICovXG4gICAgICApID8gMSA6IDApLCB0aGlzLm1hcmtlZEZvckNvbXBvc2l0aW9uLmFkZChvKTtcbiAgICAgIGxldCBhID0gZnQuZ2V0KHMpO1xuICAgICAgYSAmJiBhICE9IG8gJiYgKGEuZG9tID0gbnVsbCksIG8uc2V0RE9NKHMpO1xuICAgIH0sIHIgPSB0aGlzLmNoaWxkUG9zKGUucmFuZ2UuZnJvbUIsIDEpLCBpID0gdGhpcy5jaGlsZHJlbltyLmldO1xuICAgIG4oZS5saW5lLCBpKTtcbiAgICBmb3IgKGxldCBzID0gZS5tYXJrcy5sZW5ndGggLSAxOyBzID49IC0xOyBzLS0pXG4gICAgICByID0gaS5jaGlsZFBvcyhyLm9mZiwgMSksIGkgPSBpLmNoaWxkcmVuW3IuaV0sIG4ocyA+PSAwID8gZS5tYXJrc1tzXS5ub2RlIDogZS50ZXh0LCBpKTtcbiAgfVxuICAvLyBTeW5jIHRoZSBET00gc2VsZWN0aW9uIHRvIHRoaXMuc3RhdGUuc2VsZWN0aW9uXG4gIHVwZGF0ZVNlbGVjdGlvbihlID0gITEsIG4gPSAhMSkge1xuICAgIChlIHx8ICF0aGlzLnZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2UuZm9jdXNOb2RlKSAmJiB0aGlzLnZpZXcub2JzZXJ2ZXIucmVhZFNlbGVjdGlvblJhbmdlKCk7XG4gICAgbGV0IHIgPSB0aGlzLnZpZXcucm9vdC5hY3RpdmVFbGVtZW50LCBpID0gciA9PSB0aGlzLmRvbSwgcyA9ICFpICYmIHJ1KHRoaXMuZG9tLCB0aGlzLnZpZXcub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2UpICYmICEociAmJiB0aGlzLmRvbS5jb250YWlucyhyKSk7XG4gICAgaWYgKCEoaSB8fCBuIHx8IHMpKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCBvID0gdGhpcy5mb3JjZVNlbGVjdGlvbjtcbiAgICB0aGlzLmZvcmNlU2VsZWN0aW9uID0gITE7XG4gICAgbGV0IGEgPSB0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLm1haW4sIGwgPSB0aGlzLm1vdmVUb0xpbmUodGhpcy5kb21BdFBvcyhhLmFuY2hvcikpLCBjID0gYS5lbXB0eSA/IGwgOiB0aGlzLm1vdmVUb0xpbmUodGhpcy5kb21BdFBvcyhhLmhlYWQpKTtcbiAgICBpZiAoZGUuZ2Vja28gJiYgYS5lbXB0eSAmJiAhdGhpcy5oYXNDb21wb3NpdGlvbiAmJiBYTihsKSkge1xuICAgICAgbGV0IGQgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlwiKTtcbiAgICAgIHRoaXMudmlldy5vYnNlcnZlci5pZ25vcmUoKCkgPT4gbC5ub2RlLmluc2VydEJlZm9yZShkLCBsLm5vZGUuY2hpbGROb2Rlc1tsLm9mZnNldF0gfHwgbnVsbCkpLCBsID0gYyA9IG5ldyBhbihkLCAwKSwgbyA9ICEwO1xuICAgIH1cbiAgICBsZXQgdSA9IHRoaXMudmlldy5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgICAobyB8fCAhdS5mb2N1c05vZGUgfHwgKCF6YShsLm5vZGUsIGwub2Zmc2V0LCB1LmFuY2hvck5vZGUsIHUuYW5jaG9yT2Zmc2V0KSB8fCAhemEoYy5ub2RlLCBjLm9mZnNldCwgdS5mb2N1c05vZGUsIHUuZm9jdXNPZmZzZXQpKSAmJiAhdGhpcy5zdXBwcmVzc1dpZGdldEN1cnNvckNoYW5nZSh1LCBhKSkgJiYgKHRoaXMudmlldy5vYnNlcnZlci5pZ25vcmUoKCkgPT4ge1xuICAgICAgZGUuYW5kcm9pZCAmJiBkZS5jaHJvbWUgJiYgdGhpcy5kb20uY29udGFpbnModS5mb2N1c05vZGUpICYmIHFOKHUuZm9jdXNOb2RlLCB0aGlzLmRvbSkgJiYgKHRoaXMuZG9tLmJsdXIoKSwgdGhpcy5kb20uZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiAhMCB9KSk7XG4gICAgICBsZXQgZCA9IEl1KHRoaXMudmlldy5yb290KTtcbiAgICAgIGlmIChkKVxuICAgICAgICBpZiAoYS5lbXB0eSkge1xuICAgICAgICAgIGlmIChkZS5nZWNrbykge1xuICAgICAgICAgICAgbGV0IGYgPSBCTihsLm5vZGUsIGwub2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChmICYmIGYgIT0gMykge1xuICAgICAgICAgICAgICBsZXQgaCA9ICRrKGwubm9kZSwgbC5vZmZzZXQsIGYgPT0gMSA/IDEgOiAtMSk7XG4gICAgICAgICAgICAgIGggJiYgKGwgPSBuZXcgYW4oaC5ub2RlLCBoLm9mZnNldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBkLmNvbGxhcHNlKGwubm9kZSwgbC5vZmZzZXQpLCBhLmJpZGlMZXZlbCAhPSBudWxsICYmIGQuY2FyZXRCaWRpTGV2ZWwgIT09IHZvaWQgMCAmJiAoZC5jYXJldEJpZGlMZXZlbCA9IGEuYmlkaUxldmVsKTtcbiAgICAgICAgfSBlbHNlIGlmIChkLmV4dGVuZCkge1xuICAgICAgICAgIGQuY29sbGFwc2UobC5ub2RlLCBsLm9mZnNldCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGQuZXh0ZW5kKGMubm9kZSwgYy5vZmZzZXQpO1xuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgZiA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgYS5hbmNob3IgPiBhLmhlYWQgJiYgKFtsLCBjXSA9IFtjLCBsXSksIGYuc2V0RW5kKGMubm9kZSwgYy5vZmZzZXQpLCBmLnNldFN0YXJ0KGwubm9kZSwgbC5vZmZzZXQpLCBkLnJlbW92ZUFsbFJhbmdlcygpLCBkLmFkZFJhbmdlKGYpO1xuICAgICAgICB9XG4gICAgICBzICYmIHRoaXMudmlldy5yb290LmFjdGl2ZUVsZW1lbnQgPT0gdGhpcy5kb20gJiYgKHRoaXMuZG9tLmJsdXIoKSwgciAmJiByLmZvY3VzKCkpO1xuICAgIH0pLCB0aGlzLnZpZXcub2JzZXJ2ZXIuc2V0U2VsZWN0aW9uUmFuZ2UobCwgYykpLCB0aGlzLmltcHJlY2lzZUFuY2hvciA9IGwucHJlY2lzZSA/IG51bGwgOiBuZXcgYW4odS5hbmNob3JOb2RlLCB1LmFuY2hvck9mZnNldCksIHRoaXMuaW1wcmVjaXNlSGVhZCA9IGMucHJlY2lzZSA/IG51bGwgOiBuZXcgYW4odS5mb2N1c05vZGUsIHUuZm9jdXNPZmZzZXQpO1xuICB9XG4gIC8vIElmIGEgemVyby1sZW5ndGggd2lkZ2V0IGlzIGluc2VydGVkIG5leHQgdG8gdGhlIGN1cnNvciBkdXJpbmdcbiAgLy8gY29tcG9zaXRpb24sIGF2b2lkIG1vdmluZyBpdCBhY3Jvc3MgaXQgYW5kIGRpc3J1cHRpbmcgdGhlXG4gIC8vIGNvbXBvc2l0aW9uLlxuICBzdXBwcmVzc1dpZGdldEN1cnNvckNoYW5nZShlLCBuKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQ29tcG9zaXRpb24gJiYgbi5lbXB0eSAmJiB6YShlLmZvY3VzTm9kZSwgZS5mb2N1c09mZnNldCwgZS5hbmNob3JOb2RlLCBlLmFuY2hvck9mZnNldCkgJiYgdGhpcy5wb3NGcm9tRE9NKGUuZm9jdXNOb2RlLCBlLmZvY3VzT2Zmc2V0KSA9PSBuLmhlYWQ7XG4gIH1cbiAgZW5mb3JjZUN1cnNvckFzc29jKCkge1xuICAgIGlmICh0aGlzLmhhc0NvbXBvc2l0aW9uKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCB7IHZpZXc6IGUgfSA9IHRoaXMsIG4gPSBlLnN0YXRlLnNlbGVjdGlvbi5tYWluLCByID0gSXUoZS5yb290KSwgeyBhbmNob3JOb2RlOiBpLCBhbmNob3JPZmZzZXQ6IHMgfSA9IGUub2JzZXJ2ZXIuc2VsZWN0aW9uUmFuZ2U7XG4gICAgaWYgKCFyIHx8ICFuLmVtcHR5IHx8ICFuLmFzc29jIHx8ICFyLm1vZGlmeSlcbiAgICAgIHJldHVybjtcbiAgICBsZXQgbyA9IE50LmZpbmQodGhpcywgbi5oZWFkKTtcbiAgICBpZiAoIW8pXG4gICAgICByZXR1cm47XG4gICAgbGV0IGEgPSBvLnBvc0F0U3RhcnQ7XG4gICAgaWYgKG4uaGVhZCA9PSBhIHx8IG4uaGVhZCA9PSBhICsgby5sZW5ndGgpXG4gICAgICByZXR1cm47XG4gICAgbGV0IGwgPSB0aGlzLmNvb3Jkc0F0KG4uaGVhZCwgLTEpLCBjID0gdGhpcy5jb29yZHNBdChuLmhlYWQsIDEpO1xuICAgIGlmICghbCB8fCAhYyB8fCBsLmJvdHRvbSA+IGMudG9wKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCB1ID0gdGhpcy5kb21BdFBvcyhuLmhlYWQgKyBuLmFzc29jKTtcbiAgICByLmNvbGxhcHNlKHUubm9kZSwgdS5vZmZzZXQpLCByLm1vZGlmeShcIm1vdmVcIiwgbi5hc3NvYyA8IDAgPyBcImZvcndhcmRcIiA6IFwiYmFja3dhcmRcIiwgXCJsaW5lYm91bmRhcnlcIiksIGUub2JzZXJ2ZXIucmVhZFNlbGVjdGlvblJhbmdlKCk7XG4gICAgbGV0IGQgPSBlLm9ic2VydmVyLnNlbGVjdGlvblJhbmdlO1xuICAgIGUuZG9jVmlldy5wb3NGcm9tRE9NKGQuYW5jaG9yTm9kZSwgZC5hbmNob3JPZmZzZXQpICE9IG4uZnJvbSAmJiByLmNvbGxhcHNlKGksIHMpO1xuICB9XG4gIC8vIElmIGEgcG9zaXRpb24gaXMgaW4vbmVhciBhIGJsb2NrIHdpZGdldCwgbW92ZSBpdCB0byBhIG5lYXJieSB0ZXh0XG4gIC8vIGxpbmUsIHNpbmNlIHdlIGRvbid0IHdhbnQgdGhlIGN1cnNvciBpbnNpZGUgYSBibG9jayB3aWRnZXQuXG4gIG1vdmVUb0xpbmUoZSkge1xuICAgIGxldCBuID0gdGhpcy5kb20sIHI7XG4gICAgaWYgKGUubm9kZSAhPSBuKVxuICAgICAgcmV0dXJuIGU7XG4gICAgZm9yIChsZXQgaSA9IGUub2Zmc2V0OyAhciAmJiBpIDwgbi5jaGlsZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgcyA9IGZ0LmdldChuLmNoaWxkTm9kZXNbaV0pO1xuICAgICAgcyBpbnN0YW5jZW9mIE50ICYmIChyID0gcy5kb21BdFBvcygwKSk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSBlLm9mZnNldCAtIDE7ICFyICYmIGkgPj0gMDsgaS0tKSB7XG4gICAgICBsZXQgcyA9IGZ0LmdldChuLmNoaWxkTm9kZXNbaV0pO1xuICAgICAgcyBpbnN0YW5jZW9mIE50ICYmIChyID0gcy5kb21BdFBvcyhzLmxlbmd0aCkpO1xuICAgIH1cbiAgICByZXR1cm4gciA/IG5ldyBhbihyLm5vZGUsIHIub2Zmc2V0LCAhMCkgOiBlO1xuICB9XG4gIG5lYXJlc3QoZSkge1xuICAgIGZvciAobGV0IG4gPSBlOyBuOyApIHtcbiAgICAgIGxldCByID0gZnQuZ2V0KG4pO1xuICAgICAgaWYgKHIgJiYgci5yb290VmlldyA9PSB0aGlzKVxuICAgICAgICByZXR1cm4gcjtcbiAgICAgIG4gPSBuLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHBvc0Zyb21ET00oZSwgbikge1xuICAgIGxldCByID0gdGhpcy5uZWFyZXN0KGUpO1xuICAgIGlmICghcilcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVHJ5aW5nIHRvIGZpbmQgcG9zaXRpb24gZm9yIGEgRE9NIHBvc2l0aW9uIG91dHNpZGUgb2YgdGhlIGRvY3VtZW50XCIpO1xuICAgIHJldHVybiByLmxvY2FsUG9zRnJvbURPTShlLCBuKSArIHIucG9zQXRTdGFydDtcbiAgfVxuICBkb21BdFBvcyhlKSB7XG4gICAgbGV0IHsgaTogbiwgb2ZmOiByIH0gPSB0aGlzLmNoaWxkQ3Vyc29yKCkuZmluZFBvcyhlLCAtMSk7XG4gICAgZm9yICg7IG4gPCB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDE7ICkge1xuICAgICAgbGV0IGkgPSB0aGlzLmNoaWxkcmVuW25dO1xuICAgICAgaWYgKHIgPCBpLmxlbmd0aCB8fCBpIGluc3RhbmNlb2YgTnQpXG4gICAgICAgIGJyZWFrO1xuICAgICAgbisrLCByID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5bbl0uZG9tQXRQb3Mocik7XG4gIH1cbiAgY29vcmRzQXQoZSwgbikge1xuICAgIGxldCByID0gbnVsbCwgaSA9IDA7XG4gICAgZm9yIChsZXQgcyA9IHRoaXMubGVuZ3RoLCBvID0gdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxOyBvID49IDA7IG8tLSkge1xuICAgICAgbGV0IGEgPSB0aGlzLmNoaWxkcmVuW29dLCBsID0gcyAtIGEuYnJlYWtBZnRlciwgYyA9IGwgLSBhLmxlbmd0aDtcbiAgICAgIGlmIChsIDwgZSlcbiAgICAgICAgYnJlYWs7XG4gICAgICBjIDw9IGUgJiYgKGMgPCBlIHx8IGEuY292ZXJzKC0xKSkgJiYgKGwgPiBlIHx8IGEuY292ZXJzKDEpKSAmJiAoIXIgfHwgYSBpbnN0YW5jZW9mIE50ICYmICEociBpbnN0YW5jZW9mIE50ICYmIG4gPj0gMCkpICYmIChyID0gYSwgaSA9IGMpLCBzID0gYztcbiAgICB9XG4gICAgcmV0dXJuIHIgPyByLmNvb3Jkc0F0KGUgLSBpLCBuKSA6IG51bGw7XG4gIH1cbiAgY29vcmRzRm9yQ2hhcihlKSB7XG4gICAgbGV0IHsgaTogbiwgb2ZmOiByIH0gPSB0aGlzLmNoaWxkUG9zKGUsIDEpLCBpID0gdGhpcy5jaGlsZHJlbltuXTtcbiAgICBpZiAoIShpIGluc3RhbmNlb2YgTnQpKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgZm9yICg7IGkuY2hpbGRyZW4ubGVuZ3RoOyApIHtcbiAgICAgIGxldCB7IGk6IGEsIG9mZjogbCB9ID0gaS5jaGlsZFBvcyhyLCAxKTtcbiAgICAgIGZvciAoOyA7IGErKykge1xuICAgICAgICBpZiAoYSA9PSBpLmNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKChpID0gaS5jaGlsZHJlblthXSkubGVuZ3RoKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgciA9IGw7XG4gICAgfVxuICAgIGlmICghKGkgaW5zdGFuY2VvZiBoaSkpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgcyA9IFJyKGkudGV4dCwgcik7XG4gICAgaWYgKHMgPT0gcilcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBvID0gWXMoaS5kb20sIHIsIHMpLmdldENsaWVudFJlY3RzKCk7XG4gICAgZm9yIChsZXQgYSA9IDA7IGEgPCBvLmxlbmd0aDsgYSsrKSB7XG4gICAgICBsZXQgbCA9IG9bYV07XG4gICAgICBpZiAoYSA9PSBvLmxlbmd0aCAtIDEgfHwgbC50b3AgPCBsLmJvdHRvbSAmJiBsLmxlZnQgPCBsLnJpZ2h0KVxuICAgICAgICByZXR1cm4gbDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbWVhc3VyZVZpc2libGVMaW5lSGVpZ2h0cyhlKSB7XG4gICAgbGV0IG4gPSBbXSwgeyBmcm9tOiByLCB0bzogaSB9ID0gZSwgcyA9IHRoaXMudmlldy5jb250ZW50RE9NLmNsaWVudFdpZHRoLCBvID0gcyA+IE1hdGgubWF4KHRoaXMudmlldy5zY3JvbGxET00uY2xpZW50V2lkdGgsIHRoaXMubWluV2lkdGgpICsgMSwgYSA9IC0xLCBsID0gdGhpcy52aWV3LnRleHREaXJlY3Rpb24gPT0gUXQuTFRSO1xuICAgIGZvciAobGV0IGMgPSAwLCB1ID0gMDsgdSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyB1KyspIHtcbiAgICAgIGxldCBkID0gdGhpcy5jaGlsZHJlblt1XSwgZiA9IGMgKyBkLmxlbmd0aDtcbiAgICAgIGlmIChmID4gaSlcbiAgICAgICAgYnJlYWs7XG4gICAgICBpZiAoYyA+PSByKSB7XG4gICAgICAgIGxldCBoID0gZC5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChuLnB1c2goaC5oZWlnaHQpLCBvKSB7XG4gICAgICAgICAgbGV0IHAgPSBkLmRvbS5sYXN0Q2hpbGQsIE8gPSBwID8gT2wocCkgOiBbXTtcbiAgICAgICAgICBpZiAoTy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBtID0gT1tPLmxlbmd0aCAtIDFdLCB5ID0gbCA/IG0ucmlnaHQgLSBoLmxlZnQgOiBoLnJpZ2h0IC0gbS5sZWZ0O1xuICAgICAgICAgICAgeSA+IGEgJiYgKGEgPSB5LCB0aGlzLm1pbldpZHRoID0gcywgdGhpcy5taW5XaWR0aEZyb20gPSBjLCB0aGlzLm1pbldpZHRoVG8gPSBmKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGMgPSBmICsgZC5icmVha0FmdGVyO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfVxuICB0ZXh0RGlyZWN0aW9uQXQoZSkge1xuICAgIGxldCB7IGk6IG4gfSA9IHRoaXMuY2hpbGRQb3MoZSwgMSk7XG4gICAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGUodGhpcy5jaGlsZHJlbltuXS5kb20pLmRpcmVjdGlvbiA9PSBcInJ0bFwiID8gUXQuUlRMIDogUXQuTFRSO1xuICB9XG4gIG1lYXN1cmVUZXh0U2l6ZSgpIHtcbiAgICBmb3IgKGxldCBzIG9mIHRoaXMuY2hpbGRyZW4pXG4gICAgICBpZiAocyBpbnN0YW5jZW9mIE50KSB7XG4gICAgICAgIGxldCBvID0gcy5tZWFzdXJlVGV4dFNpemUoKTtcbiAgICAgICAgaWYgKG8pXG4gICAgICAgICAgcmV0dXJuIG87XG4gICAgICB9XG4gICAgbGV0IGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCBuLCByLCBpO1xuICAgIHJldHVybiBlLmNsYXNzTmFtZSA9IFwiY20tbGluZVwiLCBlLnN0eWxlLndpZHRoID0gXCI5OTk5OXB4XCIsIGUuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCIsIGUudGV4dENvbnRlbnQgPSBcImFiYyBkZWYgZ2hpIGprbCBtbm8gcHFyIHN0dVwiLCB0aGlzLnZpZXcub2JzZXJ2ZXIuaWdub3JlKCgpID0+IHtcbiAgICAgIHRoaXMuZG9tLmFwcGVuZENoaWxkKGUpO1xuICAgICAgbGV0IHMgPSBPbChlLmZpcnN0Q2hpbGQpWzBdO1xuICAgICAgbiA9IGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0LCByID0gcyA/IHMud2lkdGggLyAyNyA6IDcsIGkgPSBzID8gcy5oZWlnaHQgOiBuLCBlLnJlbW92ZSgpO1xuICAgIH0pLCB7IGxpbmVIZWlnaHQ6IG4sIGNoYXJXaWR0aDogciwgdGV4dEhlaWdodDogaSB9O1xuICB9XG4gIGNoaWxkQ3Vyc29yKGUgPSB0aGlzLmxlbmd0aCkge1xuICAgIGxldCBuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG4gICAgcmV0dXJuIG4gJiYgKGUgLT0gdGhpcy5jaGlsZHJlblstLW5dLmxlbmd0aCksIG5ldyBuayh0aGlzLmNoaWxkcmVuLCBlLCBuKTtcbiAgfVxuICBjb21wdXRlQmxvY2tHYXBEZWNvKCkge1xuICAgIGxldCBlID0gW10sIG4gPSB0aGlzLnZpZXcudmlld1N0YXRlO1xuICAgIGZvciAobGV0IHIgPSAwLCBpID0gMDsgOyBpKyspIHtcbiAgICAgIGxldCBzID0gaSA9PSBuLnZpZXdwb3J0cy5sZW5ndGggPyBudWxsIDogbi52aWV3cG9ydHNbaV0sIG8gPSBzID8gcy5mcm9tIC0gMSA6IHRoaXMubGVuZ3RoO1xuICAgICAgaWYgKG8gPiByKSB7XG4gICAgICAgIGxldCBhID0gKG4ubGluZUJsb2NrQXQobykuYm90dG9tIC0gbi5saW5lQmxvY2tBdChyKS50b3ApIC8gdGhpcy52aWV3LnNjYWxlWTtcbiAgICAgICAgZS5wdXNoKEplLnJlcGxhY2Uoe1xuICAgICAgICAgIHdpZGdldDogbmV3IGV2KGEpLFxuICAgICAgICAgIGJsb2NrOiAhMCxcbiAgICAgICAgICBpbmNsdXNpdmU6ICEwLFxuICAgICAgICAgIGlzQmxvY2tHYXA6ICEwXG4gICAgICAgIH0pLnJhbmdlKHIsIG8pKTtcbiAgICAgIH1cbiAgICAgIGlmICghcylcbiAgICAgICAgYnJlYWs7XG4gICAgICByID0gcy50byArIDE7XG4gICAgfVxuICAgIHJldHVybiBKZS5zZXQoZSk7XG4gIH1cbiAgdXBkYXRlRGVjbygpIHtcbiAgICBsZXQgZSA9IHRoaXMudmlldy5zdGF0ZS5mYWNldChtbCkubWFwKChpLCBzKSA9PiAodGhpcy5keW5hbWljRGVjb3JhdGlvbk1hcFtzXSA9IHR5cGVvZiBpID09IFwiZnVuY3Rpb25cIikgPyBpKHRoaXMudmlldykgOiBpKSwgbiA9ICExLCByID0gdGhpcy52aWV3LnN0YXRlLmZhY2V0KHhrKS5tYXAoKGksIHMpID0+IHtcbiAgICAgIGxldCBvID0gdHlwZW9mIGkgPT0gXCJmdW5jdGlvblwiO1xuICAgICAgcmV0dXJuIG8gJiYgKG4gPSAhMCksIG8gPyBpKHRoaXMudmlldykgOiBpO1xuICAgIH0pO1xuICAgIHIubGVuZ3RoICYmICh0aGlzLmR5bmFtaWNEZWNvcmF0aW9uTWFwW2UubGVuZ3RoXSA9IG4sIGUucHVzaCh6ZS5qb2luKHIpKSk7XG4gICAgZm9yIChsZXQgaSA9IGUubGVuZ3RoOyBpIDwgZS5sZW5ndGggKyAzOyBpKyspXG4gICAgICB0aGlzLmR5bmFtaWNEZWNvcmF0aW9uTWFwW2ldID0gITE7XG4gICAgcmV0dXJuIHRoaXMuZGVjb3JhdGlvbnMgPSBbXG4gICAgICAuLi5lLFxuICAgICAgdGhpcy5jb21wdXRlQmxvY2tHYXBEZWNvKCksXG4gICAgICB0aGlzLnZpZXcudmlld1N0YXRlLmxpbmVHYXBEZWNvXG4gICAgXTtcbiAgfVxuICBzY3JvbGxJbnRvVmlldyhlKSB7XG4gICAgaWYgKGUuaXNTbmFwc2hvdCkge1xuICAgICAgbGV0IGMgPSB0aGlzLnZpZXcudmlld1N0YXRlLmxpbmVCbG9ja0F0KGUucmFuZ2UuaGVhZCk7XG4gICAgICB0aGlzLnZpZXcuc2Nyb2xsRE9NLnNjcm9sbFRvcCA9IGMudG9wIC0gZS55TWFyZ2luLCB0aGlzLnZpZXcuc2Nyb2xsRE9NLnNjcm9sbExlZnQgPSBlLnhNYXJnaW47XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB7IHJhbmdlOiBuIH0gPSBlLCByID0gdGhpcy5jb29yZHNBdChuLmhlYWQsIG4uZW1wdHkgPyBuLmFzc29jIDogbi5oZWFkID4gbi5hbmNob3IgPyAtMSA6IDEpLCBpO1xuICAgIGlmICghcilcbiAgICAgIHJldHVybjtcbiAgICAhbi5lbXB0eSAmJiAoaSA9IHRoaXMuY29vcmRzQXQobi5hbmNob3IsIG4uYW5jaG9yID4gbi5oZWFkID8gLTEgOiAxKSkgJiYgKHIgPSB7XG4gICAgICBsZWZ0OiBNYXRoLm1pbihyLmxlZnQsIGkubGVmdCksXG4gICAgICB0b3A6IE1hdGgubWluKHIudG9wLCBpLnRvcCksXG4gICAgICByaWdodDogTWF0aC5tYXgoci5yaWdodCwgaS5yaWdodCksXG4gICAgICBib3R0b206IE1hdGgubWF4KHIuYm90dG9tLCBpLmJvdHRvbSlcbiAgICB9KTtcbiAgICBsZXQgcyA9IFRrKHRoaXMudmlldyksIG8gPSB7XG4gICAgICBsZWZ0OiByLmxlZnQgLSBzLmxlZnQsXG4gICAgICB0b3A6IHIudG9wIC0gcy50b3AsXG4gICAgICByaWdodDogci5yaWdodCArIHMucmlnaHQsXG4gICAgICBib3R0b206IHIuYm90dG9tICsgcy5ib3R0b21cbiAgICB9LCB7IG9mZnNldFdpZHRoOiBhLCBvZmZzZXRIZWlnaHQ6IGwgfSA9IHRoaXMudmlldy5zY3JvbGxET007XG4gICAgeU4odGhpcy52aWV3LnNjcm9sbERPTSwgbywgbi5oZWFkIDwgbi5hbmNob3IgPyAtMSA6IDEsIGUueCwgZS55LCBNYXRoLm1heChNYXRoLm1pbihlLnhNYXJnaW4sIGEpLCAtYSksIE1hdGgubWF4KE1hdGgubWluKGUueU1hcmdpbiwgbCksIC1sKSwgdGhpcy52aWV3LnRleHREaXJlY3Rpb24gPT0gUXQuTFRSKTtcbiAgfVxufVxuZnVuY3Rpb24gWE4odCkge1xuICByZXR1cm4gdC5ub2RlLm5vZGVUeXBlID09IDEgJiYgdC5ub2RlLmZpcnN0Q2hpbGQgJiYgKHQub2Zmc2V0ID09IDAgfHwgdC5ub2RlLmNoaWxkTm9kZXNbdC5vZmZzZXQgLSAxXS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKSAmJiAodC5vZmZzZXQgPT0gdC5ub2RlLmNoaWxkTm9kZXMubGVuZ3RoIHx8IHQubm9kZS5jaGlsZE5vZGVzW3Qub2Zmc2V0XS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKTtcbn1cbmNsYXNzIGV2IGV4dGVuZHMgcmEge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgc3VwZXIoKSwgdGhpcy5oZWlnaHQgPSBlO1xuICB9XG4gIHRvRE9NKCkge1xuICAgIGxldCBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICByZXR1cm4gZS5jbGFzc05hbWUgPSBcImNtLWdhcFwiLCB0aGlzLnVwZGF0ZURPTShlKSwgZTtcbiAgfVxuICBlcShlKSB7XG4gICAgcmV0dXJuIGUuaGVpZ2h0ID09IHRoaXMuaGVpZ2h0O1xuICB9XG4gIHVwZGF0ZURPTShlKSB7XG4gICAgcmV0dXJuIGUuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyBcInB4XCIsICEwO1xuICB9XG4gIGdldCBlZGl0YWJsZSgpIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgZ2V0IGVzdGltYXRlZEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5oZWlnaHQ7XG4gIH1cbiAgaWdub3JlRXZlbnQoKSB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5mdW5jdGlvbiBFayh0LCBlKSB7XG4gIGxldCBuID0gdC5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZSwgciA9IG4uZm9jdXNOb2RlICYmICRrKG4uZm9jdXNOb2RlLCBuLmZvY3VzT2Zmc2V0LCAwKTtcbiAgaWYgKCFyKVxuICAgIHJldHVybiBudWxsO1xuICBsZXQgaSA9IGUgLSByLm9mZnNldDtcbiAgcmV0dXJuIHsgZnJvbTogaSwgdG86IGkgKyByLm5vZGUubm9kZVZhbHVlLmxlbmd0aCwgbm9kZTogci5ub2RlIH07XG59XG5mdW5jdGlvbiBqTih0LCBlLCBuKSB7XG4gIGxldCByID0gRWsodCwgbik7XG4gIGlmICghcilcbiAgICByZXR1cm4gbnVsbDtcbiAgbGV0IHsgbm9kZTogaSwgZnJvbTogcywgdG86IG8gfSA9IHIsIGEgPSBpLm5vZGVWYWx1ZTtcbiAgaWYgKC9bXFxuXFxyXS8udGVzdChhKSB8fCB0LnN0YXRlLmRvYy5zbGljZVN0cmluZyhyLmZyb20sIHIudG8pICE9IGEpXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCBsID0gZS5pbnZlcnRlZERlc2MsIGMgPSBuZXcgdHIobC5tYXBQb3MocyksIGwubWFwUG9zKG8pLCBzLCBvKSwgdSA9IFtdO1xuICBmb3IgKGxldCBkID0gaS5wYXJlbnROb2RlOyA7IGQgPSBkLnBhcmVudE5vZGUpIHtcbiAgICBsZXQgZiA9IGZ0LmdldChkKTtcbiAgICBpZiAoZiBpbnN0YW5jZW9mIHBpKVxuICAgICAgdS5wdXNoKHsgbm9kZTogZCwgZGVjbzogZi5tYXJrIH0pO1xuICAgIGVsc2Uge1xuICAgICAgaWYgKGYgaW5zdGFuY2VvZiBOdCB8fCBkLm5vZGVOYW1lID09IFwiRElWXCIgJiYgZC5wYXJlbnROb2RlID09IHQuY29udGVudERPTSlcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IGMsIHRleHQ6IGksIG1hcmtzOiB1LCBsaW5lOiBkIH07XG4gICAgICBpZiAoZCAhPSB0LmNvbnRlbnRET00pXG4gICAgICAgIHUucHVzaCh7IG5vZGU6IGQsIGRlY286IG5ldyBIbCh7XG4gICAgICAgICAgaW5jbHVzaXZlOiAhMCxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiBFTihkKSxcbiAgICAgICAgICB0YWdOYW1lOiBkLnRhZ05hbWUudG9Mb3dlckNhc2UoKVxuICAgICAgICB9KSB9KTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiAkayh0LCBlLCBuKSB7XG4gIGlmIChuIDw9IDApXG4gICAgZm9yIChsZXQgciA9IHQsIGkgPSBlOyA7ICkge1xuICAgICAgaWYgKHIubm9kZVR5cGUgPT0gMylcbiAgICAgICAgcmV0dXJuIHsgbm9kZTogciwgb2Zmc2V0OiBpIH07XG4gICAgICBpZiAoci5ub2RlVHlwZSA9PSAxICYmIGkgPiAwKVxuICAgICAgICByID0gci5jaGlsZE5vZGVzW2kgLSAxXSwgaSA9IGZpKHIpO1xuICAgICAgZWxzZVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIGlmIChuID49IDApXG4gICAgZm9yIChsZXQgciA9IHQsIGkgPSBlOyA7ICkge1xuICAgICAgaWYgKHIubm9kZVR5cGUgPT0gMylcbiAgICAgICAgcmV0dXJuIHsgbm9kZTogciwgb2Zmc2V0OiBpIH07XG4gICAgICBpZiAoci5ub2RlVHlwZSA9PSAxICYmIGkgPCByLmNoaWxkTm9kZXMubGVuZ3RoICYmIG4gPj0gMClcbiAgICAgICAgciA9IHIuY2hpbGROb2Rlc1tpXSwgaSA9IDA7XG4gICAgICBlbHNlXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBCTih0LCBlKSB7XG4gIHJldHVybiB0Lm5vZGVUeXBlICE9IDEgPyAwIDogKGUgJiYgdC5jaGlsZE5vZGVzW2UgLSAxXS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiID8gMSA6IDApIHwgKGUgPCB0LmNoaWxkTm9kZXMubGVuZ3RoICYmIHQuY2hpbGROb2Rlc1tlXS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiID8gMiA6IDApO1xufVxubGV0IExOID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNoYW5nZXMgPSBbXTtcbiAgfVxuICBjb21wYXJlUmFuZ2UoZSwgbikge1xuICAgIGxwKGUsIG4sIHRoaXMuY2hhbmdlcyk7XG4gIH1cbiAgY29tcGFyZVBvaW50KGUsIG4pIHtcbiAgICBscChlLCBuLCB0aGlzLmNoYW5nZXMpO1xuICB9XG59O1xuZnVuY3Rpb24gVU4odCwgZSwgbikge1xuICBsZXQgciA9IG5ldyBMTigpO1xuICByZXR1cm4gemUuY29tcGFyZSh0LCBlLCBuLCByKSwgci5jaGFuZ2VzO1xufVxuZnVuY3Rpb24gcU4odCwgZSkge1xuICBmb3IgKGxldCBuID0gdDsgbiAmJiBuICE9IGU7IG4gPSBuLmFzc2lnbmVkU2xvdCB8fCBuLnBhcmVudE5vZGUpXG4gICAgaWYgKG4ubm9kZVR5cGUgPT0gMSAmJiBuLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICByZXR1cm4gITA7XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIFlOKHQsIGUpIHtcbiAgbGV0IG4gPSAhMTtcbiAgcmV0dXJuIGUgJiYgdC5pdGVyQ2hhbmdlZFJhbmdlcygociwgaSkgPT4ge1xuICAgIHIgPCBlLnRvICYmIGkgPiBlLmZyb20gJiYgKG4gPSAhMCk7XG4gIH0pLCBuO1xufVxuZnVuY3Rpb24gek4odCwgZSwgbiA9IDEpIHtcbiAgbGV0IHIgPSB0LmNoYXJDYXRlZ29yaXplcihlKSwgaSA9IHQuZG9jLmxpbmVBdChlKSwgcyA9IGUgLSBpLmZyb207XG4gIGlmIChpLmxlbmd0aCA9PSAwKVxuICAgIHJldHVybiBhZS5jdXJzb3IoZSk7XG4gIHMgPT0gMCA/IG4gPSAxIDogcyA9PSBpLmxlbmd0aCAmJiAobiA9IC0xKTtcbiAgbGV0IG8gPSBzLCBhID0gcztcbiAgbiA8IDAgPyBvID0gUnIoaS50ZXh0LCBzLCAhMSkgOiBhID0gUnIoaS50ZXh0LCBzKTtcbiAgbGV0IGwgPSByKGkudGV4dC5zbGljZShvLCBhKSk7XG4gIGZvciAoOyBvID4gMDsgKSB7XG4gICAgbGV0IGMgPSBScihpLnRleHQsIG8sICExKTtcbiAgICBpZiAocihpLnRleHQuc2xpY2UoYywgbykpICE9IGwpXG4gICAgICBicmVhaztcbiAgICBvID0gYztcbiAgfVxuICBmb3IgKDsgYSA8IGkubGVuZ3RoOyApIHtcbiAgICBsZXQgYyA9IFJyKGkudGV4dCwgYSk7XG4gICAgaWYgKHIoaS50ZXh0LnNsaWNlKGEsIGMpKSAhPSBsKVxuICAgICAgYnJlYWs7XG4gICAgYSA9IGM7XG4gIH1cbiAgcmV0dXJuIGFlLnJhbmdlKG8gKyBpLmZyb20sIGEgKyBpLmZyb20pO1xufVxuZnVuY3Rpb24gSE4odCwgZSkge1xuICByZXR1cm4gZS5sZWZ0ID4gdCA/IGUubGVmdCAtIHQgOiBNYXRoLm1heCgwLCB0IC0gZS5yaWdodCk7XG59XG5mdW5jdGlvbiBGTih0LCBlKSB7XG4gIHJldHVybiBlLnRvcCA+IHQgPyBlLnRvcCAtIHQgOiBNYXRoLm1heCgwLCB0IC0gZS5ib3R0b20pO1xufVxuZnVuY3Rpb24gX2YodCwgZSkge1xuICByZXR1cm4gdC50b3AgPCBlLmJvdHRvbSAtIDEgJiYgdC5ib3R0b20gPiBlLnRvcCArIDE7XG59XG5mdW5jdGlvbiB0dih0LCBlKSB7XG4gIHJldHVybiBlIDwgdC50b3AgPyB7IHRvcDogZSwgbGVmdDogdC5sZWZ0LCByaWdodDogdC5yaWdodCwgYm90dG9tOiB0LmJvdHRvbSB9IDogdDtcbn1cbmZ1bmN0aW9uIG52KHQsIGUpIHtcbiAgcmV0dXJuIGUgPiB0LmJvdHRvbSA/IHsgdG9wOiB0LnRvcCwgbGVmdDogdC5sZWZ0LCByaWdodDogdC5yaWdodCwgYm90dG9tOiBlIH0gOiB0O1xufVxuZnVuY3Rpb24gaHAodCwgZSwgbikge1xuICBsZXQgciwgaSwgcywgbywgYSA9ICExLCBsLCBjLCB1LCBkO1xuICBmb3IgKGxldCBwID0gdC5maXJzdENoaWxkOyBwOyBwID0gcC5uZXh0U2libGluZykge1xuICAgIGxldCBPID0gT2wocCk7XG4gICAgZm9yIChsZXQgbSA9IDA7IG0gPCBPLmxlbmd0aDsgbSsrKSB7XG4gICAgICBsZXQgeSA9IE9bbV07XG4gICAgICBpICYmIF9mKGksIHkpICYmICh5ID0gdHYobnYoeSwgaS5ib3R0b20pLCBpLnRvcCkpO1xuICAgICAgbGV0IGIgPSBITihlLCB5KSwgZyA9IEZOKG4sIHkpO1xuICAgICAgaWYgKGIgPT0gMCAmJiBnID09IDApXG4gICAgICAgIHJldHVybiBwLm5vZGVUeXBlID09IDMgPyBydihwLCBlLCBuKSA6IGhwKHAsIGUsIG4pO1xuICAgICAgaWYgKCFyIHx8IG8gPiBnIHx8IG8gPT0gZyAmJiBzID4gYikge1xuICAgICAgICByID0gcCwgaSA9IHksIHMgPSBiLCBvID0gZztcbiAgICAgICAgbGV0IHYgPSBnID8gbiA8IHkudG9wID8gLTEgOiAxIDogYiA/IGUgPCB5LmxlZnQgPyAtMSA6IDEgOiAwO1xuICAgICAgICBhID0gIXYgfHwgKHYgPiAwID8gbSA8IE8ubGVuZ3RoIC0gMSA6IG0gPiAwKTtcbiAgICAgIH1cbiAgICAgIGIgPT0gMCA/IG4gPiB5LmJvdHRvbSAmJiAoIXUgfHwgdS5ib3R0b20gPCB5LmJvdHRvbSkgPyAobCA9IHAsIHUgPSB5KSA6IG4gPCB5LnRvcCAmJiAoIWQgfHwgZC50b3AgPiB5LnRvcCkgJiYgKGMgPSBwLCBkID0geSkgOiB1ICYmIF9mKHUsIHkpID8gdSA9IG52KHUsIHkuYm90dG9tKSA6IGQgJiYgX2YoZCwgeSkgJiYgKGQgPSB0dihkLCB5LnRvcCkpO1xuICAgIH1cbiAgfVxuICBpZiAodSAmJiB1LmJvdHRvbSA+PSBuID8gKHIgPSBsLCBpID0gdSkgOiBkICYmIGQudG9wIDw9IG4gJiYgKHIgPSBjLCBpID0gZCksICFyKVxuICAgIHJldHVybiB7IG5vZGU6IHQsIG9mZnNldDogMCB9O1xuICBsZXQgZiA9IE1hdGgubWF4KGkubGVmdCwgTWF0aC5taW4oaS5yaWdodCwgZSkpO1xuICBpZiAoci5ub2RlVHlwZSA9PSAzKVxuICAgIHJldHVybiBydihyLCBmLCBuKTtcbiAgaWYgKGEgJiYgci5jb250ZW50RWRpdGFibGUgIT0gXCJmYWxzZVwiKVxuICAgIHJldHVybiBocChyLCBmLCBuKTtcbiAgbGV0IGggPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKHQuY2hpbGROb2RlcywgcikgKyAoZSA+PSAoaS5sZWZ0ICsgaS5yaWdodCkgLyAyID8gMSA6IDApO1xuICByZXR1cm4geyBub2RlOiB0LCBvZmZzZXQ6IGggfTtcbn1cbmZ1bmN0aW9uIHJ2KHQsIGUsIG4pIHtcbiAgbGV0IHIgPSB0Lm5vZGVWYWx1ZS5sZW5ndGgsIGkgPSAtMSwgcyA9IDFlOSwgbyA9IDA7XG4gIGZvciAobGV0IGEgPSAwOyBhIDwgcjsgYSsrKSB7XG4gICAgbGV0IGwgPSBZcyh0LCBhLCBhICsgMSkuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICBmb3IgKGxldCBjID0gMDsgYyA8IGwubGVuZ3RoOyBjKyspIHtcbiAgICAgIGxldCB1ID0gbFtjXTtcbiAgICAgIGlmICh1LnRvcCA9PSB1LmJvdHRvbSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBvIHx8IChvID0gZSAtIHUubGVmdCk7XG4gICAgICBsZXQgZCA9ICh1LnRvcCA+IG4gPyB1LnRvcCAtIG4gOiBuIC0gdS5ib3R0b20pIC0gMTtcbiAgICAgIGlmICh1LmxlZnQgLSAxIDw9IGUgJiYgdS5yaWdodCArIDEgPj0gZSAmJiBkIDwgcykge1xuICAgICAgICBsZXQgZiA9IGUgPj0gKHUubGVmdCArIHUucmlnaHQpIC8gMiwgaCA9IGY7XG4gICAgICAgIGlmICgoZGUuY2hyb21lIHx8IGRlLmdlY2tvKSAmJiBZcyh0LCBhKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0ID09IHUucmlnaHQgJiYgKGggPSAhZiksIGQgPD0gMClcbiAgICAgICAgICByZXR1cm4geyBub2RlOiB0LCBvZmZzZXQ6IGEgKyAoaCA/IDEgOiAwKSB9O1xuICAgICAgICBpID0gYSArIChoID8gMSA6IDApLCBzID0gZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgbm9kZTogdCwgb2Zmc2V0OiBpID4gLTEgPyBpIDogbyA+IDAgPyB0Lm5vZGVWYWx1ZS5sZW5ndGggOiAwIH07XG59XG5mdW5jdGlvbiBRayh0LCBlLCBuLCByID0gLTEpIHtcbiAgdmFyIGksIHM7XG4gIGxldCBvID0gdC5jb250ZW50RE9NLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBhID0gby50b3AgKyB0LnZpZXdTdGF0ZS5wYWRkaW5nVG9wLCBsLCB7IGRvY0hlaWdodDogYyB9ID0gdC52aWV3U3RhdGUsIHsgeDogdSwgeTogZCB9ID0gZSwgZiA9IGQgLSBhO1xuICBpZiAoZiA8IDApXG4gICAgcmV0dXJuIDA7XG4gIGlmIChmID4gYylcbiAgICByZXR1cm4gdC5zdGF0ZS5kb2MubGVuZ3RoO1xuICBmb3IgKGxldCB2ID0gdC52aWV3U3RhdGUuaGVpZ2h0T3JhY2xlLnRleHRIZWlnaHQgLyAyLCBTID0gITE7IGwgPSB0LmVsZW1lbnRBdEhlaWdodChmKSwgbC50eXBlICE9IGZyLlRleHQ7IClcbiAgICBmb3IgKDsgZiA9IHIgPiAwID8gbC5ib3R0b20gKyB2IDogbC50b3AgLSB2LCAhKGYgPj0gMCAmJiBmIDw9IGMpOyApIHtcbiAgICAgIGlmIChTKVxuICAgICAgICByZXR1cm4gbiA/IG51bGwgOiAwO1xuICAgICAgUyA9ICEwLCByID0gLXI7XG4gICAgfVxuICBkID0gYSArIGY7XG4gIGxldCBoID0gbC5mcm9tO1xuICBpZiAoaCA8IHQudmlld3BvcnQuZnJvbSlcbiAgICByZXR1cm4gdC52aWV3cG9ydC5mcm9tID09IDAgPyAwIDogbiA/IG51bGwgOiBpdih0LCBvLCBsLCB1LCBkKTtcbiAgaWYgKGggPiB0LnZpZXdwb3J0LnRvKVxuICAgIHJldHVybiB0LnZpZXdwb3J0LnRvID09IHQuc3RhdGUuZG9jLmxlbmd0aCA/IHQuc3RhdGUuZG9jLmxlbmd0aCA6IG4gPyBudWxsIDogaXYodCwgbywgbCwgdSwgZCk7XG4gIGxldCBwID0gdC5kb20ub3duZXJEb2N1bWVudCwgTyA9IHQucm9vdC5lbGVtZW50RnJvbVBvaW50ID8gdC5yb290IDogcCwgbSA9IE8uZWxlbWVudEZyb21Qb2ludCh1LCBkKTtcbiAgbSAmJiAhdC5jb250ZW50RE9NLmNvbnRhaW5zKG0pICYmIChtID0gbnVsbCksIG0gfHwgKHUgPSBNYXRoLm1heChvLmxlZnQgKyAxLCBNYXRoLm1pbihvLnJpZ2h0IC0gMSwgdSkpLCBtID0gTy5lbGVtZW50RnJvbVBvaW50KHUsIGQpLCBtICYmICF0LmNvbnRlbnRET00uY29udGFpbnMobSkgJiYgKG0gPSBudWxsKSk7XG4gIGxldCB5LCBiID0gLTE7XG4gIGlmIChtICYmICgoaSA9IHQuZG9jVmlldy5uZWFyZXN0KG0pKSA9PT0gbnVsbCB8fCBpID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpLmlzRWRpdGFibGUpICE9ICExKSB7XG4gICAgaWYgKHAuY2FyZXRQb3NpdGlvbkZyb21Qb2ludCkge1xuICAgICAgbGV0IHYgPSBwLmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQodSwgZCk7XG4gICAgICB2ICYmICh7IG9mZnNldE5vZGU6IHksIG9mZnNldDogYiB9ID0gdik7XG4gICAgfSBlbHNlIGlmIChwLmNhcmV0UmFuZ2VGcm9tUG9pbnQpIHtcbiAgICAgIGxldCB2ID0gcC5jYXJldFJhbmdlRnJvbVBvaW50KHUsIGQpO1xuICAgICAgdiAmJiAoeyBzdGFydENvbnRhaW5lcjogeSwgc3RhcnRPZmZzZXQ6IGIgfSA9IHYsICghdC5jb250ZW50RE9NLmNvbnRhaW5zKHkpIHx8IGRlLnNhZmFyaSAmJiBHTih5LCBiLCB1KSB8fCBkZS5jaHJvbWUgJiYgS04oeSwgYiwgdSkpICYmICh5ID0gdm9pZCAwKSk7XG4gICAgfVxuICB9XG4gIGlmICgheSB8fCAhdC5kb2NWaWV3LmRvbS5jb250YWlucyh5KSkge1xuICAgIGxldCB2ID0gTnQuZmluZCh0LmRvY1ZpZXcsIGgpO1xuICAgIGlmICghdilcbiAgICAgIHJldHVybiBmID4gbC50b3AgKyBsLmhlaWdodCAvIDIgPyBsLnRvIDogbC5mcm9tO1xuICAgICh7IG5vZGU6IHksIG9mZnNldDogYiB9ID0gaHAodi5kb20sIHUsIGQpKTtcbiAgfVxuICBsZXQgZyA9IHQuZG9jVmlldy5uZWFyZXN0KHkpO1xuICBpZiAoIWcpXG4gICAgcmV0dXJuIG51bGw7XG4gIGlmIChnLmlzV2lkZ2V0ICYmICgocyA9IGcuZG9tKSA9PT0gbnVsbCB8fCBzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzLm5vZGVUeXBlKSA9PSAxKSB7XG4gICAgbGV0IHYgPSBnLmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4gZS55IDwgdi50b3AgfHwgZS55IDw9IHYuYm90dG9tICYmIGUueCA8PSAodi5sZWZ0ICsgdi5yaWdodCkgLyAyID8gZy5wb3NBdFN0YXJ0IDogZy5wb3NBdEVuZDtcbiAgfSBlbHNlXG4gICAgcmV0dXJuIGcubG9jYWxQb3NGcm9tRE9NKHksIGIpICsgZy5wb3NBdFN0YXJ0O1xufVxuZnVuY3Rpb24gaXYodCwgZSwgbiwgciwgaSkge1xuICBsZXQgcyA9IE1hdGgucm91bmQoKHIgLSBlLmxlZnQpICogdC5kZWZhdWx0Q2hhcmFjdGVyV2lkdGgpO1xuICBpZiAodC5saW5lV3JhcHBpbmcgJiYgbi5oZWlnaHQgPiB0LmRlZmF1bHRMaW5lSGVpZ2h0ICogMS41KSB7XG4gICAgbGV0IGEgPSB0LnZpZXdTdGF0ZS5oZWlnaHRPcmFjbGUudGV4dEhlaWdodCwgbCA9IE1hdGguZmxvb3IoKGkgLSBuLnRvcCAtICh0LmRlZmF1bHRMaW5lSGVpZ2h0IC0gYSkgKiAwLjUpIC8gYSk7XG4gICAgcyArPSBsICogdC52aWV3U3RhdGUuaGVpZ2h0T3JhY2xlLmxpbmVMZW5ndGg7XG4gIH1cbiAgbGV0IG8gPSB0LnN0YXRlLnNsaWNlRG9jKG4uZnJvbSwgbi50byk7XG4gIHJldHVybiBuLmZyb20gKyBoTihvLCBzLCB0LnN0YXRlLnRhYlNpemUpO1xufVxuZnVuY3Rpb24gR04odCwgZSwgbikge1xuICBsZXQgcjtcbiAgaWYgKHQubm9kZVR5cGUgIT0gMyB8fCBlICE9IChyID0gdC5ub2RlVmFsdWUubGVuZ3RoKSlcbiAgICByZXR1cm4gITE7XG4gIGZvciAobGV0IGkgPSB0Lm5leHRTaWJsaW5nOyBpOyBpID0gaS5uZXh0U2libGluZylcbiAgICBpZiAoaS5ub2RlVHlwZSAhPSAxIHx8IGkubm9kZU5hbWUgIT0gXCJCUlwiKVxuICAgICAgcmV0dXJuICExO1xuICByZXR1cm4gWXModCwgciAtIDEsIHIpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgPiBuO1xufVxuZnVuY3Rpb24gS04odCwgZSwgbikge1xuICBpZiAoZSAhPSAwKVxuICAgIHJldHVybiAhMTtcbiAgZm9yIChsZXQgaSA9IHQ7IDsgKSB7XG4gICAgbGV0IHMgPSBpLnBhcmVudE5vZGU7XG4gICAgaWYgKCFzIHx8IHMubm9kZVR5cGUgIT0gMSB8fCBzLmZpcnN0Q2hpbGQgIT0gaSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBpZiAocy5jbGFzc0xpc3QuY29udGFpbnMoXCJjbS1saW5lXCIpKVxuICAgICAgYnJlYWs7XG4gICAgaSA9IHM7XG4gIH1cbiAgbGV0IHIgPSB0Lm5vZGVUeXBlID09IDEgPyB0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogWXModCwgMCwgTWF0aC5tYXgodC5ub2RlVmFsdWUubGVuZ3RoLCAxKSkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiBuIC0gci5sZWZ0ID4gNTtcbn1cbmZ1bmN0aW9uIEpOKHQsIGUpIHtcbiAgbGV0IG4gPSB0LmxpbmVCbG9ja0F0KGUpO1xuICBpZiAoQXJyYXkuaXNBcnJheShuLnR5cGUpKSB7XG4gICAgZm9yIChsZXQgciBvZiBuLnR5cGUpXG4gICAgICBpZiAoci50byA+IGUgfHwgci50byA9PSBlICYmIChyLnRvID09IG4udG8gfHwgci50eXBlID09IGZyLlRleHQpKVxuICAgICAgICByZXR1cm4gcjtcbiAgfVxuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIGU1KHQsIGUsIG4sIHIpIHtcbiAgbGV0IGkgPSBKTih0LCBlLmhlYWQpLCBzID0gIXIgfHwgaS50eXBlICE9IGZyLlRleHQgfHwgISh0LmxpbmVXcmFwcGluZyB8fCBpLndpZGdldExpbmVCcmVha3MpID8gbnVsbCA6IHQuY29vcmRzQXRQb3MoZS5hc3NvYyA8IDAgJiYgZS5oZWFkID4gaS5mcm9tID8gZS5oZWFkIC0gMSA6IGUuaGVhZCk7XG4gIGlmIChzKSB7XG4gICAgbGV0IG8gPSB0LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgYSA9IHQudGV4dERpcmVjdGlvbkF0KGkuZnJvbSksIGwgPSB0LnBvc0F0Q29vcmRzKHtcbiAgICAgIHg6IG4gPT0gKGEgPT0gUXQuTFRSKSA/IG8ucmlnaHQgLSAxIDogby5sZWZ0ICsgMSxcbiAgICAgIHk6IChzLnRvcCArIHMuYm90dG9tKSAvIDJcbiAgICB9KTtcbiAgICBpZiAobCAhPSBudWxsKVxuICAgICAgcmV0dXJuIGFlLmN1cnNvcihsLCBuID8gLTEgOiAxKTtcbiAgfVxuICByZXR1cm4gYWUuY3Vyc29yKG4gPyBpLnRvIDogaS5mcm9tLCBuID8gLTEgOiAxKTtcbn1cbmZ1bmN0aW9uIHN2KHQsIGUsIG4sIHIpIHtcbiAgbGV0IGkgPSB0LnN0YXRlLmRvYy5saW5lQXQoZS5oZWFkKSwgcyA9IHQuYmlkaVNwYW5zKGkpLCBvID0gdC50ZXh0RGlyZWN0aW9uQXQoaS5mcm9tKTtcbiAgZm9yIChsZXQgYSA9IGUsIGwgPSBudWxsOyA7ICkge1xuICAgIGxldCBjID0gVk4oaSwgcywgbywgYSwgbiksIHUgPSBPaztcbiAgICBpZiAoIWMpIHtcbiAgICAgIGlmIChpLm51bWJlciA9PSAobiA/IHQuc3RhdGUuZG9jLmxpbmVzIDogMSkpXG4gICAgICAgIHJldHVybiBhO1xuICAgICAgdSA9IGBcbmAsIGkgPSB0LnN0YXRlLmRvYy5saW5lKGkubnVtYmVyICsgKG4gPyAxIDogLTEpKSwgcyA9IHQuYmlkaVNwYW5zKGkpLCBjID0gdC52aXN1YWxMaW5lU2lkZShpLCAhbik7XG4gICAgfVxuICAgIGlmIChsKSB7XG4gICAgICBpZiAoIWwodSkpXG4gICAgICAgIHJldHVybiBhO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXIpXG4gICAgICAgIHJldHVybiBjO1xuICAgICAgbCA9IHIodSk7XG4gICAgfVxuICAgIGEgPSBjO1xuICB9XG59XG5mdW5jdGlvbiB0NSh0LCBlLCBuKSB7XG4gIGxldCByID0gdC5zdGF0ZS5jaGFyQ2F0ZWdvcml6ZXIoZSksIGkgPSByKG4pO1xuICByZXR1cm4gKHMpID0+IHtcbiAgICBsZXQgbyA9IHIocyk7XG4gICAgcmV0dXJuIGkgPT0gSG4uU3BhY2UgJiYgKGkgPSBvKSwgaSA9PSBvO1xuICB9O1xufVxuZnVuY3Rpb24gbjUodCwgZSwgbiwgcikge1xuICBsZXQgaSA9IGUuaGVhZCwgcyA9IG4gPyAxIDogLTE7XG4gIGlmIChpID09IChuID8gdC5zdGF0ZS5kb2MubGVuZ3RoIDogMCkpXG4gICAgcmV0dXJuIGFlLmN1cnNvcihpLCBlLmFzc29jKTtcbiAgbGV0IG8gPSBlLmdvYWxDb2x1bW4sIGEsIGwgPSB0LmNvbnRlbnRET00uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGMgPSB0LmNvb3Jkc0F0UG9zKGksIGUuYXNzb2MgfHwgLTEpLCB1ID0gdC5kb2N1bWVudFRvcDtcbiAgaWYgKGMpXG4gICAgbyA9PSBudWxsICYmIChvID0gYy5sZWZ0IC0gbC5sZWZ0KSwgYSA9IHMgPCAwID8gYy50b3AgOiBjLmJvdHRvbTtcbiAgZWxzZSB7XG4gICAgbGV0IGggPSB0LnZpZXdTdGF0ZS5saW5lQmxvY2tBdChpKTtcbiAgICBvID09IG51bGwgJiYgKG8gPSBNYXRoLm1pbihsLnJpZ2h0IC0gbC5sZWZ0LCB0LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aCAqIChpIC0gaC5mcm9tKSkpLCBhID0gKHMgPCAwID8gaC50b3AgOiBoLmJvdHRvbSkgKyB1O1xuICB9XG4gIGxldCBkID0gbC5sZWZ0ICsgbywgZiA9IHIgPz8gdC52aWV3U3RhdGUuaGVpZ2h0T3JhY2xlLnRleHRIZWlnaHQgPj4gMTtcbiAgZm9yIChsZXQgaCA9IDA7IDsgaCArPSAxMCkge1xuICAgIGxldCBwID0gYSArIChmICsgaCkgKiBzLCBPID0gUWsodCwgeyB4OiBkLCB5OiBwIH0sICExLCBzKTtcbiAgICBpZiAocCA8IGwudG9wIHx8IHAgPiBsLmJvdHRvbSB8fCAocyA8IDAgPyBPIDwgaSA6IE8gPiBpKSkge1xuICAgICAgbGV0IG0gPSB0LmRvY1ZpZXcuY29vcmRzRm9yQ2hhcihPKSwgeSA9ICFtIHx8IHAgPCBtLnRvcCA/IC0xIDogMTtcbiAgICAgIHJldHVybiBhZS5jdXJzb3IoTywgeSwgdm9pZCAwLCBvKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGl1KHQsIGUsIG4pIHtcbiAgZm9yICg7IDsgKSB7XG4gICAgbGV0IHIgPSAwO1xuICAgIGZvciAobGV0IGkgb2YgdClcbiAgICAgIGkuYmV0d2VlbihlIC0gMSwgZSArIDEsIChzLCBvLCBhKSA9PiB7XG4gICAgICAgIGlmIChlID4gcyAmJiBlIDwgbykge1xuICAgICAgICAgIGxldCBsID0gciB8fCBuIHx8IChlIC0gcyA8IG8gLSBlID8gLTEgOiAxKTtcbiAgICAgICAgICBlID0gbCA8IDAgPyBzIDogbywgciA9IGw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIGlmICghcilcbiAgICAgIHJldHVybiBlO1xuICB9XG59XG5mdW5jdGlvbiBUZih0LCBlLCBuKSB7XG4gIGxldCByID0gaXUodC5zdGF0ZS5mYWNldCh1ZykubWFwKChpKSA9PiBpKHQpKSwgbi5mcm9tLCBlLmhlYWQgPiBuLmZyb20gPyAtMSA6IDEpO1xuICByZXR1cm4gciA9PSBuLmZyb20gPyBuIDogYWUuY3Vyc29yKHIsIHIgPCBuLmZyb20gPyAxIDogLTEpO1xufVxuY2xhc3MgcjUge1xuICBzZXRTZWxlY3Rpb25PcmlnaW4oZSkge1xuICAgIHRoaXMubGFzdFNlbGVjdGlvbk9yaWdpbiA9IGUsIHRoaXMubGFzdFNlbGVjdGlvblRpbWUgPSBEYXRlLm5vdygpO1xuICB9XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLnZpZXcgPSBlLCB0aGlzLmxhc3RLZXlDb2RlID0gMCwgdGhpcy5sYXN0S2V5VGltZSA9IDAsIHRoaXMubGFzdFRvdWNoVGltZSA9IDAsIHRoaXMubGFzdEZvY3VzVGltZSA9IDAsIHRoaXMubGFzdFNjcm9sbFRvcCA9IDAsIHRoaXMubGFzdFNjcm9sbExlZnQgPSAwLCB0aGlzLnBlbmRpbmdJT1NLZXkgPSB2b2lkIDAsIHRoaXMubGFzdFNlbGVjdGlvbk9yaWdpbiA9IG51bGwsIHRoaXMubGFzdFNlbGVjdGlvblRpbWUgPSAwLCB0aGlzLmxhc3RFc2NQcmVzcyA9IDAsIHRoaXMubGFzdENvbnRleHRNZW51ID0gMCwgdGhpcy5zY3JvbGxIYW5kbGVycyA9IFtdLCB0aGlzLmhhbmRsZXJzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIHRoaXMuY29tcG9zaW5nID0gLTEsIHRoaXMuY29tcG9zaXRpb25GaXJzdENoYW5nZSA9IG51bGwsIHRoaXMuY29tcG9zaXRpb25FbmRlZEF0ID0gMCwgdGhpcy5jb21wb3NpdGlvblBlbmRpbmdLZXkgPSAhMSwgdGhpcy5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2UgPSAhMSwgdGhpcy5tb3VzZVNlbGVjdGlvbiA9IG51bGwsIHRoaXMuZHJhZ2dlZENvbnRlbnQgPSBudWxsLCB0aGlzLmhhbmRsZUV2ZW50ID0gdGhpcy5oYW5kbGVFdmVudC5iaW5kKHRoaXMpLCB0aGlzLm5vdGlmaWVkRm9jdXNlZCA9IGUuaGFzRm9jdXMsIGRlLnNhZmFyaSAmJiBlLmNvbnRlbnRET00uYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsICgpID0+IG51bGwpLCBkZS5nZWNrbyAmJiB2NShlLmNvbnRlbnRET00ub3duZXJEb2N1bWVudCk7XG4gIH1cbiAgaGFuZGxlRXZlbnQoZSkge1xuICAgICFkNSh0aGlzLnZpZXcsIGUpIHx8IHRoaXMuaWdub3JlRHVyaW5nQ29tcG9zaXRpb24oZSkgfHwgZS50eXBlID09IFwia2V5ZG93blwiICYmIHRoaXMua2V5ZG93bihlKSB8fCB0aGlzLnJ1bkhhbmRsZXJzKGUudHlwZSwgZSk7XG4gIH1cbiAgcnVuSGFuZGxlcnMoZSwgbikge1xuICAgIGxldCByID0gdGhpcy5oYW5kbGVyc1tlXTtcbiAgICBpZiAocikge1xuICAgICAgZm9yIChsZXQgaSBvZiByLm9ic2VydmVycylcbiAgICAgICAgaSh0aGlzLnZpZXcsIG4pO1xuICAgICAgZm9yIChsZXQgaSBvZiByLmhhbmRsZXJzKSB7XG4gICAgICAgIGlmIChuLmRlZmF1bHRQcmV2ZW50ZWQpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChpKHRoaXMudmlldywgbikpIHtcbiAgICAgICAgICBuLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZW5zdXJlSGFuZGxlcnMoZSkge1xuICAgIGxldCBuID0gaTUoZSksIHIgPSB0aGlzLmhhbmRsZXJzLCBpID0gdGhpcy52aWV3LmNvbnRlbnRET007XG4gICAgZm9yIChsZXQgcyBpbiBuKVxuICAgICAgaWYgKHMgIT0gXCJzY3JvbGxcIikge1xuICAgICAgICBsZXQgbyA9ICFuW3NdLmhhbmRsZXJzLmxlbmd0aCwgYSA9IHJbc107XG4gICAgICAgIGEgJiYgbyAhPSAhYS5oYW5kbGVycy5sZW5ndGggJiYgKGkucmVtb3ZlRXZlbnRMaXN0ZW5lcihzLCB0aGlzLmhhbmRsZUV2ZW50KSwgYSA9IG51bGwpLCBhIHx8IGkuYWRkRXZlbnRMaXN0ZW5lcihzLCB0aGlzLmhhbmRsZUV2ZW50LCB7IHBhc3NpdmU6IG8gfSk7XG4gICAgICB9XG4gICAgZm9yIChsZXQgcyBpbiByKVxuICAgICAgcyAhPSBcInNjcm9sbFwiICYmICFuW3NdICYmIGkucmVtb3ZlRXZlbnRMaXN0ZW5lcihzLCB0aGlzLmhhbmRsZUV2ZW50KTtcbiAgICB0aGlzLmhhbmRsZXJzID0gbjtcbiAgfVxuICBrZXlkb3duKGUpIHtcbiAgICBpZiAodGhpcy5sYXN0S2V5Q29kZSA9IGUua2V5Q29kZSwgdGhpcy5sYXN0S2V5VGltZSA9IERhdGUubm93KCksIGUua2V5Q29kZSA9PSA5ICYmIERhdGUubm93KCkgPCB0aGlzLmxhc3RFc2NQcmVzcyArIDJlMylcbiAgICAgIHJldHVybiAhMDtcbiAgICBpZiAoZS5rZXlDb2RlICE9IDI3ICYmIEFrLmluZGV4T2YoZS5rZXlDb2RlKSA8IDAgJiYgKHRoaXMudmlldy5pbnB1dFN0YXRlLmxhc3RFc2NQcmVzcyA9IDApLCBkZS5hbmRyb2lkICYmIGRlLmNocm9tZSAmJiAhZS5zeW50aGV0aWMgJiYgKGUua2V5Q29kZSA9PSAxMyB8fCBlLmtleUNvZGUgPT0gOCkpXG4gICAgICByZXR1cm4gdGhpcy52aWV3Lm9ic2VydmVyLmRlbGF5QW5kcm9pZEtleShlLmtleSwgZS5rZXlDb2RlKSwgITA7XG4gICAgbGV0IG47XG4gICAgcmV0dXJuIGRlLmlvcyAmJiAhZS5zeW50aGV0aWMgJiYgIWUuYWx0S2V5ICYmICFlLm1ldGFLZXkgJiYgKChuID0gQ2suZmluZCgocikgPT4gci5rZXlDb2RlID09IGUua2V5Q29kZSkpICYmICFlLmN0cmxLZXkgfHwgczUuaW5kZXhPZihlLmtleSkgPiAtMSAmJiBlLmN0cmxLZXkgJiYgIWUuc2hpZnRLZXkpID8gKHRoaXMucGVuZGluZ0lPU0tleSA9IG4gfHwgZSwgc2V0VGltZW91dCgoKSA9PiB0aGlzLmZsdXNoSU9TS2V5KCksIDI1MCksICEwKSA6IChlLmtleUNvZGUgIT0gMjI5ICYmIHRoaXMudmlldy5vYnNlcnZlci5mb3JjZUZsdXNoKCksICExKTtcbiAgfVxuICBmbHVzaElPU0tleSgpIHtcbiAgICBsZXQgZSA9IHRoaXMucGVuZGluZ0lPU0tleTtcbiAgICByZXR1cm4gZSA/ICh0aGlzLnBlbmRpbmdJT1NLZXkgPSB2b2lkIDAsIFRvKHRoaXMudmlldy5jb250ZW50RE9NLCBlLmtleSwgZS5rZXlDb2RlKSkgOiAhMTtcbiAgfVxuICBpZ25vcmVEdXJpbmdDb21wb3NpdGlvbihlKSB7XG4gICAgcmV0dXJuIC9ea2V5Ly50ZXN0KGUudHlwZSkgPyB0aGlzLmNvbXBvc2luZyA+IDAgPyAhMCA6IGRlLnNhZmFyaSAmJiAhZGUuaW9zICYmIHRoaXMuY29tcG9zaXRpb25QZW5kaW5nS2V5ICYmIERhdGUubm93KCkgLSB0aGlzLmNvbXBvc2l0aW9uRW5kZWRBdCA8IDEwMCA/ICh0aGlzLmNvbXBvc2l0aW9uUGVuZGluZ0tleSA9ICExLCAhMCkgOiAhMSA6ICExO1xuICB9XG4gIHN0YXJ0TW91c2VTZWxlY3Rpb24oZSkge1xuICAgIHRoaXMubW91c2VTZWxlY3Rpb24gJiYgdGhpcy5tb3VzZVNlbGVjdGlvbi5kZXN0cm95KCksIHRoaXMubW91c2VTZWxlY3Rpb24gPSBlO1xuICB9XG4gIHVwZGF0ZShlKSB7XG4gICAgdGhpcy5tb3VzZVNlbGVjdGlvbiAmJiB0aGlzLm1vdXNlU2VsZWN0aW9uLnVwZGF0ZShlKSwgdGhpcy5kcmFnZ2VkQ29udGVudCAmJiBlLmRvY0NoYW5nZWQgJiYgKHRoaXMuZHJhZ2dlZENvbnRlbnQgPSB0aGlzLmRyYWdnZWRDb250ZW50Lm1hcChlLmNoYW5nZXMpKSwgZS50cmFuc2FjdGlvbnMubGVuZ3RoICYmICh0aGlzLmxhc3RLZXlDb2RlID0gdGhpcy5sYXN0U2VsZWN0aW9uVGltZSA9IDApO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5tb3VzZVNlbGVjdGlvbiAmJiB0aGlzLm1vdXNlU2VsZWN0aW9uLmRlc3Ryb3koKTtcbiAgfVxufVxuZnVuY3Rpb24gb3YodCwgZSkge1xuICByZXR1cm4gKG4sIHIpID0+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGUuY2FsbCh0LCByLCBuKTtcbiAgICB9IGNhdGNoIChpKSB7XG4gICAgICBocihuLnN0YXRlLCBpKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBpNSh0KSB7XG4gIGxldCBlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGZ1bmN0aW9uIG4ocikge1xuICAgIHJldHVybiBlW3JdIHx8IChlW3JdID0geyBvYnNlcnZlcnM6IFtdLCBoYW5kbGVyczogW10gfSk7XG4gIH1cbiAgZm9yIChsZXQgciBvZiB0KSB7XG4gICAgbGV0IGkgPSByLnNwZWM7XG4gICAgaWYgKGkgJiYgaS5kb21FdmVudEhhbmRsZXJzKVxuICAgICAgZm9yIChsZXQgcyBpbiBpLmRvbUV2ZW50SGFuZGxlcnMpIHtcbiAgICAgICAgbGV0IG8gPSBpLmRvbUV2ZW50SGFuZGxlcnNbc107XG4gICAgICAgIG8gJiYgbihzKS5oYW5kbGVycy5wdXNoKG92KHIudmFsdWUsIG8pKTtcbiAgICAgIH1cbiAgICBpZiAoaSAmJiBpLmRvbUV2ZW50T2JzZXJ2ZXJzKVxuICAgICAgZm9yIChsZXQgcyBpbiBpLmRvbUV2ZW50T2JzZXJ2ZXJzKSB7XG4gICAgICAgIGxldCBvID0gaS5kb21FdmVudE9ic2VydmVyc1tzXTtcbiAgICAgICAgbyAmJiBuKHMpLm9ic2VydmVycy5wdXNoKG92KHIudmFsdWUsIG8pKTtcbiAgICAgIH1cbiAgfVxuICBmb3IgKGxldCByIGluIGJyKVxuICAgIG4ocikuaGFuZGxlcnMucHVzaChicltyXSk7XG4gIGZvciAobGV0IHIgaW4gdnIpXG4gICAgbihyKS5vYnNlcnZlcnMucHVzaCh2cltyXSk7XG4gIHJldHVybiBlO1xufVxuY29uc3QgQ2sgPSBbXG4gIHsga2V5OiBcIkJhY2tzcGFjZVwiLCBrZXlDb2RlOiA4LCBpbnB1dFR5cGU6IFwiZGVsZXRlQ29udGVudEJhY2t3YXJkXCIgfSxcbiAgeyBrZXk6IFwiRW50ZXJcIiwga2V5Q29kZTogMTMsIGlucHV0VHlwZTogXCJpbnNlcnRQYXJhZ3JhcGhcIiB9LFxuICB7IGtleTogXCJFbnRlclwiLCBrZXlDb2RlOiAxMywgaW5wdXRUeXBlOiBcImluc2VydExpbmVCcmVha1wiIH0sXG4gIHsga2V5OiBcIkRlbGV0ZVwiLCBrZXlDb2RlOiA0NiwgaW5wdXRUeXBlOiBcImRlbGV0ZUNvbnRlbnRGb3J3YXJkXCIgfVxuXSwgczUgPSBcImR0aGtvXCIsIEFrID0gWzE2LCAxNywgMTgsIDIwLCA5MSwgOTIsIDIyNCwgMjI1XSwgVGMgPSA2O1xuZnVuY3Rpb24gRWModCkge1xuICByZXR1cm4gTWF0aC5tYXgoMCwgdCkgKiAwLjcgKyA4O1xufVxuZnVuY3Rpb24gbzUodCwgZSkge1xuICByZXR1cm4gTWF0aC5tYXgoTWF0aC5hYnModC5jbGllbnRYIC0gZS5jbGllbnRYKSwgTWF0aC5hYnModC5jbGllbnRZIC0gZS5jbGllbnRZKSk7XG59XG5jbGFzcyBhNSB7XG4gIGNvbnN0cnVjdG9yKGUsIG4sIHIsIGkpIHtcbiAgICB0aGlzLnZpZXcgPSBlLCB0aGlzLnN0YXJ0RXZlbnQgPSBuLCB0aGlzLnN0eWxlID0gciwgdGhpcy5tdXN0U2VsZWN0ID0gaSwgdGhpcy5zY3JvbGxTcGVlZCA9IHsgeDogMCwgeTogMCB9LCB0aGlzLnNjcm9sbGluZyA9IC0xLCB0aGlzLmxhc3RFdmVudCA9IG4sIHRoaXMuc2Nyb2xsUGFyZW50ID0gU04oZS5jb250ZW50RE9NKSwgdGhpcy5hdG9tcyA9IGUuc3RhdGUuZmFjZXQodWcpLm1hcCgobykgPT4gbyhlKSk7XG4gICAgbGV0IHMgPSBlLmNvbnRlbnRET00ub3duZXJEb2N1bWVudDtcbiAgICBzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3ZlID0gdGhpcy5tb3ZlLmJpbmQodGhpcykpLCBzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIHRoaXMudXAgPSB0aGlzLnVwLmJpbmQodGhpcykpLCB0aGlzLmV4dGVuZCA9IG4uc2hpZnRLZXksIHRoaXMubXVsdGlwbGUgPSBlLnN0YXRlLmZhY2V0KFllLmFsbG93TXVsdGlwbGVTZWxlY3Rpb25zKSAmJiBsNShlLCBuKSwgdGhpcy5kcmFnZ2luZyA9IHU1KGUsIG4pICYmIFprKG4pID09IDEgPyBudWxsIDogITE7XG4gIH1cbiAgc3RhcnQoZSkge1xuICAgIHRoaXMuZHJhZ2dpbmcgPT09ICExICYmIHRoaXMuc2VsZWN0KGUpO1xuICB9XG4gIG1vdmUoZSkge1xuICAgIHZhciBuO1xuICAgIGlmIChlLmJ1dHRvbnMgPT0gMClcbiAgICAgIHJldHVybiB0aGlzLmRlc3Ryb3koKTtcbiAgICBpZiAodGhpcy5kcmFnZ2luZyB8fCB0aGlzLmRyYWdnaW5nID09IG51bGwgJiYgbzUodGhpcy5zdGFydEV2ZW50LCBlKSA8IDEwKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuc2VsZWN0KHRoaXMubGFzdEV2ZW50ID0gZSk7XG4gICAgbGV0IHIgPSAwLCBpID0gMCwgcyA9ICgobiA9IHRoaXMuc2Nyb2xsUGFyZW50KSA9PT0gbnVsbCB8fCBuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSB8fCB7IGxlZnQ6IDAsIHRvcDogMCwgcmlnaHQ6IHRoaXMudmlldy53aW4uaW5uZXJXaWR0aCwgYm90dG9tOiB0aGlzLnZpZXcud2luLmlubmVySGVpZ2h0IH0sIG8gPSBUayh0aGlzLnZpZXcpO1xuICAgIGUuY2xpZW50WCAtIG8ubGVmdCA8PSBzLmxlZnQgKyBUYyA/IHIgPSAtRWMocy5sZWZ0IC0gZS5jbGllbnRYKSA6IGUuY2xpZW50WCArIG8ucmlnaHQgPj0gcy5yaWdodCAtIFRjICYmIChyID0gRWMoZS5jbGllbnRYIC0gcy5yaWdodCkpLCBlLmNsaWVudFkgLSBvLnRvcCA8PSBzLnRvcCArIFRjID8gaSA9IC1FYyhzLnRvcCAtIGUuY2xpZW50WSkgOiBlLmNsaWVudFkgKyBvLmJvdHRvbSA+PSBzLmJvdHRvbSAtIFRjICYmIChpID0gRWMoZS5jbGllbnRZIC0gcy5ib3R0b20pKSwgdGhpcy5zZXRTY3JvbGxTcGVlZChyLCBpKTtcbiAgfVxuICB1cChlKSB7XG4gICAgdGhpcy5kcmFnZ2luZyA9PSBudWxsICYmIHRoaXMuc2VsZWN0KHRoaXMubGFzdEV2ZW50KSwgdGhpcy5kcmFnZ2luZyB8fCBlLnByZXZlbnREZWZhdWx0KCksIHRoaXMuZGVzdHJveSgpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5zZXRTY3JvbGxTcGVlZCgwLCAwKTtcbiAgICBsZXQgZSA9IHRoaXMudmlldy5jb250ZW50RE9NLm93bmVyRG9jdW1lbnQ7XG4gICAgZS5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW92ZSksIGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy51cCksIHRoaXMudmlldy5pbnB1dFN0YXRlLm1vdXNlU2VsZWN0aW9uID0gdGhpcy52aWV3LmlucHV0U3RhdGUuZHJhZ2dlZENvbnRlbnQgPSBudWxsO1xuICB9XG4gIHNldFNjcm9sbFNwZWVkKGUsIG4pIHtcbiAgICB0aGlzLnNjcm9sbFNwZWVkID0geyB4OiBlLCB5OiBuIH0sIGUgfHwgbiA/IHRoaXMuc2Nyb2xsaW5nIDwgMCAmJiAodGhpcy5zY3JvbGxpbmcgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLnNjcm9sbCgpLCA1MCkpIDogdGhpcy5zY3JvbGxpbmcgPiAtMSAmJiAoY2xlYXJJbnRlcnZhbCh0aGlzLnNjcm9sbGluZyksIHRoaXMuc2Nyb2xsaW5nID0gLTEpO1xuICB9XG4gIHNjcm9sbCgpIHtcbiAgICB0aGlzLnNjcm9sbFBhcmVudCA/ICh0aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0ICs9IHRoaXMuc2Nyb2xsU3BlZWQueCwgdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsVG9wICs9IHRoaXMuc2Nyb2xsU3BlZWQueSkgOiB0aGlzLnZpZXcud2luLnNjcm9sbEJ5KHRoaXMuc2Nyb2xsU3BlZWQueCwgdGhpcy5zY3JvbGxTcGVlZC55KSwgdGhpcy5kcmFnZ2luZyA9PT0gITEgJiYgdGhpcy5zZWxlY3QodGhpcy5sYXN0RXZlbnQpO1xuICB9XG4gIHNraXBBdG9tcyhlKSB7XG4gICAgbGV0IG4gPSBudWxsO1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgZS5yYW5nZXMubGVuZ3RoOyByKyspIHtcbiAgICAgIGxldCBpID0gZS5yYW5nZXNbcl0sIHMgPSBudWxsO1xuICAgICAgaWYgKGkuZW1wdHkpIHtcbiAgICAgICAgbGV0IG8gPSBpdSh0aGlzLmF0b21zLCBpLmZyb20sIDApO1xuICAgICAgICBvICE9IGkuZnJvbSAmJiAocyA9IGFlLmN1cnNvcihvLCAtMSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IG8gPSBpdSh0aGlzLmF0b21zLCBpLmZyb20sIC0xKSwgYSA9IGl1KHRoaXMuYXRvbXMsIGkudG8sIDEpO1xuICAgICAgICAobyAhPSBpLmZyb20gfHwgYSAhPSBpLnRvKSAmJiAocyA9IGFlLnJhbmdlKGkuZnJvbSA9PSBpLmFuY2hvciA/IG8gOiBhLCBpLmZyb20gPT0gaS5oZWFkID8gbyA6IGEpKTtcbiAgICAgIH1cbiAgICAgIHMgJiYgKG4gfHwgKG4gPSBlLnJhbmdlcy5zbGljZSgpKSwgbltyXSA9IHMpO1xuICAgIH1cbiAgICByZXR1cm4gbiA/IGFlLmNyZWF0ZShuLCBlLm1haW5JbmRleCkgOiBlO1xuICB9XG4gIHNlbGVjdChlKSB7XG4gICAgbGV0IHsgdmlldzogbiB9ID0gdGhpcywgciA9IHRoaXMuc2tpcEF0b21zKHRoaXMuc3R5bGUuZ2V0KGUsIHRoaXMuZXh0ZW5kLCB0aGlzLm11bHRpcGxlKSk7XG4gICAgKHRoaXMubXVzdFNlbGVjdCB8fCAhci5lcShuLnN0YXRlLnNlbGVjdGlvbiwgdGhpcy5kcmFnZ2luZyA9PT0gITEpKSAmJiB0aGlzLnZpZXcuZGlzcGF0Y2goe1xuICAgICAgc2VsZWN0aW9uOiByLFxuICAgICAgdXNlckV2ZW50OiBcInNlbGVjdC5wb2ludGVyXCJcbiAgICB9KSwgdGhpcy5tdXN0U2VsZWN0ID0gITE7XG4gIH1cbiAgdXBkYXRlKGUpIHtcbiAgICB0aGlzLnN0eWxlLnVwZGF0ZShlKSAmJiBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2VsZWN0KHRoaXMubGFzdEV2ZW50KSwgMjApO1xuICB9XG59XG5mdW5jdGlvbiBsNSh0LCBlKSB7XG4gIGxldCBuID0gdC5zdGF0ZS5mYWNldChnayk7XG4gIHJldHVybiBuLmxlbmd0aCA/IG5bMF0oZSkgOiBkZS5tYWMgPyBlLm1ldGFLZXkgOiBlLmN0cmxLZXk7XG59XG5mdW5jdGlvbiBjNSh0LCBlKSB7XG4gIGxldCBuID0gdC5zdGF0ZS5mYWNldChtayk7XG4gIHJldHVybiBuLmxlbmd0aCA/IG5bMF0oZSkgOiBkZS5tYWMgPyAhZS5hbHRLZXkgOiAhZS5jdHJsS2V5O1xufVxuZnVuY3Rpb24gdTUodCwgZSkge1xuICBsZXQgeyBtYWluOiBuIH0gPSB0LnN0YXRlLnNlbGVjdGlvbjtcbiAgaWYgKG4uZW1wdHkpXG4gICAgcmV0dXJuICExO1xuICBsZXQgciA9IEl1KHQucm9vdCk7XG4gIGlmICghciB8fCByLnJhbmdlQ291bnQgPT0gMClcbiAgICByZXR1cm4gITA7XG4gIGxldCBpID0gci5nZXRSYW5nZUF0KDApLmdldENsaWVudFJlY3RzKCk7XG4gIGZvciAobGV0IHMgPSAwOyBzIDwgaS5sZW5ndGg7IHMrKykge1xuICAgIGxldCBvID0gaVtzXTtcbiAgICBpZiAoby5sZWZ0IDw9IGUuY2xpZW50WCAmJiBvLnJpZ2h0ID49IGUuY2xpZW50WCAmJiBvLnRvcCA8PSBlLmNsaWVudFkgJiYgby5ib3R0b20gPj0gZS5jbGllbnRZKVxuICAgICAgcmV0dXJuICEwO1xuICB9XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIGQ1KHQsIGUpIHtcbiAgaWYgKCFlLmJ1YmJsZXMpXG4gICAgcmV0dXJuICEwO1xuICBpZiAoZS5kZWZhdWx0UHJldmVudGVkKVxuICAgIHJldHVybiAhMTtcbiAgZm9yIChsZXQgbiA9IGUudGFyZ2V0LCByOyBuICE9IHQuY29udGVudERPTTsgbiA9IG4ucGFyZW50Tm9kZSlcbiAgICBpZiAoIW4gfHwgbi5ub2RlVHlwZSA9PSAxMSB8fCAociA9IGZ0LmdldChuKSkgJiYgci5pZ25vcmVFdmVudChlKSlcbiAgICAgIHJldHVybiAhMTtcbiAgcmV0dXJuICEwO1xufVxuY29uc3QgYnIgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgdnIgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgUmsgPSBkZS5pZSAmJiBkZS5pZV92ZXJzaW9uIDwgMTUgfHwgZGUuaW9zICYmIGRlLndlYmtpdF92ZXJzaW9uIDwgNjA0O1xuZnVuY3Rpb24gZjUodCkge1xuICBsZXQgZSA9IHQuZG9tLnBhcmVudE5vZGU7XG4gIGlmICghZSlcbiAgICByZXR1cm47XG4gIGxldCBuID0gZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIikpO1xuICBuLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBmaXhlZDsgbGVmdDogLTEwMDAwcHg7IHRvcDogMTBweFwiLCBuLmZvY3VzKCksIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgIHQuZm9jdXMoKSwgbi5yZW1vdmUoKSwgTmsodCwgbi52YWx1ZSk7XG4gIH0sIDUwKTtcbn1cbmZ1bmN0aW9uIE5rKHQsIGUpIHtcbiAgbGV0IHsgc3RhdGU6IG4gfSA9IHQsIHIsIGkgPSAxLCBzID0gbi50b1RleHQoZSksIG8gPSBzLmxpbmVzID09IG4uc2VsZWN0aW9uLnJhbmdlcy5sZW5ndGg7XG4gIGlmIChwcCAhPSBudWxsICYmIG4uc2VsZWN0aW9uLnJhbmdlcy5ldmVyeSgobCkgPT4gbC5lbXB0eSkgJiYgcHAgPT0gcy50b1N0cmluZygpKSB7XG4gICAgbGV0IGwgPSAtMTtcbiAgICByID0gbi5jaGFuZ2VCeVJhbmdlKChjKSA9PiB7XG4gICAgICBsZXQgdSA9IG4uZG9jLmxpbmVBdChjLmZyb20pO1xuICAgICAgaWYgKHUuZnJvbSA9PSBsKVxuICAgICAgICByZXR1cm4geyByYW5nZTogYyB9O1xuICAgICAgbCA9IHUuZnJvbTtcbiAgICAgIGxldCBkID0gbi50b1RleHQoKG8gPyBzLmxpbmUoaSsrKS50ZXh0IDogZSkgKyBuLmxpbmVCcmVhayk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjaGFuZ2VzOiB7IGZyb206IHUuZnJvbSwgaW5zZXJ0OiBkIH0sXG4gICAgICAgIHJhbmdlOiBhZS5jdXJzb3IoYy5mcm9tICsgZC5sZW5ndGgpXG4gICAgICB9O1xuICAgIH0pO1xuICB9IGVsc2VcbiAgICBvID8gciA9IG4uY2hhbmdlQnlSYW5nZSgobCkgPT4ge1xuICAgICAgbGV0IGMgPSBzLmxpbmUoaSsrKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNoYW5nZXM6IHsgZnJvbTogbC5mcm9tLCB0bzogbC50bywgaW5zZXJ0OiBjLnRleHQgfSxcbiAgICAgICAgcmFuZ2U6IGFlLmN1cnNvcihsLmZyb20gKyBjLmxlbmd0aClcbiAgICAgIH07XG4gICAgfSkgOiByID0gbi5yZXBsYWNlU2VsZWN0aW9uKHMpO1xuICB0LmRpc3BhdGNoKHIsIHtcbiAgICB1c2VyRXZlbnQ6IFwiaW5wdXQucGFzdGVcIixcbiAgICBzY3JvbGxJbnRvVmlldzogITBcbiAgfSk7XG59XG52ci5zY3JvbGwgPSAodCkgPT4ge1xuICB0LmlucHV0U3RhdGUubGFzdFNjcm9sbFRvcCA9IHQuc2Nyb2xsRE9NLnNjcm9sbFRvcCwgdC5pbnB1dFN0YXRlLmxhc3RTY3JvbGxMZWZ0ID0gdC5zY3JvbGxET00uc2Nyb2xsTGVmdDtcbn07XG5ici5rZXlkb3duID0gKHQsIGUpID0+ICh0LmlucHV0U3RhdGUuc2V0U2VsZWN0aW9uT3JpZ2luKFwic2VsZWN0XCIpLCBlLmtleUNvZGUgPT0gMjcgJiYgKHQuaW5wdXRTdGF0ZS5sYXN0RXNjUHJlc3MgPSBEYXRlLm5vdygpKSwgITEpO1xudnIudG91Y2hzdGFydCA9ICh0LCBlKSA9PiB7XG4gIHQuaW5wdXRTdGF0ZS5sYXN0VG91Y2hUaW1lID0gRGF0ZS5ub3coKSwgdC5pbnB1dFN0YXRlLnNldFNlbGVjdGlvbk9yaWdpbihcInNlbGVjdC5wb2ludGVyXCIpO1xufTtcbnZyLnRvdWNobW92ZSA9ICh0KSA9PiB7XG4gIHQuaW5wdXRTdGF0ZS5zZXRTZWxlY3Rpb25PcmlnaW4oXCJzZWxlY3QucG9pbnRlclwiKTtcbn07XG5ici5tb3VzZWRvd24gPSAodCwgZSkgPT4ge1xuICBpZiAodC5vYnNlcnZlci5mbHVzaCgpLCB0LmlucHV0U3RhdGUubGFzdFRvdWNoVGltZSA+IERhdGUubm93KCkgLSAyZTMpXG4gICAgcmV0dXJuICExO1xuICBsZXQgbiA9IG51bGw7XG4gIGZvciAobGV0IHIgb2YgdC5zdGF0ZS5mYWNldChiaykpXG4gICAgaWYgKG4gPSByKHQsIGUpLCBuKVxuICAgICAgYnJlYWs7XG4gIGlmICghbiAmJiBlLmJ1dHRvbiA9PSAwICYmIChuID0gTzUodCwgZSkpLCBuKSB7XG4gICAgbGV0IHIgPSAhdC5oYXNGb2N1cztcbiAgICB0LmlucHV0U3RhdGUuc3RhcnRNb3VzZVNlbGVjdGlvbihuZXcgYTUodCwgZSwgbiwgcikpLCByICYmIHQub2JzZXJ2ZXIuaWdub3JlKCgpID0+IEp3KHQuY29udGVudERPTSkpO1xuICAgIGxldCBpID0gdC5pbnB1dFN0YXRlLm1vdXNlU2VsZWN0aW9uO1xuICAgIGlmIChpKVxuICAgICAgcmV0dXJuIGkuc3RhcnQoZSksIGkuZHJhZ2dpbmcgPT09ICExO1xuICB9XG4gIHJldHVybiAhMTtcbn07XG5mdW5jdGlvbiBhdih0LCBlLCBuLCByKSB7XG4gIGlmIChyID09IDEpXG4gICAgcmV0dXJuIGFlLmN1cnNvcihlLCBuKTtcbiAgaWYgKHIgPT0gMilcbiAgICByZXR1cm4gek4odC5zdGF0ZSwgZSwgbik7XG4gIHtcbiAgICBsZXQgaSA9IE50LmZpbmQodC5kb2NWaWV3LCBlKSwgcyA9IHQuc3RhdGUuZG9jLmxpbmVBdChpID8gaS5wb3NBdEVuZCA6IGUpLCBvID0gaSA/IGkucG9zQXRTdGFydCA6IHMuZnJvbSwgYSA9IGkgPyBpLnBvc0F0RW5kIDogcy50bztcbiAgICByZXR1cm4gYSA8IHQuc3RhdGUuZG9jLmxlbmd0aCAmJiBhID09IHMudG8gJiYgYSsrLCBhZS5yYW5nZShvLCBhKTtcbiAgfVxufVxubGV0IERrID0gKHQsIGUpID0+IHQgPj0gZS50b3AgJiYgdCA8PSBlLmJvdHRvbSwgbHYgPSAodCwgZSwgbikgPT4gRGsoZSwgbikgJiYgdCA+PSBuLmxlZnQgJiYgdCA8PSBuLnJpZ2h0O1xuZnVuY3Rpb24gaDUodCwgZSwgbiwgcikge1xuICBsZXQgaSA9IE50LmZpbmQodC5kb2NWaWV3LCBlKTtcbiAgaWYgKCFpKVxuICAgIHJldHVybiAxO1xuICBsZXQgcyA9IGUgLSBpLnBvc0F0U3RhcnQ7XG4gIGlmIChzID09IDApXG4gICAgcmV0dXJuIDE7XG4gIGlmIChzID09IGkubGVuZ3RoKVxuICAgIHJldHVybiAtMTtcbiAgbGV0IG8gPSBpLmNvb3Jkc0F0KHMsIC0xKTtcbiAgaWYgKG8gJiYgbHYobiwgciwgbykpXG4gICAgcmV0dXJuIC0xO1xuICBsZXQgYSA9IGkuY29vcmRzQXQocywgMSk7XG4gIHJldHVybiBhICYmIGx2KG4sIHIsIGEpID8gMSA6IG8gJiYgRGsociwgbykgPyAtMSA6IDE7XG59XG5mdW5jdGlvbiBjdih0LCBlKSB7XG4gIGxldCBuID0gdC5wb3NBdENvb3Jkcyh7IHg6IGUuY2xpZW50WCwgeTogZS5jbGllbnRZIH0sICExKTtcbiAgcmV0dXJuIHsgcG9zOiBuLCBiaWFzOiBoNSh0LCBuLCBlLmNsaWVudFgsIGUuY2xpZW50WSkgfTtcbn1cbmNvbnN0IHA1ID0gZGUuaWUgJiYgZGUuaWVfdmVyc2lvbiA8PSAxMTtcbmxldCB1diA9IG51bGwsIGR2ID0gMCwgZnYgPSAwO1xuZnVuY3Rpb24gWmsodCkge1xuICBpZiAoIXA1KVxuICAgIHJldHVybiB0LmRldGFpbDtcbiAgbGV0IGUgPSB1diwgbiA9IGZ2O1xuICByZXR1cm4gdXYgPSB0LCBmdiA9IERhdGUubm93KCksIGR2ID0gIWUgfHwgbiA+IERhdGUubm93KCkgLSA0MDAgJiYgTWF0aC5hYnMoZS5jbGllbnRYIC0gdC5jbGllbnRYKSA8IDIgJiYgTWF0aC5hYnMoZS5jbGllbnRZIC0gdC5jbGllbnRZKSA8IDIgPyAoZHYgKyAxKSAlIDMgOiAxO1xufVxuZnVuY3Rpb24gTzUodCwgZSkge1xuICBsZXQgbiA9IGN2KHQsIGUpLCByID0gWmsoZSksIGkgPSB0LnN0YXRlLnNlbGVjdGlvbjtcbiAgcmV0dXJuIHtcbiAgICB1cGRhdGUocykge1xuICAgICAgcy5kb2NDaGFuZ2VkICYmIChuLnBvcyA9IHMuY2hhbmdlcy5tYXBQb3Mobi5wb3MpLCBpID0gaS5tYXAocy5jaGFuZ2VzKSk7XG4gICAgfSxcbiAgICBnZXQocywgbywgYSkge1xuICAgICAgbGV0IGwgPSBjdih0LCBzKSwgYywgdSA9IGF2KHQsIGwucG9zLCBsLmJpYXMsIHIpO1xuICAgICAgaWYgKG4ucG9zICE9IGwucG9zICYmICFvKSB7XG4gICAgICAgIGxldCBkID0gYXYodCwgbi5wb3MsIG4uYmlhcywgciksIGYgPSBNYXRoLm1pbihkLmZyb20sIHUuZnJvbSksIGggPSBNYXRoLm1heChkLnRvLCB1LnRvKTtcbiAgICAgICAgdSA9IGYgPCB1LmZyb20gPyBhZS5yYW5nZShmLCBoKSA6IGFlLnJhbmdlKGgsIGYpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG8gPyBpLnJlcGxhY2VSYW5nZShpLm1haW4uZXh0ZW5kKHUuZnJvbSwgdS50bykpIDogYSAmJiByID09IDEgJiYgaS5yYW5nZXMubGVuZ3RoID4gMSAmJiAoYyA9IGc1KGksIGwucG9zKSkgPyBjIDogYSA/IGkuYWRkUmFuZ2UodSkgOiBhZS5jcmVhdGUoW3VdKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBnNSh0LCBlKSB7XG4gIGZvciAobGV0IG4gPSAwOyBuIDwgdC5yYW5nZXMubGVuZ3RoOyBuKyspIHtcbiAgICBsZXQgeyBmcm9tOiByLCB0bzogaSB9ID0gdC5yYW5nZXNbbl07XG4gICAgaWYgKHIgPD0gZSAmJiBpID49IGUpXG4gICAgICByZXR1cm4gYWUuY3JlYXRlKHQucmFuZ2VzLnNsaWNlKDAsIG4pLmNvbmNhdCh0LnJhbmdlcy5zbGljZShuICsgMSkpLCB0Lm1haW5JbmRleCA9PSBuID8gMCA6IHQubWFpbkluZGV4IC0gKHQubWFpbkluZGV4ID4gbiA/IDEgOiAwKSk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5ici5kcmFnc3RhcnQgPSAodCwgZSkgPT4ge1xuICBsZXQgeyBzZWxlY3Rpb246IHsgbWFpbjogbiB9IH0gPSB0LnN0YXRlO1xuICBpZiAoZS50YXJnZXQuZHJhZ2dhYmxlKSB7XG4gICAgbGV0IGkgPSB0LmRvY1ZpZXcubmVhcmVzdChlLnRhcmdldCk7XG4gICAgaWYgKGkgJiYgaS5pc1dpZGdldCkge1xuICAgICAgbGV0IHMgPSBpLnBvc0F0U3RhcnQsIG8gPSBzICsgaS5sZW5ndGg7XG4gICAgICAocyA+PSBuLnRvIHx8IG8gPD0gbi5mcm9tKSAmJiAobiA9IGFlLnJhbmdlKHMsIG8pKTtcbiAgICB9XG4gIH1cbiAgbGV0IHsgaW5wdXRTdGF0ZTogciB9ID0gdDtcbiAgcmV0dXJuIHIubW91c2VTZWxlY3Rpb24gJiYgKHIubW91c2VTZWxlY3Rpb24uZHJhZ2dpbmcgPSAhMCksIHIuZHJhZ2dlZENvbnRlbnQgPSBuLCBlLmRhdGFUcmFuc2ZlciAmJiAoZS5kYXRhVHJhbnNmZXIuc2V0RGF0YShcIlRleHRcIiwgdC5zdGF0ZS5zbGljZURvYyhuLmZyb20sIG4udG8pKSwgZS5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9IFwiY29weU1vdmVcIiksICExO1xufTtcbmJyLmRyYWdlbmQgPSAodCkgPT4gKHQuaW5wdXRTdGF0ZS5kcmFnZ2VkQ29udGVudCA9IG51bGwsICExKTtcbmZ1bmN0aW9uIGh2KHQsIGUsIG4sIHIpIHtcbiAgaWYgKCFuKVxuICAgIHJldHVybjtcbiAgbGV0IGkgPSB0LnBvc0F0Q29vcmRzKHsgeDogZS5jbGllbnRYLCB5OiBlLmNsaWVudFkgfSwgITEpLCB7IGRyYWdnZWRDb250ZW50OiBzIH0gPSB0LmlucHV0U3RhdGUsIG8gPSByICYmIHMgJiYgYzUodCwgZSkgPyB7IGZyb206IHMuZnJvbSwgdG86IHMudG8gfSA6IG51bGwsIGEgPSB7IGZyb206IGksIGluc2VydDogbiB9LCBsID0gdC5zdGF0ZS5jaGFuZ2VzKG8gPyBbbywgYV0gOiBhKTtcbiAgdC5mb2N1cygpLCB0LmRpc3BhdGNoKHtcbiAgICBjaGFuZ2VzOiBsLFxuICAgIHNlbGVjdGlvbjogeyBhbmNob3I6IGwubWFwUG9zKGksIC0xKSwgaGVhZDogbC5tYXBQb3MoaSwgMSkgfSxcbiAgICB1c2VyRXZlbnQ6IG8gPyBcIm1vdmUuZHJvcFwiIDogXCJpbnB1dC5kcm9wXCJcbiAgfSksIHQuaW5wdXRTdGF0ZS5kcmFnZ2VkQ29udGVudCA9IG51bGw7XG59XG5ici5kcm9wID0gKHQsIGUpID0+IHtcbiAgaWYgKCFlLmRhdGFUcmFuc2ZlcilcbiAgICByZXR1cm4gITE7XG4gIGlmICh0LnN0YXRlLnJlYWRPbmx5KVxuICAgIHJldHVybiAhMDtcbiAgbGV0IG4gPSBlLmRhdGFUcmFuc2Zlci5maWxlcztcbiAgaWYgKG4gJiYgbi5sZW5ndGgpIHtcbiAgICBsZXQgciA9IEFycmF5KG4ubGVuZ3RoKSwgaSA9IDAsIHMgPSAoKSA9PiB7XG4gICAgICArK2kgPT0gbi5sZW5ndGggJiYgaHYodCwgZSwgci5maWx0ZXIoKG8pID0+IG8gIT0gbnVsbCkuam9pbih0LnN0YXRlLmxpbmVCcmVhayksICExKTtcbiAgICB9O1xuICAgIGZvciAobGV0IG8gPSAwOyBvIDwgbi5sZW5ndGg7IG8rKykge1xuICAgICAgbGV0IGEgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgYS5vbmVycm9yID0gcywgYS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIC9bXFx4MDAtXFx4MDhcXHgwZS1cXHgxZl17Mn0vLnRlc3QoYS5yZXN1bHQpIHx8IChyW29dID0gYS5yZXN1bHQpLCBzKCk7XG4gICAgICB9LCBhLnJlYWRBc1RleHQobltvXSk7XG4gICAgfVxuICAgIHJldHVybiAhMDtcbiAgfSBlbHNlIHtcbiAgICBsZXQgciA9IGUuZGF0YVRyYW5zZmVyLmdldERhdGEoXCJUZXh0XCIpO1xuICAgIGlmIChyKVxuICAgICAgcmV0dXJuIGh2KHQsIGUsIHIsICEwKSwgITA7XG4gIH1cbiAgcmV0dXJuICExO1xufTtcbmJyLnBhc3RlID0gKHQsIGUpID0+IHtcbiAgaWYgKHQuc3RhdGUucmVhZE9ubHkpXG4gICAgcmV0dXJuICEwO1xuICB0Lm9ic2VydmVyLmZsdXNoKCk7XG4gIGxldCBuID0gUmsgPyBudWxsIDogZS5jbGlwYm9hcmREYXRhO1xuICByZXR1cm4gbiA/IChOayh0LCBuLmdldERhdGEoXCJ0ZXh0L3BsYWluXCIpIHx8IG4uZ2V0RGF0YShcInRleHQvdXJpLXRleHRcIikpLCAhMCkgOiAoZjUodCksICExKTtcbn07XG5mdW5jdGlvbiBtNSh0LCBlKSB7XG4gIGxldCBuID0gdC5kb20ucGFyZW50Tm9kZTtcbiAgaWYgKCFuKVxuICAgIHJldHVybjtcbiAgbGV0IHIgPSBuLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKSk7XG4gIHIuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IGZpeGVkOyBsZWZ0OiAtMTAwMDBweDsgdG9wOiAxMHB4XCIsIHIudmFsdWUgPSBlLCByLmZvY3VzKCksIHIuc2VsZWN0aW9uRW5kID0gZS5sZW5ndGgsIHIuc2VsZWN0aW9uU3RhcnQgPSAwLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICByLnJlbW92ZSgpLCB0LmZvY3VzKCk7XG4gIH0sIDUwKTtcbn1cbmZ1bmN0aW9uIGI1KHQpIHtcbiAgbGV0IGUgPSBbXSwgbiA9IFtdLCByID0gITE7XG4gIGZvciAobGV0IGkgb2YgdC5zZWxlY3Rpb24ucmFuZ2VzKVxuICAgIGkuZW1wdHkgfHwgKGUucHVzaCh0LnNsaWNlRG9jKGkuZnJvbSwgaS50bykpLCBuLnB1c2goaSkpO1xuICBpZiAoIWUubGVuZ3RoKSB7XG4gICAgbGV0IGkgPSAtMTtcbiAgICBmb3IgKGxldCB7IGZyb206IHMgfSBvZiB0LnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgIGxldCBvID0gdC5kb2MubGluZUF0KHMpO1xuICAgICAgby5udW1iZXIgPiBpICYmIChlLnB1c2goby50ZXh0KSwgbi5wdXNoKHsgZnJvbTogby5mcm9tLCB0bzogTWF0aC5taW4odC5kb2MubGVuZ3RoLCBvLnRvICsgMSkgfSkpLCBpID0gby5udW1iZXI7XG4gICAgfVxuICAgIHIgPSAhMDtcbiAgfVxuICByZXR1cm4geyB0ZXh0OiBlLmpvaW4odC5saW5lQnJlYWspLCByYW5nZXM6IG4sIGxpbmV3aXNlOiByIH07XG59XG5sZXQgcHAgPSBudWxsO1xuYnIuY29weSA9IGJyLmN1dCA9ICh0LCBlKSA9PiB7XG4gIGxldCB7IHRleHQ6IG4sIHJhbmdlczogciwgbGluZXdpc2U6IGkgfSA9IGI1KHQuc3RhdGUpO1xuICBpZiAoIW4gJiYgIWkpXG4gICAgcmV0dXJuICExO1xuICBwcCA9IGkgPyBuIDogbnVsbCwgZS50eXBlID09IFwiY3V0XCIgJiYgIXQuc3RhdGUucmVhZE9ubHkgJiYgdC5kaXNwYXRjaCh7XG4gICAgY2hhbmdlczogcixcbiAgICBzY3JvbGxJbnRvVmlldzogITAsXG4gICAgdXNlckV2ZW50OiBcImRlbGV0ZS5jdXRcIlxuICB9KTtcbiAgbGV0IHMgPSBSayA/IG51bGwgOiBlLmNsaXBib2FyZERhdGE7XG4gIHJldHVybiBzID8gKHMuY2xlYXJEYXRhKCksIHMuc2V0RGF0YShcInRleHQvcGxhaW5cIiwgbiksICEwKSA6IChtNSh0LCBuKSwgITEpO1xufTtcbmNvbnN0IFZrID0gLyogQF9fUFVSRV9fICovIG5vLmRlZmluZSgpO1xuZnVuY3Rpb24gSWsodCwgZSkge1xuICBsZXQgbiA9IFtdO1xuICBmb3IgKGxldCByIG9mIHQuZmFjZXQoU2spKSB7XG4gICAgbGV0IGkgPSByKHQsIGUpO1xuICAgIGkgJiYgbi5wdXNoKGkpO1xuICB9XG4gIHJldHVybiBuID8gdC51cGRhdGUoeyBlZmZlY3RzOiBuLCBhbm5vdGF0aW9uczogVmsub2YoITApIH0pIDogbnVsbDtcbn1cbmZ1bmN0aW9uIFdrKHQpIHtcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgbGV0IGUgPSB0Lmhhc0ZvY3VzO1xuICAgIGlmIChlICE9IHQuaW5wdXRTdGF0ZS5ub3RpZmllZEZvY3VzZWQpIHtcbiAgICAgIGxldCBuID0gSWsodC5zdGF0ZSwgZSk7XG4gICAgICBuID8gdC5kaXNwYXRjaChuKSA6IHQudXBkYXRlKFtdKTtcbiAgICB9XG4gIH0sIDEwKTtcbn1cbnZyLmZvY3VzID0gKHQpID0+IHtcbiAgdC5pbnB1dFN0YXRlLmxhc3RGb2N1c1RpbWUgPSBEYXRlLm5vdygpLCAhdC5zY3JvbGxET00uc2Nyb2xsVG9wICYmICh0LmlucHV0U3RhdGUubGFzdFNjcm9sbFRvcCB8fCB0LmlucHV0U3RhdGUubGFzdFNjcm9sbExlZnQpICYmICh0LnNjcm9sbERPTS5zY3JvbGxUb3AgPSB0LmlucHV0U3RhdGUubGFzdFNjcm9sbFRvcCwgdC5zY3JvbGxET00uc2Nyb2xsTGVmdCA9IHQuaW5wdXRTdGF0ZS5sYXN0U2Nyb2xsTGVmdCksIFdrKHQpO1xufTtcbnZyLmJsdXIgPSAodCkgPT4ge1xuICB0Lm9ic2VydmVyLmNsZWFyU2VsZWN0aW9uUmFuZ2UoKSwgV2sodCk7XG59O1xudnIuY29tcG9zaXRpb25zdGFydCA9IHZyLmNvbXBvc2l0aW9udXBkYXRlID0gKHQpID0+IHtcbiAgdC5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UgPT0gbnVsbCAmJiAodC5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UgPSAhMCksIHQuaW5wdXRTdGF0ZS5jb21wb3NpbmcgPCAwICYmICh0LmlucHV0U3RhdGUuY29tcG9zaW5nID0gMCk7XG59O1xudnIuY29tcG9zaXRpb25lbmQgPSAodCkgPT4ge1xuICB0LmlucHV0U3RhdGUuY29tcG9zaW5nID0gLTEsIHQuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkVuZGVkQXQgPSBEYXRlLm5vdygpLCB0LmlucHV0U3RhdGUuY29tcG9zaXRpb25QZW5kaW5nS2V5ID0gITAsIHQuaW5wdXRTdGF0ZS5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2UgPSB0Lm9ic2VydmVyLnBlbmRpbmdSZWNvcmRzKCkubGVuZ3RoID4gMCwgdC5pbnB1dFN0YXRlLmNvbXBvc2l0aW9uRmlyc3RDaGFuZ2UgPSBudWxsLCBkZS5jaHJvbWUgJiYgZGUuYW5kcm9pZCA/IHQub2JzZXJ2ZXIuZmx1c2hTb29uKCkgOiB0LmlucHV0U3RhdGUuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlID8gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB0Lm9ic2VydmVyLmZsdXNoKCkpIDogc2V0VGltZW91dCgoKSA9PiB7XG4gICAgdC5pbnB1dFN0YXRlLmNvbXBvc2luZyA8IDAgJiYgdC5kb2NWaWV3Lmhhc0NvbXBvc2l0aW9uICYmIHQudXBkYXRlKFtdKTtcbiAgfSwgNTApO1xufTtcbnZyLmNvbnRleHRtZW51ID0gKHQpID0+IHtcbiAgdC5pbnB1dFN0YXRlLmxhc3RDb250ZXh0TWVudSA9IERhdGUubm93KCk7XG59O1xuYnIuYmVmb3JlaW5wdXQgPSAodCwgZSkgPT4ge1xuICB2YXIgbjtcbiAgbGV0IHI7XG4gIGlmIChkZS5jaHJvbWUgJiYgZGUuYW5kcm9pZCAmJiAociA9IENrLmZpbmQoKGkpID0+IGkuaW5wdXRUeXBlID09IGUuaW5wdXRUeXBlKSkgJiYgKHQub2JzZXJ2ZXIuZGVsYXlBbmRyb2lkS2V5KHIua2V5LCByLmtleUNvZGUpLCByLmtleSA9PSBcIkJhY2tzcGFjZVwiIHx8IHIua2V5ID09IFwiRGVsZXRlXCIpKSB7XG4gICAgbGV0IGkgPSAoKG4gPSB3aW5kb3cudmlzdWFsVmlld3BvcnQpID09PSBudWxsIHx8IG4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG4uaGVpZ2h0KSB8fCAwO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdmFyIHM7XG4gICAgICAoKChzID0gd2luZG93LnZpc3VhbFZpZXdwb3J0KSA9PT0gbnVsbCB8fCBzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzLmhlaWdodCkgfHwgMCkgPiBpICsgMTAgJiYgdC5oYXNGb2N1cyAmJiAodC5jb250ZW50RE9NLmJsdXIoKSwgdC5mb2N1cygpKTtcbiAgICB9LCAxMDApO1xuICB9XG4gIHJldHVybiAhMTtcbn07XG5jb25zdCBwdiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG5mdW5jdGlvbiB2NSh0KSB7XG4gIHB2Lmhhcyh0KSB8fCAocHYuYWRkKHQpLCB0LmFkZEV2ZW50TGlzdGVuZXIoXCJjb3B5XCIsICgpID0+IHtcbiAgfSksIHQuYWRkRXZlbnRMaXN0ZW5lcihcImN1dFwiLCAoKSA9PiB7XG4gIH0pKTtcbn1cbmNvbnN0IE92ID0gW1wicHJlLXdyYXBcIiwgXCJub3JtYWxcIiwgXCJwcmUtbGluZVwiLCBcImJyZWFrLXNwYWNlc1wiXTtcbmNsYXNzIHk1IHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMubGluZVdyYXBwaW5nID0gZSwgdGhpcy5kb2MgPSBGZS5lbXB0eSwgdGhpcy5oZWlnaHRTYW1wbGVzID0ge30sIHRoaXMubGluZUhlaWdodCA9IDE0LCB0aGlzLmNoYXJXaWR0aCA9IDcsIHRoaXMudGV4dEhlaWdodCA9IDE0LCB0aGlzLmxpbmVMZW5ndGggPSAzMCwgdGhpcy5oZWlnaHRDaGFuZ2VkID0gITE7XG4gIH1cbiAgaGVpZ2h0Rm9yR2FwKGUsIG4pIHtcbiAgICBsZXQgciA9IHRoaXMuZG9jLmxpbmVBdChuKS5udW1iZXIgLSB0aGlzLmRvYy5saW5lQXQoZSkubnVtYmVyICsgMTtcbiAgICByZXR1cm4gdGhpcy5saW5lV3JhcHBpbmcgJiYgKHIgKz0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKChuIC0gZSAtIHIgKiB0aGlzLmxpbmVMZW5ndGggKiAwLjUpIC8gdGhpcy5saW5lTGVuZ3RoKSkpLCB0aGlzLmxpbmVIZWlnaHQgKiByO1xuICB9XG4gIGhlaWdodEZvckxpbmUoZSkge1xuICAgIHJldHVybiB0aGlzLmxpbmVXcmFwcGluZyA/ICgxICsgTWF0aC5tYXgoMCwgTWF0aC5jZWlsKChlIC0gdGhpcy5saW5lTGVuZ3RoKSAvICh0aGlzLmxpbmVMZW5ndGggLSA1KSkpKSAqIHRoaXMubGluZUhlaWdodCA6IHRoaXMubGluZUhlaWdodDtcbiAgfVxuICBzZXREb2MoZSkge1xuICAgIHJldHVybiB0aGlzLmRvYyA9IGUsIHRoaXM7XG4gIH1cbiAgbXVzdFJlZnJlc2hGb3JXcmFwcGluZyhlKSB7XG4gICAgcmV0dXJuIE92LmluZGV4T2YoZSkgPiAtMSAhPSB0aGlzLmxpbmVXcmFwcGluZztcbiAgfVxuICBtdXN0UmVmcmVzaEZvckhlaWdodHMoZSkge1xuICAgIGxldCBuID0gITE7XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCBlLmxlbmd0aDsgcisrKSB7XG4gICAgICBsZXQgaSA9IGVbcl07XG4gICAgICBpIDwgMCA/IHIrKyA6IHRoaXMuaGVpZ2h0U2FtcGxlc1tNYXRoLmZsb29yKGkgKiAxMCldIHx8IChuID0gITAsIHRoaXMuaGVpZ2h0U2FtcGxlc1tNYXRoLmZsb29yKGkgKiAxMCldID0gITApO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfVxuICByZWZyZXNoKGUsIG4sIHIsIGksIHMsIG8pIHtcbiAgICBsZXQgYSA9IE92LmluZGV4T2YoZSkgPiAtMSwgbCA9IE1hdGgucm91bmQobikgIT0gTWF0aC5yb3VuZCh0aGlzLmxpbmVIZWlnaHQpIHx8IHRoaXMubGluZVdyYXBwaW5nICE9IGE7XG4gICAgaWYgKHRoaXMubGluZVdyYXBwaW5nID0gYSwgdGhpcy5saW5lSGVpZ2h0ID0gbiwgdGhpcy5jaGFyV2lkdGggPSByLCB0aGlzLnRleHRIZWlnaHQgPSBpLCB0aGlzLmxpbmVMZW5ndGggPSBzLCBsKSB7XG4gICAgICB0aGlzLmhlaWdodFNhbXBsZXMgPSB7fTtcbiAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgby5sZW5ndGg7IGMrKykge1xuICAgICAgICBsZXQgdSA9IG9bY107XG4gICAgICAgIHUgPCAwID8gYysrIDogdGhpcy5oZWlnaHRTYW1wbGVzW01hdGguZmxvb3IodSAqIDEwKV0gPSAhMDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGw7XG4gIH1cbn1cbmNsYXNzIFM1IHtcbiAgY29uc3RydWN0b3IoZSwgbikge1xuICAgIHRoaXMuZnJvbSA9IGUsIHRoaXMuaGVpZ2h0cyA9IG4sIHRoaXMuaW5kZXggPSAwO1xuICB9XG4gIGdldCBtb3JlKCkge1xuICAgIHJldHVybiB0aGlzLmluZGV4IDwgdGhpcy5oZWlnaHRzLmxlbmd0aDtcbiAgfVxufVxuY2xhc3MgQ3Ige1xuICAvKipcbiAgQGludGVybmFsXG4gICovXG4gIGNvbnN0cnVjdG9yKGUsIG4sIHIsIGksIHMpIHtcbiAgICB0aGlzLmZyb20gPSBlLCB0aGlzLmxlbmd0aCA9IG4sIHRoaXMudG9wID0gciwgdGhpcy5oZWlnaHQgPSBpLCB0aGlzLl9jb250ZW50ID0gcztcbiAgfVxuICAvKipcbiAgVGhlIHR5cGUgb2YgZWxlbWVudCB0aGlzIGlzLiBXaGVuIHF1ZXJ5aW5nIGxpbmVzLCB0aGlzIG1heSBiZVxuICBhbiBhcnJheSBvZiBhbGwgdGhlIGJsb2NrcyB0aGF0IG1ha2UgdXAgdGhlIGxpbmUuXG4gICovXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy5fY29udGVudCA9PSBcIm51bWJlclwiID8gZnIuVGV4dCA6IEFycmF5LmlzQXJyYXkodGhpcy5fY29udGVudCkgPyB0aGlzLl9jb250ZW50IDogdGhpcy5fY29udGVudC50eXBlO1xuICB9XG4gIC8qKlxuICBUaGUgZW5kIG9mIHRoZSBlbGVtZW50IGFzIGEgZG9jdW1lbnQgcG9zaXRpb24uXG4gICovXG4gIGdldCB0bygpIHtcbiAgICByZXR1cm4gdGhpcy5mcm9tICsgdGhpcy5sZW5ndGg7XG4gIH1cbiAgLyoqXG4gIFRoZSBib3R0b20gcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQuXG4gICovXG4gIGdldCBib3R0b20oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9wICsgdGhpcy5oZWlnaHQ7XG4gIH1cbiAgLyoqXG4gIElmIHRoaXMgaXMgYSB3aWRnZXQgYmxvY2ssIHRoaXMgd2lsbCByZXR1cm4gdGhlIHdpZGdldFxuICBhc3NvY2lhdGVkIHdpdGggaXQuXG4gICovXG4gIGdldCB3aWRnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQgaW5zdGFuY2VvZiBhcyA/IHRoaXMuX2NvbnRlbnQud2lkZ2V0IDogbnVsbDtcbiAgfVxuICAvKipcbiAgSWYgdGhpcyBpcyBhIHRleHRibG9jaywgdGhpcyBob2xkcyB0aGUgbnVtYmVyIG9mIGxpbmUgYnJlYWtzXG4gIHRoYXQgYXBwZWFyIGluIHdpZGdldHMgaW5zaWRlIHRoZSBibG9jay5cbiAgKi9cbiAgZ2V0IHdpZGdldExpbmVCcmVha3MoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB0aGlzLl9jb250ZW50ID09IFwibnVtYmVyXCIgPyB0aGlzLl9jb250ZW50IDogMDtcbiAgfVxuICAvKipcbiAgQGludGVybmFsXG4gICovXG4gIGpvaW4oZSkge1xuICAgIGxldCBuID0gKEFycmF5LmlzQXJyYXkodGhpcy5fY29udGVudCkgPyB0aGlzLl9jb250ZW50IDogW3RoaXNdKS5jb25jYXQoQXJyYXkuaXNBcnJheShlLl9jb250ZW50KSA/IGUuX2NvbnRlbnQgOiBbZV0pO1xuICAgIHJldHVybiBuZXcgQ3IodGhpcy5mcm9tLCB0aGlzLmxlbmd0aCArIGUubGVuZ3RoLCB0aGlzLnRvcCwgdGhpcy5oZWlnaHQgKyBlLmhlaWdodCwgbik7XG4gIH1cbn1cbnZhciBkdCA9IC8qIEBfX1BVUkVfXyAqLyBmdW5jdGlvbih0KSB7XG4gIHJldHVybiB0W3QuQnlQb3MgPSAwXSA9IFwiQnlQb3NcIiwgdFt0LkJ5SGVpZ2h0ID0gMV0gPSBcIkJ5SGVpZ2h0XCIsIHRbdC5CeVBvc05vSGVpZ2h0ID0gMl0gPSBcIkJ5UG9zTm9IZWlnaHRcIiwgdDtcbn0oZHQgfHwgKGR0ID0ge30pKTtcbmNvbnN0IHN1ID0gMWUtMztcbmNsYXNzIHBuIHtcbiAgY29uc3RydWN0b3IoZSwgbiwgciA9IDIpIHtcbiAgICB0aGlzLmxlbmd0aCA9IGUsIHRoaXMuaGVpZ2h0ID0gbiwgdGhpcy5mbGFncyA9IHI7XG4gIH1cbiAgZ2V0IG91dGRhdGVkKCkge1xuICAgIHJldHVybiAodGhpcy5mbGFncyAmIDIpID4gMDtcbiAgfVxuICBzZXQgb3V0ZGF0ZWQoZSkge1xuICAgIHRoaXMuZmxhZ3MgPSAoZSA/IDIgOiAwKSB8IHRoaXMuZmxhZ3MgJiAtMztcbiAgfVxuICBzZXRIZWlnaHQoZSwgbikge1xuICAgIHRoaXMuaGVpZ2h0ICE9IG4gJiYgKE1hdGguYWJzKHRoaXMuaGVpZ2h0IC0gbikgPiBzdSAmJiAoZS5oZWlnaHRDaGFuZ2VkID0gITApLCB0aGlzLmhlaWdodCA9IG4pO1xuICB9XG4gIC8vIEJhc2UgY2FzZSBpcyB0byByZXBsYWNlIGEgbGVhZiBub2RlLCB3aGljaCBzaW1wbHkgYnVpbGRzIGEgdHJlZVxuICAvLyBmcm9tIHRoZSBuZXcgbm9kZXMgYW5kIHJldHVybnMgdGhhdCAoSGVpZ2h0TWFwQnJhbmNoIGFuZFxuICAvLyBIZWlnaHRNYXBHYXAgb3ZlcnJpZGUgdGhpcyB0byBhY3R1YWxseSB1c2UgZnJvbS90bylcbiAgcmVwbGFjZShlLCBuLCByKSB7XG4gICAgcmV0dXJuIHBuLm9mKHIpO1xuICB9XG4gIC8vIEFnYWluLCB0aGVzZSBhcmUgYmFzZSBjYXNlcywgYW5kIGFyZSBvdmVycmlkZGVuIGZvciBicmFuY2ggYW5kIGdhcCBub2Rlcy5cbiAgZGVjb21wb3NlTGVmdChlLCBuKSB7XG4gICAgbi5wdXNoKHRoaXMpO1xuICB9XG4gIGRlY29tcG9zZVJpZ2h0KGUsIG4pIHtcbiAgICBuLnB1c2godGhpcyk7XG4gIH1cbiAgYXBwbHlDaGFuZ2VzKGUsIG4sIHIsIGkpIHtcbiAgICBsZXQgcyA9IHRoaXMsIG8gPSByLmRvYztcbiAgICBmb3IgKGxldCBhID0gaS5sZW5ndGggLSAxOyBhID49IDA7IGEtLSkge1xuICAgICAgbGV0IHsgZnJvbUE6IGwsIHRvQTogYywgZnJvbUI6IHUsIHRvQjogZCB9ID0gaVthXSwgZiA9IHMubGluZUF0KGwsIGR0LkJ5UG9zTm9IZWlnaHQsIHIuc2V0RG9jKG4pLCAwLCAwKSwgaCA9IGYudG8gPj0gYyA/IGYgOiBzLmxpbmVBdChjLCBkdC5CeVBvc05vSGVpZ2h0LCByLCAwLCAwKTtcbiAgICAgIGZvciAoZCArPSBoLnRvIC0gYywgYyA9IGgudG87IGEgPiAwICYmIGYuZnJvbSA8PSBpW2EgLSAxXS50b0E7IClcbiAgICAgICAgbCA9IGlbYSAtIDFdLmZyb21BLCB1ID0gaVthIC0gMV0uZnJvbUIsIGEtLSwgbCA8IGYuZnJvbSAmJiAoZiA9IHMubGluZUF0KGwsIGR0LkJ5UG9zTm9IZWlnaHQsIHIsIDAsIDApKTtcbiAgICAgIHUgKz0gZi5mcm9tIC0gbCwgbCA9IGYuZnJvbTtcbiAgICAgIGxldCBwID0gZGcuYnVpbGQoci5zZXREb2MobyksIGUsIHUsIGQpO1xuICAgICAgcyA9IHMucmVwbGFjZShsLCBjLCBwKTtcbiAgICB9XG4gICAgcmV0dXJuIHMudXBkYXRlSGVpZ2h0KHIsIDApO1xuICB9XG4gIHN0YXRpYyBlbXB0eSgpIHtcbiAgICByZXR1cm4gbmV3IFJuKDAsIDApO1xuICB9XG4gIC8vIG5vZGVzIHVzZXMgbnVsbCB2YWx1ZXMgdG8gaW5kaWNhdGUgdGhlIHBvc2l0aW9uIG9mIGxpbmUgYnJlYWtzLlxuICAvLyBUaGVyZSBhcmUgbmV2ZXIgbGluZSBicmVha3MgYXQgdGhlIHN0YXJ0IG9yIGVuZCBvZiB0aGUgYXJyYXksIG9yXG4gIC8vIHR3byBsaW5lIGJyZWFrcyBuZXh0IHRvIGVhY2ggb3RoZXIsIGFuZCB0aGUgYXJyYXkgaXNuJ3QgYWxsb3dlZFxuICAvLyB0byBiZSBlbXB0eSAoc2FtZSByZXN0cmljdGlvbnMgYXMgcmV0dXJuIHZhbHVlIGZyb20gdGhlIGJ1aWxkZXIpLlxuICBzdGF0aWMgb2YoZSkge1xuICAgIGlmIChlLmxlbmd0aCA9PSAxKVxuICAgICAgcmV0dXJuIGVbMF07XG4gICAgbGV0IG4gPSAwLCByID0gZS5sZW5ndGgsIGkgPSAwLCBzID0gMDtcbiAgICBmb3IgKDsgOyApXG4gICAgICBpZiAobiA9PSByKVxuICAgICAgICBpZiAoaSA+IHMgKiAyKSB7XG4gICAgICAgICAgbGV0IGEgPSBlW24gLSAxXTtcbiAgICAgICAgICBhLmJyZWFrID8gZS5zcGxpY2UoLS1uLCAxLCBhLmxlZnQsIG51bGwsIGEucmlnaHQpIDogZS5zcGxpY2UoLS1uLCAxLCBhLmxlZnQsIGEucmlnaHQpLCByICs9IDEgKyBhLmJyZWFrLCBpIC09IGEuc2l6ZTtcbiAgICAgICAgfSBlbHNlIGlmIChzID4gaSAqIDIpIHtcbiAgICAgICAgICBsZXQgYSA9IGVbcl07XG4gICAgICAgICAgYS5icmVhayA/IGUuc3BsaWNlKHIsIDEsIGEubGVmdCwgbnVsbCwgYS5yaWdodCkgOiBlLnNwbGljZShyLCAxLCBhLmxlZnQsIGEucmlnaHQpLCByICs9IDIgKyBhLmJyZWFrLCBzIC09IGEuc2l6ZTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgYnJlYWs7XG4gICAgICBlbHNlIGlmIChpIDwgcykge1xuICAgICAgICBsZXQgYSA9IGVbbisrXTtcbiAgICAgICAgYSAmJiAoaSArPSBhLnNpemUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGEgPSBlWy0tcl07XG4gICAgICAgIGEgJiYgKHMgKz0gYS5zaXplKTtcbiAgICAgIH1cbiAgICBsZXQgbyA9IDA7XG4gICAgcmV0dXJuIGVbbiAtIDFdID09IG51bGwgPyAobyA9IDEsIG4tLSkgOiBlW25dID09IG51bGwgJiYgKG8gPSAxLCByKyspLCBuZXcgdzUocG4ub2YoZS5zbGljZSgwLCBuKSksIG8sIHBuLm9mKGUuc2xpY2UocikpKTtcbiAgfVxufVxucG4ucHJvdG90eXBlLnNpemUgPSAxO1xuY2xhc3MgTWsgZXh0ZW5kcyBwbiB7XG4gIGNvbnN0cnVjdG9yKGUsIG4sIHIpIHtcbiAgICBzdXBlcihlLCBuKSwgdGhpcy5kZWNvID0gcjtcbiAgfVxuICBibG9ja0F0KGUsIG4sIHIsIGkpIHtcbiAgICByZXR1cm4gbmV3IENyKGksIHRoaXMubGVuZ3RoLCByLCB0aGlzLmhlaWdodCwgdGhpcy5kZWNvIHx8IDApO1xuICB9XG4gIGxpbmVBdChlLCBuLCByLCBpLCBzKSB7XG4gICAgcmV0dXJuIHRoaXMuYmxvY2tBdCgwLCByLCBpLCBzKTtcbiAgfVxuICBmb3JFYWNoTGluZShlLCBuLCByLCBpLCBzLCBvKSB7XG4gICAgZSA8PSBzICsgdGhpcy5sZW5ndGggJiYgbiA+PSBzICYmIG8odGhpcy5ibG9ja0F0KDAsIHIsIGksIHMpKTtcbiAgfVxuICB1cGRhdGVIZWlnaHQoZSwgbiA9IDAsIHIgPSAhMSwgaSkge1xuICAgIHJldHVybiBpICYmIGkuZnJvbSA8PSBuICYmIGkubW9yZSAmJiB0aGlzLnNldEhlaWdodChlLCBpLmhlaWdodHNbaS5pbmRleCsrXSksIHRoaXMub3V0ZGF0ZWQgPSAhMSwgdGhpcztcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gYGJsb2NrKCR7dGhpcy5sZW5ndGh9KWA7XG4gIH1cbn1cbmNsYXNzIFJuIGV4dGVuZHMgTWsge1xuICBjb25zdHJ1Y3RvcihlLCBuKSB7XG4gICAgc3VwZXIoZSwgbiwgbnVsbCksIHRoaXMuY29sbGFwc2VkID0gMCwgdGhpcy53aWRnZXRIZWlnaHQgPSAwLCB0aGlzLmJyZWFrcyA9IDA7XG4gIH1cbiAgYmxvY2tBdChlLCBuLCByLCBpKSB7XG4gICAgcmV0dXJuIG5ldyBDcihpLCB0aGlzLmxlbmd0aCwgciwgdGhpcy5oZWlnaHQsIHRoaXMuYnJlYWtzKTtcbiAgfVxuICByZXBsYWNlKGUsIG4sIHIpIHtcbiAgICBsZXQgaSA9IHJbMF07XG4gICAgcmV0dXJuIHIubGVuZ3RoID09IDEgJiYgKGkgaW5zdGFuY2VvZiBSbiB8fCBpIGluc3RhbmNlb2YgenQgJiYgaS5mbGFncyAmIDQpICYmIE1hdGguYWJzKHRoaXMubGVuZ3RoIC0gaS5sZW5ndGgpIDwgMTAgPyAoaSBpbnN0YW5jZW9mIHp0ID8gaSA9IG5ldyBSbihpLmxlbmd0aCwgdGhpcy5oZWlnaHQpIDogaS5oZWlnaHQgPSB0aGlzLmhlaWdodCwgdGhpcy5vdXRkYXRlZCB8fCAoaS5vdXRkYXRlZCA9ICExKSwgaSkgOiBwbi5vZihyKTtcbiAgfVxuICB1cGRhdGVIZWlnaHQoZSwgbiA9IDAsIHIgPSAhMSwgaSkge1xuICAgIHJldHVybiBpICYmIGkuZnJvbSA8PSBuICYmIGkubW9yZSA/IHRoaXMuc2V0SGVpZ2h0KGUsIGkuaGVpZ2h0c1tpLmluZGV4KytdKSA6IChyIHx8IHRoaXMub3V0ZGF0ZWQpICYmIHRoaXMuc2V0SGVpZ2h0KGUsIE1hdGgubWF4KHRoaXMud2lkZ2V0SGVpZ2h0LCBlLmhlaWdodEZvckxpbmUodGhpcy5sZW5ndGggLSB0aGlzLmNvbGxhcHNlZCkpICsgdGhpcy5icmVha3MgKiBlLmxpbmVIZWlnaHQpLCB0aGlzLm91dGRhdGVkID0gITEsIHRoaXM7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBsaW5lKCR7dGhpcy5sZW5ndGh9JHt0aGlzLmNvbGxhcHNlZCA/IC10aGlzLmNvbGxhcHNlZCA6IFwiXCJ9JHt0aGlzLndpZGdldEhlaWdodCA/IFwiOlwiICsgdGhpcy53aWRnZXRIZWlnaHQgOiBcIlwifSlgO1xuICB9XG59XG5jbGFzcyB6dCBleHRlbmRzIHBuIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKGUsIDApO1xuICB9XG4gIGhlaWdodE1ldHJpY3MoZSwgbikge1xuICAgIGxldCByID0gZS5kb2MubGluZUF0KG4pLm51bWJlciwgaSA9IGUuZG9jLmxpbmVBdChuICsgdGhpcy5sZW5ndGgpLm51bWJlciwgcyA9IGkgLSByICsgMSwgbywgYSA9IDA7XG4gICAgaWYgKGUubGluZVdyYXBwaW5nKSB7XG4gICAgICBsZXQgbCA9IE1hdGgubWluKHRoaXMuaGVpZ2h0LCBlLmxpbmVIZWlnaHQgKiBzKTtcbiAgICAgIG8gPSBsIC8gcywgdGhpcy5sZW5ndGggPiBzICsgMSAmJiAoYSA9ICh0aGlzLmhlaWdodCAtIGwpIC8gKHRoaXMubGVuZ3RoIC0gcyAtIDEpKTtcbiAgICB9IGVsc2VcbiAgICAgIG8gPSB0aGlzLmhlaWdodCAvIHM7XG4gICAgcmV0dXJuIHsgZmlyc3RMaW5lOiByLCBsYXN0TGluZTogaSwgcGVyTGluZTogbywgcGVyQ2hhcjogYSB9O1xuICB9XG4gIGJsb2NrQXQoZSwgbiwgciwgaSkge1xuICAgIGxldCB7IGZpcnN0TGluZTogcywgbGFzdExpbmU6IG8sIHBlckxpbmU6IGEsIHBlckNoYXI6IGwgfSA9IHRoaXMuaGVpZ2h0TWV0cmljcyhuLCBpKTtcbiAgICBpZiAobi5saW5lV3JhcHBpbmcpIHtcbiAgICAgIGxldCBjID0gaSArIE1hdGgucm91bmQoTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKGUgLSByKSAvIHRoaXMuaGVpZ2h0KSkgKiB0aGlzLmxlbmd0aCksIHUgPSBuLmRvYy5saW5lQXQoYyksIGQgPSBhICsgdS5sZW5ndGggKiBsLCBmID0gTWF0aC5tYXgociwgZSAtIGQgLyAyKTtcbiAgICAgIHJldHVybiBuZXcgQ3IodS5mcm9tLCB1Lmxlbmd0aCwgZiwgZCwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBjID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obyAtIHMsIE1hdGguZmxvb3IoKGUgLSByKSAvIGEpKSksIHsgZnJvbTogdSwgbGVuZ3RoOiBkIH0gPSBuLmRvYy5saW5lKHMgKyBjKTtcbiAgICAgIHJldHVybiBuZXcgQ3IodSwgZCwgciArIGEgKiBjLCBhLCAwKTtcbiAgICB9XG4gIH1cbiAgbGluZUF0KGUsIG4sIHIsIGksIHMpIHtcbiAgICBpZiAobiA9PSBkdC5CeUhlaWdodClcbiAgICAgIHJldHVybiB0aGlzLmJsb2NrQXQoZSwgciwgaSwgcyk7XG4gICAgaWYgKG4gPT0gZHQuQnlQb3NOb0hlaWdodCkge1xuICAgICAgbGV0IHsgZnJvbTogaCwgdG86IHAgfSA9IHIuZG9jLmxpbmVBdChlKTtcbiAgICAgIHJldHVybiBuZXcgQ3IoaCwgcCAtIGgsIDAsIDAsIDApO1xuICAgIH1cbiAgICBsZXQgeyBmaXJzdExpbmU6IG8sIHBlckxpbmU6IGEsIHBlckNoYXI6IGwgfSA9IHRoaXMuaGVpZ2h0TWV0cmljcyhyLCBzKSwgYyA9IHIuZG9jLmxpbmVBdChlKSwgdSA9IGEgKyBjLmxlbmd0aCAqIGwsIGQgPSBjLm51bWJlciAtIG8sIGYgPSBpICsgYSAqIGQgKyBsICogKGMuZnJvbSAtIHMgLSBkKTtcbiAgICByZXR1cm4gbmV3IENyKGMuZnJvbSwgYy5sZW5ndGgsIE1hdGgubWF4KGksIE1hdGgubWluKGYsIGkgKyB0aGlzLmhlaWdodCAtIHUpKSwgdSwgMCk7XG4gIH1cbiAgZm9yRWFjaExpbmUoZSwgbiwgciwgaSwgcywgbykge1xuICAgIGUgPSBNYXRoLm1heChlLCBzKSwgbiA9IE1hdGgubWluKG4sIHMgKyB0aGlzLmxlbmd0aCk7XG4gICAgbGV0IHsgZmlyc3RMaW5lOiBhLCBwZXJMaW5lOiBsLCBwZXJDaGFyOiBjIH0gPSB0aGlzLmhlaWdodE1ldHJpY3Mociwgcyk7XG4gICAgZm9yIChsZXQgdSA9IGUsIGQgPSBpOyB1IDw9IG47ICkge1xuICAgICAgbGV0IGYgPSByLmRvYy5saW5lQXQodSk7XG4gICAgICBpZiAodSA9PSBlKSB7XG4gICAgICAgIGxldCBwID0gZi5udW1iZXIgLSBhO1xuICAgICAgICBkICs9IGwgKiBwICsgYyAqIChlIC0gcyAtIHApO1xuICAgICAgfVxuICAgICAgbGV0IGggPSBsICsgYyAqIGYubGVuZ3RoO1xuICAgICAgbyhuZXcgQ3IoZi5mcm9tLCBmLmxlbmd0aCwgZCwgaCwgMCkpLCBkICs9IGgsIHUgPSBmLnRvICsgMTtcbiAgICB9XG4gIH1cbiAgcmVwbGFjZShlLCBuLCByKSB7XG4gICAgbGV0IGkgPSB0aGlzLmxlbmd0aCAtIG47XG4gICAgaWYgKGkgPiAwKSB7XG4gICAgICBsZXQgcyA9IHJbci5sZW5ndGggLSAxXTtcbiAgICAgIHMgaW5zdGFuY2VvZiB6dCA/IHJbci5sZW5ndGggLSAxXSA9IG5ldyB6dChzLmxlbmd0aCArIGkpIDogci5wdXNoKG51bGwsIG5ldyB6dChpIC0gMSkpO1xuICAgIH1cbiAgICBpZiAoZSA+IDApIHtcbiAgICAgIGxldCBzID0gclswXTtcbiAgICAgIHMgaW5zdGFuY2VvZiB6dCA/IHJbMF0gPSBuZXcgenQoZSArIHMubGVuZ3RoKSA6IHIudW5zaGlmdChuZXcgenQoZSAtIDEpLCBudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIHBuLm9mKHIpO1xuICB9XG4gIGRlY29tcG9zZUxlZnQoZSwgbikge1xuICAgIG4ucHVzaChuZXcgenQoZSAtIDEpLCBudWxsKTtcbiAgfVxuICBkZWNvbXBvc2VSaWdodChlLCBuKSB7XG4gICAgbi5wdXNoKG51bGwsIG5ldyB6dCh0aGlzLmxlbmd0aCAtIGUgLSAxKSk7XG4gIH1cbiAgdXBkYXRlSGVpZ2h0KGUsIG4gPSAwLCByID0gITEsIGkpIHtcbiAgICBsZXQgcyA9IG4gKyB0aGlzLmxlbmd0aDtcbiAgICBpZiAoaSAmJiBpLmZyb20gPD0gbiArIHRoaXMubGVuZ3RoICYmIGkubW9yZSkge1xuICAgICAgbGV0IG8gPSBbXSwgYSA9IE1hdGgubWF4KG4sIGkuZnJvbSksIGwgPSAtMTtcbiAgICAgIGZvciAoaS5mcm9tID4gbiAmJiBvLnB1c2gobmV3IHp0KGkuZnJvbSAtIG4gLSAxKS51cGRhdGVIZWlnaHQoZSwgbikpOyBhIDw9IHMgJiYgaS5tb3JlOyApIHtcbiAgICAgICAgbGV0IHUgPSBlLmRvYy5saW5lQXQoYSkubGVuZ3RoO1xuICAgICAgICBvLmxlbmd0aCAmJiBvLnB1c2gobnVsbCk7XG4gICAgICAgIGxldCBkID0gaS5oZWlnaHRzW2kuaW5kZXgrK107XG4gICAgICAgIGwgPT0gLTEgPyBsID0gZCA6IE1hdGguYWJzKGQgLSBsKSA+PSBzdSAmJiAobCA9IC0yKTtcbiAgICAgICAgbGV0IGYgPSBuZXcgUm4odSwgZCk7XG4gICAgICAgIGYub3V0ZGF0ZWQgPSAhMSwgby5wdXNoKGYpLCBhICs9IHUgKyAxO1xuICAgICAgfVxuICAgICAgYSA8PSBzICYmIG8ucHVzaChudWxsLCBuZXcgenQocyAtIGEpLnVwZGF0ZUhlaWdodChlLCBhKSk7XG4gICAgICBsZXQgYyA9IHBuLm9mKG8pO1xuICAgICAgcmV0dXJuIChsIDwgMCB8fCBNYXRoLmFicyhjLmhlaWdodCAtIHRoaXMuaGVpZ2h0KSA+PSBzdSB8fCBNYXRoLmFicyhsIC0gdGhpcy5oZWlnaHRNZXRyaWNzKGUsIG4pLnBlckxpbmUpID49IHN1KSAmJiAoZS5oZWlnaHRDaGFuZ2VkID0gITApLCBjO1xuICAgIH0gZWxzZVxuICAgICAgKHIgfHwgdGhpcy5vdXRkYXRlZCkgJiYgKHRoaXMuc2V0SGVpZ2h0KGUsIGUuaGVpZ2h0Rm9yR2FwKG4sIG4gKyB0aGlzLmxlbmd0aCkpLCB0aGlzLm91dGRhdGVkID0gITEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgZ2FwKCR7dGhpcy5sZW5ndGh9KWA7XG4gIH1cbn1cbmNsYXNzIHc1IGV4dGVuZHMgcG4ge1xuICBjb25zdHJ1Y3RvcihlLCBuLCByKSB7XG4gICAgc3VwZXIoZS5sZW5ndGggKyBuICsgci5sZW5ndGgsIGUuaGVpZ2h0ICsgci5oZWlnaHQsIG4gfCAoZS5vdXRkYXRlZCB8fCByLm91dGRhdGVkID8gMiA6IDApKSwgdGhpcy5sZWZ0ID0gZSwgdGhpcy5yaWdodCA9IHIsIHRoaXMuc2l6ZSA9IGUuc2l6ZSArIHIuc2l6ZTtcbiAgfVxuICBnZXQgYnJlYWsoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmxhZ3MgJiAxO1xuICB9XG4gIGJsb2NrQXQoZSwgbiwgciwgaSkge1xuICAgIGxldCBzID0gciArIHRoaXMubGVmdC5oZWlnaHQ7XG4gICAgcmV0dXJuIGUgPCBzID8gdGhpcy5sZWZ0LmJsb2NrQXQoZSwgbiwgciwgaSkgOiB0aGlzLnJpZ2h0LmJsb2NrQXQoZSwgbiwgcywgaSArIHRoaXMubGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrKTtcbiAgfVxuICBsaW5lQXQoZSwgbiwgciwgaSwgcykge1xuICAgIGxldCBvID0gaSArIHRoaXMubGVmdC5oZWlnaHQsIGEgPSBzICsgdGhpcy5sZWZ0Lmxlbmd0aCArIHRoaXMuYnJlYWssIGwgPSBuID09IGR0LkJ5SGVpZ2h0ID8gZSA8IG8gOiBlIDwgYSwgYyA9IGwgPyB0aGlzLmxlZnQubGluZUF0KGUsIG4sIHIsIGksIHMpIDogdGhpcy5yaWdodC5saW5lQXQoZSwgbiwgciwgbywgYSk7XG4gICAgaWYgKHRoaXMuYnJlYWsgfHwgKGwgPyBjLnRvIDwgYSA6IGMuZnJvbSA+IGEpKVxuICAgICAgcmV0dXJuIGM7XG4gICAgbGV0IHUgPSBuID09IGR0LkJ5UG9zTm9IZWlnaHQgPyBkdC5CeVBvc05vSGVpZ2h0IDogZHQuQnlQb3M7XG4gICAgcmV0dXJuIGwgPyBjLmpvaW4odGhpcy5yaWdodC5saW5lQXQoYSwgdSwgciwgbywgYSkpIDogdGhpcy5sZWZ0LmxpbmVBdChhLCB1LCByLCBpLCBzKS5qb2luKGMpO1xuICB9XG4gIGZvckVhY2hMaW5lKGUsIG4sIHIsIGksIHMsIG8pIHtcbiAgICBsZXQgYSA9IGkgKyB0aGlzLmxlZnQuaGVpZ2h0LCBsID0gcyArIHRoaXMubGVmdC5sZW5ndGggKyB0aGlzLmJyZWFrO1xuICAgIGlmICh0aGlzLmJyZWFrKVxuICAgICAgZSA8IGwgJiYgdGhpcy5sZWZ0LmZvckVhY2hMaW5lKGUsIG4sIHIsIGksIHMsIG8pLCBuID49IGwgJiYgdGhpcy5yaWdodC5mb3JFYWNoTGluZShlLCBuLCByLCBhLCBsLCBvKTtcbiAgICBlbHNlIHtcbiAgICAgIGxldCBjID0gdGhpcy5saW5lQXQobCwgZHQuQnlQb3MsIHIsIGksIHMpO1xuICAgICAgZSA8IGMuZnJvbSAmJiB0aGlzLmxlZnQuZm9yRWFjaExpbmUoZSwgYy5mcm9tIC0gMSwgciwgaSwgcywgbyksIGMudG8gPj0gZSAmJiBjLmZyb20gPD0gbiAmJiBvKGMpLCBuID4gYy50byAmJiB0aGlzLnJpZ2h0LmZvckVhY2hMaW5lKGMudG8gKyAxLCBuLCByLCBhLCBsLCBvKTtcbiAgICB9XG4gIH1cbiAgcmVwbGFjZShlLCBuLCByKSB7XG4gICAgbGV0IGkgPSB0aGlzLmxlZnQubGVuZ3RoICsgdGhpcy5icmVhaztcbiAgICBpZiAobiA8IGkpXG4gICAgICByZXR1cm4gdGhpcy5iYWxhbmNlZCh0aGlzLmxlZnQucmVwbGFjZShlLCBuLCByKSwgdGhpcy5yaWdodCk7XG4gICAgaWYgKGUgPiB0aGlzLmxlZnQubGVuZ3RoKVxuICAgICAgcmV0dXJuIHRoaXMuYmFsYW5jZWQodGhpcy5sZWZ0LCB0aGlzLnJpZ2h0LnJlcGxhY2UoZSAtIGksIG4gLSBpLCByKSk7XG4gICAgbGV0IHMgPSBbXTtcbiAgICBlID4gMCAmJiB0aGlzLmRlY29tcG9zZUxlZnQoZSwgcyk7XG4gICAgbGV0IG8gPSBzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBhIG9mIHIpXG4gICAgICBzLnB1c2goYSk7XG4gICAgaWYgKGUgPiAwICYmIGd2KHMsIG8gLSAxKSwgbiA8IHRoaXMubGVuZ3RoKSB7XG4gICAgICBsZXQgYSA9IHMubGVuZ3RoO1xuICAgICAgdGhpcy5kZWNvbXBvc2VSaWdodChuLCBzKSwgZ3YocywgYSk7XG4gICAgfVxuICAgIHJldHVybiBwbi5vZihzKTtcbiAgfVxuICBkZWNvbXBvc2VMZWZ0KGUsIG4pIHtcbiAgICBsZXQgciA9IHRoaXMubGVmdC5sZW5ndGg7XG4gICAgaWYgKGUgPD0gcilcbiAgICAgIHJldHVybiB0aGlzLmxlZnQuZGVjb21wb3NlTGVmdChlLCBuKTtcbiAgICBuLnB1c2godGhpcy5sZWZ0KSwgdGhpcy5icmVhayAmJiAocisrLCBlID49IHIgJiYgbi5wdXNoKG51bGwpKSwgZSA+IHIgJiYgdGhpcy5yaWdodC5kZWNvbXBvc2VMZWZ0KGUgLSByLCBuKTtcbiAgfVxuICBkZWNvbXBvc2VSaWdodChlLCBuKSB7XG4gICAgbGV0IHIgPSB0aGlzLmxlZnQubGVuZ3RoLCBpID0gciArIHRoaXMuYnJlYWs7XG4gICAgaWYgKGUgPj0gaSlcbiAgICAgIHJldHVybiB0aGlzLnJpZ2h0LmRlY29tcG9zZVJpZ2h0KGUgLSBpLCBuKTtcbiAgICBlIDwgciAmJiB0aGlzLmxlZnQuZGVjb21wb3NlUmlnaHQoZSwgbiksIHRoaXMuYnJlYWsgJiYgZSA8IGkgJiYgbi5wdXNoKG51bGwpLCBuLnB1c2godGhpcy5yaWdodCk7XG4gIH1cbiAgYmFsYW5jZWQoZSwgbikge1xuICAgIHJldHVybiBlLnNpemUgPiAyICogbi5zaXplIHx8IG4uc2l6ZSA+IDIgKiBlLnNpemUgPyBwbi5vZih0aGlzLmJyZWFrID8gW2UsIG51bGwsIG5dIDogW2UsIG5dKSA6ICh0aGlzLmxlZnQgPSBlLCB0aGlzLnJpZ2h0ID0gbiwgdGhpcy5oZWlnaHQgPSBlLmhlaWdodCArIG4uaGVpZ2h0LCB0aGlzLm91dGRhdGVkID0gZS5vdXRkYXRlZCB8fCBuLm91dGRhdGVkLCB0aGlzLnNpemUgPSBlLnNpemUgKyBuLnNpemUsIHRoaXMubGVuZ3RoID0gZS5sZW5ndGggKyB0aGlzLmJyZWFrICsgbi5sZW5ndGgsIHRoaXMpO1xuICB9XG4gIHVwZGF0ZUhlaWdodChlLCBuID0gMCwgciA9ICExLCBpKSB7XG4gICAgbGV0IHsgbGVmdDogcywgcmlnaHQ6IG8gfSA9IHRoaXMsIGEgPSBuICsgcy5sZW5ndGggKyB0aGlzLmJyZWFrLCBsID0gbnVsbDtcbiAgICByZXR1cm4gaSAmJiBpLmZyb20gPD0gbiArIHMubGVuZ3RoICYmIGkubW9yZSA/IGwgPSBzID0gcy51cGRhdGVIZWlnaHQoZSwgbiwgciwgaSkgOiBzLnVwZGF0ZUhlaWdodChlLCBuLCByKSwgaSAmJiBpLmZyb20gPD0gYSArIG8ubGVuZ3RoICYmIGkubW9yZSA/IGwgPSBvID0gby51cGRhdGVIZWlnaHQoZSwgYSwgciwgaSkgOiBvLnVwZGF0ZUhlaWdodChlLCBhLCByKSwgbCA/IHRoaXMuYmFsYW5jZWQocywgbykgOiAodGhpcy5oZWlnaHQgPSB0aGlzLmxlZnQuaGVpZ2h0ICsgdGhpcy5yaWdodC5oZWlnaHQsIHRoaXMub3V0ZGF0ZWQgPSAhMSwgdGhpcyk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVmdCArICh0aGlzLmJyZWFrID8gXCIgXCIgOiBcIi1cIikgKyB0aGlzLnJpZ2h0O1xuICB9XG59XG5mdW5jdGlvbiBndih0LCBlKSB7XG4gIGxldCBuLCByO1xuICB0W2VdID09IG51bGwgJiYgKG4gPSB0W2UgLSAxXSkgaW5zdGFuY2VvZiB6dCAmJiAociA9IHRbZSArIDFdKSBpbnN0YW5jZW9mIHp0ICYmIHQuc3BsaWNlKGUgLSAxLCAzLCBuZXcgenQobi5sZW5ndGggKyAxICsgci5sZW5ndGgpKTtcbn1cbmNvbnN0IGs1ID0gNTtcbmNsYXNzIGRnIHtcbiAgY29uc3RydWN0b3IoZSwgbikge1xuICAgIHRoaXMucG9zID0gZSwgdGhpcy5vcmFjbGUgPSBuLCB0aGlzLm5vZGVzID0gW10sIHRoaXMubGluZVN0YXJ0ID0gLTEsIHRoaXMubGluZUVuZCA9IC0xLCB0aGlzLmNvdmVyaW5nID0gbnVsbCwgdGhpcy53cml0dGVuVG8gPSBlO1xuICB9XG4gIGdldCBpc0NvdmVyZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY292ZXJpbmcgJiYgdGhpcy5ub2Rlc1t0aGlzLm5vZGVzLmxlbmd0aCAtIDFdID09IHRoaXMuY292ZXJpbmc7XG4gIH1cbiAgc3BhbihlLCBuKSB7XG4gICAgaWYgKHRoaXMubGluZVN0YXJ0ID4gLTEpIHtcbiAgICAgIGxldCByID0gTWF0aC5taW4obiwgdGhpcy5saW5lRW5kKSwgaSA9IHRoaXMubm9kZXNbdGhpcy5ub2Rlcy5sZW5ndGggLSAxXTtcbiAgICAgIGkgaW5zdGFuY2VvZiBSbiA/IGkubGVuZ3RoICs9IHIgLSB0aGlzLnBvcyA6IChyID4gdGhpcy5wb3MgfHwgIXRoaXMuaXNDb3ZlcmVkKSAmJiB0aGlzLm5vZGVzLnB1c2gobmV3IFJuKHIgLSB0aGlzLnBvcywgLTEpKSwgdGhpcy53cml0dGVuVG8gPSByLCBuID4gciAmJiAodGhpcy5ub2Rlcy5wdXNoKG51bGwpLCB0aGlzLndyaXR0ZW5UbysrLCB0aGlzLmxpbmVTdGFydCA9IC0xKTtcbiAgICB9XG4gICAgdGhpcy5wb3MgPSBuO1xuICB9XG4gIHBvaW50KGUsIG4sIHIpIHtcbiAgICBpZiAoZSA8IG4gfHwgci5oZWlnaHRSZWxldmFudCkge1xuICAgICAgbGV0IGkgPSByLndpZGdldCA/IHIud2lkZ2V0LmVzdGltYXRlZEhlaWdodCA6IDAsIHMgPSByLndpZGdldCA/IHIud2lkZ2V0LmxpbmVCcmVha3MgOiAwO1xuICAgICAgaSA8IDAgJiYgKGkgPSB0aGlzLm9yYWNsZS5saW5lSGVpZ2h0KTtcbiAgICAgIGxldCBvID0gbiAtIGU7XG4gICAgICByLmJsb2NrID8gdGhpcy5hZGRCbG9jayhuZXcgTWsobywgaSwgcikpIDogKG8gfHwgcyB8fCBpID49IGs1KSAmJiB0aGlzLmFkZExpbmVEZWNvKGksIHMsIG8pO1xuICAgIH0gZWxzZVxuICAgICAgbiA+IGUgJiYgdGhpcy5zcGFuKGUsIG4pO1xuICAgIHRoaXMubGluZUVuZCA+IC0xICYmIHRoaXMubGluZUVuZCA8IHRoaXMucG9zICYmICh0aGlzLmxpbmVFbmQgPSB0aGlzLm9yYWNsZS5kb2MubGluZUF0KHRoaXMucG9zKS50byk7XG4gIH1cbiAgZW50ZXJMaW5lKCkge1xuICAgIGlmICh0aGlzLmxpbmVTdGFydCA+IC0xKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCB7IGZyb206IGUsIHRvOiBuIH0gPSB0aGlzLm9yYWNsZS5kb2MubGluZUF0KHRoaXMucG9zKTtcbiAgICB0aGlzLmxpbmVTdGFydCA9IGUsIHRoaXMubGluZUVuZCA9IG4sIHRoaXMud3JpdHRlblRvIDwgZSAmJiAoKHRoaXMud3JpdHRlblRvIDwgZSAtIDEgfHwgdGhpcy5ub2Rlc1t0aGlzLm5vZGVzLmxlbmd0aCAtIDFdID09IG51bGwpICYmIHRoaXMubm9kZXMucHVzaCh0aGlzLmJsYW5rQ29udGVudCh0aGlzLndyaXR0ZW5UbywgZSAtIDEpKSwgdGhpcy5ub2Rlcy5wdXNoKG51bGwpKSwgdGhpcy5wb3MgPiBlICYmIHRoaXMubm9kZXMucHVzaChuZXcgUm4odGhpcy5wb3MgLSBlLCAtMSkpLCB0aGlzLndyaXR0ZW5UbyA9IHRoaXMucG9zO1xuICB9XG4gIGJsYW5rQ29udGVudChlLCBuKSB7XG4gICAgbGV0IHIgPSBuZXcgenQobiAtIGUpO1xuICAgIHJldHVybiB0aGlzLm9yYWNsZS5kb2MubGluZUF0KGUpLnRvID09IG4gJiYgKHIuZmxhZ3MgfD0gNCksIHI7XG4gIH1cbiAgZW5zdXJlTGluZSgpIHtcbiAgICB0aGlzLmVudGVyTGluZSgpO1xuICAgIGxldCBlID0gdGhpcy5ub2Rlcy5sZW5ndGggPyB0aGlzLm5vZGVzW3RoaXMubm9kZXMubGVuZ3RoIC0gMV0gOiBudWxsO1xuICAgIGlmIChlIGluc3RhbmNlb2YgUm4pXG4gICAgICByZXR1cm4gZTtcbiAgICBsZXQgbiA9IG5ldyBSbigwLCAtMSk7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMucHVzaChuKSwgbjtcbiAgfVxuICBhZGRCbG9jayhlKSB7XG4gICAgdGhpcy5lbnRlckxpbmUoKTtcbiAgICBsZXQgbiA9IGUuZGVjbztcbiAgICBuICYmIG4uc3RhcnRTaWRlID4gMCAmJiAhdGhpcy5pc0NvdmVyZWQgJiYgdGhpcy5lbnN1cmVMaW5lKCksIHRoaXMubm9kZXMucHVzaChlKSwgdGhpcy53cml0dGVuVG8gPSB0aGlzLnBvcyA9IHRoaXMucG9zICsgZS5sZW5ndGgsIG4gJiYgbi5lbmRTaWRlID4gMCAmJiAodGhpcy5jb3ZlcmluZyA9IGUpO1xuICB9XG4gIGFkZExpbmVEZWNvKGUsIG4sIHIpIHtcbiAgICBsZXQgaSA9IHRoaXMuZW5zdXJlTGluZSgpO1xuICAgIGkubGVuZ3RoICs9IHIsIGkuY29sbGFwc2VkICs9IHIsIGkud2lkZ2V0SGVpZ2h0ID0gTWF0aC5tYXgoaS53aWRnZXRIZWlnaHQsIGUpLCBpLmJyZWFrcyArPSBuLCB0aGlzLndyaXR0ZW5UbyA9IHRoaXMucG9zID0gdGhpcy5wb3MgKyByO1xuICB9XG4gIGZpbmlzaChlKSB7XG4gICAgbGV0IG4gPSB0aGlzLm5vZGVzLmxlbmd0aCA9PSAwID8gbnVsbCA6IHRoaXMubm9kZXNbdGhpcy5ub2Rlcy5sZW5ndGggLSAxXTtcbiAgICB0aGlzLmxpbmVTdGFydCA+IC0xICYmICEobiBpbnN0YW5jZW9mIFJuKSAmJiAhdGhpcy5pc0NvdmVyZWQgPyB0aGlzLm5vZGVzLnB1c2gobmV3IFJuKDAsIC0xKSkgOiAodGhpcy53cml0dGVuVG8gPCB0aGlzLnBvcyB8fCBuID09IG51bGwpICYmIHRoaXMubm9kZXMucHVzaCh0aGlzLmJsYW5rQ29udGVudCh0aGlzLndyaXR0ZW5UbywgdGhpcy5wb3MpKTtcbiAgICBsZXQgciA9IGU7XG4gICAgZm9yIChsZXQgaSBvZiB0aGlzLm5vZGVzKVxuICAgICAgaSBpbnN0YW5jZW9mIFJuICYmIGkudXBkYXRlSGVpZ2h0KHRoaXMub3JhY2xlLCByKSwgciArPSBpID8gaS5sZW5ndGggOiAxO1xuICAgIHJldHVybiB0aGlzLm5vZGVzO1xuICB9XG4gIC8vIEFsd2F5cyBjYWxsZWQgd2l0aCBhIHJlZ2lvbiB0aGF0IG9uIGJvdGggc2lkZXMgZWl0aGVyIHN0cmV0Y2hlc1xuICAvLyB0byBhIGxpbmUgYnJlYWsgb3IgdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQuXG4gIC8vIFRoZSByZXR1cm5lZCBhcnJheSB1c2VzIG51bGwgdG8gaW5kaWNhdGUgbGluZSBicmVha3MsIGJ1dCBuZXZlclxuICAvLyBzdGFydHMgb3IgZW5kcyBpbiBhIGxpbmUgYnJlYWssIG9yIGhhcyBtdWx0aXBsZSBsaW5lIGJyZWFrcyBuZXh0XG4gIC8vIHRvIGVhY2ggb3RoZXIuXG4gIHN0YXRpYyBidWlsZChlLCBuLCByLCBpKSB7XG4gICAgbGV0IHMgPSBuZXcgZGcociwgZSk7XG4gICAgcmV0dXJuIHplLnNwYW5zKG4sIHIsIGksIHMsIDApLCBzLmZpbmlzaChyKTtcbiAgfVxufVxuZnVuY3Rpb24geDUodCwgZSwgbikge1xuICBsZXQgciA9IG5ldyBQNSgpO1xuICByZXR1cm4gemUuY29tcGFyZSh0LCBlLCBuLCByLCAwKSwgci5jaGFuZ2VzO1xufVxuY2xhc3MgUDUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNoYW5nZXMgPSBbXTtcbiAgfVxuICBjb21wYXJlUmFuZ2UoKSB7XG4gIH1cbiAgY29tcGFyZVBvaW50KGUsIG4sIHIsIGkpIHtcbiAgICAoZSA8IG4gfHwgciAmJiByLmhlaWdodFJlbGV2YW50IHx8IGkgJiYgaS5oZWlnaHRSZWxldmFudCkgJiYgbHAoZSwgbiwgdGhpcy5jaGFuZ2VzLCA1KTtcbiAgfVxufVxuZnVuY3Rpb24gXzUodCwgZSkge1xuICBsZXQgbiA9IHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHIgPSB0Lm93bmVyRG9jdW1lbnQsIGkgPSByLmRlZmF1bHRWaWV3IHx8IHdpbmRvdywgcyA9IE1hdGgubWF4KDAsIG4ubGVmdCksIG8gPSBNYXRoLm1pbihpLmlubmVyV2lkdGgsIG4ucmlnaHQpLCBhID0gTWF0aC5tYXgoMCwgbi50b3ApLCBsID0gTWF0aC5taW4oaS5pbm5lckhlaWdodCwgbi5ib3R0b20pO1xuICBmb3IgKGxldCBjID0gdC5wYXJlbnROb2RlOyBjICYmIGMgIT0gci5ib2R5OyApXG4gICAgaWYgKGMubm9kZVR5cGUgPT0gMSkge1xuICAgICAgbGV0IHUgPSBjLCBkID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodSk7XG4gICAgICBpZiAoKHUuc2Nyb2xsSGVpZ2h0ID4gdS5jbGllbnRIZWlnaHQgfHwgdS5zY3JvbGxXaWR0aCA+IHUuY2xpZW50V2lkdGgpICYmIGQub3ZlcmZsb3cgIT0gXCJ2aXNpYmxlXCIpIHtcbiAgICAgICAgbGV0IGYgPSB1LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBzID0gTWF0aC5tYXgocywgZi5sZWZ0KSwgbyA9IE1hdGgubWluKG8sIGYucmlnaHQpLCBhID0gTWF0aC5tYXgoYSwgZi50b3ApLCBsID0gYyA9PSB0LnBhcmVudE5vZGUgPyBmLmJvdHRvbSA6IE1hdGgubWluKGwsIGYuYm90dG9tKTtcbiAgICAgIH1cbiAgICAgIGMgPSBkLnBvc2l0aW9uID09IFwiYWJzb2x1dGVcIiB8fCBkLnBvc2l0aW9uID09IFwiZml4ZWRcIiA/IHUub2Zmc2V0UGFyZW50IDogdS5wYXJlbnROb2RlO1xuICAgIH0gZWxzZSBpZiAoYy5ub2RlVHlwZSA9PSAxMSlcbiAgICAgIGMgPSBjLmhvc3Q7XG4gICAgZWxzZVxuICAgICAgYnJlYWs7XG4gIHJldHVybiB7XG4gICAgbGVmdDogcyAtIG4ubGVmdCxcbiAgICByaWdodDogTWF0aC5tYXgocywgbykgLSBuLmxlZnQsXG4gICAgdG9wOiBhIC0gKG4udG9wICsgZSksXG4gICAgYm90dG9tOiBNYXRoLm1heChhLCBsKSAtIChuLnRvcCArIGUpXG4gIH07XG59XG5mdW5jdGlvbiBUNSh0LCBlKSB7XG4gIGxldCBuID0gdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIHtcbiAgICBsZWZ0OiAwLFxuICAgIHJpZ2h0OiBuLnJpZ2h0IC0gbi5sZWZ0LFxuICAgIHRvcDogZSxcbiAgICBib3R0b206IG4uYm90dG9tIC0gKG4udG9wICsgZSlcbiAgfTtcbn1cbmNsYXNzIEVmIHtcbiAgY29uc3RydWN0b3IoZSwgbiwgcikge1xuICAgIHRoaXMuZnJvbSA9IGUsIHRoaXMudG8gPSBuLCB0aGlzLnNpemUgPSByO1xuICB9XG4gIHN0YXRpYyBzYW1lKGUsIG4pIHtcbiAgICBpZiAoZS5sZW5ndGggIT0gbi5sZW5ndGgpXG4gICAgICByZXR1cm4gITE7XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCBlLmxlbmd0aDsgcisrKSB7XG4gICAgICBsZXQgaSA9IGVbcl0sIHMgPSBuW3JdO1xuICAgICAgaWYgKGkuZnJvbSAhPSBzLmZyb20gfHwgaS50byAhPSBzLnRvIHx8IGkuc2l6ZSAhPSBzLnNpemUpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIGRyYXcoZSwgbikge1xuICAgIHJldHVybiBKZS5yZXBsYWNlKHtcbiAgICAgIHdpZGdldDogbmV3IEU1KHRoaXMuc2l6ZSAqIChuID8gZS5zY2FsZVkgOiBlLnNjYWxlWCksIG4pXG4gICAgfSkucmFuZ2UodGhpcy5mcm9tLCB0aGlzLnRvKTtcbiAgfVxufVxuY2xhc3MgRTUgZXh0ZW5kcyByYSB7XG4gIGNvbnN0cnVjdG9yKGUsIG4pIHtcbiAgICBzdXBlcigpLCB0aGlzLnNpemUgPSBlLCB0aGlzLnZlcnRpY2FsID0gbjtcbiAgfVxuICBlcShlKSB7XG4gICAgcmV0dXJuIGUuc2l6ZSA9PSB0aGlzLnNpemUgJiYgZS52ZXJ0aWNhbCA9PSB0aGlzLnZlcnRpY2FsO1xuICB9XG4gIHRvRE9NKCkge1xuICAgIGxldCBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICByZXR1cm4gdGhpcy52ZXJ0aWNhbCA/IGUuc3R5bGUuaGVpZ2h0ID0gdGhpcy5zaXplICsgXCJweFwiIDogKGUuc3R5bGUud2lkdGggPSB0aGlzLnNpemUgKyBcInB4XCIsIGUuc3R5bGUuaGVpZ2h0ID0gXCIycHhcIiwgZS5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIiksIGU7XG4gIH1cbiAgZ2V0IGVzdGltYXRlZEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy52ZXJ0aWNhbCA/IHRoaXMuc2l6ZSA6IC0xO1xuICB9XG59XG5jbGFzcyBtdiB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLnN0YXRlID0gZSwgdGhpcy5waXhlbFZpZXdwb3J0ID0geyBsZWZ0OiAwLCByaWdodDogd2luZG93LmlubmVyV2lkdGgsIHRvcDogMCwgYm90dG9tOiAwIH0sIHRoaXMuaW5WaWV3ID0gITAsIHRoaXMucGFkZGluZ1RvcCA9IDAsIHRoaXMucGFkZGluZ0JvdHRvbSA9IDAsIHRoaXMuY29udGVudERPTVdpZHRoID0gMCwgdGhpcy5jb250ZW50RE9NSGVpZ2h0ID0gMCwgdGhpcy5lZGl0b3JIZWlnaHQgPSAwLCB0aGlzLmVkaXRvcldpZHRoID0gMCwgdGhpcy5zY3JvbGxUb3AgPSAwLCB0aGlzLnNjcm9sbGVkVG9Cb3R0b20gPSAhMCwgdGhpcy5zY2FsZVggPSAxLCB0aGlzLnNjYWxlWSA9IDEsIHRoaXMuc2Nyb2xsQW5jaG9yUG9zID0gMCwgdGhpcy5zY3JvbGxBbmNob3JIZWlnaHQgPSAtMSwgdGhpcy5zY2FsZXIgPSBidiwgdGhpcy5zY3JvbGxUYXJnZXQgPSBudWxsLCB0aGlzLnByaW50aW5nID0gITEsIHRoaXMubXVzdE1lYXN1cmVDb250ZW50ID0gITAsIHRoaXMuZGVmYXVsdFRleHREaXJlY3Rpb24gPSBRdC5MVFIsIHRoaXMudmlzaWJsZVJhbmdlcyA9IFtdLCB0aGlzLm11c3RFbmZvcmNlQ3Vyc29yQXNzb2MgPSAhMTtcbiAgICBsZXQgbiA9IGUuZmFjZXQoY2cpLnNvbWUoKHIpID0+IHR5cGVvZiByICE9IFwiZnVuY3Rpb25cIiAmJiByLmNsYXNzID09IFwiY20tbGluZVdyYXBwaW5nXCIpO1xuICAgIHRoaXMuaGVpZ2h0T3JhY2xlID0gbmV3IHk1KG4pLCB0aGlzLnN0YXRlRGVjbyA9IGUuZmFjZXQobWwpLmZpbHRlcigocikgPT4gdHlwZW9mIHIgIT0gXCJmdW5jdGlvblwiKSwgdGhpcy5oZWlnaHRNYXAgPSBwbi5lbXB0eSgpLmFwcGx5Q2hhbmdlcyh0aGlzLnN0YXRlRGVjbywgRmUuZW1wdHksIHRoaXMuaGVpZ2h0T3JhY2xlLnNldERvYyhlLmRvYyksIFtuZXcgdHIoMCwgMCwgMCwgZS5kb2MubGVuZ3RoKV0pLCB0aGlzLnZpZXdwb3J0ID0gdGhpcy5nZXRWaWV3cG9ydCgwLCBudWxsKSwgdGhpcy51cGRhdGVWaWV3cG9ydExpbmVzKCksIHRoaXMudXBkYXRlRm9yVmlld3BvcnQoKSwgdGhpcy5saW5lR2FwcyA9IHRoaXMuZW5zdXJlTGluZUdhcHMoW10pLCB0aGlzLmxpbmVHYXBEZWNvID0gSmUuc2V0KHRoaXMubGluZUdhcHMubWFwKChyKSA9PiByLmRyYXcodGhpcywgITEpKSksIHRoaXMuY29tcHV0ZVZpc2libGVSYW5nZXMoKTtcbiAgfVxuICB1cGRhdGVGb3JWaWV3cG9ydCgpIHtcbiAgICBsZXQgZSA9IFt0aGlzLnZpZXdwb3J0XSwgeyBtYWluOiBuIH0gPSB0aGlzLnN0YXRlLnNlbGVjdGlvbjtcbiAgICBmb3IgKGxldCByID0gMDsgciA8PSAxOyByKyspIHtcbiAgICAgIGxldCBpID0gciA/IG4uaGVhZCA6IG4uYW5jaG9yO1xuICAgICAgaWYgKCFlLnNvbWUoKHsgZnJvbTogcywgdG86IG8gfSkgPT4gaSA+PSBzICYmIGkgPD0gbykpIHtcbiAgICAgICAgbGV0IHsgZnJvbTogcywgdG86IG8gfSA9IHRoaXMubGluZUJsb2NrQXQoaSk7XG4gICAgICAgIGUucHVzaChuZXcgJGMocywgbykpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnZpZXdwb3J0cyA9IGUuc29ydCgociwgaSkgPT4gci5mcm9tIC0gaS5mcm9tKSwgdGhpcy5zY2FsZXIgPSB0aGlzLmhlaWdodE1hcC5oZWlnaHQgPD0gN2U2ID8gYnYgOiBuZXcgQzUodGhpcy5oZWlnaHRPcmFjbGUsIHRoaXMuaGVpZ2h0TWFwLCB0aGlzLnZpZXdwb3J0cyk7XG4gIH1cbiAgdXBkYXRlVmlld3BvcnRMaW5lcygpIHtcbiAgICB0aGlzLnZpZXdwb3J0TGluZXMgPSBbXSwgdGhpcy5oZWlnaHRNYXAuZm9yRWFjaExpbmUodGhpcy52aWV3cG9ydC5mcm9tLCB0aGlzLnZpZXdwb3J0LnRvLCB0aGlzLmhlaWdodE9yYWNsZS5zZXREb2ModGhpcy5zdGF0ZS5kb2MpLCAwLCAwLCAoZSkgPT4ge1xuICAgICAgdGhpcy52aWV3cG9ydExpbmVzLnB1c2godGhpcy5zY2FsZXIuc2NhbGUgPT0gMSA/IGUgOiBEYShlLCB0aGlzLnNjYWxlcikpO1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZShlLCBuID0gbnVsbCkge1xuICAgIHRoaXMuc3RhdGUgPSBlLnN0YXRlO1xuICAgIGxldCByID0gdGhpcy5zdGF0ZURlY287XG4gICAgdGhpcy5zdGF0ZURlY28gPSB0aGlzLnN0YXRlLmZhY2V0KG1sKS5maWx0ZXIoKHUpID0+IHR5cGVvZiB1ICE9IFwiZnVuY3Rpb25cIik7XG4gICAgbGV0IGkgPSBlLmNoYW5nZWRSYW5nZXMsIHMgPSB0ci5leHRlbmRXaXRoUmFuZ2VzKGksIHg1KHIsIHRoaXMuc3RhdGVEZWNvLCBlID8gZS5jaGFuZ2VzIDogTXQuZW1wdHkodGhpcy5zdGF0ZS5kb2MubGVuZ3RoKSkpLCBvID0gdGhpcy5oZWlnaHRNYXAuaGVpZ2h0LCBhID0gdGhpcy5zY3JvbGxlZFRvQm90dG9tID8gbnVsbCA6IHRoaXMuc2Nyb2xsQW5jaG9yQXQodGhpcy5zY3JvbGxUb3ApO1xuICAgIHRoaXMuaGVpZ2h0TWFwID0gdGhpcy5oZWlnaHRNYXAuYXBwbHlDaGFuZ2VzKHRoaXMuc3RhdGVEZWNvLCBlLnN0YXJ0U3RhdGUuZG9jLCB0aGlzLmhlaWdodE9yYWNsZS5zZXREb2ModGhpcy5zdGF0ZS5kb2MpLCBzKSwgdGhpcy5oZWlnaHRNYXAuaGVpZ2h0ICE9IG8gJiYgKGUuZmxhZ3MgfD0gMiksIGEgPyAodGhpcy5zY3JvbGxBbmNob3JQb3MgPSBlLmNoYW5nZXMubWFwUG9zKGEuZnJvbSwgLTEpLCB0aGlzLnNjcm9sbEFuY2hvckhlaWdodCA9IGEudG9wKSA6ICh0aGlzLnNjcm9sbEFuY2hvclBvcyA9IC0xLCB0aGlzLnNjcm9sbEFuY2hvckhlaWdodCA9IHRoaXMuaGVpZ2h0TWFwLmhlaWdodCk7XG4gICAgbGV0IGwgPSBzLmxlbmd0aCA/IHRoaXMubWFwVmlld3BvcnQodGhpcy52aWV3cG9ydCwgZS5jaGFuZ2VzKSA6IHRoaXMudmlld3BvcnQ7XG4gICAgKG4gJiYgKG4ucmFuZ2UuaGVhZCA8IGwuZnJvbSB8fCBuLnJhbmdlLmhlYWQgPiBsLnRvKSB8fCAhdGhpcy52aWV3cG9ydElzQXBwcm9wcmlhdGUobCkpICYmIChsID0gdGhpcy5nZXRWaWV3cG9ydCgwLCBuKSk7XG4gICAgbGV0IGMgPSAhZS5jaGFuZ2VzLmVtcHR5IHx8IGUuZmxhZ3MgJiAyIHx8IGwuZnJvbSAhPSB0aGlzLnZpZXdwb3J0LmZyb20gfHwgbC50byAhPSB0aGlzLnZpZXdwb3J0LnRvO1xuICAgIHRoaXMudmlld3BvcnQgPSBsLCB0aGlzLnVwZGF0ZUZvclZpZXdwb3J0KCksIGMgJiYgdGhpcy51cGRhdGVWaWV3cG9ydExpbmVzKCksICh0aGlzLmxpbmVHYXBzLmxlbmd0aCB8fCB0aGlzLnZpZXdwb3J0LnRvIC0gdGhpcy52aWV3cG9ydC5mcm9tID4gNGUzKSAmJiB0aGlzLnVwZGF0ZUxpbmVHYXBzKHRoaXMuZW5zdXJlTGluZUdhcHModGhpcy5tYXBMaW5lR2Fwcyh0aGlzLmxpbmVHYXBzLCBlLmNoYW5nZXMpKSksIGUuZmxhZ3MgfD0gdGhpcy5jb21wdXRlVmlzaWJsZVJhbmdlcygpLCBuICYmICh0aGlzLnNjcm9sbFRhcmdldCA9IG4pLCAhdGhpcy5tdXN0RW5mb3JjZUN1cnNvckFzc29jICYmIGUuc2VsZWN0aW9uU2V0ICYmIGUudmlldy5saW5lV3JhcHBpbmcgJiYgZS5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5lbXB0eSAmJiBlLnN0YXRlLnNlbGVjdGlvbi5tYWluLmFzc29jICYmICFlLnN0YXRlLmZhY2V0KFdOKSAmJiAodGhpcy5tdXN0RW5mb3JjZUN1cnNvckFzc29jID0gITApO1xuICB9XG4gIG1lYXN1cmUoZSkge1xuICAgIGxldCBuID0gZS5jb250ZW50RE9NLCByID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobiksIGkgPSB0aGlzLmhlaWdodE9yYWNsZSwgcyA9IHIud2hpdGVTcGFjZTtcbiAgICB0aGlzLmRlZmF1bHRUZXh0RGlyZWN0aW9uID0gci5kaXJlY3Rpb24gPT0gXCJydGxcIiA/IFF0LlJUTCA6IFF0LkxUUjtcbiAgICBsZXQgbyA9IHRoaXMuaGVpZ2h0T3JhY2xlLm11c3RSZWZyZXNoRm9yV3JhcHBpbmcocyksIGEgPSBuLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBsID0gbyB8fCB0aGlzLm11c3RNZWFzdXJlQ29udGVudCB8fCB0aGlzLmNvbnRlbnRET01IZWlnaHQgIT0gYS5oZWlnaHQ7XG4gICAgdGhpcy5jb250ZW50RE9NSGVpZ2h0ID0gYS5oZWlnaHQsIHRoaXMubXVzdE1lYXN1cmVDb250ZW50ID0gITE7XG4gICAgbGV0IGMgPSAwLCB1ID0gMDtcbiAgICBpZiAoYS53aWR0aCAmJiBhLmhlaWdodCkge1xuICAgICAgbGV0IHsgc2NhbGVYOiB2LCBzY2FsZVk6IFMgfSA9IEt3KG4sIGEpO1xuICAgICAgKHRoaXMuc2NhbGVYICE9IHYgfHwgdGhpcy5zY2FsZVkgIT0gUykgJiYgKHRoaXMuc2NhbGVYID0gdiwgdGhpcy5zY2FsZVkgPSBTLCBjIHw9IDgsIG8gPSBsID0gITApO1xuICAgIH1cbiAgICBsZXQgZCA9IChwYXJzZUludChyLnBhZGRpbmdUb3ApIHx8IDApICogdGhpcy5zY2FsZVksIGYgPSAocGFyc2VJbnQoci5wYWRkaW5nQm90dG9tKSB8fCAwKSAqIHRoaXMuc2NhbGVZO1xuICAgICh0aGlzLnBhZGRpbmdUb3AgIT0gZCB8fCB0aGlzLnBhZGRpbmdCb3R0b20gIT0gZikgJiYgKHRoaXMucGFkZGluZ1RvcCA9IGQsIHRoaXMucGFkZGluZ0JvdHRvbSA9IGYsIGMgfD0gMTApLCB0aGlzLmVkaXRvcldpZHRoICE9IGUuc2Nyb2xsRE9NLmNsaWVudFdpZHRoICYmIChpLmxpbmVXcmFwcGluZyAmJiAobCA9ICEwKSwgdGhpcy5lZGl0b3JXaWR0aCA9IGUuc2Nyb2xsRE9NLmNsaWVudFdpZHRoLCBjIHw9IDgpO1xuICAgIGxldCBoID0gZS5zY3JvbGxET00uc2Nyb2xsVG9wICogdGhpcy5zY2FsZVk7XG4gICAgdGhpcy5zY3JvbGxUb3AgIT0gaCAmJiAodGhpcy5zY3JvbGxBbmNob3JIZWlnaHQgPSAtMSwgdGhpcy5zY3JvbGxUb3AgPSBoKSwgdGhpcy5zY3JvbGxlZFRvQm90dG9tID0gdGsoZS5zY3JvbGxET00pO1xuICAgIGxldCBwID0gKHRoaXMucHJpbnRpbmcgPyBUNSA6IF81KShuLCB0aGlzLnBhZGRpbmdUb3ApLCBPID0gcC50b3AgLSB0aGlzLnBpeGVsVmlld3BvcnQudG9wLCBtID0gcC5ib3R0b20gLSB0aGlzLnBpeGVsVmlld3BvcnQuYm90dG9tO1xuICAgIHRoaXMucGl4ZWxWaWV3cG9ydCA9IHA7XG4gICAgbGV0IHkgPSB0aGlzLnBpeGVsVmlld3BvcnQuYm90dG9tID4gdGhpcy5waXhlbFZpZXdwb3J0LnRvcCAmJiB0aGlzLnBpeGVsVmlld3BvcnQucmlnaHQgPiB0aGlzLnBpeGVsVmlld3BvcnQubGVmdDtcbiAgICBpZiAoeSAhPSB0aGlzLmluVmlldyAmJiAodGhpcy5pblZpZXcgPSB5LCB5ICYmIChsID0gITApKSwgIXRoaXMuaW5WaWV3ICYmICF0aGlzLnNjcm9sbFRhcmdldClcbiAgICAgIHJldHVybiAwO1xuICAgIGxldCBiID0gYS53aWR0aDtcbiAgICBpZiAoKHRoaXMuY29udGVudERPTVdpZHRoICE9IGIgfHwgdGhpcy5lZGl0b3JIZWlnaHQgIT0gZS5zY3JvbGxET00uY2xpZW50SGVpZ2h0KSAmJiAodGhpcy5jb250ZW50RE9NV2lkdGggPSBhLndpZHRoLCB0aGlzLmVkaXRvckhlaWdodCA9IGUuc2Nyb2xsRE9NLmNsaWVudEhlaWdodCwgYyB8PSA4KSwgbCkge1xuICAgICAgbGV0IHYgPSBlLmRvY1ZpZXcubWVhc3VyZVZpc2libGVMaW5lSGVpZ2h0cyh0aGlzLnZpZXdwb3J0KTtcbiAgICAgIGlmIChpLm11c3RSZWZyZXNoRm9ySGVpZ2h0cyh2KSAmJiAobyA9ICEwKSwgbyB8fCBpLmxpbmVXcmFwcGluZyAmJiBNYXRoLmFicyhiIC0gdGhpcy5jb250ZW50RE9NV2lkdGgpID4gaS5jaGFyV2lkdGgpIHtcbiAgICAgICAgbGV0IHsgbGluZUhlaWdodDogUywgY2hhcldpZHRoOiB3LCB0ZXh0SGVpZ2h0OiBrIH0gPSBlLmRvY1ZpZXcubWVhc3VyZVRleHRTaXplKCk7XG4gICAgICAgIG8gPSBTID4gMCAmJiBpLnJlZnJlc2gocywgUywgdywgaywgYiAvIHcsIHYpLCBvICYmIChlLmRvY1ZpZXcubWluV2lkdGggPSAwLCBjIHw9IDgpO1xuICAgICAgfVxuICAgICAgTyA+IDAgJiYgbSA+IDAgPyB1ID0gTWF0aC5tYXgoTywgbSkgOiBPIDwgMCAmJiBtIDwgMCAmJiAodSA9IE1hdGgubWluKE8sIG0pKSwgaS5oZWlnaHRDaGFuZ2VkID0gITE7XG4gICAgICBmb3IgKGxldCBTIG9mIHRoaXMudmlld3BvcnRzKSB7XG4gICAgICAgIGxldCB3ID0gUy5mcm9tID09IHRoaXMudmlld3BvcnQuZnJvbSA/IHYgOiBlLmRvY1ZpZXcubWVhc3VyZVZpc2libGVMaW5lSGVpZ2h0cyhTKTtcbiAgICAgICAgdGhpcy5oZWlnaHRNYXAgPSAobyA/IHBuLmVtcHR5KCkuYXBwbHlDaGFuZ2VzKHRoaXMuc3RhdGVEZWNvLCBGZS5lbXB0eSwgdGhpcy5oZWlnaHRPcmFjbGUsIFtuZXcgdHIoMCwgMCwgMCwgZS5zdGF0ZS5kb2MubGVuZ3RoKV0pIDogdGhpcy5oZWlnaHRNYXApLnVwZGF0ZUhlaWdodChpLCAwLCBvLCBuZXcgUzUoUy5mcm9tLCB3KSk7XG4gICAgICB9XG4gICAgICBpLmhlaWdodENoYW5nZWQgJiYgKGMgfD0gMik7XG4gICAgfVxuICAgIGxldCBnID0gIXRoaXMudmlld3BvcnRJc0FwcHJvcHJpYXRlKHRoaXMudmlld3BvcnQsIHUpIHx8IHRoaXMuc2Nyb2xsVGFyZ2V0ICYmICh0aGlzLnNjcm9sbFRhcmdldC5yYW5nZS5oZWFkIDwgdGhpcy52aWV3cG9ydC5mcm9tIHx8IHRoaXMuc2Nyb2xsVGFyZ2V0LnJhbmdlLmhlYWQgPiB0aGlzLnZpZXdwb3J0LnRvKTtcbiAgICByZXR1cm4gZyAmJiAodGhpcy52aWV3cG9ydCA9IHRoaXMuZ2V0Vmlld3BvcnQodSwgdGhpcy5zY3JvbGxUYXJnZXQpKSwgdGhpcy51cGRhdGVGb3JWaWV3cG9ydCgpLCAoYyAmIDIgfHwgZykgJiYgdGhpcy51cGRhdGVWaWV3cG9ydExpbmVzKCksICh0aGlzLmxpbmVHYXBzLmxlbmd0aCB8fCB0aGlzLnZpZXdwb3J0LnRvIC0gdGhpcy52aWV3cG9ydC5mcm9tID4gNGUzKSAmJiB0aGlzLnVwZGF0ZUxpbmVHYXBzKHRoaXMuZW5zdXJlTGluZUdhcHMobyA/IFtdIDogdGhpcy5saW5lR2FwcywgZSkpLCBjIHw9IHRoaXMuY29tcHV0ZVZpc2libGVSYW5nZXMoKSwgdGhpcy5tdXN0RW5mb3JjZUN1cnNvckFzc29jICYmICh0aGlzLm11c3RFbmZvcmNlQ3Vyc29yQXNzb2MgPSAhMSwgZS5kb2NWaWV3LmVuZm9yY2VDdXJzb3JBc3NvYygpKSwgYztcbiAgfVxuICBnZXQgdmlzaWJsZVRvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5zY2FsZXIuZnJvbURPTSh0aGlzLnBpeGVsVmlld3BvcnQudG9wKTtcbiAgfVxuICBnZXQgdmlzaWJsZUJvdHRvbSgpIHtcbiAgICByZXR1cm4gdGhpcy5zY2FsZXIuZnJvbURPTSh0aGlzLnBpeGVsVmlld3BvcnQuYm90dG9tKTtcbiAgfVxuICBnZXRWaWV3cG9ydChlLCBuKSB7XG4gICAgbGV0IHIgPSAwLjUgLSBNYXRoLm1heCgtMC41LCBNYXRoLm1pbigwLjUsIGUgLyAxZTMgLyAyKSksIGkgPSB0aGlzLmhlaWdodE1hcCwgcyA9IHRoaXMuaGVpZ2h0T3JhY2xlLCB7IHZpc2libGVUb3A6IG8sIHZpc2libGVCb3R0b206IGEgfSA9IHRoaXMsIGwgPSBuZXcgJGMoaS5saW5lQXQobyAtIHIgKiAxZTMsIGR0LkJ5SGVpZ2h0LCBzLCAwLCAwKS5mcm9tLCBpLmxpbmVBdChhICsgKDEgLSByKSAqIDFlMywgZHQuQnlIZWlnaHQsIHMsIDAsIDApLnRvKTtcbiAgICBpZiAobikge1xuICAgICAgbGV0IHsgaGVhZDogYyB9ID0gbi5yYW5nZTtcbiAgICAgIGlmIChjIDwgbC5mcm9tIHx8IGMgPiBsLnRvKSB7XG4gICAgICAgIGxldCB1ID0gTWF0aC5taW4odGhpcy5lZGl0b3JIZWlnaHQsIHRoaXMucGl4ZWxWaWV3cG9ydC5ib3R0b20gLSB0aGlzLnBpeGVsVmlld3BvcnQudG9wKSwgZCA9IGkubGluZUF0KGMsIGR0LkJ5UG9zLCBzLCAwLCAwKSwgZjtcbiAgICAgICAgbi55ID09IFwiY2VudGVyXCIgPyBmID0gKGQudG9wICsgZC5ib3R0b20pIC8gMiAtIHUgLyAyIDogbi55ID09IFwic3RhcnRcIiB8fCBuLnkgPT0gXCJuZWFyZXN0XCIgJiYgYyA8IGwuZnJvbSA/IGYgPSBkLnRvcCA6IGYgPSBkLmJvdHRvbSAtIHUsIGwgPSBuZXcgJGMoaS5saW5lQXQoZiAtIDFlMyAvIDIsIGR0LkJ5SGVpZ2h0LCBzLCAwLCAwKS5mcm9tLCBpLmxpbmVBdChmICsgdSArIDFlMyAvIDIsIGR0LkJ5SGVpZ2h0LCBzLCAwLCAwKS50byk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBsO1xuICB9XG4gIG1hcFZpZXdwb3J0KGUsIG4pIHtcbiAgICBsZXQgciA9IG4ubWFwUG9zKGUuZnJvbSwgLTEpLCBpID0gbi5tYXBQb3MoZS50bywgMSk7XG4gICAgcmV0dXJuIG5ldyAkYyh0aGlzLmhlaWdodE1hcC5saW5lQXQociwgZHQuQnlQb3MsIHRoaXMuaGVpZ2h0T3JhY2xlLCAwLCAwKS5mcm9tLCB0aGlzLmhlaWdodE1hcC5saW5lQXQoaSwgZHQuQnlQb3MsIHRoaXMuaGVpZ2h0T3JhY2xlLCAwLCAwKS50byk7XG4gIH1cbiAgLy8gQ2hlY2tzIGlmIGEgZ2l2ZW4gdmlld3BvcnQgY292ZXJzIHRoZSB2aXNpYmxlIHBhcnQgb2YgdGhlXG4gIC8vIGRvY3VtZW50IGFuZCBub3QgdG9vIG11Y2ggYmV5b25kIHRoYXQuXG4gIHZpZXdwb3J0SXNBcHByb3ByaWF0ZSh7IGZyb206IGUsIHRvOiBuIH0sIHIgPSAwKSB7XG4gICAgaWYgKCF0aGlzLmluVmlldylcbiAgICAgIHJldHVybiAhMDtcbiAgICBsZXQgeyB0b3A6IGkgfSA9IHRoaXMuaGVpZ2h0TWFwLmxpbmVBdChlLCBkdC5CeVBvcywgdGhpcy5oZWlnaHRPcmFjbGUsIDAsIDApLCB7IGJvdHRvbTogcyB9ID0gdGhpcy5oZWlnaHRNYXAubGluZUF0KG4sIGR0LkJ5UG9zLCB0aGlzLmhlaWdodE9yYWNsZSwgMCwgMCksIHsgdmlzaWJsZVRvcDogbywgdmlzaWJsZUJvdHRvbTogYSB9ID0gdGhpcztcbiAgICByZXR1cm4gKGUgPT0gMCB8fCBpIDw9IG8gLSBNYXRoLm1heCgxMCwgTWF0aC5taW4oXG4gICAgICAtcixcbiAgICAgIDI1MFxuICAgICAgLyogVlAuTWF4Q292ZXJNYXJnaW4gKi9cbiAgICApKSkgJiYgKG4gPT0gdGhpcy5zdGF0ZS5kb2MubGVuZ3RoIHx8IHMgPj0gYSArIE1hdGgubWF4KDEwLCBNYXRoLm1pbihcbiAgICAgIHIsXG4gICAgICAyNTBcbiAgICAgIC8qIFZQLk1heENvdmVyTWFyZ2luICovXG4gICAgKSkpICYmIGkgPiBvIC0gMiAqIDFlMyAmJiBzIDwgYSArIDIgKiAxZTM7XG4gIH1cbiAgbWFwTGluZUdhcHMoZSwgbikge1xuICAgIGlmICghZS5sZW5ndGggfHwgbi5lbXB0eSlcbiAgICAgIHJldHVybiBlO1xuICAgIGxldCByID0gW107XG4gICAgZm9yIChsZXQgaSBvZiBlKVxuICAgICAgbi50b3VjaGVzUmFuZ2UoaS5mcm9tLCBpLnRvKSB8fCByLnB1c2gobmV3IEVmKG4ubWFwUG9zKGkuZnJvbSksIG4ubWFwUG9zKGkudG8pLCBpLnNpemUpKTtcbiAgICByZXR1cm4gcjtcbiAgfVxuICAvLyBDb21wdXRlcyBwb3NpdGlvbnMgaW4gdGhlIHZpZXdwb3J0IHdoZXJlIHRoZSBzdGFydCBvciBlbmQgb2YgYVxuICAvLyBsaW5lIHNob3VsZCBiZSBoaWRkZW4sIHRyeWluZyB0byByZXVzZSBleGlzdGluZyBsaW5lIGdhcHMgd2hlblxuICAvLyBhcHByb3ByaWF0ZSB0byBhdm9pZCB1bm5lY2Nlc2FyeSByZWRyYXdzLlxuICAvLyBVc2VzIGNydWRlIGNoYXJhY3Rlci1jb3VudGluZyBmb3IgdGhlIHBvc2l0aW9uaW5nIGFuZCBzaXppbmcsXG4gIC8vIHNpbmNlIGFjdHVhbCBET00gY29vcmRpbmF0ZXMgYXJlbid0IGFsd2F5cyBhdmFpbGFibGUgYW5kXG4gIC8vIHByZWRpY3RhYmxlLiBSZWxpZXMgb24gZ2VuZXJvdXMgbWFyZ2lucyAoc2VlIExHLk1hcmdpbikgdG8gaGlkZVxuICAvLyB0aGUgYXJ0aWZhY3RzIHRoaXMgbWlnaHQgcHJvZHVjZSBmcm9tIHRoZSB1c2VyLlxuICBlbnN1cmVMaW5lR2FwcyhlLCBuKSB7XG4gICAgbGV0IHIgPSB0aGlzLmhlaWdodE9yYWNsZS5saW5lV3JhcHBpbmcsIGkgPSByID8gMWU0IDogMmUzLCBzID0gaSA+PiAxLCBvID0gaSA8PCAxO1xuICAgIGlmICh0aGlzLmRlZmF1bHRUZXh0RGlyZWN0aW9uICE9IFF0LkxUUiAmJiAhcilcbiAgICAgIHJldHVybiBbXTtcbiAgICBsZXQgYSA9IFtdLCBsID0gKGMsIHUsIGQsIGYpID0+IHtcbiAgICAgIGlmICh1IC0gYyA8IHMpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGxldCBoID0gdGhpcy5zdGF0ZS5zZWxlY3Rpb24ubWFpbiwgcCA9IFtoLmZyb21dO1xuICAgICAgaC5lbXB0eSB8fCBwLnB1c2goaC50byk7XG4gICAgICBmb3IgKGxldCBtIG9mIHApXG4gICAgICAgIGlmIChtID4gYyAmJiBtIDwgdSkge1xuICAgICAgICAgIGwoYywgbSAtIDEwLCBkLCBmKSwgbChtICsgMTAsIHUsIGQsIGYpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgbGV0IE8gPSBRNShlLCAobSkgPT4gbS5mcm9tID49IGQuZnJvbSAmJiBtLnRvIDw9IGQudG8gJiYgTWF0aC5hYnMobS5mcm9tIC0gYykgPCBzICYmIE1hdGguYWJzKG0udG8gLSB1KSA8IHMgJiYgIXAuc29tZSgoeSkgPT4gbS5mcm9tIDwgeSAmJiBtLnRvID4geSkpO1xuICAgICAgaWYgKCFPKSB7XG4gICAgICAgIGlmICh1IDwgZC50byAmJiBuICYmIHIgJiYgbi52aXNpYmxlUmFuZ2VzLnNvbWUoKG0pID0+IG0uZnJvbSA8PSB1ICYmIG0udG8gPj0gdSkpIHtcbiAgICAgICAgICBsZXQgbSA9IG4ubW92ZVRvTGluZUJvdW5kYXJ5KGFlLmN1cnNvcih1KSwgITEsICEwKS5oZWFkO1xuICAgICAgICAgIG0gPiBjICYmICh1ID0gbSk7XG4gICAgICAgIH1cbiAgICAgICAgTyA9IG5ldyBFZihjLCB1LCB0aGlzLmdhcFNpemUoZCwgYywgdSwgZikpO1xuICAgICAgfVxuICAgICAgYS5wdXNoKE8pO1xuICAgIH07XG4gICAgZm9yIChsZXQgYyBvZiB0aGlzLnZpZXdwb3J0TGluZXMpIHtcbiAgICAgIGlmIChjLmxlbmd0aCA8IG8pXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgbGV0IHUgPSAkNShjLmZyb20sIGMudG8sIHRoaXMuc3RhdGVEZWNvKTtcbiAgICAgIGlmICh1LnRvdGFsIDwgbylcbiAgICAgICAgY29udGludWU7XG4gICAgICBsZXQgZCA9IHRoaXMuc2Nyb2xsVGFyZ2V0ID8gdGhpcy5zY3JvbGxUYXJnZXQucmFuZ2UuaGVhZCA6IG51bGwsIGYsIGg7XG4gICAgICBpZiAocikge1xuICAgICAgICBsZXQgcCA9IGkgLyB0aGlzLmhlaWdodE9yYWNsZS5saW5lTGVuZ3RoICogdGhpcy5oZWlnaHRPcmFjbGUubGluZUhlaWdodCwgTywgbTtcbiAgICAgICAgaWYgKGQgIT0gbnVsbCkge1xuICAgICAgICAgIGxldCB5ID0gQ2ModSwgZCksIGIgPSAoKHRoaXMudmlzaWJsZUJvdHRvbSAtIHRoaXMudmlzaWJsZVRvcCkgLyAyICsgcCkgLyBjLmhlaWdodDtcbiAgICAgICAgICBPID0geSAtIGIsIG0gPSB5ICsgYjtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgTyA9ICh0aGlzLnZpc2libGVUb3AgLSBjLnRvcCAtIHApIC8gYy5oZWlnaHQsIG0gPSAodGhpcy52aXNpYmxlQm90dG9tIC0gYy50b3AgKyBwKSAvIGMuaGVpZ2h0O1xuICAgICAgICBmID0gUWModSwgTyksIGggPSBRYyh1LCBtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBwID0gdS50b3RhbCAqIHRoaXMuaGVpZ2h0T3JhY2xlLmNoYXJXaWR0aCwgTyA9IGkgKiB0aGlzLmhlaWdodE9yYWNsZS5jaGFyV2lkdGgsIG0sIHk7XG4gICAgICAgIGlmIChkICE9IG51bGwpIHtcbiAgICAgICAgICBsZXQgYiA9IENjKHUsIGQpLCBnID0gKCh0aGlzLnBpeGVsVmlld3BvcnQucmlnaHQgLSB0aGlzLnBpeGVsVmlld3BvcnQubGVmdCkgLyAyICsgTykgLyBwO1xuICAgICAgICAgIG0gPSBiIC0gZywgeSA9IGIgKyBnO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBtID0gKHRoaXMucGl4ZWxWaWV3cG9ydC5sZWZ0IC0gTykgLyBwLCB5ID0gKHRoaXMucGl4ZWxWaWV3cG9ydC5yaWdodCArIE8pIC8gcDtcbiAgICAgICAgZiA9IFFjKHUsIG0pLCBoID0gUWModSwgeSk7XG4gICAgICB9XG4gICAgICBmID4gYy5mcm9tICYmIGwoYy5mcm9tLCBmLCBjLCB1KSwgaCA8IGMudG8gJiYgbChoLCBjLnRvLCBjLCB1KTtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH1cbiAgZ2FwU2l6ZShlLCBuLCByLCBpKSB7XG4gICAgbGV0IHMgPSBDYyhpLCByKSAtIENjKGksIG4pO1xuICAgIHJldHVybiB0aGlzLmhlaWdodE9yYWNsZS5saW5lV3JhcHBpbmcgPyBlLmhlaWdodCAqIHMgOiBpLnRvdGFsICogdGhpcy5oZWlnaHRPcmFjbGUuY2hhcldpZHRoICogcztcbiAgfVxuICB1cGRhdGVMaW5lR2FwcyhlKSB7XG4gICAgRWYuc2FtZShlLCB0aGlzLmxpbmVHYXBzKSB8fCAodGhpcy5saW5lR2FwcyA9IGUsIHRoaXMubGluZUdhcERlY28gPSBKZS5zZXQoZS5tYXAoKG4pID0+IG4uZHJhdyh0aGlzLCB0aGlzLmhlaWdodE9yYWNsZS5saW5lV3JhcHBpbmcpKSkpO1xuICB9XG4gIGNvbXB1dGVWaXNpYmxlUmFuZ2VzKCkge1xuICAgIGxldCBlID0gdGhpcy5zdGF0ZURlY287XG4gICAgdGhpcy5saW5lR2Fwcy5sZW5ndGggJiYgKGUgPSBlLmNvbmNhdCh0aGlzLmxpbmVHYXBEZWNvKSk7XG4gICAgbGV0IG4gPSBbXTtcbiAgICB6ZS5zcGFucyhlLCB0aGlzLnZpZXdwb3J0LmZyb20sIHRoaXMudmlld3BvcnQudG8sIHtcbiAgICAgIHNwYW4oaSwgcykge1xuICAgICAgICBuLnB1c2goeyBmcm9tOiBpLCB0bzogcyB9KTtcbiAgICAgIH0sXG4gICAgICBwb2ludCgpIHtcbiAgICAgIH1cbiAgICB9LCAyMCk7XG4gICAgbGV0IHIgPSBuLmxlbmd0aCAhPSB0aGlzLnZpc2libGVSYW5nZXMubGVuZ3RoIHx8IHRoaXMudmlzaWJsZVJhbmdlcy5zb21lKChpLCBzKSA9PiBpLmZyb20gIT0gbltzXS5mcm9tIHx8IGkudG8gIT0gbltzXS50byk7XG4gICAgcmV0dXJuIHRoaXMudmlzaWJsZVJhbmdlcyA9IG4sIHIgPyA0IDogMDtcbiAgfVxuICBsaW5lQmxvY2tBdChlKSB7XG4gICAgcmV0dXJuIGUgPj0gdGhpcy52aWV3cG9ydC5mcm9tICYmIGUgPD0gdGhpcy52aWV3cG9ydC50byAmJiB0aGlzLnZpZXdwb3J0TGluZXMuZmluZCgobikgPT4gbi5mcm9tIDw9IGUgJiYgbi50byA+PSBlKSB8fCBEYSh0aGlzLmhlaWdodE1hcC5saW5lQXQoZSwgZHQuQnlQb3MsIHRoaXMuaGVpZ2h0T3JhY2xlLCAwLCAwKSwgdGhpcy5zY2FsZXIpO1xuICB9XG4gIGxpbmVCbG9ja0F0SGVpZ2h0KGUpIHtcbiAgICByZXR1cm4gRGEodGhpcy5oZWlnaHRNYXAubGluZUF0KHRoaXMuc2NhbGVyLmZyb21ET00oZSksIGR0LkJ5SGVpZ2h0LCB0aGlzLmhlaWdodE9yYWNsZSwgMCwgMCksIHRoaXMuc2NhbGVyKTtcbiAgfVxuICBzY3JvbGxBbmNob3JBdChlKSB7XG4gICAgbGV0IG4gPSB0aGlzLmxpbmVCbG9ja0F0SGVpZ2h0KGUgKyA4KTtcbiAgICByZXR1cm4gbi5mcm9tID49IHRoaXMudmlld3BvcnQuZnJvbSB8fCB0aGlzLnZpZXdwb3J0TGluZXNbMF0udG9wIC0gZSA+IDIwMCA/IG4gOiB0aGlzLnZpZXdwb3J0TGluZXNbMF07XG4gIH1cbiAgZWxlbWVudEF0SGVpZ2h0KGUpIHtcbiAgICByZXR1cm4gRGEodGhpcy5oZWlnaHRNYXAuYmxvY2tBdCh0aGlzLnNjYWxlci5mcm9tRE9NKGUpLCB0aGlzLmhlaWdodE9yYWNsZSwgMCwgMCksIHRoaXMuc2NhbGVyKTtcbiAgfVxuICBnZXQgZG9jSGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnNjYWxlci50b0RPTSh0aGlzLmhlaWdodE1hcC5oZWlnaHQpO1xuICB9XG4gIGdldCBjb250ZW50SGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmRvY0hlaWdodCArIHRoaXMucGFkZGluZ1RvcCArIHRoaXMucGFkZGluZ0JvdHRvbTtcbiAgfVxufVxuY2xhc3MgJGMge1xuICBjb25zdHJ1Y3RvcihlLCBuKSB7XG4gICAgdGhpcy5mcm9tID0gZSwgdGhpcy50byA9IG47XG4gIH1cbn1cbmZ1bmN0aW9uICQ1KHQsIGUsIG4pIHtcbiAgbGV0IHIgPSBbXSwgaSA9IHQsIHMgPSAwO1xuICByZXR1cm4gemUuc3BhbnMobiwgdCwgZSwge1xuICAgIHNwYW4oKSB7XG4gICAgfSxcbiAgICBwb2ludChvLCBhKSB7XG4gICAgICBvID4gaSAmJiAoci5wdXNoKHsgZnJvbTogaSwgdG86IG8gfSksIHMgKz0gbyAtIGkpLCBpID0gYTtcbiAgICB9XG4gIH0sIDIwKSwgaSA8IGUgJiYgKHIucHVzaCh7IGZyb206IGksIHRvOiBlIH0pLCBzICs9IGUgLSBpKSwgeyB0b3RhbDogcywgcmFuZ2VzOiByIH07XG59XG5mdW5jdGlvbiBRYyh7IHRvdGFsOiB0LCByYW5nZXM6IGUgfSwgbikge1xuICBpZiAobiA8PSAwKVxuICAgIHJldHVybiBlWzBdLmZyb207XG4gIGlmIChuID49IDEpXG4gICAgcmV0dXJuIGVbZS5sZW5ndGggLSAxXS50bztcbiAgbGV0IHIgPSBNYXRoLmZsb29yKHQgKiBuKTtcbiAgZm9yIChsZXQgaSA9IDA7IDsgaSsrKSB7XG4gICAgbGV0IHsgZnJvbTogcywgdG86IG8gfSA9IGVbaV0sIGEgPSBvIC0gcztcbiAgICBpZiAociA8PSBhKVxuICAgICAgcmV0dXJuIHMgKyByO1xuICAgIHIgLT0gYTtcbiAgfVxufVxuZnVuY3Rpb24gQ2ModCwgZSkge1xuICBsZXQgbiA9IDA7XG4gIGZvciAobGV0IHsgZnJvbTogciwgdG86IGkgfSBvZiB0LnJhbmdlcykge1xuICAgIGlmIChlIDw9IGkpIHtcbiAgICAgIG4gKz0gZSAtIHI7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbiArPSBpIC0gcjtcbiAgfVxuICByZXR1cm4gbiAvIHQudG90YWw7XG59XG5mdW5jdGlvbiBRNSh0LCBlKSB7XG4gIGZvciAobGV0IG4gb2YgdClcbiAgICBpZiAoZShuKSlcbiAgICAgIHJldHVybiBuO1xufVxuY29uc3QgYnYgPSB7XG4gIHRvRE9NKHQpIHtcbiAgICByZXR1cm4gdDtcbiAgfSxcbiAgZnJvbURPTSh0KSB7XG4gICAgcmV0dXJuIHQ7XG4gIH0sXG4gIHNjYWxlOiAxXG59O1xuY2xhc3MgQzUge1xuICBjb25zdHJ1Y3RvcihlLCBuLCByKSB7XG4gICAgbGV0IGkgPSAwLCBzID0gMCwgbyA9IDA7XG4gICAgdGhpcy52aWV3cG9ydHMgPSByLm1hcCgoeyBmcm9tOiBhLCB0bzogbCB9KSA9PiB7XG4gICAgICBsZXQgYyA9IG4ubGluZUF0KGEsIGR0LkJ5UG9zLCBlLCAwLCAwKS50b3AsIHUgPSBuLmxpbmVBdChsLCBkdC5CeVBvcywgZSwgMCwgMCkuYm90dG9tO1xuICAgICAgcmV0dXJuIGkgKz0gdSAtIGMsIHsgZnJvbTogYSwgdG86IGwsIHRvcDogYywgYm90dG9tOiB1LCBkb21Ub3A6IDAsIGRvbUJvdHRvbTogMCB9O1xuICAgIH0pLCB0aGlzLnNjYWxlID0gKDdlNiAtIGkpIC8gKG4uaGVpZ2h0IC0gaSk7XG4gICAgZm9yIChsZXQgYSBvZiB0aGlzLnZpZXdwb3J0cylcbiAgICAgIGEuZG9tVG9wID0gbyArIChhLnRvcCAtIHMpICogdGhpcy5zY2FsZSwgbyA9IGEuZG9tQm90dG9tID0gYS5kb21Ub3AgKyAoYS5ib3R0b20gLSBhLnRvcCksIHMgPSBhLmJvdHRvbTtcbiAgfVxuICB0b0RPTShlKSB7XG4gICAgZm9yIChsZXQgbiA9IDAsIHIgPSAwLCBpID0gMDsgOyBuKyspIHtcbiAgICAgIGxldCBzID0gbiA8IHRoaXMudmlld3BvcnRzLmxlbmd0aCA/IHRoaXMudmlld3BvcnRzW25dIDogbnVsbDtcbiAgICAgIGlmICghcyB8fCBlIDwgcy50b3ApXG4gICAgICAgIHJldHVybiBpICsgKGUgLSByKSAqIHRoaXMuc2NhbGU7XG4gICAgICBpZiAoZSA8PSBzLmJvdHRvbSlcbiAgICAgICAgcmV0dXJuIHMuZG9tVG9wICsgKGUgLSBzLnRvcCk7XG4gICAgICByID0gcy5ib3R0b20sIGkgPSBzLmRvbUJvdHRvbTtcbiAgICB9XG4gIH1cbiAgZnJvbURPTShlKSB7XG4gICAgZm9yIChsZXQgbiA9IDAsIHIgPSAwLCBpID0gMDsgOyBuKyspIHtcbiAgICAgIGxldCBzID0gbiA8IHRoaXMudmlld3BvcnRzLmxlbmd0aCA/IHRoaXMudmlld3BvcnRzW25dIDogbnVsbDtcbiAgICAgIGlmICghcyB8fCBlIDwgcy5kb21Ub3ApXG4gICAgICAgIHJldHVybiByICsgKGUgLSBpKSAvIHRoaXMuc2NhbGU7XG4gICAgICBpZiAoZSA8PSBzLmRvbUJvdHRvbSlcbiAgICAgICAgcmV0dXJuIHMudG9wICsgKGUgLSBzLmRvbVRvcCk7XG4gICAgICByID0gcy5ib3R0b20sIGkgPSBzLmRvbUJvdHRvbTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIERhKHQsIGUpIHtcbiAgaWYgKGUuc2NhbGUgPT0gMSlcbiAgICByZXR1cm4gdDtcbiAgbGV0IG4gPSBlLnRvRE9NKHQudG9wKSwgciA9IGUudG9ET00odC5ib3R0b20pO1xuICByZXR1cm4gbmV3IENyKHQuZnJvbSwgdC5sZW5ndGgsIG4sIHIgLSBuLCBBcnJheS5pc0FycmF5KHQuX2NvbnRlbnQpID8gdC5fY29udGVudC5tYXAoKGkpID0+IERhKGksIGUpKSA6IHQuX2NvbnRlbnQpO1xufVxuY29uc3QgQWMgPSAvKiBAX19QVVJFX18gKi8gdmUuZGVmaW5lKHsgY29tYmluZTogKHQpID0+IHQuam9pbihcIiBcIikgfSksIE9wID0gLyogQF9fUFVSRV9fICovIHZlLmRlZmluZSh7IGNvbWJpbmU6ICh0KSA9PiB0LmluZGV4T2YoITApID4gLTEgfSksIGdwID0gLyogQF9fUFVSRV9fICovIHNzLm5ld05hbWUoKSwgWGsgPSAvKiBAX19QVVJFX18gKi8gc3MubmV3TmFtZSgpLCBqayA9IC8qIEBfX1BVUkVfXyAqLyBzcy5uZXdOYW1lKCksIEJrID0geyBcIiZsaWdodFwiOiBcIi5cIiArIFhrLCBcIiZkYXJrXCI6IFwiLlwiICsgamsgfTtcbmZ1bmN0aW9uIG1wKHQsIGUsIG4pIHtcbiAgcmV0dXJuIG5ldyBzcyhlLCB7XG4gICAgZmluaXNoKHIpIHtcbiAgICAgIHJldHVybiAvJi8udGVzdChyKSA/IHIucmVwbGFjZSgvJlxcdyovLCAoaSkgPT4ge1xuICAgICAgICBpZiAoaSA9PSBcIiZcIilcbiAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgaWYgKCFuIHx8ICFuW2ldKVxuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBVbnN1cHBvcnRlZCBzZWxlY3RvcjogJHtpfWApO1xuICAgICAgICByZXR1cm4gbltpXTtcbiAgICAgIH0pIDogdCArIFwiIFwiICsgcjtcbiAgICB9XG4gIH0pO1xufVxuY29uc3QgQTUgPSAvKiBAX19QVVJFX18gKi8gbXAoXCIuXCIgKyBncCwge1xuICBcIiZcIjoge1xuICAgIHBvc2l0aW9uOiBcInJlbGF0aXZlICFpbXBvcnRhbnRcIixcbiAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICAgIFwiJi5jbS1mb2N1c2VkXCI6IHtcbiAgICAgIC8vIFByb3ZpZGUgYSBzaW1wbGUgZGVmYXVsdCBvdXRsaW5lIHRvIG1ha2Ugc3VyZSBhIGZvY3VzZWRcbiAgICAgIC8vIGVkaXRvciBpcyB2aXN1YWxseSBkaXN0aW5jdC4gQ2FuJ3QgbGVhdmUgdGhlIGRlZmF1bHQgYmVoYXZpb3JcbiAgICAgIC8vIGJlY2F1c2UgdGhhdCB3aWxsIGFwcGx5IHRvIHRoZSBjb250ZW50IGVsZW1lbnQsIHdoaWNoIGlzXG4gICAgICAvLyBpbnNpZGUgdGhlIHNjcm9sbGFibGUgY29udGFpbmVyIGFuZCBkb2Vzbid0IGluY2x1ZGUgdGhlXG4gICAgICAvLyBndXR0ZXJzLiBXZSBhbHNvIGNhbid0IHVzZSBhbiAnYXV0bycgb3V0bGluZSwgc2luY2UgdGhvc2VcbiAgICAgIC8vIGFyZSwgZm9yIHNvbWUgcmVhc29uLCBkcmF3biBiZWhpbmQgdGhlIGVsZW1lbnQgY29udGVudCwgd2hpY2hcbiAgICAgIC8vIHdpbGwgY2F1c2UgdGhpbmdzIGxpa2UgdGhlIGFjdGl2ZSBsaW5lIGJhY2tncm91bmQgdG8gY292ZXJcbiAgICAgIC8vIHRoZSBvdXRsaW5lICgjMjk3KS5cbiAgICAgIG91dGxpbmU6IFwiMXB4IGRvdHRlZCAjMjEyMTIxXCJcbiAgICB9LFxuICAgIGRpc3BsYXk6IFwiZmxleCAhaW1wb3J0YW50XCIsXG4gICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIlxuICB9LFxuICBcIi5jbS1zY3JvbGxlclwiOiB7XG4gICAgZGlzcGxheTogXCJmbGV4ICFpbXBvcnRhbnRcIixcbiAgICBhbGlnbkl0ZW1zOiBcImZsZXgtc3RhcnQgIWltcG9ydGFudFwiLFxuICAgIGZvbnRGYW1pbHk6IFwibW9ub3NwYWNlXCIsXG4gICAgbGluZUhlaWdodDogMS40LFxuICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgb3ZlcmZsb3dYOiBcImF1dG9cIixcbiAgICBwb3NpdGlvbjogXCJyZWxhdGl2ZVwiLFxuICAgIHpJbmRleDogMFxuICB9LFxuICBcIi5jbS1jb250ZW50XCI6IHtcbiAgICBtYXJnaW46IDAsXG4gICAgZmxleEdyb3c6IDIsXG4gICAgZmxleFNocmluazogMCxcbiAgICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gICAgd2hpdGVTcGFjZTogXCJwcmVcIixcbiAgICB3b3JkV3JhcDogXCJub3JtYWxcIixcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY29kZW1pcnJvci9kZXYvaXNzdWVzLzQ1NlxuICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCIsXG4gICAgbWluSGVpZ2h0OiBcIjEwMCVcIixcbiAgICBwYWRkaW5nOiBcIjRweCAwXCIsXG4gICAgb3V0bGluZTogXCJub25lXCIsXG4gICAgXCImW2NvbnRlbnRlZGl0YWJsZT10cnVlXVwiOiB7XG4gICAgICBXZWJraXRVc2VyTW9kaWZ5OiBcInJlYWQtd3JpdGUtcGxhaW50ZXh0LW9ubHlcIlxuICAgIH1cbiAgfSxcbiAgXCIuY20tbGluZVdyYXBwaW5nXCI6IHtcbiAgICB3aGl0ZVNwYWNlX2ZhbGxiYWNrOiBcInByZS13cmFwXCIsXG4gICAgLy8gRm9yIElFXG4gICAgd2hpdGVTcGFjZTogXCJicmVhay1zcGFjZXNcIixcbiAgICB3b3JkQnJlYWs6IFwiYnJlYWstd29yZFwiLFxuICAgIC8vIEZvciBTYWZhcmksIHdoaWNoIGRvZXNuJ3Qgc3VwcG9ydCBvdmVyZmxvdy13cmFwOiBhbnl3aGVyZVxuICAgIG92ZXJmbG93V3JhcDogXCJhbnl3aGVyZVwiLFxuICAgIGZsZXhTaHJpbms6IDFcbiAgfSxcbiAgXCImbGlnaHQgLmNtLWNvbnRlbnRcIjogeyBjYXJldENvbG9yOiBcImJsYWNrXCIgfSxcbiAgXCImZGFyayAuY20tY29udGVudFwiOiB7IGNhcmV0Q29sb3I6IFwid2hpdGVcIiB9LFxuICBcIi5jbS1saW5lXCI6IHtcbiAgICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gICAgcGFkZGluZzogXCIwIDJweCAwIDZweFwiXG4gIH0sXG4gIFwiLmNtLWxheWVyXCI6IHtcbiAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgIGxlZnQ6IDAsXG4gICAgdG9wOiAwLFxuICAgIGNvbnRhaW46IFwic2l6ZSBzdHlsZVwiLFxuICAgIFwiJiA+ICpcIjoge1xuICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIlxuICAgIH1cbiAgfSxcbiAgXCImbGlnaHQgLmNtLXNlbGVjdGlvbkJhY2tncm91bmRcIjoge1xuICAgIGJhY2tncm91bmQ6IFwiI2Q5ZDlkOVwiXG4gIH0sXG4gIFwiJmRhcmsgLmNtLXNlbGVjdGlvbkJhY2tncm91bmRcIjoge1xuICAgIGJhY2tncm91bmQ6IFwiIzIyMlwiXG4gIH0sXG4gIFwiJmxpZ2h0LmNtLWZvY3VzZWQgPiAuY20tc2Nyb2xsZXIgPiAuY20tc2VsZWN0aW9uTGF5ZXIgLmNtLXNlbGVjdGlvbkJhY2tncm91bmRcIjoge1xuICAgIGJhY2tncm91bmQ6IFwiI2Q3ZDRmMFwiXG4gIH0sXG4gIFwiJmRhcmsuY20tZm9jdXNlZCA+IC5jbS1zY3JvbGxlciA+IC5jbS1zZWxlY3Rpb25MYXllciAuY20tc2VsZWN0aW9uQmFja2dyb3VuZFwiOiB7XG4gICAgYmFja2dyb3VuZDogXCIjMjMzXCJcbiAgfSxcbiAgXCIuY20tY3Vyc29yTGF5ZXJcIjoge1xuICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiXG4gIH0sXG4gIFwiJi5jbS1mb2N1c2VkID4gLmNtLXNjcm9sbGVyID4gLmNtLWN1cnNvckxheWVyXCI6IHtcbiAgICBhbmltYXRpb246IFwic3RlcHMoMSkgY20tYmxpbmsgMS4ycyBpbmZpbml0ZVwiXG4gIH0sXG4gIC8vIFR3byBhbmltYXRpb25zIGRlZmluZWQgc28gdGhhdCB3ZSBjYW4gc3dpdGNoIGJldHdlZW4gdGhlbSB0b1xuICAvLyByZXN0YXJ0IHRoZSBhbmltYXRpb24gd2l0aG91dCBmb3JjaW5nIGFub3RoZXIgc3R5bGVcbiAgLy8gcmVjb21wdXRhdGlvbi5cbiAgXCJAa2V5ZnJhbWVzIGNtLWJsaW5rXCI6IHsgXCIwJVwiOiB7fSwgXCI1MCVcIjogeyBvcGFjaXR5OiAwIH0sIFwiMTAwJVwiOiB7fSB9LFxuICBcIkBrZXlmcmFtZXMgY20tYmxpbmsyXCI6IHsgXCIwJVwiOiB7fSwgXCI1MCVcIjogeyBvcGFjaXR5OiAwIH0sIFwiMTAwJVwiOiB7fSB9LFxuICBcIi5jbS1jdXJzb3IsIC5jbS1kcm9wQ3Vyc29yXCI6IHtcbiAgICBib3JkZXJMZWZ0OiBcIjEuMnB4IHNvbGlkIGJsYWNrXCIsXG4gICAgbWFyZ2luTGVmdDogXCItMC42cHhcIixcbiAgICBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIlxuICB9LFxuICBcIi5jbS1jdXJzb3JcIjoge1xuICAgIGRpc3BsYXk6IFwibm9uZVwiXG4gIH0sXG4gIFwiJmRhcmsgLmNtLWN1cnNvclwiOiB7XG4gICAgYm9yZGVyTGVmdENvbG9yOiBcIiM0NDRcIlxuICB9LFxuICBcIi5jbS1kcm9wQ3Vyc29yXCI6IHtcbiAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiXG4gIH0sXG4gIFwiJi5jbS1mb2N1c2VkID4gLmNtLXNjcm9sbGVyID4gLmNtLWN1cnNvckxheWVyIC5jbS1jdXJzb3JcIjoge1xuICAgIGRpc3BsYXk6IFwiYmxvY2tcIlxuICB9LFxuICBcIi5jbS1pc29cIjoge1xuICAgIHVuaWNvZGVCaWRpOiBcImlzb2xhdGVcIlxuICB9LFxuICBcIi5jbS1hbm5vdW5jZWRcIjoge1xuICAgIHBvc2l0aW9uOiBcImZpeGVkXCIsXG4gICAgdG9wOiBcIi0xMDAwMHB4XCJcbiAgfSxcbiAgXCJAbWVkaWEgcHJpbnRcIjoge1xuICAgIFwiLmNtLWFubm91bmNlZFwiOiB7IGRpc3BsYXk6IFwibm9uZVwiIH1cbiAgfSxcbiAgXCImbGlnaHQgLmNtLWFjdGl2ZUxpbmVcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2NjZWVmZjQ0XCIgfSxcbiAgXCImZGFyayAuY20tYWN0aXZlTGluZVwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjOTllZWZmMzNcIiB9LFxuICBcIiZsaWdodCAuY20tc3BlY2lhbENoYXJcIjogeyBjb2xvcjogXCJyZWRcIiB9LFxuICBcIiZkYXJrIC5jbS1zcGVjaWFsQ2hhclwiOiB7IGNvbG9yOiBcIiNmNzhcIiB9LFxuICBcIi5jbS1ndXR0ZXJzXCI6IHtcbiAgICBmbGV4U2hyaW5rOiAwLFxuICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICBpbnNldElubGluZVN0YXJ0OiAwLFxuICAgIHpJbmRleDogMjAwXG4gIH0sXG4gIFwiJmxpZ2h0IC5jbS1ndXR0ZXJzXCI6IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2Y1ZjVmNVwiLFxuICAgIGNvbG9yOiBcIiM2YzZjNmNcIixcbiAgICBib3JkZXJSaWdodDogXCIxcHggc29saWQgI2RkZFwiXG4gIH0sXG4gIFwiJmRhcmsgLmNtLWd1dHRlcnNcIjoge1xuICAgIGJhY2tncm91bmRDb2xvcjogXCIjMzMzMzM4XCIsXG4gICAgY29sb3I6IFwiI2NjY1wiXG4gIH0sXG4gIFwiLmNtLWd1dHRlclwiOiB7XG4gICAgZGlzcGxheTogXCJmbGV4ICFpbXBvcnRhbnRcIixcbiAgICAvLyBOZWNlc3NhcnkgLS0gcHJldmVudHMgbWFyZ2luIGNvbGxhcHNpbmdcbiAgICBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiLFxuICAgIGZsZXhTaHJpbms6IDAsXG4gICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICBtaW5IZWlnaHQ6IFwiMTAwJVwiLFxuICAgIG92ZXJmbG93OiBcImhpZGRlblwiXG4gIH0sXG4gIFwiLmNtLWd1dHRlckVsZW1lbnRcIjoge1xuICAgIGJveFNpemluZzogXCJib3JkZXItYm94XCJcbiAgfSxcbiAgXCIuY20tbGluZU51bWJlcnMgLmNtLWd1dHRlckVsZW1lbnRcIjoge1xuICAgIHBhZGRpbmc6IFwiMCAzcHggMCA1cHhcIixcbiAgICBtaW5XaWR0aDogXCIyMHB4XCIsXG4gICAgdGV4dEFsaWduOiBcInJpZ2h0XCIsXG4gICAgd2hpdGVTcGFjZTogXCJub3dyYXBcIlxuICB9LFxuICBcIiZsaWdodCAuY20tYWN0aXZlTGluZUd1dHRlclwiOiB7XG4gICAgYmFja2dyb3VuZENvbG9yOiBcIiNlMmYyZmZcIlxuICB9LFxuICBcIiZkYXJrIC5jbS1hY3RpdmVMaW5lR3V0dGVyXCI6IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiIzIyMjIyN1wiXG4gIH0sXG4gIFwiLmNtLXBhbmVsc1wiOiB7XG4gICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIixcbiAgICBwb3NpdGlvbjogXCJzdGlja3lcIixcbiAgICBsZWZ0OiAwLFxuICAgIHJpZ2h0OiAwXG4gIH0sXG4gIFwiJmxpZ2h0IC5jbS1wYW5lbHNcIjoge1xuICAgIGJhY2tncm91bmRDb2xvcjogXCIjZjVmNWY1XCIsXG4gICAgY29sb3I6IFwiYmxhY2tcIlxuICB9LFxuICBcIiZsaWdodCAuY20tcGFuZWxzLXRvcFwiOiB7XG4gICAgYm9yZGVyQm90dG9tOiBcIjFweCBzb2xpZCAjZGRkXCJcbiAgfSxcbiAgXCImbGlnaHQgLmNtLXBhbmVscy1ib3R0b21cIjoge1xuICAgIGJvcmRlclRvcDogXCIxcHggc29saWQgI2RkZFwiXG4gIH0sXG4gIFwiJmRhcmsgLmNtLXBhbmVsc1wiOiB7XG4gICAgYmFja2dyb3VuZENvbG9yOiBcIiMzMzMzMzhcIixcbiAgICBjb2xvcjogXCJ3aGl0ZVwiXG4gIH0sXG4gIFwiLmNtLXRhYlwiOiB7XG4gICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIixcbiAgICBvdmVyZmxvdzogXCJoaWRkZW5cIixcbiAgICB2ZXJ0aWNhbEFsaWduOiBcImJvdHRvbVwiXG4gIH0sXG4gIFwiLmNtLXdpZGdldEJ1ZmZlclwiOiB7XG4gICAgdmVydGljYWxBbGlnbjogXCJ0ZXh0LXRvcFwiLFxuICAgIGhlaWdodDogXCIxZW1cIixcbiAgICB3aWR0aDogMCxcbiAgICBkaXNwbGF5OiBcImlubGluZVwiXG4gIH0sXG4gIFwiLmNtLXBsYWNlaG9sZGVyXCI6IHtcbiAgICBjb2xvcjogXCIjODg4XCIsXG4gICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIixcbiAgICB2ZXJ0aWNhbEFsaWduOiBcInRvcFwiXG4gIH0sXG4gIFwiLmNtLWhpZ2hsaWdodFNwYWNlOmJlZm9yZVwiOiB7XG4gICAgY29udGVudDogXCJhdHRyKGRhdGEtZGlzcGxheSlcIixcbiAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgIHBvaW50ZXJFdmVudHM6IFwibm9uZVwiLFxuICAgIGNvbG9yOiBcIiM4ODhcIlxuICB9LFxuICBcIi5jbS1oaWdobGlnaHRUYWJcIjoge1xuICAgIGJhY2tncm91bmRJbWFnZTogYHVybCgnZGF0YTppbWFnZS9zdmcreG1sLDxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMjAwXCIgaGVpZ2h0PVwiMjBcIj48cGF0aCBzdHJva2U9XCIlMjM4ODhcIiBzdHJva2Utd2lkdGg9XCIxXCIgZmlsbD1cIm5vbmVcIiBkPVwiTTEgMTBIMTk2TDE5MCA1TTE5MCAxNUwxOTYgMTBNMTk3IDRMMTk3IDE2XCIvPjwvc3ZnPicpYCxcbiAgICBiYWNrZ3JvdW5kU2l6ZTogXCJhdXRvIDEwMCVcIixcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb246IFwicmlnaHQgOTAlXCIsXG4gICAgYmFja2dyb3VuZFJlcGVhdDogXCJuby1yZXBlYXRcIlxuICB9LFxuICBcIi5jbS10cmFpbGluZ1NwYWNlXCI6IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmMzMyMjU1XCJcbiAgfSxcbiAgXCIuY20tYnV0dG9uXCI6IHtcbiAgICB2ZXJ0aWNhbEFsaWduOiBcIm1pZGRsZVwiLFxuICAgIGNvbG9yOiBcImluaGVyaXRcIixcbiAgICBmb250U2l6ZTogXCI3MCVcIixcbiAgICBwYWRkaW5nOiBcIi4yZW0gMWVtXCIsXG4gICAgYm9yZGVyUmFkaXVzOiBcIjFweFwiXG4gIH0sXG4gIFwiJmxpZ2h0IC5jbS1idXR0b25cIjoge1xuICAgIGJhY2tncm91bmRJbWFnZTogXCJsaW5lYXItZ3JhZGllbnQoI2VmZjFmNSwgI2Q5ZDlkZilcIixcbiAgICBib3JkZXI6IFwiMXB4IHNvbGlkICM4ODhcIixcbiAgICBcIiY6YWN0aXZlXCI6IHtcbiAgICAgIGJhY2tncm91bmRJbWFnZTogXCJsaW5lYXItZ3JhZGllbnQoI2I0YjRiNCwgI2QwZDNkNilcIlxuICAgIH1cbiAgfSxcbiAgXCImZGFyayAuY20tYnV0dG9uXCI6IHtcbiAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwibGluZWFyLWdyYWRpZW50KCMzOTM5MzksICMxMTEpXCIsXG4gICAgYm9yZGVyOiBcIjFweCBzb2xpZCAjODg4XCIsXG4gICAgXCImOmFjdGl2ZVwiOiB7XG4gICAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwibGluZWFyLWdyYWRpZW50KCMxMTEsICMzMzMpXCJcbiAgICB9XG4gIH0sXG4gIFwiLmNtLXRleHRmaWVsZFwiOiB7XG4gICAgdmVydGljYWxBbGlnbjogXCJtaWRkbGVcIixcbiAgICBjb2xvcjogXCJpbmhlcml0XCIsXG4gICAgZm9udFNpemU6IFwiNzAlXCIsXG4gICAgYm9yZGVyOiBcIjFweCBzb2xpZCBzaWx2ZXJcIixcbiAgICBwYWRkaW5nOiBcIi4yZW0gLjVlbVwiXG4gIH0sXG4gIFwiJmxpZ2h0IC5jbS10ZXh0ZmllbGRcIjoge1xuICAgIGJhY2tncm91bmRDb2xvcjogXCJ3aGl0ZVwiXG4gIH0sXG4gIFwiJmRhcmsgLmNtLXRleHRmaWVsZFwiOiB7XG4gICAgYm9yZGVyOiBcIjFweCBzb2xpZCAjNTU1XCIsXG4gICAgYmFja2dyb3VuZENvbG9yOiBcImluaGVyaXRcIlxuICB9XG59LCBCayksIFphID0gXCLvv79cIjtcbmNsYXNzIFI1IHtcbiAgY29uc3RydWN0b3IoZSwgbikge1xuICAgIHRoaXMucG9pbnRzID0gZSwgdGhpcy50ZXh0ID0gXCJcIiwgdGhpcy5saW5lU2VwYXJhdG9yID0gbi5mYWNldChZZS5saW5lU2VwYXJhdG9yKTtcbiAgfVxuICBhcHBlbmQoZSkge1xuICAgIHRoaXMudGV4dCArPSBlO1xuICB9XG4gIGxpbmVCcmVhaygpIHtcbiAgICB0aGlzLnRleHQgKz0gWmE7XG4gIH1cbiAgcmVhZFJhbmdlKGUsIG4pIHtcbiAgICBpZiAoIWUpXG4gICAgICByZXR1cm4gdGhpcztcbiAgICBsZXQgciA9IGUucGFyZW50Tm9kZTtcbiAgICBmb3IgKGxldCBpID0gZTsgOyApIHtcbiAgICAgIHRoaXMuZmluZFBvaW50QmVmb3JlKHIsIGkpO1xuICAgICAgbGV0IHMgPSB0aGlzLnRleHQubGVuZ3RoO1xuICAgICAgdGhpcy5yZWFkTm9kZShpKTtcbiAgICAgIGxldCBvID0gaS5uZXh0U2libGluZztcbiAgICAgIGlmIChvID09IG4pXG4gICAgICAgIGJyZWFrO1xuICAgICAgbGV0IGEgPSBmdC5nZXQoaSksIGwgPSBmdC5nZXQobyk7XG4gICAgICAoYSAmJiBsID8gYS5icmVha0FmdGVyIDogKGEgPyBhLmJyZWFrQWZ0ZXIgOiB2dihpKSkgfHwgdnYobykgJiYgKGkubm9kZU5hbWUgIT0gXCJCUlwiIHx8IGkuY21JZ25vcmUpICYmIHRoaXMudGV4dC5sZW5ndGggPiBzKSAmJiB0aGlzLmxpbmVCcmVhaygpLCBpID0gbztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZmluZFBvaW50QmVmb3JlKHIsIG4pLCB0aGlzO1xuICB9XG4gIHJlYWRUZXh0Tm9kZShlKSB7XG4gICAgbGV0IG4gPSBlLm5vZGVWYWx1ZTtcbiAgICBmb3IgKGxldCByIG9mIHRoaXMucG9pbnRzKVxuICAgICAgci5ub2RlID09IGUgJiYgKHIucG9zID0gdGhpcy50ZXh0Lmxlbmd0aCArIE1hdGgubWluKHIub2Zmc2V0LCBuLmxlbmd0aCkpO1xuICAgIGZvciAobGV0IHIgPSAwLCBpID0gdGhpcy5saW5lU2VwYXJhdG9yID8gbnVsbCA6IC9cXHJcXG4/fFxcbi9nOyA7ICkge1xuICAgICAgbGV0IHMgPSAtMSwgbyA9IDEsIGE7XG4gICAgICBpZiAodGhpcy5saW5lU2VwYXJhdG9yID8gKHMgPSBuLmluZGV4T2YodGhpcy5saW5lU2VwYXJhdG9yLCByKSwgbyA9IHRoaXMubGluZVNlcGFyYXRvci5sZW5ndGgpIDogKGEgPSBpLmV4ZWMobikpICYmIChzID0gYS5pbmRleCwgbyA9IGFbMF0ubGVuZ3RoKSwgdGhpcy5hcHBlbmQobi5zbGljZShyLCBzIDwgMCA/IG4ubGVuZ3RoIDogcykpLCBzIDwgMClcbiAgICAgICAgYnJlYWs7XG4gICAgICBpZiAodGhpcy5saW5lQnJlYWsoKSwgbyA+IDEpXG4gICAgICAgIGZvciAobGV0IGwgb2YgdGhpcy5wb2ludHMpXG4gICAgICAgICAgbC5ub2RlID09IGUgJiYgbC5wb3MgPiB0aGlzLnRleHQubGVuZ3RoICYmIChsLnBvcyAtPSBvIC0gMSk7XG4gICAgICByID0gcyArIG87XG4gICAgfVxuICB9XG4gIHJlYWROb2RlKGUpIHtcbiAgICBpZiAoZS5jbUlnbm9yZSlcbiAgICAgIHJldHVybjtcbiAgICBsZXQgbiA9IGZ0LmdldChlKSwgciA9IG4gJiYgbi5vdmVycmlkZURPTVRleHQ7XG4gICAgaWYgKHIgIT0gbnVsbCkge1xuICAgICAgdGhpcy5maW5kUG9pbnRJbnNpZGUoZSwgci5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaSA9IHIuaXRlcigpOyAhaS5uZXh0KCkuZG9uZTsgKVxuICAgICAgICBpLmxpbmVCcmVhayA/IHRoaXMubGluZUJyZWFrKCkgOiB0aGlzLmFwcGVuZChpLnZhbHVlKTtcbiAgICB9IGVsc2VcbiAgICAgIGUubm9kZVR5cGUgPT0gMyA/IHRoaXMucmVhZFRleHROb2RlKGUpIDogZS5ub2RlTmFtZSA9PSBcIkJSXCIgPyBlLm5leHRTaWJsaW5nICYmIHRoaXMubGluZUJyZWFrKCkgOiBlLm5vZGVUeXBlID09IDEgJiYgdGhpcy5yZWFkUmFuZ2UoZS5maXJzdENoaWxkLCBudWxsKTtcbiAgfVxuICBmaW5kUG9pbnRCZWZvcmUoZSwgbikge1xuICAgIGZvciAobGV0IHIgb2YgdGhpcy5wb2ludHMpXG4gICAgICByLm5vZGUgPT0gZSAmJiBlLmNoaWxkTm9kZXNbci5vZmZzZXRdID09IG4gJiYgKHIucG9zID0gdGhpcy50ZXh0Lmxlbmd0aCk7XG4gIH1cbiAgZmluZFBvaW50SW5zaWRlKGUsIG4pIHtcbiAgICBmb3IgKGxldCByIG9mIHRoaXMucG9pbnRzKVxuICAgICAgKGUubm9kZVR5cGUgPT0gMyA/IHIubm9kZSA9PSBlIDogZS5jb250YWlucyhyLm5vZGUpKSAmJiAoci5wb3MgPSB0aGlzLnRleHQubGVuZ3RoICsgKE41KGUsIHIubm9kZSwgci5vZmZzZXQpID8gbiA6IDApKTtcbiAgfVxufVxuZnVuY3Rpb24gTjUodCwgZSwgbikge1xuICBmb3IgKDsgOyApIHtcbiAgICBpZiAoIWUgfHwgbiA8IGZpKGUpKVxuICAgICAgcmV0dXJuICExO1xuICAgIGlmIChlID09IHQpXG4gICAgICByZXR1cm4gITA7XG4gICAgbiA9IGdsKGUpICsgMSwgZSA9IGUucGFyZW50Tm9kZTtcbiAgfVxufVxuZnVuY3Rpb24gdnYodCkge1xuICByZXR1cm4gdC5ub2RlVHlwZSA9PSAxICYmIC9eKERJVnxQfExJfFVMfE9MfEJMT0NLUVVPVEV8RER8RFR8SFxcZHxTRUNUSU9OfFBSRSkkLy50ZXN0KHQubm9kZU5hbWUpO1xufVxuY2xhc3MgeXYge1xuICBjb25zdHJ1Y3RvcihlLCBuKSB7XG4gICAgdGhpcy5ub2RlID0gZSwgdGhpcy5vZmZzZXQgPSBuLCB0aGlzLnBvcyA9IC0xO1xuICB9XG59XG5jbGFzcyBENSB7XG4gIGNvbnN0cnVjdG9yKGUsIG4sIHIsIGkpIHtcbiAgICB0aGlzLnR5cGVPdmVyID0gaSwgdGhpcy5ib3VuZHMgPSBudWxsLCB0aGlzLnRleHQgPSBcIlwiO1xuICAgIGxldCB7IGltcHJlY2lzZUhlYWQ6IHMsIGltcHJlY2lzZUFuY2hvcjogbyB9ID0gZS5kb2NWaWV3O1xuICAgIGlmIChlLnN0YXRlLnJlYWRPbmx5ICYmIG4gPiAtMSlcbiAgICAgIHRoaXMubmV3U2VsID0gbnVsbDtcbiAgICBlbHNlIGlmIChuID4gLTEgJiYgKHRoaXMuYm91bmRzID0gZS5kb2NWaWV3LmRvbUJvdW5kc0Fyb3VuZChuLCByLCAwKSkpIHtcbiAgICAgIGxldCBhID0gcyB8fCBvID8gW10gOiBJNShlKSwgbCA9IG5ldyBSNShhLCBlLnN0YXRlKTtcbiAgICAgIGwucmVhZFJhbmdlKHRoaXMuYm91bmRzLnN0YXJ0RE9NLCB0aGlzLmJvdW5kcy5lbmRET00pLCB0aGlzLnRleHQgPSBsLnRleHQsIHRoaXMubmV3U2VsID0gVzUoYSwgdGhpcy5ib3VuZHMuZnJvbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBhID0gZS5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZSwgbCA9IHMgJiYgcy5ub2RlID09IGEuZm9jdXNOb2RlICYmIHMub2Zmc2V0ID09IGEuZm9jdXNPZmZzZXQgfHwgIW5wKGUuY29udGVudERPTSwgYS5mb2N1c05vZGUpID8gZS5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkIDogZS5kb2NWaWV3LnBvc0Zyb21ET00oYS5mb2N1c05vZGUsIGEuZm9jdXNPZmZzZXQpLCBjID0gbyAmJiBvLm5vZGUgPT0gYS5hbmNob3JOb2RlICYmIG8ub2Zmc2V0ID09IGEuYW5jaG9yT2Zmc2V0IHx8ICFucChlLmNvbnRlbnRET00sIGEuYW5jaG9yTm9kZSkgPyBlLnN0YXRlLnNlbGVjdGlvbi5tYWluLmFuY2hvciA6IGUuZG9jVmlldy5wb3NGcm9tRE9NKGEuYW5jaG9yTm9kZSwgYS5hbmNob3JPZmZzZXQpLCB1ID0gZS52aWV3cG9ydDtcbiAgICAgIGlmICgoZGUuaW9zIHx8IGRlLmNocm9tZSkgJiYgZS5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5lbXB0eSAmJiBsICE9IGMgJiYgKHUuZnJvbSA+IDAgfHwgdS50byA8IGUuc3RhdGUuZG9jLmxlbmd0aCkpIHtcbiAgICAgICAgbGV0IGQgPSBNYXRoLm1pbihsLCBjKSwgZiA9IE1hdGgubWF4KGwsIGMpLCBoID0gdS5mcm9tIC0gZCwgcCA9IHUudG8gLSBmO1xuICAgICAgICAoaCA9PSAwIHx8IGggPT0gMSB8fCBkID09IDApICYmIChwID09IDAgfHwgcCA9PSAtMSB8fCBmID09IGUuc3RhdGUuZG9jLmxlbmd0aCkgJiYgKGwgPSAwLCBjID0gZS5zdGF0ZS5kb2MubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubmV3U2VsID0gYWUuc2luZ2xlKGMsIGwpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gTGsodCwgZSkge1xuICBsZXQgbiwgeyBuZXdTZWw6IHIgfSA9IGUsIGkgPSB0LnN0YXRlLnNlbGVjdGlvbi5tYWluLCBzID0gdC5pbnB1dFN0YXRlLmxhc3RLZXlUaW1lID4gRGF0ZS5ub3coKSAtIDEwMCA/IHQuaW5wdXRTdGF0ZS5sYXN0S2V5Q29kZSA6IC0xO1xuICBpZiAoZS5ib3VuZHMpIHtcbiAgICBsZXQgeyBmcm9tOiBvLCB0bzogYSB9ID0gZS5ib3VuZHMsIGwgPSBpLmZyb20sIGMgPSBudWxsO1xuICAgIChzID09PSA4IHx8IGRlLmFuZHJvaWQgJiYgZS50ZXh0Lmxlbmd0aCA8IGEgLSBvKSAmJiAobCA9IGkudG8sIGMgPSBcImVuZFwiKTtcbiAgICBsZXQgdSA9IFY1KHQuc3RhdGUuZG9jLnNsaWNlU3RyaW5nKG8sIGEsIFphKSwgZS50ZXh0LCBsIC0gbywgYyk7XG4gICAgdSAmJiAoZGUuY2hyb21lICYmIHMgPT0gMTMgJiYgdS50b0IgPT0gdS5mcm9tICsgMiAmJiBlLnRleHQuc2xpY2UodS5mcm9tLCB1LnRvQikgPT0gWmEgKyBaYSAmJiB1LnRvQi0tLCBuID0ge1xuICAgICAgZnJvbTogbyArIHUuZnJvbSxcbiAgICAgIHRvOiBvICsgdS50b0EsXG4gICAgICBpbnNlcnQ6IEZlLm9mKGUudGV4dC5zbGljZSh1LmZyb20sIHUudG9CKS5zcGxpdChaYSkpXG4gICAgfSk7XG4gIH0gZWxzZVxuICAgIHIgJiYgKCF0Lmhhc0ZvY3VzICYmIHQuc3RhdGUuZmFjZXQoWWQpIHx8IHIubWFpbi5lcShpKSkgJiYgKHIgPSBudWxsKTtcbiAgaWYgKCFuICYmICFyKVxuICAgIHJldHVybiAhMTtcbiAgaWYgKCFuICYmIGUudHlwZU92ZXIgJiYgIWkuZW1wdHkgJiYgciAmJiByLm1haW4uZW1wdHkgPyBuID0geyBmcm9tOiBpLmZyb20sIHRvOiBpLnRvLCBpbnNlcnQ6IHQuc3RhdGUuZG9jLnNsaWNlKGkuZnJvbSwgaS50bykgfSA6IG4gJiYgbi5mcm9tID49IGkuZnJvbSAmJiBuLnRvIDw9IGkudG8gJiYgKG4uZnJvbSAhPSBpLmZyb20gfHwgbi50byAhPSBpLnRvKSAmJiBpLnRvIC0gaS5mcm9tIC0gKG4udG8gLSBuLmZyb20pIDw9IDQgPyBuID0ge1xuICAgIGZyb206IGkuZnJvbSxcbiAgICB0bzogaS50byxcbiAgICBpbnNlcnQ6IHQuc3RhdGUuZG9jLnNsaWNlKGkuZnJvbSwgbi5mcm9tKS5hcHBlbmQobi5pbnNlcnQpLmFwcGVuZCh0LnN0YXRlLmRvYy5zbGljZShuLnRvLCBpLnRvKSlcbiAgfSA6IChkZS5tYWMgfHwgZGUuYW5kcm9pZCkgJiYgbiAmJiBuLmZyb20gPT0gbi50byAmJiBuLmZyb20gPT0gaS5oZWFkIC0gMSAmJiAvXlxcLiA/JC8udGVzdChuLmluc2VydC50b1N0cmluZygpKSAmJiB0LmNvbnRlbnRET00uZ2V0QXR0cmlidXRlKFwiYXV0b2NvcnJlY3RcIikgPT0gXCJvZmZcIiA/IChyICYmIG4uaW5zZXJ0Lmxlbmd0aCA9PSAyICYmIChyID0gYWUuc2luZ2xlKHIubWFpbi5hbmNob3IgLSAxLCByLm1haW4uaGVhZCAtIDEpKSwgbiA9IHsgZnJvbTogaS5mcm9tLCB0bzogaS50bywgaW5zZXJ0OiBGZS5vZihbXCIgXCJdKSB9KSA6IGRlLmNocm9tZSAmJiBuICYmIG4uZnJvbSA9PSBuLnRvICYmIG4uZnJvbSA9PSBpLmhlYWQgJiYgbi5pbnNlcnQudG9TdHJpbmcoKSA9PSBgXG4gYCAmJiB0LmxpbmVXcmFwcGluZyAmJiAociAmJiAociA9IGFlLnNpbmdsZShyLm1haW4uYW5jaG9yIC0gMSwgci5tYWluLmhlYWQgLSAxKSksIG4gPSB7IGZyb206IGkuZnJvbSwgdG86IGkudG8sIGluc2VydDogRmUub2YoW1wiIFwiXSkgfSksIG4pIHtcbiAgICBpZiAoZGUuaW9zICYmIHQuaW5wdXRTdGF0ZS5mbHVzaElPU0tleSgpIHx8IGRlLmFuZHJvaWQgJiYgKG4uZnJvbSA9PSBpLmZyb20gJiYgbi50byA9PSBpLnRvICYmIG4uaW5zZXJ0Lmxlbmd0aCA9PSAxICYmIG4uaW5zZXJ0LmxpbmVzID09IDIgJiYgVG8odC5jb250ZW50RE9NLCBcIkVudGVyXCIsIDEzKSB8fCAobi5mcm9tID09IGkuZnJvbSAtIDEgJiYgbi50byA9PSBpLnRvICYmIG4uaW5zZXJ0Lmxlbmd0aCA9PSAwIHx8IHMgPT0gOCAmJiBuLmluc2VydC5sZW5ndGggPCBuLnRvIC0gbi5mcm9tICYmIG4udG8gPiBpLmhlYWQpICYmIFRvKHQuY29udGVudERPTSwgXCJCYWNrc3BhY2VcIiwgOCkgfHwgbi5mcm9tID09IGkuZnJvbSAmJiBuLnRvID09IGkudG8gKyAxICYmIG4uaW5zZXJ0Lmxlbmd0aCA9PSAwICYmIFRvKHQuY29udGVudERPTSwgXCJEZWxldGVcIiwgNDYpKSlcbiAgICAgIHJldHVybiAhMDtcbiAgICBsZXQgbyA9IG4uaW5zZXJ0LnRvU3RyaW5nKCk7XG4gICAgdC5pbnB1dFN0YXRlLmNvbXBvc2luZyA+PSAwICYmIHQuaW5wdXRTdGF0ZS5jb21wb3NpbmcrKztcbiAgICBsZXQgYSwgbCA9ICgpID0+IGEgfHwgKGEgPSBaNSh0LCBuLCByKSk7XG4gICAgcmV0dXJuIHQuc3RhdGUuZmFjZXQoeWspLnNvbWUoKGMpID0+IGModCwgbi5mcm9tLCBuLnRvLCBvLCBsKSkgfHwgdC5kaXNwYXRjaChsKCkpLCAhMDtcbiAgfSBlbHNlIGlmIChyICYmICFyLm1haW4uZXEoaSkpIHtcbiAgICBsZXQgbyA9ICExLCBhID0gXCJzZWxlY3RcIjtcbiAgICByZXR1cm4gdC5pbnB1dFN0YXRlLmxhc3RTZWxlY3Rpb25UaW1lID4gRGF0ZS5ub3coKSAtIDUwICYmICh0LmlucHV0U3RhdGUubGFzdFNlbGVjdGlvbk9yaWdpbiA9PSBcInNlbGVjdFwiICYmIChvID0gITApLCBhID0gdC5pbnB1dFN0YXRlLmxhc3RTZWxlY3Rpb25PcmlnaW4pLCB0LmRpc3BhdGNoKHsgc2VsZWN0aW9uOiByLCBzY3JvbGxJbnRvVmlldzogbywgdXNlckV2ZW50OiBhIH0pLCAhMDtcbiAgfSBlbHNlXG4gICAgcmV0dXJuICExO1xufVxuZnVuY3Rpb24gWjUodCwgZSwgbikge1xuICBsZXQgciwgaSA9IHQuc3RhdGUsIHMgPSBpLnNlbGVjdGlvbi5tYWluO1xuICBpZiAoZS5mcm9tID49IHMuZnJvbSAmJiBlLnRvIDw9IHMudG8gJiYgZS50byAtIGUuZnJvbSA+PSAocy50byAtIHMuZnJvbSkgLyAzICYmICghbiB8fCBuLm1haW4uZW1wdHkgJiYgbi5tYWluLmZyb20gPT0gZS5mcm9tICsgZS5pbnNlcnQubGVuZ3RoKSAmJiB0LmlucHV0U3RhdGUuY29tcG9zaW5nIDwgMCkge1xuICAgIGxldCBhID0gcy5mcm9tIDwgZS5mcm9tID8gaS5zbGljZURvYyhzLmZyb20sIGUuZnJvbSkgOiBcIlwiLCBsID0gcy50byA+IGUudG8gPyBpLnNsaWNlRG9jKGUudG8sIHMudG8pIDogXCJcIjtcbiAgICByID0gaS5yZXBsYWNlU2VsZWN0aW9uKHQuc3RhdGUudG9UZXh0KGEgKyBlLmluc2VydC5zbGljZVN0cmluZygwLCB2b2lkIDAsIHQuc3RhdGUubGluZUJyZWFrKSArIGwpKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgYSA9IGkuY2hhbmdlcyhlKSwgbCA9IG4gJiYgbi5tYWluLnRvIDw9IGEubmV3TGVuZ3RoID8gbi5tYWluIDogdm9pZCAwO1xuICAgIGlmIChpLnNlbGVjdGlvbi5yYW5nZXMubGVuZ3RoID4gMSAmJiB0LmlucHV0U3RhdGUuY29tcG9zaW5nID49IDAgJiYgZS50byA8PSBzLnRvICYmIGUudG8gPj0gcy50byAtIDEwKSB7XG4gICAgICBsZXQgYyA9IHQuc3RhdGUuc2xpY2VEb2MoZS5mcm9tLCBlLnRvKSwgdSwgZCA9IG4gJiYgRWsodCwgbi5tYWluLmhlYWQpO1xuICAgICAgaWYgKGQpIHtcbiAgICAgICAgbGV0IHAgPSBlLmluc2VydC5sZW5ndGggLSAoZS50byAtIGUuZnJvbSk7XG4gICAgICAgIHUgPSB7IGZyb206IGQuZnJvbSwgdG86IGQudG8gLSBwIH07XG4gICAgICB9IGVsc2VcbiAgICAgICAgdSA9IHQuc3RhdGUuZG9jLmxpbmVBdChzLmhlYWQpO1xuICAgICAgbGV0IGYgPSBzLnRvIC0gZS50bywgaCA9IHMudG8gLSBzLmZyb207XG4gICAgICByID0gaS5jaGFuZ2VCeVJhbmdlKChwKSA9PiB7XG4gICAgICAgIGlmIChwLmZyb20gPT0gcy5mcm9tICYmIHAudG8gPT0gcy50bylcbiAgICAgICAgICByZXR1cm4geyBjaGFuZ2VzOiBhLCByYW5nZTogbCB8fCBwLm1hcChhKSB9O1xuICAgICAgICBsZXQgTyA9IHAudG8gLSBmLCBtID0gTyAtIGMubGVuZ3RoO1xuICAgICAgICBpZiAocC50byAtIHAuZnJvbSAhPSBoIHx8IHQuc3RhdGUuc2xpY2VEb2MobSwgTykgIT0gYyB8fCAvLyBVbmZvcnR1bmF0ZWx5LCB0aGVyZSdzIG5vIHdheSB0byBtYWtlIG11bHRpcGxlXG4gICAgICAgIC8vIGNoYW5nZXMgaW4gdGhlIHNhbWUgbm9kZSB3b3JrIHdpdGhvdXQgYWJvcnRpbmdcbiAgICAgICAgLy8gY29tcG9zaXRpb24sIHNvIGN1cnNvcnMgaW4gdGhlIGNvbXBvc2l0aW9uIHJhbmdlIGFyZVxuICAgICAgICAvLyBpZ25vcmVkLlxuICAgICAgICBwLnRvID49IHUuZnJvbSAmJiBwLmZyb20gPD0gdS50bylcbiAgICAgICAgICByZXR1cm4geyByYW5nZTogcCB9O1xuICAgICAgICBsZXQgeSA9IGkuY2hhbmdlcyh7IGZyb206IG0sIHRvOiBPLCBpbnNlcnQ6IGUuaW5zZXJ0IH0pLCBiID0gcC50byAtIHMudG87XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2hhbmdlczogeSxcbiAgICAgICAgICByYW5nZTogbCA/IGFlLnJhbmdlKE1hdGgubWF4KDAsIGwuYW5jaG9yICsgYiksIE1hdGgubWF4KDAsIGwuaGVhZCArIGIpKSA6IHAubWFwKHkpXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9IGVsc2VcbiAgICAgIHIgPSB7XG4gICAgICAgIGNoYW5nZXM6IGEsXG4gICAgICAgIHNlbGVjdGlvbjogbCAmJiBpLnNlbGVjdGlvbi5yZXBsYWNlUmFuZ2UobClcbiAgICAgIH07XG4gIH1cbiAgbGV0IG8gPSBcImlucHV0LnR5cGVcIjtcbiAgcmV0dXJuICh0LmNvbXBvc2luZyB8fCB0LmlucHV0U3RhdGUuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlICYmIHQuaW5wdXRTdGF0ZS5jb21wb3NpdGlvbkVuZGVkQXQgPiBEYXRlLm5vdygpIC0gNTApICYmICh0LmlucHV0U3RhdGUuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlID0gITEsIG8gKz0gXCIuY29tcG9zZVwiLCB0LmlucHV0U3RhdGUuY29tcG9zaXRpb25GaXJzdENoYW5nZSAmJiAobyArPSBcIi5zdGFydFwiLCB0LmlucHV0U3RhdGUuY29tcG9zaXRpb25GaXJzdENoYW5nZSA9ICExKSksIGkudXBkYXRlKHIsIHsgdXNlckV2ZW50OiBvLCBzY3JvbGxJbnRvVmlldzogITAgfSk7XG59XG5mdW5jdGlvbiBWNSh0LCBlLCBuLCByKSB7XG4gIGxldCBpID0gTWF0aC5taW4odC5sZW5ndGgsIGUubGVuZ3RoKSwgcyA9IDA7XG4gIGZvciAoOyBzIDwgaSAmJiB0LmNoYXJDb2RlQXQocykgPT0gZS5jaGFyQ29kZUF0KHMpOyApXG4gICAgcysrO1xuICBpZiAocyA9PSBpICYmIHQubGVuZ3RoID09IGUubGVuZ3RoKVxuICAgIHJldHVybiBudWxsO1xuICBsZXQgbyA9IHQubGVuZ3RoLCBhID0gZS5sZW5ndGg7XG4gIGZvciAoOyBvID4gMCAmJiBhID4gMCAmJiB0LmNoYXJDb2RlQXQobyAtIDEpID09IGUuY2hhckNvZGVBdChhIC0gMSk7IClcbiAgICBvLS0sIGEtLTtcbiAgaWYgKHIgPT0gXCJlbmRcIikge1xuICAgIGxldCBsID0gTWF0aC5tYXgoMCwgcyAtIE1hdGgubWluKG8sIGEpKTtcbiAgICBuIC09IG8gKyBsIC0gcztcbiAgfVxuICBpZiAobyA8IHMgJiYgdC5sZW5ndGggPCBlLmxlbmd0aCkge1xuICAgIGxldCBsID0gbiA8PSBzICYmIG4gPj0gbyA/IHMgLSBuIDogMDtcbiAgICBzIC09IGwsIGEgPSBzICsgKGEgLSBvKSwgbyA9IHM7XG4gIH0gZWxzZSBpZiAoYSA8IHMpIHtcbiAgICBsZXQgbCA9IG4gPD0gcyAmJiBuID49IGEgPyBzIC0gbiA6IDA7XG4gICAgcyAtPSBsLCBvID0gcyArIChvIC0gYSksIGEgPSBzO1xuICB9XG4gIHJldHVybiB7IGZyb206IHMsIHRvQTogbywgdG9COiBhIH07XG59XG5mdW5jdGlvbiBJNSh0KSB7XG4gIGxldCBlID0gW107XG4gIGlmICh0LnJvb3QuYWN0aXZlRWxlbWVudCAhPSB0LmNvbnRlbnRET00pXG4gICAgcmV0dXJuIGU7XG4gIGxldCB7IGFuY2hvck5vZGU6IG4sIGFuY2hvck9mZnNldDogciwgZm9jdXNOb2RlOiBpLCBmb2N1c09mZnNldDogcyB9ID0gdC5vYnNlcnZlci5zZWxlY3Rpb25SYW5nZTtcbiAgcmV0dXJuIG4gJiYgKGUucHVzaChuZXcgeXYobiwgcikpLCAoaSAhPSBuIHx8IHMgIT0gcikgJiYgZS5wdXNoKG5ldyB5dihpLCBzKSkpLCBlO1xufVxuZnVuY3Rpb24gVzUodCwgZSkge1xuICBpZiAodC5sZW5ndGggPT0gMClcbiAgICByZXR1cm4gbnVsbDtcbiAgbGV0IG4gPSB0WzBdLnBvcywgciA9IHQubGVuZ3RoID09IDIgPyB0WzFdLnBvcyA6IG47XG4gIHJldHVybiBuID4gLTEgJiYgciA+IC0xID8gYWUuc2luZ2xlKG4gKyBlLCByICsgZSkgOiBudWxsO1xufVxuY29uc3QgTTUgPSB7XG4gIGNoaWxkTGlzdDogITAsXG4gIGNoYXJhY3RlckRhdGE6ICEwLFxuICBzdWJ0cmVlOiAhMCxcbiAgYXR0cmlidXRlczogITAsXG4gIGNoYXJhY3RlckRhdGFPbGRWYWx1ZTogITBcbn0sICRmID0gZGUuaWUgJiYgZGUuaWVfdmVyc2lvbiA8PSAxMTtcbmNsYXNzIFg1IHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMudmlldyA9IGUsIHRoaXMuYWN0aXZlID0gITEsIHRoaXMuc2VsZWN0aW9uUmFuZ2UgPSBuZXcgd04oKSwgdGhpcy5zZWxlY3Rpb25DaGFuZ2VkID0gITEsIHRoaXMuZGVsYXllZEZsdXNoID0gLTEsIHRoaXMucmVzaXplVGltZW91dCA9IC0xLCB0aGlzLnF1ZXVlID0gW10sIHRoaXMuZGVsYXllZEFuZHJvaWRLZXkgPSBudWxsLCB0aGlzLmZsdXNoaW5nQW5kcm9pZEtleSA9IC0xLCB0aGlzLmxhc3RDaGFuZ2UgPSAwLCB0aGlzLnNjcm9sbFRhcmdldHMgPSBbXSwgdGhpcy5pbnRlcnNlY3Rpb24gPSBudWxsLCB0aGlzLnJlc2l6ZVNjcm9sbCA9IG51bGwsIHRoaXMuaW50ZXJzZWN0aW5nID0gITEsIHRoaXMuZ2FwSW50ZXJzZWN0aW9uID0gbnVsbCwgdGhpcy5nYXBzID0gW10sIHRoaXMucGFyZW50Q2hlY2sgPSAtMSwgdGhpcy5kb20gPSBlLmNvbnRlbnRET00sIHRoaXMub2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigobikgPT4ge1xuICAgICAgZm9yIChsZXQgciBvZiBuKVxuICAgICAgICB0aGlzLnF1ZXVlLnB1c2gocik7XG4gICAgICAoZGUuaWUgJiYgZGUuaWVfdmVyc2lvbiA8PSAxMSB8fCBkZS5pb3MgJiYgZS5jb21wb3NpbmcpICYmIG4uc29tZSgocikgPT4gci50eXBlID09IFwiY2hpbGRMaXN0XCIgJiYgci5yZW1vdmVkTm9kZXMubGVuZ3RoIHx8IHIudHlwZSA9PSBcImNoYXJhY3RlckRhdGFcIiAmJiByLm9sZFZhbHVlLmxlbmd0aCA+IHIudGFyZ2V0Lm5vZGVWYWx1ZS5sZW5ndGgpID8gdGhpcy5mbHVzaFNvb24oKSA6IHRoaXMuZmx1c2goKTtcbiAgICB9KSwgJGYgJiYgKHRoaXMub25DaGFyRGF0YSA9IChuKSA9PiB7XG4gICAgICB0aGlzLnF1ZXVlLnB1c2goe1xuICAgICAgICB0YXJnZXQ6IG4udGFyZ2V0LFxuICAgICAgICB0eXBlOiBcImNoYXJhY3RlckRhdGFcIixcbiAgICAgICAgb2xkVmFsdWU6IG4ucHJldlZhbHVlXG4gICAgICB9KSwgdGhpcy5mbHVzaFNvb24oKTtcbiAgICB9KSwgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSA9IHRoaXMub25TZWxlY3Rpb25DaGFuZ2UuYmluZCh0aGlzKSwgdGhpcy5vblJlc2l6ZSA9IHRoaXMub25SZXNpemUuYmluZCh0aGlzKSwgdGhpcy5vblByaW50ID0gdGhpcy5vblByaW50LmJpbmQodGhpcyksIHRoaXMub25TY3JvbGwgPSB0aGlzLm9uU2Nyb2xsLmJpbmQodGhpcyksIHR5cGVvZiBSZXNpemVPYnNlcnZlciA9PSBcImZ1bmN0aW9uXCIgJiYgKHRoaXMucmVzaXplU2Nyb2xsID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHtcbiAgICAgIHZhciBuO1xuICAgICAgKChuID0gdGhpcy52aWV3LmRvY1ZpZXcpID09PSBudWxsIHx8IG4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG4ubGFzdFVwZGF0ZSkgPCBEYXRlLm5vdygpIC0gNzUgJiYgdGhpcy5vblJlc2l6ZSgpO1xuICAgIH0pLCB0aGlzLnJlc2l6ZVNjcm9sbC5vYnNlcnZlKGUuc2Nyb2xsRE9NKSksIHRoaXMuYWRkV2luZG93TGlzdGVuZXJzKHRoaXMud2luID0gZS53aW4pLCB0aGlzLnN0YXJ0KCksIHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciA9PSBcImZ1bmN0aW9uXCIgJiYgKHRoaXMuaW50ZXJzZWN0aW9uID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKChuKSA9PiB7XG4gICAgICB0aGlzLnBhcmVudENoZWNrIDwgMCAmJiAodGhpcy5wYXJlbnRDaGVjayA9IHNldFRpbWVvdXQodGhpcy5saXN0ZW5Gb3JTY3JvbGwuYmluZCh0aGlzKSwgMWUzKSksIG4ubGVuZ3RoID4gMCAmJiBuW24ubGVuZ3RoIC0gMV0uaW50ZXJzZWN0aW9uUmF0aW8gPiAwICE9IHRoaXMuaW50ZXJzZWN0aW5nICYmICh0aGlzLmludGVyc2VjdGluZyA9ICF0aGlzLmludGVyc2VjdGluZywgdGhpcy5pbnRlcnNlY3RpbmcgIT0gdGhpcy52aWV3LmluVmlldyAmJiB0aGlzLm9uU2Nyb2xsQ2hhbmdlZChkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpKSk7XG4gICAgfSwgeyB0aHJlc2hvbGQ6IFswLCAxZS0zXSB9KSwgdGhpcy5pbnRlcnNlY3Rpb24ub2JzZXJ2ZSh0aGlzLmRvbSksIHRoaXMuZ2FwSW50ZXJzZWN0aW9uID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKChuKSA9PiB7XG4gICAgICBuLmxlbmd0aCA+IDAgJiYgbltuLmxlbmd0aCAtIDFdLmludGVyc2VjdGlvblJhdGlvID4gMCAmJiB0aGlzLm9uU2Nyb2xsQ2hhbmdlZChkb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpKTtcbiAgICB9LCB7fSkpLCB0aGlzLmxpc3RlbkZvclNjcm9sbCgpLCB0aGlzLnJlYWRTZWxlY3Rpb25SYW5nZSgpO1xuICB9XG4gIG9uU2Nyb2xsQ2hhbmdlZChlKSB7XG4gICAgdGhpcy52aWV3LmlucHV0U3RhdGUucnVuSGFuZGxlcnMoXCJzY3JvbGxcIiwgZSksIHRoaXMuaW50ZXJzZWN0aW5nICYmIHRoaXMudmlldy5tZWFzdXJlKCk7XG4gIH1cbiAgb25TY3JvbGwoZSkge1xuICAgIHRoaXMuaW50ZXJzZWN0aW5nICYmIHRoaXMuZmx1c2goITEpLCB0aGlzLm9uU2Nyb2xsQ2hhbmdlZChlKTtcbiAgfVxuICBvblJlc2l6ZSgpIHtcbiAgICB0aGlzLnJlc2l6ZVRpbWVvdXQgPCAwICYmICh0aGlzLnJlc2l6ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMucmVzaXplVGltZW91dCA9IC0xLCB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUoKTtcbiAgICB9LCA1MCkpO1xuICB9XG4gIG9uUHJpbnQoKSB7XG4gICAgdGhpcy52aWV3LnZpZXdTdGF0ZS5wcmludGluZyA9ICEwLCB0aGlzLnZpZXcubWVhc3VyZSgpLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMudmlldy52aWV3U3RhdGUucHJpbnRpbmcgPSAhMSwgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKCk7XG4gICAgfSwgNTAwKTtcbiAgfVxuICB1cGRhdGVHYXBzKGUpIHtcbiAgICBpZiAodGhpcy5nYXBJbnRlcnNlY3Rpb24gJiYgKGUubGVuZ3RoICE9IHRoaXMuZ2Fwcy5sZW5ndGggfHwgdGhpcy5nYXBzLnNvbWUoKG4sIHIpID0+IG4gIT0gZVtyXSkpKSB7XG4gICAgICB0aGlzLmdhcEludGVyc2VjdGlvbi5kaXNjb25uZWN0KCk7XG4gICAgICBmb3IgKGxldCBuIG9mIGUpXG4gICAgICAgIHRoaXMuZ2FwSW50ZXJzZWN0aW9uLm9ic2VydmUobik7XG4gICAgICB0aGlzLmdhcHMgPSBlO1xuICAgIH1cbiAgfVxuICBvblNlbGVjdGlvbkNoYW5nZShlKSB7XG4gICAgbGV0IG4gPSB0aGlzLnNlbGVjdGlvbkNoYW5nZWQ7XG4gICAgaWYgKCF0aGlzLnJlYWRTZWxlY3Rpb25SYW5nZSgpIHx8IHRoaXMuZGVsYXllZEFuZHJvaWRLZXkpXG4gICAgICByZXR1cm47XG4gICAgbGV0IHsgdmlldzogciB9ID0gdGhpcywgaSA9IHRoaXMuc2VsZWN0aW9uUmFuZ2U7XG4gICAgaWYgKHIuc3RhdGUuZmFjZXQoWWQpID8gci5yb290LmFjdGl2ZUVsZW1lbnQgIT0gdGhpcy5kb20gOiAhcnUoci5kb20sIGkpKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCBzID0gaS5hbmNob3JOb2RlICYmIHIuZG9jVmlldy5uZWFyZXN0KGkuYW5jaG9yTm9kZSk7XG4gICAgaWYgKHMgJiYgcy5pZ25vcmVFdmVudChlKSkge1xuICAgICAgbiB8fCAodGhpcy5zZWxlY3Rpb25DaGFuZ2VkID0gITEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAoZGUuaWUgJiYgZGUuaWVfdmVyc2lvbiA8PSAxMSB8fCBkZS5hbmRyb2lkICYmIGRlLmNocm9tZSkgJiYgIXIuc3RhdGUuc2VsZWN0aW9uLm1haW4uZW1wdHkgJiYgLy8gKFNlbGVjdGlvbi5pc0NvbGxhcHNlZCBpc24ndCByZWxpYWJsZSBvbiBJRSlcbiAgICBpLmZvY3VzTm9kZSAmJiB6YShpLmZvY3VzTm9kZSwgaS5mb2N1c09mZnNldCwgaS5hbmNob3JOb2RlLCBpLmFuY2hvck9mZnNldCkgPyB0aGlzLmZsdXNoU29vbigpIDogdGhpcy5mbHVzaCghMSk7XG4gIH1cbiAgcmVhZFNlbGVjdGlvblJhbmdlKCkge1xuICAgIGxldCB7IHZpZXc6IGUgfSA9IHRoaXMsIG4gPSBkZS5zYWZhcmkgJiYgZS5yb290Lm5vZGVUeXBlID09IDExICYmIGJOKHRoaXMuZG9tLm93bmVyRG9jdW1lbnQpID09IHRoaXMuZG9tICYmIGo1KHRoaXMudmlldykgfHwgSXUoZS5yb290KTtcbiAgICBpZiAoIW4gfHwgdGhpcy5zZWxlY3Rpb25SYW5nZS5lcShuKSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBsZXQgciA9IHJ1KHRoaXMuZG9tLCBuKTtcbiAgICByZXR1cm4gciAmJiAhdGhpcy5zZWxlY3Rpb25DaGFuZ2VkICYmIGUuaW5wdXRTdGF0ZS5sYXN0Rm9jdXNUaW1lID4gRGF0ZS5ub3coKSAtIDIwMCAmJiBlLmlucHV0U3RhdGUubGFzdFRvdWNoVGltZSA8IERhdGUubm93KCkgLSAzMDAgJiYgeE4odGhpcy5kb20sIG4pID8gKHRoaXMudmlldy5pbnB1dFN0YXRlLmxhc3RGb2N1c1RpbWUgPSAwLCBlLmRvY1ZpZXcudXBkYXRlU2VsZWN0aW9uKCksICExKSA6ICh0aGlzLnNlbGVjdGlvblJhbmdlLnNldFJhbmdlKG4pLCByICYmICh0aGlzLnNlbGVjdGlvbkNoYW5nZWQgPSAhMCksICEwKTtcbiAgfVxuICBzZXRTZWxlY3Rpb25SYW5nZShlLCBuKSB7XG4gICAgdGhpcy5zZWxlY3Rpb25SYW5nZS5zZXQoZS5ub2RlLCBlLm9mZnNldCwgbi5ub2RlLCBuLm9mZnNldCksIHRoaXMuc2VsZWN0aW9uQ2hhbmdlZCA9ICExO1xuICB9XG4gIGNsZWFyU2VsZWN0aW9uUmFuZ2UoKSB7XG4gICAgdGhpcy5zZWxlY3Rpb25SYW5nZS5zZXQobnVsbCwgMCwgbnVsbCwgMCk7XG4gIH1cbiAgbGlzdGVuRm9yU2Nyb2xsKCkge1xuICAgIHRoaXMucGFyZW50Q2hlY2sgPSAtMTtcbiAgICBsZXQgZSA9IDAsIG4gPSBudWxsO1xuICAgIGZvciAobGV0IHIgPSB0aGlzLmRvbTsgcjsgKVxuICAgICAgaWYgKHIubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgIW4gJiYgZSA8IHRoaXMuc2Nyb2xsVGFyZ2V0cy5sZW5ndGggJiYgdGhpcy5zY3JvbGxUYXJnZXRzW2VdID09IHIgPyBlKysgOiBuIHx8IChuID0gdGhpcy5zY3JvbGxUYXJnZXRzLnNsaWNlKDAsIGUpKSwgbiAmJiBuLnB1c2gociksIHIgPSByLmFzc2lnbmVkU2xvdCB8fCByLnBhcmVudE5vZGU7XG4gICAgICBlbHNlIGlmIChyLm5vZGVUeXBlID09IDExKVxuICAgICAgICByID0gci5ob3N0O1xuICAgICAgZWxzZVxuICAgICAgICBicmVhaztcbiAgICBpZiAoZSA8IHRoaXMuc2Nyb2xsVGFyZ2V0cy5sZW5ndGggJiYgIW4gJiYgKG4gPSB0aGlzLnNjcm9sbFRhcmdldHMuc2xpY2UoMCwgZSkpLCBuKSB7XG4gICAgICBmb3IgKGxldCByIG9mIHRoaXMuc2Nyb2xsVGFyZ2V0cylcbiAgICAgICAgci5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpO1xuICAgICAgZm9yIChsZXQgciBvZiB0aGlzLnNjcm9sbFRhcmdldHMgPSBuKVxuICAgICAgICByLmFkZEV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbCk7XG4gICAgfVxuICB9XG4gIGlnbm9yZShlKSB7XG4gICAgaWYgKCF0aGlzLmFjdGl2ZSlcbiAgICAgIHJldHVybiBlKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLnN0b3AoKSwgZSgpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLnN0YXJ0KCksIHRoaXMuY2xlYXIoKTtcbiAgICB9XG4gIH1cbiAgc3RhcnQoKSB7XG4gICAgdGhpcy5hY3RpdmUgfHwgKHRoaXMub2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmRvbSwgTTUpLCAkZiAmJiB0aGlzLmRvbS5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCIsIHRoaXMub25DaGFyRGF0YSksIHRoaXMuYWN0aXZlID0gITApO1xuICB9XG4gIHN0b3AoKSB7XG4gICAgdGhpcy5hY3RpdmUgJiYgKHRoaXMuYWN0aXZlID0gITEsIHRoaXMub2JzZXJ2ZXIuZGlzY29ubmVjdCgpLCAkZiAmJiB0aGlzLmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCIsIHRoaXMub25DaGFyRGF0YSkpO1xuICB9XG4gIC8vIFRocm93IGF3YXkgYW55IHBlbmRpbmcgY2hhbmdlc1xuICBjbGVhcigpIHtcbiAgICB0aGlzLnByb2Nlc3NSZWNvcmRzKCksIHRoaXMucXVldWUubGVuZ3RoID0gMCwgdGhpcy5zZWxlY3Rpb25DaGFuZ2VkID0gITE7XG4gIH1cbiAgLy8gQ2hyb21lIEFuZHJvaWQsIGVzcGVjaWFsbHkgaW4gY29tYmluYXRpb24gd2l0aCBHQm9hcmQsIG5vdCBvbmx5XG4gIC8vIGRvZXNuJ3QgcmVsaWFibHkgZmlyZSByZWd1bGFyIGtleSBldmVudHMsIGJ1dCBhbHNvIG9mdGVuXG4gIC8vIHN1cnJvdW5kcyB0aGUgZWZmZWN0IG9mIGVudGVyIG9yIGJhY2tzcGFjZSB3aXRoIGEgYnVuY2ggb2ZcbiAgLy8gY29tcG9zaXRpb24gZXZlbnRzIHRoYXQsIHdoZW4gaW50ZXJydXB0ZWQsIGNhdXNlIHRleHQgZHVwbGljYXRpb25cbiAgLy8gb3Igb3RoZXIga2luZHMgb2YgY29ycnVwdGlvbi4gVGhpcyBoYWNrIG1ha2VzIHRoZSBlZGl0b3IgYmFjayBvZmZcbiAgLy8gZnJvbSBoYW5kbGluZyBET00gY2hhbmdlcyBmb3IgYSBtb21lbnQgd2hlbiBzdWNoIGEga2V5IGlzXG4gIC8vIGRldGVjdGVkICh2aWEgYmVmb3JlaW5wdXQgb3Iga2V5ZG93biksIGFuZCB0aGVuIHRyaWVzIHRvIGZsdXNoXG4gIC8vIHRoZW0gb3IsIGlmIHRoYXQgaGFzIG5vIGVmZmVjdCwgZGlzcGF0Y2hlcyB0aGUgZ2l2ZW4ga2V5LlxuICBkZWxheUFuZHJvaWRLZXkoZSwgbikge1xuICAgIHZhciByO1xuICAgIGlmICghdGhpcy5kZWxheWVkQW5kcm9pZEtleSkge1xuICAgICAgbGV0IGkgPSAoKSA9PiB7XG4gICAgICAgIGxldCBzID0gdGhpcy5kZWxheWVkQW5kcm9pZEtleTtcbiAgICAgICAgcyAmJiAodGhpcy5jbGVhckRlbGF5ZWRBbmRyb2lkS2V5KCksIHRoaXMudmlldy5pbnB1dFN0YXRlLmxhc3RLZXlDb2RlID0gcy5rZXlDb2RlLCB0aGlzLnZpZXcuaW5wdXRTdGF0ZS5sYXN0S2V5VGltZSA9IERhdGUubm93KCksICF0aGlzLmZsdXNoKCkgJiYgcy5mb3JjZSAmJiBUbyh0aGlzLmRvbSwgcy5rZXksIHMua2V5Q29kZSkpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuZmx1c2hpbmdBbmRyb2lkS2V5ID0gdGhpcy52aWV3Lndpbi5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoaSk7XG4gICAgfVxuICAgICghdGhpcy5kZWxheWVkQW5kcm9pZEtleSB8fCBlID09IFwiRW50ZXJcIikgJiYgKHRoaXMuZGVsYXllZEFuZHJvaWRLZXkgPSB7XG4gICAgICBrZXk6IGUsXG4gICAgICBrZXlDb2RlOiBuLFxuICAgICAgLy8gT25seSBydW4gdGhlIGtleSBoYW5kbGVyIHdoZW4gbm8gY2hhbmdlcyBhcmUgZGV0ZWN0ZWQgaWZcbiAgICAgIC8vIHRoaXMgaXNuJ3QgY29taW5nIHJpZ2h0IGFmdGVyIGFub3RoZXIgY2hhbmdlLCBpbiB3aGljaCBjYXNlXG4gICAgICAvLyBpdCBpcyBwcm9iYWJseSBwYXJ0IG9mIGEgd2VpcmQgY2hhaW4gb2YgdXBkYXRlcywgYW5kIHNob3VsZFxuICAgICAgLy8gYmUgaWdub3JlZCBpZiBpdCByZXR1cm5zIHRoZSBET00gdG8gaXRzIHByZXZpb3VzIHN0YXRlLlxuICAgICAgZm9yY2U6IHRoaXMubGFzdENoYW5nZSA8IERhdGUubm93KCkgLSA1MCB8fCAhISghKChyID0gdGhpcy5kZWxheWVkQW5kcm9pZEtleSkgPT09IG51bGwgfHwgciA9PT0gdm9pZCAwKSAmJiByLmZvcmNlKVxuICAgIH0pO1xuICB9XG4gIGNsZWFyRGVsYXllZEFuZHJvaWRLZXkoKSB7XG4gICAgdGhpcy53aW4uY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5mbHVzaGluZ0FuZHJvaWRLZXkpLCB0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5ID0gbnVsbCwgdGhpcy5mbHVzaGluZ0FuZHJvaWRLZXkgPSAtMTtcbiAgfVxuICBmbHVzaFNvb24oKSB7XG4gICAgdGhpcy5kZWxheWVkRmx1c2ggPCAwICYmICh0aGlzLmRlbGF5ZWRGbHVzaCA9IHRoaXMudmlldy53aW4ucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMuZGVsYXllZEZsdXNoID0gLTEsIHRoaXMuZmx1c2goKTtcbiAgICB9KSk7XG4gIH1cbiAgZm9yY2VGbHVzaCgpIHtcbiAgICB0aGlzLmRlbGF5ZWRGbHVzaCA+PSAwICYmICh0aGlzLnZpZXcud2luLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZGVsYXllZEZsdXNoKSwgdGhpcy5kZWxheWVkRmx1c2ggPSAtMSksIHRoaXMuZmx1c2goKTtcbiAgfVxuICBwZW5kaW5nUmVjb3JkcygpIHtcbiAgICBmb3IgKGxldCBlIG9mIHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKSlcbiAgICAgIHRoaXMucXVldWUucHVzaChlKTtcbiAgICByZXR1cm4gdGhpcy5xdWV1ZTtcbiAgfVxuICBwcm9jZXNzUmVjb3JkcygpIHtcbiAgICBsZXQgZSA9IHRoaXMucGVuZGluZ1JlY29yZHMoKTtcbiAgICBlLmxlbmd0aCAmJiAodGhpcy5xdWV1ZSA9IFtdKTtcbiAgICBsZXQgbiA9IC0xLCByID0gLTEsIGkgPSAhMTtcbiAgICBmb3IgKGxldCBzIG9mIGUpIHtcbiAgICAgIGxldCBvID0gdGhpcy5yZWFkTXV0YXRpb24ocyk7XG4gICAgICBvICYmIChvLnR5cGVPdmVyICYmIChpID0gITApLCBuID09IC0xID8geyBmcm9tOiBuLCB0bzogciB9ID0gbyA6IChuID0gTWF0aC5taW4oby5mcm9tLCBuKSwgciA9IE1hdGgubWF4KG8udG8sIHIpKSk7XG4gICAgfVxuICAgIHJldHVybiB7IGZyb206IG4sIHRvOiByLCB0eXBlT3ZlcjogaSB9O1xuICB9XG4gIHJlYWRDaGFuZ2UoKSB7XG4gICAgbGV0IHsgZnJvbTogZSwgdG86IG4sIHR5cGVPdmVyOiByIH0gPSB0aGlzLnByb2Nlc3NSZWNvcmRzKCksIGkgPSB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgJiYgcnUodGhpcy5kb20sIHRoaXMuc2VsZWN0aW9uUmFuZ2UpO1xuICAgIGlmIChlIDwgMCAmJiAhaSlcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGUgPiAtMSAmJiAodGhpcy5sYXN0Q2hhbmdlID0gRGF0ZS5ub3coKSksIHRoaXMudmlldy5pbnB1dFN0YXRlLmxhc3RGb2N1c1RpbWUgPSAwLCB0aGlzLnNlbGVjdGlvbkNoYW5nZWQgPSAhMTtcbiAgICBsZXQgcyA9IG5ldyBENSh0aGlzLnZpZXcsIGUsIG4sIHIpO1xuICAgIHJldHVybiB0aGlzLnZpZXcuZG9jVmlldy5kb21DaGFuZ2VkID0geyBuZXdTZWw6IHMubmV3U2VsID8gcy5uZXdTZWwubWFpbiA6IG51bGwgfSwgcztcbiAgfVxuICAvLyBBcHBseSBwZW5kaW5nIGNoYW5nZXMsIGlmIGFueVxuICBmbHVzaChlID0gITApIHtcbiAgICBpZiAodGhpcy5kZWxheWVkRmx1c2ggPj0gMCB8fCB0aGlzLmRlbGF5ZWRBbmRyb2lkS2V5KVxuICAgICAgcmV0dXJuICExO1xuICAgIGUgJiYgdGhpcy5yZWFkU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICBsZXQgbiA9IHRoaXMucmVhZENoYW5nZSgpO1xuICAgIGlmICghbilcbiAgICAgIHJldHVybiB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUoKSwgITE7XG4gICAgbGV0IHIgPSB0aGlzLnZpZXcuc3RhdGUsIGkgPSBMayh0aGlzLnZpZXcsIG4pO1xuICAgIHJldHVybiB0aGlzLnZpZXcuc3RhdGUgPT0gciAmJiB0aGlzLnZpZXcudXBkYXRlKFtdKSwgaTtcbiAgfVxuICByZWFkTXV0YXRpb24oZSkge1xuICAgIGxldCBuID0gdGhpcy52aWV3LmRvY1ZpZXcubmVhcmVzdChlLnRhcmdldCk7XG4gICAgaWYgKCFuIHx8IG4uaWdub3JlTXV0YXRpb24oZSkpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAobi5tYXJrRGlydHkoZS50eXBlID09IFwiYXR0cmlidXRlc1wiKSwgZS50eXBlID09IFwiYXR0cmlidXRlc1wiICYmIChuLmZsYWdzIHw9IDQpLCBlLnR5cGUgPT0gXCJjaGlsZExpc3RcIikge1xuICAgICAgbGV0IHIgPSBTdihuLCBlLnByZXZpb3VzU2libGluZyB8fCBlLnRhcmdldC5wcmV2aW91c1NpYmxpbmcsIC0xKSwgaSA9IFN2KG4sIGUubmV4dFNpYmxpbmcgfHwgZS50YXJnZXQubmV4dFNpYmxpbmcsIDEpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbTogciA/IG4ucG9zQWZ0ZXIocikgOiBuLnBvc0F0U3RhcnQsXG4gICAgICAgIHRvOiBpID8gbi5wb3NCZWZvcmUoaSkgOiBuLnBvc0F0RW5kLFxuICAgICAgICB0eXBlT3ZlcjogITFcbiAgICAgIH07XG4gICAgfSBlbHNlXG4gICAgICByZXR1cm4gZS50eXBlID09IFwiY2hhcmFjdGVyRGF0YVwiID8geyBmcm9tOiBuLnBvc0F0U3RhcnQsIHRvOiBuLnBvc0F0RW5kLCB0eXBlT3ZlcjogZS50YXJnZXQubm9kZVZhbHVlID09IGUub2xkVmFsdWUgfSA6IG51bGw7XG4gIH1cbiAgc2V0V2luZG93KGUpIHtcbiAgICBlICE9IHRoaXMud2luICYmICh0aGlzLnJlbW92ZVdpbmRvd0xpc3RlbmVycyh0aGlzLndpbiksIHRoaXMud2luID0gZSwgdGhpcy5hZGRXaW5kb3dMaXN0ZW5lcnModGhpcy53aW4pKTtcbiAgfVxuICBhZGRXaW5kb3dMaXN0ZW5lcnMoZSkge1xuICAgIGUuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLm9uUmVzaXplKSwgZS5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JlcHJpbnRcIiwgdGhpcy5vblByaW50KSwgZS5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHRoaXMub25TY3JvbGwpLCBlLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSk7XG4gIH1cbiAgcmVtb3ZlV2luZG93TGlzdGVuZXJzKGUpIHtcbiAgICBlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbCksIGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLm9uUmVzaXplKSwgZS5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmVmb3JlcHJpbnRcIiwgdGhpcy5vblByaW50KSwgZS5kb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdmFyIGUsIG4sIHI7XG4gICAgdGhpcy5zdG9wKCksIChlID0gdGhpcy5pbnRlcnNlY3Rpb24pID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCB8fCBlLmRpc2Nvbm5lY3QoKSwgKG4gPSB0aGlzLmdhcEludGVyc2VjdGlvbikgPT09IG51bGwgfHwgbiA9PT0gdm9pZCAwIHx8IG4uZGlzY29ubmVjdCgpLCAociA9IHRoaXMucmVzaXplU2Nyb2xsKSA9PT0gbnVsbCB8fCByID09PSB2b2lkIDAgfHwgci5kaXNjb25uZWN0KCk7XG4gICAgZm9yIChsZXQgaSBvZiB0aGlzLnNjcm9sbFRhcmdldHMpXG4gICAgICBpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzY3JvbGxcIiwgdGhpcy5vblNjcm9sbCk7XG4gICAgdGhpcy5yZW1vdmVXaW5kb3dMaXN0ZW5lcnModGhpcy53aW4pLCBjbGVhclRpbWVvdXQodGhpcy5wYXJlbnRDaGVjayksIGNsZWFyVGltZW91dCh0aGlzLnJlc2l6ZVRpbWVvdXQpLCB0aGlzLndpbi5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmRlbGF5ZWRGbHVzaCksIHRoaXMud2luLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZmx1c2hpbmdBbmRyb2lkS2V5KTtcbiAgfVxufVxuZnVuY3Rpb24gU3YodCwgZSwgbikge1xuICBmb3IgKDsgZTsgKSB7XG4gICAgbGV0IHIgPSBmdC5nZXQoZSk7XG4gICAgaWYgKHIgJiYgci5wYXJlbnQgPT0gdClcbiAgICAgIHJldHVybiByO1xuICAgIGxldCBpID0gZS5wYXJlbnROb2RlO1xuICAgIGUgPSBpICE9IHQuZG9tID8gaSA6IG4gPiAwID8gZS5uZXh0U2libGluZyA6IGUucHJldmlvdXNTaWJsaW5nO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gajUodCkge1xuICBsZXQgZSA9IG51bGw7XG4gIGZ1bmN0aW9uIG4obCkge1xuICAgIGwucHJldmVudERlZmF1bHQoKSwgbC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSwgZSA9IGwuZ2V0VGFyZ2V0UmFuZ2VzKClbMF07XG4gIH1cbiAgaWYgKHQuY29udGVudERPTS5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JlaW5wdXRcIiwgbiwgITApLCB0LmRvbS5vd25lckRvY3VtZW50LmV4ZWNDb21tYW5kKFwiaW5kZW50XCIpLCB0LmNvbnRlbnRET00ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJlZm9yZWlucHV0XCIsIG4sICEwKSwgIWUpXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCByID0gZS5zdGFydENvbnRhaW5lciwgaSA9IGUuc3RhcnRPZmZzZXQsIHMgPSBlLmVuZENvbnRhaW5lciwgbyA9IGUuZW5kT2Zmc2V0LCBhID0gdC5kb2NWaWV3LmRvbUF0UG9zKHQuc3RhdGUuc2VsZWN0aW9uLm1haW4uYW5jaG9yKTtcbiAgcmV0dXJuIHphKGEubm9kZSwgYS5vZmZzZXQsIHMsIG8pICYmIChbciwgaSwgcywgb10gPSBbcywgbywgciwgaV0pLCB7IGFuY2hvck5vZGU6IHIsIGFuY2hvck9mZnNldDogaSwgZm9jdXNOb2RlOiBzLCBmb2N1c09mZnNldDogbyB9O1xufVxuY2xhc3MgU2Uge1xuICAvKipcbiAgVGhlIGN1cnJlbnQgZWRpdG9yIHN0YXRlLlxuICAqL1xuICBnZXQgc3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlld1N0YXRlLnN0YXRlO1xuICB9XG4gIC8qKlxuICBUbyBiZSBhYmxlIHRvIGRpc3BsYXkgbGFyZ2UgZG9jdW1lbnRzIHdpdGhvdXQgY29uc3VtaW5nIHRvbyBtdWNoXG4gIG1lbW9yeSBvciBvdmVybG9hZGluZyB0aGUgYnJvd3NlciwgQ29kZU1pcnJvciBvbmx5IGRyYXdzIHRoZVxuICBjb2RlIHRoYXQgaXMgdmlzaWJsZSAocGx1cyBhIG1hcmdpbiBhcm91bmQgaXQpIHRvIHRoZSBET00uIFRoaXNcbiAgcHJvcGVydHkgdGVsbHMgeW91IHRoZSBleHRlbnQgb2YgdGhlIGN1cnJlbnQgZHJhd24gdmlld3BvcnQsIGluXG4gIGRvY3VtZW50IHBvc2l0aW9ucy5cbiAgKi9cbiAgZ2V0IHZpZXdwb3J0KCkge1xuICAgIHJldHVybiB0aGlzLnZpZXdTdGF0ZS52aWV3cG9ydDtcbiAgfVxuICAvKipcbiAgV2hlbiB0aGVyZSBhcmUsIGZvciBleGFtcGxlLCBsYXJnZSBjb2xsYXBzZWQgcmFuZ2VzIGluIHRoZVxuICB2aWV3cG9ydCwgaXRzIHNpemUgY2FuIGJlIGEgbG90IGJpZ2dlciB0aGFuIHRoZSBhY3R1YWwgdmlzaWJsZVxuICBjb250ZW50LiBUaHVzLCBpZiB5b3UgYXJlIGRvaW5nIHNvbWV0aGluZyBsaWtlIHN0eWxpbmcgdGhlXG4gIGNvbnRlbnQgaW4gdGhlIHZpZXdwb3J0LCBpdCBpcyBwcmVmZXJhYmxlIHRvIG9ubHkgZG8gc28gZm9yXG4gIHRoZXNlIHJhbmdlcywgd2hpY2ggYXJlIHRoZSBzdWJzZXQgb2YgdGhlIHZpZXdwb3J0IHRoYXQgaXNcbiAgYWN0dWFsbHkgZHJhd24uXG4gICovXG4gIGdldCB2aXNpYmxlUmFuZ2VzKCkge1xuICAgIHJldHVybiB0aGlzLnZpZXdTdGF0ZS52aXNpYmxlUmFuZ2VzO1xuICB9XG4gIC8qKlxuICBSZXR1cm5zIGZhbHNlIHdoZW4gdGhlIGVkaXRvciBpcyBlbnRpcmVseSBzY3JvbGxlZCBvdXQgb2Ygdmlld1xuICBvciBvdGhlcndpc2UgaGlkZGVuLlxuICAqL1xuICBnZXQgaW5WaWV3KCkge1xuICAgIHJldHVybiB0aGlzLnZpZXdTdGF0ZS5pblZpZXc7XG4gIH1cbiAgLyoqXG4gIEluZGljYXRlcyB3aGV0aGVyIHRoZSB1c2VyIGlzIGN1cnJlbnRseSBjb21wb3NpbmcgdGV4dCB2aWFcbiAgW0lNRV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSW5wdXRfbWV0aG9kKSwgYW5kIGF0IGxlYXN0XG4gIG9uZSBjaGFuZ2UgaGFzIGJlZW4gbWFkZSBpbiB0aGUgY3VycmVudCBjb21wb3NpdGlvbi5cbiAgKi9cbiAgZ2V0IGNvbXBvc2luZygpIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dFN0YXRlLmNvbXBvc2luZyA+IDA7XG4gIH1cbiAgLyoqXG4gIEluZGljYXRlcyB3aGV0aGVyIHRoZSB1c2VyIGlzIGN1cnJlbnRseSBpbiBjb21wb3Npbmcgc3RhdGUuIE5vdGVcbiAgdGhhdCBvbiBzb21lIHBsYXRmb3JtcywgbGlrZSBBbmRyb2lkLCB0aGlzIHdpbGwgYmUgdGhlIGNhc2UgYVxuICBsb3QsIHNpbmNlIGp1c3QgcHV0dGluZyB0aGUgY3Vyc29yIG9uIGEgd29yZCBzdGFydHMgYVxuICBjb21wb3NpdGlvbiB0aGVyZS5cbiAgKi9cbiAgZ2V0IGNvbXBvc2l0aW9uU3RhcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnB1dFN0YXRlLmNvbXBvc2luZyA+PSAwO1xuICB9XG4gIC8qKlxuICBUaGUgZG9jdW1lbnQgb3Igc2hhZG93IHJvb3QgdGhhdCB0aGUgdmlldyBsaXZlcyBpbi5cbiAgKi9cbiAgZ2V0IHJvb3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jvb3Q7XG4gIH1cbiAgLyoqXG4gIEBpbnRlcm5hbFxuICAqL1xuICBnZXQgd2luKCkge1xuICAgIHJldHVybiB0aGlzLmRvbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgfVxuICAvKipcbiAgQ29uc3RydWN0IGEgbmV3IHZpZXcuIFlvdSdsbCB3YW50IHRvIGVpdGhlciBwcm92aWRlIGEgYHBhcmVudGBcbiAgb3B0aW9uLCBvciBwdXQgYHZpZXcuZG9tYCBpbnRvIHlvdXIgZG9jdW1lbnQgYWZ0ZXIgY3JlYXRpbmcgYVxuICB2aWV3LCBzbyB0aGF0IHRoZSB1c2VyIGNhbiBzZWUgdGhlIGVkaXRvci5cbiAgKi9cbiAgY29uc3RydWN0b3IoZSA9IHt9KSB7XG4gICAgdGhpcy5wbHVnaW5zID0gW10sIHRoaXMucGx1Z2luTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgdGhpcy5lZGl0b3JBdHRycyA9IHt9LCB0aGlzLmNvbnRlbnRBdHRycyA9IHt9LCB0aGlzLmJpZGlDYWNoZSA9IFtdLCB0aGlzLmRlc3Ryb3llZCA9ICExLCB0aGlzLnVwZGF0ZVN0YXRlID0gMiwgdGhpcy5tZWFzdXJlU2NoZWR1bGVkID0gLTEsIHRoaXMubWVhc3VyZVJlcXVlc3RzID0gW10sIHRoaXMuY29udGVudERPTSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIHRoaXMuc2Nyb2xsRE9NID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgdGhpcy5zY3JvbGxET00udGFiSW5kZXggPSAtMSwgdGhpcy5zY3JvbGxET00uY2xhc3NOYW1lID0gXCJjbS1zY3JvbGxlclwiLCB0aGlzLnNjcm9sbERPTS5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRET00pLCB0aGlzLmFubm91bmNlRE9NID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgdGhpcy5hbm5vdW5jZURPTS5jbGFzc05hbWUgPSBcImNtLWFubm91bmNlZFwiLCB0aGlzLmFubm91bmNlRE9NLnNldEF0dHJpYnV0ZShcImFyaWEtbGl2ZVwiLCBcInBvbGl0ZVwiKSwgdGhpcy5kb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLCB0aGlzLmRvbS5hcHBlbmRDaGlsZCh0aGlzLmFubm91bmNlRE9NKSwgdGhpcy5kb20uYXBwZW5kQ2hpbGQodGhpcy5zY3JvbGxET00pLCBlLnBhcmVudCAmJiBlLnBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLmRvbSk7XG4gICAgbGV0IHsgZGlzcGF0Y2g6IG4gfSA9IGU7XG4gICAgdGhpcy5kaXNwYXRjaFRyYW5zYWN0aW9ucyA9IGUuZGlzcGF0Y2hUcmFuc2FjdGlvbnMgfHwgbiAmJiAoKHIpID0+IHIuZm9yRWFjaCgoaSkgPT4gbihpLCB0aGlzKSkpIHx8ICgocikgPT4gdGhpcy51cGRhdGUocikpLCB0aGlzLmRpc3BhdGNoID0gdGhpcy5kaXNwYXRjaC5iaW5kKHRoaXMpLCB0aGlzLl9yb290ID0gZS5yb290IHx8IGtOKGUucGFyZW50KSB8fCBkb2N1bWVudCwgdGhpcy52aWV3U3RhdGUgPSBuZXcgbXYoZS5zdGF0ZSB8fCBZZS5jcmVhdGUoZSkpLCBlLnNjcm9sbFRvICYmIGUuc2Nyb2xsVG8uaXMoX2MpICYmICh0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUYXJnZXQgPSBlLnNjcm9sbFRvLnZhbHVlLmNsaXAodGhpcy52aWV3U3RhdGUuc3RhdGUpKSwgdGhpcy5wbHVnaW5zID0gdGhpcy5zdGF0ZS5mYWNldChSYSkubWFwKChyKSA9PiBuZXcgUGYocikpO1xuICAgIGZvciAobGV0IHIgb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgci51cGRhdGUodGhpcyk7XG4gICAgdGhpcy5vYnNlcnZlciA9IG5ldyBYNSh0aGlzKSwgdGhpcy5pbnB1dFN0YXRlID0gbmV3IHI1KHRoaXMpLCB0aGlzLmlucHV0U3RhdGUuZW5zdXJlSGFuZGxlcnModGhpcy5wbHVnaW5zKSwgdGhpcy5kb2NWaWV3ID0gbmV3IEpiKHRoaXMpLCB0aGlzLm1vdW50U3R5bGVzKCksIHRoaXMudXBkYXRlQXR0cnMoKSwgdGhpcy51cGRhdGVTdGF0ZSA9IDAsIHRoaXMucmVxdWVzdE1lYXN1cmUoKTtcbiAgfVxuICBkaXNwYXRjaCguLi5lKSB7XG4gICAgbGV0IG4gPSBlLmxlbmd0aCA9PSAxICYmIGVbMF0gaW5zdGFuY2VvZiBHdCA/IGUgOiBlLmxlbmd0aCA9PSAxICYmIEFycmF5LmlzQXJyYXkoZVswXSkgPyBlWzBdIDogW3RoaXMuc3RhdGUudXBkYXRlKC4uLmUpXTtcbiAgICB0aGlzLmRpc3BhdGNoVHJhbnNhY3Rpb25zKG4sIHRoaXMpO1xuICB9XG4gIC8qKlxuICBVcGRhdGUgdGhlIHZpZXcgZm9yIHRoZSBnaXZlbiBhcnJheSBvZiB0cmFuc2FjdGlvbnMuIFRoaXMgd2lsbFxuICB1cGRhdGUgdGhlIHZpc2libGUgZG9jdW1lbnQgYW5kIHNlbGVjdGlvbiB0byBtYXRjaCB0aGUgc3RhdGVcbiAgcHJvZHVjZWQgYnkgdGhlIHRyYW5zYWN0aW9ucywgYW5kIG5vdGlmeSB2aWV3IHBsdWdpbnMgb2YgdGhlXG4gIGNoYW5nZS4gWW91IHNob3VsZCB1c3VhbGx5IGNhbGxcbiAgW2BkaXNwYXRjaGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRpc3BhdGNoKSBpbnN0ZWFkLCB3aGljaCB1c2VzIHRoaXNcbiAgYXMgYSBwcmltaXRpdmUuXG4gICovXG4gIHVwZGF0ZShlKSB7XG4gICAgaWYgKHRoaXMudXBkYXRlU3RhdGUgIT0gMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbGxzIHRvIEVkaXRvclZpZXcudXBkYXRlIGFyZSBub3QgYWxsb3dlZCB3aGlsZSBhbiB1cGRhdGUgaXMgaW4gcHJvZ3Jlc3NcIik7XG4gICAgbGV0IG4gPSAhMSwgciA9ICExLCBpLCBzID0gdGhpcy5zdGF0ZTtcbiAgICBmb3IgKGxldCBmIG9mIGUpIHtcbiAgICAgIGlmIChmLnN0YXJ0U3RhdGUgIT0gcylcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUcnlpbmcgdG8gdXBkYXRlIHN0YXRlIHdpdGggYSB0cmFuc2FjdGlvbiB0aGF0IGRvZXNuJ3Qgc3RhcnQgZnJvbSB0aGUgcHJldmlvdXMgc3RhdGUuXCIpO1xuICAgICAgcyA9IGYuc3RhdGU7XG4gICAgfVxuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgdGhpcy52aWV3U3RhdGUuc3RhdGUgPSBzO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgbyA9IHRoaXMuaGFzRm9jdXMsIGEgPSAwLCBsID0gbnVsbDtcbiAgICBlLnNvbWUoKGYpID0+IGYuYW5ub3RhdGlvbihWaykpID8gKHRoaXMuaW5wdXRTdGF0ZS5ub3RpZmllZEZvY3VzZWQgPSBvLCBhID0gMSkgOiBvICE9IHRoaXMuaW5wdXRTdGF0ZS5ub3RpZmllZEZvY3VzZWQgJiYgKHRoaXMuaW5wdXRTdGF0ZS5ub3RpZmllZEZvY3VzZWQgPSBvLCBsID0gSWsocywgbyksIGwgfHwgKGEgPSAxKSk7XG4gICAgbGV0IGMgPSB0aGlzLm9ic2VydmVyLmRlbGF5ZWRBbmRyb2lkS2V5LCB1ID0gbnVsbDtcbiAgICBpZiAoYyA/ICh0aGlzLm9ic2VydmVyLmNsZWFyRGVsYXllZEFuZHJvaWRLZXkoKSwgdSA9IHRoaXMub2JzZXJ2ZXIucmVhZENoYW5nZSgpLCAodSAmJiAhdGhpcy5zdGF0ZS5kb2MuZXEocy5kb2MpIHx8ICF0aGlzLnN0YXRlLnNlbGVjdGlvbi5lcShzLnNlbGVjdGlvbikpICYmICh1ID0gbnVsbCkpIDogdGhpcy5vYnNlcnZlci5jbGVhcigpLCBzLmZhY2V0KFllLnBocmFzZXMpICE9IHRoaXMuc3RhdGUuZmFjZXQoWWUucGhyYXNlcykpXG4gICAgICByZXR1cm4gdGhpcy5zZXRTdGF0ZShzKTtcbiAgICBpID0gV3UuY3JlYXRlKHRoaXMsIHMsIGUpLCBpLmZsYWdzIHw9IGE7XG4gICAgbGV0IGQgPSB0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUYXJnZXQ7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAyO1xuICAgICAgZm9yIChsZXQgZiBvZiBlKSB7XG4gICAgICAgIGlmIChkICYmIChkID0gZC5tYXAoZi5jaGFuZ2VzKSksIGYuc2Nyb2xsSW50b1ZpZXcpIHtcbiAgICAgICAgICBsZXQgeyBtYWluOiBoIH0gPSBmLnN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgICBkID0gbmV3IEVvKGguZW1wdHkgPyBoIDogYWUuY3Vyc29yKGguaGVhZCwgaC5oZWFkID4gaC5hbmNob3IgPyAtMSA6IDEpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBoIG9mIGYuZWZmZWN0cylcbiAgICAgICAgICBoLmlzKF9jKSAmJiAoZCA9IGgudmFsdWUuY2xpcCh0aGlzLnN0YXRlKSk7XG4gICAgICB9XG4gICAgICB0aGlzLnZpZXdTdGF0ZS51cGRhdGUoaSwgZCksIHRoaXMuYmlkaUNhY2hlID0gTXUudXBkYXRlKHRoaXMuYmlkaUNhY2hlLCBpLmNoYW5nZXMpLCBpLmVtcHR5IHx8ICh0aGlzLnVwZGF0ZVBsdWdpbnMoaSksIHRoaXMuaW5wdXRTdGF0ZS51cGRhdGUoaSkpLCBuID0gdGhpcy5kb2NWaWV3LnVwZGF0ZShpKSwgdGhpcy5zdGF0ZS5mYWNldChOYSkgIT0gdGhpcy5zdHlsZU1vZHVsZXMgJiYgdGhpcy5tb3VudFN0eWxlcygpLCByID0gdGhpcy51cGRhdGVBdHRycygpLCB0aGlzLnNob3dBbm5vdW5jZW1lbnRzKGUpLCB0aGlzLmRvY1ZpZXcudXBkYXRlU2VsZWN0aW9uKG4sIGUuc29tZSgoZikgPT4gZi5pc1VzZXJFdmVudChcInNlbGVjdC5wb2ludGVyXCIpKSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAwO1xuICAgIH1cbiAgICBpZiAoaS5zdGFydFN0YXRlLmZhY2V0KEFjKSAhPSBpLnN0YXRlLmZhY2V0KEFjKSAmJiAodGhpcy52aWV3U3RhdGUubXVzdE1lYXN1cmVDb250ZW50ID0gITApLCAobiB8fCByIHx8IGQgfHwgdGhpcy52aWV3U3RhdGUubXVzdEVuZm9yY2VDdXJzb3JBc3NvYyB8fCB0aGlzLnZpZXdTdGF0ZS5tdXN0TWVhc3VyZUNvbnRlbnQpICYmIHRoaXMucmVxdWVzdE1lYXN1cmUoKSwgIWkuZW1wdHkpXG4gICAgICBmb3IgKGxldCBmIG9mIHRoaXMuc3RhdGUuZmFjZXQoZnApKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGYoaSk7XG4gICAgICAgIH0gY2F0Y2ggKGgpIHtcbiAgICAgICAgICBocih0aGlzLnN0YXRlLCBoLCBcInVwZGF0ZSBsaXN0ZW5lclwiKTtcbiAgICAgICAgfVxuICAgIChsIHx8IHUpICYmIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgbCAmJiB0aGlzLnN0YXRlID09IGwuc3RhcnRTdGF0ZSAmJiB0aGlzLmRpc3BhdGNoKGwpLCB1ICYmICFMayh0aGlzLCB1KSAmJiBjLmZvcmNlICYmIFRvKHRoaXMuY29udGVudERPTSwgYy5rZXksIGMua2V5Q29kZSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gIFJlc2V0IHRoZSB2aWV3IHRvIHRoZSBnaXZlbiBzdGF0ZS4gKFRoaXMgd2lsbCBjYXVzZSB0aGUgZW50aXJlXG4gIGRvY3VtZW50IHRvIGJlIHJlZHJhd24gYW5kIGFsbCB2aWV3IHBsdWdpbnMgdG8gYmUgcmVpbml0aWFsaXplZCxcbiAgc28geW91IHNob3VsZCBwcm9iYWJseSBvbmx5IHVzZSBpdCB3aGVuIHRoZSBuZXcgc3RhdGUgaXNuJ3RcbiAgZGVyaXZlZCBmcm9tIHRoZSBvbGQgc3RhdGUuIE90aGVyd2lzZSwgdXNlXG4gIFtgZGlzcGF0Y2hgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kaXNwYXRjaCkgaW5zdGVhZC4pXG4gICovXG4gIHNldFN0YXRlKGUpIHtcbiAgICBpZiAodGhpcy51cGRhdGVTdGF0ZSAhPSAwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbHMgdG8gRWRpdG9yVmlldy5zZXRTdGF0ZSBhcmUgbm90IGFsbG93ZWQgd2hpbGUgYW4gdXBkYXRlIGlzIGluIHByb2dyZXNzXCIpO1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgdGhpcy52aWV3U3RhdGUuc3RhdGUgPSBlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMjtcbiAgICBsZXQgbiA9IHRoaXMuaGFzRm9jdXM7XG4gICAgdHJ5IHtcbiAgICAgIGZvciAobGV0IHIgb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgICByLmRlc3Ryb3kodGhpcyk7XG4gICAgICB0aGlzLnZpZXdTdGF0ZSA9IG5ldyBtdihlKSwgdGhpcy5wbHVnaW5zID0gZS5mYWNldChSYSkubWFwKChyKSA9PiBuZXcgUGYocikpLCB0aGlzLnBsdWdpbk1hcC5jbGVhcigpO1xuICAgICAgZm9yIChsZXQgciBvZiB0aGlzLnBsdWdpbnMpXG4gICAgICAgIHIudXBkYXRlKHRoaXMpO1xuICAgICAgdGhpcy5kb2NWaWV3LmRlc3Ryb3koKSwgdGhpcy5kb2NWaWV3ID0gbmV3IEpiKHRoaXMpLCB0aGlzLmlucHV0U3RhdGUuZW5zdXJlSGFuZGxlcnModGhpcy5wbHVnaW5zKSwgdGhpcy5tb3VudFN0eWxlcygpLCB0aGlzLnVwZGF0ZUF0dHJzKCksIHRoaXMuYmlkaUNhY2hlID0gW107XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAwO1xuICAgIH1cbiAgICBuICYmIHRoaXMuZm9jdXMoKSwgdGhpcy5yZXF1ZXN0TWVhc3VyZSgpO1xuICB9XG4gIHVwZGF0ZVBsdWdpbnMoZSkge1xuICAgIGxldCBuID0gZS5zdGFydFN0YXRlLmZhY2V0KFJhKSwgciA9IGUuc3RhdGUuZmFjZXQoUmEpO1xuICAgIGlmIChuICE9IHIpIHtcbiAgICAgIGxldCBpID0gW107XG4gICAgICBmb3IgKGxldCBzIG9mIHIpIHtcbiAgICAgICAgbGV0IG8gPSBuLmluZGV4T2Yocyk7XG4gICAgICAgIGlmIChvIDwgMClcbiAgICAgICAgICBpLnB1c2gobmV3IFBmKHMpKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbGV0IGEgPSB0aGlzLnBsdWdpbnNbb107XG4gICAgICAgICAgYS5tdXN0VXBkYXRlID0gZSwgaS5wdXNoKGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBzIG9mIHRoaXMucGx1Z2lucylcbiAgICAgICAgcy5tdXN0VXBkYXRlICE9IGUgJiYgcy5kZXN0cm95KHRoaXMpO1xuICAgICAgdGhpcy5wbHVnaW5zID0gaSwgdGhpcy5wbHVnaW5NYXAuY2xlYXIoKTtcbiAgICB9IGVsc2VcbiAgICAgIGZvciAobGV0IGkgb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgICBpLm11c3RVcGRhdGUgPSBlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wbHVnaW5zLmxlbmd0aDsgaSsrKVxuICAgICAgdGhpcy5wbHVnaW5zW2ldLnVwZGF0ZSh0aGlzKTtcbiAgICBuICE9IHIgJiYgdGhpcy5pbnB1dFN0YXRlLmVuc3VyZUhhbmRsZXJzKHRoaXMucGx1Z2lucyk7XG4gIH1cbiAgLyoqXG4gIEBpbnRlcm5hbFxuICAqL1xuICBtZWFzdXJlKGUgPSAhMCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3llZClcbiAgICAgIHJldHVybjtcbiAgICBpZiAodGhpcy5tZWFzdXJlU2NoZWR1bGVkID4gLTEgJiYgdGhpcy53aW4uY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5tZWFzdXJlU2NoZWR1bGVkKSwgdGhpcy5vYnNlcnZlci5kZWxheWVkQW5kcm9pZEtleSkge1xuICAgICAgdGhpcy5tZWFzdXJlU2NoZWR1bGVkID0gLTEsIHRoaXMucmVxdWVzdE1lYXN1cmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5tZWFzdXJlU2NoZWR1bGVkID0gMCwgZSAmJiB0aGlzLm9ic2VydmVyLmZvcmNlRmx1c2goKTtcbiAgICBsZXQgbiA9IG51bGwsIHIgPSB0aGlzLnNjcm9sbERPTSwgaSA9IHIuc2Nyb2xsVG9wICogdGhpcy5zY2FsZVksIHsgc2Nyb2xsQW5jaG9yUG9zOiBzLCBzY3JvbGxBbmNob3JIZWlnaHQ6IG8gfSA9IHRoaXMudmlld1N0YXRlO1xuICAgIE1hdGguYWJzKGkgLSB0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUb3ApID4gMSAmJiAobyA9IC0xKSwgdGhpcy52aWV3U3RhdGUuc2Nyb2xsQW5jaG9ySGVpZ2h0ID0gLTE7XG4gICAgdHJ5IHtcbiAgICAgIGZvciAobGV0IGEgPSAwOyA7IGErKykge1xuICAgICAgICBpZiAobyA8IDApXG4gICAgICAgICAgaWYgKHRrKHIpKVxuICAgICAgICAgICAgcyA9IC0xLCBvID0gdGhpcy52aWV3U3RhdGUuaGVpZ2h0TWFwLmhlaWdodDtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBoID0gdGhpcy52aWV3U3RhdGUuc2Nyb2xsQW5jaG9yQXQoaSk7XG4gICAgICAgICAgICBzID0gaC5mcm9tLCBvID0gaC50b3A7XG4gICAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlID0gMTtcbiAgICAgICAgbGV0IGwgPSB0aGlzLnZpZXdTdGF0ZS5tZWFzdXJlKHRoaXMpO1xuICAgICAgICBpZiAoIWwgJiYgIXRoaXMubWVhc3VyZVJlcXVlc3RzLmxlbmd0aCAmJiB0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUYXJnZXQgPT0gbnVsbClcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKGEgPiA1KSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKHRoaXMubWVhc3VyZVJlcXVlc3RzLmxlbmd0aCA/IFwiTWVhc3VyZSBsb29wIHJlc3RhcnRlZCBtb3JlIHRoYW4gNSB0aW1lc1wiIDogXCJWaWV3cG9ydCBmYWlsZWQgdG8gc3RhYmlsaXplXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjID0gW107XG4gICAgICAgIGwgJiA0IHx8IChbdGhpcy5tZWFzdXJlUmVxdWVzdHMsIGNdID0gW2MsIHRoaXMubWVhc3VyZVJlcXVlc3RzXSk7XG4gICAgICAgIGxldCB1ID0gYy5tYXAoKGgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGgucmVhZCh0aGlzKTtcbiAgICAgICAgICB9IGNhdGNoIChwKSB7XG4gICAgICAgICAgICByZXR1cm4gaHIodGhpcy5zdGF0ZSwgcCksIHd2O1xuICAgICAgICAgIH1cbiAgICAgICAgfSksIGQgPSBXdS5jcmVhdGUodGhpcywgdGhpcy5zdGF0ZSwgW10pLCBmID0gITE7XG4gICAgICAgIGQuZmxhZ3MgfD0gbCwgbiA/IG4uZmxhZ3MgfD0gbCA6IG4gPSBkLCB0aGlzLnVwZGF0ZVN0YXRlID0gMiwgZC5lbXB0eSB8fCAodGhpcy51cGRhdGVQbHVnaW5zKGQpLCB0aGlzLmlucHV0U3RhdGUudXBkYXRlKGQpLCB0aGlzLnVwZGF0ZUF0dHJzKCksIGYgPSB0aGlzLmRvY1ZpZXcudXBkYXRlKGQpKTtcbiAgICAgICAgZm9yIChsZXQgaCA9IDA7IGggPCBjLmxlbmd0aDsgaCsrKVxuICAgICAgICAgIGlmICh1W2hdICE9IHd2KVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgbGV0IHAgPSBjW2hdO1xuICAgICAgICAgICAgICBwLndyaXRlICYmIHAud3JpdGUodVtoXSwgdGhpcyk7XG4gICAgICAgICAgICB9IGNhdGNoIChwKSB7XG4gICAgICAgICAgICAgIGhyKHRoaXMuc3RhdGUsIHApO1xuICAgICAgICAgICAgfVxuICAgICAgICBpZiAoZiAmJiB0aGlzLmRvY1ZpZXcudXBkYXRlU2VsZWN0aW9uKCEwKSwgIWQudmlld3BvcnRDaGFuZ2VkICYmIHRoaXMubWVhc3VyZVJlcXVlc3RzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgaWYgKHRoaXMudmlld1N0YXRlLmVkaXRvckhlaWdodClcbiAgICAgICAgICAgIGlmICh0aGlzLnZpZXdTdGF0ZS5zY3JvbGxUYXJnZXQpIHtcbiAgICAgICAgICAgICAgdGhpcy5kb2NWaWV3LnNjcm9sbEludG9WaWV3KHRoaXMudmlld1N0YXRlLnNjcm9sbFRhcmdldCksIHRoaXMudmlld1N0YXRlLnNjcm9sbFRhcmdldCA9IG51bGwsIG8gPSAtMTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsZXQgcCA9IChzIDwgMCA/IHRoaXMudmlld1N0YXRlLmhlaWdodE1hcC5oZWlnaHQgOiB0aGlzLnZpZXdTdGF0ZS5saW5lQmxvY2tBdChzKS50b3ApIC0gbztcbiAgICAgICAgICAgICAgaWYgKHAgPiAxIHx8IHAgPCAtMSkge1xuICAgICAgICAgICAgICAgIGkgPSBpICsgcCwgci5zY3JvbGxUb3AgPSBpIC8gdGhpcy5zY2FsZVksIG8gPSAtMTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMudXBkYXRlU3RhdGUgPSAwLCB0aGlzLm1lYXN1cmVTY2hlZHVsZWQgPSAtMTtcbiAgICB9XG4gICAgaWYgKG4gJiYgIW4uZW1wdHkpXG4gICAgICBmb3IgKGxldCBhIG9mIHRoaXMuc3RhdGUuZmFjZXQoZnApKVxuICAgICAgICBhKG4pO1xuICB9XG4gIC8qKlxuICBHZXQgdGhlIENTUyBjbGFzc2VzIGZvciB0aGUgY3VycmVudGx5IGFjdGl2ZSBlZGl0b3IgdGhlbWVzLlxuICAqL1xuICBnZXQgdGhlbWVDbGFzc2VzKCkge1xuICAgIHJldHVybiBncCArIFwiIFwiICsgKHRoaXMuc3RhdGUuZmFjZXQoT3ApID8gamsgOiBYaykgKyBcIiBcIiArIHRoaXMuc3RhdGUuZmFjZXQoQWMpO1xuICB9XG4gIHVwZGF0ZUF0dHJzKCkge1xuICAgIGxldCBlID0ga3YodGhpcywga2ssIHtcbiAgICAgIGNsYXNzOiBcImNtLWVkaXRvclwiICsgKHRoaXMuaGFzRm9jdXMgPyBcIiBjbS1mb2N1c2VkIFwiIDogXCIgXCIpICsgdGhpcy50aGVtZUNsYXNzZXNcbiAgICB9KSwgbiA9IHtcbiAgICAgIHNwZWxsY2hlY2s6IFwiZmFsc2VcIixcbiAgICAgIGF1dG9jb3JyZWN0OiBcIm9mZlwiLFxuICAgICAgYXV0b2NhcGl0YWxpemU6IFwib2ZmXCIsXG4gICAgICB0cmFuc2xhdGU6IFwibm9cIixcbiAgICAgIGNvbnRlbnRlZGl0YWJsZTogdGhpcy5zdGF0ZS5mYWNldChZZCkgPyBcInRydWVcIiA6IFwiZmFsc2VcIixcbiAgICAgIGNsYXNzOiBcImNtLWNvbnRlbnRcIixcbiAgICAgIHN0eWxlOiBgJHtkZS50YWJTaXplfTogJHt0aGlzLnN0YXRlLnRhYlNpemV9YCxcbiAgICAgIHJvbGU6IFwidGV4dGJveFwiLFxuICAgICAgXCJhcmlhLW11bHRpbGluZVwiOiBcInRydWVcIlxuICAgIH07XG4gICAgdGhpcy5zdGF0ZS5yZWFkT25seSAmJiAobltcImFyaWEtcmVhZG9ubHlcIl0gPSBcInRydWVcIiksIGt2KHRoaXMsIGNnLCBuKTtcbiAgICBsZXQgciA9IHRoaXMub2JzZXJ2ZXIuaWdub3JlKCgpID0+IHtcbiAgICAgIGxldCBpID0gYXAodGhpcy5jb250ZW50RE9NLCB0aGlzLmNvbnRlbnRBdHRycywgbiksIHMgPSBhcCh0aGlzLmRvbSwgdGhpcy5lZGl0b3JBdHRycywgZSk7XG4gICAgICByZXR1cm4gaSB8fCBzO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmVkaXRvckF0dHJzID0gZSwgdGhpcy5jb250ZW50QXR0cnMgPSBuLCByO1xuICB9XG4gIHNob3dBbm5vdW5jZW1lbnRzKGUpIHtcbiAgICBsZXQgbiA9ICEwO1xuICAgIGZvciAobGV0IHIgb2YgZSlcbiAgICAgIGZvciAobGV0IGkgb2Ygci5lZmZlY3RzKVxuICAgICAgICBpZiAoaS5pcyhTZS5hbm5vdW5jZSkpIHtcbiAgICAgICAgICBuICYmICh0aGlzLmFubm91bmNlRE9NLnRleHRDb250ZW50ID0gXCJcIiksIG4gPSAhMTtcbiAgICAgICAgICBsZXQgcyA9IHRoaXMuYW5ub3VuY2VET00uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7XG4gICAgICAgICAgcy50ZXh0Q29udGVudCA9IGkudmFsdWU7XG4gICAgICAgIH1cbiAgfVxuICBtb3VudFN0eWxlcygpIHtcbiAgICB0aGlzLnN0eWxlTW9kdWxlcyA9IHRoaXMuc3RhdGUuZmFjZXQoTmEpO1xuICAgIGxldCBlID0gdGhpcy5zdGF0ZS5mYWNldChTZS5jc3BOb25jZSk7XG4gICAgc3MubW91bnQodGhpcy5yb290LCB0aGlzLnN0eWxlTW9kdWxlcy5jb25jYXQoQTUpLnJldmVyc2UoKSwgZSA/IHsgbm9uY2U6IGUgfSA6IHZvaWQgMCk7XG4gIH1cbiAgcmVhZE1lYXN1cmVkKCkge1xuICAgIGlmICh0aGlzLnVwZGF0ZVN0YXRlID09IDIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWFkaW5nIHRoZSBlZGl0b3IgbGF5b3V0IGlzbid0IGFsbG93ZWQgZHVyaW5nIGFuIHVwZGF0ZVwiKTtcbiAgICB0aGlzLnVwZGF0ZVN0YXRlID09IDAgJiYgdGhpcy5tZWFzdXJlU2NoZWR1bGVkID4gLTEgJiYgdGhpcy5tZWFzdXJlKCExKTtcbiAgfVxuICAvKipcbiAgU2NoZWR1bGUgYSBsYXlvdXQgbWVhc3VyZW1lbnQsIG9wdGlvbmFsbHkgcHJvdmlkaW5nIGNhbGxiYWNrcyB0b1xuICBkbyBjdXN0b20gRE9NIG1lYXN1cmluZyBmb2xsb3dlZCBieSBhIERPTSB3cml0ZSBwaGFzZS4gVXNpbmdcbiAgdGhpcyBpcyBwcmVmZXJhYmxlIHJlYWRpbmcgRE9NIGxheW91dCBkaXJlY3RseSBmcm9tLCBmb3JcbiAgZXhhbXBsZSwgYW4gZXZlbnQgaGFuZGxlciwgYmVjYXVzZSBpdCdsbCBtYWtlIHN1cmUgbWVhc3VyaW5nIGFuZFxuICBkcmF3aW5nIGRvbmUgYnkgb3RoZXIgY29tcG9uZW50cyBpcyBzeW5jaHJvbml6ZWQsIGF2b2lkaW5nXG4gIHVubmVjZXNzYXJ5IERPTSBsYXlvdXQgY29tcHV0YXRpb25zLlxuICAqL1xuICByZXF1ZXN0TWVhc3VyZShlKSB7XG4gICAgaWYgKHRoaXMubWVhc3VyZVNjaGVkdWxlZCA8IDAgJiYgKHRoaXMubWVhc3VyZVNjaGVkdWxlZCA9IHRoaXMud2luLnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLm1lYXN1cmUoKSkpLCBlKSB7XG4gICAgICBpZiAodGhpcy5tZWFzdXJlUmVxdWVzdHMuaW5kZXhPZihlKSA+IC0xKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAoZS5rZXkgIT0gbnVsbCkge1xuICAgICAgICBmb3IgKGxldCBuID0gMDsgbiA8IHRoaXMubWVhc3VyZVJlcXVlc3RzLmxlbmd0aDsgbisrKVxuICAgICAgICAgIGlmICh0aGlzLm1lYXN1cmVSZXF1ZXN0c1tuXS5rZXkgPT09IGUua2V5KSB7XG4gICAgICAgICAgICB0aGlzLm1lYXN1cmVSZXF1ZXN0c1tuXSA9IGU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5tZWFzdXJlUmVxdWVzdHMucHVzaChlKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gIEdldCB0aGUgdmFsdWUgb2YgYSBzcGVjaWZpYyBwbHVnaW4sIGlmIHByZXNlbnQuIE5vdGUgdGhhdFxuICBwbHVnaW5zIHRoYXQgY3Jhc2ggY2FuIGJlIGRyb3BwZWQgZnJvbSBhIHZpZXcsIHNvIGV2ZW4gd2hlbiB5b3VcbiAga25vdyB5b3UgcmVnaXN0ZXJlZCBhIGdpdmVuIHBsdWdpbiwgaXQgaXMgcmVjb21tZW5kZWQgdG8gY2hlY2tcbiAgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGlzIG1ldGhvZC5cbiAgKi9cbiAgcGx1Z2luKGUpIHtcbiAgICBsZXQgbiA9IHRoaXMucGx1Z2luTWFwLmdldChlKTtcbiAgICByZXR1cm4gKG4gPT09IHZvaWQgMCB8fCBuICYmIG4uc3BlYyAhPSBlKSAmJiB0aGlzLnBsdWdpbk1hcC5zZXQoZSwgbiA9IHRoaXMucGx1Z2lucy5maW5kKChyKSA9PiByLnNwZWMgPT0gZSkgfHwgbnVsbCksIG4gJiYgbi51cGRhdGUodGhpcykudmFsdWU7XG4gIH1cbiAgLyoqXG4gIFRoZSB0b3AgcG9zaXRpb24gb2YgdGhlIGRvY3VtZW50LCBpbiBzY3JlZW4gY29vcmRpbmF0ZXMuIFRoaXNcbiAgbWF5IGJlIG5lZ2F0aXZlIHdoZW4gdGhlIGVkaXRvciBpcyBzY3JvbGxlZCBkb3duLiBQb2ludHNcbiAgZGlyZWN0bHkgdG8gdGhlIHRvcCBvZiB0aGUgZmlyc3QgbGluZSwgbm90IGFib3ZlIHRoZSBwYWRkaW5nLlxuICAqL1xuICBnZXQgZG9jdW1lbnRUb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyB0aGlzLnZpZXdTdGF0ZS5wYWRkaW5nVG9wO1xuICB9XG4gIC8qKlxuICBSZXBvcnRzIHRoZSBwYWRkaW5nIGFib3ZlIGFuZCBiZWxvdyB0aGUgZG9jdW1lbnQuXG4gICovXG4gIGdldCBkb2N1bWVudFBhZGRpbmcoKSB7XG4gICAgcmV0dXJuIHsgdG9wOiB0aGlzLnZpZXdTdGF0ZS5wYWRkaW5nVG9wLCBib3R0b206IHRoaXMudmlld1N0YXRlLnBhZGRpbmdCb3R0b20gfTtcbiAgfVxuICAvKipcbiAgSWYgdGhlIGVkaXRvciBpcyB0cmFuc2Zvcm1lZCB3aXRoIENTUywgdGhpcyBwcm92aWRlcyB0aGUgc2NhbGVcbiAgYWxvbmcgdGhlIFggYXhpcy4gT3RoZXJ3aXNlLCBpdCB3aWxsIGp1c3QgYmUgMS4gTm90ZSB0aGF0XG4gIHRyYW5zZm9ybXMgb3RoZXIgdGhhbiB0cmFuc2xhdGlvbiBhbmQgc2NhbGluZyBhcmUgbm90IHN1cHBvcnRlZC5cbiAgKi9cbiAgZ2V0IHNjYWxlWCgpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3U3RhdGUuc2NhbGVYO1xuICB9XG4gIC8qKlxuICBQcm92aWRlIHRoZSBDU1MgdHJhbnNmb3JtZWQgc2NhbGUgYWxvbmcgdGhlIFkgYXhpcy5cbiAgKi9cbiAgZ2V0IHNjYWxlWSgpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3U3RhdGUuc2NhbGVZO1xuICB9XG4gIC8qKlxuICBGaW5kIHRoZSB0ZXh0IGxpbmUgb3IgYmxvY2sgd2lkZ2V0IGF0IHRoZSBnaXZlbiB2ZXJ0aWNhbFxuICBwb3NpdGlvbiAod2hpY2ggaXMgaW50ZXJwcmV0ZWQgYXMgcmVsYXRpdmUgdG8gdGhlIFt0b3Agb2YgdGhlXG4gIGRvY3VtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5kb2N1bWVudFRvcCkpLlxuICAqL1xuICBlbGVtZW50QXRIZWlnaHQoZSkge1xuICAgIHJldHVybiB0aGlzLnJlYWRNZWFzdXJlZCgpLCB0aGlzLnZpZXdTdGF0ZS5lbGVtZW50QXRIZWlnaHQoZSk7XG4gIH1cbiAgLyoqXG4gIEZpbmQgdGhlIGxpbmUgYmxvY2sgKHNlZVxuICBbYGxpbmVCbG9ja0F0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubGluZUJsb2NrQXQpIGF0IHRoZSBnaXZlblxuICBoZWlnaHQsIGFnYWluIGludGVycHJldGVkIHJlbGF0aXZlIHRvIHRoZSBbdG9wIG9mIHRoZVxuICBkb2N1bWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZG9jdW1lbnRUb3ApLlxuICAqL1xuICBsaW5lQmxvY2tBdEhlaWdodChlKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZE1lYXN1cmVkKCksIHRoaXMudmlld1N0YXRlLmxpbmVCbG9ja0F0SGVpZ2h0KGUpO1xuICB9XG4gIC8qKlxuICBHZXQgdGhlIGV4dGVudCBhbmQgdmVydGljYWwgcG9zaXRpb24gb2YgYWxsIFtsaW5lXG4gIGJsb2Nrc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcubGluZUJsb2NrQXQpIGluIHRoZSB2aWV3cG9ydC4gUG9zaXRpb25zXG4gIGFyZSByZWxhdGl2ZSB0byB0aGUgW3RvcCBvZiB0aGVcbiAgZG9jdW1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRvY3VtZW50VG9wKTtcbiAgKi9cbiAgZ2V0IHZpZXdwb3J0TGluZUJsb2NrcygpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3U3RhdGUudmlld3BvcnRMaW5lcztcbiAgfVxuICAvKipcbiAgRmluZCB0aGUgbGluZSBibG9jayBhcm91bmQgdGhlIGdpdmVuIGRvY3VtZW50IHBvc2l0aW9uLiBBIGxpbmVcbiAgYmxvY2sgaXMgYSByYW5nZSBkZWxpbWl0ZWQgb24gYm90aCBzaWRlcyBieSBlaXRoZXIgYVxuICBub24tW2hpZGRlbl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb25ecmVwbGFjZSkgbGluZSBicmVha3MsIG9yIHRoZVxuICBzdGFydC9lbmQgb2YgdGhlIGRvY3VtZW50LiBJdCB3aWxsIHVzdWFsbHkganVzdCBob2xkIGEgbGluZSBvZlxuICB0ZXh0LCBidXQgbWF5IGJlIGJyb2tlbiBpbnRvIG11bHRpcGxlIHRleHRibG9ja3MgYnkgYmxvY2tcbiAgd2lkZ2V0cy5cbiAgKi9cbiAgbGluZUJsb2NrQXQoZSkge1xuICAgIHJldHVybiB0aGlzLnZpZXdTdGF0ZS5saW5lQmxvY2tBdChlKTtcbiAgfVxuICAvKipcbiAgVGhlIGVkaXRvcidzIHRvdGFsIGNvbnRlbnQgaGVpZ2h0LlxuICAqL1xuICBnZXQgY29udGVudEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3U3RhdGUuY29udGVudEhlaWdodDtcbiAgfVxuICAvKipcbiAgTW92ZSBhIGN1cnNvciBwb3NpdGlvbiBieSBbZ3JhcGhlbWVcbiAgY2x1c3Rlcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5maW5kQ2x1c3RlckJyZWFrKS4gYGZvcndhcmRgIGRldGVybWluZXMgd2hldGhlclxuICB0aGUgbW90aW9uIGlzIGF3YXkgZnJvbSB0aGUgbGluZSBzdGFydCwgb3IgdG93YXJkcyBpdC4gSW5cbiAgYmlkaXJlY3Rpb25hbCB0ZXh0LCB0aGUgbGluZSBpcyB0cmF2ZXJzZWQgaW4gdmlzdWFsIG9yZGVyLCB1c2luZ1xuICB0aGUgZWRpdG9yJ3MgW3RleHQgZGlyZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy50ZXh0RGlyZWN0aW9uKS5cbiAgV2hlbiB0aGUgc3RhcnQgcG9zaXRpb24gd2FzIHRoZSBsYXN0IG9uZSBvbiB0aGUgbGluZSwgdGhlXG4gIHJldHVybmVkIHBvc2l0aW9uIHdpbGwgYmUgYWNyb3NzIHRoZSBsaW5lIGJyZWFrLiBJZiB0aGVyZSBpcyBub1xuICBmdXJ0aGVyIGxpbmUsIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiBpcyByZXR1cm5lZC5cbiAgXG4gIEJ5IGRlZmF1bHQsIHRoaXMgbWV0aG9kIG1vdmVzIG92ZXIgYSBzaW5nbGUgY2x1c3Rlci4gVGhlXG4gIG9wdGlvbmFsIGBieWAgYXJndW1lbnQgY2FuIGJlIHVzZWQgdG8gbW92ZSBhY3Jvc3MgbW9yZS4gSXQgd2lsbFxuICBiZSBjYWxsZWQgd2l0aCB0aGUgZmlyc3QgY2x1c3RlciBhcyBhcmd1bWVudCwgYW5kIHNob3VsZCByZXR1cm5cbiAgYSBwcmVkaWNhdGUgdGhhdCBkZXRlcm1pbmVzLCBmb3IgZWFjaCBzdWJzZXF1ZW50IGNsdXN0ZXIsXG4gIHdoZXRoZXIgaXQgc2hvdWxkIGFsc28gYmUgbW92ZWQgb3Zlci5cbiAgKi9cbiAgbW92ZUJ5Q2hhcihlLCBuLCByKSB7XG4gICAgcmV0dXJuIFRmKHRoaXMsIGUsIHN2KHRoaXMsIGUsIG4sIHIpKTtcbiAgfVxuICAvKipcbiAgTW92ZSBhIGN1cnNvciBwb3NpdGlvbiBhY3Jvc3MgdGhlIG5leHQgZ3JvdXAgb2YgZWl0aGVyXG4gIFtsZXR0ZXJzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmNoYXJDYXRlZ29yaXplcikgb3Igbm9uLWxldHRlclxuICBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzLlxuICAqL1xuICBtb3ZlQnlHcm91cChlLCBuKSB7XG4gICAgcmV0dXJuIFRmKHRoaXMsIGUsIHN2KHRoaXMsIGUsIG4sIChyKSA9PiB0NSh0aGlzLCBlLmhlYWQsIHIpKSk7XG4gIH1cbiAgLyoqXG4gIEdldCB0aGUgY3Vyc29yIHBvc2l0aW9uIHZpc3VhbGx5IGF0IHRoZSBzdGFydCBvciBlbmQgb2YgYSBsaW5lLlxuICBOb3RlIHRoYXQgdGhpcyBtYXkgZGlmZmVyIGZyb20gdGhlIF9sb2dpY2FsXyBwb3NpdGlvbiBhdCBpdHNcbiAgc3RhcnQgb3IgZW5kICh3aGljaCBpcyBzaW1wbHkgYXQgYGxpbmUuZnJvbWAvYGxpbmUudG9gKSBpZiB0ZXh0XG4gIGF0IHRoZSBzdGFydCBvciBlbmQgZ29lcyBhZ2FpbnN0IHRoZSBsaW5lJ3MgYmFzZSB0ZXh0IGRpcmVjdGlvbi5cbiAgKi9cbiAgdmlzdWFsTGluZVNpZGUoZSwgbikge1xuICAgIGxldCByID0gdGhpcy5iaWRpU3BhbnMoZSksIGkgPSB0aGlzLnRleHREaXJlY3Rpb25BdChlLmZyb20pLCBzID0gcltuID8gci5sZW5ndGggLSAxIDogMF07XG4gICAgcmV0dXJuIGFlLmN1cnNvcihzLnNpZGUobiwgaSkgKyBlLmZyb20sIHMuZm9yd2FyZCghbiwgaSkgPyAxIDogLTEpO1xuICB9XG4gIC8qKlxuICBNb3ZlIHRvIHRoZSBuZXh0IGxpbmUgYm91bmRhcnkgaW4gdGhlIGdpdmVuIGRpcmVjdGlvbi4gSWZcbiAgYGluY2x1ZGVXcmFwYCBpcyB0cnVlLCBsaW5lIHdyYXBwaW5nIGlzIG9uLCBhbmQgdGhlcmUgaXMgYVxuICBmdXJ0aGVyIHdyYXAgcG9pbnQgb24gdGhlIGN1cnJlbnQgbGluZSwgdGhlIHdyYXAgcG9pbnQgd2lsbCBiZVxuICByZXR1cm5lZC4gT3RoZXJ3aXNlIHRoaXMgZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHN0YXJ0IG9yIGVuZFxuICBvZiB0aGUgbGluZS5cbiAgKi9cbiAgbW92ZVRvTGluZUJvdW5kYXJ5KGUsIG4sIHIgPSAhMCkge1xuICAgIHJldHVybiBlNSh0aGlzLCBlLCBuLCByKTtcbiAgfVxuICAvKipcbiAgTW92ZSBhIGN1cnNvciBwb3NpdGlvbiB2ZXJ0aWNhbGx5LiBXaGVuIGBkaXN0YW5jZWAgaXNuJ3QgZ2l2ZW4sXG4gIGl0IGRlZmF1bHRzIHRvIG1vdmluZyB0byB0aGUgbmV4dCBsaW5lIChpbmNsdWRpbmcgd3JhcHBlZFxuICBsaW5lcykuIE90aGVyd2lzZSwgYGRpc3RhbmNlYCBzaG91bGQgcHJvdmlkZSBhIHBvc2l0aXZlIGRpc3RhbmNlXG4gIGluIHBpeGVscy5cbiAgXG4gIFdoZW4gYHN0YXJ0YCBoYXMgYVxuICBbYGdvYWxDb2x1bW5gXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvblJhbmdlLmdvYWxDb2x1bW4pLCB0aGUgdmVydGljYWxcbiAgbW90aW9uIHdpbGwgdXNlIHRoYXQgYXMgYSB0YXJnZXQgaG9yaXpvbnRhbCBwb3NpdGlvbi4gT3RoZXJ3aXNlLFxuICB0aGUgY3Vyc29yJ3Mgb3duIGhvcml6b250YWwgcG9zaXRpb24gaXMgdXNlZC4gVGhlIHJldHVybmVkXG4gIGN1cnNvciB3aWxsIGhhdmUgaXRzIGdvYWwgY29sdW1uIHNldCB0byB3aGljaGV2ZXIgY29sdW1uIHdhc1xuICB1c2VkLlxuICAqL1xuICBtb3ZlVmVydGljYWxseShlLCBuLCByKSB7XG4gICAgcmV0dXJuIFRmKHRoaXMsIGUsIG41KHRoaXMsIGUsIG4sIHIpKTtcbiAgfVxuICAvKipcbiAgRmluZCB0aGUgRE9NIHBhcmVudCBub2RlIGFuZCBvZmZzZXQgKGNoaWxkIG9mZnNldCBpZiBgbm9kZWAgaXNcbiAgYW4gZWxlbWVudCwgY2hhcmFjdGVyIG9mZnNldCB3aGVuIGl0IGlzIGEgdGV4dCBub2RlKSBhdCB0aGVcbiAgZ2l2ZW4gZG9jdW1lbnQgcG9zaXRpb24uXG4gIFxuICBOb3RlIHRoYXQgZm9yIHBvc2l0aW9ucyB0aGF0IGFyZW4ndCBjdXJyZW50bHkgaW5cbiAgYHZpc2libGVSYW5nZXNgLCB0aGUgcmVzdWx0aW5nIERPTSBwb3NpdGlvbiBpc24ndCBuZWNlc3NhcmlseVxuICBtZWFuaW5nZnVsIChpdCBtYXkganVzdCBwb2ludCBiZWZvcmUgb3IgYWZ0ZXIgYSBwbGFjZWhvbGRlclxuICBlbGVtZW50KS5cbiAgKi9cbiAgZG9tQXRQb3MoZSkge1xuICAgIHJldHVybiB0aGlzLmRvY1ZpZXcuZG9tQXRQb3MoZSk7XG4gIH1cbiAgLyoqXG4gIEZpbmQgdGhlIGRvY3VtZW50IHBvc2l0aW9uIGF0IHRoZSBnaXZlbiBET00gbm9kZS4gQ2FuIGJlIHVzZWZ1bFxuICBmb3IgYXNzb2NpYXRpbmcgcG9zaXRpb25zIHdpdGggRE9NIGV2ZW50cy4gV2lsbCByYWlzZSBhbiBlcnJvclxuICB3aGVuIGBub2RlYCBpc24ndCBwYXJ0IG9mIHRoZSBlZGl0b3IgY29udGVudC5cbiAgKi9cbiAgcG9zQXRET00oZSwgbiA9IDApIHtcbiAgICByZXR1cm4gdGhpcy5kb2NWaWV3LnBvc0Zyb21ET00oZSwgbik7XG4gIH1cbiAgcG9zQXRDb29yZHMoZSwgbiA9ICEwKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZE1lYXN1cmVkKCksIFFrKHRoaXMsIGUsIG4pO1xuICB9XG4gIC8qKlxuICBHZXQgdGhlIHNjcmVlbiBjb29yZGluYXRlcyBhdCB0aGUgZ2l2ZW4gZG9jdW1lbnQgcG9zaXRpb24uXG4gIGBzaWRlYCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGNvb3JkaW5hdGVzIGFyZSBiYXNlZCBvbiB0aGVcbiAgZWxlbWVudCBiZWZvcmUgKC0xKSBvciBhZnRlciAoMSkgdGhlIHBvc2l0aW9uIChpZiBubyBlbGVtZW50IGlzXG4gIGF2YWlsYWJsZSBvbiB0aGUgZ2l2ZW4gc2lkZSwgdGhlIG1ldGhvZCB3aWxsIHRyYW5zcGFyZW50bHkgdXNlXG4gIGFub3RoZXIgc3RyYXRlZ3kgdG8gZ2V0IHJlYXNvbmFibGUgY29vcmRpbmF0ZXMpLlxuICAqL1xuICBjb29yZHNBdFBvcyhlLCBuID0gMSkge1xuICAgIHRoaXMucmVhZE1lYXN1cmVkKCk7XG4gICAgbGV0IHIgPSB0aGlzLmRvY1ZpZXcuY29vcmRzQXQoZSwgbik7XG4gICAgaWYgKCFyIHx8IHIubGVmdCA9PSByLnJpZ2h0KVxuICAgICAgcmV0dXJuIHI7XG4gICAgbGV0IGkgPSB0aGlzLnN0YXRlLmRvYy5saW5lQXQoZSksIHMgPSB0aGlzLmJpZGlTcGFucyhpKSwgbyA9IHNbQmkuZmluZChzLCBlIC0gaS5mcm9tLCAtMSwgbildO1xuICAgIHJldHVybiBzZyhyLCBvLmRpciA9PSBRdC5MVFIgPT0gbiA+IDApO1xuICB9XG4gIC8qKlxuICBSZXR1cm4gdGhlIHJlY3RhbmdsZSBhcm91bmQgYSBnaXZlbiBjaGFyYWN0ZXIuIElmIGBwb3NgIGRvZXMgbm90XG4gIHBvaW50IGluIGZyb250IG9mIGEgY2hhcmFjdGVyIHRoYXQgaXMgaW4gdGhlIHZpZXdwb3J0IGFuZFxuICByZW5kZXJlZCAoaS5lLiBub3QgcmVwbGFjZWQsIG5vdCBhIGxpbmUgYnJlYWspLCB0aGlzIHdpbGwgcmV0dXJuXG4gIG51bGwuIEZvciBzcGFjZSBjaGFyYWN0ZXJzIHRoYXQgYXJlIGEgbGluZSB3cmFwIHBvaW50LCB0aGlzIHdpbGxcbiAgcmV0dXJuIHRoZSBwb3NpdGlvbiBiZWZvcmUgdGhlIGxpbmUgYnJlYWsuXG4gICovXG4gIGNvb3Jkc0ZvckNoYXIoZSkge1xuICAgIHJldHVybiB0aGlzLnJlYWRNZWFzdXJlZCgpLCB0aGlzLmRvY1ZpZXcuY29vcmRzRm9yQ2hhcihlKTtcbiAgfVxuICAvKipcbiAgVGhlIGRlZmF1bHQgd2lkdGggb2YgYSBjaGFyYWN0ZXIgaW4gdGhlIGVkaXRvci4gTWF5IG5vdFxuICBhY2N1cmF0ZWx5IHJlZmxlY3QgdGhlIHdpZHRoIG9mIGFsbCBjaGFyYWN0ZXJzIChnaXZlbiB2YXJpYWJsZVxuICB3aWR0aCBmb250cyBvciBzdHlsaW5nIG9mIGludmlkaWR1YWwgcmFuZ2VzKS5cbiAgKi9cbiAgZ2V0IGRlZmF1bHRDaGFyYWN0ZXJXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3U3RhdGUuaGVpZ2h0T3JhY2xlLmNoYXJXaWR0aDtcbiAgfVxuICAvKipcbiAgVGhlIGRlZmF1bHQgaGVpZ2h0IG9mIGEgbGluZSBpbiB0aGUgZWRpdG9yLiBNYXkgbm90IGJlIGFjY3VyYXRlXG4gIGZvciBhbGwgbGluZXMuXG4gICovXG4gIGdldCBkZWZhdWx0TGluZUhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3U3RhdGUuaGVpZ2h0T3JhY2xlLmxpbmVIZWlnaHQ7XG4gIH1cbiAgLyoqXG4gIFRoZSB0ZXh0IGRpcmVjdGlvblxuICAoW2BkaXJlY3Rpb25gXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvZGlyZWN0aW9uKVxuICBDU1MgcHJvcGVydHkpIG9mIHRoZSBlZGl0b3IncyBjb250ZW50IGVsZW1lbnQuXG4gICovXG4gIGdldCB0ZXh0RGlyZWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnZpZXdTdGF0ZS5kZWZhdWx0VGV4dERpcmVjdGlvbjtcbiAgfVxuICAvKipcbiAgRmluZCB0aGUgdGV4dCBkaXJlY3Rpb24gb2YgdGhlIGJsb2NrIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiwgYXNcbiAgYXNzaWduZWQgYnkgQ1NTLiBJZlxuICBbYHBlckxpbmVUZXh0RGlyZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdecGVyTGluZVRleHREaXJlY3Rpb24pXG4gIGlzbid0IGVuYWJsZWQsIG9yIHRoZSBnaXZlbiBwb3NpdGlvbiBpcyBvdXRzaWRlIG9mIHRoZSB2aWV3cG9ydCxcbiAgdGhpcyB3aWxsIGFsd2F5cyByZXR1cm4gdGhlIHNhbWUgYXNcbiAgW2B0ZXh0RGlyZWN0aW9uYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcudGV4dERpcmVjdGlvbikuIE5vdGUgdGhhdFxuICB0aGlzIG1heSB0cmlnZ2VyIGEgRE9NIGxheW91dC5cbiAgKi9cbiAgdGV4dERpcmVjdGlvbkF0KGUpIHtcbiAgICByZXR1cm4gIXRoaXMuc3RhdGUuZmFjZXQod2spIHx8IGUgPCB0aGlzLnZpZXdwb3J0LmZyb20gfHwgZSA+IHRoaXMudmlld3BvcnQudG8gPyB0aGlzLnRleHREaXJlY3Rpb24gOiAodGhpcy5yZWFkTWVhc3VyZWQoKSwgdGhpcy5kb2NWaWV3LnRleHREaXJlY3Rpb25BdChlKSk7XG4gIH1cbiAgLyoqXG4gIFdoZXRoZXIgdGhpcyBlZGl0b3IgW3dyYXBzIGxpbmVzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5saW5lV3JhcHBpbmcpXG4gIChhcyBkZXRlcm1pbmVkIGJ5IHRoZVxuICBbYHdoaXRlLXNwYWNlYF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL3doaXRlLXNwYWNlKVxuICBDU1MgcHJvcGVydHkgb2YgaXRzIGNvbnRlbnQgZWxlbWVudCkuXG4gICovXG4gIGdldCBsaW5lV3JhcHBpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlld1N0YXRlLmhlaWdodE9yYWNsZS5saW5lV3JhcHBpbmc7XG4gIH1cbiAgLyoqXG4gIFJldHVybnMgdGhlIGJpZGlyZWN0aW9uYWwgdGV4dCBzdHJ1Y3R1cmUgb2YgdGhlIGdpdmVuIGxpbmVcbiAgKHdoaWNoIHNob3VsZCBiZSBpbiB0aGUgY3VycmVudCBkb2N1bWVudCkgYXMgYW4gYXJyYXkgb2Ygc3BhblxuICBvYmplY3RzLiBUaGUgb3JkZXIgb2YgdGhlc2Ugc3BhbnMgbWF0Y2hlcyB0aGUgW3RleHRcbiAgZGlyZWN0aW9uXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy50ZXh0RGlyZWN0aW9uKeKAlGlmIHRoYXQgaXNcbiAgbGVmdC10by1yaWdodCwgdGhlIGxlZnRtb3N0IHNwYW5zIGNvbWUgZmlyc3QsIG90aGVyd2lzZSB0aGVcbiAgcmlnaHRtb3N0IHNwYW5zIGNvbWUgZmlyc3QuXG4gICovXG4gIGJpZGlTcGFucyhlKSB7XG4gICAgaWYgKGUubGVuZ3RoID4gQjUpXG4gICAgICByZXR1cm4gcGsoZS5sZW5ndGgpO1xuICAgIGxldCBuID0gdGhpcy50ZXh0RGlyZWN0aW9uQXQoZS5mcm9tKSwgcjtcbiAgICBmb3IgKGxldCBzIG9mIHRoaXMuYmlkaUNhY2hlKVxuICAgICAgaWYgKHMuZnJvbSA9PSBlLmZyb20gJiYgcy5kaXIgPT0gbiAmJiAocy5mcmVzaCB8fCBoayhzLmlzb2xhdGVzLCByID0gS2IodGhpcywgZSkpKSlcbiAgICAgICAgcmV0dXJuIHMub3JkZXI7XG4gICAgciB8fCAociA9IEtiKHRoaXMsIGUpKTtcbiAgICBsZXQgaSA9IFpOKGUudGV4dCwgbiwgcik7XG4gICAgcmV0dXJuIHRoaXMuYmlkaUNhY2hlLnB1c2gobmV3IE11KGUuZnJvbSwgZS50bywgbiwgciwgITAsIGkpKSwgaTtcbiAgfVxuICAvKipcbiAgQ2hlY2sgd2hldGhlciB0aGUgZWRpdG9yIGhhcyBmb2N1cy5cbiAgKi9cbiAgZ2V0IGhhc0ZvY3VzKCkge1xuICAgIHZhciBlO1xuICAgIHJldHVybiAodGhpcy5kb20ub3duZXJEb2N1bWVudC5oYXNGb2N1cygpIHx8IGRlLnNhZmFyaSAmJiAoKGUgPSB0aGlzLmlucHV0U3RhdGUpID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUubGFzdENvbnRleHRNZW51KSA+IERhdGUubm93KCkgLSAzZTQpICYmIHRoaXMucm9vdC5hY3RpdmVFbGVtZW50ID09IHRoaXMuY29udGVudERPTTtcbiAgfVxuICAvKipcbiAgUHV0IGZvY3VzIG9uIHRoZSBlZGl0b3IuXG4gICovXG4gIGZvY3VzKCkge1xuICAgIHRoaXMub2JzZXJ2ZXIuaWdub3JlKCgpID0+IHtcbiAgICAgIEp3KHRoaXMuY29udGVudERPTSksIHRoaXMuZG9jVmlldy51cGRhdGVTZWxlY3Rpb24oKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgVXBkYXRlIHRoZSBbcm9vdF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyMjdmlldy5FZGl0b3JWaWV3Q29uZmlnLnJvb3QpIGluIHdoaWNoIHRoZSBlZGl0b3IgbGl2ZXMuIFRoaXMgaXMgb25seVxuICBuZWNlc3Nhcnkgd2hlbiBtb3ZpbmcgdGhlIGVkaXRvcidzIGV4aXN0aW5nIERPTSB0byBhIG5ldyB3aW5kb3cgb3Igc2hhZG93IHJvb3QuXG4gICovXG4gIHNldFJvb3QoZSkge1xuICAgIHRoaXMuX3Jvb3QgIT0gZSAmJiAodGhpcy5fcm9vdCA9IGUsIHRoaXMub2JzZXJ2ZXIuc2V0V2luZG93KChlLm5vZGVUeXBlID09IDkgPyBlIDogZS5vd25lckRvY3VtZW50KS5kZWZhdWx0VmlldyB8fCB3aW5kb3cpLCB0aGlzLm1vdW50U3R5bGVzKCkpO1xuICB9XG4gIC8qKlxuICBDbGVhbiB1cCB0aGlzIGVkaXRvciB2aWV3LCByZW1vdmluZyBpdHMgZWxlbWVudCBmcm9tIHRoZVxuICBkb2N1bWVudCwgdW5yZWdpc3RlcmluZyBldmVudCBoYW5kbGVycywgYW5kIG5vdGlmeWluZ1xuICBwbHVnaW5zLiBUaGUgdmlldyBpbnN0YW5jZSBjYW4gbm8gbG9uZ2VyIGJlIHVzZWQgYWZ0ZXJcbiAgY2FsbGluZyB0aGlzLlxuICAqL1xuICBkZXN0cm95KCkge1xuICAgIGZvciAobGV0IGUgb2YgdGhpcy5wbHVnaW5zKVxuICAgICAgZS5kZXN0cm95KHRoaXMpO1xuICAgIHRoaXMucGx1Z2lucyA9IFtdLCB0aGlzLmlucHV0U3RhdGUuZGVzdHJveSgpLCB0aGlzLmRvY1ZpZXcuZGVzdHJveSgpLCB0aGlzLmRvbS5yZW1vdmUoKSwgdGhpcy5vYnNlcnZlci5kZXN0cm95KCksIHRoaXMubWVhc3VyZVNjaGVkdWxlZCA+IC0xICYmIHRoaXMud2luLmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMubWVhc3VyZVNjaGVkdWxlZCksIHRoaXMuZGVzdHJveWVkID0gITA7XG4gIH1cbiAgLyoqXG4gIFJldHVybnMgYW4gZWZmZWN0IHRoYXQgY2FuIGJlXG4gIFthZGRlZF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvblNwZWMuZWZmZWN0cykgdG8gYSB0cmFuc2FjdGlvbiB0b1xuICBjYXVzZSBpdCB0byBzY3JvbGwgdGhlIGdpdmVuIHBvc2l0aW9uIG9yIHJhbmdlIGludG8gdmlldy5cbiAgKi9cbiAgc3RhdGljIHNjcm9sbEludG9WaWV3KGUsIG4gPSB7fSkge1xuICAgIHJldHVybiBfYy5vZihuZXcgRW8odHlwZW9mIGUgPT0gXCJudW1iZXJcIiA/IGFlLmN1cnNvcihlKSA6IGUsIG4ueSwgbi54LCBuLnlNYXJnaW4sIG4ueE1hcmdpbikpO1xuICB9XG4gIC8qKlxuICBSZXR1cm4gYW4gZWZmZWN0IHRoYXQgcmVzZXRzIHRoZSBlZGl0b3IgdG8gaXRzIGN1cnJlbnQgKGF0IHRoZVxuICB0aW1lIHRoaXMgbWV0aG9kIHdhcyBjYWxsZWQpIHNjcm9sbCBwb3NpdGlvbi4gTm90ZSB0aGF0IHRoaXNcbiAgb25seSBhZmZlY3RzIHRoZSBlZGl0b3IncyBvd24gc2Nyb2xsYWJsZSBlbGVtZW50LCBub3QgcGFyZW50cy5cbiAgU2VlIGFsc29cbiAgW2BFZGl0b3JWaWV3Q29uZmlnLnNjcm9sbFRvYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdDb25maWcuc2Nyb2xsVG8pLlxuICBcbiAgVGhlIGVmZmVjdCBzaG91bGQgYmUgdXNlZCB3aXRoIGEgZG9jdW1lbnQgaWRlbnRpY2FsIHRvIHRoZSBvbmVcbiAgaXQgd2FzIGNyZWF0ZWQgZm9yLiBGYWlsaW5nIHRvIGRvIHNvIGlzIG5vdCBhbiBlcnJvciwgYnV0IG1heVxuICBub3Qgc2Nyb2xsIHRvIHRoZSBleHBlY3RlZCBwb3NpdGlvbi4gWW91IGNhblxuICBbbWFwXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRWZmZWN0Lm1hcCkgdGhlIGVmZmVjdCB0byBhY2NvdW50IGZvciBjaGFuZ2VzLlxuICAqL1xuICBzY3JvbGxTbmFwc2hvdCgpIHtcbiAgICBsZXQgeyBzY3JvbGxUb3A6IGUsIHNjcm9sbExlZnQ6IG4gfSA9IHRoaXMuc2Nyb2xsRE9NLCByID0gdGhpcy52aWV3U3RhdGUuc2Nyb2xsQW5jaG9yQXQoZSk7XG4gICAgcmV0dXJuIF9jLm9mKG5ldyBFbyhhZS5jdXJzb3Ioci5mcm9tKSwgXCJzdGFydFwiLCBcInN0YXJ0XCIsIHIudG9wIC0gZSwgbiwgITApKTtcbiAgfVxuICAvKipcbiAgUmV0dXJucyBhbiBleHRlbnNpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBhZGQgRE9NIGV2ZW50IGhhbmRsZXJzLlxuICBUaGUgdmFsdWUgc2hvdWxkIGJlIGFuIG9iamVjdCBtYXBwaW5nIGV2ZW50IG5hbWVzIHRvIGhhbmRsZXJcbiAgZnVuY3Rpb25zLiBGb3IgYW55IGdpdmVuIGV2ZW50LCBzdWNoIGZ1bmN0aW9ucyBhcmUgb3JkZXJlZCBieVxuICBleHRlbnNpb24gcHJlY2VkZW5jZSwgYW5kIHRoZSBmaXJzdCBoYW5kbGVyIHRvIHJldHVybiB0cnVlIHdpbGxcbiAgYmUgYXNzdW1lZCB0byBoYXZlIGhhbmRsZWQgdGhhdCBldmVudCwgYW5kIG5vIG90aGVyIGhhbmRsZXJzIG9yXG4gIGJ1aWx0LWluIGJlaGF2aW9yIHdpbGwgYmUgYWN0aXZhdGVkIGZvciBpdC4gVGhlc2UgYXJlIHJlZ2lzdGVyZWRcbiAgb24gdGhlIFtjb250ZW50IGVsZW1lbnRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmNvbnRlbnRET00pLCBleGNlcHRcbiAgZm9yIGBzY3JvbGxgIGhhbmRsZXJzLCB3aGljaCB3aWxsIGJlIGNhbGxlZCBhbnkgdGltZSB0aGVcbiAgZWRpdG9yJ3MgW3Njcm9sbCBlbGVtZW50XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlldy5zY3JvbGxET00pIG9yIG9uZSBvZlxuICBpdHMgcGFyZW50IG5vZGVzIGlzIHNjcm9sbGVkLlxuICAqL1xuICBzdGF0aWMgZG9tRXZlbnRIYW5kbGVycyhlKSB7XG4gICAgcmV0dXJuIHJyLmRlZmluZSgoKSA9PiAoe30pLCB7IGV2ZW50SGFuZGxlcnM6IGUgfSk7XG4gIH1cbiAgLyoqXG4gIENyZWF0ZSBhbiBleHRlbnNpb24gdGhhdCByZWdpc3RlcnMgRE9NIGV2ZW50IG9ic2VydmVycy4gQ29udHJhcnlcbiAgdG8gZXZlbnQgW2hhbmRsZXJzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yVmlld15kb21FdmVudEhhbmRsZXJzKSxcbiAgb2JzZXJ2ZXJzIGNhbid0IGJlIHByZXZlbnRlZCBmcm9tIHJ1bm5pbmcgYnkgYSBoaWdoZXItcHJlY2VkZW5jZVxuICBoYW5kbGVyIHJldHVybmluZyB0cnVlLiBUaGV5IGFsc28gZG9uJ3QgcHJldmVudCBvdGhlciBoYW5kbGVyc1xuICBhbmQgb2JzZXJ2ZXJzIGZyb20gcnVubmluZyB3aGVuIHRoZXkgcmV0dXJuIHRydWUsIGFuZCBzaG91bGQgbm90XG4gIGNhbGwgYHByZXZlbnREZWZhdWx0YC5cbiAgKi9cbiAgc3RhdGljIGRvbUV2ZW50T2JzZXJ2ZXJzKGUpIHtcbiAgICByZXR1cm4gcnIuZGVmaW5lKCgpID0+ICh7fSksIHsgZXZlbnRPYnNlcnZlcnM6IGUgfSk7XG4gIH1cbiAgLyoqXG4gIENyZWF0ZSBhIHRoZW1lIGV4dGVuc2lvbi4gVGhlIGZpcnN0IGFyZ3VtZW50IGNhbiBiZSBhXG4gIFtgc3R5bGUtbW9kYF0oaHR0cHM6Ly9naXRodWIuY29tL21hcmlqbmgvc3R5bGUtbW9kI2RvY3VtZW50YXRpb24pXG4gIHN0eWxlIHNwZWMgcHJvdmlkaW5nIHRoZSBzdHlsZXMgZm9yIHRoZSB0aGVtZS4gVGhlc2Ugd2lsbCBiZVxuICBwcmVmaXhlZCB3aXRoIGEgZ2VuZXJhdGVkIGNsYXNzIGZvciB0aGUgc3R5bGUuXG4gIFxuICBCZWNhdXNlIHRoZSBzZWxlY3RvcnMgd2lsbCBiZSBwcmVmaXhlZCB3aXRoIGEgc2NvcGUgY2xhc3MsIHJ1bGVcbiAgdGhhdCBkaXJlY3RseSBtYXRjaCB0aGUgZWRpdG9yJ3MgW3dyYXBwZXJcbiAgZWxlbWVudF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcuZG9tKeKAlHRvIHdoaWNoIHRoZSBzY29wZSBjbGFzcyB3aWxsIGJlXG4gIGFkZGVk4oCUbmVlZCB0byBiZSBleHBsaWNpdGx5IGRpZmZlcmVudGlhdGVkIGJ5IGFkZGluZyBhbiBgJmAgdG9cbiAgdGhlIHNlbGVjdG9yIGZvciB0aGF0IGVsZW1lbnTigJRmb3IgZXhhbXBsZVxuICBgJi5jbS1mb2N1c2VkYC5cbiAgXG4gIFdoZW4gYGRhcmtgIGlzIHNldCB0byB0cnVlLCB0aGUgdGhlbWUgd2lsbCBiZSBtYXJrZWQgYXMgZGFyayxcbiAgd2hpY2ggd2lsbCBjYXVzZSB0aGUgYCZkYXJrYCBydWxlcyBmcm9tIFtiYXNlXG4gIHRoZW1lc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXdeYmFzZVRoZW1lKSB0byBiZSB1c2VkIChhcyBvcHBvc2VkIHRvXG4gIGAmbGlnaHRgIHdoZW4gYSBsaWdodCB0aGVtZSBpcyBhY3RpdmUpLlxuICAqL1xuICBzdGF0aWMgdGhlbWUoZSwgbikge1xuICAgIGxldCByID0gc3MubmV3TmFtZSgpLCBpID0gW0FjLm9mKHIpLCBOYS5vZihtcChgLiR7cn1gLCBlKSldO1xuICAgIHJldHVybiBuICYmIG4uZGFyayAmJiBpLnB1c2goT3Aub2YoITApKSwgaTtcbiAgfVxuICAvKipcbiAgQ3JlYXRlIGFuIGV4dGVuc2lvbiB0aGF0IGFkZHMgc3R5bGVzIHRvIHRoZSBiYXNlIHRoZW1lLiBMaWtlXG4gIHdpdGggW2B0aGVtZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3XnRoZW1lKSwgdXNlIGAmYCB0byBpbmRpY2F0ZSB0aGVcbiAgcGxhY2Ugb2YgdGhlIGVkaXRvciB3cmFwcGVyIGVsZW1lbnQgd2hlbiBkaXJlY3RseSB0YXJnZXRpbmdcbiAgdGhhdC4gWW91IGNhbiBhbHNvIHVzZSBgJmRhcmtgIG9yIGAmbGlnaHRgIGluc3RlYWQgdG8gb25seVxuICB0YXJnZXQgZWRpdG9ycyB3aXRoIGEgZGFyayBvciBsaWdodCB0aGVtZS5cbiAgKi9cbiAgc3RhdGljIGJhc2VUaGVtZShlKSB7XG4gICAgcmV0dXJuIHpsLmxvd2VzdChOYS5vZihtcChcIi5cIiArIGdwLCBlLCBCaykpKTtcbiAgfVxuICAvKipcbiAgUmV0cmlldmUgYW4gZWRpdG9yIHZpZXcgaW5zdGFuY2UgZnJvbSB0aGUgdmlldydzIERPTVxuICByZXByZXNlbnRhdGlvbi5cbiAgKi9cbiAgc3RhdGljIGZpbmRGcm9tRE9NKGUpIHtcbiAgICB2YXIgbjtcbiAgICBsZXQgciA9IGUucXVlcnlTZWxlY3RvcihcIi5jbS1jb250ZW50XCIpLCBpID0gciAmJiBmdC5nZXQocikgfHwgZnQuZ2V0KGUpO1xuICAgIHJldHVybiAoKG4gPSBpID09IG51bGwgPyB2b2lkIDAgOiBpLnJvb3RWaWV3KSA9PT0gbnVsbCB8fCBuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuLnZpZXcpIHx8IG51bGw7XG4gIH1cbn1cblNlLnN0eWxlTW9kdWxlID0gTmE7XG5TZS5pbnB1dEhhbmRsZXIgPSB5aztcblNlLmZvY3VzQ2hhbmdlRWZmZWN0ID0gU2s7XG5TZS5wZXJMaW5lVGV4dERpcmVjdGlvbiA9IHdrO1xuU2UuZXhjZXB0aW9uU2luayA9IHZrO1xuU2UudXBkYXRlTGlzdGVuZXIgPSBmcDtcblNlLmVkaXRhYmxlID0gWWQ7XG5TZS5tb3VzZVNlbGVjdGlvblN0eWxlID0gYms7XG5TZS5kcmFnTW92ZXNTZWxlY3Rpb24gPSBtaztcblNlLmNsaWNrQWRkc1NlbGVjdGlvblJhbmdlID0gZ2s7XG5TZS5kZWNvcmF0aW9ucyA9IG1sO1xuU2Uub3V0ZXJEZWNvcmF0aW9ucyA9IHhrO1xuU2UuYXRvbWljUmFuZ2VzID0gdWc7XG5TZS5iaWRpSXNvbGF0ZWRSYW5nZXMgPSBQaztcblNlLnNjcm9sbE1hcmdpbnMgPSBfaztcblNlLmRhcmtUaGVtZSA9IE9wO1xuU2UuY3NwTm9uY2UgPSAvKiBAX19QVVJFX18gKi8gdmUuZGVmaW5lKHsgY29tYmluZTogKHQpID0+IHQubGVuZ3RoID8gdFswXSA6IFwiXCIgfSk7XG5TZS5jb250ZW50QXR0cmlidXRlcyA9IGNnO1xuU2UuZWRpdG9yQXR0cmlidXRlcyA9IGtrO1xuU2UubGluZVdyYXBwaW5nID0gLyogQF9fUFVSRV9fICovIFNlLmNvbnRlbnRBdHRyaWJ1dGVzLm9mKHsgY2xhc3M6IFwiY20tbGluZVdyYXBwaW5nXCIgfSk7XG5TZS5hbm5vdW5jZSA9IC8qIEBfX1BVUkVfXyAqLyBvdC5kZWZpbmUoKTtcbmNvbnN0IEI1ID0gNDA5Niwgd3YgPSB7fTtcbmNsYXNzIE11IHtcbiAgY29uc3RydWN0b3IoZSwgbiwgciwgaSwgcywgbykge1xuICAgIHRoaXMuZnJvbSA9IGUsIHRoaXMudG8gPSBuLCB0aGlzLmRpciA9IHIsIHRoaXMuaXNvbGF0ZXMgPSBpLCB0aGlzLmZyZXNoID0gcywgdGhpcy5vcmRlciA9IG87XG4gIH1cbiAgc3RhdGljIHVwZGF0ZShlLCBuKSB7XG4gICAgaWYgKG4uZW1wdHkgJiYgIWUuc29tZSgocykgPT4gcy5mcmVzaCkpXG4gICAgICByZXR1cm4gZTtcbiAgICBsZXQgciA9IFtdLCBpID0gZS5sZW5ndGggPyBlW2UubGVuZ3RoIC0gMV0uZGlyIDogUXQuTFRSO1xuICAgIGZvciAobGV0IHMgPSBNYXRoLm1heCgwLCBlLmxlbmd0aCAtIDEwKTsgcyA8IGUubGVuZ3RoOyBzKyspIHtcbiAgICAgIGxldCBvID0gZVtzXTtcbiAgICAgIG8uZGlyID09IGkgJiYgIW4udG91Y2hlc1JhbmdlKG8uZnJvbSwgby50bykgJiYgci5wdXNoKG5ldyBNdShuLm1hcFBvcyhvLmZyb20sIDEpLCBuLm1hcFBvcyhvLnRvLCAtMSksIG8uZGlyLCBvLmlzb2xhdGVzLCAhMSwgby5vcmRlcikpO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxufVxuZnVuY3Rpb24ga3YodCwgZSwgbikge1xuICBmb3IgKGxldCByID0gdC5zdGF0ZS5mYWNldChlKSwgaSA9IHIubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBsZXQgcyA9IHJbaV0sIG8gPSB0eXBlb2YgcyA9PSBcImZ1bmN0aW9uXCIgPyBzKHQpIDogcztcbiAgICBvICYmIG9wKG8sIG4pO1xuICB9XG4gIHJldHVybiBuO1xufVxuY29uc3QgTDUgPSBkZS5tYWMgPyBcIm1hY1wiIDogZGUud2luZG93cyA/IFwid2luXCIgOiBkZS5saW51eCA/IFwibGludXhcIiA6IFwia2V5XCI7XG5mdW5jdGlvbiBVNSh0LCBlKSB7XG4gIGNvbnN0IG4gPSB0LnNwbGl0KC8tKD8hJCkvKTtcbiAgbGV0IHIgPSBuW24ubGVuZ3RoIC0gMV07XG4gIHIgPT0gXCJTcGFjZVwiICYmIChyID0gXCIgXCIpO1xuICBsZXQgaSwgcywgbywgYTtcbiAgZm9yIChsZXQgbCA9IDA7IGwgPCBuLmxlbmd0aCAtIDE7ICsrbCkge1xuICAgIGNvbnN0IGMgPSBuW2xdO1xuICAgIGlmICgvXihjbWR8bWV0YXxtKSQvaS50ZXN0KGMpKVxuICAgICAgYSA9ICEwO1xuICAgIGVsc2UgaWYgKC9eYShsdCk/JC9pLnRlc3QoYykpXG4gICAgICBpID0gITA7XG4gICAgZWxzZSBpZiAoL14oY3xjdHJsfGNvbnRyb2wpJC9pLnRlc3QoYykpXG4gICAgICBzID0gITA7XG4gICAgZWxzZSBpZiAoL15zKGhpZnQpPyQvaS50ZXN0KGMpKVxuICAgICAgbyA9ICEwO1xuICAgIGVsc2UgaWYgKC9ebW9kJC9pLnRlc3QoYykpXG4gICAgICBlID09IFwibWFjXCIgPyBhID0gITAgOiBzID0gITA7XG4gICAgZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIG1vZGlmaWVyIG5hbWU6IFwiICsgYyk7XG4gIH1cbiAgcmV0dXJuIGkgJiYgKHIgPSBcIkFsdC1cIiArIHIpLCBzICYmIChyID0gXCJDdHJsLVwiICsgciksIGEgJiYgKHIgPSBcIk1ldGEtXCIgKyByKSwgbyAmJiAociA9IFwiU2hpZnQtXCIgKyByKSwgcjtcbn1cbmZ1bmN0aW9uIFJjKHQsIGUsIG4pIHtcbiAgcmV0dXJuIGUuYWx0S2V5ICYmICh0ID0gXCJBbHQtXCIgKyB0KSwgZS5jdHJsS2V5ICYmICh0ID0gXCJDdHJsLVwiICsgdCksIGUubWV0YUtleSAmJiAodCA9IFwiTWV0YS1cIiArIHQpLCBuICE9PSAhMSAmJiBlLnNoaWZ0S2V5ICYmICh0ID0gXCJTaGlmdC1cIiArIHQpLCB0O1xufVxuY29uc3QgcTUgPSAvKiBAX19QVVJFX18gKi8gemwuZGVmYXVsdCgvKiBAX19QVVJFX18gKi8gU2UuZG9tRXZlbnRIYW5kbGVycyh7XG4gIGtleWRvd24odCwgZSkge1xuICAgIHJldHVybiBGNShZNShlLnN0YXRlKSwgdCwgZSwgXCJlZGl0b3JcIik7XG4gIH1cbn0pKSwgYmwgPSAvKiBAX19QVVJFX18gKi8gdmUuZGVmaW5lKHsgZW5hYmxlczogcTUgfSksIHh2ID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBZNSh0KSB7XG4gIGxldCBlID0gdC5mYWNldChibCksIG4gPSB4di5nZXQoZSk7XG4gIHJldHVybiBuIHx8IHh2LnNldChlLCBuID0gSDUoZS5yZWR1Y2UoKHIsIGkpID0+IHIuY29uY2F0KGkpLCBbXSkpKSwgbjtcbn1cbmxldCBNaSA9IG51bGw7XG5jb25zdCB6NSA9IDRlMztcbmZ1bmN0aW9uIEg1KHQsIGUgPSBMNSkge1xuICBsZXQgbiA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCByID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIGkgPSAobywgYSkgPT4ge1xuICAgIGxldCBsID0gcltvXTtcbiAgICBpZiAobCA9PSBudWxsKVxuICAgICAgcltvXSA9IGE7XG4gICAgZWxzZSBpZiAobCAhPSBhKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiS2V5IGJpbmRpbmcgXCIgKyBvICsgXCIgaXMgdXNlZCBib3RoIGFzIGEgcmVndWxhciBiaW5kaW5nIGFuZCBhcyBhIG11bHRpLXN0cm9rZSBwcmVmaXhcIik7XG4gIH0sIHMgPSAobywgYSwgbCwgYywgdSkgPT4ge1xuICAgIHZhciBkLCBmO1xuICAgIGxldCBoID0gbltvXSB8fCAobltvXSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpKSwgcCA9IGEuc3BsaXQoLyAoPyEkKS8pLm1hcCgoeSkgPT4gVTUoeSwgZSkpO1xuICAgIGZvciAobGV0IHkgPSAxOyB5IDwgcC5sZW5ndGg7IHkrKykge1xuICAgICAgbGV0IGIgPSBwLnNsaWNlKDAsIHkpLmpvaW4oXCIgXCIpO1xuICAgICAgaShiLCAhMCksIGhbYl0gfHwgKGhbYl0gPSB7XG4gICAgICAgIHByZXZlbnREZWZhdWx0OiAhMCxcbiAgICAgICAgc3RvcFByb3BhZ2F0aW9uOiAhMSxcbiAgICAgICAgcnVuOiBbKGcpID0+IHtcbiAgICAgICAgICBsZXQgdiA9IE1pID0geyB2aWV3OiBnLCBwcmVmaXg6IGIsIHNjb3BlOiBvIH07XG4gICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgTWkgPT0gdiAmJiAoTWkgPSBudWxsKTtcbiAgICAgICAgICB9LCB6NSksICEwO1xuICAgICAgICB9XVxuICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBPID0gcC5qb2luKFwiIFwiKTtcbiAgICBpKE8sICExKTtcbiAgICBsZXQgbSA9IGhbT10gfHwgKGhbT10gPSB7XG4gICAgICBwcmV2ZW50RGVmYXVsdDogITEsXG4gICAgICBzdG9wUHJvcGFnYXRpb246ICExLFxuICAgICAgcnVuOiAoKGYgPSAoZCA9IGguX2FueSkgPT09IG51bGwgfHwgZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZC5ydW4pID09PSBudWxsIHx8IGYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGYuc2xpY2UoKSkgfHwgW11cbiAgICB9KTtcbiAgICBsICYmIG0ucnVuLnB1c2gobCksIGMgJiYgKG0ucHJldmVudERlZmF1bHQgPSAhMCksIHUgJiYgKG0uc3RvcFByb3BhZ2F0aW9uID0gITApO1xuICB9O1xuICBmb3IgKGxldCBvIG9mIHQpIHtcbiAgICBsZXQgYSA9IG8uc2NvcGUgPyBvLnNjb3BlLnNwbGl0KFwiIFwiKSA6IFtcImVkaXRvclwiXTtcbiAgICBpZiAoby5hbnkpXG4gICAgICBmb3IgKGxldCBjIG9mIGEpIHtcbiAgICAgICAgbGV0IHUgPSBuW2NdIHx8IChuW2NdID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgICAgICB1Ll9hbnkgfHwgKHUuX2FueSA9IHsgcHJldmVudERlZmF1bHQ6ICExLCBzdG9wUHJvcGFnYXRpb246ICExLCBydW46IFtdIH0pO1xuICAgICAgICBmb3IgKGxldCBkIGluIHUpXG4gICAgICAgICAgdVtkXS5ydW4ucHVzaChvLmFueSk7XG4gICAgICB9XG4gICAgbGV0IGwgPSBvW2VdIHx8IG8ua2V5O1xuICAgIGlmIChsKVxuICAgICAgZm9yIChsZXQgYyBvZiBhKVxuICAgICAgICBzKGMsIGwsIG8ucnVuLCBvLnByZXZlbnREZWZhdWx0LCBvLnN0b3BQcm9wYWdhdGlvbiksIG8uc2hpZnQgJiYgcyhjLCBcIlNoaWZ0LVwiICsgbCwgby5zaGlmdCwgby5wcmV2ZW50RGVmYXVsdCwgby5zdG9wUHJvcGFnYXRpb24pO1xuICB9XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gRjUodCwgZSwgbiwgcikge1xuICBsZXQgaSA9IG1OKGUpLCBzID0gbm4oaSwgMCksIG8gPSBjcihzKSA9PSBpLmxlbmd0aCAmJiBpICE9IFwiIFwiLCBhID0gXCJcIiwgbCA9ICExLCBjID0gITEsIHUgPSAhMTtcbiAgTWkgJiYgTWkudmlldyA9PSBuICYmIE1pLnNjb3BlID09IHIgJiYgKGEgPSBNaS5wcmVmaXggKyBcIiBcIiwgQWsuaW5kZXhPZihlLmtleUNvZGUpIDwgMCAmJiAoYyA9ICEwLCBNaSA9IG51bGwpKTtcbiAgbGV0IGQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLCBmID0gKG0pID0+IHtcbiAgICBpZiAobSkge1xuICAgICAgZm9yIChsZXQgeSBvZiBtLnJ1bilcbiAgICAgICAgaWYgKCFkLmhhcyh5KSAmJiAoZC5hZGQoeSksIHkobiwgZSkpKVxuICAgICAgICAgIHJldHVybiBtLnN0b3BQcm9wYWdhdGlvbiAmJiAodSA9ICEwKSwgITA7XG4gICAgICBtLnByZXZlbnREZWZhdWx0ICYmIChtLnN0b3BQcm9wYWdhdGlvbiAmJiAodSA9ICEwKSwgYyA9ICEwKTtcbiAgICB9XG4gICAgcmV0dXJuICExO1xuICB9LCBoID0gdFtyXSwgcCwgTztcbiAgcmV0dXJuIGggJiYgKGYoaFthICsgUmMoaSwgZSwgIW8pXSkgPyBsID0gITAgOiBvICYmIChlLmFsdEtleSB8fCBlLm1ldGFLZXkgfHwgZS5jdHJsS2V5KSAmJiAvLyBDdHJsLUFsdCBtYXkgYmUgdXNlZCBmb3IgQWx0R3Igb24gV2luZG93c1xuICAhKGRlLndpbmRvd3MgJiYgZS5jdHJsS2V5ICYmIGUuYWx0S2V5KSAmJiAocCA9IG9zW2Uua2V5Q29kZV0pICYmIHAgIT0gaSA/IChmKGhbYSArIFJjKHAsIGUsICEwKV0pIHx8IGUuc2hpZnRLZXkgJiYgKE8gPSBwbFtlLmtleUNvZGVdKSAhPSBpICYmIE8gIT0gcCAmJiBmKGhbYSArIFJjKE8sIGUsICExKV0pKSAmJiAobCA9ICEwKSA6IG8gJiYgZS5zaGlmdEtleSAmJiBmKGhbYSArIFJjKGksIGUsICEwKV0pICYmIChsID0gITApLCAhbCAmJiBmKGguX2FueSkgJiYgKGwgPSAhMCkpLCBjICYmIChsID0gITApLCBsICYmIHUgJiYgZS5zdG9wUHJvcGFnYXRpb24oKSwgbDtcbn1cbmZ1bmN0aW9uIFB2KHQsIGUsIG4sIHIsIGkpIHtcbiAgZS5sYXN0SW5kZXggPSAwO1xuICBmb3IgKGxldCBzID0gdC5pdGVyUmFuZ2UobiwgciksIG8gPSBuLCBhOyAhcy5uZXh0KCkuZG9uZTsgbyArPSBzLnZhbHVlLmxlbmd0aClcbiAgICBpZiAoIXMubGluZUJyZWFrKVxuICAgICAgZm9yICg7IGEgPSBlLmV4ZWMocy52YWx1ZSk7IClcbiAgICAgICAgaShvICsgYS5pbmRleCwgYSk7XG59XG5mdW5jdGlvbiBHNSh0LCBlKSB7XG4gIGxldCBuID0gdC52aXNpYmxlUmFuZ2VzO1xuICBpZiAobi5sZW5ndGggPT0gMSAmJiBuWzBdLmZyb20gPT0gdC52aWV3cG9ydC5mcm9tICYmIG5bMF0udG8gPT0gdC52aWV3cG9ydC50bylcbiAgICByZXR1cm4gbjtcbiAgbGV0IHIgPSBbXTtcbiAgZm9yIChsZXQgeyBmcm9tOiBpLCB0bzogcyB9IG9mIG4pXG4gICAgaSA9IE1hdGgubWF4KHQuc3RhdGUuZG9jLmxpbmVBdChpKS5mcm9tLCBpIC0gZSksIHMgPSBNYXRoLm1pbih0LnN0YXRlLmRvYy5saW5lQXQocykudG8sIHMgKyBlKSwgci5sZW5ndGggJiYgcltyLmxlbmd0aCAtIDFdLnRvID49IGkgPyByW3IubGVuZ3RoIC0gMV0udG8gPSBzIDogci5wdXNoKHsgZnJvbTogaSwgdG86IHMgfSk7XG4gIHJldHVybiByO1xufVxuY2xhc3MgVWsge1xuICAvKipcbiAgQ3JlYXRlIGEgZGVjb3JhdG9yLlxuICAqL1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgY29uc3QgeyByZWdleHA6IG4sIGRlY29yYXRpb246IHIsIGRlY29yYXRlOiBpLCBib3VuZGFyeTogcywgbWF4TGVuZ3RoOiBvID0gMWUzIH0gPSBlO1xuICAgIGlmICghbi5nbG9iYWwpXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSByZWd1bGFyIGV4cHJlc3Npb24gZ2l2ZW4gdG8gTWF0Y2hEZWNvcmF0b3Igc2hvdWxkIGhhdmUgaXRzICdnJyBmbGFnIHNldFwiKTtcbiAgICBpZiAodGhpcy5yZWdleHAgPSBuLCBpKVxuICAgICAgdGhpcy5hZGRNYXRjaCA9IChhLCBsLCBjLCB1KSA9PiBpKHUsIGMsIGMgKyBhWzBdLmxlbmd0aCwgYSwgbCk7XG4gICAgZWxzZSBpZiAodHlwZW9mIHIgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgdGhpcy5hZGRNYXRjaCA9IChhLCBsLCBjLCB1KSA9PiB7XG4gICAgICAgIGxldCBkID0gcihhLCBsLCBjKTtcbiAgICAgICAgZCAmJiB1KGMsIGMgKyBhWzBdLmxlbmd0aCwgZCk7XG4gICAgICB9O1xuICAgIGVsc2UgaWYgKHIpXG4gICAgICB0aGlzLmFkZE1hdGNoID0gKGEsIGwsIGMsIHUpID0+IHUoYywgYyArIGFbMF0ubGVuZ3RoLCByKTtcbiAgICBlbHNlXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkVpdGhlciAnZGVjb3JhdGUnIG9yICdkZWNvcmF0aW9uJyBzaG91bGQgYmUgcHJvdmlkZWQgdG8gTWF0Y2hEZWNvcmF0b3JcIik7XG4gICAgdGhpcy5ib3VuZGFyeSA9IHMsIHRoaXMubWF4TGVuZ3RoID0gbztcbiAgfVxuICAvKipcbiAgQ29tcHV0ZSB0aGUgZnVsbCBzZXQgb2YgZGVjb3JhdGlvbnMgZm9yIG1hdGNoZXMgaW4gdGhlIGdpdmVuXG4gIHZpZXcncyB2aWV3cG9ydC4gWW91J2xsIHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4gaW5pdGlhbGl6aW5nIHlvdXJcbiAgcGx1Z2luLlxuICAqL1xuICBjcmVhdGVEZWNvKGUpIHtcbiAgICBsZXQgbiA9IG5ldyBqbygpLCByID0gbi5hZGQuYmluZChuKTtcbiAgICBmb3IgKGxldCB7IGZyb206IGksIHRvOiBzIH0gb2YgRzUoZSwgdGhpcy5tYXhMZW5ndGgpKVxuICAgICAgUHYoZS5zdGF0ZS5kb2MsIHRoaXMucmVnZXhwLCBpLCBzLCAobywgYSkgPT4gdGhpcy5hZGRNYXRjaChhLCBlLCBvLCByKSk7XG4gICAgcmV0dXJuIG4uZmluaXNoKCk7XG4gIH1cbiAgLyoqXG4gIFVwZGF0ZSBhIHNldCBvZiBkZWNvcmF0aW9ucyBmb3IgYSB2aWV3IHVwZGF0ZS4gYGRlY29gIF9tdXN0XyBiZVxuICB0aGUgc2V0IG9mIGRlY29yYXRpb25zIHByb2R1Y2VkIGJ5IF90aGlzXyBgTWF0Y2hEZWNvcmF0b3JgIGZvclxuICB0aGUgdmlldyBzdGF0ZSBiZWZvcmUgdGhlIHVwZGF0ZS5cbiAgKi9cbiAgdXBkYXRlRGVjbyhlLCBuKSB7XG4gICAgbGV0IHIgPSAxZTksIGkgPSAtMTtcbiAgICByZXR1cm4gZS5kb2NDaGFuZ2VkICYmIGUuY2hhbmdlcy5pdGVyQ2hhbmdlcygocywgbywgYSwgbCkgPT4ge1xuICAgICAgbCA+IGUudmlldy52aWV3cG9ydC5mcm9tICYmIGEgPCBlLnZpZXcudmlld3BvcnQudG8gJiYgKHIgPSBNYXRoLm1pbihhLCByKSwgaSA9IE1hdGgubWF4KGwsIGkpKTtcbiAgICB9KSwgZS52aWV3cG9ydENoYW5nZWQgfHwgaSAtIHIgPiAxZTMgPyB0aGlzLmNyZWF0ZURlY28oZS52aWV3KSA6IGkgPiAtMSA/IHRoaXMudXBkYXRlUmFuZ2UoZS52aWV3LCBuLm1hcChlLmNoYW5nZXMpLCByLCBpKSA6IG47XG4gIH1cbiAgdXBkYXRlUmFuZ2UoZSwgbiwgciwgaSkge1xuICAgIGZvciAobGV0IHMgb2YgZS52aXNpYmxlUmFuZ2VzKSB7XG4gICAgICBsZXQgbyA9IE1hdGgubWF4KHMuZnJvbSwgciksIGEgPSBNYXRoLm1pbihzLnRvLCBpKTtcbiAgICAgIGlmIChhID4gbykge1xuICAgICAgICBsZXQgbCA9IGUuc3RhdGUuZG9jLmxpbmVBdChvKSwgYyA9IGwudG8gPCBhID8gZS5zdGF0ZS5kb2MubGluZUF0KGEpIDogbCwgdSA9IE1hdGgubWF4KHMuZnJvbSwgbC5mcm9tKSwgZCA9IE1hdGgubWluKHMudG8sIGMudG8pO1xuICAgICAgICBpZiAodGhpcy5ib3VuZGFyeSkge1xuICAgICAgICAgIGZvciAoOyBvID4gbC5mcm9tOyBvLS0pXG4gICAgICAgICAgICBpZiAodGhpcy5ib3VuZGFyeS50ZXN0KGwudGV4dFtvIC0gMSAtIGwuZnJvbV0pKSB7XG4gICAgICAgICAgICAgIHUgPSBvO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKDsgYSA8IGMudG87IGErKylcbiAgICAgICAgICAgIGlmICh0aGlzLmJvdW5kYXJ5LnRlc3QoYy50ZXh0W2EgLSBjLmZyb21dKSkge1xuICAgICAgICAgICAgICBkID0gYTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGYgPSBbXSwgaCwgcCA9IChPLCBtLCB5KSA9PiBmLnB1c2goeS5yYW5nZShPLCBtKSk7XG4gICAgICAgIGlmIChsID09IGMpXG4gICAgICAgICAgZm9yICh0aGlzLnJlZ2V4cC5sYXN0SW5kZXggPSB1IC0gbC5mcm9tOyAoaCA9IHRoaXMucmVnZXhwLmV4ZWMobC50ZXh0KSkgJiYgaC5pbmRleCA8IGQgLSBsLmZyb207IClcbiAgICAgICAgICAgIHRoaXMuYWRkTWF0Y2goaCwgZSwgaC5pbmRleCArIGwuZnJvbSwgcCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBQdihlLnN0YXRlLmRvYywgdGhpcy5yZWdleHAsIHUsIGQsIChPLCBtKSA9PiB0aGlzLmFkZE1hdGNoKG0sIGUsIE8sIHApKTtcbiAgICAgICAgbiA9IG4udXBkYXRlKHsgZmlsdGVyRnJvbTogdSwgZmlsdGVyVG86IGQsIGZpbHRlcjogKE8sIG0pID0+IE8gPCB1IHx8IG0gPiBkLCBhZGQ6IGYgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9XG59XG5jb25zdCBicCA9IC94Ly51bmljb2RlICE9IG51bGwgPyBcImd1XCIgOiBcImdcIiwgSzUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFJlZ0V4cChgW1xcMC1cXGJcbi1cdTAwMWZ/LcKfwq3YnOKAi+KAjuKAj1xcdTIwMjhcXHUyMDI54oCt4oCu4oGm4oGn4oGpXFx1RkVGRu+/uS3vv7xdYCwgYnApLCBKNSA9IHtcbiAgMDogXCJudWxsXCIsXG4gIDc6IFwiYmVsbFwiLFxuICA4OiBcImJhY2tzcGFjZVwiLFxuICAxMDogXCJuZXdsaW5lXCIsXG4gIDExOiBcInZlcnRpY2FsIHRhYlwiLFxuICAxMzogXCJjYXJyaWFnZSByZXR1cm5cIixcbiAgMjc6IFwiZXNjYXBlXCIsXG4gIDgyMDM6IFwiemVybyB3aWR0aCBzcGFjZVwiLFxuICA4MjA0OiBcInplcm8gd2lkdGggbm9uLWpvaW5lclwiLFxuICA4MjA1OiBcInplcm8gd2lkdGggam9pbmVyXCIsXG4gIDgyMDY6IFwibGVmdC10by1yaWdodCBtYXJrXCIsXG4gIDgyMDc6IFwicmlnaHQtdG8tbGVmdCBtYXJrXCIsXG4gIDgyMzI6IFwibGluZSBzZXBhcmF0b3JcIixcbiAgODIzNzogXCJsZWZ0LXRvLXJpZ2h0IG92ZXJyaWRlXCIsXG4gIDgyMzg6IFwicmlnaHQtdG8tbGVmdCBvdmVycmlkZVwiLFxuICA4Mjk0OiBcImxlZnQtdG8tcmlnaHQgaXNvbGF0ZVwiLFxuICA4Mjk1OiBcInJpZ2h0LXRvLWxlZnQgaXNvbGF0ZVwiLFxuICA4Mjk3OiBcInBvcCBkaXJlY3Rpb25hbCBpc29sYXRlXCIsXG4gIDgyMzM6IFwicGFyYWdyYXBoIHNlcGFyYXRvclwiLFxuICA2NTI3OTogXCJ6ZXJvIHdpZHRoIG5vLWJyZWFrIHNwYWNlXCIsXG4gIDY1NTMyOiBcIm9iamVjdCByZXBsYWNlbWVudFwiXG59O1xubGV0IFFmID0gbnVsbDtcbmZ1bmN0aW9uIGVEKCkge1xuICB2YXIgdDtcbiAgaWYgKFFmID09IG51bGwgJiYgdHlwZW9mIGRvY3VtZW50IDwgXCJ1XCIgJiYgZG9jdW1lbnQuYm9keSkge1xuICAgIGxldCBlID0gZG9jdW1lbnQuYm9keS5zdHlsZTtcbiAgICBRZiA9ICgodCA9IGUudGFiU2l6ZSkgIT09IG51bGwgJiYgdCAhPT0gdm9pZCAwID8gdCA6IGUuTW96VGFiU2l6ZSkgIT0gbnVsbDtcbiAgfVxuICByZXR1cm4gUWYgfHwgITE7XG59XG5jb25zdCBvdSA9IC8qIEBfX1BVUkVfXyAqLyB2ZS5kZWZpbmUoe1xuICBjb21iaW5lKHQpIHtcbiAgICBsZXQgZSA9IFVkKHQsIHtcbiAgICAgIHJlbmRlcjogbnVsbCxcbiAgICAgIHNwZWNpYWxDaGFyczogSzUsXG4gICAgICBhZGRTcGVjaWFsQ2hhcnM6IG51bGxcbiAgICB9KTtcbiAgICByZXR1cm4gKGUucmVwbGFjZVRhYnMgPSAhZUQoKSkgJiYgKGUuc3BlY2lhbENoYXJzID0gbmV3IFJlZ0V4cChcIlx0fFwiICsgZS5zcGVjaWFsQ2hhcnMuc291cmNlLCBicCkpLCBlLmFkZFNwZWNpYWxDaGFycyAmJiAoZS5zcGVjaWFsQ2hhcnMgPSBuZXcgUmVnRXhwKGUuc3BlY2lhbENoYXJzLnNvdXJjZSArIFwifFwiICsgZS5hZGRTcGVjaWFsQ2hhcnMuc291cmNlLCBicCkpLCBlO1xuICB9XG59KTtcbmZ1bmN0aW9uIHREKHQgPSB7fSkge1xuICByZXR1cm4gW291Lm9mKHQpLCBuRCgpXTtcbn1cbmxldCBfdiA9IG51bGw7XG5mdW5jdGlvbiBuRCgpIHtcbiAgcmV0dXJuIF92IHx8IChfdiA9IHJyLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3IodCkge1xuICAgICAgdGhpcy52aWV3ID0gdCwgdGhpcy5kZWNvcmF0aW9ucyA9IEplLm5vbmUsIHRoaXMuZGVjb3JhdGlvbkNhY2hlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIHRoaXMuZGVjb3JhdG9yID0gdGhpcy5tYWtlRGVjb3JhdG9yKHQuc3RhdGUuZmFjZXQob3UpKSwgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZGVjb3JhdG9yLmNyZWF0ZURlY28odCk7XG4gICAgfVxuICAgIG1ha2VEZWNvcmF0b3IodCkge1xuICAgICAgcmV0dXJuIG5ldyBVayh7XG4gICAgICAgIHJlZ2V4cDogdC5zcGVjaWFsQ2hhcnMsXG4gICAgICAgIGRlY29yYXRpb246IChlLCBuLCByKSA9PiB7XG4gICAgICAgICAgbGV0IHsgZG9jOiBpIH0gPSBuLnN0YXRlLCBzID0gbm4oZVswXSwgMCk7XG4gICAgICAgICAgaWYgKHMgPT0gOSkge1xuICAgICAgICAgICAgbGV0IG8gPSBpLmxpbmVBdChyKSwgYSA9IG4uc3RhdGUudGFiU2l6ZSwgbCA9IGlnKG8udGV4dCwgYSwgciAtIG8uZnJvbSk7XG4gICAgICAgICAgICByZXR1cm4gSmUucmVwbGFjZSh7XG4gICAgICAgICAgICAgIHdpZGdldDogbmV3IG9EKChhIC0gbCAlIGEpICogdGhpcy52aWV3LmRlZmF1bHRDaGFyYWN0ZXJXaWR0aCAvIHRoaXMudmlldy5zY2FsZVgpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVjb3JhdGlvbkNhY2hlW3NdIHx8ICh0aGlzLmRlY29yYXRpb25DYWNoZVtzXSA9IEplLnJlcGxhY2UoeyB3aWRnZXQ6IG5ldyBzRCh0LCBzKSB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIGJvdW5kYXJ5OiB0LnJlcGxhY2VUYWJzID8gdm9pZCAwIDogL1teXS9cbiAgICAgIH0pO1xuICAgIH1cbiAgICB1cGRhdGUodCkge1xuICAgICAgbGV0IGUgPSB0LnN0YXRlLmZhY2V0KG91KTtcbiAgICAgIHQuc3RhcnRTdGF0ZS5mYWNldChvdSkgIT0gZSA/ICh0aGlzLmRlY29yYXRvciA9IHRoaXMubWFrZURlY29yYXRvcihlKSwgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZGVjb3JhdG9yLmNyZWF0ZURlY28odC52aWV3KSkgOiB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5kZWNvcmF0b3IudXBkYXRlRGVjbyh0LCB0aGlzLmRlY29yYXRpb25zKTtcbiAgICB9XG4gIH0sIHtcbiAgICBkZWNvcmF0aW9uczogKHQpID0+IHQuZGVjb3JhdGlvbnNcbiAgfSkpO1xufVxuY29uc3QgckQgPSBcIuKAolwiO1xuZnVuY3Rpb24gaUQodCkge1xuICByZXR1cm4gdCA+PSAzMiA/IHJEIDogdCA9PSAxMCA/IFwi4pCkXCIgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKDkyMTYgKyB0KTtcbn1cbmNsYXNzIHNEIGV4dGVuZHMgcmEge1xuICBjb25zdHJ1Y3RvcihlLCBuKSB7XG4gICAgc3VwZXIoKSwgdGhpcy5vcHRpb25zID0gZSwgdGhpcy5jb2RlID0gbjtcbiAgfVxuICBlcShlKSB7XG4gICAgcmV0dXJuIGUuY29kZSA9PSB0aGlzLmNvZGU7XG4gIH1cbiAgdG9ET00oZSkge1xuICAgIGxldCBuID0gaUQodGhpcy5jb2RlKSwgciA9IGUuc3RhdGUucGhyYXNlKFwiQ29udHJvbCBjaGFyYWN0ZXJcIikgKyBcIiBcIiArIChKNVt0aGlzLmNvZGVdIHx8IFwiMHhcIiArIHRoaXMuY29kZS50b1N0cmluZygxNikpLCBpID0gdGhpcy5vcHRpb25zLnJlbmRlciAmJiB0aGlzLm9wdGlvbnMucmVuZGVyKHRoaXMuY29kZSwgciwgbik7XG4gICAgaWYgKGkpXG4gICAgICByZXR1cm4gaTtcbiAgICBsZXQgcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIHJldHVybiBzLnRleHRDb250ZW50ID0gbiwgcy50aXRsZSA9IHIsIHMuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCByKSwgcy5jbGFzc05hbWUgPSBcImNtLXNwZWNpYWxDaGFyXCIsIHM7XG4gIH1cbiAgaWdub3JlRXZlbnQoKSB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5jbGFzcyBvRCBleHRlbmRzIHJhIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKCksIHRoaXMud2lkdGggPSBlO1xuICB9XG4gIGVxKGUpIHtcbiAgICByZXR1cm4gZS53aWR0aCA9PSB0aGlzLndpZHRoO1xuICB9XG4gIHRvRE9NKCkge1xuICAgIGxldCBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgcmV0dXJuIGUudGV4dENvbnRlbnQgPSBcIlx0XCIsIGUuY2xhc3NOYW1lID0gXCJjbS10YWJcIiwgZS5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyBcInB4XCIsIGU7XG4gIH1cbiAgaWdub3JlRXZlbnQoKSB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5jb25zdCB5YSA9IFwiLTEwMDAwcHhcIjtcbmNsYXNzIGFEIHtcbiAgY29uc3RydWN0b3IoZSwgbiwgciwgaSkge1xuICAgIHRoaXMuZmFjZXQgPSBuLCB0aGlzLmNyZWF0ZVRvb2x0aXBWaWV3ID0gciwgdGhpcy5yZW1vdmVUb29sdGlwVmlldyA9IGksIHRoaXMuaW5wdXQgPSBlLnN0YXRlLmZhY2V0KG4pLCB0aGlzLnRvb2x0aXBzID0gdGhpcy5pbnB1dC5maWx0ZXIoKG8pID0+IG8pO1xuICAgIGxldCBzID0gbnVsbDtcbiAgICB0aGlzLnRvb2x0aXBWaWV3cyA9IHRoaXMudG9vbHRpcHMubWFwKChvKSA9PiBzID0gcihvLCBzKSk7XG4gIH1cbiAgdXBkYXRlKGUsIG4pIHtcbiAgICB2YXIgcjtcbiAgICBsZXQgaSA9IGUuc3RhdGUuZmFjZXQodGhpcy5mYWNldCksIHMgPSBpLmZpbHRlcigobCkgPT4gbCk7XG4gICAgaWYgKGkgPT09IHRoaXMuaW5wdXQpIHtcbiAgICAgIGZvciAobGV0IGwgb2YgdGhpcy50b29sdGlwVmlld3MpXG4gICAgICAgIGwudXBkYXRlICYmIGwudXBkYXRlKGUpO1xuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICBsZXQgbyA9IFtdLCBhID0gbiA/IFtdIDogbnVsbDtcbiAgICBmb3IgKGxldCBsID0gMDsgbCA8IHMubGVuZ3RoOyBsKyspIHtcbiAgICAgIGxldCBjID0gc1tsXSwgdSA9IC0xO1xuICAgICAgaWYgKGMpIHtcbiAgICAgICAgZm9yIChsZXQgZCA9IDA7IGQgPCB0aGlzLnRvb2x0aXBzLmxlbmd0aDsgZCsrKSB7XG4gICAgICAgICAgbGV0IGYgPSB0aGlzLnRvb2x0aXBzW2RdO1xuICAgICAgICAgIGYgJiYgZi5jcmVhdGUgPT0gYy5jcmVhdGUgJiYgKHUgPSBkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodSA8IDApXG4gICAgICAgICAgb1tsXSA9IHRoaXMuY3JlYXRlVG9vbHRpcFZpZXcoYywgbCA/IG9bbCAtIDFdIDogbnVsbCksIGEgJiYgKGFbbF0gPSAhIWMuYWJvdmUpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBsZXQgZCA9IG9bbF0gPSB0aGlzLnRvb2x0aXBWaWV3c1t1XTtcbiAgICAgICAgICBhICYmIChhW2xdID0gblt1XSksIGQudXBkYXRlICYmIGQudXBkYXRlKGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGwgb2YgdGhpcy50b29sdGlwVmlld3MpXG4gICAgICBvLmluZGV4T2YobCkgPCAwICYmICh0aGlzLnJlbW92ZVRvb2x0aXBWaWV3KGwpLCAociA9IGwuZGVzdHJveSkgPT09IG51bGwgfHwgciA9PT0gdm9pZCAwIHx8IHIuY2FsbChsKSk7XG4gICAgcmV0dXJuIG4gJiYgKGEuZm9yRWFjaCgobCwgYykgPT4gbltjXSA9IGwpLCBuLmxlbmd0aCA9IGEubGVuZ3RoKSwgdGhpcy5pbnB1dCA9IGksIHRoaXMudG9vbHRpcHMgPSBzLCB0aGlzLnRvb2x0aXBWaWV3cyA9IG8sICEwO1xuICB9XG59XG5mdW5jdGlvbiBsRCh0KSB7XG4gIGxldCB7IHdpbjogZSB9ID0gdDtcbiAgcmV0dXJuIHsgdG9wOiAwLCBsZWZ0OiAwLCBib3R0b206IGUuaW5uZXJIZWlnaHQsIHJpZ2h0OiBlLmlubmVyV2lkdGggfTtcbn1cbmNvbnN0IENmID0gLyogQF9fUFVSRV9fICovIHZlLmRlZmluZSh7XG4gIGNvbWJpbmU6ICh0KSA9PiB7XG4gICAgdmFyIGUsIG4sIHI7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc2l0aW9uOiBkZS5pb3MgPyBcImFic29sdXRlXCIgOiAoKGUgPSB0LmZpbmQoKGkpID0+IGkucG9zaXRpb24pKSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLnBvc2l0aW9uKSB8fCBcImZpeGVkXCIsXG4gICAgICBwYXJlbnQ6ICgobiA9IHQuZmluZCgoaSkgPT4gaS5wYXJlbnQpKSA9PT0gbnVsbCB8fCBuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuLnBhcmVudCkgfHwgbnVsbCxcbiAgICAgIHRvb2x0aXBTcGFjZTogKChyID0gdC5maW5kKChpKSA9PiBpLnRvb2x0aXBTcGFjZSkpID09PSBudWxsIHx8IHIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHIudG9vbHRpcFNwYWNlKSB8fCBsRFxuICAgIH07XG4gIH1cbn0pLCBUdiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBxayA9IC8qIEBfX1BVUkVfXyAqLyByci5mcm9tQ2xhc3MoY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgdGhpcy52aWV3ID0gdCwgdGhpcy5hYm92ZSA9IFtdLCB0aGlzLmluVmlldyA9ICEwLCB0aGlzLm1hZGVBYnNvbHV0ZSA9ICExLCB0aGlzLmxhc3RUcmFuc2FjdGlvbiA9IDAsIHRoaXMubWVhc3VyZVRpbWVvdXQgPSAtMTtcbiAgICBsZXQgZSA9IHQuc3RhdGUuZmFjZXQoQ2YpO1xuICAgIHRoaXMucG9zaXRpb24gPSBlLnBvc2l0aW9uLCB0aGlzLnBhcmVudCA9IGUucGFyZW50LCB0aGlzLmNsYXNzZXMgPSB0LnRoZW1lQ2xhc3NlcywgdGhpcy5jcmVhdGVDb250YWluZXIoKSwgdGhpcy5tZWFzdXJlUmVxID0geyByZWFkOiB0aGlzLnJlYWRNZWFzdXJlLmJpbmQodGhpcyksIHdyaXRlOiB0aGlzLndyaXRlTWVhc3VyZS5iaW5kKHRoaXMpLCBrZXk6IHRoaXMgfSwgdGhpcy5yZXNpemVPYnNlcnZlciA9IHR5cGVvZiBSZXNpemVPYnNlcnZlciA9PSBcImZ1bmN0aW9uXCIgPyBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4gdGhpcy5tZWFzdXJlU29vbigpKSA6IG51bGwsIHRoaXMubWFuYWdlciA9IG5ldyBhRCh0LCBZaywgKG4sIHIpID0+IHRoaXMuY3JlYXRlVG9vbHRpcChuLCByKSwgKG4pID0+IHtcbiAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIgJiYgdGhpcy5yZXNpemVPYnNlcnZlci51bm9ic2VydmUobi5kb20pLCBuLmRvbS5yZW1vdmUoKTtcbiAgICB9KSwgdGhpcy5hYm92ZSA9IHRoaXMubWFuYWdlci50b29sdGlwcy5tYXAoKG4pID0+ICEhbi5hYm92ZSksIHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSB0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT0gXCJmdW5jdGlvblwiID8gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKChuKSA9PiB7XG4gICAgICBEYXRlLm5vdygpID4gdGhpcy5sYXN0VHJhbnNhY3Rpb24gLSA1MCAmJiBuLmxlbmd0aCA+IDAgJiYgbltuLmxlbmd0aCAtIDFdLmludGVyc2VjdGlvblJhdGlvIDwgMSAmJiB0aGlzLm1lYXN1cmVTb29uKCk7XG4gICAgfSwgeyB0aHJlc2hvbGQ6IFsxXSB9KSA6IG51bGwsIHRoaXMub2JzZXJ2ZUludGVyc2VjdGlvbigpLCB0Lndpbi5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMubWVhc3VyZVNvb24gPSB0aGlzLm1lYXN1cmVTb29uLmJpbmQodGhpcykpLCB0aGlzLm1heWJlTWVhc3VyZSgpO1xuICB9XG4gIGNyZWF0ZUNvbnRhaW5lcigpIHtcbiAgICB0aGlzLnBhcmVudCA/ICh0aGlzLmNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIHRoaXMuY29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiLCB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSB0aGlzLnZpZXcudGhlbWVDbGFzc2VzLCB0aGlzLnBhcmVudC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRhaW5lcikpIDogdGhpcy5jb250YWluZXIgPSB0aGlzLnZpZXcuZG9tO1xuICB9XG4gIG9ic2VydmVJbnRlcnNlY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgIHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgZm9yIChsZXQgdCBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKVxuICAgICAgICB0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyLm9ic2VydmUodC5kb20pO1xuICAgIH1cbiAgfVxuICBtZWFzdXJlU29vbigpIHtcbiAgICB0aGlzLm1lYXN1cmVUaW1lb3V0IDwgMCAmJiAodGhpcy5tZWFzdXJlVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5tZWFzdXJlVGltZW91dCA9IC0xLCB0aGlzLm1heWJlTWVhc3VyZSgpO1xuICAgIH0sIDUwKSk7XG4gIH1cbiAgdXBkYXRlKHQpIHtcbiAgICB0LnRyYW5zYWN0aW9ucy5sZW5ndGggJiYgKHRoaXMubGFzdFRyYW5zYWN0aW9uID0gRGF0ZS5ub3coKSk7XG4gICAgbGV0IGUgPSB0aGlzLm1hbmFnZXIudXBkYXRlKHQsIHRoaXMuYWJvdmUpO1xuICAgIGUgJiYgdGhpcy5vYnNlcnZlSW50ZXJzZWN0aW9uKCk7XG4gICAgbGV0IG4gPSBlIHx8IHQuZ2VvbWV0cnlDaGFuZ2VkLCByID0gdC5zdGF0ZS5mYWNldChDZik7XG4gICAgaWYgKHIucG9zaXRpb24gIT0gdGhpcy5wb3NpdGlvbiAmJiAhdGhpcy5tYWRlQWJzb2x1dGUpIHtcbiAgICAgIHRoaXMucG9zaXRpb24gPSByLnBvc2l0aW9uO1xuICAgICAgZm9yIChsZXQgaSBvZiB0aGlzLm1hbmFnZXIudG9vbHRpcFZpZXdzKVxuICAgICAgICBpLmRvbS5zdHlsZS5wb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gICAgICBuID0gITA7XG4gICAgfVxuICAgIGlmIChyLnBhcmVudCAhPSB0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQgJiYgdGhpcy5jb250YWluZXIucmVtb3ZlKCksIHRoaXMucGFyZW50ID0gci5wYXJlbnQsIHRoaXMuY3JlYXRlQ29udGFpbmVyKCk7XG4gICAgICBmb3IgKGxldCBpIG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpXG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGkuZG9tKTtcbiAgICAgIG4gPSAhMDtcbiAgICB9IGVsc2VcbiAgICAgIHRoaXMucGFyZW50ICYmIHRoaXMudmlldy50aGVtZUNsYXNzZXMgIT0gdGhpcy5jbGFzc2VzICYmICh0aGlzLmNsYXNzZXMgPSB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSB0aGlzLnZpZXcudGhlbWVDbGFzc2VzKTtcbiAgICBuICYmIHRoaXMubWF5YmVNZWFzdXJlKCk7XG4gIH1cbiAgY3JlYXRlVG9vbHRpcCh0LCBlKSB7XG4gICAgbGV0IG4gPSB0LmNyZWF0ZSh0aGlzLnZpZXcpLCByID0gZSA/IGUuZG9tIDogbnVsbDtcbiAgICBpZiAobi5kb20uY2xhc3NMaXN0LmFkZChcImNtLXRvb2x0aXBcIiksIHQuYXJyb3cgJiYgIW4uZG9tLnF1ZXJ5U2VsZWN0b3IoXCIuY20tdG9vbHRpcCA+IC5jbS10b29sdGlwLWFycm93XCIpKSB7XG4gICAgICBsZXQgaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBpLmNsYXNzTmFtZSA9IFwiY20tdG9vbHRpcC1hcnJvd1wiLCBuLmRvbS5pbnNlcnRCZWZvcmUoaSwgcik7XG4gICAgfVxuICAgIHJldHVybiBuLmRvbS5zdHlsZS5wb3NpdGlvbiA9IHRoaXMucG9zaXRpb24sIG4uZG9tLnN0eWxlLnRvcCA9IHlhLCBuLmRvbS5zdHlsZS5sZWZ0ID0gXCIwcHhcIiwgdGhpcy5jb250YWluZXIuaW5zZXJ0QmVmb3JlKG4uZG9tLCByKSwgbi5tb3VudCAmJiBuLm1vdW50KHRoaXMudmlldyksIHRoaXMucmVzaXplT2JzZXJ2ZXIgJiYgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKG4uZG9tKSwgbjtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHZhciB0LCBlLCBuO1xuICAgIHRoaXMudmlldy53aW4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLm1lYXN1cmVTb29uKTtcbiAgICBmb3IgKGxldCByIG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpXG4gICAgICByLmRvbS5yZW1vdmUoKSwgKHQgPSByLmRlc3Ryb3kpID09PSBudWxsIHx8IHQgPT09IHZvaWQgMCB8fCB0LmNhbGwocik7XG4gICAgdGhpcy5wYXJlbnQgJiYgdGhpcy5jb250YWluZXIucmVtb3ZlKCksIChlID0gdGhpcy5yZXNpemVPYnNlcnZlcikgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwIHx8IGUuZGlzY29ubmVjdCgpLCAobiA9IHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIpID09PSBudWxsIHx8IG4gPT09IHZvaWQgMCB8fCBuLmRpc2Nvbm5lY3QoKSwgY2xlYXJUaW1lb3V0KHRoaXMubWVhc3VyZVRpbWVvdXQpO1xuICB9XG4gIHJlYWRNZWFzdXJlKCkge1xuICAgIGxldCB0ID0gdGhpcy52aWV3LmRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgZSA9IDEsIG4gPSAxLCByID0gITE7XG4gICAgaWYgKHRoaXMucG9zaXRpb24gPT0gXCJmaXhlZFwiICYmIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MubGVuZ3RoKSB7XG4gICAgICBsZXQgeyBkb206IGkgfSA9IHRoaXMubWFuYWdlci50b29sdGlwVmlld3NbMF07XG4gICAgICBpZiAoZGUuZ2Vja28pXG4gICAgICAgIHIgPSBpLm9mZnNldFBhcmVudCAhPSB0aGlzLmNvbnRhaW5lci5vd25lckRvY3VtZW50LmJvZHk7XG4gICAgICBlbHNlIGlmIChpLnN0eWxlLnRvcCA9PSB5YSAmJiBpLnN0eWxlLmxlZnQgPT0gXCIwcHhcIikge1xuICAgICAgICBsZXQgcyA9IGkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHIgPSBNYXRoLmFicyhzLnRvcCArIDFlNCkgPiAxIHx8IE1hdGguYWJzKHMubGVmdCkgPiAxO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAociB8fCB0aGlzLnBvc2l0aW9uID09IFwiYWJzb2x1dGVcIilcbiAgICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgICBsZXQgaSA9IHRoaXMucGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpLndpZHRoICYmIGkuaGVpZ2h0ICYmIChlID0gaS53aWR0aCAvIHRoaXMucGFyZW50Lm9mZnNldFdpZHRoLCBuID0gaS5oZWlnaHQgLyB0aGlzLnBhcmVudC5vZmZzZXRIZWlnaHQpO1xuICAgICAgfSBlbHNlXG4gICAgICAgICh7IHNjYWxlWDogZSwgc2NhbGVZOiBuIH0gPSB0aGlzLnZpZXcudmlld1N0YXRlKTtcbiAgICByZXR1cm4ge1xuICAgICAgZWRpdG9yOiB0LFxuICAgICAgcGFyZW50OiB0aGlzLnBhcmVudCA/IHRoaXMuY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogdCxcbiAgICAgIHBvczogdGhpcy5tYW5hZ2VyLnRvb2x0aXBzLm1hcCgoaSwgcykgPT4ge1xuICAgICAgICBsZXQgbyA9IHRoaXMubWFuYWdlci50b29sdGlwVmlld3Nbc107XG4gICAgICAgIHJldHVybiBvLmdldENvb3JkcyA/IG8uZ2V0Q29vcmRzKGkucG9zKSA6IHRoaXMudmlldy5jb29yZHNBdFBvcyhpLnBvcyk7XG4gICAgICB9KSxcbiAgICAgIHNpemU6IHRoaXMubWFuYWdlci50b29sdGlwVmlld3MubWFwKCh7IGRvbTogaSB9KSA9PiBpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpKSxcbiAgICAgIHNwYWNlOiB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoQ2YpLnRvb2x0aXBTcGFjZSh0aGlzLnZpZXcpLFxuICAgICAgc2NhbGVYOiBlLFxuICAgICAgc2NhbGVZOiBuLFxuICAgICAgbWFrZUFic29sdXRlOiByXG4gICAgfTtcbiAgfVxuICB3cml0ZU1lYXN1cmUodCkge1xuICAgIHZhciBlO1xuICAgIGlmICh0Lm1ha2VBYnNvbHV0ZSkge1xuICAgICAgdGhpcy5tYWRlQWJzb2x1dGUgPSAhMCwgdGhpcy5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgIGZvciAobGV0IGEgb2YgdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3cylcbiAgICAgICAgYS5kb20uc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgfVxuICAgIGxldCB7IGVkaXRvcjogbiwgc3BhY2U6IHIsIHNjYWxlWDogaSwgc2NhbGVZOiBzIH0gPSB0LCBvID0gW107XG4gICAgZm9yIChsZXQgYSA9IDA7IGEgPCB0aGlzLm1hbmFnZXIudG9vbHRpcHMubGVuZ3RoOyBhKyspIHtcbiAgICAgIGxldCBsID0gdGhpcy5tYW5hZ2VyLnRvb2x0aXBzW2FdLCBjID0gdGhpcy5tYW5hZ2VyLnRvb2x0aXBWaWV3c1thXSwgeyBkb206IHUgfSA9IGMsIGQgPSB0LnBvc1thXSwgZiA9IHQuc2l6ZVthXTtcbiAgICAgIGlmICghZCB8fCBkLmJvdHRvbSA8PSBNYXRoLm1heChuLnRvcCwgci50b3ApIHx8IGQudG9wID49IE1hdGgubWluKG4uYm90dG9tLCByLmJvdHRvbSkgfHwgZC5yaWdodCA8IE1hdGgubWF4KG4ubGVmdCwgci5sZWZ0KSAtIDAuMSB8fCBkLmxlZnQgPiBNYXRoLm1pbihuLnJpZ2h0LCByLnJpZ2h0KSArIDAuMSkge1xuICAgICAgICB1LnN0eWxlLnRvcCA9IHlhO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxldCBoID0gbC5hcnJvdyA/IGMuZG9tLnF1ZXJ5U2VsZWN0b3IoXCIuY20tdG9vbHRpcC1hcnJvd1wiKSA6IG51bGwsIHAgPSBoID8gNyA6IDAsIE8gPSBmLnJpZ2h0IC0gZi5sZWZ0LCBtID0gKGUgPSBUdi5nZXQoYykpICE9PSBudWxsICYmIGUgIT09IHZvaWQgMCA/IGUgOiBmLmJvdHRvbSAtIGYudG9wLCB5ID0gYy5vZmZzZXQgfHwgdUQsIGIgPSB0aGlzLnZpZXcudGV4dERpcmVjdGlvbiA9PSBRdC5MVFIsIGcgPSBmLndpZHRoID4gci5yaWdodCAtIHIubGVmdCA/IGIgPyByLmxlZnQgOiByLnJpZ2h0IC0gZi53aWR0aCA6IGIgPyBNYXRoLm1pbihkLmxlZnQgLSAoaCA/IDE0IDogMCkgKyB5LngsIHIucmlnaHQgLSBPKSA6IE1hdGgubWF4KHIubGVmdCwgZC5sZWZ0IC0gTyArIChoID8gMTQgOiAwKSAtIHkueCksIHYgPSB0aGlzLmFib3ZlW2FdO1xuICAgICAgIWwuc3RyaWN0U2lkZSAmJiAodiA/IGQudG9wIC0gKGYuYm90dG9tIC0gZi50b3ApIC0geS55IDwgci50b3AgOiBkLmJvdHRvbSArIChmLmJvdHRvbSAtIGYudG9wKSArIHkueSA+IHIuYm90dG9tKSAmJiB2ID09IHIuYm90dG9tIC0gZC5ib3R0b20gPiBkLnRvcCAtIHIudG9wICYmICh2ID0gdGhpcy5hYm92ZVthXSA9ICF2KTtcbiAgICAgIGxldCBTID0gKHYgPyBkLnRvcCAtIHIudG9wIDogci5ib3R0b20gLSBkLmJvdHRvbSkgLSBwO1xuICAgICAgaWYgKFMgPCBtICYmIGMucmVzaXplICE9PSAhMSkge1xuICAgICAgICBpZiAoUyA8IHRoaXMudmlldy5kZWZhdWx0TGluZUhlaWdodCkge1xuICAgICAgICAgIHUuc3R5bGUudG9wID0geWE7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgVHYuc2V0KGMsIG0pLCB1LnN0eWxlLmhlaWdodCA9IChtID0gUykgLyBzICsgXCJweFwiO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHUuc3R5bGUuaGVpZ2h0ICYmICh1LnN0eWxlLmhlaWdodCA9IFwiXCIpO1xuICAgICAgbGV0IHcgPSB2ID8gZC50b3AgLSBtIC0gcCAtIHkueSA6IGQuYm90dG9tICsgcCArIHkueSwgayA9IGcgKyBPO1xuICAgICAgaWYgKGMub3ZlcmxhcCAhPT0gITApXG4gICAgICAgIGZvciAobGV0IF8gb2YgbylcbiAgICAgICAgICBfLmxlZnQgPCBrICYmIF8ucmlnaHQgPiBnICYmIF8udG9wIDwgdyArIG0gJiYgXy5ib3R0b20gPiB3ICYmICh3ID0gdiA/IF8udG9wIC0gbSAtIDIgLSBwIDogXy5ib3R0b20gKyBwICsgMik7XG4gICAgICBpZiAodGhpcy5wb3NpdGlvbiA9PSBcImFic29sdXRlXCIgPyAodS5zdHlsZS50b3AgPSAodyAtIHQucGFyZW50LnRvcCkgLyBzICsgXCJweFwiLCB1LnN0eWxlLmxlZnQgPSAoZyAtIHQucGFyZW50LmxlZnQpIC8gaSArIFwicHhcIikgOiAodS5zdHlsZS50b3AgPSB3IC8gcyArIFwicHhcIiwgdS5zdHlsZS5sZWZ0ID0gZyAvIGkgKyBcInB4XCIpLCBoKSB7XG4gICAgICAgIGxldCBfID0gZC5sZWZ0ICsgKGIgPyB5LnggOiAteS54KSAtIChnICsgMTQgLSA3KTtcbiAgICAgICAgaC5zdHlsZS5sZWZ0ID0gXyAvIGkgKyBcInB4XCI7XG4gICAgICB9XG4gICAgICBjLm92ZXJsYXAgIT09ICEwICYmIG8ucHVzaCh7IGxlZnQ6IGcsIHRvcDogdywgcmlnaHQ6IGssIGJvdHRvbTogdyArIG0gfSksIHUuY2xhc3NMaXN0LnRvZ2dsZShcImNtLXRvb2x0aXAtYWJvdmVcIiwgdiksIHUuY2xhc3NMaXN0LnRvZ2dsZShcImNtLXRvb2x0aXAtYmVsb3dcIiwgIXYpLCBjLnBvc2l0aW9uZWQgJiYgYy5wb3NpdGlvbmVkKHQuc3BhY2UpO1xuICAgIH1cbiAgfVxuICBtYXliZU1lYXN1cmUoKSB7XG4gICAgaWYgKHRoaXMubWFuYWdlci50b29sdGlwcy5sZW5ndGggJiYgKHRoaXMudmlldy5pblZpZXcgJiYgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMubWVhc3VyZVJlcSksIHRoaXMuaW5WaWV3ICE9IHRoaXMudmlldy5pblZpZXcgJiYgKHRoaXMuaW5WaWV3ID0gdGhpcy52aWV3LmluVmlldywgIXRoaXMuaW5WaWV3KSkpXG4gICAgICBmb3IgKGxldCB0IG9mIHRoaXMubWFuYWdlci50b29sdGlwVmlld3MpXG4gICAgICAgIHQuZG9tLnN0eWxlLnRvcCA9IHlhO1xuICB9XG59LCB7XG4gIGV2ZW50T2JzZXJ2ZXJzOiB7XG4gICAgc2Nyb2xsKCkge1xuICAgICAgdGhpcy5tYXliZU1lYXN1cmUoKTtcbiAgICB9XG4gIH1cbn0pLCBjRCA9IC8qIEBfX1BVUkVfXyAqLyBTZS5iYXNlVGhlbWUoe1xuICBcIi5jbS10b29sdGlwXCI6IHtcbiAgICB6SW5kZXg6IDEwMCxcbiAgICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiXG4gIH0sXG4gIFwiJmxpZ2h0IC5jbS10b29sdGlwXCI6IHtcbiAgICBib3JkZXI6IFwiMXB4IHNvbGlkICNiYmJcIixcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IFwiI2Y1ZjVmNVwiXG4gIH0sXG4gIFwiJmxpZ2h0IC5jbS10b29sdGlwLXNlY3Rpb246bm90KDpmaXJzdC1jaGlsZClcIjoge1xuICAgIGJvcmRlclRvcDogXCIxcHggc29saWQgI2JiYlwiXG4gIH0sXG4gIFwiJmRhcmsgLmNtLXRvb2x0aXBcIjoge1xuICAgIGJhY2tncm91bmRDb2xvcjogXCIjMzMzMzM4XCIsXG4gICAgY29sb3I6IFwid2hpdGVcIlxuICB9LFxuICBcIi5jbS10b29sdGlwLWFycm93XCI6IHtcbiAgICBoZWlnaHQ6IFwiN3B4XCIsXG4gICAgd2lkdGg6IGAkezcgKiAyfXB4YCxcbiAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgIHpJbmRleDogLTEsXG4gICAgb3ZlcmZsb3c6IFwiaGlkZGVuXCIsXG4gICAgXCImOmJlZm9yZSwgJjphZnRlclwiOiB7XG4gICAgICBjb250ZW50OiBcIicnXCIsXG4gICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLFxuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDAsXG4gICAgICBib3JkZXJMZWZ0OiBcIjdweCBzb2xpZCB0cmFuc3BhcmVudFwiLFxuICAgICAgYm9yZGVyUmlnaHQ6IFwiN3B4IHNvbGlkIHRyYW5zcGFyZW50XCJcbiAgICB9LFxuICAgIFwiLmNtLXRvb2x0aXAtYWJvdmUgJlwiOiB7XG4gICAgICBib3R0b206IFwiLTdweFwiLFxuICAgICAgXCImOmJlZm9yZVwiOiB7XG4gICAgICAgIGJvcmRlclRvcDogXCI3cHggc29saWQgI2JiYlwiXG4gICAgICB9LFxuICAgICAgXCImOmFmdGVyXCI6IHtcbiAgICAgICAgYm9yZGVyVG9wOiBcIjdweCBzb2xpZCAjZjVmNWY1XCIsXG4gICAgICAgIGJvdHRvbTogXCIxcHhcIlxuICAgICAgfVxuICAgIH0sXG4gICAgXCIuY20tdG9vbHRpcC1iZWxvdyAmXCI6IHtcbiAgICAgIHRvcDogXCItN3B4XCIsXG4gICAgICBcIiY6YmVmb3JlXCI6IHtcbiAgICAgICAgYm9yZGVyQm90dG9tOiBcIjdweCBzb2xpZCAjYmJiXCJcbiAgICAgIH0sXG4gICAgICBcIiY6YWZ0ZXJcIjoge1xuICAgICAgICBib3JkZXJCb3R0b206IFwiN3B4IHNvbGlkICNmNWY1ZjVcIixcbiAgICAgICAgdG9wOiBcIjFweFwiXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBcIiZkYXJrIC5jbS10b29sdGlwIC5jbS10b29sdGlwLWFycm93XCI6IHtcbiAgICBcIiY6YmVmb3JlXCI6IHtcbiAgICAgIGJvcmRlclRvcENvbG9yOiBcIiMzMzMzMzhcIixcbiAgICAgIGJvcmRlckJvdHRvbUNvbG9yOiBcIiMzMzMzMzhcIlxuICAgIH0sXG4gICAgXCImOmFmdGVyXCI6IHtcbiAgICAgIGJvcmRlclRvcENvbG9yOiBcInRyYW5zcGFyZW50XCIsXG4gICAgICBib3JkZXJCb3R0b21Db2xvcjogXCJ0cmFuc3BhcmVudFwiXG4gICAgfVxuICB9XG59KSwgdUQgPSB7IHg6IDAsIHk6IDAgfSwgWWsgPSAvKiBAX19QVVJFX18gKi8gdmUuZGVmaW5lKHtcbiAgZW5hYmxlczogW3FrLCBjRF1cbn0pO1xuZnVuY3Rpb24gemsodCwgZSkge1xuICBsZXQgbiA9IHQucGx1Z2luKHFrKTtcbiAgaWYgKCFuKVxuICAgIHJldHVybiBudWxsO1xuICBsZXQgciA9IG4ubWFuYWdlci50b29sdGlwcy5pbmRleE9mKGUpO1xuICByZXR1cm4gciA8IDAgPyBudWxsIDogbi5tYW5hZ2VyLnRvb2x0aXBWaWV3c1tyXTtcbn1cbmNsYXNzIEhzIGV4dGVuZHMgcXMge1xuICAvKipcbiAgQGludGVybmFsXG4gICovXG4gIGNvbXBhcmUoZSkge1xuICAgIHJldHVybiB0aGlzID09IGUgfHwgdGhpcy5jb25zdHJ1Y3RvciA9PSBlLmNvbnN0cnVjdG9yICYmIHRoaXMuZXEoZSk7XG4gIH1cbiAgLyoqXG4gIENvbXBhcmUgdGhpcyBtYXJrZXIgdG8gYW5vdGhlciBtYXJrZXIgb2YgdGhlIHNhbWUgdHlwZS5cbiAgKi9cbiAgZXEoZSkge1xuICAgIHJldHVybiAhMTtcbiAgfVxuICAvKipcbiAgQ2FsbGVkIGlmIHRoZSBtYXJrZXIgaGFzIGEgYHRvRE9NYCBtZXRob2QgYW5kIGl0cyByZXByZXNlbnRhdGlvblxuICB3YXMgcmVtb3ZlZCBmcm9tIGEgZ3V0dGVyLlxuICAqL1xuICBkZXN0cm95KGUpIHtcbiAgfVxufVxuSHMucHJvdG90eXBlLmVsZW1lbnRDbGFzcyA9IFwiXCI7XG5Icy5wcm90b3R5cGUudG9ET00gPSB2b2lkIDA7XG5Icy5wcm90b3R5cGUubWFwTW9kZSA9IG9uLlRyYWNrQmVmb3JlO1xuSHMucHJvdG90eXBlLnN0YXJ0U2lkZSA9IEhzLnByb3RvdHlwZS5lbmRTaWRlID0gLTE7XG5Icy5wcm90b3R5cGUucG9pbnQgPSAhMDtcbmNvbnN0IEFmID0gLyogQF9fUFVSRV9fICovIHZlLmRlZmluZSgpLCBhdSA9IC8qIEBfX1BVUkVfXyAqLyB2ZS5kZWZpbmUoKSwgdnAgPSAvKiBAX19QVVJFX18gKi8gdmUuZGVmaW5lKHtcbiAgY29tYmluZTogKHQpID0+IHQuc29tZSgoZSkgPT4gZSlcbn0pO1xuZnVuY3Rpb24gZEQodCkge1xuICBsZXQgZSA9IFtcbiAgICBmRFxuICBdO1xuICByZXR1cm4gdCAmJiB0LmZpeGVkID09PSAhMSAmJiBlLnB1c2godnAub2YoITApKSwgZTtcbn1cbmNvbnN0IGZEID0gLyogQF9fUFVSRV9fICovIHJyLmZyb21DbGFzcyhjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHQpIHtcbiAgICB0aGlzLnZpZXcgPSB0LCB0aGlzLnByZXZWaWV3cG9ydCA9IHQudmlld3BvcnQsIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS1ndXR0ZXJzXCIsIHRoaXMuZG9tLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKSwgdGhpcy5kb20uc3R5bGUubWluSGVpZ2h0ID0gdGhpcy52aWV3LmNvbnRlbnRIZWlnaHQgLyB0aGlzLnZpZXcuc2NhbGVZICsgXCJweFwiLCB0aGlzLmd1dHRlcnMgPSB0LnN0YXRlLmZhY2V0KGF1KS5tYXAoKGUpID0+IG5ldyAkdih0LCBlKSk7XG4gICAgZm9yIChsZXQgZSBvZiB0aGlzLmd1dHRlcnMpXG4gICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZChlLmRvbSk7XG4gICAgdGhpcy5maXhlZCA9ICF0LnN0YXRlLmZhY2V0KHZwKSwgdGhpcy5maXhlZCAmJiAodGhpcy5kb20uc3R5bGUucG9zaXRpb24gPSBcInN0aWNreVwiKSwgdGhpcy5zeW5jR3V0dGVycyghMSksIHQuc2Nyb2xsRE9NLmluc2VydEJlZm9yZSh0aGlzLmRvbSwgdC5jb250ZW50RE9NKTtcbiAgfVxuICB1cGRhdGUodCkge1xuICAgIGlmICh0aGlzLnVwZGF0ZUd1dHRlcnModCkpIHtcbiAgICAgIGxldCBlID0gdGhpcy5wcmV2Vmlld3BvcnQsIG4gPSB0LnZpZXcudmlld3BvcnQsIHIgPSBNYXRoLm1pbihlLnRvLCBuLnRvKSAtIE1hdGgubWF4KGUuZnJvbSwgbi5mcm9tKTtcbiAgICAgIHRoaXMuc3luY0d1dHRlcnMociA8IChuLnRvIC0gbi5mcm9tKSAqIDAuOCk7XG4gICAgfVxuICAgIHQuZ2VvbWV0cnlDaGFuZ2VkICYmICh0aGlzLmRvbS5zdHlsZS5taW5IZWlnaHQgPSB0aGlzLnZpZXcuY29udGVudEhlaWdodCArIFwicHhcIiksIHRoaXMudmlldy5zdGF0ZS5mYWNldCh2cCkgIT0gIXRoaXMuZml4ZWQgJiYgKHRoaXMuZml4ZWQgPSAhdGhpcy5maXhlZCwgdGhpcy5kb20uc3R5bGUucG9zaXRpb24gPSB0aGlzLmZpeGVkID8gXCJzdGlja3lcIiA6IFwiXCIpLCB0aGlzLnByZXZWaWV3cG9ydCA9IHQudmlldy52aWV3cG9ydDtcbiAgfVxuICBzeW5jR3V0dGVycyh0KSB7XG4gICAgbGV0IGUgPSB0aGlzLmRvbS5uZXh0U2libGluZztcbiAgICB0ICYmIHRoaXMuZG9tLnJlbW92ZSgpO1xuICAgIGxldCBuID0gemUuaXRlcih0aGlzLnZpZXcuc3RhdGUuZmFjZXQoQWYpLCB0aGlzLnZpZXcudmlld3BvcnQuZnJvbSksIHIgPSBbXSwgaSA9IHRoaXMuZ3V0dGVycy5tYXAoKHMpID0+IG5ldyBoRChzLCB0aGlzLnZpZXcudmlld3BvcnQsIC10aGlzLnZpZXcuZG9jdW1lbnRQYWRkaW5nLnRvcCkpO1xuICAgIGZvciAobGV0IHMgb2YgdGhpcy52aWV3LnZpZXdwb3J0TGluZUJsb2NrcylcbiAgICAgIGlmIChyLmxlbmd0aCAmJiAociA9IFtdKSwgQXJyYXkuaXNBcnJheShzLnR5cGUpKSB7XG4gICAgICAgIGxldCBvID0gITA7XG4gICAgICAgIGZvciAobGV0IGEgb2Ygcy50eXBlKVxuICAgICAgICAgIGlmIChhLnR5cGUgPT0gZnIuVGV4dCAmJiBvKSB7XG4gICAgICAgICAgICB5cChuLCByLCBhLmZyb20pO1xuICAgICAgICAgICAgZm9yIChsZXQgbCBvZiBpKVxuICAgICAgICAgICAgICBsLmxpbmUodGhpcy52aWV3LCBhLCByKTtcbiAgICAgICAgICAgIG8gPSAhMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGEud2lkZ2V0KVxuICAgICAgICAgICAgZm9yIChsZXQgbCBvZiBpKVxuICAgICAgICAgICAgICBsLndpZGdldCh0aGlzLnZpZXcsIGEpO1xuICAgICAgfSBlbHNlIGlmIChzLnR5cGUgPT0gZnIuVGV4dCkge1xuICAgICAgICB5cChuLCByLCBzLmZyb20pO1xuICAgICAgICBmb3IgKGxldCBvIG9mIGkpXG4gICAgICAgICAgby5saW5lKHRoaXMudmlldywgcywgcik7XG4gICAgICB9IGVsc2UgaWYgKHMud2lkZ2V0KVxuICAgICAgICBmb3IgKGxldCBvIG9mIGkpXG4gICAgICAgICAgby53aWRnZXQodGhpcy52aWV3LCBzKTtcbiAgICBmb3IgKGxldCBzIG9mIGkpXG4gICAgICBzLmZpbmlzaCgpO1xuICAgIHQgJiYgdGhpcy52aWV3LnNjcm9sbERPTS5pbnNlcnRCZWZvcmUodGhpcy5kb20sIGUpO1xuICB9XG4gIHVwZGF0ZUd1dHRlcnModCkge1xuICAgIGxldCBlID0gdC5zdGFydFN0YXRlLmZhY2V0KGF1KSwgbiA9IHQuc3RhdGUuZmFjZXQoYXUpLCByID0gdC5kb2NDaGFuZ2VkIHx8IHQuaGVpZ2h0Q2hhbmdlZCB8fCB0LnZpZXdwb3J0Q2hhbmdlZCB8fCAhemUuZXEodC5zdGFydFN0YXRlLmZhY2V0KEFmKSwgdC5zdGF0ZS5mYWNldChBZiksIHQudmlldy52aWV3cG9ydC5mcm9tLCB0LnZpZXcudmlld3BvcnQudG8pO1xuICAgIGlmIChlID09IG4pXG4gICAgICBmb3IgKGxldCBpIG9mIHRoaXMuZ3V0dGVycylcbiAgICAgICAgaS51cGRhdGUodCkgJiYgKHIgPSAhMCk7XG4gICAgZWxzZSB7XG4gICAgICByID0gITA7XG4gICAgICBsZXQgaSA9IFtdO1xuICAgICAgZm9yIChsZXQgcyBvZiBuKSB7XG4gICAgICAgIGxldCBvID0gZS5pbmRleE9mKHMpO1xuICAgICAgICBvIDwgMCA/IGkucHVzaChuZXcgJHYodGhpcy52aWV3LCBzKSkgOiAodGhpcy5ndXR0ZXJzW29dLnVwZGF0ZSh0KSwgaS5wdXNoKHRoaXMuZ3V0dGVyc1tvXSkpO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgcyBvZiB0aGlzLmd1dHRlcnMpXG4gICAgICAgIHMuZG9tLnJlbW92ZSgpLCBpLmluZGV4T2YocykgPCAwICYmIHMuZGVzdHJveSgpO1xuICAgICAgZm9yIChsZXQgcyBvZiBpKVxuICAgICAgICB0aGlzLmRvbS5hcHBlbmRDaGlsZChzLmRvbSk7XG4gICAgICB0aGlzLmd1dHRlcnMgPSBpO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGZvciAobGV0IHQgb2YgdGhpcy5ndXR0ZXJzKVxuICAgICAgdC5kZXN0cm95KCk7XG4gICAgdGhpcy5kb20ucmVtb3ZlKCk7XG4gIH1cbn0sIHtcbiAgcHJvdmlkZTogKHQpID0+IFNlLnNjcm9sbE1hcmdpbnMub2YoKGUpID0+IHtcbiAgICBsZXQgbiA9IGUucGx1Z2luKHQpO1xuICAgIHJldHVybiAhbiB8fCBuLmd1dHRlcnMubGVuZ3RoID09IDAgfHwgIW4uZml4ZWQgPyBudWxsIDogZS50ZXh0RGlyZWN0aW9uID09IFF0LkxUUiA/IHsgbGVmdDogbi5kb20ub2Zmc2V0V2lkdGggKiBlLnNjYWxlWCB9IDogeyByaWdodDogbi5kb20ub2Zmc2V0V2lkdGggKiBlLnNjYWxlWCB9O1xuICB9KVxufSk7XG5mdW5jdGlvbiBFdih0KSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHQpID8gdCA6IFt0XTtcbn1cbmZ1bmN0aW9uIHlwKHQsIGUsIG4pIHtcbiAgZm9yICg7IHQudmFsdWUgJiYgdC5mcm9tIDw9IG47IClcbiAgICB0LmZyb20gPT0gbiAmJiBlLnB1c2godC52YWx1ZSksIHQubmV4dCgpO1xufVxuY2xhc3MgaEQge1xuICBjb25zdHJ1Y3RvcihlLCBuLCByKSB7XG4gICAgdGhpcy5ndXR0ZXIgPSBlLCB0aGlzLmhlaWdodCA9IHIsIHRoaXMuaSA9IDAsIHRoaXMuY3Vyc29yID0gemUuaXRlcihlLm1hcmtlcnMsIG4uZnJvbSk7XG4gIH1cbiAgYWRkRWxlbWVudChlLCBuLCByKSB7XG4gICAgbGV0IHsgZ3V0dGVyOiBpIH0gPSB0aGlzLCBzID0gKG4udG9wIC0gdGhpcy5oZWlnaHQpIC8gZS5zY2FsZVksIG8gPSBuLmhlaWdodCAvIGUuc2NhbGVZO1xuICAgIGlmICh0aGlzLmkgPT0gaS5lbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgIGxldCBhID0gbmV3IEhrKGUsIG8sIHMsIHIpO1xuICAgICAgaS5lbGVtZW50cy5wdXNoKGEpLCBpLmRvbS5hcHBlbmRDaGlsZChhLmRvbSk7XG4gICAgfSBlbHNlXG4gICAgICBpLmVsZW1lbnRzW3RoaXMuaV0udXBkYXRlKGUsIG8sIHMsIHIpO1xuICAgIHRoaXMuaGVpZ2h0ID0gbi5ib3R0b20sIHRoaXMuaSsrO1xuICB9XG4gIGxpbmUoZSwgbiwgcikge1xuICAgIGxldCBpID0gW107XG4gICAgeXAodGhpcy5jdXJzb3IsIGksIG4uZnJvbSksIHIubGVuZ3RoICYmIChpID0gaS5jb25jYXQocikpO1xuICAgIGxldCBzID0gdGhpcy5ndXR0ZXIuY29uZmlnLmxpbmVNYXJrZXIoZSwgbiwgaSk7XG4gICAgcyAmJiBpLnVuc2hpZnQocyk7XG4gICAgbGV0IG8gPSB0aGlzLmd1dHRlcjtcbiAgICBpLmxlbmd0aCA9PSAwICYmICFvLmNvbmZpZy5yZW5kZXJFbXB0eUVsZW1lbnRzIHx8IHRoaXMuYWRkRWxlbWVudChlLCBuLCBpKTtcbiAgfVxuICB3aWRnZXQoZSwgbikge1xuICAgIGxldCByID0gdGhpcy5ndXR0ZXIuY29uZmlnLndpZGdldE1hcmtlcihlLCBuLndpZGdldCwgbik7XG4gICAgciAmJiB0aGlzLmFkZEVsZW1lbnQoZSwgbiwgW3JdKTtcbiAgfVxuICBmaW5pc2goKSB7XG4gICAgbGV0IGUgPSB0aGlzLmd1dHRlcjtcbiAgICBmb3IgKDsgZS5lbGVtZW50cy5sZW5ndGggPiB0aGlzLmk7ICkge1xuICAgICAgbGV0IG4gPSBlLmVsZW1lbnRzLnBvcCgpO1xuICAgICAgZS5kb20ucmVtb3ZlQ2hpbGQobi5kb20pLCBuLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzICR2IHtcbiAgY29uc3RydWN0b3IoZSwgbikge1xuICAgIHRoaXMudmlldyA9IGUsIHRoaXMuY29uZmlnID0gbiwgdGhpcy5lbGVtZW50cyA9IFtdLCB0aGlzLnNwYWNlciA9IG51bGwsIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS1ndXR0ZXJcIiArICh0aGlzLmNvbmZpZy5jbGFzcyA/IFwiIFwiICsgdGhpcy5jb25maWcuY2xhc3MgOiBcIlwiKTtcbiAgICBmb3IgKGxldCByIGluIG4uZG9tRXZlbnRIYW5kbGVycylcbiAgICAgIHRoaXMuZG9tLmFkZEV2ZW50TGlzdGVuZXIociwgKGkpID0+IHtcbiAgICAgICAgbGV0IHMgPSBpLnRhcmdldCwgbztcbiAgICAgICAgaWYgKHMgIT0gdGhpcy5kb20gJiYgdGhpcy5kb20uY29udGFpbnMocykpIHtcbiAgICAgICAgICBmb3IgKDsgcy5wYXJlbnROb2RlICE9IHRoaXMuZG9tOyApXG4gICAgICAgICAgICBzID0gcy5wYXJlbnROb2RlO1xuICAgICAgICAgIGxldCBsID0gcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICBvID0gKGwudG9wICsgbC5ib3R0b20pIC8gMjtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgbyA9IGkuY2xpZW50WTtcbiAgICAgICAgbGV0IGEgPSBlLmxpbmVCbG9ja0F0SGVpZ2h0KG8gLSBlLmRvY3VtZW50VG9wKTtcbiAgICAgICAgbi5kb21FdmVudEhhbmRsZXJzW3JdKGUsIGEsIGkpICYmIGkucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH0pO1xuICAgIHRoaXMubWFya2VycyA9IEV2KG4ubWFya2VycyhlKSksIG4uaW5pdGlhbFNwYWNlciAmJiAodGhpcy5zcGFjZXIgPSBuZXcgSGsoZSwgMCwgMCwgW24uaW5pdGlhbFNwYWNlcihlKV0pLCB0aGlzLmRvbS5hcHBlbmRDaGlsZCh0aGlzLnNwYWNlci5kb20pLCB0aGlzLnNwYWNlci5kb20uc3R5bGUuY3NzVGV4dCArPSBcInZpc2liaWxpdHk6IGhpZGRlbjsgcG9pbnRlci1ldmVudHM6IG5vbmVcIik7XG4gIH1cbiAgdXBkYXRlKGUpIHtcbiAgICBsZXQgbiA9IHRoaXMubWFya2VycztcbiAgICBpZiAodGhpcy5tYXJrZXJzID0gRXYodGhpcy5jb25maWcubWFya2VycyhlLnZpZXcpKSwgdGhpcy5zcGFjZXIgJiYgdGhpcy5jb25maWcudXBkYXRlU3BhY2VyKSB7XG4gICAgICBsZXQgaSA9IHRoaXMuY29uZmlnLnVwZGF0ZVNwYWNlcih0aGlzLnNwYWNlci5tYXJrZXJzWzBdLCBlKTtcbiAgICAgIGkgIT0gdGhpcy5zcGFjZXIubWFya2Vyc1swXSAmJiB0aGlzLnNwYWNlci51cGRhdGUoZS52aWV3LCAwLCAwLCBbaV0pO1xuICAgIH1cbiAgICBsZXQgciA9IGUudmlldy52aWV3cG9ydDtcbiAgICByZXR1cm4gIXplLmVxKHRoaXMubWFya2Vycywgbiwgci5mcm9tLCByLnRvKSB8fCAodGhpcy5jb25maWcubGluZU1hcmtlckNoYW5nZSA/IHRoaXMuY29uZmlnLmxpbmVNYXJrZXJDaGFuZ2UoZSkgOiAhMSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBmb3IgKGxldCBlIG9mIHRoaXMuZWxlbWVudHMpXG4gICAgICBlLmRlc3Ryb3koKTtcbiAgfVxufVxuY2xhc3MgSGsge1xuICBjb25zdHJ1Y3RvcihlLCBuLCByLCBpKSB7XG4gICAgdGhpcy5oZWlnaHQgPSAtMSwgdGhpcy5hYm92ZSA9IDAsIHRoaXMubWFya2VycyA9IFtdLCB0aGlzLmRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksIHRoaXMuZG9tLmNsYXNzTmFtZSA9IFwiY20tZ3V0dGVyRWxlbWVudFwiLCB0aGlzLnVwZGF0ZShlLCBuLCByLCBpKTtcbiAgfVxuICB1cGRhdGUoZSwgbiwgciwgaSkge1xuICAgIHRoaXMuaGVpZ2h0ICE9IG4gJiYgKHRoaXMuaGVpZ2h0ID0gbiwgdGhpcy5kb20uc3R5bGUuaGVpZ2h0ID0gbiArIFwicHhcIiksIHRoaXMuYWJvdmUgIT0gciAmJiAodGhpcy5kb20uc3R5bGUubWFyZ2luVG9wID0gKHRoaXMuYWJvdmUgPSByKSA/IHIgKyBcInB4XCIgOiBcIlwiKSwgcEQodGhpcy5tYXJrZXJzLCBpKSB8fCB0aGlzLnNldE1hcmtlcnMoZSwgaSk7XG4gIH1cbiAgc2V0TWFya2VycyhlLCBuKSB7XG4gICAgbGV0IHIgPSBcImNtLWd1dHRlckVsZW1lbnRcIiwgaSA9IHRoaXMuZG9tLmZpcnN0Q2hpbGQ7XG4gICAgZm9yIChsZXQgcyA9IDAsIG8gPSAwOyA7ICkge1xuICAgICAgbGV0IGEgPSBvLCBsID0gcyA8IG4ubGVuZ3RoID8gbltzKytdIDogbnVsbCwgYyA9ICExO1xuICAgICAgaWYgKGwpIHtcbiAgICAgICAgbGV0IHUgPSBsLmVsZW1lbnRDbGFzcztcbiAgICAgICAgdSAmJiAociArPSBcIiBcIiArIHUpO1xuICAgICAgICBmb3IgKGxldCBkID0gbzsgZCA8IHRoaXMubWFya2Vycy5sZW5ndGg7IGQrKylcbiAgICAgICAgICBpZiAodGhpcy5tYXJrZXJzW2RdLmNvbXBhcmUobCkpIHtcbiAgICAgICAgICAgIGEgPSBkLCBjID0gITA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9IGVsc2VcbiAgICAgICAgYSA9IHRoaXMubWFya2Vycy5sZW5ndGg7XG4gICAgICBmb3IgKDsgbyA8IGE7ICkge1xuICAgICAgICBsZXQgdSA9IHRoaXMubWFya2Vyc1tvKytdO1xuICAgICAgICBpZiAodS50b0RPTSkge1xuICAgICAgICAgIHUuZGVzdHJveShpKTtcbiAgICAgICAgICBsZXQgZCA9IGkubmV4dFNpYmxpbmc7XG4gICAgICAgICAgaS5yZW1vdmUoKSwgaSA9IGQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghbClcbiAgICAgICAgYnJlYWs7XG4gICAgICBsLnRvRE9NICYmIChjID8gaSA9IGkubmV4dFNpYmxpbmcgOiB0aGlzLmRvbS5pbnNlcnRCZWZvcmUobC50b0RPTShlKSwgaSkpLCBjICYmIG8rKztcbiAgICB9XG4gICAgdGhpcy5kb20uY2xhc3NOYW1lID0gciwgdGhpcy5tYXJrZXJzID0gbjtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuc2V0TWFya2VycyhudWxsLCBbXSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBEKHQsIGUpIHtcbiAgaWYgKHQubGVuZ3RoICE9IGUubGVuZ3RoKVxuICAgIHJldHVybiAhMTtcbiAgZm9yIChsZXQgbiA9IDA7IG4gPCB0Lmxlbmd0aDsgbisrKVxuICAgIGlmICghdFtuXS5jb21wYXJlKGVbbl0pKVxuICAgICAgcmV0dXJuICExO1xuICByZXR1cm4gITA7XG59XG5jb25zdCBPRCA9IC8qIEBfX1BVUkVfXyAqLyB2ZS5kZWZpbmUoKSwgcG8gPSAvKiBAX19QVVJFX18gKi8gdmUuZGVmaW5lKHtcbiAgY29tYmluZSh0KSB7XG4gICAgcmV0dXJuIFVkKHQsIHsgZm9ybWF0TnVtYmVyOiBTdHJpbmcsIGRvbUV2ZW50SGFuZGxlcnM6IHt9IH0sIHtcbiAgICAgIGRvbUV2ZW50SGFuZGxlcnMoZSwgbikge1xuICAgICAgICBsZXQgciA9IE9iamVjdC5hc3NpZ24oe30sIGUpO1xuICAgICAgICBmb3IgKGxldCBpIGluIG4pIHtcbiAgICAgICAgICBsZXQgcyA9IHJbaV0sIG8gPSBuW2ldO1xuICAgICAgICAgIHJbaV0gPSBzID8gKGEsIGwsIGMpID0+IHMoYSwgbCwgYykgfHwgbyhhLCBsLCBjKSA6IG87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn0pO1xuY2xhc3MgUmYgZXh0ZW5kcyBIcyB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcigpLCB0aGlzLm51bWJlciA9IGU7XG4gIH1cbiAgZXEoZSkge1xuICAgIHJldHVybiB0aGlzLm51bWJlciA9PSBlLm51bWJlcjtcbiAgfVxuICB0b0RPTSgpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy5udW1iZXIpO1xuICB9XG59XG5mdW5jdGlvbiBOZih0LCBlKSB7XG4gIHJldHVybiB0LnN0YXRlLmZhY2V0KHBvKS5mb3JtYXROdW1iZXIoZSwgdC5zdGF0ZSk7XG59XG5jb25zdCBnRCA9IC8qIEBfX1BVUkVfXyAqLyBhdS5jb21wdXRlKFtwb10sICh0KSA9PiAoe1xuICBjbGFzczogXCJjbS1saW5lTnVtYmVyc1wiLFxuICByZW5kZXJFbXB0eUVsZW1lbnRzOiAhMSxcbiAgbWFya2VycyhlKSB7XG4gICAgcmV0dXJuIGUuc3RhdGUuZmFjZXQoT0QpO1xuICB9LFxuICBsaW5lTWFya2VyKGUsIG4sIHIpIHtcbiAgICByZXR1cm4gci5zb21lKChpKSA9PiBpLnRvRE9NKSA/IG51bGwgOiBuZXcgUmYoTmYoZSwgZS5zdGF0ZS5kb2MubGluZUF0KG4uZnJvbSkubnVtYmVyKSk7XG4gIH0sXG4gIHdpZGdldE1hcmtlcjogKCkgPT4gbnVsbCxcbiAgbGluZU1hcmtlckNoYW5nZTogKGUpID0+IGUuc3RhcnRTdGF0ZS5mYWNldChwbykgIT0gZS5zdGF0ZS5mYWNldChwbyksXG4gIGluaXRpYWxTcGFjZXIoZSkge1xuICAgIHJldHVybiBuZXcgUmYoTmYoZSwgUXYoZS5zdGF0ZS5kb2MubGluZXMpKSk7XG4gIH0sXG4gIHVwZGF0ZVNwYWNlcihlLCBuKSB7XG4gICAgbGV0IHIgPSBOZihuLnZpZXcsIFF2KG4udmlldy5zdGF0ZS5kb2MubGluZXMpKTtcbiAgICByZXR1cm4gciA9PSBlLm51bWJlciA/IGUgOiBuZXcgUmYocik7XG4gIH0sXG4gIGRvbUV2ZW50SGFuZGxlcnM6IHQuZmFjZXQocG8pLmRvbUV2ZW50SGFuZGxlcnNcbn0pKTtcbmZ1bmN0aW9uIG1EKHQgPSB7fSkge1xuICByZXR1cm4gW1xuICAgIHBvLm9mKHQpLFxuICAgIGREKCksXG4gICAgZ0RcbiAgXTtcbn1cbmZ1bmN0aW9uIFF2KHQpIHtcbiAgbGV0IGUgPSA5O1xuICBmb3IgKDsgZSA8IHQ7IClcbiAgICBlID0gZSAqIDEwICsgOTtcbiAgcmV0dXJuIGU7XG59XG5jb25zdCBGayA9IDEwMjQ7XG5sZXQgYkQgPSAwO1xuY2xhc3MgRm4ge1xuICBjb25zdHJ1Y3RvcihlLCBuKSB7XG4gICAgdGhpcy5mcm9tID0gZSwgdGhpcy50byA9IG47XG4gIH1cbn1cbmNsYXNzIFJlIHtcbiAgLyoqXG4gIENyZWF0ZSBhIG5ldyBub2RlIHByb3AgdHlwZS5cbiAgKi9cbiAgY29uc3RydWN0b3IoZSA9IHt9KSB7XG4gICAgdGhpcy5pZCA9IGJEKyssIHRoaXMucGVyTm9kZSA9ICEhZS5wZXJOb2RlLCB0aGlzLmRlc2VyaWFsaXplID0gZS5kZXNlcmlhbGl6ZSB8fCAoKCkgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBub2RlIHR5cGUgZG9lc24ndCBkZWZpbmUgYSBkZXNlcmlhbGl6ZSBmdW5jdGlvblwiKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgVGhpcyBpcyBtZWFudCB0byBiZSB1c2VkIHdpdGhcbiAgW2BOb2RlU2V0LmV4dGVuZGBdKCNjb21tb24uTm9kZVNldC5leHRlbmQpIG9yXG4gIFtgTFJQYXJzZXIuY29uZmlndXJlYF0oI2xyLlBhcnNlckNvbmZpZy5wcm9wcykgdG8gY29tcHV0ZVxuICBwcm9wIHZhbHVlcyBmb3IgZWFjaCBub2RlIHR5cGUgaW4gdGhlIHNldC4gVGFrZXMgYSBbbWF0Y2hcbiAgb2JqZWN0XSgjY29tbW9uLk5vZGVUeXBlXm1hdGNoKSBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgdW5kZWZpbmVkXG4gIGlmIHRoZSBub2RlIHR5cGUgZG9lc24ndCBnZXQgdGhpcyBwcm9wLCBhbmQgdGhlIHByb3AncyB2YWx1ZSBpZlxuICBpdCBkb2VzLlxuICAqL1xuICBhZGQoZSkge1xuICAgIGlmICh0aGlzLnBlck5vZGUpXG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNhbid0IGFkZCBwZXItbm9kZSBwcm9wcyB0byBub2RlIHR5cGVzXCIpO1xuICAgIHJldHVybiB0eXBlb2YgZSAhPSBcImZ1bmN0aW9uXCIgJiYgKGUgPSBPbi5tYXRjaChlKSksIChuKSA9PiB7XG4gICAgICBsZXQgciA9IGUobik7XG4gICAgICByZXR1cm4gciA9PT0gdm9pZCAwID8gbnVsbCA6IFt0aGlzLCByXTtcbiAgICB9O1xuICB9XG59XG5SZS5jbG9zZWRCeSA9IG5ldyBSZSh7IGRlc2VyaWFsaXplOiAodCkgPT4gdC5zcGxpdChcIiBcIikgfSk7XG5SZS5vcGVuZWRCeSA9IG5ldyBSZSh7IGRlc2VyaWFsaXplOiAodCkgPT4gdC5zcGxpdChcIiBcIikgfSk7XG5SZS5ncm91cCA9IG5ldyBSZSh7IGRlc2VyaWFsaXplOiAodCkgPT4gdC5zcGxpdChcIiBcIikgfSk7XG5SZS5pc29sYXRlID0gbmV3IFJlKHsgZGVzZXJpYWxpemU6ICh0KSA9PiB7XG4gIGlmICh0ICYmIHQgIT0gXCJydGxcIiAmJiB0ICE9IFwibHRyXCIgJiYgdCAhPSBcImF1dG9cIilcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIGlzb2xhdGU6IFwiICsgdCk7XG4gIHJldHVybiB0IHx8IFwiYXV0b1wiO1xufSB9KTtcblJlLmNvbnRleHRIYXNoID0gbmV3IFJlKHsgcGVyTm9kZTogITAgfSk7XG5SZS5sb29rQWhlYWQgPSBuZXcgUmUoeyBwZXJOb2RlOiAhMCB9KTtcblJlLm1vdW50ZWQgPSBuZXcgUmUoeyBwZXJOb2RlOiAhMCB9KTtcbmNsYXNzIHZsIHtcbiAgY29uc3RydWN0b3IoZSwgbiwgcikge1xuICAgIHRoaXMudHJlZSA9IGUsIHRoaXMub3ZlcmxheSA9IG4sIHRoaXMucGFyc2VyID0gcjtcbiAgfVxuICAvKipcbiAgQGludGVybmFsXG4gICovXG4gIHN0YXRpYyBnZXQoZSkge1xuICAgIHJldHVybiBlICYmIGUucHJvcHMgJiYgZS5wcm9wc1tSZS5tb3VudGVkLmlkXTtcbiAgfVxufVxuY29uc3QgdkQgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmNsYXNzIE9uIHtcbiAgLyoqXG4gIEBpbnRlcm5hbFxuICAqL1xuICBjb25zdHJ1Y3RvcihlLCBuLCByLCBpID0gMCkge1xuICAgIHRoaXMubmFtZSA9IGUsIHRoaXMucHJvcHMgPSBuLCB0aGlzLmlkID0gciwgdGhpcy5mbGFncyA9IGk7XG4gIH1cbiAgLyoqXG4gIERlZmluZSBhIG5vZGUgdHlwZS5cbiAgKi9cbiAgc3RhdGljIGRlZmluZShlKSB7XG4gICAgbGV0IG4gPSBlLnByb3BzICYmIGUucHJvcHMubGVuZ3RoID8gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCkgOiB2RCwgciA9IChlLnRvcCA/IDEgOiAwKSB8IChlLnNraXBwZWQgPyAyIDogMCkgfCAoZS5lcnJvciA/IDQgOiAwKSB8IChlLm5hbWUgPT0gbnVsbCA/IDggOiAwKSwgaSA9IG5ldyBPbihlLm5hbWUgfHwgXCJcIiwgbiwgZS5pZCwgcik7XG4gICAgaWYgKGUucHJvcHMpIHtcbiAgICAgIGZvciAobGV0IHMgb2YgZS5wcm9wcylcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocykgfHwgKHMgPSBzKGkpKSwgcykge1xuICAgICAgICAgIGlmIChzWzBdLnBlck5vZGUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkNhbid0IHN0b3JlIGEgcGVyLW5vZGUgcHJvcCBvbiBhIG5vZGUgdHlwZVwiKTtcbiAgICAgICAgICBuW3NbMF0uaWRdID0gc1sxXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfVxuICAvKipcbiAgUmV0cmlldmVzIGEgbm9kZSBwcm9wIGZvciB0aGlzIHR5cGUuIFdpbGwgcmV0dXJuIGB1bmRlZmluZWRgIGlmXG4gIHRoZSBwcm9wIGlzbid0IHByZXNlbnQgb24gdGhpcyBub2RlLlxuICAqL1xuICBwcm9wKGUpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9wc1tlLmlkXTtcbiAgfVxuICAvKipcbiAgVHJ1ZSB3aGVuIHRoaXMgaXMgdGhlIHRvcCBub2RlIG9mIGEgZ3JhbW1hci5cbiAgKi9cbiAgZ2V0IGlzVG9wKCkge1xuICAgIHJldHVybiAodGhpcy5mbGFncyAmIDEpID4gMDtcbiAgfVxuICAvKipcbiAgVHJ1ZSB3aGVuIHRoaXMgbm9kZSBpcyBwcm9kdWNlZCBieSBhIHNraXAgcnVsZS5cbiAgKi9cbiAgZ2V0IGlzU2tpcHBlZCgpIHtcbiAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiAyKSA+IDA7XG4gIH1cbiAgLyoqXG4gIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgaXMgYW4gZXJyb3Igbm9kZS5cbiAgKi9cbiAgZ2V0IGlzRXJyb3IoKSB7XG4gICAgcmV0dXJuICh0aGlzLmZsYWdzICYgNCkgPiAwO1xuICB9XG4gIC8qKlxuICBXaGVuIHRydWUsIHRoaXMgbm9kZSB0eXBlIGRvZXNuJ3QgY29ycmVzcG9uZCB0byBhIHVzZXItZGVjbGFyZWRcbiAgbmFtZWQgbm9kZSwgZm9yIGV4YW1wbGUgYmVjYXVzZSBpdCBpcyB1c2VkIHRvIGNhY2hlIHJlcGV0aXRpb24uXG4gICovXG4gIGdldCBpc0Fub255bW91cygpIHtcbiAgICByZXR1cm4gKHRoaXMuZmxhZ3MgJiA4KSA+IDA7XG4gIH1cbiAgLyoqXG4gIFJldHVybnMgdHJ1ZSB3aGVuIHRoaXMgbm9kZSdzIG5hbWUgb3Igb25lIG9mIGl0c1xuICBbZ3JvdXBzXSgjY29tbW9uLk5vZGVQcm9wXmdyb3VwKSBtYXRjaGVzIHRoZSBnaXZlbiBzdHJpbmcuXG4gICovXG4gIGlzKGUpIHtcbiAgICBpZiAodHlwZW9mIGUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKHRoaXMubmFtZSA9PSBlKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgICBsZXQgbiA9IHRoaXMucHJvcChSZS5ncm91cCk7XG4gICAgICByZXR1cm4gbiA/IG4uaW5kZXhPZihlKSA+IC0xIDogITE7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmlkID09IGU7XG4gIH1cbiAgLyoqXG4gIENyZWF0ZSBhIGZ1bmN0aW9uIGZyb20gbm9kZSB0eXBlcyB0byBhcmJpdHJhcnkgdmFsdWVzIGJ5XG4gIHNwZWNpZnlpbmcgYW4gb2JqZWN0IHdob3NlIHByb3BlcnR5IG5hbWVzIGFyZSBub2RlIG9yXG4gIFtncm91cF0oI2NvbW1vbi5Ob2RlUHJvcF5ncm91cCkgbmFtZXMuIE9mdGVuIHVzZWZ1bCB3aXRoXG4gIFtgTm9kZVByb3AuYWRkYF0oI2NvbW1vbi5Ob2RlUHJvcC5hZGQpLiBZb3UgY2FuIHB1dCBtdWx0aXBsZVxuICBuYW1lcywgc2VwYXJhdGVkIGJ5IHNwYWNlcywgaW4gYSBzaW5nbGUgcHJvcGVydHkgbmFtZSB0byBtYXBcbiAgbXVsdGlwbGUgbm9kZSBuYW1lcyB0byBhIHNpbmdsZSB2YWx1ZS5cbiAgKi9cbiAgc3RhdGljIG1hdGNoKGUpIHtcbiAgICBsZXQgbiA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IHIgaW4gZSlcbiAgICAgIGZvciAobGV0IGkgb2Ygci5zcGxpdChcIiBcIikpXG4gICAgICAgIG5baV0gPSBlW3JdO1xuICAgIHJldHVybiAocikgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IHIucHJvcChSZS5ncm91cCksIHMgPSAtMTsgcyA8IChpID8gaS5sZW5ndGggOiAwKTsgcysrKSB7XG4gICAgICAgIGxldCBvID0gbltzIDwgMCA/IHIubmFtZSA6IGlbc11dO1xuICAgICAgICBpZiAobylcbiAgICAgICAgICByZXR1cm4gbztcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5Pbi5ub25lID0gbmV3IE9uKFxuICBcIlwiLFxuICAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgMCxcbiAgOFxuICAvKiBOb2RlRmxhZy5Bbm9ueW1vdXMgKi9cbik7XG5jbGFzcyBmZyB7XG4gIC8qKlxuICBDcmVhdGUgYSBzZXQgd2l0aCB0aGUgZ2l2ZW4gdHlwZXMuIFRoZSBgaWRgIHByb3BlcnR5IG9mIGVhY2hcbiAgdHlwZSBzaG91bGQgY29ycmVzcG9uZCB0byBpdHMgcG9zaXRpb24gd2l0aGluIHRoZSBhcnJheS5cbiAgKi9cbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMudHlwZXMgPSBlO1xuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgZS5sZW5ndGg7IG4rKylcbiAgICAgIGlmIChlW25dLmlkICE9IG4pXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm9kZSB0eXBlIGlkcyBzaG91bGQgY29ycmVzcG9uZCB0byBhcnJheSBwb3NpdGlvbnMgd2hlbiBjcmVhdGluZyBhIG5vZGUgc2V0XCIpO1xuICB9XG4gIC8qKlxuICBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgc2V0IHdpdGggc29tZSBub2RlIHByb3BlcnRpZXMgYWRkZWQuIFRoZVxuICBhcmd1bWVudHMgdG8gdGhpcyBtZXRob2QgY2FuIGJlIGNyZWF0ZWQgd2l0aFxuICBbYE5vZGVQcm9wLmFkZGBdKCNjb21tb24uTm9kZVByb3AuYWRkKS5cbiAgKi9cbiAgZXh0ZW5kKC4uLmUpIHtcbiAgICBsZXQgbiA9IFtdO1xuICAgIGZvciAobGV0IHIgb2YgdGhpcy50eXBlcykge1xuICAgICAgbGV0IGkgPSBudWxsO1xuICAgICAgZm9yIChsZXQgcyBvZiBlKSB7XG4gICAgICAgIGxldCBvID0gcyhyKTtcbiAgICAgICAgbyAmJiAoaSB8fCAoaSA9IE9iamVjdC5hc3NpZ24oe30sIHIucHJvcHMpKSwgaVtvWzBdLmlkXSA9IG9bMV0pO1xuICAgICAgfVxuICAgICAgbi5wdXNoKGkgPyBuZXcgT24oci5uYW1lLCBpLCByLmlkLCByLmZsYWdzKSA6IHIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IGZnKG4pO1xuICB9XG59XG5jb25zdCBOYyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBDdiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xudmFyIGx0O1xuKGZ1bmN0aW9uKHQpIHtcbiAgdFt0LkV4Y2x1ZGVCdWZmZXJzID0gMV0gPSBcIkV4Y2x1ZGVCdWZmZXJzXCIsIHRbdC5JbmNsdWRlQW5vbnltb3VzID0gMl0gPSBcIkluY2x1ZGVBbm9ueW1vdXNcIiwgdFt0Lklnbm9yZU1vdW50cyA9IDRdID0gXCJJZ25vcmVNb3VudHNcIiwgdFt0Lklnbm9yZU92ZXJsYXlzID0gOF0gPSBcIklnbm9yZU92ZXJsYXlzXCI7XG59KShsdCB8fCAobHQgPSB7fSkpO1xuY2xhc3MgZ3Qge1xuICAvKipcbiAgQ29uc3RydWN0IGEgbmV3IHRyZWUuIFNlZSBhbHNvIFtgVHJlZS5idWlsZGBdKCNjb21tb24uVHJlZV5idWlsZCkuXG4gICovXG4gIGNvbnN0cnVjdG9yKGUsIG4sIHIsIGksIHMpIHtcbiAgICBpZiAodGhpcy50eXBlID0gZSwgdGhpcy5jaGlsZHJlbiA9IG4sIHRoaXMucG9zaXRpb25zID0gciwgdGhpcy5sZW5ndGggPSBpLCB0aGlzLnByb3BzID0gbnVsbCwgcyAmJiBzLmxlbmd0aCkge1xuICAgICAgdGhpcy5wcm9wcyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgZm9yIChsZXQgW28sIGFdIG9mIHMpXG4gICAgICAgIHRoaXMucHJvcHNbdHlwZW9mIG8gPT0gXCJudW1iZXJcIiA/IG8gOiBvLmlkXSA9IGE7XG4gICAgfVxuICB9XG4gIC8qKlxuICBAaW50ZXJuYWxcbiAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgbGV0IGUgPSB2bC5nZXQodGhpcyk7XG4gICAgaWYgKGUgJiYgIWUub3ZlcmxheSlcbiAgICAgIHJldHVybiBlLnRyZWUudG9TdHJpbmcoKTtcbiAgICBsZXQgbiA9IFwiXCI7XG4gICAgZm9yIChsZXQgciBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICBsZXQgaSA9IHIudG9TdHJpbmcoKTtcbiAgICAgIGkgJiYgKG4gJiYgKG4gKz0gXCIsXCIpLCBuICs9IGkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy50eXBlLm5hbWUgPyAoL1xcVy8udGVzdCh0aGlzLnR5cGUubmFtZSkgJiYgIXRoaXMudHlwZS5pc0Vycm9yID8gSlNPTi5zdHJpbmdpZnkodGhpcy50eXBlLm5hbWUpIDogdGhpcy50eXBlLm5hbWUpICsgKG4ubGVuZ3RoID8gXCIoXCIgKyBuICsgXCIpXCIgOiBcIlwiKSA6IG47XG4gIH1cbiAgLyoqXG4gIEdldCBhIFt0cmVlIGN1cnNvcl0oI2NvbW1vbi5UcmVlQ3Vyc29yKSBwb3NpdGlvbmVkIGF0IHRoZSB0b3Agb2ZcbiAgdGhlIHRyZWUuIE1vZGUgY2FuIGJlIHVzZWQgdG8gW2NvbnRyb2xdKCNjb21tb24uSXRlck1vZGUpIHdoaWNoXG4gIG5vZGVzIHRoZSBjdXJzb3IgdmlzaXRzLlxuICAqL1xuICBjdXJzb3IoZSA9IDApIHtcbiAgICByZXR1cm4gbmV3IFh1KHRoaXMudG9wTm9kZSwgZSk7XG4gIH1cbiAgLyoqXG4gIEdldCBhIFt0cmVlIGN1cnNvcl0oI2NvbW1vbi5UcmVlQ3Vyc29yKSBwb2ludGluZyBpbnRvIHRoaXMgdHJlZVxuICBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIHNpZGUgKHNlZVxuICBbYG1vdmVUb2BdKCNjb21tb24uVHJlZUN1cnNvci5tb3ZlVG8pLlxuICAqL1xuICBjdXJzb3JBdChlLCBuID0gMCwgciA9IDApIHtcbiAgICBsZXQgaSA9IE5jLmdldCh0aGlzKSB8fCB0aGlzLnRvcE5vZGUsIHMgPSBuZXcgWHUoaSk7XG4gICAgcmV0dXJuIHMubW92ZVRvKGUsIG4pLCBOYy5zZXQodGhpcywgcy5fdHJlZSksIHM7XG4gIH1cbiAgLyoqXG4gIEdldCBhIFtzeW50YXggbm9kZV0oI2NvbW1vbi5TeW50YXhOb2RlKSBvYmplY3QgZm9yIHRoZSB0b3Agb2YgdGhlXG4gIHRyZWUuXG4gICovXG4gIGdldCB0b3BOb2RlKCkge1xuICAgIHJldHVybiBuZXcgbG4odGhpcywgMCwgMCwgbnVsbCk7XG4gIH1cbiAgLyoqXG4gIEdldCB0aGUgW3N5bnRheCBub2RlXSgjY29tbW9uLlN5bnRheE5vZGUpIGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgSWYgYHNpZGVgIGlzIC0xLCB0aGlzIHdpbGwgbW92ZSBpbnRvIG5vZGVzIHRoYXQgZW5kIGF0IHRoZVxuICBwb3NpdGlvbi4gSWYgMSwgaXQnbGwgbW92ZSBpbnRvIG5vZGVzIHRoYXQgc3RhcnQgYXQgdGhlXG4gIHBvc2l0aW9uLiBXaXRoIDAsIGl0J2xsIG9ubHkgZW50ZXIgbm9kZXMgdGhhdCBjb3ZlciB0aGUgcG9zaXRpb25cbiAgZnJvbSBib3RoIHNpZGVzLlxuICBcbiAgTm90ZSB0aGF0IHRoaXMgd2lsbCBub3QgZW50ZXJcbiAgW292ZXJsYXlzXSgjY29tbW9uLk1vdW50ZWRUcmVlLm92ZXJsYXkpLCBhbmQgeW91IG9mdGVuIHdhbnRcbiAgW2ByZXNvbHZlSW5uZXJgXSgjY29tbW9uLlRyZWUucmVzb2x2ZUlubmVyKSBpbnN0ZWFkLlxuICAqL1xuICByZXNvbHZlKGUsIG4gPSAwKSB7XG4gICAgbGV0IHIgPSB5bChOYy5nZXQodGhpcykgfHwgdGhpcy50b3BOb2RlLCBlLCBuLCAhMSk7XG4gICAgcmV0dXJuIE5jLnNldCh0aGlzLCByKSwgcjtcbiAgfVxuICAvKipcbiAgTGlrZSBbYHJlc29sdmVgXSgjY29tbW9uLlRyZWUucmVzb2x2ZSksIGJ1dCB3aWxsIGVudGVyXG4gIFtvdmVybGFpZF0oI2NvbW1vbi5Nb3VudGVkVHJlZS5vdmVybGF5KSBub2RlcywgcHJvZHVjaW5nIGEgc3ludGF4IG5vZGVcbiAgcG9pbnRpbmcgaW50byB0aGUgaW5uZXJtb3N0IG92ZXJsYWlkIHRyZWUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uXG4gICh3aXRoIHBhcmVudCBsaW5rcyBnb2luZyB0aHJvdWdoIGFsbCBwYXJlbnQgc3RydWN0dXJlLCBpbmNsdWRpbmdcbiAgdGhlIGhvc3QgdHJlZXMpLlxuICAqL1xuICByZXNvbHZlSW5uZXIoZSwgbiA9IDApIHtcbiAgICBsZXQgciA9IHlsKEN2LmdldCh0aGlzKSB8fCB0aGlzLnRvcE5vZGUsIGUsIG4sICEwKTtcbiAgICByZXR1cm4gQ3Yuc2V0KHRoaXMsIHIpLCByO1xuICB9XG4gIC8qKlxuICBJbiBzb21lIHNpdHVhdGlvbnMsIGl0IGNhbiBiZSB1c2VmdWwgdG8gaXRlcmF0ZSB0aHJvdWdoIGFsbFxuICBub2RlcyBhcm91bmQgYSBwb3NpdGlvbiwgaW5jbHVkaW5nIHRob3NlIGluIG92ZXJsYXlzIHRoYXQgZG9uJ3RcbiAgZGlyZWN0bHkgY292ZXIgdGhlIHBvc2l0aW9uLiBUaGlzIG1ldGhvZCBnaXZlcyB5b3UgYW4gaXRlcmF0b3JcbiAgdGhhdCB3aWxsIHByb2R1Y2UgYWxsIG5vZGVzLCBmcm9tIHNtYWxsIHRvIGJpZywgYXJvdW5kIHRoZSBnaXZlblxuICBwb3NpdGlvbi5cbiAgKi9cbiAgcmVzb2x2ZVN0YWNrKGUsIG4gPSAwKSB7XG4gICAgcmV0dXJuIHdEKHRoaXMsIGUsIG4pO1xuICB9XG4gIC8qKlxuICBJdGVyYXRlIG92ZXIgdGhlIHRyZWUgYW5kIGl0cyBjaGlsZHJlbiwgY2FsbGluZyBgZW50ZXJgIGZvciBhbnlcbiAgbm9kZSB0aGF0IHRvdWNoZXMgdGhlIGBmcm9tYC9gdG9gIHJlZ2lvbiAoaWYgZ2l2ZW4pIGJlZm9yZVxuICBydW5uaW5nIG92ZXIgc3VjaCBhIG5vZGUncyBjaGlsZHJlbiwgYW5kIGBsZWF2ZWAgKGlmIGdpdmVuKSB3aGVuXG4gIGxlYXZpbmcgdGhlIG5vZGUuIFdoZW4gYGVudGVyYCByZXR1cm5zIGBmYWxzZWAsIHRoYXQgbm9kZSB3aWxsXG4gIG5vdCBoYXZlIGl0cyBjaGlsZHJlbiBpdGVyYXRlZCBvdmVyIChvciBgbGVhdmVgIGNhbGxlZCkuXG4gICovXG4gIGl0ZXJhdGUoZSkge1xuICAgIGxldCB7IGVudGVyOiBuLCBsZWF2ZTogciwgZnJvbTogaSA9IDAsIHRvOiBzID0gdGhpcy5sZW5ndGggfSA9IGUsIG8gPSBlLm1vZGUgfHwgMCwgYSA9IChvICYgbHQuSW5jbHVkZUFub255bW91cykgPiAwO1xuICAgIGZvciAobGV0IGwgPSB0aGlzLmN1cnNvcihvIHwgbHQuSW5jbHVkZUFub255bW91cyk7IDsgKSB7XG4gICAgICBsZXQgYyA9ICExO1xuICAgICAgaWYgKGwuZnJvbSA8PSBzICYmIGwudG8gPj0gaSAmJiAoIWEgJiYgbC50eXBlLmlzQW5vbnltb3VzIHx8IG4obCkgIT09ICExKSkge1xuICAgICAgICBpZiAobC5maXJzdENoaWxkKCkpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGMgPSAhMDtcbiAgICAgIH1cbiAgICAgIGZvciAoOyBjICYmIHIgJiYgKGEgfHwgIWwudHlwZS5pc0Fub255bW91cykgJiYgcihsKSwgIWwubmV4dFNpYmxpbmcoKTsgKSB7XG4gICAgICAgIGlmICghbC5wYXJlbnQoKSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIGMgPSAhMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gIEdldCB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIFtub2RlIHByb3BdKCNjb21tb24uTm9kZVByb3ApIGZvciB0aGlzXG4gIG5vZGUuIFdvcmtzIHdpdGggYm90aCBwZXItbm9kZSBhbmQgcGVyLXR5cGUgcHJvcHMuXG4gICovXG4gIHByb3AoZSkge1xuICAgIHJldHVybiBlLnBlck5vZGUgPyB0aGlzLnByb3BzID8gdGhpcy5wcm9wc1tlLmlkXSA6IHZvaWQgMCA6IHRoaXMudHlwZS5wcm9wKGUpO1xuICB9XG4gIC8qKlxuICBSZXR1cm5zIHRoZSBub2RlJ3MgW3Blci1ub2RlIHByb3BzXSgjY29tbW9uLk5vZGVQcm9wLnBlck5vZGUpIGluIGFcbiAgZm9ybWF0IHRoYXQgY2FuIGJlIHBhc3NlZCB0byB0aGUgW2BUcmVlYF0oI2NvbW1vbi5UcmVlKVxuICBjb25zdHJ1Y3Rvci5cbiAgKi9cbiAgZ2V0IHByb3BWYWx1ZXMoKSB7XG4gICAgbGV0IGUgPSBbXTtcbiAgICBpZiAodGhpcy5wcm9wcylcbiAgICAgIGZvciAobGV0IG4gaW4gdGhpcy5wcm9wcylcbiAgICAgICAgZS5wdXNoKFsrbiwgdGhpcy5wcm9wc1tuXV0pO1xuICAgIHJldHVybiBlO1xuICB9XG4gIC8qKlxuICBCYWxhbmNlIHRoZSBkaXJlY3QgY2hpbGRyZW4gb2YgdGhpcyB0cmVlLCBwcm9kdWNpbmcgYSBjb3B5IG9mXG4gIHdoaWNoIG1heSBoYXZlIGNoaWxkcmVuIGdyb3VwZWQgaW50byBzdWJ0cmVlcyB3aXRoIHR5cGVcbiAgW2BOb2RlVHlwZS5ub25lYF0oI2NvbW1vbi5Ob2RlVHlwZV5ub25lKS5cbiAgKi9cbiAgYmFsYW5jZShlID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5sZW5ndGggPD0gOCA/IHRoaXMgOiBPZyhPbi5ub25lLCB0aGlzLmNoaWxkcmVuLCB0aGlzLnBvc2l0aW9ucywgMCwgdGhpcy5jaGlsZHJlbi5sZW5ndGgsIDAsIHRoaXMubGVuZ3RoLCAobiwgciwgaSkgPT4gbmV3IGd0KHRoaXMudHlwZSwgbiwgciwgaSwgdGhpcy5wcm9wVmFsdWVzKSwgZS5tYWtlVHJlZSB8fCAoKG4sIHIsIGkpID0+IG5ldyBndChPbi5ub25lLCBuLCByLCBpKSkpO1xuICB9XG4gIC8qKlxuICBCdWlsZCBhIHRyZWUgZnJvbSBhIHBvc3RmaXgtb3JkZXJlZCBidWZmZXIgb2Ygbm9kZSBpbmZvcm1hdGlvbixcbiAgb3IgYSBjdXJzb3Igb3ZlciBzdWNoIGEgYnVmZmVyLlxuICAqL1xuICBzdGF0aWMgYnVpbGQoZSkge1xuICAgIHJldHVybiBrRChlKTtcbiAgfVxufVxuZ3QuZW1wdHkgPSBuZXcgZ3QoT24ubm9uZSwgW10sIFtdLCAwKTtcbmNsYXNzIGhnIHtcbiAgY29uc3RydWN0b3IoZSwgbikge1xuICAgIHRoaXMuYnVmZmVyID0gZSwgdGhpcy5pbmRleCA9IG47XG4gIH1cbiAgZ2V0IGlkKCkge1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gNF07XG4gIH1cbiAgZ2V0IHN0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gM107XG4gIH1cbiAgZ2V0IGVuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDJdO1xuICB9XG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMV07XG4gIH1cbiAgZ2V0IHBvcygpIHtcbiAgICByZXR1cm4gdGhpcy5pbmRleDtcbiAgfVxuICBuZXh0KCkge1xuICAgIHRoaXMuaW5kZXggLT0gNDtcbiAgfVxuICBmb3JrKCkge1xuICAgIHJldHVybiBuZXcgaGcodGhpcy5idWZmZXIsIHRoaXMuaW5kZXgpO1xuICB9XG59XG5jbGFzcyBscyB7XG4gIC8qKlxuICBDcmVhdGUgYSB0cmVlIGJ1ZmZlci5cbiAgKi9cbiAgY29uc3RydWN0b3IoZSwgbiwgcikge1xuICAgIHRoaXMuYnVmZmVyID0gZSwgdGhpcy5sZW5ndGggPSBuLCB0aGlzLnNldCA9IHI7XG4gIH1cbiAgLyoqXG4gIEBpbnRlcm5hbFxuICAqL1xuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gT24ubm9uZTtcbiAgfVxuICAvKipcbiAgQGludGVybmFsXG4gICovXG4gIHRvU3RyaW5nKCkge1xuICAgIGxldCBlID0gW107XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCB0aGlzLmJ1ZmZlci5sZW5ndGg7IClcbiAgICAgIGUucHVzaCh0aGlzLmNoaWxkU3RyaW5nKG4pKSwgbiA9IHRoaXMuYnVmZmVyW24gKyAzXTtcbiAgICByZXR1cm4gZS5qb2luKFwiLFwiKTtcbiAgfVxuICAvKipcbiAgQGludGVybmFsXG4gICovXG4gIGNoaWxkU3RyaW5nKGUpIHtcbiAgICBsZXQgbiA9IHRoaXMuYnVmZmVyW2VdLCByID0gdGhpcy5idWZmZXJbZSArIDNdLCBpID0gdGhpcy5zZXQudHlwZXNbbl0sIHMgPSBpLm5hbWU7XG4gICAgaWYgKC9cXFcvLnRlc3QocykgJiYgIWkuaXNFcnJvciAmJiAocyA9IEpTT04uc3RyaW5naWZ5KHMpKSwgZSArPSA0LCByID09IGUpXG4gICAgICByZXR1cm4gcztcbiAgICBsZXQgbyA9IFtdO1xuICAgIGZvciAoOyBlIDwgcjsgKVxuICAgICAgby5wdXNoKHRoaXMuY2hpbGRTdHJpbmcoZSkpLCBlID0gdGhpcy5idWZmZXJbZSArIDNdO1xuICAgIHJldHVybiBzICsgXCIoXCIgKyBvLmpvaW4oXCIsXCIpICsgXCIpXCI7XG4gIH1cbiAgLyoqXG4gIEBpbnRlcm5hbFxuICAqL1xuICBmaW5kQ2hpbGQoZSwgbiwgciwgaSwgcykge1xuICAgIGxldCB7IGJ1ZmZlcjogbyB9ID0gdGhpcywgYSA9IC0xO1xuICAgIGZvciAobGV0IGwgPSBlOyBsICE9IG4gJiYgIShHayhzLCBpLCBvW2wgKyAxXSwgb1tsICsgMl0pICYmIChhID0gbCwgciA+IDApKTsgbCA9IG9bbCArIDNdKVxuICAgICAgO1xuICAgIHJldHVybiBhO1xuICB9XG4gIC8qKlxuICBAaW50ZXJuYWxcbiAgKi9cbiAgc2xpY2UoZSwgbiwgcikge1xuICAgIGxldCBpID0gdGhpcy5idWZmZXIsIHMgPSBuZXcgVWludDE2QXJyYXkobiAtIGUpLCBvID0gMDtcbiAgICBmb3IgKGxldCBhID0gZSwgbCA9IDA7IGEgPCBuOyApIHtcbiAgICAgIHNbbCsrXSA9IGlbYSsrXSwgc1tsKytdID0gaVthKytdIC0gcjtcbiAgICAgIGxldCBjID0gc1tsKytdID0gaVthKytdIC0gcjtcbiAgICAgIHNbbCsrXSA9IGlbYSsrXSAtIGUsIG8gPSBNYXRoLm1heChvLCBjKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBscyhzLCBvLCB0aGlzLnNldCk7XG4gIH1cbn1cbmZ1bmN0aW9uIEdrKHQsIGUsIG4sIHIpIHtcbiAgc3dpdGNoICh0KSB7XG4gICAgY2FzZSAtMjpcbiAgICAgIHJldHVybiBuIDwgZTtcbiAgICBjYXNlIC0xOlxuICAgICAgcmV0dXJuIHIgPj0gZSAmJiBuIDwgZTtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gbiA8IGUgJiYgciA+IGU7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIG4gPD0gZSAmJiByID4gZTtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gciA+IGU7XG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuICEwO1xuICB9XG59XG5mdW5jdGlvbiB5bCh0LCBlLCBuLCByKSB7XG4gIGZvciAodmFyIGk7IHQuZnJvbSA9PSB0LnRvIHx8IChuIDwgMSA/IHQuZnJvbSA+PSBlIDogdC5mcm9tID4gZSkgfHwgKG4gPiAtMSA/IHQudG8gPD0gZSA6IHQudG8gPCBlKTsgKSB7XG4gICAgbGV0IG8gPSAhciAmJiB0IGluc3RhbmNlb2YgbG4gJiYgdC5pbmRleCA8IDAgPyBudWxsIDogdC5wYXJlbnQ7XG4gICAgaWYgKCFvKVxuICAgICAgcmV0dXJuIHQ7XG4gICAgdCA9IG87XG4gIH1cbiAgbGV0IHMgPSByID8gMCA6IGx0Lklnbm9yZU92ZXJsYXlzO1xuICBpZiAocilcbiAgICBmb3IgKGxldCBvID0gdCwgYSA9IG8ucGFyZW50OyBhOyBvID0gYSwgYSA9IG8ucGFyZW50KVxuICAgICAgbyBpbnN0YW5jZW9mIGxuICYmIG8uaW5kZXggPCAwICYmICgoaSA9IGEuZW50ZXIoZSwgbiwgcykpID09PSBudWxsIHx8IGkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGkuZnJvbSkgIT0gby5mcm9tICYmICh0ID0gYSk7XG4gIGZvciAoOyA7ICkge1xuICAgIGxldCBvID0gdC5lbnRlcihlLCBuLCBzKTtcbiAgICBpZiAoIW8pXG4gICAgICByZXR1cm4gdDtcbiAgICB0ID0gbztcbiAgfVxufVxuY2xhc3MgS2sge1xuICBjdXJzb3IoZSA9IDApIHtcbiAgICByZXR1cm4gbmV3IFh1KHRoaXMsIGUpO1xuICB9XG4gIGdldENoaWxkKGUsIG4gPSBudWxsLCByID0gbnVsbCkge1xuICAgIGxldCBpID0gQXYodGhpcywgZSwgbiwgcik7XG4gICAgcmV0dXJuIGkubGVuZ3RoID8gaVswXSA6IG51bGw7XG4gIH1cbiAgZ2V0Q2hpbGRyZW4oZSwgbiA9IG51bGwsIHIgPSBudWxsKSB7XG4gICAgcmV0dXJuIEF2KHRoaXMsIGUsIG4sIHIpO1xuICB9XG4gIHJlc29sdmUoZSwgbiA9IDApIHtcbiAgICByZXR1cm4geWwodGhpcywgZSwgbiwgITEpO1xuICB9XG4gIHJlc29sdmVJbm5lcihlLCBuID0gMCkge1xuICAgIHJldHVybiB5bCh0aGlzLCBlLCBuLCAhMCk7XG4gIH1cbiAgbWF0Y2hDb250ZXh0KGUpIHtcbiAgICByZXR1cm4gU3AodGhpcywgZSk7XG4gIH1cbiAgZW50ZXJVbmZpbmlzaGVkTm9kZXNCZWZvcmUoZSkge1xuICAgIGxldCBuID0gdGhpcy5jaGlsZEJlZm9yZShlKSwgciA9IHRoaXM7XG4gICAgZm9yICg7IG47ICkge1xuICAgICAgbGV0IGkgPSBuLmxhc3RDaGlsZDtcbiAgICAgIGlmICghaSB8fCBpLnRvICE9IG4udG8pXG4gICAgICAgIGJyZWFrO1xuICAgICAgaS50eXBlLmlzRXJyb3IgJiYgaS5mcm9tID09IGkudG8gPyAociA9IG4sIG4gPSBpLnByZXZTaWJsaW5nKSA6IG4gPSBpO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICBnZXQgbm9kZSgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBnZXQgbmV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnQ7XG4gIH1cbn1cbmNsYXNzIGxuIGV4dGVuZHMgS2sge1xuICBjb25zdHJ1Y3RvcihlLCBuLCByLCBpKSB7XG4gICAgc3VwZXIoKSwgdGhpcy5fdHJlZSA9IGUsIHRoaXMuZnJvbSA9IG4sIHRoaXMuaW5kZXggPSByLCB0aGlzLl9wYXJlbnQgPSBpO1xuICB9XG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLl90cmVlLnR5cGU7XG4gIH1cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyZWUudHlwZS5uYW1lO1xuICB9XG4gIGdldCB0bygpIHtcbiAgICByZXR1cm4gdGhpcy5mcm9tICsgdGhpcy5fdHJlZS5sZW5ndGg7XG4gIH1cbiAgbmV4dENoaWxkKGUsIG4sIHIsIGksIHMgPSAwKSB7XG4gICAgZm9yIChsZXQgbyA9IHRoaXM7IDsgKSB7XG4gICAgICBmb3IgKGxldCB7IGNoaWxkcmVuOiBhLCBwb3NpdGlvbnM6IGwgfSA9IG8uX3RyZWUsIGMgPSBuID4gMCA/IGEubGVuZ3RoIDogLTE7IGUgIT0gYzsgZSArPSBuKSB7XG4gICAgICAgIGxldCB1ID0gYVtlXSwgZCA9IGxbZV0gKyBvLmZyb207XG4gICAgICAgIGlmIChHayhpLCByLCBkLCBkICsgdS5sZW5ndGgpKSB7XG4gICAgICAgICAgaWYgKHUgaW5zdGFuY2VvZiBscykge1xuICAgICAgICAgICAgaWYgKHMgJiBsdC5FeGNsdWRlQnVmZmVycylcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgZiA9IHUuZmluZENoaWxkKDAsIHUuYnVmZmVyLmxlbmd0aCwgbiwgciAtIGQsIGkpO1xuICAgICAgICAgICAgaWYgKGYgPiAtMSlcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBOcihuZXcgeUQobywgdSwgZSwgZCksIG51bGwsIGYpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocyAmIGx0LkluY2x1ZGVBbm9ueW1vdXMgfHwgIXUudHlwZS5pc0Fub255bW91cyB8fCBwZyh1KSkge1xuICAgICAgICAgICAgbGV0IGY7XG4gICAgICAgICAgICBpZiAoIShzICYgbHQuSWdub3JlTW91bnRzKSAmJiAoZiA9IHZsLmdldCh1KSkgJiYgIWYub3ZlcmxheSlcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBsbihmLnRyZWUsIGQsIGUsIG8pO1xuICAgICAgICAgICAgbGV0IGggPSBuZXcgbG4odSwgZCwgZSwgbyk7XG4gICAgICAgICAgICByZXR1cm4gcyAmIGx0LkluY2x1ZGVBbm9ueW1vdXMgfHwgIWgudHlwZS5pc0Fub255bW91cyA/IGggOiBoLm5leHRDaGlsZChuIDwgMCA/IHUuY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDAsIG4sIHIsIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHMgJiBsdC5JbmNsdWRlQW5vbnltb3VzIHx8ICFvLnR5cGUuaXNBbm9ueW1vdXMgfHwgKG8uaW5kZXggPj0gMCA/IGUgPSBvLmluZGV4ICsgbiA6IGUgPSBuIDwgMCA/IC0xIDogby5fcGFyZW50Ll90cmVlLmNoaWxkcmVuLmxlbmd0aCwgbyA9IG8uX3BhcmVudCwgIW8pKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgZ2V0IGZpcnN0Q2hpbGQoKSB7XG4gICAgcmV0dXJuIHRoaXMubmV4dENoaWxkKFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICAgNFxuICAgICAgLyogU2lkZS5Eb250Q2FyZSAqL1xuICAgICk7XG4gIH1cbiAgZ2V0IGxhc3RDaGlsZCgpIHtcbiAgICByZXR1cm4gdGhpcy5uZXh0Q2hpbGQoXG4gICAgICB0aGlzLl90cmVlLmNoaWxkcmVuLmxlbmd0aCAtIDEsXG4gICAgICAtMSxcbiAgICAgIDAsXG4gICAgICA0XG4gICAgICAvKiBTaWRlLkRvbnRDYXJlICovXG4gICAgKTtcbiAgfVxuICBjaGlsZEFmdGVyKGUpIHtcbiAgICByZXR1cm4gdGhpcy5uZXh0Q2hpbGQoXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIGUsXG4gICAgICAyXG4gICAgICAvKiBTaWRlLkFmdGVyICovXG4gICAgKTtcbiAgfVxuICBjaGlsZEJlZm9yZShlKSB7XG4gICAgcmV0dXJuIHRoaXMubmV4dENoaWxkKFxuICAgICAgdGhpcy5fdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxLFxuICAgICAgLTEsXG4gICAgICBlLFxuICAgICAgLTJcbiAgICAgIC8qIFNpZGUuQmVmb3JlICovXG4gICAgKTtcbiAgfVxuICBlbnRlcihlLCBuLCByID0gMCkge1xuICAgIGxldCBpO1xuICAgIGlmICghKHIgJiBsdC5JZ25vcmVPdmVybGF5cykgJiYgKGkgPSB2bC5nZXQodGhpcy5fdHJlZSkpICYmIGkub3ZlcmxheSkge1xuICAgICAgbGV0IHMgPSBlIC0gdGhpcy5mcm9tO1xuICAgICAgZm9yIChsZXQgeyBmcm9tOiBvLCB0bzogYSB9IG9mIGkub3ZlcmxheSlcbiAgICAgICAgaWYgKChuID4gMCA/IG8gPD0gcyA6IG8gPCBzKSAmJiAobiA8IDAgPyBhID49IHMgOiBhID4gcykpXG4gICAgICAgICAgcmV0dXJuIG5ldyBsbihpLnRyZWUsIGkub3ZlcmxheVswXS5mcm9tICsgdGhpcy5mcm9tLCAtMSwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm5leHRDaGlsZCgwLCAxLCBlLCBuLCByKTtcbiAgfVxuICBuZXh0U2lnbmlmaWNhbnRQYXJlbnQoKSB7XG4gICAgbGV0IGUgPSB0aGlzO1xuICAgIGZvciAoOyBlLnR5cGUuaXNBbm9ueW1vdXMgJiYgZS5fcGFyZW50OyApXG4gICAgICBlID0gZS5fcGFyZW50O1xuICAgIHJldHVybiBlO1xuICB9XG4gIGdldCBwYXJlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5uZXh0U2lnbmlmaWNhbnRQYXJlbnQoKSA6IG51bGw7XG4gIH1cbiAgZ2V0IG5leHRTaWJsaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXJlbnQgJiYgdGhpcy5pbmRleCA+PSAwID8gdGhpcy5fcGFyZW50Lm5leHRDaGlsZChcbiAgICAgIHRoaXMuaW5kZXggKyAxLFxuICAgICAgMSxcbiAgICAgIDAsXG4gICAgICA0XG4gICAgICAvKiBTaWRlLkRvbnRDYXJlICovXG4gICAgKSA6IG51bGw7XG4gIH1cbiAgZ2V0IHByZXZTaWJsaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXJlbnQgJiYgdGhpcy5pbmRleCA+PSAwID8gdGhpcy5fcGFyZW50Lm5leHRDaGlsZChcbiAgICAgIHRoaXMuaW5kZXggLSAxLFxuICAgICAgLTEsXG4gICAgICAwLFxuICAgICAgNFxuICAgICAgLyogU2lkZS5Eb250Q2FyZSAqL1xuICAgICkgOiBudWxsO1xuICB9XG4gIGdldCB0cmVlKCkge1xuICAgIHJldHVybiB0aGlzLl90cmVlO1xuICB9XG4gIHRvVHJlZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJlZTtcbiAgfVxuICAvKipcbiAgQGludGVybmFsXG4gICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl90cmVlLnRvU3RyaW5nKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIEF2KHQsIGUsIG4sIHIpIHtcbiAgbGV0IGkgPSB0LmN1cnNvcigpLCBzID0gW107XG4gIGlmICghaS5maXJzdENoaWxkKCkpXG4gICAgcmV0dXJuIHM7XG4gIGlmIChuICE9IG51bGwpIHtcbiAgICBmb3IgKGxldCBvID0gITE7ICFvOyApXG4gICAgICBpZiAobyA9IGkudHlwZS5pcyhuKSwgIWkubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgcmV0dXJuIHM7XG4gIH1cbiAgZm9yICg7IDsgKSB7XG4gICAgaWYgKHIgIT0gbnVsbCAmJiBpLnR5cGUuaXMocikpXG4gICAgICByZXR1cm4gcztcbiAgICBpZiAoaS50eXBlLmlzKGUpICYmIHMucHVzaChpLm5vZGUpLCAhaS5uZXh0U2libGluZygpKVxuICAgICAgcmV0dXJuIHIgPT0gbnVsbCA/IHMgOiBbXTtcbiAgfVxufVxuZnVuY3Rpb24gU3AodCwgZSwgbiA9IGUubGVuZ3RoIC0gMSkge1xuICBmb3IgKGxldCByID0gdC5wYXJlbnQ7IG4gPj0gMDsgciA9IHIucGFyZW50KSB7XG4gICAgaWYgKCFyKVxuICAgICAgcmV0dXJuICExO1xuICAgIGlmICghci50eXBlLmlzQW5vbnltb3VzKSB7XG4gICAgICBpZiAoZVtuXSAmJiBlW25dICE9IHIubmFtZSlcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgbi0tO1xuICAgIH1cbiAgfVxuICByZXR1cm4gITA7XG59XG5jbGFzcyB5RCB7XG4gIGNvbnN0cnVjdG9yKGUsIG4sIHIsIGkpIHtcbiAgICB0aGlzLnBhcmVudCA9IGUsIHRoaXMuYnVmZmVyID0gbiwgdGhpcy5pbmRleCA9IHIsIHRoaXMuc3RhcnQgPSBpO1xuICB9XG59XG5jbGFzcyBOciBleHRlbmRzIEtrIHtcbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZS5uYW1lO1xuICB9XG4gIGdldCBmcm9tKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQuc3RhcnQgKyB0aGlzLmNvbnRleHQuYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgMV07XG4gIH1cbiAgZ2V0IHRvKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQuc3RhcnQgKyB0aGlzLmNvbnRleHQuYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgMl07XG4gIH1cbiAgY29uc3RydWN0b3IoZSwgbiwgcikge1xuICAgIHN1cGVyKCksIHRoaXMuY29udGV4dCA9IGUsIHRoaXMuX3BhcmVudCA9IG4sIHRoaXMuaW5kZXggPSByLCB0aGlzLnR5cGUgPSBlLmJ1ZmZlci5zZXQudHlwZXNbZS5idWZmZXIuYnVmZmVyW3JdXTtcbiAgfVxuICBjaGlsZChlLCBuLCByKSB7XG4gICAgbGV0IHsgYnVmZmVyOiBpIH0gPSB0aGlzLmNvbnRleHQsIHMgPSBpLmZpbmRDaGlsZCh0aGlzLmluZGV4ICsgNCwgaS5idWZmZXJbdGhpcy5pbmRleCArIDNdLCBlLCBuIC0gdGhpcy5jb250ZXh0LnN0YXJ0LCByKTtcbiAgICByZXR1cm4gcyA8IDAgPyBudWxsIDogbmV3IE5yKHRoaXMuY29udGV4dCwgdGhpcywgcyk7XG4gIH1cbiAgZ2V0IGZpcnN0Q2hpbGQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGQoXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIDRcbiAgICAgIC8qIFNpZGUuRG9udENhcmUgKi9cbiAgICApO1xuICB9XG4gIGdldCBsYXN0Q2hpbGQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hpbGQoXG4gICAgICAtMSxcbiAgICAgIDAsXG4gICAgICA0XG4gICAgICAvKiBTaWRlLkRvbnRDYXJlICovXG4gICAgKTtcbiAgfVxuICBjaGlsZEFmdGVyKGUpIHtcbiAgICByZXR1cm4gdGhpcy5jaGlsZChcbiAgICAgIDEsXG4gICAgICBlLFxuICAgICAgMlxuICAgICAgLyogU2lkZS5BZnRlciAqL1xuICAgICk7XG4gIH1cbiAgY2hpbGRCZWZvcmUoZSkge1xuICAgIHJldHVybiB0aGlzLmNoaWxkKFxuICAgICAgLTEsXG4gICAgICBlLFxuICAgICAgLTJcbiAgICAgIC8qIFNpZGUuQmVmb3JlICovXG4gICAgKTtcbiAgfVxuICBlbnRlcihlLCBuLCByID0gMCkge1xuICAgIGlmIChyICYgbHQuRXhjbHVkZUJ1ZmZlcnMpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgeyBidWZmZXI6IGkgfSA9IHRoaXMuY29udGV4dCwgcyA9IGkuZmluZENoaWxkKHRoaXMuaW5kZXggKyA0LCBpLmJ1ZmZlclt0aGlzLmluZGV4ICsgM10sIG4gPiAwID8gMSA6IC0xLCBlIC0gdGhpcy5jb250ZXh0LnN0YXJ0LCBuKTtcbiAgICByZXR1cm4gcyA8IDAgPyBudWxsIDogbmV3IE5yKHRoaXMuY29udGV4dCwgdGhpcywgcyk7XG4gIH1cbiAgZ2V0IHBhcmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50IHx8IHRoaXMuY29udGV4dC5wYXJlbnQubmV4dFNpZ25pZmljYW50UGFyZW50KCk7XG4gIH1cbiAgZXh0ZXJuYWxTaWJsaW5nKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50ID8gbnVsbCA6IHRoaXMuY29udGV4dC5wYXJlbnQubmV4dENoaWxkKFxuICAgICAgdGhpcy5jb250ZXh0LmluZGV4ICsgZSxcbiAgICAgIGUsXG4gICAgICAwLFxuICAgICAgNFxuICAgICAgLyogU2lkZS5Eb250Q2FyZSAqL1xuICAgICk7XG4gIH1cbiAgZ2V0IG5leHRTaWJsaW5nKCkge1xuICAgIGxldCB7IGJ1ZmZlcjogZSB9ID0gdGhpcy5jb250ZXh0LCBuID0gZS5idWZmZXJbdGhpcy5pbmRleCArIDNdO1xuICAgIHJldHVybiBuIDwgKHRoaXMuX3BhcmVudCA/IGUuYnVmZmVyW3RoaXMuX3BhcmVudC5pbmRleCArIDNdIDogZS5idWZmZXIubGVuZ3RoKSA/IG5ldyBOcih0aGlzLmNvbnRleHQsIHRoaXMuX3BhcmVudCwgbikgOiB0aGlzLmV4dGVybmFsU2libGluZygxKTtcbiAgfVxuICBnZXQgcHJldlNpYmxpbmcoKSB7XG4gICAgbGV0IHsgYnVmZmVyOiBlIH0gPSB0aGlzLmNvbnRleHQsIG4gPSB0aGlzLl9wYXJlbnQgPyB0aGlzLl9wYXJlbnQuaW5kZXggKyA0IDogMDtcbiAgICByZXR1cm4gdGhpcy5pbmRleCA9PSBuID8gdGhpcy5leHRlcm5hbFNpYmxpbmcoLTEpIDogbmV3IE5yKHRoaXMuY29udGV4dCwgdGhpcy5fcGFyZW50LCBlLmZpbmRDaGlsZChcbiAgICAgIG4sXG4gICAgICB0aGlzLmluZGV4LFxuICAgICAgLTEsXG4gICAgICAwLFxuICAgICAgNFxuICAgICAgLyogU2lkZS5Eb250Q2FyZSAqL1xuICAgICkpO1xuICB9XG4gIGdldCB0cmVlKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHRvVHJlZSgpIHtcbiAgICBsZXQgZSA9IFtdLCBuID0gW10sIHsgYnVmZmVyOiByIH0gPSB0aGlzLmNvbnRleHQsIGkgPSB0aGlzLmluZGV4ICsgNCwgcyA9IHIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXTtcbiAgICBpZiAocyA+IGkpIHtcbiAgICAgIGxldCBvID0gci5idWZmZXJbdGhpcy5pbmRleCArIDFdO1xuICAgICAgZS5wdXNoKHIuc2xpY2UoaSwgcywgbykpLCBuLnB1c2goMCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgZ3QodGhpcy50eXBlLCBlLCBuLCB0aGlzLnRvIC0gdGhpcy5mcm9tKTtcbiAgfVxuICAvKipcbiAgQGludGVybmFsXG4gICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRleHQuYnVmZmVyLmNoaWxkU3RyaW5nKHRoaXMuaW5kZXgpO1xuICB9XG59XG5mdW5jdGlvbiBKayh0KSB7XG4gIGlmICghdC5sZW5ndGgpXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCBlID0gMCwgbiA9IHRbMF07XG4gIGZvciAobGV0IHMgPSAxOyBzIDwgdC5sZW5ndGg7IHMrKykge1xuICAgIGxldCBvID0gdFtzXTtcbiAgICAoby5mcm9tID4gbi5mcm9tIHx8IG8udG8gPCBuLnRvKSAmJiAobiA9IG8sIGUgPSBzKTtcbiAgfVxuICBsZXQgciA9IG4gaW5zdGFuY2VvZiBsbiAmJiBuLmluZGV4IDwgMCA/IG51bGwgOiBuLnBhcmVudCwgaSA9IHQuc2xpY2UoKTtcbiAgcmV0dXJuIHIgPyBpW2VdID0gciA6IGkuc3BsaWNlKGUsIDEpLCBuZXcgU0QoaSwgbik7XG59XG5jbGFzcyBTRCB7XG4gIGNvbnN0cnVjdG9yKGUsIG4pIHtcbiAgICB0aGlzLmhlYWRzID0gZSwgdGhpcy5ub2RlID0gbjtcbiAgfVxuICBnZXQgbmV4dCgpIHtcbiAgICByZXR1cm4gSmsodGhpcy5oZWFkcyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdEKHQsIGUsIG4pIHtcbiAgbGV0IHIgPSB0LnJlc29sdmVJbm5lcihlLCBuKSwgaSA9IG51bGw7XG4gIGZvciAobGV0IHMgPSByIGluc3RhbmNlb2YgbG4gPyByIDogci5jb250ZXh0LnBhcmVudDsgczsgcyA9IHMucGFyZW50KVxuICAgIGlmIChzLmluZGV4IDwgMCkge1xuICAgICAgbGV0IG8gPSBzLnBhcmVudDtcbiAgICAgIChpIHx8IChpID0gW3JdKSkucHVzaChvLnJlc29sdmUoZSwgbikpLCBzID0gbztcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG8gPSB2bC5nZXQocy50cmVlKTtcbiAgICAgIGlmIChvICYmIG8ub3ZlcmxheSAmJiBvLm92ZXJsYXlbMF0uZnJvbSA8PSBlICYmIG8ub3ZlcmxheVtvLm92ZXJsYXkubGVuZ3RoIC0gMV0udG8gPj0gZSkge1xuICAgICAgICBsZXQgYSA9IG5ldyBsbihvLnRyZWUsIG8ub3ZlcmxheVswXS5mcm9tICsgcy5mcm9tLCAtMSwgcyk7XG4gICAgICAgIChpIHx8IChpID0gW3JdKSkucHVzaCh5bChhLCBlLCBuLCAhMSkpO1xuICAgICAgfVxuICAgIH1cbiAgcmV0dXJuIGkgPyBKayhpKSA6IHI7XG59XG5jbGFzcyBYdSB7XG4gIC8qKlxuICBTaG9ydGhhbmQgZm9yIGAudHlwZS5uYW1lYC5cbiAgKi9cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZS5uYW1lO1xuICB9XG4gIC8qKlxuICBAaW50ZXJuYWxcbiAgKi9cbiAgY29uc3RydWN0b3IoZSwgbiA9IDApIHtcbiAgICBpZiAodGhpcy5tb2RlID0gbiwgdGhpcy5idWZmZXIgPSBudWxsLCB0aGlzLnN0YWNrID0gW10sIHRoaXMuaW5kZXggPSAwLCB0aGlzLmJ1ZmZlck5vZGUgPSBudWxsLCBlIGluc3RhbmNlb2YgbG4pXG4gICAgICB0aGlzLnlpZWxkTm9kZShlKTtcbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuX3RyZWUgPSBlLmNvbnRleHQucGFyZW50LCB0aGlzLmJ1ZmZlciA9IGUuY29udGV4dDtcbiAgICAgIGZvciAobGV0IHIgPSBlLl9wYXJlbnQ7IHI7IHIgPSByLl9wYXJlbnQpXG4gICAgICAgIHRoaXMuc3RhY2sudW5zaGlmdChyLmluZGV4KTtcbiAgICAgIHRoaXMuYnVmZmVyTm9kZSA9IGUsIHRoaXMueWllbGRCdWYoZS5pbmRleCk7XG4gICAgfVxuICB9XG4gIHlpZWxkTm9kZShlKSB7XG4gICAgcmV0dXJuIGUgPyAodGhpcy5fdHJlZSA9IGUsIHRoaXMudHlwZSA9IGUudHlwZSwgdGhpcy5mcm9tID0gZS5mcm9tLCB0aGlzLnRvID0gZS50bywgITApIDogITE7XG4gIH1cbiAgeWllbGRCdWYoZSwgbikge1xuICAgIHRoaXMuaW5kZXggPSBlO1xuICAgIGxldCB7IHN0YXJ0OiByLCBidWZmZXI6IGkgfSA9IHRoaXMuYnVmZmVyO1xuICAgIHJldHVybiB0aGlzLnR5cGUgPSBuIHx8IGkuc2V0LnR5cGVzW2kuYnVmZmVyW2VdXSwgdGhpcy5mcm9tID0gciArIGkuYnVmZmVyW2UgKyAxXSwgdGhpcy50byA9IHIgKyBpLmJ1ZmZlcltlICsgMl0sICEwO1xuICB9XG4gIC8qKlxuICBAaW50ZXJuYWxcbiAgKi9cbiAgeWllbGQoZSkge1xuICAgIHJldHVybiBlID8gZSBpbnN0YW5jZW9mIGxuID8gKHRoaXMuYnVmZmVyID0gbnVsbCwgdGhpcy55aWVsZE5vZGUoZSkpIDogKHRoaXMuYnVmZmVyID0gZS5jb250ZXh0LCB0aGlzLnlpZWxkQnVmKGUuaW5kZXgsIGUudHlwZSkpIDogITE7XG4gIH1cbiAgLyoqXG4gIEBpbnRlcm5hbFxuICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5idWZmZXIgPyB0aGlzLmJ1ZmZlci5idWZmZXIuY2hpbGRTdHJpbmcodGhpcy5pbmRleCkgOiB0aGlzLl90cmVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgLyoqXG4gIEBpbnRlcm5hbFxuICAqL1xuICBlbnRlckNoaWxkKGUsIG4sIHIpIHtcbiAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgcmV0dXJuIHRoaXMueWllbGQodGhpcy5fdHJlZS5uZXh0Q2hpbGQoZSA8IDAgPyB0aGlzLl90cmVlLl90cmVlLmNoaWxkcmVuLmxlbmd0aCAtIDEgOiAwLCBlLCBuLCByLCB0aGlzLm1vZGUpKTtcbiAgICBsZXQgeyBidWZmZXI6IGkgfSA9IHRoaXMuYnVmZmVyLCBzID0gaS5maW5kQ2hpbGQodGhpcy5pbmRleCArIDQsIGkuYnVmZmVyW3RoaXMuaW5kZXggKyAzXSwgZSwgbiAtIHRoaXMuYnVmZmVyLnN0YXJ0LCByKTtcbiAgICByZXR1cm4gcyA8IDAgPyAhMSA6ICh0aGlzLnN0YWNrLnB1c2godGhpcy5pbmRleCksIHRoaXMueWllbGRCdWYocykpO1xuICB9XG4gIC8qKlxuICBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhpcyBub2RlJ3MgZmlyc3QgY2hpbGQuIFdoZW4gdGhpcyByZXR1cm5zXG4gIGZhbHNlLCB0aGUgbm9kZSBoYXMgbm8gY2hpbGQsIGFuZCB0aGUgY3Vyc29yIGhhcyBub3QgYmVlbiBtb3ZlZC5cbiAgKi9cbiAgZmlyc3RDaGlsZCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbnRlckNoaWxkKFxuICAgICAgMSxcbiAgICAgIDAsXG4gICAgICA0XG4gICAgICAvKiBTaWRlLkRvbnRDYXJlICovXG4gICAgKTtcbiAgfVxuICAvKipcbiAgTW92ZSB0aGUgY3Vyc29yIHRvIHRoaXMgbm9kZSdzIGxhc3QgY2hpbGQuXG4gICovXG4gIGxhc3RDaGlsZCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbnRlckNoaWxkKFxuICAgICAgLTEsXG4gICAgICAwLFxuICAgICAgNFxuICAgICAgLyogU2lkZS5Eb250Q2FyZSAqL1xuICAgICk7XG4gIH1cbiAgLyoqXG4gIE1vdmUgdGhlIGN1cnNvciB0byB0aGUgZmlyc3QgY2hpbGQgdGhhdCBlbmRzIGFmdGVyIGBwb3NgLlxuICAqL1xuICBjaGlsZEFmdGVyKGUpIHtcbiAgICByZXR1cm4gdGhpcy5lbnRlckNoaWxkKFxuICAgICAgMSxcbiAgICAgIGUsXG4gICAgICAyXG4gICAgICAvKiBTaWRlLkFmdGVyICovXG4gICAgKTtcbiAgfVxuICAvKipcbiAgTW92ZSB0byB0aGUgbGFzdCBjaGlsZCB0aGF0IHN0YXJ0cyBiZWZvcmUgYHBvc2AuXG4gICovXG4gIGNoaWxkQmVmb3JlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5lbnRlckNoaWxkKFxuICAgICAgLTEsXG4gICAgICBlLFxuICAgICAgLTJcbiAgICAgIC8qIFNpZGUuQmVmb3JlICovXG4gICAgKTtcbiAgfVxuICAvKipcbiAgTW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBjaGlsZCBhcm91bmQgYHBvc2AuIElmIHNpZGUgaXMgLTEgdGhlXG4gIGNoaWxkIG1heSBlbmQgYXQgdGhhdCBwb3NpdGlvbiwgd2hlbiAxIGl0IG1heSBzdGFydCB0aGVyZS4gVGhpc1xuICB3aWxsIGFsc28gZW50ZXIgW292ZXJsYWlkXSgjY29tbW9uLk1vdW50ZWRUcmVlLm92ZXJsYXkpXG4gIFttb3VudGVkXSgjY29tbW9uLk5vZGVQcm9wXm1vdW50ZWQpIHRyZWVzIHVubGVzcyBgb3ZlcmxheXNgIGlzXG4gIHNldCB0byBmYWxzZS5cbiAgKi9cbiAgZW50ZXIoZSwgbiwgciA9IHRoaXMubW9kZSkge1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlciA/IHIgJiBsdC5FeGNsdWRlQnVmZmVycyA/ICExIDogdGhpcy5lbnRlckNoaWxkKDEsIGUsIG4pIDogdGhpcy55aWVsZCh0aGlzLl90cmVlLmVudGVyKGUsIG4sIHIpKTtcbiAgfVxuICAvKipcbiAgTW92ZSB0byB0aGUgbm9kZSdzIHBhcmVudCBub2RlLCBpZiB0aGlzIGlzbid0IHRoZSB0b3Agbm9kZS5cbiAgKi9cbiAgcGFyZW50KCkge1xuICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICByZXR1cm4gdGhpcy55aWVsZE5vZGUodGhpcy5tb2RlICYgbHQuSW5jbHVkZUFub255bW91cyA/IHRoaXMuX3RyZWUuX3BhcmVudCA6IHRoaXMuX3RyZWUucGFyZW50KTtcbiAgICBpZiAodGhpcy5zdGFjay5sZW5ndGgpXG4gICAgICByZXR1cm4gdGhpcy55aWVsZEJ1Zih0aGlzLnN0YWNrLnBvcCgpKTtcbiAgICBsZXQgZSA9IHRoaXMubW9kZSAmIGx0LkluY2x1ZGVBbm9ueW1vdXMgPyB0aGlzLmJ1ZmZlci5wYXJlbnQgOiB0aGlzLmJ1ZmZlci5wYXJlbnQubmV4dFNpZ25pZmljYW50UGFyZW50KCk7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyID0gbnVsbCwgdGhpcy55aWVsZE5vZGUoZSk7XG4gIH1cbiAgLyoqXG4gIEBpbnRlcm5hbFxuICAqL1xuICBzaWJsaW5nKGUpIHtcbiAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgcmV0dXJuIHRoaXMuX3RyZWUuX3BhcmVudCA/IHRoaXMueWllbGQodGhpcy5fdHJlZS5pbmRleCA8IDAgPyBudWxsIDogdGhpcy5fdHJlZS5fcGFyZW50Lm5leHRDaGlsZCh0aGlzLl90cmVlLmluZGV4ICsgZSwgZSwgMCwgNCwgdGhpcy5tb2RlKSkgOiAhMTtcbiAgICBsZXQgeyBidWZmZXI6IG4gfSA9IHRoaXMuYnVmZmVyLCByID0gdGhpcy5zdGFjay5sZW5ndGggLSAxO1xuICAgIGlmIChlIDwgMCkge1xuICAgICAgbGV0IGkgPSByIDwgMCA/IDAgOiB0aGlzLnN0YWNrW3JdICsgNDtcbiAgICAgIGlmICh0aGlzLmluZGV4ICE9IGkpXG4gICAgICAgIHJldHVybiB0aGlzLnlpZWxkQnVmKG4uZmluZENoaWxkKFxuICAgICAgICAgIGksXG4gICAgICAgICAgdGhpcy5pbmRleCxcbiAgICAgICAgICAtMSxcbiAgICAgICAgICAwLFxuICAgICAgICAgIDRcbiAgICAgICAgICAvKiBTaWRlLkRvbnRDYXJlICovXG4gICAgICAgICkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgaSA9IG4uYnVmZmVyW3RoaXMuaW5kZXggKyAzXTtcbiAgICAgIGlmIChpIDwgKHIgPCAwID8gbi5idWZmZXIubGVuZ3RoIDogbi5idWZmZXJbdGhpcy5zdGFja1tyXSArIDNdKSlcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYoaSk7XG4gICAgfVxuICAgIHJldHVybiByIDwgMCA/IHRoaXMueWllbGQodGhpcy5idWZmZXIucGFyZW50Lm5leHRDaGlsZCh0aGlzLmJ1ZmZlci5pbmRleCArIGUsIGUsIDAsIDQsIHRoaXMubW9kZSkpIDogITE7XG4gIH1cbiAgLyoqXG4gIE1vdmUgdG8gdGhpcyBub2RlJ3MgbmV4dCBzaWJsaW5nLCBpZiBhbnkuXG4gICovXG4gIG5leHRTaWJsaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnNpYmxpbmcoMSk7XG4gIH1cbiAgLyoqXG4gIE1vdmUgdG8gdGhpcyBub2RlJ3MgcHJldmlvdXMgc2libGluZywgaWYgYW55LlxuICAqL1xuICBwcmV2U2libGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5zaWJsaW5nKC0xKTtcbiAgfVxuICBhdExhc3ROb2RlKGUpIHtcbiAgICBsZXQgbiwgciwgeyBidWZmZXI6IGkgfSA9IHRoaXM7XG4gICAgaWYgKGkpIHtcbiAgICAgIGlmIChlID4gMCkge1xuICAgICAgICBpZiAodGhpcy5pbmRleCA8IGkuYnVmZmVyLmJ1ZmZlci5sZW5ndGgpXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgdGhpcy5pbmRleDsgcysrKVxuICAgICAgICAgIGlmIChpLmJ1ZmZlci5idWZmZXJbcyArIDNdIDwgdGhpcy5pbmRleClcbiAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICh7IGluZGV4OiBuLCBwYXJlbnQ6IHIgfSA9IGkpO1xuICAgIH0gZWxzZVxuICAgICAgKHsgaW5kZXg6IG4sIF9wYXJlbnQ6IHIgfSA9IHRoaXMuX3RyZWUpO1xuICAgIGZvciAoOyByOyB7IGluZGV4OiBuLCBfcGFyZW50OiByIH0gPSByKVxuICAgICAgaWYgKG4gPiAtMSlcbiAgICAgICAgZm9yIChsZXQgcyA9IG4gKyBlLCBvID0gZSA8IDAgPyAtMSA6IHIuX3RyZWUuY2hpbGRyZW4ubGVuZ3RoOyBzICE9IG87IHMgKz0gZSkge1xuICAgICAgICAgIGxldCBhID0gci5fdHJlZS5jaGlsZHJlbltzXTtcbiAgICAgICAgICBpZiAodGhpcy5tb2RlICYgbHQuSW5jbHVkZUFub255bW91cyB8fCBhIGluc3RhbmNlb2YgbHMgfHwgIWEudHlwZS5pc0Fub255bW91cyB8fCBwZyhhKSlcbiAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfVxuICAgIHJldHVybiAhMDtcbiAgfVxuICBtb3ZlKGUsIG4pIHtcbiAgICBpZiAobiAmJiB0aGlzLmVudGVyQ2hpbGQoXG4gICAgICBlLFxuICAgICAgMCxcbiAgICAgIDRcbiAgICAgIC8qIFNpZGUuRG9udENhcmUgKi9cbiAgICApKVxuICAgICAgcmV0dXJuICEwO1xuICAgIGZvciAoOyA7ICkge1xuICAgICAgaWYgKHRoaXMuc2libGluZyhlKSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgaWYgKHRoaXMuYXRMYXN0Tm9kZShlKSB8fCAhdGhpcy5wYXJlbnQoKSlcbiAgICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgfVxuICAvKipcbiAgTW92ZSB0byB0aGUgbmV4dCBub2RlIGluIGFcbiAgW3ByZS1vcmRlcl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHJlZV90cmF2ZXJzYWwjUHJlLW9yZGVyLF9OTFIpXG4gIHRyYXZlcnNhbCwgZ29pbmcgZnJvbSBhIG5vZGUgdG8gaXRzIGZpcnN0IGNoaWxkIG9yLCBpZiB0aGVcbiAgY3VycmVudCBub2RlIGlzIGVtcHR5IG9yIGBlbnRlcmAgaXMgZmFsc2UsIGl0cyBuZXh0IHNpYmxpbmcgb3JcbiAgdGhlIG5leHQgc2libGluZyBvZiB0aGUgZmlyc3QgcGFyZW50IG5vZGUgdGhhdCBoYXMgb25lLlxuICAqL1xuICBuZXh0KGUgPSAhMCkge1xuICAgIHJldHVybiB0aGlzLm1vdmUoMSwgZSk7XG4gIH1cbiAgLyoqXG4gIE1vdmUgdG8gdGhlIG5leHQgbm9kZSBpbiBhIGxhc3QtdG8tZmlyc3QgcHJlLW9yZGVyIHRyYXZlcmFsLiBBXG4gIG5vZGUgaXMgZm9sbG93ZWQgYnkgaXRzIGxhc3QgY2hpbGQgb3IsIGlmIGl0IGhhcyBub25lLCBpdHNcbiAgcHJldmlvdXMgc2libGluZyBvciB0aGUgcHJldmlvdXMgc2libGluZyBvZiB0aGUgZmlyc3QgcGFyZW50XG4gIG5vZGUgdGhhdCBoYXMgb25lLlxuICAqL1xuICBwcmV2KGUgPSAhMCkge1xuICAgIHJldHVybiB0aGlzLm1vdmUoLTEsIGUpO1xuICB9XG4gIC8qKlxuICBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhlIGlubmVybW9zdCBub2RlIHRoYXQgY292ZXJzIGBwb3NgLiBJZlxuICBgc2lkZWAgaXMgLTEsIGl0IHdpbGwgZW50ZXIgbm9kZXMgdGhhdCBlbmQgYXQgYHBvc2AuIElmIGl0IGlzIDEsXG4gIGl0IHdpbGwgZW50ZXIgbm9kZXMgdGhhdCBzdGFydCBhdCBgcG9zYC5cbiAgKi9cbiAgbW92ZVRvKGUsIG4gPSAwKSB7XG4gICAgZm9yICg7ICh0aGlzLmZyb20gPT0gdGhpcy50byB8fCAobiA8IDEgPyB0aGlzLmZyb20gPj0gZSA6IHRoaXMuZnJvbSA+IGUpIHx8IChuID4gLTEgPyB0aGlzLnRvIDw9IGUgOiB0aGlzLnRvIDwgZSkpICYmIHRoaXMucGFyZW50KCk7IClcbiAgICAgIDtcbiAgICBmb3IgKDsgdGhpcy5lbnRlckNoaWxkKDEsIGUsIG4pOyApXG4gICAgICA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gIEdldCBhIFtzeW50YXggbm9kZV0oI2NvbW1vbi5TeW50YXhOb2RlKSBhdCB0aGUgY3Vyc29yJ3MgY3VycmVudFxuICBwb3NpdGlvbi5cbiAgKi9cbiAgZ2V0IG5vZGUoKSB7XG4gICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgIHJldHVybiB0aGlzLl90cmVlO1xuICAgIGxldCBlID0gdGhpcy5idWZmZXJOb2RlLCBuID0gbnVsbCwgciA9IDA7XG4gICAgaWYgKGUgJiYgZS5jb250ZXh0ID09IHRoaXMuYnVmZmVyKVxuICAgICAgZTpcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaW5kZXgsIHMgPSB0aGlzLnN0YWNrLmxlbmd0aDsgcyA+PSAwOyApIHtcbiAgICAgICAgICBmb3IgKGxldCBvID0gZTsgbzsgbyA9IG8uX3BhcmVudClcbiAgICAgICAgICAgIGlmIChvLmluZGV4ID09IGkpIHtcbiAgICAgICAgICAgICAgaWYgKGkgPT0gdGhpcy5pbmRleClcbiAgICAgICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgICAgICAgbiA9IG8sIHIgPSBzICsgMTtcbiAgICAgICAgICAgICAgYnJlYWsgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBpID0gdGhpcy5zdGFja1stLXNdO1xuICAgICAgICB9XG4gICAgZm9yIChsZXQgaSA9IHI7IGkgPCB0aGlzLnN0YWNrLmxlbmd0aDsgaSsrKVxuICAgICAgbiA9IG5ldyBOcih0aGlzLmJ1ZmZlciwgbiwgdGhpcy5zdGFja1tpXSk7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyTm9kZSA9IG5ldyBOcih0aGlzLmJ1ZmZlciwgbiwgdGhpcy5pbmRleCk7XG4gIH1cbiAgLyoqXG4gIEdldCB0aGUgW3RyZWVdKCNjb21tb24uVHJlZSkgdGhhdCByZXByZXNlbnRzIHRoZSBjdXJyZW50IG5vZGUsIGlmXG4gIGFueS4gV2lsbCByZXR1cm4gbnVsbCB3aGVuIHRoZSBub2RlIGlzIGluIGEgW3RyZWVcbiAgYnVmZmVyXSgjY29tbW9uLlRyZWVCdWZmZXIpLlxuICAqL1xuICBnZXQgdHJlZSgpIHtcbiAgICByZXR1cm4gdGhpcy5idWZmZXIgPyBudWxsIDogdGhpcy5fdHJlZS5fdHJlZTtcbiAgfVxuICAvKipcbiAgSXRlcmF0ZSBvdmVyIHRoZSBjdXJyZW50IG5vZGUgYW5kIGFsbCBpdHMgZGVzY2VuZGFudHMsIGNhbGxpbmdcbiAgYGVudGVyYCB3aGVuIGVudGVyaW5nIGEgbm9kZSBhbmQgYGxlYXZlYCwgaWYgZ2l2ZW4sIHdoZW4gbGVhdmluZ1xuICBvbmUuIFdoZW4gYGVudGVyYCByZXR1cm5zIGBmYWxzZWAsIGFueSBjaGlsZHJlbiBvZiB0aGF0IG5vZGUgYXJlXG4gIHNraXBwZWQsIGFuZCBgbGVhdmVgIGlzbid0IGNhbGxlZCBmb3IgaXQuXG4gICovXG4gIGl0ZXJhdGUoZSwgbikge1xuICAgIGZvciAobGV0IHIgPSAwOyA7ICkge1xuICAgICAgbGV0IGkgPSAhMTtcbiAgICAgIGlmICh0aGlzLnR5cGUuaXNBbm9ueW1vdXMgfHwgZSh0aGlzKSAhPT0gITEpIHtcbiAgICAgICAgaWYgKHRoaXMuZmlyc3RDaGlsZCgpKSB7XG4gICAgICAgICAgcisrO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHlwZS5pc0Fub255bW91cyB8fCAoaSA9ICEwKTtcbiAgICAgIH1cbiAgICAgIGZvciAoOyBpICYmIG4gJiYgbih0aGlzKSwgaSA9IHRoaXMudHlwZS5pc0Fub255bW91cywgIXRoaXMubmV4dFNpYmxpbmcoKTsgKSB7XG4gICAgICAgIGlmICghcilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMucGFyZW50KCksIHItLSwgaSA9ICEwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgVGVzdCB3aGV0aGVyIHRoZSBjdXJyZW50IG5vZGUgbWF0Y2hlcyBhIGdpdmVuIGNvbnRleHTigJRhIHNlcXVlbmNlXG4gIG9mIGRpcmVjdCBwYXJlbnQgbm9kZSBuYW1lcy4gRW1wdHkgc3RyaW5ncyBpbiB0aGUgY29udGV4dCBhcnJheVxuICBhcmUgdHJlYXRlZCBhcyB3aWxkY2FyZHMuXG4gICovXG4gIG1hdGNoQ29udGV4dChlKSB7XG4gICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgIHJldHVybiBTcCh0aGlzLm5vZGUsIGUpO1xuICAgIGxldCB7IGJ1ZmZlcjogbiB9ID0gdGhpcy5idWZmZXIsIHsgdHlwZXM6IHIgfSA9IG4uc2V0O1xuICAgIGZvciAobGV0IGkgPSBlLmxlbmd0aCAtIDEsIHMgPSB0aGlzLnN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgcy0tKSB7XG4gICAgICBpZiAocyA8IDApXG4gICAgICAgIHJldHVybiBTcCh0aGlzLm5vZGUsIGUsIGkpO1xuICAgICAgbGV0IG8gPSByW24uYnVmZmVyW3RoaXMuc3RhY2tbc11dXTtcbiAgICAgIGlmICghby5pc0Fub255bW91cykge1xuICAgICAgICBpZiAoZVtpXSAmJiBlW2ldICE9IG8ubmFtZSlcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICEwO1xuICB9XG59XG5mdW5jdGlvbiBwZyh0KSB7XG4gIHJldHVybiB0LmNoaWxkcmVuLnNvbWUoKGUpID0+IGUgaW5zdGFuY2VvZiBscyB8fCAhZS50eXBlLmlzQW5vbnltb3VzIHx8IHBnKGUpKTtcbn1cbmZ1bmN0aW9uIGtEKHQpIHtcbiAgdmFyIGU7XG4gIGxldCB7IGJ1ZmZlcjogbiwgbm9kZVNldDogciwgbWF4QnVmZmVyTGVuZ3RoOiBpID0gRmssIHJldXNlZDogcyA9IFtdLCBtaW5SZXBlYXRUeXBlOiBvID0gci50eXBlcy5sZW5ndGggfSA9IHQsIGEgPSBBcnJheS5pc0FycmF5KG4pID8gbmV3IGhnKG4sIG4ubGVuZ3RoKSA6IG4sIGwgPSByLnR5cGVzLCBjID0gMCwgdSA9IDA7XG4gIGZ1bmN0aW9uIGQoUywgdywgaywgXywgVCwgQykge1xuICAgIGxldCB7IGlkOiBBLCBzdGFydDogUSwgZW5kOiBXLCBzaXplOiBMIH0gPSBhLCByZSA9IHU7XG4gICAgZm9yICg7IEwgPCAwOyApXG4gICAgICBpZiAoYS5uZXh0KCksIEwgPT0gLTEpIHtcbiAgICAgICAgbGV0IENlID0gc1tBXTtcbiAgICAgICAgay5wdXNoKENlKSwgXy5wdXNoKFEgLSBTKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChMID09IC0zKSB7XG4gICAgICAgIGMgPSBBO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKEwgPT0gLTQpIHtcbiAgICAgICAgdSA9IEE7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVW5yZWNvZ25pemVkIHJlY29yZCBzaXplOiAke0x9YCk7XG4gICAgbGV0IFkgPSBsW0FdLCBLLCBCLCBfZSA9IFEgLSBTO1xuICAgIGlmIChXIC0gUSA8PSBpICYmIChCID0gbShhLnBvcyAtIHcsIFQpKSkge1xuICAgICAgbGV0IENlID0gbmV3IFVpbnQxNkFycmF5KEIuc2l6ZSAtIEIuc2tpcCksIHVlID0gYS5wb3MgLSBCLnNpemUsIGdlID0gQ2UubGVuZ3RoO1xuICAgICAgZm9yICg7IGEucG9zID4gdWU7IClcbiAgICAgICAgZ2UgPSB5KEIuc3RhcnQsIENlLCBnZSk7XG4gICAgICBLID0gbmV3IGxzKENlLCBXIC0gQi5zdGFydCwgciksIF9lID0gQi5zdGFydCAtIFM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBDZSA9IGEucG9zIC0gTDtcbiAgICAgIGEubmV4dCgpO1xuICAgICAgbGV0IHVlID0gW10sIGdlID0gW10sIEJlID0gQSA+PSBvID8gQSA6IC0xLCBMZSA9IDAsIFp0ID0gVztcbiAgICAgIGZvciAoOyBhLnBvcyA+IENlOyApXG4gICAgICAgIEJlID49IDAgJiYgYS5pZCA9PSBCZSAmJiBhLnNpemUgPj0gMCA/IChhLmVuZCA8PSBadCAtIGkgJiYgKHAodWUsIGdlLCBRLCBMZSwgYS5lbmQsIFp0LCBCZSwgcmUpLCBMZSA9IHVlLmxlbmd0aCwgWnQgPSBhLmVuZCksIGEubmV4dCgpKSA6IEMgPiAyNTAwID8gZihRLCBDZSwgdWUsIGdlKSA6IGQoUSwgQ2UsIHVlLCBnZSwgQmUsIEMgKyAxKTtcbiAgICAgIGlmIChCZSA+PSAwICYmIExlID4gMCAmJiBMZSA8IHVlLmxlbmd0aCAmJiBwKHVlLCBnZSwgUSwgTGUsIFEsIFp0LCBCZSwgcmUpLCB1ZS5yZXZlcnNlKCksIGdlLnJldmVyc2UoKSwgQmUgPiAtMSAmJiBMZSA+IDApIHtcbiAgICAgICAgbGV0IFZ0ID0gaChZKTtcbiAgICAgICAgSyA9IE9nKFksIHVlLCBnZSwgMCwgdWUubGVuZ3RoLCAwLCBXIC0gUSwgVnQsIFZ0KTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBLID0gTyhZLCB1ZSwgZ2UsIFcgLSBRLCByZSAtIFcpO1xuICAgIH1cbiAgICBrLnB1c2goSyksIF8ucHVzaChfZSk7XG4gIH1cbiAgZnVuY3Rpb24gZihTLCB3LCBrLCBfKSB7XG4gICAgbGV0IFQgPSBbXSwgQyA9IDAsIEEgPSAtMTtcbiAgICBmb3IgKDsgYS5wb3MgPiB3OyApIHtcbiAgICAgIGxldCB7IGlkOiBRLCBzdGFydDogVywgZW5kOiBMLCBzaXplOiByZSB9ID0gYTtcbiAgICAgIGlmIChyZSA+IDQpXG4gICAgICAgIGEubmV4dCgpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGlmIChBID4gLTEgJiYgVyA8IEEpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIEEgPCAwICYmIChBID0gTCAtIGkpLCBULnB1c2goUSwgVywgTCksIEMrKywgYS5uZXh0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChDKSB7XG4gICAgICBsZXQgUSA9IG5ldyBVaW50MTZBcnJheShDICogNCksIFcgPSBUW1QubGVuZ3RoIC0gMl07XG4gICAgICBmb3IgKGxldCBMID0gVC5sZW5ndGggLSAzLCByZSA9IDA7IEwgPj0gMDsgTCAtPSAzKVxuICAgICAgICBRW3JlKytdID0gVFtMXSwgUVtyZSsrXSA9IFRbTCArIDFdIC0gVywgUVtyZSsrXSA9IFRbTCArIDJdIC0gVywgUVtyZSsrXSA9IHJlO1xuICAgICAgay5wdXNoKG5ldyBscyhRLCBUWzJdIC0gVywgcikpLCBfLnB1c2goVyAtIFMpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBoKFMpIHtcbiAgICByZXR1cm4gKHcsIGssIF8pID0+IHtcbiAgICAgIGxldCBUID0gMCwgQyA9IHcubGVuZ3RoIC0gMSwgQSwgUTtcbiAgICAgIGlmIChDID49IDAgJiYgKEEgPSB3W0NdKSBpbnN0YW5jZW9mIGd0KSB7XG4gICAgICAgIGlmICghQyAmJiBBLnR5cGUgPT0gUyAmJiBBLmxlbmd0aCA9PSBfKVxuICAgICAgICAgIHJldHVybiBBO1xuICAgICAgICAoUSA9IEEucHJvcChSZS5sb29rQWhlYWQpKSAmJiAoVCA9IGtbQ10gKyBBLmxlbmd0aCArIFEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE8oUywgdywgaywgXywgVCk7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBwKFMsIHcsIGssIF8sIFQsIEMsIEEsIFEpIHtcbiAgICBsZXQgVyA9IFtdLCBMID0gW107XG4gICAgZm9yICg7IFMubGVuZ3RoID4gXzsgKVxuICAgICAgVy5wdXNoKFMucG9wKCkpLCBMLnB1c2gody5wb3AoKSArIGsgLSBUKTtcbiAgICBTLnB1c2goTyhyLnR5cGVzW0FdLCBXLCBMLCBDIC0gVCwgUSAtIEMpKSwgdy5wdXNoKFQgLSBrKTtcbiAgfVxuICBmdW5jdGlvbiBPKFMsIHcsIGssIF8sIFQgPSAwLCBDKSB7XG4gICAgaWYgKGMpIHtcbiAgICAgIGxldCBBID0gW1JlLmNvbnRleHRIYXNoLCBjXTtcbiAgICAgIEMgPSBDID8gW0FdLmNvbmNhdChDKSA6IFtBXTtcbiAgICB9XG4gICAgaWYgKFQgPiAyNSkge1xuICAgICAgbGV0IEEgPSBbUmUubG9va0FoZWFkLCBUXTtcbiAgICAgIEMgPSBDID8gW0FdLmNvbmNhdChDKSA6IFtBXTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBndChTLCB3LCBrLCBfLCBDKTtcbiAgfVxuICBmdW5jdGlvbiBtKFMsIHcpIHtcbiAgICBsZXQgayA9IGEuZm9yaygpLCBfID0gMCwgVCA9IDAsIEMgPSAwLCBBID0gay5lbmQgLSBpLCBRID0geyBzaXplOiAwLCBzdGFydDogMCwgc2tpcDogMCB9O1xuICAgIGU6XG4gICAgICBmb3IgKGxldCBXID0gay5wb3MgLSBTOyBrLnBvcyA+IFc7ICkge1xuICAgICAgICBsZXQgTCA9IGsuc2l6ZTtcbiAgICAgICAgaWYgKGsuaWQgPT0gdyAmJiBMID49IDApIHtcbiAgICAgICAgICBRLnNpemUgPSBfLCBRLnN0YXJ0ID0gVCwgUS5za2lwID0gQywgQyArPSA0LCBfICs9IDQsIGsubmV4dCgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZSA9IGsucG9zIC0gTDtcbiAgICAgICAgaWYgKEwgPCAwIHx8IHJlIDwgVyB8fCBrLnN0YXJ0IDwgQSlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgbGV0IFkgPSBrLmlkID49IG8gPyA0IDogMCwgSyA9IGsuc3RhcnQ7XG4gICAgICAgIGZvciAoay5uZXh0KCk7IGsucG9zID4gcmU7ICkge1xuICAgICAgICAgIGlmIChrLnNpemUgPCAwKVxuICAgICAgICAgICAgaWYgKGsuc2l6ZSA9PSAtMylcbiAgICAgICAgICAgICAgWSArPSA0O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBicmVhayBlO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGsuaWQgPj0gbyAmJiAoWSArPSA0KTtcbiAgICAgICAgICBrLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICBUID0gSywgXyArPSBMLCBDICs9IFk7XG4gICAgICB9XG4gICAgcmV0dXJuICh3IDwgMCB8fCBfID09IFMpICYmIChRLnNpemUgPSBfLCBRLnN0YXJ0ID0gVCwgUS5za2lwID0gQyksIFEuc2l6ZSA+IDQgPyBRIDogdm9pZCAwO1xuICB9XG4gIGZ1bmN0aW9uIHkoUywgdywgaykge1xuICAgIGxldCB7IGlkOiBfLCBzdGFydDogVCwgZW5kOiBDLCBzaXplOiBBIH0gPSBhO1xuICAgIGlmIChhLm5leHQoKSwgQSA+PSAwICYmIF8gPCBvKSB7XG4gICAgICBsZXQgUSA9IGs7XG4gICAgICBpZiAoQSA+IDQpIHtcbiAgICAgICAgbGV0IFcgPSBhLnBvcyAtIChBIC0gNCk7XG4gICAgICAgIGZvciAoOyBhLnBvcyA+IFc7IClcbiAgICAgICAgICBrID0geShTLCB3LCBrKTtcbiAgICAgIH1cbiAgICAgIHdbLS1rXSA9IFEsIHdbLS1rXSA9IEMgLSBTLCB3Wy0ta10gPSBUIC0gUywgd1stLWtdID0gXztcbiAgICB9IGVsc2VcbiAgICAgIEEgPT0gLTMgPyBjID0gXyA6IEEgPT0gLTQgJiYgKHUgPSBfKTtcbiAgICByZXR1cm4gaztcbiAgfVxuICBsZXQgYiA9IFtdLCBnID0gW107XG4gIGZvciAoOyBhLnBvcyA+IDA7IClcbiAgICBkKHQuc3RhcnQgfHwgMCwgdC5idWZmZXJTdGFydCB8fCAwLCBiLCBnLCAtMSwgMCk7XG4gIGxldCB2ID0gKGUgPSB0Lmxlbmd0aCkgIT09IG51bGwgJiYgZSAhPT0gdm9pZCAwID8gZSA6IGIubGVuZ3RoID8gZ1swXSArIGJbMF0ubGVuZ3RoIDogMDtcbiAgcmV0dXJuIG5ldyBndChsW3QudG9wSURdLCBiLnJldmVyc2UoKSwgZy5yZXZlcnNlKCksIHYpO1xufVxuY29uc3QgUnYgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGx1KHQsIGUpIHtcbiAgaWYgKCF0LmlzQW5vbnltb3VzIHx8IGUgaW5zdGFuY2VvZiBscyB8fCBlLnR5cGUgIT0gdClcbiAgICByZXR1cm4gMTtcbiAgbGV0IG4gPSBSdi5nZXQoZSk7XG4gIGlmIChuID09IG51bGwpIHtcbiAgICBuID0gMTtcbiAgICBmb3IgKGxldCByIG9mIGUuY2hpbGRyZW4pIHtcbiAgICAgIGlmIChyLnR5cGUgIT0gdCB8fCAhKHIgaW5zdGFuY2VvZiBndCkpIHtcbiAgICAgICAgbiA9IDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbiArPSBsdSh0LCByKTtcbiAgICB9XG4gICAgUnYuc2V0KGUsIG4pO1xuICB9XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gT2codCwgZSwgbiwgciwgaSwgcywgbywgYSwgbCkge1xuICBsZXQgYyA9IDA7XG4gIGZvciAobGV0IHAgPSByOyBwIDwgaTsgcCsrKVxuICAgIGMgKz0gbHUodCwgZVtwXSk7XG4gIGxldCB1ID0gTWF0aC5jZWlsKFxuICAgIGMgKiAxLjUgLyA4XG4gICAgLyogQmFsYW5jZS5CcmFuY2hGYWN0b3IgKi9cbiAgKSwgZCA9IFtdLCBmID0gW107XG4gIGZ1bmN0aW9uIGgocCwgTywgbSwgeSwgYikge1xuICAgIGZvciAobGV0IGcgPSBtOyBnIDwgeTsgKSB7XG4gICAgICBsZXQgdiA9IGcsIFMgPSBPW2ddLCB3ID0gbHUodCwgcFtnXSk7XG4gICAgICBmb3IgKGcrKzsgZyA8IHk7IGcrKykge1xuICAgICAgICBsZXQgayA9IGx1KHQsIHBbZ10pO1xuICAgICAgICBpZiAodyArIGsgPj0gdSlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgdyArPSBrO1xuICAgICAgfVxuICAgICAgaWYgKGcgPT0gdiArIDEpIHtcbiAgICAgICAgaWYgKHcgPiB1KSB7XG4gICAgICAgICAgbGV0IGsgPSBwW3ZdO1xuICAgICAgICAgIGgoay5jaGlsZHJlbiwgay5wb3NpdGlvbnMsIDAsIGsuY2hpbGRyZW4ubGVuZ3RoLCBPW3ZdICsgYik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZC5wdXNoKHBbdl0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGsgPSBPW2cgLSAxXSArIHBbZyAtIDFdLmxlbmd0aCAtIFM7XG4gICAgICAgIGQucHVzaChPZyh0LCBwLCBPLCB2LCBnLCBTLCBrLCBudWxsLCBsKSk7XG4gICAgICB9XG4gICAgICBmLnB1c2goUyArIGIgLSBzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGgoZSwgbiwgciwgaSwgMCksIChhIHx8IGwpKGQsIGYsIG8pO1xufVxuY2xhc3MgZXgge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICB9XG4gIHNldEJ1ZmZlcihlLCBuLCByKSB7XG4gICAgbGV0IGkgPSB0aGlzLm1hcC5nZXQoZSk7XG4gICAgaSB8fCB0aGlzLm1hcC5zZXQoZSwgaSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpLCBpLnNldChuLCByKTtcbiAgfVxuICBnZXRCdWZmZXIoZSwgbikge1xuICAgIGxldCByID0gdGhpcy5tYXAuZ2V0KGUpO1xuICAgIHJldHVybiByICYmIHIuZ2V0KG4pO1xuICB9XG4gIC8qKlxuICBTZXQgdGhlIHZhbHVlIGZvciB0aGlzIHN5bnRheCBub2RlLlxuICAqL1xuICBzZXQoZSwgbikge1xuICAgIGUgaW5zdGFuY2VvZiBOciA/IHRoaXMuc2V0QnVmZmVyKGUuY29udGV4dC5idWZmZXIsIGUuaW5kZXgsIG4pIDogZSBpbnN0YW5jZW9mIGxuICYmIHRoaXMubWFwLnNldChlLnRyZWUsIG4pO1xuICB9XG4gIC8qKlxuICBSZXRyaWV2ZSB2YWx1ZSBmb3IgdGhpcyBzeW50YXggbm9kZSwgaWYgaXQgZXhpc3RzIGluIHRoZSBtYXAuXG4gICovXG4gIGdldChlKSB7XG4gICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBOciA/IHRoaXMuZ2V0QnVmZmVyKGUuY29udGV4dC5idWZmZXIsIGUuaW5kZXgpIDogZSBpbnN0YW5jZW9mIGxuID8gdGhpcy5tYXAuZ2V0KGUudHJlZSkgOiB2b2lkIDA7XG4gIH1cbiAgLyoqXG4gIFNldCB0aGUgdmFsdWUgZm9yIHRoZSBub2RlIHRoYXQgYSBjdXJzb3IgY3VycmVudGx5IHBvaW50cyB0by5cbiAgKi9cbiAgY3Vyc29yU2V0KGUsIG4pIHtcbiAgICBlLmJ1ZmZlciA/IHRoaXMuc2V0QnVmZmVyKGUuYnVmZmVyLmJ1ZmZlciwgZS5pbmRleCwgbikgOiB0aGlzLm1hcC5zZXQoZS50cmVlLCBuKTtcbiAgfVxuICAvKipcbiAgUmV0cmlldmUgdGhlIHZhbHVlIGZvciB0aGUgbm9kZSB0aGF0IGEgY3Vyc29yIGN1cnJlbnRseSBwb2ludHNcbiAgdG8uXG4gICovXG4gIGN1cnNvckdldChlKSB7XG4gICAgcmV0dXJuIGUuYnVmZmVyID8gdGhpcy5nZXRCdWZmZXIoZS5idWZmZXIuYnVmZmVyLCBlLmluZGV4KSA6IHRoaXMubWFwLmdldChlLnRyZWUpO1xuICB9XG59XG5jbGFzcyBzaSB7XG4gIC8qKlxuICBDb25zdHJ1Y3QgYSB0cmVlIGZyYWdtZW50LiBZb3UnbGwgdXN1YWxseSB3YW50IHRvIHVzZVxuICBbYGFkZFRyZWVgXSgjY29tbW9uLlRyZWVGcmFnbWVudF5hZGRUcmVlKSBhbmRcbiAgW2BhcHBseUNoYW5nZXNgXSgjY29tbW9uLlRyZWVGcmFnbWVudF5hcHBseUNoYW5nZXMpIGluc3RlYWQgb2ZcbiAgY2FsbGluZyB0aGlzIGRpcmVjdGx5LlxuICAqL1xuICBjb25zdHJ1Y3RvcihlLCBuLCByLCBpLCBzID0gITEsIG8gPSAhMSkge1xuICAgIHRoaXMuZnJvbSA9IGUsIHRoaXMudG8gPSBuLCB0aGlzLnRyZWUgPSByLCB0aGlzLm9mZnNldCA9IGksIHRoaXMub3BlbiA9IChzID8gMSA6IDApIHwgKG8gPyAyIDogMCk7XG4gIH1cbiAgLyoqXG4gIFdoZXRoZXIgdGhlIHN0YXJ0IG9mIHRoZSBmcmFnbWVudCByZXByZXNlbnRzIHRoZSBzdGFydCBvZiBhXG4gIHBhcnNlLCBvciB0aGUgZW5kIG9mIGEgY2hhbmdlLiAoSW4gdGhlIHNlY29uZCBjYXNlLCBpdCBtYXkgbm90XG4gIGJlIHNhZmUgdG8gcmV1c2Ugc29tZSBub2RlcyBhdCB0aGUgc3RhcnQsIGRlcGVuZGluZyBvbiB0aGVcbiAgcGFyc2luZyBhbGdvcml0aG0uKVxuICAqL1xuICBnZXQgb3BlblN0YXJ0KCkge1xuICAgIHJldHVybiAodGhpcy5vcGVuICYgMSkgPiAwO1xuICB9XG4gIC8qKlxuICBXaGV0aGVyIHRoZSBlbmQgb2YgdGhlIGZyYWdtZW50IHJlcHJlc2VudHMgdGhlIGVuZCBvZiBhXG4gIGZ1bGwtZG9jdW1lbnQgcGFyc2UsIG9yIHRoZSBzdGFydCBvZiBhIGNoYW5nZS5cbiAgKi9cbiAgZ2V0IG9wZW5FbmQoKSB7XG4gICAgcmV0dXJuICh0aGlzLm9wZW4gJiAyKSA+IDA7XG4gIH1cbiAgLyoqXG4gIENyZWF0ZSBhIHNldCBvZiBmcmFnbWVudHMgZnJvbSBhIGZyZXNobHkgcGFyc2VkIHRyZWUsIG9yIHVwZGF0ZVxuICBhbiBleGlzdGluZyBzZXQgb2YgZnJhZ21lbnRzIGJ5IHJlcGxhY2luZyB0aGUgb25lcyB0aGF0IG92ZXJsYXBcbiAgd2l0aCBhIHRyZWUgd2l0aCBjb250ZW50IGZyb20gdGhlIG5ldyB0cmVlLiBXaGVuIGBwYXJ0aWFsYCBpc1xuICB0cnVlLCB0aGUgcGFyc2UgaXMgdHJlYXRlZCBhcyBpbmNvbXBsZXRlLCBhbmQgdGhlIHJlc3VsdGluZ1xuICBmcmFnbWVudCBoYXMgW2BvcGVuRW5kYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnQub3BlbkVuZCkgc2V0IHRvXG4gIHRydWUuXG4gICovXG4gIHN0YXRpYyBhZGRUcmVlKGUsIG4gPSBbXSwgciA9ICExKSB7XG4gICAgbGV0IGkgPSBbbmV3IHNpKDAsIGUubGVuZ3RoLCBlLCAwLCAhMSwgcildO1xuICAgIGZvciAobGV0IHMgb2YgbilcbiAgICAgIHMudG8gPiBlLmxlbmd0aCAmJiBpLnB1c2gocyk7XG4gICAgcmV0dXJuIGk7XG4gIH1cbiAgLyoqXG4gIEFwcGx5IGEgc2V0IG9mIGVkaXRzIHRvIGFuIGFycmF5IG9mIGZyYWdtZW50cywgcmVtb3Zpbmcgb3JcbiAgc3BsaXR0aW5nIGZyYWdtZW50cyBhcyBuZWNlc3NhcnkgdG8gcmVtb3ZlIGVkaXRlZCByYW5nZXMsIGFuZFxuICBhZGp1c3Rpbmcgb2Zmc2V0cyBmb3IgZnJhZ21lbnRzIHRoYXQgbW92ZWQuXG4gICovXG4gIHN0YXRpYyBhcHBseUNoYW5nZXMoZSwgbiwgciA9IDEyOCkge1xuICAgIGlmICghbi5sZW5ndGgpXG4gICAgICByZXR1cm4gZTtcbiAgICBsZXQgaSA9IFtdLCBzID0gMSwgbyA9IGUubGVuZ3RoID8gZVswXSA6IG51bGw7XG4gICAgZm9yIChsZXQgYSA9IDAsIGwgPSAwLCBjID0gMDsgOyBhKyspIHtcbiAgICAgIGxldCB1ID0gYSA8IG4ubGVuZ3RoID8gblthXSA6IG51bGwsIGQgPSB1ID8gdS5mcm9tQSA6IDFlOTtcbiAgICAgIGlmIChkIC0gbCA+PSByKVxuICAgICAgICBmb3IgKDsgbyAmJiBvLmZyb20gPCBkOyApIHtcbiAgICAgICAgICBsZXQgZiA9IG87XG4gICAgICAgICAgaWYgKGwgPj0gZi5mcm9tIHx8IGQgPD0gZi50byB8fCBjKSB7XG4gICAgICAgICAgICBsZXQgaCA9IE1hdGgubWF4KGYuZnJvbSwgbCkgLSBjLCBwID0gTWF0aC5taW4oZi50bywgZCkgLSBjO1xuICAgICAgICAgICAgZiA9IGggPj0gcCA/IG51bGwgOiBuZXcgc2koaCwgcCwgZi50cmVlLCBmLm9mZnNldCArIGMsIGEgPiAwLCAhIXUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZiAmJiBpLnB1c2goZiksIG8udG8gPiBkKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgbyA9IHMgPCBlLmxlbmd0aCA/IGVbcysrXSA6IG51bGw7XG4gICAgICAgIH1cbiAgICAgIGlmICghdSlcbiAgICAgICAgYnJlYWs7XG4gICAgICBsID0gdS50b0EsIGMgPSB1LnRvQSAtIHUudG9CO1xuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfVxufVxuY2xhc3MgdHgge1xuICAvKipcbiAgU3RhcnQgYSBwYXJzZSwgcmV0dXJuaW5nIGEgW3BhcnRpYWwgcGFyc2VdKCNjb21tb24uUGFydGlhbFBhcnNlKVxuICBvYmplY3QuIFtgZnJhZ21lbnRzYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnQpIGNhbiBiZSBwYXNzZWQgaW4gdG9cbiAgbWFrZSB0aGUgcGFyc2UgaW5jcmVtZW50YWwuXG4gIFxuICBCeSBkZWZhdWx0LCB0aGUgZW50aXJlIGlucHV0IGlzIHBhcnNlZC4gWW91IGNhbiBwYXNzIGByYW5nZXNgLFxuICB3aGljaCBzaG91bGQgYmUgYSBzb3J0ZWQgYXJyYXkgb2Ygbm9uLWVtcHR5LCBub24tb3ZlcmxhcHBpbmdcbiAgcmFuZ2VzLCB0byBwYXJzZSBvbmx5IHRob3NlIHJhbmdlcy4gVGhlIHRyZWUgcmV0dXJuZWQgaW4gdGhhdFxuICBjYXNlIHdpbGwgc3RhcnQgYXQgYHJhbmdlc1swXS5mcm9tYC5cbiAgKi9cbiAgc3RhcnRQYXJzZShlLCBuLCByKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBlID09IFwic3RyaW5nXCIgJiYgKGUgPSBuZXcgeEQoZSkpLCByID0gciA/IHIubGVuZ3RoID8gci5tYXAoKGkpID0+IG5ldyBGbihpLmZyb20sIGkudG8pKSA6IFtuZXcgRm4oMCwgMCldIDogW25ldyBGbigwLCBlLmxlbmd0aCldLCB0aGlzLmNyZWF0ZVBhcnNlKGUsIG4gfHwgW10sIHIpO1xuICB9XG4gIC8qKlxuICBSdW4gYSBmdWxsIHBhcnNlLCByZXR1cm5pbmcgdGhlIHJlc3VsdGluZyB0cmVlLlxuICAqL1xuICBwYXJzZShlLCBuLCByKSB7XG4gICAgbGV0IGkgPSB0aGlzLnN0YXJ0UGFyc2UoZSwgbiwgcik7XG4gICAgZm9yICg7IDsgKSB7XG4gICAgICBsZXQgcyA9IGkuYWR2YW5jZSgpO1xuICAgICAgaWYgKHMpXG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgeEQge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5zdHJpbmcgPSBlO1xuICB9XG4gIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyaW5nLmxlbmd0aDtcbiAgfVxuICBjaHVuayhlKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGUpO1xuICB9XG4gIGdldCBsaW5lQ2h1bmtzKCkge1xuICAgIHJldHVybiAhMTtcbiAgfVxuICByZWFkKGUsIG4pIHtcbiAgICByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UoZSwgbik7XG4gIH1cbn1cbmZ1bmN0aW9uIFBEKHQpIHtcbiAgcmV0dXJuIChlLCBuLCByLCBpKSA9PiBuZXcgVEQoZSwgdCwgbiwgciwgaSk7XG59XG5jbGFzcyBOdiB7XG4gIGNvbnN0cnVjdG9yKGUsIG4sIHIsIGksIHMpIHtcbiAgICB0aGlzLnBhcnNlciA9IGUsIHRoaXMucGFyc2UgPSBuLCB0aGlzLm92ZXJsYXkgPSByLCB0aGlzLnRhcmdldCA9IGksIHRoaXMuZnJvbSA9IHM7XG4gIH1cbn1cbmZ1bmN0aW9uIER2KHQpIHtcbiAgaWYgKCF0Lmxlbmd0aCB8fCB0LnNvbWUoKGUpID0+IGUuZnJvbSA+PSBlLnRvKSlcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5uZXIgcGFyc2UgcmFuZ2VzIGdpdmVuOiBcIiArIEpTT04uc3RyaW5naWZ5KHQpKTtcbn1cbmNsYXNzIF9EIHtcbiAgY29uc3RydWN0b3IoZSwgbiwgciwgaSwgcywgbywgYSkge1xuICAgIHRoaXMucGFyc2VyID0gZSwgdGhpcy5wcmVkaWNhdGUgPSBuLCB0aGlzLm1vdW50cyA9IHIsIHRoaXMuaW5kZXggPSBpLCB0aGlzLnN0YXJ0ID0gcywgdGhpcy50YXJnZXQgPSBvLCB0aGlzLnByZXYgPSBhLCB0aGlzLmRlcHRoID0gMCwgdGhpcy5yYW5nZXMgPSBbXTtcbiAgfVxufVxuY29uc3Qgd3AgPSBuZXcgUmUoeyBwZXJOb2RlOiAhMCB9KTtcbmNsYXNzIFREIHtcbiAgY29uc3RydWN0b3IoZSwgbiwgciwgaSwgcykge1xuICAgIHRoaXMubmVzdCA9IG4sIHRoaXMuaW5wdXQgPSByLCB0aGlzLmZyYWdtZW50cyA9IGksIHRoaXMucmFuZ2VzID0gcywgdGhpcy5pbm5lciA9IFtdLCB0aGlzLmlubmVyRG9uZSA9IDAsIHRoaXMuYmFzZVRyZWUgPSBudWxsLCB0aGlzLnN0b3BwZWRBdCA9IG51bGwsIHRoaXMuYmFzZVBhcnNlID0gZTtcbiAgfVxuICBhZHZhbmNlKCkge1xuICAgIGlmICh0aGlzLmJhc2VQYXJzZSkge1xuICAgICAgbGV0IHIgPSB0aGlzLmJhc2VQYXJzZS5hZHZhbmNlKCk7XG4gICAgICBpZiAoIXIpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgaWYgKHRoaXMuYmFzZVBhcnNlID0gbnVsbCwgdGhpcy5iYXNlVHJlZSA9IHIsIHRoaXMuc3RhcnRJbm5lcigpLCB0aGlzLnN0b3BwZWRBdCAhPSBudWxsKVxuICAgICAgICBmb3IgKGxldCBpIG9mIHRoaXMuaW5uZXIpXG4gICAgICAgICAgaS5wYXJzZS5zdG9wQXQodGhpcy5zdG9wcGVkQXQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pbm5lckRvbmUgPT0gdGhpcy5pbm5lci5sZW5ndGgpIHtcbiAgICAgIGxldCByID0gdGhpcy5iYXNlVHJlZTtcbiAgICAgIHJldHVybiB0aGlzLnN0b3BwZWRBdCAhPSBudWxsICYmIChyID0gbmV3IGd0KHIudHlwZSwgci5jaGlsZHJlbiwgci5wb3NpdGlvbnMsIHIubGVuZ3RoLCByLnByb3BWYWx1ZXMuY29uY2F0KFtbd3AsIHRoaXMuc3RvcHBlZEF0XV0pKSksIHI7XG4gICAgfVxuICAgIGxldCBlID0gdGhpcy5pbm5lclt0aGlzLmlubmVyRG9uZV0sIG4gPSBlLnBhcnNlLmFkdmFuY2UoKTtcbiAgICBpZiAobikge1xuICAgICAgdGhpcy5pbm5lckRvbmUrKztcbiAgICAgIGxldCByID0gT2JqZWN0LmFzc2lnbigvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgZS50YXJnZXQucHJvcHMpO1xuICAgICAgcltSZS5tb3VudGVkLmlkXSA9IG5ldyB2bChuLCBlLm92ZXJsYXksIGUucGFyc2VyKSwgZS50YXJnZXQucHJvcHMgPSByO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnZXQgcGFyc2VkUG9zKCkge1xuICAgIGlmICh0aGlzLmJhc2VQYXJzZSlcbiAgICAgIHJldHVybiAwO1xuICAgIGxldCBlID0gdGhpcy5pbnB1dC5sZW5ndGg7XG4gICAgZm9yIChsZXQgbiA9IHRoaXMuaW5uZXJEb25lOyBuIDwgdGhpcy5pbm5lci5sZW5ndGg7IG4rKylcbiAgICAgIHRoaXMuaW5uZXJbbl0uZnJvbSA8IGUgJiYgKGUgPSBNYXRoLm1pbihlLCB0aGlzLmlubmVyW25dLnBhcnNlLnBhcnNlZFBvcykpO1xuICAgIHJldHVybiBlO1xuICB9XG4gIHN0b3BBdChlKSB7XG4gICAgaWYgKHRoaXMuc3RvcHBlZEF0ID0gZSwgdGhpcy5iYXNlUGFyc2UpXG4gICAgICB0aGlzLmJhc2VQYXJzZS5zdG9wQXQoZSk7XG4gICAgZWxzZVxuICAgICAgZm9yIChsZXQgbiA9IHRoaXMuaW5uZXJEb25lOyBuIDwgdGhpcy5pbm5lci5sZW5ndGg7IG4rKylcbiAgICAgICAgdGhpcy5pbm5lcltuXS5wYXJzZS5zdG9wQXQoZSk7XG4gIH1cbiAgc3RhcnRJbm5lcigpIHtcbiAgICBsZXQgZSA9IG5ldyBRRCh0aGlzLmZyYWdtZW50cyksIG4gPSBudWxsLCByID0gbnVsbCwgaSA9IG5ldyBYdShuZXcgbG4odGhpcy5iYXNlVHJlZSwgdGhpcy5yYW5nZXNbMF0uZnJvbSwgMCwgbnVsbCksIGx0LkluY2x1ZGVBbm9ueW1vdXMgfCBsdC5JZ25vcmVNb3VudHMpO1xuICAgIGU6XG4gICAgICBmb3IgKGxldCBzLCBvOyA7ICkge1xuICAgICAgICBsZXQgYSA9ICEwLCBsO1xuICAgICAgICBpZiAodGhpcy5zdG9wcGVkQXQgIT0gbnVsbCAmJiBpLmZyb20gPj0gdGhpcy5zdG9wcGVkQXQpXG4gICAgICAgICAgYSA9ICExO1xuICAgICAgICBlbHNlIGlmIChlLmhhc05vZGUoaSkpIHtcbiAgICAgICAgICBpZiAobikge1xuICAgICAgICAgICAgbGV0IGMgPSBuLm1vdW50cy5maW5kKCh1KSA9PiB1LmZyYWcuZnJvbSA8PSBpLmZyb20gJiYgdS5mcmFnLnRvID49IGkudG8gJiYgdS5tb3VudC5vdmVybGF5KTtcbiAgICAgICAgICAgIGlmIChjKVxuICAgICAgICAgICAgICBmb3IgKGxldCB1IG9mIGMubW91bnQub3ZlcmxheSkge1xuICAgICAgICAgICAgICAgIGxldCBkID0gdS5mcm9tICsgYy5wb3MsIGYgPSB1LnRvICsgYy5wb3M7XG4gICAgICAgICAgICAgICAgZCA+PSBpLmZyb20gJiYgZiA8PSBpLnRvICYmICFuLnJhbmdlcy5zb21lKChoKSA9PiBoLmZyb20gPCBmICYmIGgudG8gPiBkKSAmJiBuLnJhbmdlcy5wdXNoKHsgZnJvbTogZCwgdG86IGYgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYSA9ICExO1xuICAgICAgICB9IGVsc2UgaWYgKHIgJiYgKG8gPSBFRChyLnJhbmdlcywgaS5mcm9tLCBpLnRvKSkpXG4gICAgICAgICAgYSA9IG8gIT0gMjtcbiAgICAgICAgZWxzZSBpZiAoIWkudHlwZS5pc0Fub255bW91cyAmJiAocyA9IHRoaXMubmVzdChpLCB0aGlzLmlucHV0KSkgJiYgKGkuZnJvbSA8IGkudG8gfHwgIXMub3ZlcmxheSkpIHtcbiAgICAgICAgICBpLnRyZWUgfHwgJEQoaSk7XG4gICAgICAgICAgbGV0IGMgPSBlLmZpbmRNb3VudHMoaS5mcm9tLCBzLnBhcnNlcik7XG4gICAgICAgICAgaWYgKHR5cGVvZiBzLm92ZXJsYXkgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgbiA9IG5ldyBfRChzLnBhcnNlciwgcy5vdmVybGF5LCBjLCB0aGlzLmlubmVyLmxlbmd0aCwgaS5mcm9tLCBpLnRyZWUsIG4pO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHUgPSBJdih0aGlzLnJhbmdlcywgcy5vdmVybGF5IHx8IChpLmZyb20gPCBpLnRvID8gW25ldyBGbihpLmZyb20sIGkudG8pXSA6IFtdKSk7XG4gICAgICAgICAgICB1Lmxlbmd0aCAmJiBEdih1KSwgKHUubGVuZ3RoIHx8ICFzLm92ZXJsYXkpICYmIHRoaXMuaW5uZXIucHVzaChuZXcgTnYocy5wYXJzZXIsIHUubGVuZ3RoID8gcy5wYXJzZXIuc3RhcnRQYXJzZSh0aGlzLmlucHV0LCBXdihjLCB1KSwgdSkgOiBzLnBhcnNlci5zdGFydFBhcnNlKFwiXCIpLCBzLm92ZXJsYXkgPyBzLm92ZXJsYXkubWFwKChkKSA9PiBuZXcgRm4oZC5mcm9tIC0gaS5mcm9tLCBkLnRvIC0gaS5mcm9tKSkgOiBudWxsLCBpLnRyZWUsIHUubGVuZ3RoID8gdVswXS5mcm9tIDogaS5mcm9tKSksIHMub3ZlcmxheSA/IHUubGVuZ3RoICYmIChyID0geyByYW5nZXM6IHUsIGRlcHRoOiAwLCBwcmV2OiByIH0pIDogYSA9ICExO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgbiAmJiAobCA9IG4ucHJlZGljYXRlKGkpKSAmJiAobCA9PT0gITAgJiYgKGwgPSBuZXcgRm4oaS5mcm9tLCBpLnRvKSksIGwuZnJvbSA8IGwudG8gJiYgbi5yYW5nZXMucHVzaChsKSk7XG4gICAgICAgIGlmIChhICYmIGkuZmlyc3RDaGlsZCgpKVxuICAgICAgICAgIG4gJiYgbi5kZXB0aCsrLCByICYmIHIuZGVwdGgrKztcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGZvciAoOyAhaS5uZXh0U2libGluZygpOyApIHtcbiAgICAgICAgICAgIGlmICghaS5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgYnJlYWsgZTtcbiAgICAgICAgICAgIGlmIChuICYmICEtLW4uZGVwdGgpIHtcbiAgICAgICAgICAgICAgbGV0IGMgPSBJdih0aGlzLnJhbmdlcywgbi5yYW5nZXMpO1xuICAgICAgICAgICAgICBjLmxlbmd0aCAmJiAoRHYoYyksIHRoaXMuaW5uZXIuc3BsaWNlKG4uaW5kZXgsIDAsIG5ldyBOdihuLnBhcnNlciwgbi5wYXJzZXIuc3RhcnRQYXJzZSh0aGlzLmlucHV0LCBXdihuLm1vdW50cywgYyksIGMpLCBuLnJhbmdlcy5tYXAoKHUpID0+IG5ldyBGbih1LmZyb20gLSBuLnN0YXJ0LCB1LnRvIC0gbi5zdGFydCkpLCBuLnRhcmdldCwgY1swXS5mcm9tKSkpLCBuID0gbi5wcmV2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgciAmJiAhLS1yLmRlcHRoICYmIChyID0gci5wcmV2KTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIEVEKHQsIGUsIG4pIHtcbiAgZm9yIChsZXQgciBvZiB0KSB7XG4gICAgaWYgKHIuZnJvbSA+PSBuKVxuICAgICAgYnJlYWs7XG4gICAgaWYgKHIudG8gPiBlKVxuICAgICAgcmV0dXJuIHIuZnJvbSA8PSBlICYmIHIudG8gPj0gbiA/IDIgOiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gWnYodCwgZSwgbiwgciwgaSwgcykge1xuICBpZiAoZSA8IG4pIHtcbiAgICBsZXQgbyA9IHQuYnVmZmVyW2UgKyAxXTtcbiAgICByLnB1c2godC5zbGljZShlLCBuLCBvKSksIGkucHVzaChvIC0gcyk7XG4gIH1cbn1cbmZ1bmN0aW9uICREKHQpIHtcbiAgbGV0IHsgbm9kZTogZSB9ID0gdCwgbiA9IFtdLCByID0gZS5jb250ZXh0LmJ1ZmZlcjtcbiAgZG9cbiAgICBuLnB1c2godC5pbmRleCksIHQucGFyZW50KCk7XG4gIHdoaWxlICghdC50cmVlKTtcbiAgbGV0IGkgPSB0LnRyZWUsIHMgPSBpLmNoaWxkcmVuLmluZGV4T2YociksIG8gPSBpLmNoaWxkcmVuW3NdLCBhID0gby5idWZmZXIsIGwgPSBbc107XG4gIGZ1bmN0aW9uIGModSwgZCwgZiwgaCwgcCwgTykge1xuICAgIGxldCBtID0gbltPXSwgeSA9IFtdLCBiID0gW107XG4gICAgWnYobywgdSwgbSwgeSwgYiwgaCk7XG4gICAgbGV0IGcgPSBhW20gKyAxXSwgdiA9IGFbbSArIDJdO1xuICAgIGwucHVzaCh5Lmxlbmd0aCk7XG4gICAgbGV0IFMgPSBPID8gYyhtICsgNCwgYVttICsgM10sIG8uc2V0LnR5cGVzW2FbbV1dLCBnLCB2IC0gZywgTyAtIDEpIDogZS50b1RyZWUoKTtcbiAgICByZXR1cm4geS5wdXNoKFMpLCBiLnB1c2goZyAtIGgpLCBadihvLCBhW20gKyAzXSwgZCwgeSwgYiwgaCksIG5ldyBndChmLCB5LCBiLCBwKTtcbiAgfVxuICBpLmNoaWxkcmVuW3NdID0gYygwLCBhLmxlbmd0aCwgT24ubm9uZSwgMCwgby5sZW5ndGgsIG4ubGVuZ3RoIC0gMSk7XG4gIGZvciAobGV0IHUgb2YgbCkge1xuICAgIGxldCBkID0gdC50cmVlLmNoaWxkcmVuW3VdLCBmID0gdC50cmVlLnBvc2l0aW9uc1t1XTtcbiAgICB0LnlpZWxkKG5ldyBsbihkLCBmICsgdC5mcm9tLCB1LCB0Ll90cmVlKSk7XG4gIH1cbn1cbmNsYXNzIFZ2IHtcbiAgY29uc3RydWN0b3IoZSwgbikge1xuICAgIHRoaXMub2Zmc2V0ID0gbiwgdGhpcy5kb25lID0gITEsIHRoaXMuY3Vyc29yID0gZS5jdXJzb3IobHQuSW5jbHVkZUFub255bW91cyB8IGx0Lklnbm9yZU1vdW50cyk7XG4gIH1cbiAgLy8gTW92ZSB0byB0aGUgZmlyc3Qgbm9kZSAoaW4gcHJlLW9yZGVyKSB0aGF0IHN0YXJ0cyBhdCBvciBhZnRlciBgcG9zYC5cbiAgbW92ZVRvKGUpIHtcbiAgICBsZXQgeyBjdXJzb3I6IG4gfSA9IHRoaXMsIHIgPSBlIC0gdGhpcy5vZmZzZXQ7XG4gICAgZm9yICg7ICF0aGlzLmRvbmUgJiYgbi5mcm9tIDwgcjsgKVxuICAgICAgbi50byA+PSBlICYmIG4uZW50ZXIociwgMSwgbHQuSWdub3JlT3ZlcmxheXMgfCBsdC5FeGNsdWRlQnVmZmVycykgfHwgbi5uZXh0KCExKSB8fCAodGhpcy5kb25lID0gITApO1xuICB9XG4gIGhhc05vZGUoZSkge1xuICAgIGlmICh0aGlzLm1vdmVUbyhlLmZyb20pLCAhdGhpcy5kb25lICYmIHRoaXMuY3Vyc29yLmZyb20gKyB0aGlzLm9mZnNldCA9PSBlLmZyb20gJiYgdGhpcy5jdXJzb3IudHJlZSlcbiAgICAgIGZvciAobGV0IG4gPSB0aGlzLmN1cnNvci50cmVlOyA7ICkge1xuICAgICAgICBpZiAobiA9PSBlLnRyZWUpXG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICBpZiAobi5jaGlsZHJlbi5sZW5ndGggJiYgbi5wb3NpdGlvbnNbMF0gPT0gMCAmJiBuLmNoaWxkcmVuWzBdIGluc3RhbmNlb2YgZ3QpXG4gICAgICAgICAgbiA9IG4uY2hpbGRyZW5bMF07XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICByZXR1cm4gITE7XG4gIH1cbn1cbmxldCBRRCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHZhciBuO1xuICAgIGlmICh0aGlzLmZyYWdtZW50cyA9IGUsIHRoaXMuY3VyVG8gPSAwLCB0aGlzLmZyYWdJID0gMCwgZS5sZW5ndGgpIHtcbiAgICAgIGxldCByID0gdGhpcy5jdXJGcmFnID0gZVswXTtcbiAgICAgIHRoaXMuY3VyVG8gPSAobiA9IHIudHJlZS5wcm9wKHdwKSkgIT09IG51bGwgJiYgbiAhPT0gdm9pZCAwID8gbiA6IHIudG8sIHRoaXMuaW5uZXIgPSBuZXcgVnYoci50cmVlLCAtci5vZmZzZXQpO1xuICAgIH0gZWxzZVxuICAgICAgdGhpcy5jdXJGcmFnID0gdGhpcy5pbm5lciA9IG51bGw7XG4gIH1cbiAgaGFzTm9kZShlKSB7XG4gICAgZm9yICg7IHRoaXMuY3VyRnJhZyAmJiBlLmZyb20gPj0gdGhpcy5jdXJUbzsgKVxuICAgICAgdGhpcy5uZXh0RnJhZygpO1xuICAgIHJldHVybiB0aGlzLmN1ckZyYWcgJiYgdGhpcy5jdXJGcmFnLmZyb20gPD0gZS5mcm9tICYmIHRoaXMuY3VyVG8gPj0gZS50byAmJiB0aGlzLmlubmVyLmhhc05vZGUoZSk7XG4gIH1cbiAgbmV4dEZyYWcoKSB7XG4gICAgdmFyIGU7XG4gICAgaWYgKHRoaXMuZnJhZ0krKywgdGhpcy5mcmFnSSA9PSB0aGlzLmZyYWdtZW50cy5sZW5ndGgpXG4gICAgICB0aGlzLmN1ckZyYWcgPSB0aGlzLmlubmVyID0gbnVsbDtcbiAgICBlbHNlIHtcbiAgICAgIGxldCBuID0gdGhpcy5jdXJGcmFnID0gdGhpcy5mcmFnbWVudHNbdGhpcy5mcmFnSV07XG4gICAgICB0aGlzLmN1clRvID0gKGUgPSBuLnRyZWUucHJvcCh3cCkpICE9PSBudWxsICYmIGUgIT09IHZvaWQgMCA/IGUgOiBuLnRvLCB0aGlzLmlubmVyID0gbmV3IFZ2KG4udHJlZSwgLW4ub2Zmc2V0KTtcbiAgICB9XG4gIH1cbiAgZmluZE1vdW50cyhlLCBuKSB7XG4gICAgdmFyIHI7XG4gICAgbGV0IGkgPSBbXTtcbiAgICBpZiAodGhpcy5pbm5lcikge1xuICAgICAgdGhpcy5pbm5lci5jdXJzb3IubW92ZVRvKGUsIDEpO1xuICAgICAgZm9yIChsZXQgcyA9IHRoaXMuaW5uZXIuY3Vyc29yLm5vZGU7IHM7IHMgPSBzLnBhcmVudCkge1xuICAgICAgICBsZXQgbyA9IChyID0gcy50cmVlKSA9PT0gbnVsbCB8fCByID09PSB2b2lkIDAgPyB2b2lkIDAgOiByLnByb3AoUmUubW91bnRlZCk7XG4gICAgICAgIGlmIChvICYmIG8ucGFyc2VyID09IG4pXG4gICAgICAgICAgZm9yIChsZXQgYSA9IHRoaXMuZnJhZ0k7IGEgPCB0aGlzLmZyYWdtZW50cy5sZW5ndGg7IGErKykge1xuICAgICAgICAgICAgbGV0IGwgPSB0aGlzLmZyYWdtZW50c1thXTtcbiAgICAgICAgICAgIGlmIChsLmZyb20gPj0gcy50bylcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBsLnRyZWUgPT0gdGhpcy5jdXJGcmFnLnRyZWUgJiYgaS5wdXNoKHtcbiAgICAgICAgICAgICAgZnJhZzogbCxcbiAgICAgICAgICAgICAgcG9zOiBzLmZyb20gLSBsLm9mZnNldCxcbiAgICAgICAgICAgICAgbW91bnQ6IG9cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH1cbn07XG5mdW5jdGlvbiBJdih0LCBlKSB7XG4gIGxldCBuID0gbnVsbCwgciA9IGU7XG4gIGZvciAobGV0IGkgPSAxLCBzID0gMDsgaSA8IHQubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgbyA9IHRbaSAtIDFdLnRvLCBhID0gdFtpXS5mcm9tO1xuICAgIGZvciAoOyBzIDwgci5sZW5ndGg7IHMrKykge1xuICAgICAgbGV0IGwgPSByW3NdO1xuICAgICAgaWYgKGwuZnJvbSA+PSBhKVxuICAgICAgICBicmVhaztcbiAgICAgIGwudG8gPD0gbyB8fCAobiB8fCAociA9IG4gPSBlLnNsaWNlKCkpLCBsLmZyb20gPCBvID8gKG5bc10gPSBuZXcgRm4obC5mcm9tLCBvKSwgbC50byA+IGEgJiYgbi5zcGxpY2UocyArIDEsIDAsIG5ldyBGbihhLCBsLnRvKSkpIDogbC50byA+IGEgPyBuW3MtLV0gPSBuZXcgRm4oYSwgbC50bykgOiBuLnNwbGljZShzLS0sIDEpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBDRCh0LCBlLCBuLCByKSB7XG4gIGxldCBpID0gMCwgcyA9IDAsIG8gPSAhMSwgYSA9ICExLCBsID0gLTFlOSwgYyA9IFtdO1xuICBmb3IgKDsgOyApIHtcbiAgICBsZXQgdSA9IGkgPT0gdC5sZW5ndGggPyAxZTkgOiBvID8gdFtpXS50byA6IHRbaV0uZnJvbSwgZCA9IHMgPT0gZS5sZW5ndGggPyAxZTkgOiBhID8gZVtzXS50byA6IGVbc10uZnJvbTtcbiAgICBpZiAobyAhPSBhKSB7XG4gICAgICBsZXQgZiA9IE1hdGgubWF4KGwsIG4pLCBoID0gTWF0aC5taW4odSwgZCwgcik7XG4gICAgICBmIDwgaCAmJiBjLnB1c2gobmV3IEZuKGYsIGgpKTtcbiAgICB9XG4gICAgaWYgKGwgPSBNYXRoLm1pbih1LCBkKSwgbCA9PSAxZTkpXG4gICAgICBicmVhaztcbiAgICB1ID09IGwgJiYgKG8gPyAobyA9ICExLCBpKyspIDogbyA9ICEwKSwgZCA9PSBsICYmIChhID8gKGEgPSAhMSwgcysrKSA6IGEgPSAhMCk7XG4gIH1cbiAgcmV0dXJuIGM7XG59XG5mdW5jdGlvbiBXdih0LCBlKSB7XG4gIGxldCBuID0gW107XG4gIGZvciAobGV0IHsgcG9zOiByLCBtb3VudDogaSwgZnJhZzogcyB9IG9mIHQpIHtcbiAgICBsZXQgbyA9IHIgKyAoaS5vdmVybGF5ID8gaS5vdmVybGF5WzBdLmZyb20gOiAwKSwgYSA9IG8gKyBpLnRyZWUubGVuZ3RoLCBsID0gTWF0aC5tYXgocy5mcm9tLCBvKSwgYyA9IE1hdGgubWluKHMudG8sIGEpO1xuICAgIGlmIChpLm92ZXJsYXkpIHtcbiAgICAgIGxldCB1ID0gaS5vdmVybGF5Lm1hcCgoZikgPT4gbmV3IEZuKGYuZnJvbSArIHIsIGYudG8gKyByKSksIGQgPSBDRChlLCB1LCBsLCBjKTtcbiAgICAgIGZvciAobGV0IGYgPSAwLCBoID0gbDsgOyBmKyspIHtcbiAgICAgICAgbGV0IHAgPSBmID09IGQubGVuZ3RoLCBPID0gcCA/IGMgOiBkW2ZdLmZyb207XG4gICAgICAgIGlmIChPID4gaCAmJiBuLnB1c2gobmV3IHNpKGgsIE8sIGkudHJlZSwgLW8sIHMuZnJvbSA+PSBoIHx8IHMub3BlblN0YXJ0LCBzLnRvIDw9IE8gfHwgcy5vcGVuRW5kKSksIHApXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGggPSBkW2ZdLnRvO1xuICAgICAgfVxuICAgIH0gZWxzZVxuICAgICAgbi5wdXNoKG5ldyBzaShsLCBjLCBpLnRyZWUsIC1vLCBzLmZyb20gPj0gbyB8fCBzLm9wZW5TdGFydCwgcy50byA8PSBhIHx8IHMub3BlbkVuZCkpO1xuICB9XG4gIHJldHVybiBuO1xufVxubGV0IEFEID0gMCwgTmkgPSBjbGFzcyBueCB7XG4gIC8qKlxuICBAaW50ZXJuYWxcbiAgKi9cbiAgY29uc3RydWN0b3IoZSwgbiwgcikge1xuICAgIHRoaXMuc2V0ID0gZSwgdGhpcy5iYXNlID0gbiwgdGhpcy5tb2RpZmllZCA9IHIsIHRoaXMuaWQgPSBBRCsrO1xuICB9XG4gIC8qKlxuICBEZWZpbmUgYSBuZXcgdGFnLiBJZiBgcGFyZW50YCBpcyBnaXZlbiwgdGhlIHRhZyBpcyB0cmVhdGVkIGFzIGFcbiAgc3ViLXRhZyBvZiB0aGF0IHBhcmVudCwgYW5kXG4gIFtoaWdobGlnaHRlcnNdKCNoaWdobGlnaHQudGFnSGlnaGxpZ2h0ZXIpIHRoYXQgZG9uJ3QgbWVudGlvblxuICB0aGlzIHRhZyB3aWxsIHRyeSB0byBmYWxsIGJhY2sgdG8gdGhlIHBhcmVudCB0YWcgKG9yIGdyYW5kcGFyZW50XG4gIHRhZywgZXRjKS5cbiAgKi9cbiAgc3RhdGljIGRlZmluZShlKSB7XG4gICAgaWYgKGUgIT0gbnVsbCAmJiBlLmJhc2UpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGRlcml2ZSBmcm9tIGEgbW9kaWZpZWQgdGFnXCIpO1xuICAgIGxldCBuID0gbmV3IG54KFtdLCBudWxsLCBbXSk7XG4gICAgaWYgKG4uc2V0LnB1c2gobiksIGUpXG4gICAgICBmb3IgKGxldCByIG9mIGUuc2V0KVxuICAgICAgICBuLnNldC5wdXNoKHIpO1xuICAgIHJldHVybiBuO1xuICB9XG4gIC8qKlxuICBEZWZpbmUgYSB0YWcgX21vZGlmaWVyXywgd2hpY2ggaXMgYSBmdW5jdGlvbiB0aGF0LCBnaXZlbiBhIHRhZyxcbiAgd2lsbCByZXR1cm4gYSB0YWcgdGhhdCBpcyBhIHN1YnRhZyBvZiB0aGUgb3JpZ2luYWwuIEFwcGx5aW5nIHRoZVxuICBzYW1lIG1vZGlmaWVyIHRvIGEgdHdpY2UgdGFnIHdpbGwgcmV0dXJuIHRoZSBzYW1lIHZhbHVlIChgbTEodDEpXG4gID09IG0xKHQxKWApIGFuZCBhcHBseWluZyBtdWx0aXBsZSBtb2RpZmllcnMgd2lsbCwgcmVnYXJkbGVzcyBvclxuICBvcmRlciwgcHJvZHVjZSB0aGUgc2FtZSB0YWcgKGBtMShtMih0MSkpID09IG0yKG0xKHQxKSlgKS5cbiAgXG4gIFdoZW4gbXVsdGlwbGUgbW9kaWZpZXJzIGFyZSBhcHBsaWVkIHRvIGEgZ2l2ZW4gYmFzZSB0YWcsIGVhY2hcbiAgc21hbGxlciBzZXQgb2YgbW9kaWZpZXJzIGlzIHJlZ2lzdGVyZWQgYXMgYSBwYXJlbnQsIHNvIHRoYXQgZm9yXG4gIGV4YW1wbGUgYG0xKG0yKG0zKHQxKSkpYCBpcyBhIHN1YnR5cGUgb2YgYG0xKG0yKHQxKSlgLFxuICBgbTEobTModDEpYCwgYW5kIHNvIG9uLlxuICAqL1xuICBzdGF0aWMgZGVmaW5lTW9kaWZpZXIoKSB7XG4gICAgbGV0IGUgPSBuZXcganUoKTtcbiAgICByZXR1cm4gKG4pID0+IG4ubW9kaWZpZWQuaW5kZXhPZihlKSA+IC0xID8gbiA6IGp1LmdldChuLmJhc2UgfHwgbiwgbi5tb2RpZmllZC5jb25jYXQoZSkuc29ydCgociwgaSkgPT4gci5pZCAtIGkuaWQpKTtcbiAgfVxufSwgUkQgPSAwO1xuY2xhc3MganUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmluc3RhbmNlcyA9IFtdLCB0aGlzLmlkID0gUkQrKztcbiAgfVxuICBzdGF0aWMgZ2V0KGUsIG4pIHtcbiAgICBpZiAoIW4ubGVuZ3RoKVxuICAgICAgcmV0dXJuIGU7XG4gICAgbGV0IHIgPSBuWzBdLmluc3RhbmNlcy5maW5kKChhKSA9PiBhLmJhc2UgPT0gZSAmJiBORChuLCBhLm1vZGlmaWVkKSk7XG4gICAgaWYgKHIpXG4gICAgICByZXR1cm4gcjtcbiAgICBsZXQgaSA9IFtdLCBzID0gbmV3IE5pKGksIGUsIG4pO1xuICAgIGZvciAobGV0IGEgb2YgbilcbiAgICAgIGEuaW5zdGFuY2VzLnB1c2gocyk7XG4gICAgbGV0IG8gPSBERChuKTtcbiAgICBmb3IgKGxldCBhIG9mIGUuc2V0KVxuICAgICAgaWYgKCFhLm1vZGlmaWVkLmxlbmd0aClcbiAgICAgICAgZm9yIChsZXQgbCBvZiBvKVxuICAgICAgICAgIGkucHVzaChqdS5nZXQoYSwgbCkpO1xuICAgIHJldHVybiBzO1xuICB9XG59XG5mdW5jdGlvbiBORCh0LCBlKSB7XG4gIHJldHVybiB0Lmxlbmd0aCA9PSBlLmxlbmd0aCAmJiB0LmV2ZXJ5KChuLCByKSA9PiBuID09IGVbcl0pO1xufVxuZnVuY3Rpb24gREQodCkge1xuICBsZXQgZSA9IFtbXV07XG4gIGZvciAobGV0IG4gPSAwOyBuIDwgdC5sZW5ndGg7IG4rKylcbiAgICBmb3IgKGxldCByID0gMCwgaSA9IGUubGVuZ3RoOyByIDwgaTsgcisrKVxuICAgICAgZS5wdXNoKGVbcl0uY29uY2F0KHRbbl0pKTtcbiAgcmV0dXJuIGUuc29ydCgobiwgcikgPT4gci5sZW5ndGggLSBuLmxlbmd0aCk7XG59XG5mdW5jdGlvbiBpYSh0KSB7XG4gIGxldCBlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGZvciAobGV0IG4gaW4gdCkge1xuICAgIGxldCByID0gdFtuXTtcbiAgICBBcnJheS5pc0FycmF5KHIpIHx8IChyID0gW3JdKTtcbiAgICBmb3IgKGxldCBpIG9mIG4uc3BsaXQoXCIgXCIpKVxuICAgICAgaWYgKGkpIHtcbiAgICAgICAgbGV0IHMgPSBbXSwgbyA9IDIsIGEgPSBpO1xuICAgICAgICBmb3IgKGxldCBkID0gMDsgOyApIHtcbiAgICAgICAgICBpZiAoYSA9PSBcIi4uLlwiICYmIGQgPiAwICYmIGQgKyAzID09IGkubGVuZ3RoKSB7XG4gICAgICAgICAgICBvID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgZiA9IC9eXCIoPzpbXlwiXFxcXF18XFxcXC4pKj9cInxbXlxcLyFdKy8uZXhlYyhhKTtcbiAgICAgICAgICBpZiAoIWYpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgcGF0aDogXCIgKyBpKTtcbiAgICAgICAgICBpZiAocy5wdXNoKGZbMF0gPT0gXCIqXCIgPyBcIlwiIDogZlswXVswXSA9PSAnXCInID8gSlNPTi5wYXJzZShmWzBdKSA6IGZbMF0pLCBkICs9IGZbMF0ubGVuZ3RoLCBkID09IGkubGVuZ3RoKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgbGV0IGggPSBpW2QrK107XG4gICAgICAgICAgaWYgKGQgPT0gaS5sZW5ndGggJiYgaCA9PSBcIiFcIikge1xuICAgICAgICAgICAgbyA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGggIT0gXCIvXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgcGF0aDogXCIgKyBpKTtcbiAgICAgICAgICBhID0gaS5zbGljZShkKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbCA9IHMubGVuZ3RoIC0gMSwgYyA9IHNbbF07XG4gICAgICAgIGlmICghYylcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgcGF0aDogXCIgKyBpKTtcbiAgICAgICAgbGV0IHUgPSBuZXcgQnUociwgbywgbCA+IDAgPyBzLnNsaWNlKDAsIGwpIDogbnVsbCk7XG4gICAgICAgIGVbY10gPSB1LnNvcnQoZVtjXSk7XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIHJ4LmFkZChlKTtcbn1cbmNvbnN0IHJ4ID0gbmV3IFJlKCk7XG5jbGFzcyBCdSB7XG4gIGNvbnN0cnVjdG9yKGUsIG4sIHIsIGkpIHtcbiAgICB0aGlzLnRhZ3MgPSBlLCB0aGlzLm1vZGUgPSBuLCB0aGlzLmNvbnRleHQgPSByLCB0aGlzLm5leHQgPSBpO1xuICB9XG4gIGdldCBvcGFxdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kZSA9PSAwO1xuICB9XG4gIGdldCBpbmhlcml0KCkge1xuICAgIHJldHVybiB0aGlzLm1vZGUgPT0gMTtcbiAgfVxuICBzb3J0KGUpIHtcbiAgICByZXR1cm4gIWUgfHwgZS5kZXB0aCA8IHRoaXMuZGVwdGggPyAodGhpcy5uZXh0ID0gZSwgdGhpcykgOiAoZS5uZXh0ID0gdGhpcy5zb3J0KGUubmV4dCksIGUpO1xuICB9XG4gIGdldCBkZXB0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0ID8gdGhpcy5jb250ZXh0Lmxlbmd0aCA6IDA7XG4gIH1cbn1cbkJ1LmVtcHR5ID0gbmV3IEJ1KFtdLCAyLCBudWxsKTtcbmZ1bmN0aW9uIGl4KHQsIGUpIHtcbiAgbGV0IG4gPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZm9yIChsZXQgcyBvZiB0KVxuICAgIGlmICghQXJyYXkuaXNBcnJheShzLnRhZykpXG4gICAgICBuW3MudGFnLmlkXSA9IHMuY2xhc3M7XG4gICAgZWxzZVxuICAgICAgZm9yIChsZXQgbyBvZiBzLnRhZylcbiAgICAgICAgbltvLmlkXSA9IHMuY2xhc3M7XG4gIGxldCB7IHNjb3BlOiByLCBhbGw6IGkgPSBudWxsIH0gPSBlIHx8IHt9O1xuICByZXR1cm4ge1xuICAgIHN0eWxlOiAocykgPT4ge1xuICAgICAgbGV0IG8gPSBpO1xuICAgICAgZm9yIChsZXQgYSBvZiBzKVxuICAgICAgICBmb3IgKGxldCBsIG9mIGEuc2V0KSB7XG4gICAgICAgICAgbGV0IGMgPSBuW2wuaWRdO1xuICAgICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgICBvID0gbyA/IG8gKyBcIiBcIiArIGMgOiBjO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbztcbiAgICB9LFxuICAgIHNjb3BlOiByXG4gIH07XG59XG5mdW5jdGlvbiBaRCh0LCBlKSB7XG4gIGxldCBuID0gbnVsbDtcbiAgZm9yIChsZXQgciBvZiB0KSB7XG4gICAgbGV0IGkgPSByLnN0eWxlKGUpO1xuICAgIGkgJiYgKG4gPSBuID8gbiArIFwiIFwiICsgaSA6IGkpO1xuICB9XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gVkQodCwgZSwgbiwgciA9IDAsIGkgPSB0Lmxlbmd0aCkge1xuICBsZXQgcyA9IG5ldyBJRChyLCBBcnJheS5pc0FycmF5KGUpID8gZSA6IFtlXSwgbik7XG4gIHMuaGlnaGxpZ2h0UmFuZ2UodC5jdXJzb3IoKSwgciwgaSwgXCJcIiwgcy5oaWdobGlnaHRlcnMpLCBzLmZsdXNoKGkpO1xufVxuY2xhc3MgSUQge1xuICBjb25zdHJ1Y3RvcihlLCBuLCByKSB7XG4gICAgdGhpcy5hdCA9IGUsIHRoaXMuaGlnaGxpZ2h0ZXJzID0gbiwgdGhpcy5zcGFuID0gciwgdGhpcy5jbGFzcyA9IFwiXCI7XG4gIH1cbiAgc3RhcnRTcGFuKGUsIG4pIHtcbiAgICBuICE9IHRoaXMuY2xhc3MgJiYgKHRoaXMuZmx1c2goZSksIGUgPiB0aGlzLmF0ICYmICh0aGlzLmF0ID0gZSksIHRoaXMuY2xhc3MgPSBuKTtcbiAgfVxuICBmbHVzaChlKSB7XG4gICAgZSA+IHRoaXMuYXQgJiYgdGhpcy5jbGFzcyAmJiB0aGlzLnNwYW4odGhpcy5hdCwgZSwgdGhpcy5jbGFzcyk7XG4gIH1cbiAgaGlnaGxpZ2h0UmFuZ2UoZSwgbiwgciwgaSwgcykge1xuICAgIGxldCB7IHR5cGU6IG8sIGZyb206IGEsIHRvOiBsIH0gPSBlO1xuICAgIGlmIChhID49IHIgfHwgbCA8PSBuKVxuICAgICAgcmV0dXJuO1xuICAgIG8uaXNUb3AgJiYgKHMgPSB0aGlzLmhpZ2hsaWdodGVycy5maWx0ZXIoKGgpID0+ICFoLnNjb3BlIHx8IGguc2NvcGUobykpKTtcbiAgICBsZXQgYyA9IGksIHUgPSBXRChlKSB8fCBCdS5lbXB0eSwgZCA9IFpEKHMsIHUudGFncyk7XG4gICAgaWYgKGQgJiYgKGMgJiYgKGMgKz0gXCIgXCIpLCBjICs9IGQsIHUubW9kZSA9PSAxICYmIChpICs9IChpID8gXCIgXCIgOiBcIlwiKSArIGQpKSwgdGhpcy5zdGFydFNwYW4oTWF0aC5tYXgobiwgYSksIGMpLCB1Lm9wYXF1ZSlcbiAgICAgIHJldHVybjtcbiAgICBsZXQgZiA9IGUudHJlZSAmJiBlLnRyZWUucHJvcChSZS5tb3VudGVkKTtcbiAgICBpZiAoZiAmJiBmLm92ZXJsYXkpIHtcbiAgICAgIGxldCBoID0gZS5ub2RlLmVudGVyKGYub3ZlcmxheVswXS5mcm9tICsgYSwgMSksIHAgPSB0aGlzLmhpZ2hsaWdodGVycy5maWx0ZXIoKG0pID0+ICFtLnNjb3BlIHx8IG0uc2NvcGUoZi50cmVlLnR5cGUpKSwgTyA9IGUuZmlyc3RDaGlsZCgpO1xuICAgICAgZm9yIChsZXQgbSA9IDAsIHkgPSBhOyA7IG0rKykge1xuICAgICAgICBsZXQgYiA9IG0gPCBmLm92ZXJsYXkubGVuZ3RoID8gZi5vdmVybGF5W21dIDogbnVsbCwgZyA9IGIgPyBiLmZyb20gKyBhIDogbCwgdiA9IE1hdGgubWF4KG4sIHkpLCBTID0gTWF0aC5taW4ociwgZyk7XG4gICAgICAgIGlmICh2IDwgUyAmJiBPKVxuICAgICAgICAgIGZvciAoOyBlLmZyb20gPCBTICYmICh0aGlzLmhpZ2hsaWdodFJhbmdlKGUsIHYsIFMsIGksIHMpLCB0aGlzLnN0YXJ0U3BhbihNYXRoLm1pbihTLCBlLnRvKSwgYyksICEoZS50byA+PSBnIHx8ICFlLm5leHRTaWJsaW5nKCkpKTsgKVxuICAgICAgICAgICAgO1xuICAgICAgICBpZiAoIWIgfHwgZyA+IHIpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIHkgPSBiLnRvICsgYSwgeSA+IG4gJiYgKHRoaXMuaGlnaGxpZ2h0UmFuZ2UoaC5jdXJzb3IoKSwgTWF0aC5tYXgobiwgYi5mcm9tICsgYSksIE1hdGgubWluKHIsIHkpLCBcIlwiLCBwKSwgdGhpcy5zdGFydFNwYW4oTWF0aC5taW4ociwgeSksIGMpKTtcbiAgICAgIH1cbiAgICAgIE8gJiYgZS5wYXJlbnQoKTtcbiAgICB9IGVsc2UgaWYgKGUuZmlyc3RDaGlsZCgpKSB7XG4gICAgICBmICYmIChpID0gXCJcIik7XG4gICAgICBkb1xuICAgICAgICBpZiAoIShlLnRvIDw9IG4pKSB7XG4gICAgICAgICAgaWYgKGUuZnJvbSA+PSByKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgdGhpcy5oaWdobGlnaHRSYW5nZShlLCBuLCByLCBpLCBzKSwgdGhpcy5zdGFydFNwYW4oTWF0aC5taW4ociwgZS50byksIGMpO1xuICAgICAgICB9XG4gICAgICB3aGlsZSAoZS5uZXh0U2libGluZygpKTtcbiAgICAgIGUucGFyZW50KCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBXRCh0KSB7XG4gIGxldCBlID0gdC50eXBlLnByb3AocngpO1xuICBmb3IgKDsgZSAmJiBlLmNvbnRleHQgJiYgIXQubWF0Y2hDb250ZXh0KGUuY29udGV4dCk7IClcbiAgICBlID0gZS5uZXh0O1xuICByZXR1cm4gZSB8fCBudWxsO1xufVxuY29uc3QgdGUgPSBOaS5kZWZpbmUsIERjID0gdGUoKSwgRGkgPSB0ZSgpLCBNdiA9IHRlKERpKSwgWHYgPSB0ZShEaSksIFppID0gdGUoKSwgWmMgPSB0ZShaaSksIERmID0gdGUoWmkpLCBQciA9IHRlKCksIG1zID0gdGUoUHIpLCBrciA9IHRlKCksIHhyID0gdGUoKSwga3AgPSB0ZSgpLCBTYSA9IHRlKGtwKSwgVmMgPSB0ZSgpLCBQID0ge1xuICAvKipcbiAgQSBjb21tZW50LlxuICAqL1xuICBjb21tZW50OiBEYyxcbiAgLyoqXG4gIEEgbGluZSBbY29tbWVudF0oI2hpZ2hsaWdodC50YWdzLmNvbW1lbnQpLlxuICAqL1xuICBsaW5lQ29tbWVudDogdGUoRGMpLFxuICAvKipcbiAgQSBibG9jayBbY29tbWVudF0oI2hpZ2hsaWdodC50YWdzLmNvbW1lbnQpLlxuICAqL1xuICBibG9ja0NvbW1lbnQ6IHRlKERjKSxcbiAgLyoqXG4gIEEgZG9jdW1lbnRhdGlvbiBbY29tbWVudF0oI2hpZ2hsaWdodC50YWdzLmNvbW1lbnQpLlxuICAqL1xuICBkb2NDb21tZW50OiB0ZShEYyksXG4gIC8qKlxuICBBbnkga2luZCBvZiBpZGVudGlmaWVyLlxuICAqL1xuICBuYW1lOiBEaSxcbiAgLyoqXG4gIFRoZSBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpIG9mIGEgdmFyaWFibGUuXG4gICovXG4gIHZhcmlhYmxlTmFtZTogdGUoRGkpLFxuICAvKipcbiAgQSB0eXBlIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkuXG4gICovXG4gIHR5cGVOYW1lOiBNdixcbiAgLyoqXG4gIEEgdGFnIG5hbWUgKHN1YnRhZyBvZiBbYHR5cGVOYW1lYF0oI2hpZ2hsaWdodC50YWdzLnR5cGVOYW1lKSkuXG4gICovXG4gIHRhZ05hbWU6IHRlKE12KSxcbiAgLyoqXG4gIEEgcHJvcGVydHkgb3IgZmllbGQgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKS5cbiAgKi9cbiAgcHJvcGVydHlOYW1lOiBYdixcbiAgLyoqXG4gIEFuIGF0dHJpYnV0ZSBuYW1lIChzdWJ0YWcgb2YgW2Bwcm9wZXJ0eU5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MucHJvcGVydHlOYW1lKSkuXG4gICovXG4gIGF0dHJpYnV0ZU5hbWU6IHRlKFh2KSxcbiAgLyoqXG4gIFRoZSBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpIG9mIGEgY2xhc3MuXG4gICovXG4gIGNsYXNzTmFtZTogdGUoRGkpLFxuICAvKipcbiAgQSBsYWJlbCBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpLlxuICAqL1xuICBsYWJlbE5hbWU6IHRlKERpKSxcbiAgLyoqXG4gIEEgbmFtZXNwYWNlIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkuXG4gICovXG4gIG5hbWVzcGFjZTogdGUoRGkpLFxuICAvKipcbiAgVGhlIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgb2YgYSBtYWNyby5cbiAgKi9cbiAgbWFjcm9OYW1lOiB0ZShEaSksXG4gIC8qKlxuICBBIGxpdGVyYWwgdmFsdWUuXG4gICovXG4gIGxpdGVyYWw6IFppLFxuICAvKipcbiAgQSBzdHJpbmcgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgKi9cbiAgc3RyaW5nOiBaYyxcbiAgLyoqXG4gIEEgZG9jdW1lbnRhdGlvbiBbc3RyaW5nXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKS5cbiAgKi9cbiAgZG9jU3RyaW5nOiB0ZShaYyksXG4gIC8qKlxuICBBIGNoYXJhY3RlciBsaXRlcmFsIChzdWJ0YWcgb2YgW3N0cmluZ10oI2hpZ2hsaWdodC50YWdzLnN0cmluZykpLlxuICAqL1xuICBjaGFyYWN0ZXI6IHRlKFpjKSxcbiAgLyoqXG4gIEFuIGF0dHJpYnV0ZSB2YWx1ZSAoc3VidGFnIG9mIFtzdHJpbmddKCNoaWdobGlnaHQudGFncy5zdHJpbmcpKS5cbiAgKi9cbiAgYXR0cmlidXRlVmFsdWU6IHRlKFpjKSxcbiAgLyoqXG4gIEEgbnVtYmVyIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICovXG4gIG51bWJlcjogRGYsXG4gIC8qKlxuICBBbiBpbnRlZ2VyIFtudW1iZXJdKCNoaWdobGlnaHQudGFncy5udW1iZXIpIGxpdGVyYWwuXG4gICovXG4gIGludGVnZXI6IHRlKERmKSxcbiAgLyoqXG4gIEEgZmxvYXRpbmctcG9pbnQgW251bWJlcl0oI2hpZ2hsaWdodC50YWdzLm51bWJlcikgbGl0ZXJhbC5cbiAgKi9cbiAgZmxvYXQ6IHRlKERmKSxcbiAgLyoqXG4gIEEgYm9vbGVhbiBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxuICAqL1xuICBib29sOiB0ZShaaSksXG4gIC8qKlxuICBSZWd1bGFyIGV4cHJlc3Npb24gW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgKi9cbiAgcmVnZXhwOiB0ZShaaSksXG4gIC8qKlxuICBBbiBlc2NhcGUgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKSwgZm9yIGV4YW1wbGUgYVxuICBiYWNrc2xhc2ggZXNjYXBlIGluIGEgc3RyaW5nLlxuICAqL1xuICBlc2NhcGU6IHRlKFppKSxcbiAgLyoqXG4gIEEgY29sb3IgW2xpdGVyYWxdKCNoaWdobGlnaHQudGFncy5saXRlcmFsKS5cbiAgKi9cbiAgY29sb3I6IHRlKFppKSxcbiAgLyoqXG4gIEEgVVJMIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICovXG4gIHVybDogdGUoWmkpLFxuICAvKipcbiAgQSBsYW5ndWFnZSBrZXl3b3JkLlxuICAqL1xuICBrZXl3b3JkOiBrcixcbiAgLyoqXG4gIFRoZSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIGZvciB0aGUgc2VsZiBvciB0aGlzXG4gIG9iamVjdC5cbiAgKi9cbiAgc2VsZjogdGUoa3IpLFxuICAvKipcbiAgVGhlIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgZm9yIG51bGwuXG4gICovXG4gIG51bGw6IHRlKGtyKSxcbiAgLyoqXG4gIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSBkZW5vdGluZyBzb21lIGF0b21pYyB2YWx1ZS5cbiAgKi9cbiAgYXRvbTogdGUoa3IpLFxuICAvKipcbiAgQSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIHRoYXQgcmVwcmVzZW50cyBhIHVuaXQuXG4gICovXG4gIHVuaXQ6IHRlKGtyKSxcbiAgLyoqXG4gIEEgbW9kaWZpZXIgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKS5cbiAgKi9cbiAgbW9kaWZpZXI6IHRlKGtyKSxcbiAgLyoqXG4gIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSB0aGF0IGFjdHMgYXMgYW4gb3BlcmF0b3IuXG4gICovXG4gIG9wZXJhdG9yS2V5d29yZDogdGUoa3IpLFxuICAvKipcbiAgQSBjb250cm9sLWZsb3cgcmVsYXRlZCBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpLlxuICAqL1xuICBjb250cm9sS2V5d29yZDogdGUoa3IpLFxuICAvKipcbiAgQSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIHRoYXQgZGVmaW5lcyBzb21ldGhpbmcuXG4gICovXG4gIGRlZmluaXRpb25LZXl3b3JkOiB0ZShrciksXG4gIC8qKlxuICBBIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgcmVsYXRlZCB0byBkZWZpbmluZyBvclxuICBpbnRlcmZhY2luZyB3aXRoIG1vZHVsZXMuXG4gICovXG4gIG1vZHVsZUtleXdvcmQ6IHRlKGtyKSxcbiAgLyoqXG4gIEFuIG9wZXJhdG9yLlxuICAqL1xuICBvcGVyYXRvcjogeHIsXG4gIC8qKlxuICBBbiBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikgdGhhdCBkZXJlZmVyZW5jZXMgc29tZXRoaW5nLlxuICAqL1xuICBkZXJlZk9wZXJhdG9yOiB0ZSh4ciksXG4gIC8qKlxuICBBcml0aG1ldGljLXJlbGF0ZWQgW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAqL1xuICBhcml0aG1ldGljT3BlcmF0b3I6IHRlKHhyKSxcbiAgLyoqXG4gIExvZ2ljYWwgW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAqL1xuICBsb2dpY09wZXJhdG9yOiB0ZSh4ciksXG4gIC8qKlxuICBCaXQgW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAqL1xuICBiaXR3aXNlT3BlcmF0b3I6IHRlKHhyKSxcbiAgLyoqXG4gIENvbXBhcmlzb24gW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAqL1xuICBjb21wYXJlT3BlcmF0b3I6IHRlKHhyKSxcbiAgLyoqXG4gIFtPcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKSB0aGF0IHVwZGF0ZXMgaXRzIG9wZXJhbmQuXG4gICovXG4gIHVwZGF0ZU9wZXJhdG9yOiB0ZSh4ciksXG4gIC8qKlxuICBbT3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikgdGhhdCBkZWZpbmVzIHNvbWV0aGluZy5cbiAgKi9cbiAgZGVmaW5pdGlvbk9wZXJhdG9yOiB0ZSh4ciksXG4gIC8qKlxuICBUeXBlLXJlbGF0ZWQgW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAqL1xuICB0eXBlT3BlcmF0b3I6IHRlKHhyKSxcbiAgLyoqXG4gIENvbnRyb2wtZmxvdyBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICovXG4gIGNvbnRyb2xPcGVyYXRvcjogdGUoeHIpLFxuICAvKipcbiAgUHJvZ3JhbSBvciBtYXJrdXAgcHVuY3R1YXRpb24uXG4gICovXG4gIHB1bmN0dWF0aW9uOiBrcCxcbiAgLyoqXG4gIFtQdW5jdHVhdGlvbl0oI2hpZ2hsaWdodC50YWdzLnB1bmN0dWF0aW9uKSB0aGF0IHNlcGFyYXRlc1xuICB0aGluZ3MuXG4gICovXG4gIHNlcGFyYXRvcjogdGUoa3ApLFxuICAvKipcbiAgQnJhY2tldC1zdHlsZSBbcHVuY3R1YXRpb25dKCNoaWdobGlnaHQudGFncy5wdW5jdHVhdGlvbikuXG4gICovXG4gIGJyYWNrZXQ6IFNhLFxuICAvKipcbiAgQW5nbGUgW2JyYWNrZXRzXSgjaGlnaGxpZ2h0LnRhZ3MuYnJhY2tldCkgKHVzdWFsbHkgYDxgIGFuZCBgPmBcbiAgdG9rZW5zKS5cbiAgKi9cbiAgYW5nbGVCcmFja2V0OiB0ZShTYSksXG4gIC8qKlxuICBTcXVhcmUgW2JyYWNrZXRzXSgjaGlnaGxpZ2h0LnRhZ3MuYnJhY2tldCkgKHVzdWFsbHkgYFtgIGFuZCBgXWBcbiAgdG9rZW5zKS5cbiAgKi9cbiAgc3F1YXJlQnJhY2tldDogdGUoU2EpLFxuICAvKipcbiAgUGFyZW50aGVzZXMgKHVzdWFsbHkgYChgIGFuZCBgKWAgdG9rZW5zKS4gU3VidGFnIG9mXG4gIFticmFja2V0XSgjaGlnaGxpZ2h0LnRhZ3MuYnJhY2tldCkuXG4gICovXG4gIHBhcmVuOiB0ZShTYSksXG4gIC8qKlxuICBCcmFjZXMgKHVzdWFsbHkgYHtgIGFuZCBgfWAgdG9rZW5zKS4gU3VidGFnIG9mXG4gIFticmFja2V0XSgjaGlnaGxpZ2h0LnRhZ3MuYnJhY2tldCkuXG4gICovXG4gIGJyYWNlOiB0ZShTYSksXG4gIC8qKlxuICBDb250ZW50LCBmb3IgZXhhbXBsZSBwbGFpbiB0ZXh0IGluIFhNTCBvciBtYXJrdXAgZG9jdW1lbnRzLlxuICAqL1xuICBjb250ZW50OiBQcixcbiAgLyoqXG4gIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCByZXByZXNlbnRzIGEgaGVhZGluZy5cbiAgKi9cbiAgaGVhZGluZzogbXMsXG4gIC8qKlxuICBBIGxldmVsIDEgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgKi9cbiAgaGVhZGluZzE6IHRlKG1zKSxcbiAgLyoqXG4gIEEgbGV2ZWwgMiBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAqL1xuICBoZWFkaW5nMjogdGUobXMpLFxuICAvKipcbiAgQSBsZXZlbCAzIFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICovXG4gIGhlYWRpbmczOiB0ZShtcyksXG4gIC8qKlxuICBBIGxldmVsIDQgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgKi9cbiAgaGVhZGluZzQ6IHRlKG1zKSxcbiAgLyoqXG4gIEEgbGV2ZWwgNSBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAqL1xuICBoZWFkaW5nNTogdGUobXMpLFxuICAvKipcbiAgQSBsZXZlbCA2IFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICovXG4gIGhlYWRpbmc2OiB0ZShtcyksXG4gIC8qKlxuICBBIHByb3NlIHNlcGFyYXRvciAoc3VjaCBhcyBhIGhvcml6b250YWwgcnVsZSkuXG4gICovXG4gIGNvbnRlbnRTZXBhcmF0b3I6IHRlKFByKSxcbiAgLyoqXG4gIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCByZXByZXNlbnRzIGEgbGlzdC5cbiAgKi9cbiAgbGlzdDogdGUoUHIpLFxuICAvKipcbiAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IHJlcHJlc2VudHMgYSBxdW90ZS5cbiAgKi9cbiAgcXVvdGU6IHRlKFByKSxcbiAgLyoqXG4gIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCBpcyBlbXBoYXNpemVkLlxuICAqL1xuICBlbXBoYXNpczogdGUoUHIpLFxuICAvKipcbiAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IGlzIHN0eWxlZCBzdHJvbmcuXG4gICovXG4gIHN0cm9uZzogdGUoUHIpLFxuICAvKipcbiAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IGlzIHBhcnQgb2YgYSBsaW5rLlxuICAqL1xuICBsaW5rOiB0ZShQciksXG4gIC8qKlxuICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaXMgc3R5bGVkIGFzIGNvZGUgb3JcbiAgbW9ub3NwYWNlLlxuICAqL1xuICBtb25vc3BhY2U6IHRlKFByKSxcbiAgLyoqXG4gIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCBoYXMgYSBzdHJpa2UtdGhyb3VnaFxuICBzdHlsZS5cbiAgKi9cbiAgc3RyaWtldGhyb3VnaDogdGUoUHIpLFxuICAvKipcbiAgSW5zZXJ0ZWQgdGV4dCBpbiBhIGNoYW5nZS10cmFja2luZyBmb3JtYXQuXG4gICovXG4gIGluc2VydGVkOiB0ZSgpLFxuICAvKipcbiAgRGVsZXRlZCB0ZXh0LlxuICAqL1xuICBkZWxldGVkOiB0ZSgpLFxuICAvKipcbiAgQ2hhbmdlZCB0ZXh0LlxuICAqL1xuICBjaGFuZ2VkOiB0ZSgpLFxuICAvKipcbiAgQW4gaW52YWxpZCBvciB1bnN5bnRhY3RpYyBlbGVtZW50LlxuICAqL1xuICBpbnZhbGlkOiB0ZSgpLFxuICAvKipcbiAgTWV0YWRhdGEgb3IgbWV0YS1pbnN0cnVjdGlvbi5cbiAgKi9cbiAgbWV0YTogVmMsXG4gIC8qKlxuICBbTWV0YWRhdGFdKCNoaWdobGlnaHQudGFncy5tZXRhKSB0aGF0IGFwcGxpZXMgdG8gdGhlIGVudGlyZVxuICBkb2N1bWVudC5cbiAgKi9cbiAgZG9jdW1lbnRNZXRhOiB0ZShWYyksXG4gIC8qKlxuICBbTWV0YWRhdGFdKCNoaWdobGlnaHQudGFncy5tZXRhKSB0aGF0IGFubm90YXRlcyBvciBhZGRzXG4gIGF0dHJpYnV0ZXMgdG8gYSBnaXZlbiBzeW50YWN0aWMgZWxlbWVudC5cbiAgKi9cbiAgYW5ub3RhdGlvbjogdGUoVmMpLFxuICAvKipcbiAgUHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBvciBwcmVwcm9jZXNzb3IgZGlyZWN0aXZlLiBTdWJ0YWcgb2ZcbiAgW21ldGFdKCNoaWdobGlnaHQudGFncy5tZXRhKS5cbiAgKi9cbiAgcHJvY2Vzc2luZ0luc3RydWN0aW9uOiB0ZShWYyksXG4gIC8qKlxuICBbTW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB0aGF0IGluZGljYXRlcyB0aGF0IGFcbiAgZ2l2ZW4gZWxlbWVudCBpcyBiZWluZyBkZWZpbmVkLiBFeHBlY3RlZCB0byBiZSB1c2VkIHdpdGggdGhlXG4gIHZhcmlvdXMgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKSB0YWdzLlxuICAqL1xuICBkZWZpbml0aW9uOiBOaS5kZWZpbmVNb2RpZmllcigpLFxuICAvKipcbiAgW01vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdCBpbmRpY2F0ZXMgdGhhdFxuICBzb21ldGhpbmcgaXMgY29uc3RhbnQuIE1vc3RseSBleHBlY3RlZCB0byBiZSB1c2VkIHdpdGhcbiAgW3ZhcmlhYmxlIG5hbWVzXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKS5cbiAgKi9cbiAgY29uc3RhbnQ6IE5pLmRlZmluZU1vZGlmaWVyKCksXG4gIC8qKlxuICBbTW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB1c2VkIHRvIGluZGljYXRlIHRoYXRcbiAgYSBbdmFyaWFibGVdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpIG9yIFtwcm9wZXJ0eVxuICBuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MucHJvcGVydHlOYW1lKSBpcyBiZWluZyBjYWxsZWQgb3IgZGVmaW5lZFxuICBhcyBhIGZ1bmN0aW9uLlxuICAqL1xuICBmdW5jdGlvbjogTmkuZGVmaW5lTW9kaWZpZXIoKSxcbiAgLyoqXG4gIFtNb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHRoYXQgY2FuIGJlIGFwcGxpZWQgdG9cbiAgW25hbWVzXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgdG8gaW5kaWNhdGUgdGhhdCB0aGV5IGJlbG9uZyB0b1xuICB0aGUgbGFuZ3VhZ2UncyBzdGFuZGFyZCBlbnZpcm9ubWVudC5cbiAgKi9cbiAgc3RhbmRhcmQ6IE5pLmRlZmluZU1vZGlmaWVyKCksXG4gIC8qKlxuICBbTW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB0aGF0IGluZGljYXRlcyBhIGdpdmVuXG4gIFtuYW1lc10oI2hpZ2hsaWdodC50YWdzLm5hbWUpIGlzIGxvY2FsIHRvIHNvbWUgc2NvcGUuXG4gICovXG4gIGxvY2FsOiBOaS5kZWZpbmVNb2RpZmllcigpLFxuICAvKipcbiAgQSBnZW5lcmljIHZhcmlhbnQgW21vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdFxuICBjYW4gYmUgdXNlZCB0byB0YWcgbGFuZ3VhZ2Utc3BlY2lmaWMgYWx0ZXJuYXRpdmUgdmFyaWFudHMgb2ZcbiAgc29tZSBjb21tb24gdGFnLiBJdCBpcyByZWNvbW1lbmRlZCBmb3IgdGhlbWVzIHRvIGRlZmluZSBzcGVjaWFsXG4gIGZvcm1zIG9mIGF0IGxlYXN0IHRoZSBbc3RyaW5nXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKSBhbmRcbiAgW3ZhcmlhYmxlIG5hbWVdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpIHRhZ3MsIHNpbmNlIHRob3NlXG4gIGNvbWUgdXAgYSBsb3QuXG4gICovXG4gIHNwZWNpYWw6IE5pLmRlZmluZU1vZGlmaWVyKClcbn07XG5peChbXG4gIHsgdGFnOiBQLmxpbmssIGNsYXNzOiBcInRvay1saW5rXCIgfSxcbiAgeyB0YWc6IFAuaGVhZGluZywgY2xhc3M6IFwidG9rLWhlYWRpbmdcIiB9LFxuICB7IHRhZzogUC5lbXBoYXNpcywgY2xhc3M6IFwidG9rLWVtcGhhc2lzXCIgfSxcbiAgeyB0YWc6IFAuc3Ryb25nLCBjbGFzczogXCJ0b2stc3Ryb25nXCIgfSxcbiAgeyB0YWc6IFAua2V5d29yZCwgY2xhc3M6IFwidG9rLWtleXdvcmRcIiB9LFxuICB7IHRhZzogUC5hdG9tLCBjbGFzczogXCJ0b2stYXRvbVwiIH0sXG4gIHsgdGFnOiBQLmJvb2wsIGNsYXNzOiBcInRvay1ib29sXCIgfSxcbiAgeyB0YWc6IFAudXJsLCBjbGFzczogXCJ0b2stdXJsXCIgfSxcbiAgeyB0YWc6IFAubGFiZWxOYW1lLCBjbGFzczogXCJ0b2stbGFiZWxOYW1lXCIgfSxcbiAgeyB0YWc6IFAuaW5zZXJ0ZWQsIGNsYXNzOiBcInRvay1pbnNlcnRlZFwiIH0sXG4gIHsgdGFnOiBQLmRlbGV0ZWQsIGNsYXNzOiBcInRvay1kZWxldGVkXCIgfSxcbiAgeyB0YWc6IFAubGl0ZXJhbCwgY2xhc3M6IFwidG9rLWxpdGVyYWxcIiB9LFxuICB7IHRhZzogUC5zdHJpbmcsIGNsYXNzOiBcInRvay1zdHJpbmdcIiB9LFxuICB7IHRhZzogUC5udW1iZXIsIGNsYXNzOiBcInRvay1udW1iZXJcIiB9LFxuICB7IHRhZzogW1AucmVnZXhwLCBQLmVzY2FwZSwgUC5zcGVjaWFsKFAuc3RyaW5nKV0sIGNsYXNzOiBcInRvay1zdHJpbmcyXCIgfSxcbiAgeyB0YWc6IFAudmFyaWFibGVOYW1lLCBjbGFzczogXCJ0b2stdmFyaWFibGVOYW1lXCIgfSxcbiAgeyB0YWc6IFAubG9jYWwoUC52YXJpYWJsZU5hbWUpLCBjbGFzczogXCJ0b2stdmFyaWFibGVOYW1lIHRvay1sb2NhbFwiIH0sXG4gIHsgdGFnOiBQLmRlZmluaXRpb24oUC52YXJpYWJsZU5hbWUpLCBjbGFzczogXCJ0b2stdmFyaWFibGVOYW1lIHRvay1kZWZpbml0aW9uXCIgfSxcbiAgeyB0YWc6IFAuc3BlY2lhbChQLnZhcmlhYmxlTmFtZSksIGNsYXNzOiBcInRvay12YXJpYWJsZU5hbWUyXCIgfSxcbiAgeyB0YWc6IFAuZGVmaW5pdGlvbihQLnByb3BlcnR5TmFtZSksIGNsYXNzOiBcInRvay1wcm9wZXJ0eU5hbWUgdG9rLWRlZmluaXRpb25cIiB9LFxuICB7IHRhZzogUC50eXBlTmFtZSwgY2xhc3M6IFwidG9rLXR5cGVOYW1lXCIgfSxcbiAgeyB0YWc6IFAubmFtZXNwYWNlLCBjbGFzczogXCJ0b2stbmFtZXNwYWNlXCIgfSxcbiAgeyB0YWc6IFAuY2xhc3NOYW1lLCBjbGFzczogXCJ0b2stY2xhc3NOYW1lXCIgfSxcbiAgeyB0YWc6IFAubWFjcm9OYW1lLCBjbGFzczogXCJ0b2stbWFjcm9OYW1lXCIgfSxcbiAgeyB0YWc6IFAucHJvcGVydHlOYW1lLCBjbGFzczogXCJ0b2stcHJvcGVydHlOYW1lXCIgfSxcbiAgeyB0YWc6IFAub3BlcmF0b3IsIGNsYXNzOiBcInRvay1vcGVyYXRvclwiIH0sXG4gIHsgdGFnOiBQLmNvbW1lbnQsIGNsYXNzOiBcInRvay1jb21tZW50XCIgfSxcbiAgeyB0YWc6IFAubWV0YSwgY2xhc3M6IFwidG9rLW1ldGFcIiB9LFxuICB7IHRhZzogUC5pbnZhbGlkLCBjbGFzczogXCJ0b2staW52YWxpZFwiIH0sXG4gIHsgdGFnOiBQLnB1bmN0dWF0aW9uLCBjbGFzczogXCJ0b2stcHVuY3R1YXRpb25cIiB9XG5dKTtcbnZhciBaZjtcbmNvbnN0IE9vID0gLyogQF9fUFVSRV9fICovIG5ldyBSZSgpO1xuZnVuY3Rpb24gc3godCkge1xuICByZXR1cm4gdmUuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB0ID8gKGUpID0+IGUuY29uY2F0KHQpIDogdm9pZCAwXG4gIH0pO1xufVxuY29uc3QgZ2cgPSAvKiBAX19QVVJFX18gKi8gbmV3IFJlKCk7XG5jbGFzcyB1ciB7XG4gIC8qKlxuICBDb25zdHJ1Y3QgYSBsYW5ndWFnZSBvYmplY3QuIElmIHlvdSBuZWVkIHRvIGludm9rZSB0aGlzXG4gIGRpcmVjdGx5LCBmaXJzdCBkZWZpbmUgYSBkYXRhIGZhY2V0IHdpdGhcbiAgW2BkZWZpbmVMYW5ndWFnZUZhY2V0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5kZWZpbmVMYW5ndWFnZUZhY2V0KSwgYW5kIHRoZW5cbiAgY29uZmlndXJlIHlvdXIgcGFyc2VyIHRvIFthdHRhY2hdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UubGFuZ3VhZ2VEYXRhUHJvcCkgaXRcbiAgdG8gdGhlIGxhbmd1YWdlJ3Mgb3V0ZXIgc3ludGF4IG5vZGUuXG4gICovXG4gIGNvbnN0cnVjdG9yKGUsIG4sIHIgPSBbXSwgaSA9IFwiXCIpIHtcbiAgICB0aGlzLmRhdGEgPSBlLCB0aGlzLm5hbWUgPSBpLCBZZS5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoXCJ0cmVlXCIpIHx8IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShZZS5wcm90b3R5cGUsIFwidHJlZVwiLCB7IGdldCgpIHtcbiAgICAgIHJldHVybiB1bih0aGlzKTtcbiAgICB9IH0pLCB0aGlzLnBhcnNlciA9IG4sIHRoaXMuZXh0ZW5zaW9uID0gW1xuICAgICAgVW8ub2YodGhpcyksXG4gICAgICBZZS5sYW5ndWFnZURhdGEub2YoKHMsIG8sIGEpID0+IHtcbiAgICAgICAgbGV0IGwgPSBqdihzLCBvLCBhKSwgYyA9IGwudHlwZS5wcm9wKE9vKTtcbiAgICAgICAgaWYgKCFjKVxuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgbGV0IHUgPSBzLmZhY2V0KGMpLCBkID0gbC50eXBlLnByb3AoZ2cpO1xuICAgICAgICBpZiAoZCkge1xuICAgICAgICAgIGxldCBmID0gbC5yZXNvbHZlKG8gLSBsLmZyb20sIGEpO1xuICAgICAgICAgIGZvciAobGV0IGggb2YgZClcbiAgICAgICAgICAgIGlmIChoLnRlc3QoZiwgcykpIHtcbiAgICAgICAgICAgICAgbGV0IHAgPSBzLmZhY2V0KGguZmFjZXQpO1xuICAgICAgICAgICAgICByZXR1cm4gaC50eXBlID09IFwicmVwbGFjZVwiID8gcCA6IHAuY29uY2F0KHUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1O1xuICAgICAgfSlcbiAgICBdLmNvbmNhdChyKTtcbiAgfVxuICAvKipcbiAgUXVlcnkgd2hldGhlciB0aGlzIGxhbmd1YWdlIGlzIGFjdGl2ZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICovXG4gIGlzQWN0aXZlQXQoZSwgbiwgciA9IC0xKSB7XG4gICAgcmV0dXJuIGp2KGUsIG4sIHIpLnR5cGUucHJvcChPbykgPT0gdGhpcy5kYXRhO1xuICB9XG4gIC8qKlxuICBGaW5kIHRoZSBkb2N1bWVudCByZWdpb25zIHRoYXQgd2VyZSBwYXJzZWQgdXNpbmcgdGhpcyBsYW5ndWFnZS5cbiAgVGhlIHJldHVybmVkIHJlZ2lvbnMgd2lsbCBfaW5jbHVkZV8gYW55IG5lc3RlZCBsYW5ndWFnZXMgcm9vdGVkXG4gIGluIHRoaXMgbGFuZ3VhZ2UsIHdoZW4gdGhvc2UgZXhpc3QuXG4gICovXG4gIGZpbmRSZWdpb25zKGUpIHtcbiAgICBsZXQgbiA9IGUuZmFjZXQoVW8pO1xuICAgIGlmICgobiA9PSBudWxsID8gdm9pZCAwIDogbi5kYXRhKSA9PSB0aGlzLmRhdGEpXG4gICAgICByZXR1cm4gW3sgZnJvbTogMCwgdG86IGUuZG9jLmxlbmd0aCB9XTtcbiAgICBpZiAoIW4gfHwgIW4uYWxsb3dzTmVzdGluZylcbiAgICAgIHJldHVybiBbXTtcbiAgICBsZXQgciA9IFtdLCBpID0gKHMsIG8pID0+IHtcbiAgICAgIGlmIChzLnByb3AoT28pID09IHRoaXMuZGF0YSkge1xuICAgICAgICByLnB1c2goeyBmcm9tOiBvLCB0bzogbyArIHMubGVuZ3RoIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgYSA9IHMucHJvcChSZS5tb3VudGVkKTtcbiAgICAgIGlmIChhKSB7XG4gICAgICAgIGlmIChhLnRyZWUucHJvcChPbykgPT0gdGhpcy5kYXRhKSB7XG4gICAgICAgICAgaWYgKGEub3ZlcmxheSlcbiAgICAgICAgICAgIGZvciAobGV0IGwgb2YgYS5vdmVybGF5KVxuICAgICAgICAgICAgICByLnB1c2goeyBmcm9tOiBsLmZyb20gKyBvLCB0bzogbC50byArIG8gfSk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgci5wdXNoKHsgZnJvbTogbywgdG86IG8gKyBzLmxlbmd0aCB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSBpZiAoYS5vdmVybGF5KSB7XG4gICAgICAgICAgbGV0IGwgPSByLmxlbmd0aDtcbiAgICAgICAgICBpZiAoaShhLnRyZWUsIGEub3ZlcmxheVswXS5mcm9tICsgbyksIHIubGVuZ3RoID4gbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChsZXQgbCA9IDA7IGwgPCBzLmNoaWxkcmVuLmxlbmd0aDsgbCsrKSB7XG4gICAgICAgIGxldCBjID0gcy5jaGlsZHJlbltsXTtcbiAgICAgICAgYyBpbnN0YW5jZW9mIGd0ICYmIGkoYywgcy5wb3NpdGlvbnNbbF0gKyBvKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBpKHVuKGUpLCAwKSwgcjtcbiAgfVxuICAvKipcbiAgSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBsYW5ndWFnZSBhbGxvd3MgbmVzdGVkIGxhbmd1YWdlcy4gVGhlXG4gIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmV0dXJucyB0cnVlLlxuICAqL1xuICBnZXQgYWxsb3dzTmVzdGluZygpIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbn1cbnVyLnNldFN0YXRlID0gLyogQF9fUFVSRV9fICovIG90LmRlZmluZSgpO1xuZnVuY3Rpb24ganYodCwgZSwgbikge1xuICBsZXQgciA9IHQuZmFjZXQoVW8pLCBpID0gdW4odCkudG9wTm9kZTtcbiAgaWYgKCFyIHx8IHIuYWxsb3dzTmVzdGluZylcbiAgICBmb3IgKGxldCBzID0gaTsgczsgcyA9IHMuZW50ZXIoZSwgbiwgbHQuRXhjbHVkZUJ1ZmZlcnMpKVxuICAgICAgcy50eXBlLmlzVG9wICYmIChpID0gcyk7XG4gIHJldHVybiBpO1xufVxuY2xhc3MgY3MgZXh0ZW5kcyB1ciB7XG4gIGNvbnN0cnVjdG9yKGUsIG4sIHIpIHtcbiAgICBzdXBlcihlLCBuLCBbXSwgciksIHRoaXMucGFyc2VyID0gbjtcbiAgfVxuICAvKipcbiAgRGVmaW5lIGEgbGFuZ3VhZ2UgZnJvbSBhIHBhcnNlci5cbiAgKi9cbiAgc3RhdGljIGRlZmluZShlKSB7XG4gICAgbGV0IG4gPSBzeChlLmxhbmd1YWdlRGF0YSk7XG4gICAgcmV0dXJuIG5ldyBjcyhuLCBlLnBhcnNlci5jb25maWd1cmUoe1xuICAgICAgcHJvcHM6IFtPby5hZGQoKHIpID0+IHIuaXNUb3AgPyBuIDogdm9pZCAwKV1cbiAgICB9KSwgZS5uYW1lKTtcbiAgfVxuICAvKipcbiAgQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHRoaXMgbGFuZ3VhZ2Ugd2l0aCBhIHJlY29uZmlndXJlZFxuICB2ZXJzaW9uIG9mIGl0cyBwYXJzZXIgYW5kIG9wdGlvbmFsbHkgYSBuZXcgbmFtZS5cbiAgKi9cbiAgY29uZmlndXJlKGUsIG4pIHtcbiAgICByZXR1cm4gbmV3IGNzKHRoaXMuZGF0YSwgdGhpcy5wYXJzZXIuY29uZmlndXJlKGUpLCBuIHx8IHRoaXMubmFtZSk7XG4gIH1cbiAgZ2V0IGFsbG93c05lc3RpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyc2VyLmhhc1dyYXBwZXJzKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVuKHQpIHtcbiAgbGV0IGUgPSB0LmZpZWxkKHVyLnN0YXRlLCAhMSk7XG4gIHJldHVybiBlID8gZS50cmVlIDogZ3QuZW1wdHk7XG59XG5jbGFzcyBNRCB7XG4gIC8qKlxuICBDcmVhdGUgYW4gaW5wdXQgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gZG9jdW1lbnQuXG4gICovXG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLmRvYyA9IGUsIHRoaXMuY3Vyc29yUG9zID0gMCwgdGhpcy5zdHJpbmcgPSBcIlwiLCB0aGlzLmN1cnNvciA9IGUuaXRlcigpO1xuICB9XG4gIGdldCBsZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZG9jLmxlbmd0aDtcbiAgfVxuICBzeW5jVG8oZSkge1xuICAgIHJldHVybiB0aGlzLnN0cmluZyA9IHRoaXMuY3Vyc29yLm5leHQoZSAtIHRoaXMuY3Vyc29yUG9zKS52YWx1ZSwgdGhpcy5jdXJzb3JQb3MgPSBlICsgdGhpcy5zdHJpbmcubGVuZ3RoLCB0aGlzLmN1cnNvclBvcyAtIHRoaXMuc3RyaW5nLmxlbmd0aDtcbiAgfVxuICBjaHVuayhlKSB7XG4gICAgcmV0dXJuIHRoaXMuc3luY1RvKGUpLCB0aGlzLnN0cmluZztcbiAgfVxuICBnZXQgbGluZUNodW5rcygpIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgcmVhZChlLCBuKSB7XG4gICAgbGV0IHIgPSB0aGlzLmN1cnNvclBvcyAtIHRoaXMuc3RyaW5nLmxlbmd0aDtcbiAgICByZXR1cm4gZSA8IHIgfHwgbiA+PSB0aGlzLmN1cnNvclBvcyA/IHRoaXMuZG9jLnNsaWNlU3RyaW5nKGUsIG4pIDogdGhpcy5zdHJpbmcuc2xpY2UoZSAtIHIsIG4gLSByKTtcbiAgfVxufVxubGV0IHdhID0gbnVsbDtcbmNsYXNzIEx1IHtcbiAgY29uc3RydWN0b3IoZSwgbiwgciA9IFtdLCBpLCBzLCBvLCBhLCBsKSB7XG4gICAgdGhpcy5wYXJzZXIgPSBlLCB0aGlzLnN0YXRlID0gbiwgdGhpcy5mcmFnbWVudHMgPSByLCB0aGlzLnRyZWUgPSBpLCB0aGlzLnRyZWVMZW4gPSBzLCB0aGlzLnZpZXdwb3J0ID0gbywgdGhpcy5za2lwcGVkID0gYSwgdGhpcy5zY2hlZHVsZU9uID0gbCwgdGhpcy5wYXJzZSA9IG51bGwsIHRoaXMudGVtcFNraXBwZWQgPSBbXTtcbiAgfVxuICAvKipcbiAgQGludGVybmFsXG4gICovXG4gIHN0YXRpYyBjcmVhdGUoZSwgbiwgcikge1xuICAgIHJldHVybiBuZXcgTHUoZSwgbiwgW10sIGd0LmVtcHR5LCAwLCByLCBbXSwgbnVsbCk7XG4gIH1cbiAgc3RhcnRQYXJzZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZXIuc3RhcnRQYXJzZShuZXcgTUQodGhpcy5zdGF0ZS5kb2MpLCB0aGlzLmZyYWdtZW50cyk7XG4gIH1cbiAgLyoqXG4gIEBpbnRlcm5hbFxuICAqL1xuICB3b3JrKGUsIG4pIHtcbiAgICByZXR1cm4gbiAhPSBudWxsICYmIG4gPj0gdGhpcy5zdGF0ZS5kb2MubGVuZ3RoICYmIChuID0gdm9pZCAwKSwgdGhpcy50cmVlICE9IGd0LmVtcHR5ICYmIHRoaXMuaXNEb25lKG4gPz8gdGhpcy5zdGF0ZS5kb2MubGVuZ3RoKSA/ICh0aGlzLnRha2VUcmVlKCksICEwKSA6IHRoaXMud2l0aENvbnRleHQoKCkgPT4ge1xuICAgICAgdmFyIHI7XG4gICAgICBpZiAodHlwZW9mIGUgPT0gXCJudW1iZXJcIikge1xuICAgICAgICBsZXQgaSA9IERhdGUubm93KCkgKyBlO1xuICAgICAgICBlID0gKCkgPT4gRGF0ZS5ub3coKSA+IGk7XG4gICAgICB9XG4gICAgICBmb3IgKHRoaXMucGFyc2UgfHwgKHRoaXMucGFyc2UgPSB0aGlzLnN0YXJ0UGFyc2UoKSksIG4gIT0gbnVsbCAmJiAodGhpcy5wYXJzZS5zdG9wcGVkQXQgPT0gbnVsbCB8fCB0aGlzLnBhcnNlLnN0b3BwZWRBdCA+IG4pICYmIG4gPCB0aGlzLnN0YXRlLmRvYy5sZW5ndGggJiYgdGhpcy5wYXJzZS5zdG9wQXQobik7IDsgKSB7XG4gICAgICAgIGxldCBpID0gdGhpcy5wYXJzZS5hZHZhbmNlKCk7XG4gICAgICAgIGlmIChpKVxuICAgICAgICAgIGlmICh0aGlzLmZyYWdtZW50cyA9IHRoaXMud2l0aG91dFRlbXBTa2lwcGVkKHNpLmFkZFRyZWUoaSwgdGhpcy5mcmFnbWVudHMsIHRoaXMucGFyc2Uuc3RvcHBlZEF0ICE9IG51bGwpKSwgdGhpcy50cmVlTGVuID0gKHIgPSB0aGlzLnBhcnNlLnN0b3BwZWRBdCkgIT09IG51bGwgJiYgciAhPT0gdm9pZCAwID8gciA6IHRoaXMuc3RhdGUuZG9jLmxlbmd0aCwgdGhpcy50cmVlID0gaSwgdGhpcy5wYXJzZSA9IG51bGwsIHRoaXMudHJlZUxlbiA8IChuID8/IHRoaXMuc3RhdGUuZG9jLmxlbmd0aCkpXG4gICAgICAgICAgICB0aGlzLnBhcnNlID0gdGhpcy5zdGFydFBhcnNlKCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICBpZiAoZSgpKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgQGludGVybmFsXG4gICovXG4gIHRha2VUcmVlKCkge1xuICAgIGxldCBlLCBuO1xuICAgIHRoaXMucGFyc2UgJiYgKGUgPSB0aGlzLnBhcnNlLnBhcnNlZFBvcykgPj0gdGhpcy50cmVlTGVuICYmICgodGhpcy5wYXJzZS5zdG9wcGVkQXQgPT0gbnVsbCB8fCB0aGlzLnBhcnNlLnN0b3BwZWRBdCA+IGUpICYmIHRoaXMucGFyc2Uuc3RvcEF0KGUpLCB0aGlzLndpdGhDb250ZXh0KCgpID0+IHtcbiAgICAgIGZvciAoOyAhKG4gPSB0aGlzLnBhcnNlLmFkdmFuY2UoKSk7IClcbiAgICAgICAgO1xuICAgIH0pLCB0aGlzLnRyZWVMZW4gPSBlLCB0aGlzLnRyZWUgPSBuLCB0aGlzLmZyYWdtZW50cyA9IHRoaXMud2l0aG91dFRlbXBTa2lwcGVkKHNpLmFkZFRyZWUodGhpcy50cmVlLCB0aGlzLmZyYWdtZW50cywgITApKSwgdGhpcy5wYXJzZSA9IG51bGwpO1xuICB9XG4gIHdpdGhDb250ZXh0KGUpIHtcbiAgICBsZXQgbiA9IHdhO1xuICAgIHdhID0gdGhpcztcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGUoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgd2EgPSBuO1xuICAgIH1cbiAgfVxuICB3aXRob3V0VGVtcFNraXBwZWQoZSkge1xuICAgIGZvciAobGV0IG47IG4gPSB0aGlzLnRlbXBTa2lwcGVkLnBvcCgpOyApXG4gICAgICBlID0gQnYoZSwgbi5mcm9tLCBuLnRvKTtcbiAgICByZXR1cm4gZTtcbiAgfVxuICAvKipcbiAgQGludGVybmFsXG4gICovXG4gIGNoYW5nZXMoZSwgbikge1xuICAgIGxldCB7IGZyYWdtZW50czogciwgdHJlZTogaSwgdHJlZUxlbjogcywgdmlld3BvcnQ6IG8sIHNraXBwZWQ6IGEgfSA9IHRoaXM7XG4gICAgaWYgKHRoaXMudGFrZVRyZWUoKSwgIWUuZW1wdHkpIHtcbiAgICAgIGxldCBsID0gW107XG4gICAgICBpZiAoZS5pdGVyQ2hhbmdlZFJhbmdlcygoYywgdSwgZCwgZikgPT4gbC5wdXNoKHsgZnJvbUE6IGMsIHRvQTogdSwgZnJvbUI6IGQsIHRvQjogZiB9KSksIHIgPSBzaS5hcHBseUNoYW5nZXMociwgbCksIGkgPSBndC5lbXB0eSwgcyA9IDAsIG8gPSB7IGZyb206IGUubWFwUG9zKG8uZnJvbSwgLTEpLCB0bzogZS5tYXBQb3Moby50bywgMSkgfSwgdGhpcy5za2lwcGVkLmxlbmd0aCkge1xuICAgICAgICBhID0gW107XG4gICAgICAgIGZvciAobGV0IGMgb2YgdGhpcy5za2lwcGVkKSB7XG4gICAgICAgICAgbGV0IHUgPSBlLm1hcFBvcyhjLmZyb20sIDEpLCBkID0gZS5tYXBQb3MoYy50bywgLTEpO1xuICAgICAgICAgIHUgPCBkICYmIGEucHVzaCh7IGZyb206IHUsIHRvOiBkIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgTHUodGhpcy5wYXJzZXIsIG4sIHIsIGksIHMsIG8sIGEsIHRoaXMuc2NoZWR1bGVPbik7XG4gIH1cbiAgLyoqXG4gIEBpbnRlcm5hbFxuICAqL1xuICB1cGRhdGVWaWV3cG9ydChlKSB7XG4gICAgaWYgKHRoaXMudmlld3BvcnQuZnJvbSA9PSBlLmZyb20gJiYgdGhpcy52aWV3cG9ydC50byA9PSBlLnRvKVxuICAgICAgcmV0dXJuICExO1xuICAgIHRoaXMudmlld3BvcnQgPSBlO1xuICAgIGxldCBuID0gdGhpcy5za2lwcGVkLmxlbmd0aDtcbiAgICBmb3IgKGxldCByID0gMDsgciA8IHRoaXMuc2tpcHBlZC5sZW5ndGg7IHIrKykge1xuICAgICAgbGV0IHsgZnJvbTogaSwgdG86IHMgfSA9IHRoaXMuc2tpcHBlZFtyXTtcbiAgICAgIGkgPCBlLnRvICYmIHMgPiBlLmZyb20gJiYgKHRoaXMuZnJhZ21lbnRzID0gQnYodGhpcy5mcmFnbWVudHMsIGksIHMpLCB0aGlzLnNraXBwZWQuc3BsaWNlKHItLSwgMSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5za2lwcGVkLmxlbmd0aCA+PSBuID8gITEgOiAodGhpcy5yZXNldCgpLCAhMCk7XG4gIH1cbiAgLyoqXG4gIEBpbnRlcm5hbFxuICAqL1xuICByZXNldCgpIHtcbiAgICB0aGlzLnBhcnNlICYmICh0aGlzLnRha2VUcmVlKCksIHRoaXMucGFyc2UgPSBudWxsKTtcbiAgfVxuICAvKipcbiAgTm90aWZ5IHRoZSBwYXJzZSBzY2hlZHVsZXIgdGhhdCB0aGUgZ2l2ZW4gcmVnaW9uIHdhcyBza2lwcGVkXG4gIGJlY2F1c2UgaXQgd2Fzbid0IGluIHZpZXcsIGFuZCB0aGUgcGFyc2Ugc2hvdWxkIGJlIHJlc3RhcnRlZFxuICB3aGVuIGl0IGNvbWVzIGludG8gdmlldy5cbiAgKi9cbiAgc2tpcFVudGlsSW5WaWV3KGUsIG4pIHtcbiAgICB0aGlzLnNraXBwZWQucHVzaCh7IGZyb206IGUsIHRvOiBuIH0pO1xuICB9XG4gIC8qKlxuICBSZXR1cm5zIGEgcGFyc2VyIGludGVuZGVkIHRvIGJlIHVzZWQgYXMgcGxhY2Vob2xkZXIgd2hlblxuICBhc3luY2hyb25vdXNseSBsb2FkaW5nIGEgbmVzdGVkIHBhcnNlci4gSXQnbGwgc2tpcCBpdHMgaW5wdXQgYW5kXG4gIG1hcmsgaXQgYXMgbm90LXJlYWxseS1wYXJzZWQsIHNvIHRoYXQgdGhlIG5leHQgdXBkYXRlIHdpbGwgcGFyc2VcbiAgaXQgYWdhaW4uXG4gIFxuICBXaGVuIGB1bnRpbGAgaXMgZ2l2ZW4sIGEgcmVwYXJzZSB3aWxsIGJlIHNjaGVkdWxlZCB3aGVuIHRoYXRcbiAgcHJvbWlzZSByZXNvbHZlcy5cbiAgKi9cbiAgc3RhdGljIGdldFNraXBwaW5nUGFyc2VyKGUpIHtcbiAgICByZXR1cm4gbmV3IGNsYXNzIGV4dGVuZHMgdHgge1xuICAgICAgY3JlYXRlUGFyc2UobiwgciwgaSkge1xuICAgICAgICBsZXQgcyA9IGlbMF0uZnJvbSwgbyA9IGlbaS5sZW5ndGggLSAxXS50bztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXJzZWRQb3M6IHMsXG4gICAgICAgICAgYWR2YW5jZSgpIHtcbiAgICAgICAgICAgIGxldCBsID0gd2E7XG4gICAgICAgICAgICBpZiAobCkge1xuICAgICAgICAgICAgICBmb3IgKGxldCBjIG9mIGkpXG4gICAgICAgICAgICAgICAgbC50ZW1wU2tpcHBlZC5wdXNoKGMpO1xuICAgICAgICAgICAgICBlICYmIChsLnNjaGVkdWxlT24gPSBsLnNjaGVkdWxlT24gPyBQcm9taXNlLmFsbChbbC5zY2hlZHVsZU9uLCBlXSkgOiBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlZFBvcyA9IG8sIG5ldyBndChPbi5ub25lLCBbXSwgW10sIG8gLSBzKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHN0b3BwZWRBdDogbnVsbCxcbiAgICAgICAgICBzdG9wQXQoKSB7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0oKTtcbiAgfVxuICAvKipcbiAgQGludGVybmFsXG4gICovXG4gIGlzRG9uZShlKSB7XG4gICAgZSA9IE1hdGgubWluKGUsIHRoaXMuc3RhdGUuZG9jLmxlbmd0aCk7XG4gICAgbGV0IG4gPSB0aGlzLmZyYWdtZW50cztcbiAgICByZXR1cm4gdGhpcy50cmVlTGVuID49IGUgJiYgbi5sZW5ndGggJiYgblswXS5mcm9tID09IDAgJiYgblswXS50byA+PSBlO1xuICB9XG4gIC8qKlxuICBHZXQgdGhlIGNvbnRleHQgZm9yIHRoZSBjdXJyZW50IHBhcnNlLCBvciBgbnVsbGAgaWYgbm8gZWRpdG9yXG4gIHBhcnNlIGlzIGluIHByb2dyZXNzLlxuICAqL1xuICBzdGF0aWMgZ2V0KCkge1xuICAgIHJldHVybiB3YTtcbiAgfVxufVxuZnVuY3Rpb24gQnYodCwgZSwgbikge1xuICByZXR1cm4gc2kuYXBwbHlDaGFuZ2VzKHQsIFt7IGZyb21BOiBlLCB0b0E6IG4sIGZyb21COiBlLCB0b0I6IG4gfV0pO1xufVxuY2xhc3MgTG8ge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5jb250ZXh0ID0gZSwgdGhpcy50cmVlID0gZS50cmVlO1xuICB9XG4gIGFwcGx5KGUpIHtcbiAgICBpZiAoIWUuZG9jQ2hhbmdlZCAmJiB0aGlzLnRyZWUgPT0gdGhpcy5jb250ZXh0LnRyZWUpXG4gICAgICByZXR1cm4gdGhpcztcbiAgICBsZXQgbiA9IHRoaXMuY29udGV4dC5jaGFuZ2VzKGUuY2hhbmdlcywgZS5zdGF0ZSksIHIgPSB0aGlzLmNvbnRleHQudHJlZUxlbiA9PSBlLnN0YXJ0U3RhdGUuZG9jLmxlbmd0aCA/IHZvaWQgMCA6IE1hdGgubWF4KGUuY2hhbmdlcy5tYXBQb3ModGhpcy5jb250ZXh0LnRyZWVMZW4pLCBuLnZpZXdwb3J0LnRvKTtcbiAgICByZXR1cm4gbi53b3JrKDIwLCByKSB8fCBuLnRha2VUcmVlKCksIG5ldyBMbyhuKTtcbiAgfVxuICBzdGF0aWMgaW5pdChlKSB7XG4gICAgbGV0IG4gPSBNYXRoLm1pbigzZTMsIGUuZG9jLmxlbmd0aCksIHIgPSBMdS5jcmVhdGUoZS5mYWNldChVbykucGFyc2VyLCBlLCB7IGZyb206IDAsIHRvOiBuIH0pO1xuICAgIHJldHVybiByLndvcmsoMjAsIG4pIHx8IHIudGFrZVRyZWUoKSwgbmV3IExvKHIpO1xuICB9XG59XG51ci5zdGF0ZSA9IC8qIEBfX1BVUkVfXyAqLyB5ci5kZWZpbmUoe1xuICBjcmVhdGU6IExvLmluaXQsXG4gIHVwZGF0ZSh0LCBlKSB7XG4gICAgZm9yIChsZXQgbiBvZiBlLmVmZmVjdHMpXG4gICAgICBpZiAobi5pcyh1ci5zZXRTdGF0ZSkpXG4gICAgICAgIHJldHVybiBuLnZhbHVlO1xuICAgIHJldHVybiBlLnN0YXJ0U3RhdGUuZmFjZXQoVW8pICE9IGUuc3RhdGUuZmFjZXQoVW8pID8gTG8uaW5pdChlLnN0YXRlKSA6IHQuYXBwbHkoZSk7XG4gIH1cbn0pO1xubGV0IG94ID0gKHQpID0+IHtcbiAgbGV0IGUgPSBzZXRUaW1lb3V0KFxuICAgICgpID0+IHQoKSxcbiAgICA1MDBcbiAgICAvKiBXb3JrLk1heFBhdXNlICovXG4gICk7XG4gIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQoZSk7XG59O1xudHlwZW9mIHJlcXVlc3RJZGxlQ2FsbGJhY2sgPCBcInVcIiAmJiAob3ggPSAodCkgPT4ge1xuICBsZXQgZSA9IC0xLCBuID0gc2V0VGltZW91dChcbiAgICAoKSA9PiB7XG4gICAgICBlID0gcmVxdWVzdElkbGVDYWxsYmFjayh0LCB7XG4gICAgICAgIHRpbWVvdXQ6IDQwMFxuICAgICAgICAvKiBXb3JrLk1pblBhdXNlICovXG4gICAgICB9KTtcbiAgICB9LFxuICAgIDEwMFxuICAgIC8qIFdvcmsuTWluUGF1c2UgKi9cbiAgKTtcbiAgcmV0dXJuICgpID0+IGUgPCAwID8gY2xlYXJUaW1lb3V0KG4pIDogY2FuY2VsSWRsZUNhbGxiYWNrKGUpO1xufSk7XG5jb25zdCBWZiA9IHR5cGVvZiBuYXZpZ2F0b3IgPCBcInVcIiAmJiAoISgoWmYgPSBuYXZpZ2F0b3Iuc2NoZWR1bGluZykgPT09IG51bGwgfHwgWmYgPT09IHZvaWQgMCkgJiYgWmYuaXNJbnB1dFBlbmRpbmcpID8gKCkgPT4gbmF2aWdhdG9yLnNjaGVkdWxpbmcuaXNJbnB1dFBlbmRpbmcoKSA6IG51bGwsIFhEID0gLyogQF9fUFVSRV9fICovIHJyLmZyb21DbGFzcyhjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLnZpZXcgPSBlLCB0aGlzLndvcmtpbmcgPSBudWxsLCB0aGlzLndvcmtTY2hlZHVsZWQgPSAwLCB0aGlzLmNodW5rRW5kID0gLTEsIHRoaXMuY2h1bmtCdWRnZXQgPSAtMSwgdGhpcy53b3JrID0gdGhpcy53b3JrLmJpbmQodGhpcyksIHRoaXMuc2NoZWR1bGVXb3JrKCk7XG4gIH1cbiAgdXBkYXRlKGUpIHtcbiAgICBsZXQgbiA9IHRoaXMudmlldy5zdGF0ZS5maWVsZCh1ci5zdGF0ZSkuY29udGV4dDtcbiAgICAobi51cGRhdGVWaWV3cG9ydChlLnZpZXcudmlld3BvcnQpIHx8IHRoaXMudmlldy52aWV3cG9ydC50byA+IG4udHJlZUxlbikgJiYgdGhpcy5zY2hlZHVsZVdvcmsoKSwgKGUuZG9jQ2hhbmdlZCB8fCBlLnNlbGVjdGlvblNldCkgJiYgKHRoaXMudmlldy5oYXNGb2N1cyAmJiAodGhpcy5jaHVua0J1ZGdldCArPSA1MCksIHRoaXMuc2NoZWR1bGVXb3JrKCkpLCB0aGlzLmNoZWNrQXN5bmNTY2hlZHVsZShuKTtcbiAgfVxuICBzY2hlZHVsZVdvcmsoKSB7XG4gICAgaWYgKHRoaXMud29ya2luZylcbiAgICAgIHJldHVybjtcbiAgICBsZXQgeyBzdGF0ZTogZSB9ID0gdGhpcy52aWV3LCBuID0gZS5maWVsZCh1ci5zdGF0ZSk7XG4gICAgKG4udHJlZSAhPSBuLmNvbnRleHQudHJlZSB8fCAhbi5jb250ZXh0LmlzRG9uZShlLmRvYy5sZW5ndGgpKSAmJiAodGhpcy53b3JraW5nID0gb3godGhpcy53b3JrKSk7XG4gIH1cbiAgd29yayhlKSB7XG4gICAgdGhpcy53b3JraW5nID0gbnVsbDtcbiAgICBsZXQgbiA9IERhdGUubm93KCk7XG4gICAgaWYgKHRoaXMuY2h1bmtFbmQgPCBuICYmICh0aGlzLmNodW5rRW5kIDwgMCB8fCB0aGlzLnZpZXcuaGFzRm9jdXMpICYmICh0aGlzLmNodW5rRW5kID0gbiArIDNlNCwgdGhpcy5jaHVua0J1ZGdldCA9IDNlMyksIHRoaXMuY2h1bmtCdWRnZXQgPD0gMClcbiAgICAgIHJldHVybjtcbiAgICBsZXQgeyBzdGF0ZTogciwgdmlld3BvcnQ6IHsgdG86IGkgfSB9ID0gdGhpcy52aWV3LCBzID0gci5maWVsZCh1ci5zdGF0ZSk7XG4gICAgaWYgKHMudHJlZSA9PSBzLmNvbnRleHQudHJlZSAmJiBzLmNvbnRleHQuaXNEb25lKFxuICAgICAgaSArIDFlNVxuICAgICAgLyogV29yay5NYXhQYXJzZUFoZWFkICovXG4gICAgKSlcbiAgICAgIHJldHVybjtcbiAgICBsZXQgbyA9IERhdGUubm93KCkgKyBNYXRoLm1pbih0aGlzLmNodW5rQnVkZ2V0LCAxMDAsIGUgJiYgIVZmID8gTWF0aC5tYXgoMjUsIGUudGltZVJlbWFpbmluZygpIC0gNSkgOiAxZTkpLCBhID0gcy5jb250ZXh0LnRyZWVMZW4gPCBpICYmIHIuZG9jLmxlbmd0aCA+IGkgKyAxZTMsIGwgPSBzLmNvbnRleHQud29yaygoKSA9PiBWZiAmJiBWZigpIHx8IERhdGUubm93KCkgPiBvLCBpICsgKGEgPyAwIDogMWU1KSk7XG4gICAgdGhpcy5jaHVua0J1ZGdldCAtPSBEYXRlLm5vdygpIC0gbiwgKGwgfHwgdGhpcy5jaHVua0J1ZGdldCA8PSAwKSAmJiAocy5jb250ZXh0LnRha2VUcmVlKCksIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHVyLnNldFN0YXRlLm9mKG5ldyBMbyhzLmNvbnRleHQpKSB9KSksIHRoaXMuY2h1bmtCdWRnZXQgPiAwICYmICEobCAmJiAhYSkgJiYgdGhpcy5zY2hlZHVsZVdvcmsoKSwgdGhpcy5jaGVja0FzeW5jU2NoZWR1bGUocy5jb250ZXh0KTtcbiAgfVxuICBjaGVja0FzeW5jU2NoZWR1bGUoZSkge1xuICAgIGUuc2NoZWR1bGVPbiAmJiAodGhpcy53b3JrU2NoZWR1bGVkKyssIGUuc2NoZWR1bGVPbi50aGVuKCgpID0+IHRoaXMuc2NoZWR1bGVXb3JrKCkpLmNhdGNoKChuKSA9PiBocih0aGlzLnZpZXcuc3RhdGUsIG4pKS50aGVuKCgpID0+IHRoaXMud29ya1NjaGVkdWxlZC0tKSwgZS5zY2hlZHVsZU9uID0gbnVsbCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLndvcmtpbmcgJiYgdGhpcy53b3JraW5nKCk7XG4gIH1cbiAgaXNXb3JraW5nKCkge1xuICAgIHJldHVybiAhISh0aGlzLndvcmtpbmcgfHwgdGhpcy53b3JrU2NoZWR1bGVkID4gMCk7XG4gIH1cbn0sIHtcbiAgZXZlbnRIYW5kbGVyczogeyBmb2N1cygpIHtcbiAgICB0aGlzLnNjaGVkdWxlV29yaygpO1xuICB9IH1cbn0pLCBVbyA9IC8qIEBfX1BVUkVfXyAqLyB2ZS5kZWZpbmUoe1xuICBjb21iaW5lKHQpIHtcbiAgICByZXR1cm4gdC5sZW5ndGggPyB0WzBdIDogbnVsbDtcbiAgfSxcbiAgZW5hYmxlczogKHQpID0+IFtcbiAgICB1ci5zdGF0ZSxcbiAgICBYRCxcbiAgICBTZS5jb250ZW50QXR0cmlidXRlcy5jb21wdXRlKFt0XSwgKGUpID0+IHtcbiAgICAgIGxldCBuID0gZS5mYWNldCh0KTtcbiAgICAgIHJldHVybiBuICYmIG4ubmFtZSA/IHsgXCJkYXRhLWxhbmd1YWdlXCI6IG4ubmFtZSB9IDoge307XG4gICAgfSlcbiAgXVxufSk7XG5jbGFzcyBHbCB7XG4gIC8qKlxuICBDcmVhdGUgYSBsYW5ndWFnZSBzdXBwb3J0IG9iamVjdC5cbiAgKi9cbiAgY29uc3RydWN0b3IoZSwgbiA9IFtdKSB7XG4gICAgdGhpcy5sYW5ndWFnZSA9IGUsIHRoaXMuc3VwcG9ydCA9IG4sIHRoaXMuZXh0ZW5zaW9uID0gW2UsIG5dO1xuICB9XG59XG5jb25zdCBqRCA9IC8qIEBfX1BVUkVfXyAqLyB2ZS5kZWZpbmUoKSwgemQgPSAvKiBAX19QVVJFX18gKi8gdmUuZGVmaW5lKHtcbiAgY29tYmluZTogKHQpID0+IHtcbiAgICBpZiAoIXQubGVuZ3RoKVxuICAgICAgcmV0dXJuIFwiICBcIjtcbiAgICBsZXQgZSA9IHRbMF07XG4gICAgaWYgKCFlIHx8IC9cXFMvLnRlc3QoZSkgfHwgQXJyYXkuZnJvbShlKS5zb21lKChuKSA9PiBuICE9IGVbMF0pKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbmRlbnQgdW5pdDogXCIgKyBKU09OLnN0cmluZ2lmeSh0WzBdKSk7XG4gICAgcmV0dXJuIGU7XG4gIH1cbn0pO1xuZnVuY3Rpb24gYXgodCkge1xuICBsZXQgZSA9IHQuZmFjZXQoemQpO1xuICByZXR1cm4gZS5jaGFyQ29kZUF0KDApID09IDkgPyB0LnRhYlNpemUgKiBlLmxlbmd0aCA6IGUubGVuZ3RoO1xufVxuZnVuY3Rpb24gbHgodCwgZSkge1xuICBsZXQgbiA9IFwiXCIsIHIgPSB0LnRhYlNpemUsIGkgPSB0LmZhY2V0KHpkKVswXTtcbiAgaWYgKGkgPT0gXCJcdFwiKSB7XG4gICAgZm9yICg7IGUgPj0gcjsgKVxuICAgICAgbiArPSBcIlx0XCIsIGUgLT0gcjtcbiAgICBpID0gXCIgXCI7XG4gIH1cbiAgZm9yIChsZXQgcyA9IDA7IHMgPCBlOyBzKyspXG4gICAgbiArPSBpO1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIEJEKHQsIGUpIHtcbiAgdCBpbnN0YW5jZW9mIFllICYmICh0ID0gbmV3IGN4KHQpKTtcbiAgZm9yIChsZXQgciBvZiB0LnN0YXRlLmZhY2V0KGpEKSkge1xuICAgIGxldCBpID0gcih0LCBlKTtcbiAgICBpZiAoaSAhPT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIGk7XG4gIH1cbiAgbGV0IG4gPSB1bih0LnN0YXRlKTtcbiAgcmV0dXJuIG4ubGVuZ3RoID49IGUgPyBMRCh0LCBuLCBlKSA6IG51bGw7XG59XG5jbGFzcyBjeCB7XG4gIC8qKlxuICBDcmVhdGUgYW4gaW5kZW50IGNvbnRleHQuXG4gICovXG4gIGNvbnN0cnVjdG9yKGUsIG4gPSB7fSkge1xuICAgIHRoaXMuc3RhdGUgPSBlLCB0aGlzLm9wdGlvbnMgPSBuLCB0aGlzLnVuaXQgPSBheChlKTtcbiAgfVxuICAvKipcbiAgR2V0IGEgZGVzY3JpcHRpb24gb2YgdGhlIGxpbmUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLCB0YWtpbmdcbiAgW3NpbXVsYXRlZCBsaW5lXG4gIGJyZWFrc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5JbmRlbnRDb250ZXh0LmNvbnN0cnVjdG9yXm9wdGlvbnMuc2ltdWxhdGVCcmVhaylcbiAgaW50byBhY2NvdW50LiBJZiB0aGVyZSBpcyBzdWNoIGEgYnJlYWsgYXQgYHBvc2AsIHRoZSBgYmlhc2BcbiAgYXJndW1lbnQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwYXJ0IG9mIHRoZSBsaW5lIGxpbmUgYmVmb3JlIG9yXG4gIGFmdGVyIHRoZSBicmVhayBpcyB1c2VkLlxuICAqL1xuICBsaW5lQXQoZSwgbiA9IDEpIHtcbiAgICBsZXQgciA9IHRoaXMuc3RhdGUuZG9jLmxpbmVBdChlKSwgeyBzaW11bGF0ZUJyZWFrOiBpLCBzaW11bGF0ZURvdWJsZUJyZWFrOiBzIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgcmV0dXJuIGkgIT0gbnVsbCAmJiBpID49IHIuZnJvbSAmJiBpIDw9IHIudG8gPyBzICYmIGkgPT0gZSA/IHsgdGV4dDogXCJcIiwgZnJvbTogZSB9IDogKG4gPCAwID8gaSA8IGUgOiBpIDw9IGUpID8geyB0ZXh0OiByLnRleHQuc2xpY2UoaSAtIHIuZnJvbSksIGZyb206IGkgfSA6IHsgdGV4dDogci50ZXh0LnNsaWNlKDAsIGkgLSByLmZyb20pLCBmcm9tOiByLmZyb20gfSA6IHI7XG4gIH1cbiAgLyoqXG4gIEdldCB0aGUgdGV4dCBkaXJlY3RseSBhZnRlciBgcG9zYCwgZWl0aGVyIHRoZSBlbnRpcmUgbGluZVxuICBvciB0aGUgbmV4dCAxMDAgY2hhcmFjdGVycywgd2hpY2hldmVyIGlzIHNob3J0ZXIuXG4gICovXG4gIHRleHRBZnRlclBvcyhlLCBuID0gMSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMuc2ltdWxhdGVEb3VibGVCcmVhayAmJiBlID09IHRoaXMub3B0aW9ucy5zaW11bGF0ZUJyZWFrKVxuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgbGV0IHsgdGV4dDogciwgZnJvbTogaSB9ID0gdGhpcy5saW5lQXQoZSwgbik7XG4gICAgcmV0dXJuIHIuc2xpY2UoZSAtIGksIE1hdGgubWluKHIubGVuZ3RoLCBlICsgMTAwIC0gaSkpO1xuICB9XG4gIC8qKlxuICBGaW5kIHRoZSBjb2x1bW4gZm9yIHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgKi9cbiAgY29sdW1uKGUsIG4gPSAxKSB7XG4gICAgbGV0IHsgdGV4dDogciwgZnJvbTogaSB9ID0gdGhpcy5saW5lQXQoZSwgbiksIHMgPSB0aGlzLmNvdW50Q29sdW1uKHIsIGUgLSBpKSwgbyA9IHRoaXMub3B0aW9ucy5vdmVycmlkZUluZGVudGF0aW9uID8gdGhpcy5vcHRpb25zLm92ZXJyaWRlSW5kZW50YXRpb24oaSkgOiAtMTtcbiAgICByZXR1cm4gbyA+IC0xICYmIChzICs9IG8gLSB0aGlzLmNvdW50Q29sdW1uKHIsIHIuc2VhcmNoKC9cXFN8JC8pKSksIHM7XG4gIH1cbiAgLyoqXG4gIEZpbmQgdGhlIGNvbHVtbiBwb3NpdGlvbiAodGFraW5nIHRhYnMgaW50byBhY2NvdW50KSBvZiB0aGUgZ2l2ZW5cbiAgcG9zaXRpb24gaW4gdGhlIGdpdmVuIHN0cmluZy5cbiAgKi9cbiAgY291bnRDb2x1bW4oZSwgbiA9IGUubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGlnKGUsIHRoaXMuc3RhdGUudGFiU2l6ZSwgbik7XG4gIH1cbiAgLyoqXG4gIEZpbmQgdGhlIGluZGVudGF0aW9uIGNvbHVtbiBvZiB0aGUgbGluZSBhdCB0aGUgZ2l2ZW4gcG9pbnQuXG4gICovXG4gIGxpbmVJbmRlbnQoZSwgbiA9IDEpIHtcbiAgICBsZXQgeyB0ZXh0OiByLCBmcm9tOiBpIH0gPSB0aGlzLmxpbmVBdChlLCBuKSwgcyA9IHRoaXMub3B0aW9ucy5vdmVycmlkZUluZGVudGF0aW9uO1xuICAgIGlmIChzKSB7XG4gICAgICBsZXQgbyA9IHMoaSk7XG4gICAgICBpZiAobyA+IC0xKVxuICAgICAgICByZXR1cm4gbztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY291bnRDb2x1bW4ociwgci5zZWFyY2goL1xcU3wkLykpO1xuICB9XG4gIC8qKlxuICBSZXR1cm5zIHRoZSBbc2ltdWxhdGVkIGxpbmVcbiAgYnJlYWtdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuSW5kZW50Q29udGV4dC5jb25zdHJ1Y3Rvcl5vcHRpb25zLnNpbXVsYXRlQnJlYWspXG4gIGZvciB0aGlzIGNvbnRleHQsIGlmIGFueS5cbiAgKi9cbiAgZ2V0IHNpbXVsYXRlZEJyZWFrKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc2ltdWxhdGVCcmVhayB8fCBudWxsO1xuICB9XG59XG5jb25zdCBzYSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgUmUoKTtcbmZ1bmN0aW9uIExEKHQsIGUsIG4pIHtcbiAgbGV0IHIgPSBlLnJlc29sdmVTdGFjayhuKSwgaSA9IHIubm9kZS5lbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZShuKTtcbiAgaWYgKGkgIT0gci5ub2RlKSB7XG4gICAgbGV0IHMgPSBbXTtcbiAgICBmb3IgKGxldCBvID0gaTsgbyAhPSByLm5vZGU7IG8gPSBvLnBhcmVudClcbiAgICAgIHMucHVzaChvKTtcbiAgICBmb3IgKGxldCBvID0gcy5sZW5ndGggLSAxOyBvID49IDA7IG8tLSlcbiAgICAgIHIgPSB7IG5vZGU6IHNbb10sIG5leHQ6IHIgfTtcbiAgfVxuICByZXR1cm4gdXgociwgdCwgbik7XG59XG5mdW5jdGlvbiB1eCh0LCBlLCBuKSB7XG4gIGZvciAobGV0IHIgPSB0OyByOyByID0gci5uZXh0KSB7XG4gICAgbGV0IGkgPSBxRChyLm5vZGUpO1xuICAgIGlmIChpKVxuICAgICAgcmV0dXJuIGkobWcuY3JlYXRlKGUsIG4sIHIpKTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIFVEKHQpIHtcbiAgcmV0dXJuIHQucG9zID09IHQub3B0aW9ucy5zaW11bGF0ZUJyZWFrICYmIHQub3B0aW9ucy5zaW11bGF0ZURvdWJsZUJyZWFrO1xufVxuZnVuY3Rpb24gcUQodCkge1xuICBsZXQgZSA9IHQudHlwZS5wcm9wKHNhKTtcbiAgaWYgKGUpXG4gICAgcmV0dXJuIGU7XG4gIGxldCBuID0gdC5maXJzdENoaWxkLCByO1xuICBpZiAobiAmJiAociA9IG4udHlwZS5wcm9wKFJlLmNsb3NlZEJ5KSkpIHtcbiAgICBsZXQgaSA9IHQubGFzdENoaWxkLCBzID0gaSAmJiByLmluZGV4T2YoaS5uYW1lKSA+IC0xO1xuICAgIHJldHVybiAobykgPT4gZHgobywgITAsIDEsIHZvaWQgMCwgcyAmJiAhVUQobykgPyBpLmZyb20gOiB2b2lkIDApO1xuICB9XG4gIHJldHVybiB0LnBhcmVudCA9PSBudWxsID8gWUQgOiBudWxsO1xufVxuZnVuY3Rpb24gWUQoKSB7XG4gIHJldHVybiAwO1xufVxuY2xhc3MgbWcgZXh0ZW5kcyBjeCB7XG4gIGNvbnN0cnVjdG9yKGUsIG4sIHIpIHtcbiAgICBzdXBlcihlLnN0YXRlLCBlLm9wdGlvbnMpLCB0aGlzLmJhc2UgPSBlLCB0aGlzLnBvcyA9IG4sIHRoaXMuY29udGV4dCA9IHI7XG4gIH1cbiAgLyoqXG4gIFRoZSBzeW50YXggdHJlZSBub2RlIHRvIHdoaWNoIHRoZSBpbmRlbnRhdGlvbiBzdHJhdGVneVxuICBhcHBsaWVzLlxuICAqL1xuICBnZXQgbm9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250ZXh0Lm5vZGU7XG4gIH1cbiAgLyoqXG4gIEBpbnRlcm5hbFxuICAqL1xuICBzdGF0aWMgY3JlYXRlKGUsIG4sIHIpIHtcbiAgICByZXR1cm4gbmV3IG1nKGUsIG4sIHIpO1xuICB9XG4gIC8qKlxuICBHZXQgdGhlIHRleHQgZGlyZWN0bHkgYWZ0ZXIgYHRoaXMucG9zYCwgZWl0aGVyIHRoZSBlbnRpcmUgbGluZVxuICBvciB0aGUgbmV4dCAxMDAgY2hhcmFjdGVycywgd2hpY2hldmVyIGlzIHNob3J0ZXIuXG4gICovXG4gIGdldCB0ZXh0QWZ0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMudGV4dEFmdGVyUG9zKHRoaXMucG9zKTtcbiAgfVxuICAvKipcbiAgR2V0IHRoZSBpbmRlbnRhdGlvbiBhdCB0aGUgcmVmZXJlbmNlIGxpbmUgZm9yIGB0aGlzLm5vZGVgLCB3aGljaFxuICBpcyB0aGUgbGluZSBvbiB3aGljaCBpdCBzdGFydHMsIHVubGVzcyB0aGVyZSBpcyBhIG5vZGUgdGhhdCBpc1xuICBfbm90XyBhIHBhcmVudCBvZiB0aGlzIG5vZGUgY292ZXJpbmcgdGhlIHN0YXJ0IG9mIHRoYXQgbGluZS4gSWZcbiAgc28sIHRoZSBsaW5lIGF0IHRoZSBzdGFydCBvZiB0aGF0IG5vZGUgaXMgdHJpZWQsIGFnYWluIHNraXBwaW5nXG4gIG9uIGlmIGl0IGlzIGNvdmVyZWQgYnkgYW5vdGhlciBzdWNoIG5vZGUuXG4gICovXG4gIGdldCBiYXNlSW5kZW50KCkge1xuICAgIHJldHVybiB0aGlzLmJhc2VJbmRlbnRGb3IodGhpcy5ub2RlKTtcbiAgfVxuICAvKipcbiAgR2V0IHRoZSBpbmRlbnRhdGlvbiBmb3IgdGhlIHJlZmVyZW5jZSBsaW5lIG9mIHRoZSBnaXZlbiBub2RlXG4gIChzZWUgW2BiYXNlSW5kZW50YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5UcmVlSW5kZW50Q29udGV4dC5iYXNlSW5kZW50KSkuXG4gICovXG4gIGJhc2VJbmRlbnRGb3IoZSkge1xuICAgIGxldCBuID0gdGhpcy5zdGF0ZS5kb2MubGluZUF0KGUuZnJvbSk7XG4gICAgZm9yICg7IDsgKSB7XG4gICAgICBsZXQgciA9IGUucmVzb2x2ZShuLmZyb20pO1xuICAgICAgZm9yICg7IHIucGFyZW50ICYmIHIucGFyZW50LmZyb20gPT0gci5mcm9tOyApXG4gICAgICAgIHIgPSByLnBhcmVudDtcbiAgICAgIGlmICh6RChyLCBlKSlcbiAgICAgICAgYnJlYWs7XG4gICAgICBuID0gdGhpcy5zdGF0ZS5kb2MubGluZUF0KHIuZnJvbSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxpbmVJbmRlbnQobi5mcm9tKTtcbiAgfVxuICAvKipcbiAgQ29udGludWUgbG9va2luZyBmb3IgaW5kZW50YXRpb25zIGluIHRoZSBub2RlJ3MgcGFyZW50IG5vZGVzLFxuICBhbmQgcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhhdC5cbiAgKi9cbiAgY29udGludWUoKSB7XG4gICAgcmV0dXJuIHV4KHRoaXMuY29udGV4dC5uZXh0LCB0aGlzLmJhc2UsIHRoaXMucG9zKTtcbiAgfVxufVxuZnVuY3Rpb24gekQodCwgZSkge1xuICBmb3IgKGxldCBuID0gZTsgbjsgbiA9IG4ucGFyZW50KVxuICAgIGlmICh0ID09IG4pXG4gICAgICByZXR1cm4gITA7XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIEhEKHQpIHtcbiAgbGV0IGUgPSB0Lm5vZGUsIG4gPSBlLmNoaWxkQWZ0ZXIoZS5mcm9tKSwgciA9IGUubGFzdENoaWxkO1xuICBpZiAoIW4pXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCBpID0gdC5vcHRpb25zLnNpbXVsYXRlQnJlYWssIHMgPSB0LnN0YXRlLmRvYy5saW5lQXQobi5mcm9tKSwgbyA9IGkgPT0gbnVsbCB8fCBpIDw9IHMuZnJvbSA/IHMudG8gOiBNYXRoLm1pbihzLnRvLCBpKTtcbiAgZm9yIChsZXQgYSA9IG4udG87IDsgKSB7XG4gICAgbGV0IGwgPSBlLmNoaWxkQWZ0ZXIoYSk7XG4gICAgaWYgKCFsIHx8IGwgPT0gcilcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGlmICghbC50eXBlLmlzU2tpcHBlZClcbiAgICAgIHJldHVybiBsLmZyb20gPCBvID8gbiA6IG51bGw7XG4gICAgYSA9IGwudG87XG4gIH1cbn1cbmZ1bmN0aW9uIHhwKHsgY2xvc2luZzogdCwgYWxpZ246IGUgPSAhMCwgdW5pdHM6IG4gPSAxIH0pIHtcbiAgcmV0dXJuIChyKSA9PiBkeChyLCBlLCBuLCB0KTtcbn1cbmZ1bmN0aW9uIGR4KHQsIGUsIG4sIHIsIGkpIHtcbiAgbGV0IHMgPSB0LnRleHRBZnRlciwgbyA9IHMubWF0Y2goL15cXHMqLylbMF0ubGVuZ3RoLCBhID0gciAmJiBzLnNsaWNlKG8sIG8gKyByLmxlbmd0aCkgPT0gciB8fCBpID09IHQucG9zICsgbywgbCA9IGUgPyBIRCh0KSA6IG51bGw7XG4gIHJldHVybiBsID8gYSA/IHQuY29sdW1uKGwuZnJvbSkgOiB0LmNvbHVtbihsLnRvKSA6IHQuYmFzZUluZGVudCArIChhID8gMCA6IHQudW5pdCAqIG4pO1xufVxuY29uc3QgRkQgPSAodCkgPT4gdC5iYXNlSW5kZW50O1xuZnVuY3Rpb24gJG8oeyBleGNlcHQ6IHQsIHVuaXRzOiBlID0gMSB9ID0ge30pIHtcbiAgcmV0dXJuIChuKSA9PiB7XG4gICAgbGV0IHIgPSB0ICYmIHQudGVzdChuLnRleHRBZnRlcik7XG4gICAgcmV0dXJuIG4uYmFzZUluZGVudCArIChyID8gMCA6IGUgKiBuLnVuaXQpO1xuICB9O1xufVxuY29uc3QgR0QgPSAyMDA7XG5mdW5jdGlvbiBLRCgpIHtcbiAgcmV0dXJuIFllLnRyYW5zYWN0aW9uRmlsdGVyLm9mKCh0KSA9PiB7XG4gICAgaWYgKCF0LmRvY0NoYW5nZWQgfHwgIXQuaXNVc2VyRXZlbnQoXCJpbnB1dC50eXBlXCIpICYmICF0LmlzVXNlckV2ZW50KFwiaW5wdXQuY29tcGxldGVcIikpXG4gICAgICByZXR1cm4gdDtcbiAgICBsZXQgZSA9IHQuc3RhcnRTdGF0ZS5sYW5ndWFnZURhdGFBdChcImluZGVudE9uSW5wdXRcIiwgdC5zdGFydFN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQpO1xuICAgIGlmICghZS5sZW5ndGgpXG4gICAgICByZXR1cm4gdDtcbiAgICBsZXQgbiA9IHQubmV3RG9jLCB7IGhlYWQ6IHIgfSA9IHQubmV3U2VsZWN0aW9uLm1haW4sIGkgPSBuLmxpbmVBdChyKTtcbiAgICBpZiAociA+IGkuZnJvbSArIEdEKVxuICAgICAgcmV0dXJuIHQ7XG4gICAgbGV0IHMgPSBuLnNsaWNlU3RyaW5nKGkuZnJvbSwgcik7XG4gICAgaWYgKCFlLnNvbWUoKGMpID0+IGMudGVzdChzKSkpXG4gICAgICByZXR1cm4gdDtcbiAgICBsZXQgeyBzdGF0ZTogbyB9ID0gdCwgYSA9IC0xLCBsID0gW107XG4gICAgZm9yIChsZXQgeyBoZWFkOiBjIH0gb2Ygby5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICBsZXQgdSA9IG8uZG9jLmxpbmVBdChjKTtcbiAgICAgIGlmICh1LmZyb20gPT0gYSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBhID0gdS5mcm9tO1xuICAgICAgbGV0IGQgPSBCRChvLCB1LmZyb20pO1xuICAgICAgaWYgKGQgPT0gbnVsbClcbiAgICAgICAgY29udGludWU7XG4gICAgICBsZXQgZiA9IC9eXFxzKi8uZXhlYyh1LnRleHQpWzBdLCBoID0gbHgobywgZCk7XG4gICAgICBmICE9IGggJiYgbC5wdXNoKHsgZnJvbTogdS5mcm9tLCB0bzogdS5mcm9tICsgZi5sZW5ndGgsIGluc2VydDogaCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGwubGVuZ3RoID8gW3QsIHsgY2hhbmdlczogbCwgc2VxdWVudGlhbDogITAgfV0gOiB0O1xuICB9KTtcbn1cbmNvbnN0IEtsID0gLyogQF9fUFVSRV9fICovIG5ldyBSZSgpO1xuZnVuY3Rpb24gSGQodCkge1xuICBsZXQgZSA9IHQuZmlyc3RDaGlsZCwgbiA9IHQubGFzdENoaWxkO1xuICByZXR1cm4gZSAmJiBlLnRvIDwgbi5mcm9tID8geyBmcm9tOiBlLnRvLCB0bzogbi50eXBlLmlzRXJyb3IgPyB0LnRvIDogbi5mcm9tIH0gOiBudWxsO1xufVxuY2xhc3MgSmwge1xuICBjb25zdHJ1Y3RvcihlLCBuKSB7XG4gICAgdGhpcy5zcGVjcyA9IGU7XG4gICAgbGV0IHI7XG4gICAgZnVuY3Rpb24gaShhKSB7XG4gICAgICBsZXQgbCA9IHNzLm5ld05hbWUoKTtcbiAgICAgIHJldHVybiAociB8fCAociA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpKSlbXCIuXCIgKyBsXSA9IGEsIGw7XG4gICAgfVxuICAgIGNvbnN0IHMgPSB0eXBlb2Ygbi5hbGwgPT0gXCJzdHJpbmdcIiA/IG4uYWxsIDogbi5hbGwgPyBpKG4uYWxsKSA6IHZvaWQgMCwgbyA9IG4uc2NvcGU7XG4gICAgdGhpcy5zY29wZSA9IG8gaW5zdGFuY2VvZiB1ciA/IChhKSA9PiBhLnByb3AoT28pID09IG8uZGF0YSA6IG8gPyAoYSkgPT4gYSA9PSBvIDogdm9pZCAwLCB0aGlzLnN0eWxlID0gaXgoZS5tYXAoKGEpID0+ICh7XG4gICAgICB0YWc6IGEudGFnLFxuICAgICAgY2xhc3M6IGEuY2xhc3MgfHwgaShPYmplY3QuYXNzaWduKHt9LCBhLCB7IHRhZzogbnVsbCB9KSlcbiAgICB9KSksIHtcbiAgICAgIGFsbDogc1xuICAgIH0pLnN0eWxlLCB0aGlzLm1vZHVsZSA9IHIgPyBuZXcgc3MocikgOiBudWxsLCB0aGlzLnRoZW1lVHlwZSA9IG4udGhlbWVUeXBlO1xuICB9XG4gIC8qKlxuICBDcmVhdGUgYSBoaWdobGlnaHRlciBzdHlsZSB0aGF0IGFzc29jaWF0ZXMgdGhlIGdpdmVuIHN0eWxlcyB0b1xuICB0aGUgZ2l2ZW4gdGFncy4gVGhlIHNwZWNzIG11c3QgYmUgb2JqZWN0cyB0aGF0IGhvbGQgYSBzdHlsZSB0YWdcbiAgb3IgYXJyYXkgb2YgdGFncyBpbiB0aGVpciBgdGFnYCBwcm9wZXJ0eSwgYW5kIGVpdGhlciBhIHNpbmdsZVxuICBgY2xhc3NgIHByb3BlcnR5IHByb3ZpZGluZyBhIHN0YXRpYyBDU1MgY2xhc3MgKGZvciBoaWdobGlnaHRlclxuICB0aGF0IHJlbHkgb24gZXh0ZXJuYWwgc3R5bGluZyksIG9yIGFcbiAgW2BzdHlsZS1tb2RgXShodHRwczovL2dpdGh1Yi5jb20vbWFyaWpuaC9zdHlsZS1tb2QjZG9jdW1lbnRhdGlvbiktc3R5bGVcbiAgc2V0IG9mIENTUyBwcm9wZXJ0aWVzICh3aGljaCBkZWZpbmUgdGhlIHN0eWxpbmcgZm9yIHRob3NlIHRhZ3MpLlxuICBcbiAgVGhlIENTUyBydWxlcyBjcmVhdGVkIGZvciBhIGhpZ2hsaWdodGVyIHdpbGwgYmUgZW1pdHRlZCBpbiB0aGVcbiAgb3JkZXIgb2YgdGhlIHNwZWMncyBwcm9wZXJ0aWVzLiBUaGF0IG1lYW5zIHRoYXQgZm9yIGVsZW1lbnRzIHRoYXRcbiAgaGF2ZSBtdWx0aXBsZSB0YWdzIGFzc29jaWF0ZWQgd2l0aCB0aGVtLCBzdHlsZXMgZGVmaW5lZCBmdXJ0aGVyXG4gIGRvd24gaW4gdGhlIGxpc3Qgd2lsbCBoYXZlIGEgaGlnaGVyIENTUyBwcmVjZWRlbmNlIHRoYW4gc3R5bGVzXG4gIGRlZmluZWQgZWFybGllci5cbiAgKi9cbiAgc3RhdGljIGRlZmluZShlLCBuKSB7XG4gICAgcmV0dXJuIG5ldyBKbChlLCBuIHx8IHt9KTtcbiAgfVxufVxuY29uc3QgUHAgPSAvKiBAX19QVVJFX18gKi8gdmUuZGVmaW5lKCksIGZ4ID0gLyogQF9fUFVSRV9fICovIHZlLmRlZmluZSh7XG4gIGNvbWJpbmUodCkge1xuICAgIHJldHVybiB0Lmxlbmd0aCA/IFt0WzBdXSA6IG51bGw7XG4gIH1cbn0pO1xuZnVuY3Rpb24gSWYodCkge1xuICBsZXQgZSA9IHQuZmFjZXQoUHApO1xuICByZXR1cm4gZS5sZW5ndGggPyBlIDogdC5mYWNldChmeCk7XG59XG5mdW5jdGlvbiBoeCh0LCBlKSB7XG4gIGxldCBuID0gW2VaXSwgcjtcbiAgcmV0dXJuIHQgaW5zdGFuY2VvZiBKbCAmJiAodC5tb2R1bGUgJiYgbi5wdXNoKFNlLnN0eWxlTW9kdWxlLm9mKHQubW9kdWxlKSksIHIgPSB0LnRoZW1lVHlwZSksIGUgIT0gbnVsbCAmJiBlLmZhbGxiYWNrID8gbi5wdXNoKGZ4Lm9mKHQpKSA6IHIgPyBuLnB1c2goUHAuY29tcHV0ZU4oW1NlLmRhcmtUaGVtZV0sIChpKSA9PiBpLmZhY2V0KFNlLmRhcmtUaGVtZSkgPT0gKHIgPT0gXCJkYXJrXCIpID8gW3RdIDogW10pKSA6IG4ucHVzaChQcC5vZih0KSksIG47XG59XG5jbGFzcyBKRCB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLm1hcmtDYWNoZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCB0aGlzLnRyZWUgPSB1bihlLnN0YXRlKSwgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuYnVpbGREZWNvKGUsIElmKGUuc3RhdGUpKSwgdGhpcy5kZWNvcmF0ZWRUbyA9IGUudmlld3BvcnQudG87XG4gIH1cbiAgdXBkYXRlKGUpIHtcbiAgICBsZXQgbiA9IHVuKGUuc3RhdGUpLCByID0gSWYoZS5zdGF0ZSksIGkgPSByICE9IElmKGUuc3RhcnRTdGF0ZSksIHsgdmlld3BvcnQ6IHMgfSA9IGUudmlldywgbyA9IGUuY2hhbmdlcy5tYXBQb3ModGhpcy5kZWNvcmF0ZWRUbywgMSk7XG4gICAgbi5sZW5ndGggPCBzLnRvICYmICFpICYmIG4udHlwZSA9PSB0aGlzLnRyZWUudHlwZSAmJiBvID49IHMudG8gPyAodGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuZGVjb3JhdGlvbnMubWFwKGUuY2hhbmdlcyksIHRoaXMuZGVjb3JhdGVkVG8gPSBvKSA6IChuICE9IHRoaXMudHJlZSB8fCBlLnZpZXdwb3J0Q2hhbmdlZCB8fCBpKSAmJiAodGhpcy50cmVlID0gbiwgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuYnVpbGREZWNvKGUudmlldywgciksIHRoaXMuZGVjb3JhdGVkVG8gPSBzLnRvKTtcbiAgfVxuICBidWlsZERlY28oZSwgbikge1xuICAgIGlmICghbiB8fCAhdGhpcy50cmVlLmxlbmd0aClcbiAgICAgIHJldHVybiBKZS5ub25lO1xuICAgIGxldCByID0gbmV3IGpvKCk7XG4gICAgZm9yIChsZXQgeyBmcm9tOiBpLCB0bzogcyB9IG9mIGUudmlzaWJsZVJhbmdlcylcbiAgICAgIFZEKHRoaXMudHJlZSwgbiwgKG8sIGEsIGwpID0+IHtcbiAgICAgICAgci5hZGQobywgYSwgdGhpcy5tYXJrQ2FjaGVbbF0gfHwgKHRoaXMubWFya0NhY2hlW2xdID0gSmUubWFyayh7IGNsYXNzOiBsIH0pKSk7XG4gICAgICB9LCBpLCBzKTtcbiAgICByZXR1cm4gci5maW5pc2goKTtcbiAgfVxufVxuY29uc3QgZVogPSAvKiBAX19QVVJFX18gKi8gemwuaGlnaCgvKiBAX19QVVJFX18gKi8gcnIuZnJvbUNsYXNzKEpELCB7XG4gIGRlY29yYXRpb25zOiAodCkgPT4gdC5kZWNvcmF0aW9uc1xufSkpLCB0WiA9IC8qIEBfX1BVUkVfXyAqLyBKbC5kZWZpbmUoW1xuICB7XG4gICAgdGFnOiBQLm1ldGEsXG4gICAgY29sb3I6IFwiIzQwNDc0MFwiXG4gIH0sXG4gIHtcbiAgICB0YWc6IFAubGluayxcbiAgICB0ZXh0RGVjb3JhdGlvbjogXCJ1bmRlcmxpbmVcIlxuICB9LFxuICB7XG4gICAgdGFnOiBQLmhlYWRpbmcsXG4gICAgdGV4dERlY29yYXRpb246IFwidW5kZXJsaW5lXCIsXG4gICAgZm9udFdlaWdodDogXCJib2xkXCJcbiAgfSxcbiAge1xuICAgIHRhZzogUC5lbXBoYXNpcyxcbiAgICBmb250U3R5bGU6IFwiaXRhbGljXCJcbiAgfSxcbiAge1xuICAgIHRhZzogUC5zdHJvbmcsXG4gICAgZm9udFdlaWdodDogXCJib2xkXCJcbiAgfSxcbiAge1xuICAgIHRhZzogUC5zdHJpa2V0aHJvdWdoLFxuICAgIHRleHREZWNvcmF0aW9uOiBcImxpbmUtdGhyb3VnaFwiXG4gIH0sXG4gIHtcbiAgICB0YWc6IFAua2V5d29yZCxcbiAgICBjb2xvcjogXCIjNzA4XCJcbiAgfSxcbiAge1xuICAgIHRhZzogW1AuYXRvbSwgUC5ib29sLCBQLnVybCwgUC5jb250ZW50U2VwYXJhdG9yLCBQLmxhYmVsTmFtZV0sXG4gICAgY29sb3I6IFwiIzIxOVwiXG4gIH0sXG4gIHtcbiAgICB0YWc6IFtQLmxpdGVyYWwsIFAuaW5zZXJ0ZWRdLFxuICAgIGNvbG9yOiBcIiMxNjRcIlxuICB9LFxuICB7XG4gICAgdGFnOiBbUC5zdHJpbmcsIFAuZGVsZXRlZF0sXG4gICAgY29sb3I6IFwiI2ExMVwiXG4gIH0sXG4gIHtcbiAgICB0YWc6IFtQLnJlZ2V4cCwgUC5lc2NhcGUsIC8qIEBfX1BVUkVfXyAqLyBQLnNwZWNpYWwoUC5zdHJpbmcpXSxcbiAgICBjb2xvcjogXCIjZTQwXCJcbiAgfSxcbiAge1xuICAgIHRhZzogLyogQF9fUFVSRV9fICovIFAuZGVmaW5pdGlvbihQLnZhcmlhYmxlTmFtZSksXG4gICAgY29sb3I6IFwiIzAwZlwiXG4gIH0sXG4gIHtcbiAgICB0YWc6IC8qIEBfX1BVUkVfXyAqLyBQLmxvY2FsKFAudmFyaWFibGVOYW1lKSxcbiAgICBjb2xvcjogXCIjMzBhXCJcbiAgfSxcbiAge1xuICAgIHRhZzogW1AudHlwZU5hbWUsIFAubmFtZXNwYWNlXSxcbiAgICBjb2xvcjogXCIjMDg1XCJcbiAgfSxcbiAge1xuICAgIHRhZzogUC5jbGFzc05hbWUsXG4gICAgY29sb3I6IFwiIzE2N1wiXG4gIH0sXG4gIHtcbiAgICB0YWc6IFsvKiBAX19QVVJFX18gKi8gUC5zcGVjaWFsKFAudmFyaWFibGVOYW1lKSwgUC5tYWNyb05hbWVdLFxuICAgIGNvbG9yOiBcIiMyNTZcIlxuICB9LFxuICB7XG4gICAgdGFnOiAvKiBAX19QVVJFX18gKi8gUC5kZWZpbml0aW9uKFAucHJvcGVydHlOYW1lKSxcbiAgICBjb2xvcjogXCIjMDBjXCJcbiAgfSxcbiAge1xuICAgIHRhZzogUC5jb21tZW50LFxuICAgIGNvbG9yOiBcIiM5NDBcIlxuICB9LFxuICB7XG4gICAgdGFnOiBQLmludmFsaWQsXG4gICAgY29sb3I6IFwiI2YwMFwiXG4gIH1cbl0pLCBuWiA9IC8qIEBfX1BVUkVfXyAqLyBTZS5iYXNlVGhlbWUoe1xuICBcIiYuY20tZm9jdXNlZCAuY20tbWF0Y2hpbmdCcmFja2V0XCI6IHsgYmFja2dyb3VuZENvbG9yOiBcIiMzMjhjODI1MlwiIH0sXG4gIFwiJi5jbS1mb2N1c2VkIC5jbS1ub25tYXRjaGluZ0JyYWNrZXRcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2JiNTU1NTQ0XCIgfVxufSksIHB4ID0gMWU0LCBPeCA9IFwiKClbXXt9XCIsIGd4ID0gLyogQF9fUFVSRV9fICovIHZlLmRlZmluZSh7XG4gIGNvbWJpbmUodCkge1xuICAgIHJldHVybiBVZCh0LCB7XG4gICAgICBhZnRlckN1cnNvcjogITAsXG4gICAgICBicmFja2V0czogT3gsXG4gICAgICBtYXhTY2FuRGlzdGFuY2U6IHB4LFxuICAgICAgcmVuZGVyTWF0Y2g6IHNaXG4gICAgfSk7XG4gIH1cbn0pLCByWiA9IC8qIEBfX1BVUkVfXyAqLyBKZS5tYXJrKHsgY2xhc3M6IFwiY20tbWF0Y2hpbmdCcmFja2V0XCIgfSksIGlaID0gLyogQF9fUFVSRV9fICovIEplLm1hcmsoeyBjbGFzczogXCJjbS1ub25tYXRjaGluZ0JyYWNrZXRcIiB9KTtcbmZ1bmN0aW9uIHNaKHQpIHtcbiAgbGV0IGUgPSBbXSwgbiA9IHQubWF0Y2hlZCA/IHJaIDogaVo7XG4gIHJldHVybiBlLnB1c2gobi5yYW5nZSh0LnN0YXJ0LmZyb20sIHQuc3RhcnQudG8pKSwgdC5lbmQgJiYgZS5wdXNoKG4ucmFuZ2UodC5lbmQuZnJvbSwgdC5lbmQudG8pKSwgZTtcbn1cbmNvbnN0IG9aID0gLyogQF9fUFVSRV9fICovIHlyLmRlZmluZSh7XG4gIGNyZWF0ZSgpIHtcbiAgICByZXR1cm4gSmUubm9uZTtcbiAgfSxcbiAgdXBkYXRlKHQsIGUpIHtcbiAgICBpZiAoIWUuZG9jQ2hhbmdlZCAmJiAhZS5zZWxlY3Rpb24pXG4gICAgICByZXR1cm4gdDtcbiAgICBsZXQgbiA9IFtdLCByID0gZS5zdGF0ZS5mYWNldChneCk7XG4gICAgZm9yIChsZXQgaSBvZiBlLnN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgIGlmICghaS5lbXB0eSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBsZXQgcyA9IEljKGUuc3RhdGUsIGkuaGVhZCwgLTEsIHIpIHx8IGkuaGVhZCA+IDAgJiYgSWMoZS5zdGF0ZSwgaS5oZWFkIC0gMSwgMSwgcikgfHwgci5hZnRlckN1cnNvciAmJiAoSWMoZS5zdGF0ZSwgaS5oZWFkLCAxLCByKSB8fCBpLmhlYWQgPCBlLnN0YXRlLmRvYy5sZW5ndGggJiYgSWMoZS5zdGF0ZSwgaS5oZWFkICsgMSwgLTEsIHIpKTtcbiAgICAgIHMgJiYgKG4gPSBuLmNvbmNhdChyLnJlbmRlck1hdGNoKHMsIGUuc3RhdGUpKSk7XG4gICAgfVxuICAgIHJldHVybiBKZS5zZXQobiwgITApO1xuICB9LFxuICBwcm92aWRlOiAodCkgPT4gU2UuZGVjb3JhdGlvbnMuZnJvbSh0KVxufSksIGFaID0gW1xuICBvWixcbiAgblpcbl07XG5mdW5jdGlvbiBsWih0ID0ge30pIHtcbiAgcmV0dXJuIFtneC5vZih0KSwgYVpdO1xufVxuY29uc3QgbXggPSAvKiBAX19QVVJFX18gKi8gbmV3IFJlKCk7XG5mdW5jdGlvbiBfcCh0LCBlLCBuKSB7XG4gIGxldCByID0gdC5wcm9wKGUgPCAwID8gUmUub3BlbmVkQnkgOiBSZS5jbG9zZWRCeSk7XG4gIGlmIChyKVxuICAgIHJldHVybiByO1xuICBpZiAodC5uYW1lLmxlbmd0aCA9PSAxKSB7XG4gICAgbGV0IGkgPSBuLmluZGV4T2YodC5uYW1lKTtcbiAgICBpZiAoaSA+IC0xICYmIGkgJSAyID09IChlIDwgMCA/IDEgOiAwKSlcbiAgICAgIHJldHVybiBbbltpICsgZV1dO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gVHAodCkge1xuICBsZXQgZSA9IHQudHlwZS5wcm9wKG14KTtcbiAgcmV0dXJuIGUgPyBlKHQubm9kZSkgOiB0O1xufVxuZnVuY3Rpb24gSWModCwgZSwgbiwgciA9IHt9KSB7XG4gIGxldCBpID0gci5tYXhTY2FuRGlzdGFuY2UgfHwgcHgsIHMgPSByLmJyYWNrZXRzIHx8IE94LCBvID0gdW4odCksIGEgPSBvLnJlc29sdmVJbm5lcihlLCBuKTtcbiAgZm9yIChsZXQgbCA9IGE7IGw7IGwgPSBsLnBhcmVudCkge1xuICAgIGxldCBjID0gX3AobC50eXBlLCBuLCBzKTtcbiAgICBpZiAoYyAmJiBsLmZyb20gPCBsLnRvKSB7XG4gICAgICBsZXQgdSA9IFRwKGwpO1xuICAgICAgaWYgKHUgJiYgKG4gPiAwID8gZSA+PSB1LmZyb20gJiYgZSA8IHUudG8gOiBlID4gdS5mcm9tICYmIGUgPD0gdS50bykpXG4gICAgICAgIHJldHVybiBjWih0LCBlLCBuLCBsLCB1LCBjLCBzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVaKHQsIGUsIG4sIG8sIGEudHlwZSwgaSwgcyk7XG59XG5mdW5jdGlvbiBjWih0LCBlLCBuLCByLCBpLCBzLCBvKSB7XG4gIGxldCBhID0gci5wYXJlbnQsIGwgPSB7IGZyb206IGkuZnJvbSwgdG86IGkudG8gfSwgYyA9IDAsIHUgPSBhID09IG51bGwgPyB2b2lkIDAgOiBhLmN1cnNvcigpO1xuICBpZiAodSAmJiAobiA8IDAgPyB1LmNoaWxkQmVmb3JlKHIuZnJvbSkgOiB1LmNoaWxkQWZ0ZXIoci50bykpKVxuICAgIGRvXG4gICAgICBpZiAobiA8IDAgPyB1LnRvIDw9IHIuZnJvbSA6IHUuZnJvbSA+PSByLnRvKSB7XG4gICAgICAgIGlmIChjID09IDAgJiYgcy5pbmRleE9mKHUudHlwZS5uYW1lKSA+IC0xICYmIHUuZnJvbSA8IHUudG8pIHtcbiAgICAgICAgICBsZXQgZCA9IFRwKHUpO1xuICAgICAgICAgIHJldHVybiB7IHN0YXJ0OiBsLCBlbmQ6IGQgPyB7IGZyb206IGQuZnJvbSwgdG86IGQudG8gfSA6IHZvaWQgMCwgbWF0Y2hlZDogITAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChfcCh1LnR5cGUsIG4sIG8pKVxuICAgICAgICAgIGMrKztcbiAgICAgICAgZWxzZSBpZiAoX3AodS50eXBlLCAtbiwgbykpIHtcbiAgICAgICAgICBpZiAoYyA9PSAwKSB7XG4gICAgICAgICAgICBsZXQgZCA9IFRwKHUpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgc3RhcnQ6IGwsXG4gICAgICAgICAgICAgIGVuZDogZCAmJiBkLmZyb20gPCBkLnRvID8geyBmcm9tOiBkLmZyb20sIHRvOiBkLnRvIH0gOiB2b2lkIDAsXG4gICAgICAgICAgICAgIG1hdGNoZWQ6ICExXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjLS07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB3aGlsZSAobiA8IDAgPyB1LnByZXZTaWJsaW5nKCkgOiB1Lm5leHRTaWJsaW5nKCkpO1xuICByZXR1cm4geyBzdGFydDogbCwgbWF0Y2hlZDogITEgfTtcbn1cbmZ1bmN0aW9uIHVaKHQsIGUsIG4sIHIsIGksIHMsIG8pIHtcbiAgbGV0IGEgPSBuIDwgMCA/IHQuc2xpY2VEb2MoZSAtIDEsIGUpIDogdC5zbGljZURvYyhlLCBlICsgMSksIGwgPSBvLmluZGV4T2YoYSk7XG4gIGlmIChsIDwgMCB8fCBsICUgMiA9PSAwICE9IG4gPiAwKVxuICAgIHJldHVybiBudWxsO1xuICBsZXQgYyA9IHsgZnJvbTogbiA8IDAgPyBlIC0gMSA6IGUsIHRvOiBuID4gMCA/IGUgKyAxIDogZSB9LCB1ID0gdC5kb2MuaXRlclJhbmdlKGUsIG4gPiAwID8gdC5kb2MubGVuZ3RoIDogMCksIGQgPSAwO1xuICBmb3IgKGxldCBmID0gMDsgIXUubmV4dCgpLmRvbmUgJiYgZiA8PSBzOyApIHtcbiAgICBsZXQgaCA9IHUudmFsdWU7XG4gICAgbiA8IDAgJiYgKGYgKz0gaC5sZW5ndGgpO1xuICAgIGxldCBwID0gZSArIGYgKiBuO1xuICAgIGZvciAobGV0IE8gPSBuID4gMCA/IDAgOiBoLmxlbmd0aCAtIDEsIG0gPSBuID4gMCA/IGgubGVuZ3RoIDogLTE7IE8gIT0gbTsgTyArPSBuKSB7XG4gICAgICBsZXQgeSA9IG8uaW5kZXhPZihoW09dKTtcbiAgICAgIGlmICghKHkgPCAwIHx8IHIucmVzb2x2ZUlubmVyKHAgKyBPLCAxKS50eXBlICE9IGkpKVxuICAgICAgICBpZiAoeSAlIDIgPT0gMCA9PSBuID4gMClcbiAgICAgICAgICBkKys7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmIChkID09IDEpXG4gICAgICAgICAgICByZXR1cm4geyBzdGFydDogYywgZW5kOiB7IGZyb206IHAgKyBPLCB0bzogcCArIE8gKyAxIH0sIG1hdGNoZWQ6IHkgPj4gMSA9PSBsID4+IDEgfTtcbiAgICAgICAgICBkLS07XG4gICAgICAgIH1cbiAgICB9XG4gICAgbiA+IDAgJiYgKGYgKz0gaC5sZW5ndGgpO1xuICB9XG4gIHJldHVybiB1LmRvbmUgPyB7IHN0YXJ0OiBjLCBtYXRjaGVkOiAhMSB9IDogbnVsbDtcbn1cbmNvbnN0IGRaID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIEx2ID0gW09uLm5vbmVdLCBVdiA9IFtdLCBxdiA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCBmWiA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuZm9yIChsZXQgW3QsIGVdIG9mIFtcbiAgW1widmFyaWFibGVcIiwgXCJ2YXJpYWJsZU5hbWVcIl0sXG4gIFtcInZhcmlhYmxlLTJcIiwgXCJ2YXJpYWJsZU5hbWUuc3BlY2lhbFwiXSxcbiAgW1wic3RyaW5nLTJcIiwgXCJzdHJpbmcuc3BlY2lhbFwiXSxcbiAgW1wiZGVmXCIsIFwidmFyaWFibGVOYW1lLmRlZmluaXRpb25cIl0sXG4gIFtcInRhZ1wiLCBcInRhZ05hbWVcIl0sXG4gIFtcImF0dHJpYnV0ZVwiLCBcImF0dHJpYnV0ZU5hbWVcIl0sXG4gIFtcInR5cGVcIiwgXCJ0eXBlTmFtZVwiXSxcbiAgW1wiYnVpbHRpblwiLCBcInZhcmlhYmxlTmFtZS5zdGFuZGFyZFwiXSxcbiAgW1wicXVhbGlmaWVyXCIsIFwibW9kaWZpZXJcIl0sXG4gIFtcImVycm9yXCIsIFwiaW52YWxpZFwiXSxcbiAgW1wiaGVhZGVyXCIsIFwiaGVhZGluZ1wiXSxcbiAgW1wicHJvcGVydHlcIiwgXCJwcm9wZXJ0eU5hbWVcIl1cbl0pXG4gIGZaW3RdID0gLyogQF9fUFVSRV9fICovIGhaKGRaLCBlKTtcbmZ1bmN0aW9uIFdmKHQsIGUpIHtcbiAgVXYuaW5kZXhPZih0KSA+IC0xIHx8IChVdi5wdXNoKHQpLCBjb25zb2xlLndhcm4oZSkpO1xufVxuZnVuY3Rpb24gaFoodCwgZSkge1xuICBsZXQgbiA9IFtdO1xuICBmb3IgKGxldCBhIG9mIGUuc3BsaXQoXCIgXCIpKSB7XG4gICAgbGV0IGwgPSBbXTtcbiAgICBmb3IgKGxldCBjIG9mIGEuc3BsaXQoXCIuXCIpKSB7XG4gICAgICBsZXQgdSA9IHRbY10gfHwgUFtjXTtcbiAgICAgIHUgPyB0eXBlb2YgdSA9PSBcImZ1bmN0aW9uXCIgPyBsLmxlbmd0aCA/IGwgPSBsLm1hcCh1KSA6IFdmKGMsIGBNb2RpZmllciAke2N9IHVzZWQgYXQgc3RhcnQgb2YgdGFnYCkgOiBsLmxlbmd0aCA/IFdmKGMsIGBUYWcgJHtjfSB1c2VkIGFzIG1vZGlmaWVyYCkgOiBsID0gQXJyYXkuaXNBcnJheSh1KSA/IHUgOiBbdV0gOiBXZihjLCBgVW5rbm93biBoaWdobGlnaHRpbmcgdGFnICR7Y31gKTtcbiAgICB9XG4gICAgZm9yIChsZXQgYyBvZiBsKVxuICAgICAgbi5wdXNoKGMpO1xuICB9XG4gIGlmICghbi5sZW5ndGgpXG4gICAgcmV0dXJuIDA7XG4gIGxldCByID0gZS5yZXBsYWNlKC8gL2csIFwiX1wiKSwgaSA9IHIgKyBcIiBcIiArIG4ubWFwKChhKSA9PiBhLmlkKSwgcyA9IHF2W2ldO1xuICBpZiAocylcbiAgICByZXR1cm4gcy5pZDtcbiAgbGV0IG8gPSBxdltpXSA9IE9uLmRlZmluZSh7XG4gICAgaWQ6IEx2Lmxlbmd0aCxcbiAgICBuYW1lOiByLFxuICAgIHByb3BzOiBbaWEoeyBbcl06IG4gfSldXG4gIH0pO1xuICByZXR1cm4gTHYucHVzaChvKSwgby5pZDtcbn1cblF0LlJUTCwgUXQuTFRSO1xuY2xhc3MgYngge1xuICAvKipcbiAgQ3JlYXRlIGEgbmV3IGNvbXBsZXRpb24gY29udGV4dC4gKE1vc3RseSB1c2VmdWwgZm9yIHRlc3RpbmdcbiAgY29tcGxldGlvbiBzb3VyY2Vz4oCUaW4gdGhlIGVkaXRvciwgdGhlIGV4dGVuc2lvbiB3aWxsIGNyZWF0ZVxuICB0aGVzZSBmb3IgeW91LilcbiAgKi9cbiAgY29uc3RydWN0b3IoZSwgbiwgcikge1xuICAgIHRoaXMuc3RhdGUgPSBlLCB0aGlzLnBvcyA9IG4sIHRoaXMuZXhwbGljaXQgPSByLCB0aGlzLmFib3J0TGlzdGVuZXJzID0gW107XG4gIH1cbiAgLyoqXG4gIEdldCB0aGUgZXh0ZW50LCBjb250ZW50LCBhbmQgKGlmIHRoZXJlIGlzIGEgdG9rZW4pIHR5cGUgb2YgdGhlXG4gIHRva2VuIGJlZm9yZSBgdGhpcy5wb3NgLlxuICAqL1xuICB0b2tlbkJlZm9yZShlKSB7XG4gICAgbGV0IG4gPSB1bih0aGlzLnN0YXRlKS5yZXNvbHZlSW5uZXIodGhpcy5wb3MsIC0xKTtcbiAgICBmb3IgKDsgbiAmJiBlLmluZGV4T2Yobi5uYW1lKSA8IDA7IClcbiAgICAgIG4gPSBuLnBhcmVudDtcbiAgICByZXR1cm4gbiA/IHtcbiAgICAgIGZyb206IG4uZnJvbSxcbiAgICAgIHRvOiB0aGlzLnBvcyxcbiAgICAgIHRleHQ6IHRoaXMuc3RhdGUuc2xpY2VEb2Mobi5mcm9tLCB0aGlzLnBvcyksXG4gICAgICB0eXBlOiBuLnR5cGVcbiAgICB9IDogbnVsbDtcbiAgfVxuICAvKipcbiAgR2V0IHRoZSBtYXRjaCBvZiB0aGUgZ2l2ZW4gZXhwcmVzc2lvbiBkaXJlY3RseSBiZWZvcmUgdGhlXG4gIGN1cnNvci5cbiAgKi9cbiAgbWF0Y2hCZWZvcmUoZSkge1xuICAgIGxldCBuID0gdGhpcy5zdGF0ZS5kb2MubGluZUF0KHRoaXMucG9zKSwgciA9IE1hdGgubWF4KG4uZnJvbSwgdGhpcy5wb3MgLSAyNTApLCBpID0gbi50ZXh0LnNsaWNlKHIgLSBuLmZyb20sIHRoaXMucG9zIC0gbi5mcm9tKSwgcyA9IGkuc2VhcmNoKHl4KGUsICExKSk7XG4gICAgcmV0dXJuIHMgPCAwID8gbnVsbCA6IHsgZnJvbTogciArIHMsIHRvOiB0aGlzLnBvcywgdGV4dDogaS5zbGljZShzKSB9O1xuICB9XG4gIC8qKlxuICBZaWVsZHMgdHJ1ZSB3aGVuIHRoZSBxdWVyeSBoYXMgYmVlbiBhYm9ydGVkLiBDYW4gYmUgdXNlZnVsIGluXG4gIGFzeW5jaHJvbm91cyBxdWVyaWVzIHRvIGF2b2lkIGRvaW5nIHdvcmsgdGhhdCB3aWxsIGJlIGlnbm9yZWQuXG4gICovXG4gIGdldCBhYm9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLmFib3J0TGlzdGVuZXJzID09IG51bGw7XG4gIH1cbiAgLyoqXG4gIEFsbG93cyB5b3UgdG8gcmVnaXN0ZXIgYWJvcnQgaGFuZGxlcnMsIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgdGhlIHF1ZXJ5IGlzXG4gIFthYm9ydGVkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2F1dG9jb21wbGV0ZS5Db21wbGV0aW9uQ29udGV4dC5hYm9ydGVkKS5cbiAgKi9cbiAgYWRkRXZlbnRMaXN0ZW5lcihlLCBuKSB7XG4gICAgZSA9PSBcImFib3J0XCIgJiYgdGhpcy5hYm9ydExpc3RlbmVycyAmJiB0aGlzLmFib3J0TGlzdGVuZXJzLnB1c2gobik7XG4gIH1cbn1cbmZ1bmN0aW9uIFl2KHQpIHtcbiAgbGV0IGUgPSBPYmplY3Qua2V5cyh0KS5qb2luKFwiXCIpLCBuID0gL1xcdy8udGVzdChlKTtcbiAgcmV0dXJuIG4gJiYgKGUgPSBlLnJlcGxhY2UoL1xcdy9nLCBcIlwiKSksIGBbJHtuID8gXCJcXFxcd1wiIDogXCJcIn0ke2UucmVwbGFjZSgvW15cXHdcXHNdL2csIFwiXFxcXCQmXCIpfV1gO1xufVxuZnVuY3Rpb24gcFoodCkge1xuICBsZXQgZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCBuID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGZvciAobGV0IHsgbGFiZWw6IGkgfSBvZiB0KSB7XG4gICAgZVtpWzBdXSA9ICEwO1xuICAgIGZvciAobGV0IHMgPSAxOyBzIDwgaS5sZW5ndGg7IHMrKylcbiAgICAgIG5baVtzXV0gPSAhMDtcbiAgfVxuICBsZXQgciA9IFl2KGUpICsgWXYobikgKyBcIiokXCI7XG4gIHJldHVybiBbbmV3IFJlZ0V4cChcIl5cIiArIHIpLCBuZXcgUmVnRXhwKHIpXTtcbn1cbmZ1bmN0aW9uIHZ4KHQpIHtcbiAgbGV0IGUgPSB0Lm1hcCgoaSkgPT4gdHlwZW9mIGkgPT0gXCJzdHJpbmdcIiA/IHsgbGFiZWw6IGkgfSA6IGkpLCBbbiwgcl0gPSBlLmV2ZXJ5KChpKSA9PiAvXlxcdyskLy50ZXN0KGkubGFiZWwpKSA/IFsvXFx3KiQvLCAvXFx3KyQvXSA6IHBaKGUpO1xuICByZXR1cm4gKGkpID0+IHtcbiAgICBsZXQgcyA9IGkubWF0Y2hCZWZvcmUocik7XG4gICAgcmV0dXJuIHMgfHwgaS5leHBsaWNpdCA/IHsgZnJvbTogcyA/IHMuZnJvbSA6IGkucG9zLCBvcHRpb25zOiBlLCB2YWxpZEZvcjogbiB9IDogbnVsbDtcbiAgfTtcbn1cbmZ1bmN0aW9uIE9aKHQsIGUpIHtcbiAgcmV0dXJuIChuKSA9PiB7XG4gICAgZm9yIChsZXQgciA9IHVuKG4uc3RhdGUpLnJlc29sdmVJbm5lcihuLnBvcywgLTEpOyByOyByID0gci5wYXJlbnQpIHtcbiAgICAgIGlmICh0LmluZGV4T2Yoci5uYW1lKSA+IC0xKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGlmIChyLnR5cGUuaXNUb3ApXG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gZShuKTtcbiAgfTtcbn1cbmNsYXNzIHp2IHtcbiAgY29uc3RydWN0b3IoZSwgbiwgciwgaSkge1xuICAgIHRoaXMuY29tcGxldGlvbiA9IGUsIHRoaXMuc291cmNlID0gbiwgdGhpcy5tYXRjaCA9IHIsIHRoaXMuc2NvcmUgPSBpO1xuICB9XG59XG5mdW5jdGlvbiBKaSh0KSB7XG4gIHJldHVybiB0LnNlbGVjdGlvbi5tYWluLmZyb207XG59XG5mdW5jdGlvbiB5eCh0LCBlKSB7XG4gIHZhciBuO1xuICBsZXQgeyBzb3VyY2U6IHIgfSA9IHQsIGkgPSBlICYmIHJbMF0gIT0gXCJeXCIsIHMgPSByW3IubGVuZ3RoIC0gMV0gIT0gXCIkXCI7XG4gIHJldHVybiAhaSAmJiAhcyA/IHQgOiBuZXcgUmVnRXhwKGAke2kgPyBcIl5cIiA6IFwiXCJ9KD86JHtyfSkke3MgPyBcIiRcIiA6IFwiXCJ9YCwgKG4gPSB0LmZsYWdzKSAhPT0gbnVsbCAmJiBuICE9PSB2b2lkIDAgPyBuIDogdC5pZ25vcmVDYXNlID8gXCJpXCIgOiBcIlwiKTtcbn1cbmNvbnN0IFN4ID0gLyogQF9fUFVSRV9fICovIG5vLmRlZmluZSgpO1xuZnVuY3Rpb24gZ1oodCwgZSwgbiwgcikge1xuICBsZXQgeyBtYWluOiBpIH0gPSB0LnNlbGVjdGlvbiwgcyA9IG4gLSBpLmZyb20sIG8gPSByIC0gaS5mcm9tO1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0LmNoYW5nZUJ5UmFuZ2UoKGEpID0+IGEgIT0gaSAmJiBuICE9IHIgJiYgdC5zbGljZURvYyhhLmZyb20gKyBzLCBhLmZyb20gKyBvKSAhPSB0LnNsaWNlRG9jKG4sIHIpID8geyByYW5nZTogYSB9IDoge1xuICAgIGNoYW5nZXM6IHsgZnJvbTogYS5mcm9tICsgcywgdG86IHIgPT0gaS5mcm9tID8gYS50byA6IGEuZnJvbSArIG8sIGluc2VydDogZSB9LFxuICAgIHJhbmdlOiBhZS5jdXJzb3IoYS5mcm9tICsgcyArIGUubGVuZ3RoKVxuICB9KSksIHsgc2Nyb2xsSW50b1ZpZXc6ICEwLCB1c2VyRXZlbnQ6IFwiaW5wdXQuY29tcGxldGVcIiB9KTtcbn1cbmNvbnN0IEh2ID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBtWih0KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheSh0KSlcbiAgICByZXR1cm4gdDtcbiAgbGV0IGUgPSBIdi5nZXQodCk7XG4gIHJldHVybiBlIHx8IEh2LnNldCh0LCBlID0gdngodCkpLCBlO1xufVxuY29uc3QgVXUgPSAvKiBAX19QVVJFX18gKi8gb3QuZGVmaW5lKCksIFNsID0gLyogQF9fUFVSRV9fICovIG90LmRlZmluZSgpO1xuY2xhc3MgYloge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5wYXR0ZXJuID0gZSwgdGhpcy5jaGFycyA9IFtdLCB0aGlzLmZvbGRlZCA9IFtdLCB0aGlzLmFueSA9IFtdLCB0aGlzLnByZWNpc2UgPSBbXSwgdGhpcy5ieVdvcmQgPSBbXSwgdGhpcy5zY29yZSA9IDAsIHRoaXMubWF0Y2hlZCA9IFtdO1xuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgZS5sZW5ndGg7ICkge1xuICAgICAgbGV0IHIgPSBubihlLCBuKSwgaSA9IGNyKHIpO1xuICAgICAgdGhpcy5jaGFycy5wdXNoKHIpO1xuICAgICAgbGV0IHMgPSBlLnNsaWNlKG4sIG4gKyBpKSwgbyA9IHMudG9VcHBlckNhc2UoKTtcbiAgICAgIHRoaXMuZm9sZGVkLnB1c2gobm4obyA9PSBzID8gcy50b0xvd2VyQ2FzZSgpIDogbywgMCkpLCBuICs9IGk7XG4gICAgfVxuICAgIHRoaXMuYXN0cmFsID0gZS5sZW5ndGggIT0gdGhpcy5jaGFycy5sZW5ndGg7XG4gIH1cbiAgcmV0KGUsIG4pIHtcbiAgICByZXR1cm4gdGhpcy5zY29yZSA9IGUsIHRoaXMubWF0Y2hlZCA9IG4sICEwO1xuICB9XG4gIC8vIE1hdGNoZXMgYSBnaXZlbiB3b3JkIChjb21wbGV0aW9uKSBhZ2FpbnN0IHRoZSBwYXR0ZXJuIChpbnB1dCkuXG4gIC8vIFdpbGwgcmV0dXJuIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlcmUgd2FzIGEgbWF0Y2ggYW5kLFxuICAvLyBvbiBzdWNjZXNzLCBzZXQgYHRoaXMuc2NvcmVgIHRvIHRoZSBzY29yZSwgYHRoaXMubWF0Y2hlZGAgdG8gYW5cbiAgLy8gYXJyYXkgb2YgYGZyb20sIHRvYCBwYWlycyBpbmRpY2F0aW5nIHRoZSBtYXRjaGVkIHBhcnRzIG9mIGB3b3JkYC5cbiAgLy9cbiAgLy8gVGhlIHNjb3JlIGlzIGEgbnVtYmVyIHRoYXQgaXMgbW9yZSBuZWdhdGl2ZSB0aGUgd29yc2UgdGhlIG1hdGNoXG4gIC8vIGlzLiBTZWUgYFBlbmFsdHlgIGFib3ZlLlxuICBtYXRjaChlKSB7XG4gICAgaWYgKHRoaXMucGF0dGVybi5sZW5ndGggPT0gMClcbiAgICAgIHJldHVybiB0aGlzLnJldCgtMTAwLCBbXSk7XG4gICAgaWYgKGUubGVuZ3RoIDwgdGhpcy5wYXR0ZXJuLmxlbmd0aClcbiAgICAgIHJldHVybiAhMTtcbiAgICBsZXQgeyBjaGFyczogbiwgZm9sZGVkOiByLCBhbnk6IGksIHByZWNpc2U6IHMsIGJ5V29yZDogbyB9ID0gdGhpcztcbiAgICBpZiAobi5sZW5ndGggPT0gMSkge1xuICAgICAgbGV0IGIgPSBubihlLCAwKSwgZyA9IGNyKGIpLCB2ID0gZyA9PSBlLmxlbmd0aCA/IDAgOiAtMTAwO1xuICAgICAgaWYgKGIgIT0gblswXSlcbiAgICAgICAgaWYgKGIgPT0gclswXSlcbiAgICAgICAgICB2ICs9IC0yMDA7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICByZXR1cm4gdGhpcy5yZXQodiwgWzAsIGddKTtcbiAgICB9XG4gICAgbGV0IGEgPSBlLmluZGV4T2YodGhpcy5wYXR0ZXJuKTtcbiAgICBpZiAoYSA9PSAwKVxuICAgICAgcmV0dXJuIHRoaXMucmV0KGUubGVuZ3RoID09IHRoaXMucGF0dGVybi5sZW5ndGggPyAwIDogLTEwMCwgWzAsIHRoaXMucGF0dGVybi5sZW5ndGhdKTtcbiAgICBsZXQgbCA9IG4ubGVuZ3RoLCBjID0gMDtcbiAgICBpZiAoYSA8IDApIHtcbiAgICAgIGZvciAobGV0IGIgPSAwLCBnID0gTWF0aC5taW4oZS5sZW5ndGgsIDIwMCk7IGIgPCBnICYmIGMgPCBsOyApIHtcbiAgICAgICAgbGV0IHYgPSBubihlLCBiKTtcbiAgICAgICAgKHYgPT0gbltjXSB8fCB2ID09IHJbY10pICYmIChpW2MrK10gPSBiKSwgYiArPSBjcih2KTtcbiAgICAgIH1cbiAgICAgIGlmIChjIDwgbClcbiAgICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICBsZXQgdSA9IDAsIGQgPSAwLCBmID0gITEsIGggPSAwLCBwID0gLTEsIE8gPSAtMSwgbSA9IC9bYS16XS8udGVzdChlKSwgeSA9ICEwO1xuICAgIGZvciAobGV0IGIgPSAwLCBnID0gTWF0aC5taW4oZS5sZW5ndGgsIDIwMCksIHYgPSAwOyBiIDwgZyAmJiBkIDwgbDsgKSB7XG4gICAgICBsZXQgUyA9IG5uKGUsIGIpO1xuICAgICAgYSA8IDAgJiYgKHUgPCBsICYmIFMgPT0gblt1XSAmJiAoc1t1KytdID0gYiksIGggPCBsICYmIChTID09IG5baF0gfHwgUyA9PSByW2hdID8gKGggPT0gMCAmJiAocCA9IGIpLCBPID0gYiArIDEsIGgrKykgOiBoID0gMCkpO1xuICAgICAgbGV0IHcsIGsgPSBTIDwgMjU1ID8gUyA+PSA0OCAmJiBTIDw9IDU3IHx8IFMgPj0gOTcgJiYgUyA8PSAxMjIgPyAyIDogUyA+PSA2NSAmJiBTIDw9IDkwID8gMSA6IDAgOiAodyA9IEl3KFMpKSAhPSB3LnRvTG93ZXJDYXNlKCkgPyAxIDogdyAhPSB3LnRvVXBwZXJDYXNlKCkgPyAyIDogMDtcbiAgICAgICghYiB8fCBrID09IDEgJiYgbSB8fCB2ID09IDAgJiYgayAhPSAwKSAmJiAobltkXSA9PSBTIHx8IHJbZF0gPT0gUyAmJiAoZiA9ICEwKSA/IG9bZCsrXSA9IGIgOiBvLmxlbmd0aCAmJiAoeSA9ICExKSksIHYgPSBrLCBiICs9IGNyKFMpO1xuICAgIH1cbiAgICByZXR1cm4gZCA9PSBsICYmIG9bMF0gPT0gMCAmJiB5ID8gdGhpcy5yZXN1bHQoLTEwMCArIChmID8gLTIwMCA6IDApLCBvLCBlKSA6IGggPT0gbCAmJiBwID09IDAgPyB0aGlzLnJldCgtMjAwIC0gZS5sZW5ndGggKyAoTyA9PSBlLmxlbmd0aCA/IDAgOiAtMTAwKSwgWzAsIE9dKSA6IGEgPiAtMSA/IHRoaXMucmV0KC03MDAgLSBlLmxlbmd0aCwgW2EsIGEgKyB0aGlzLnBhdHRlcm4ubGVuZ3RoXSkgOiBoID09IGwgPyB0aGlzLnJldCgtOTAwIC0gZS5sZW5ndGgsIFtwLCBPXSkgOiBkID09IGwgPyB0aGlzLnJlc3VsdCgtMTAwICsgKGYgPyAtMjAwIDogMCkgKyAtNzAwICsgKHkgPyAwIDogLTExMDApLCBvLCBlKSA6IG4ubGVuZ3RoID09IDIgPyAhMSA6IHRoaXMucmVzdWx0KChpWzBdID8gLTcwMCA6IDApICsgLTIwMCArIC0xMTAwLCBpLCBlKTtcbiAgfVxuICByZXN1bHQoZSwgbiwgcikge1xuICAgIGxldCBpID0gW10sIHMgPSAwO1xuICAgIGZvciAobGV0IG8gb2Ygbikge1xuICAgICAgbGV0IGEgPSBvICsgKHRoaXMuYXN0cmFsID8gY3Iobm4ociwgbykpIDogMSk7XG4gICAgICBzICYmIGlbcyAtIDFdID09IG8gPyBpW3MgLSAxXSA9IGEgOiAoaVtzKytdID0gbywgaVtzKytdID0gYSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJldChlIC0gci5sZW5ndGgsIGkpO1xuICB9XG59XG5jb25zdCBGdCA9IC8qIEBfX1BVUkVfXyAqLyB2ZS5kZWZpbmUoe1xuICBjb21iaW5lKHQpIHtcbiAgICByZXR1cm4gVWQodCwge1xuICAgICAgYWN0aXZhdGVPblR5cGluZzogITAsXG4gICAgICBhY3RpdmF0ZU9uVHlwaW5nRGVsYXk6IDEwMCxcbiAgICAgIHNlbGVjdE9uT3BlbjogITAsXG4gICAgICBvdmVycmlkZTogbnVsbCxcbiAgICAgIGNsb3NlT25CbHVyOiAhMCxcbiAgICAgIG1heFJlbmRlcmVkT3B0aW9uczogMTAwLFxuICAgICAgZGVmYXVsdEtleW1hcDogITAsXG4gICAgICB0b29sdGlwQ2xhc3M6ICgpID0+IFwiXCIsXG4gICAgICBvcHRpb25DbGFzczogKCkgPT4gXCJcIixcbiAgICAgIGFib3ZlQ3Vyc29yOiAhMSxcbiAgICAgIGljb25zOiAhMCxcbiAgICAgIGFkZFRvT3B0aW9uczogW10sXG4gICAgICBwb3NpdGlvbkluZm86IHZaLFxuICAgICAgY29tcGFyZUNvbXBsZXRpb25zOiAoZSwgbikgPT4gZS5sYWJlbC5sb2NhbGVDb21wYXJlKG4ubGFiZWwpLFxuICAgICAgaW50ZXJhY3Rpb25EZWxheTogNzUsXG4gICAgICB1cGRhdGVTeW5jVGltZTogMTAwXG4gICAgfSwge1xuICAgICAgZGVmYXVsdEtleW1hcDogKGUsIG4pID0+IGUgJiYgbixcbiAgICAgIGNsb3NlT25CbHVyOiAoZSwgbikgPT4gZSAmJiBuLFxuICAgICAgaWNvbnM6IChlLCBuKSA9PiBlICYmIG4sXG4gICAgICB0b29sdGlwQ2xhc3M6IChlLCBuKSA9PiAocikgPT4gRnYoZShyKSwgbihyKSksXG4gICAgICBvcHRpb25DbGFzczogKGUsIG4pID0+IChyKSA9PiBGdihlKHIpLCBuKHIpKSxcbiAgICAgIGFkZFRvT3B0aW9uczogKGUsIG4pID0+IGUuY29uY2F0KG4pXG4gICAgfSk7XG4gIH1cbn0pO1xuZnVuY3Rpb24gRnYodCwgZSkge1xuICByZXR1cm4gdCA/IGUgPyB0ICsgXCIgXCIgKyBlIDogdCA6IGU7XG59XG5mdW5jdGlvbiB2Wih0LCBlLCBuLCByLCBpLCBzKSB7XG4gIGxldCBvID0gdC50ZXh0RGlyZWN0aW9uID09IFF0LlJUTCwgYSA9IG8sIGwgPSAhMSwgYyA9IFwidG9wXCIsIHUsIGQsIGYgPSBlLmxlZnQgLSBpLmxlZnQsIGggPSBpLnJpZ2h0IC0gZS5yaWdodCwgcCA9IHIucmlnaHQgLSByLmxlZnQsIE8gPSByLmJvdHRvbSAtIHIudG9wO1xuICBpZiAoYSAmJiBmIDwgTWF0aC5taW4ocCwgaCkgPyBhID0gITEgOiAhYSAmJiBoIDwgTWF0aC5taW4ocCwgZikgJiYgKGEgPSAhMCksIHAgPD0gKGEgPyBmIDogaCkpXG4gICAgdSA9IE1hdGgubWF4KGkudG9wLCBNYXRoLm1pbihuLnRvcCwgaS5ib3R0b20gLSBPKSkgLSBlLnRvcCwgZCA9IE1hdGgubWluKDQwMCwgYSA/IGYgOiBoKTtcbiAgZWxzZSB7XG4gICAgbCA9ICEwLCBkID0gTWF0aC5taW4oXG4gICAgICA0MDAsXG4gICAgICAobyA/IGUucmlnaHQgOiBpLnJpZ2h0IC0gZS5sZWZ0KSAtIDMwXG4gICAgICAvKiBJbmZvLk1hcmdpbiAqL1xuICAgICk7XG4gICAgbGV0IGIgPSBpLmJvdHRvbSAtIGUuYm90dG9tO1xuICAgIGIgPj0gTyB8fCBiID4gZS50b3AgPyB1ID0gbi5ib3R0b20gLSBlLnRvcCA6IChjID0gXCJib3R0b21cIiwgdSA9IGUuYm90dG9tIC0gbi50b3ApO1xuICB9XG4gIGxldCBtID0gKGUuYm90dG9tIC0gZS50b3ApIC8gcy5vZmZzZXRIZWlnaHQsIHkgPSAoZS5yaWdodCAtIGUubGVmdCkgLyBzLm9mZnNldFdpZHRoO1xuICByZXR1cm4ge1xuICAgIHN0eWxlOiBgJHtjfTogJHt1IC8gbX1weDsgbWF4LXdpZHRoOiAke2QgLyB5fXB4YCxcbiAgICBjbGFzczogXCJjbS1jb21wbGV0aW9uSW5mby1cIiArIChsID8gbyA/IFwibGVmdC1uYXJyb3dcIiA6IFwicmlnaHQtbmFycm93XCIgOiBhID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIpXG4gIH07XG59XG5mdW5jdGlvbiB5Wih0KSB7XG4gIGxldCBlID0gdC5hZGRUb09wdGlvbnMuc2xpY2UoKTtcbiAgcmV0dXJuIHQuaWNvbnMgJiYgZS5wdXNoKHtcbiAgICByZW5kZXIobikge1xuICAgICAgbGV0IHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgcmV0dXJuIHIuY2xhc3NMaXN0LmFkZChcImNtLWNvbXBsZXRpb25JY29uXCIpLCBuLnR5cGUgJiYgci5jbGFzc0xpc3QuYWRkKC4uLm4udHlwZS5zcGxpdCgvXFxzKy9nKS5tYXAoKGkpID0+IFwiY20tY29tcGxldGlvbkljb24tXCIgKyBpKSksIHIuc2V0QXR0cmlidXRlKFwiYXJpYS1oaWRkZW5cIiwgXCJ0cnVlXCIpLCByO1xuICAgIH0sXG4gICAgcG9zaXRpb246IDIwXG4gIH0pLCBlLnB1c2goe1xuICAgIHJlbmRlcihuLCByLCBpLCBzKSB7XG4gICAgICBsZXQgbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgby5jbGFzc05hbWUgPSBcImNtLWNvbXBsZXRpb25MYWJlbFwiO1xuICAgICAgbGV0IGEgPSBuLmRpc3BsYXlMYWJlbCB8fCBuLmxhYmVsLCBsID0gMDtcbiAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgcy5sZW5ndGg7ICkge1xuICAgICAgICBsZXQgdSA9IHNbYysrXSwgZCA9IHNbYysrXTtcbiAgICAgICAgdSA+IGwgJiYgby5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShhLnNsaWNlKGwsIHUpKSk7XG4gICAgICAgIGxldCBmID0gby5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKSk7XG4gICAgICAgIGYuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYS5zbGljZSh1LCBkKSkpLCBmLmNsYXNzTmFtZSA9IFwiY20tY29tcGxldGlvbk1hdGNoZWRUZXh0XCIsIGwgPSBkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGwgPCBhLmxlbmd0aCAmJiBvLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGEuc2xpY2UobCkpKSwgbztcbiAgICB9LFxuICAgIHBvc2l0aW9uOiA1MFxuICB9LCB7XG4gICAgcmVuZGVyKG4pIHtcbiAgICAgIGlmICghbi5kZXRhaWwpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgbGV0IHIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIHJldHVybiByLmNsYXNzTmFtZSA9IFwiY20tY29tcGxldGlvbkRldGFpbFwiLCByLnRleHRDb250ZW50ID0gbi5kZXRhaWwsIHI7XG4gICAgfSxcbiAgICBwb3NpdGlvbjogODBcbiAgfSksIGUuc29ydCgobiwgcikgPT4gbi5wb3NpdGlvbiAtIHIucG9zaXRpb24pLm1hcCgobikgPT4gbi5yZW5kZXIpO1xufVxuZnVuY3Rpb24gTWYodCwgZSwgbikge1xuICBpZiAodCA8PSBuKVxuICAgIHJldHVybiB7IGZyb206IDAsIHRvOiB0IH07XG4gIGlmIChlIDwgMCAmJiAoZSA9IDApLCBlIDw9IHQgPj4gMSkge1xuICAgIGxldCBpID0gTWF0aC5mbG9vcihlIC8gbik7XG4gICAgcmV0dXJuIHsgZnJvbTogaSAqIG4sIHRvOiAoaSArIDEpICogbiB9O1xuICB9XG4gIGxldCByID0gTWF0aC5mbG9vcigodCAtIGUpIC8gbik7XG4gIHJldHVybiB7IGZyb206IHQgLSAociArIDEpICogbiwgdG86IHQgLSByICogbiB9O1xufVxuY2xhc3MgU1oge1xuICBjb25zdHJ1Y3RvcihlLCBuLCByKSB7XG4gICAgdGhpcy52aWV3ID0gZSwgdGhpcy5zdGF0ZUZpZWxkID0gbiwgdGhpcy5hcHBseUNvbXBsZXRpb24gPSByLCB0aGlzLmluZm8gPSBudWxsLCB0aGlzLmluZm9EZXN0cm95ID0gbnVsbCwgdGhpcy5wbGFjZUluZm9SZXEgPSB7XG4gICAgICByZWFkOiAoKSA9PiB0aGlzLm1lYXN1cmVJbmZvKCksXG4gICAgICB3cml0ZTogKGwpID0+IHRoaXMucGxhY2VJbmZvKGwpLFxuICAgICAga2V5OiB0aGlzXG4gICAgfSwgdGhpcy5zcGFjZSA9IG51bGwsIHRoaXMuY3VycmVudENsYXNzID0gXCJcIjtcbiAgICBsZXQgaSA9IGUuc3RhdGUuZmllbGQobiksIHsgb3B0aW9uczogcywgc2VsZWN0ZWQ6IG8gfSA9IGkub3BlbiwgYSA9IGUuc3RhdGUuZmFjZXQoRnQpO1xuICAgIHRoaXMub3B0aW9uQ29udGVudCA9IHlaKGEpLCB0aGlzLm9wdGlvbkNsYXNzID0gYS5vcHRpb25DbGFzcywgdGhpcy50b29sdGlwQ2xhc3MgPSBhLnRvb2x0aXBDbGFzcywgdGhpcy5yYW5nZSA9IE1mKHMubGVuZ3RoLCBvLCBhLm1heFJlbmRlcmVkT3B0aW9ucyksIHRoaXMuZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgdGhpcy5kb20uY2xhc3NOYW1lID0gXCJjbS10b29sdGlwLWF1dG9jb21wbGV0ZVwiLCB0aGlzLnVwZGF0ZVRvb2x0aXBDbGFzcyhlLnN0YXRlKSwgdGhpcy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCAobCkgPT4ge1xuICAgICAgbGV0IHsgb3B0aW9uczogYyB9ID0gZS5zdGF0ZS5maWVsZChuKS5vcGVuO1xuICAgICAgZm9yIChsZXQgdSA9IGwudGFyZ2V0LCBkOyB1ICYmIHUgIT0gdGhpcy5kb207IHUgPSB1LnBhcmVudE5vZGUpXG4gICAgICAgIGlmICh1Lm5vZGVOYW1lID09IFwiTElcIiAmJiAoZCA9IC8tKFxcZCspJC8uZXhlYyh1LmlkKSkgJiYgK2RbMV0gPCBjLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuYXBwbHlDb21wbGV0aW9uKGUsIGNbK2RbMV1dKSwgbC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH0pLCB0aGlzLmRvbS5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgKGwpID0+IHtcbiAgICAgIGxldCBjID0gZS5zdGF0ZS5maWVsZCh0aGlzLnN0YXRlRmllbGQsICExKTtcbiAgICAgIGMgJiYgYy50b29sdGlwICYmIGUuc3RhdGUuZmFjZXQoRnQpLmNsb3NlT25CbHVyICYmIGwucmVsYXRlZFRhcmdldCAhPSBlLmNvbnRlbnRET00gJiYgZS5kaXNwYXRjaCh7IGVmZmVjdHM6IFNsLm9mKG51bGwpIH0pO1xuICAgIH0pLCB0aGlzLnNob3dPcHRpb25zKHMsIGkuaWQpO1xuICB9XG4gIG1vdW50KCkge1xuICAgIHRoaXMudXBkYXRlU2VsKCk7XG4gIH1cbiAgc2hvd09wdGlvbnMoZSwgbikge1xuICAgIHRoaXMubGlzdCAmJiB0aGlzLmxpc3QucmVtb3ZlKCksIHRoaXMubGlzdCA9IHRoaXMuZG9tLmFwcGVuZENoaWxkKHRoaXMuY3JlYXRlTGlzdEJveChlLCBuLCB0aGlzLnJhbmdlKSksIHRoaXMubGlzdC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsICgpID0+IHtcbiAgICAgIHRoaXMuaW5mbyAmJiB0aGlzLnZpZXcucmVxdWVzdE1lYXN1cmUodGhpcy5wbGFjZUluZm9SZXEpO1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZShlKSB7XG4gICAgdmFyIG47XG4gICAgbGV0IHIgPSBlLnN0YXRlLmZpZWxkKHRoaXMuc3RhdGVGaWVsZCksIGkgPSBlLnN0YXJ0U3RhdGUuZmllbGQodGhpcy5zdGF0ZUZpZWxkKTtcbiAgICBpZiAodGhpcy51cGRhdGVUb29sdGlwQ2xhc3MoZS5zdGF0ZSksIHIgIT0gaSkge1xuICAgICAgbGV0IHsgb3B0aW9uczogcywgc2VsZWN0ZWQ6IG8sIGRpc2FibGVkOiBhIH0gPSByLm9wZW47XG4gICAgICAoIWkub3BlbiB8fCBpLm9wZW4ub3B0aW9ucyAhPSBzKSAmJiAodGhpcy5yYW5nZSA9IE1mKHMubGVuZ3RoLCBvLCBlLnN0YXRlLmZhY2V0KEZ0KS5tYXhSZW5kZXJlZE9wdGlvbnMpLCB0aGlzLnNob3dPcHRpb25zKHMsIHIuaWQpKSwgdGhpcy51cGRhdGVTZWwoKSwgYSAhPSAoKG4gPSBpLm9wZW4pID09PSBudWxsIHx8IG4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG4uZGlzYWJsZWQpICYmIHRoaXMuZG9tLmNsYXNzTGlzdC50b2dnbGUoXCJjbS10b29sdGlwLWF1dG9jb21wbGV0ZS1kaXNhYmxlZFwiLCAhIWEpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVUb29sdGlwQ2xhc3MoZSkge1xuICAgIGxldCBuID0gdGhpcy50b29sdGlwQ2xhc3MoZSk7XG4gICAgaWYgKG4gIT0gdGhpcy5jdXJyZW50Q2xhc3MpIHtcbiAgICAgIGZvciAobGV0IHIgb2YgdGhpcy5jdXJyZW50Q2xhc3Muc3BsaXQoXCIgXCIpKVxuICAgICAgICByICYmIHRoaXMuZG9tLmNsYXNzTGlzdC5yZW1vdmUocik7XG4gICAgICBmb3IgKGxldCByIG9mIG4uc3BsaXQoXCIgXCIpKVxuICAgICAgICByICYmIHRoaXMuZG9tLmNsYXNzTGlzdC5hZGQocik7XG4gICAgICB0aGlzLmN1cnJlbnRDbGFzcyA9IG47XG4gICAgfVxuICB9XG4gIHBvc2l0aW9uZWQoZSkge1xuICAgIHRoaXMuc3BhY2UgPSBlLCB0aGlzLmluZm8gJiYgdGhpcy52aWV3LnJlcXVlc3RNZWFzdXJlKHRoaXMucGxhY2VJbmZvUmVxKTtcbiAgfVxuICB1cGRhdGVTZWwoKSB7XG4gICAgbGV0IGUgPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQodGhpcy5zdGF0ZUZpZWxkKSwgbiA9IGUub3BlbjtcbiAgICBpZiAoKG4uc2VsZWN0ZWQgPiAtMSAmJiBuLnNlbGVjdGVkIDwgdGhpcy5yYW5nZS5mcm9tIHx8IG4uc2VsZWN0ZWQgPj0gdGhpcy5yYW5nZS50bykgJiYgKHRoaXMucmFuZ2UgPSBNZihuLm9wdGlvbnMubGVuZ3RoLCBuLnNlbGVjdGVkLCB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoRnQpLm1heFJlbmRlcmVkT3B0aW9ucyksIHRoaXMuc2hvd09wdGlvbnMobi5vcHRpb25zLCBlLmlkKSksIHRoaXMudXBkYXRlU2VsZWN0ZWRPcHRpb24obi5zZWxlY3RlZCkpIHtcbiAgICAgIHRoaXMuZGVzdHJveUluZm8oKTtcbiAgICAgIGxldCB7IGNvbXBsZXRpb246IHIgfSA9IG4ub3B0aW9uc1tuLnNlbGVjdGVkXSwgeyBpbmZvOiBpIH0gPSByO1xuICAgICAgaWYgKCFpKVxuICAgICAgICByZXR1cm47XG4gICAgICBsZXQgcyA9IHR5cGVvZiBpID09IFwic3RyaW5nXCIgPyBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShpKSA6IGkocik7XG4gICAgICBpZiAoIXMpXG4gICAgICAgIHJldHVybjtcbiAgICAgIFwidGhlblwiIGluIHMgPyBzLnRoZW4oKG8pID0+IHtcbiAgICAgICAgbyAmJiB0aGlzLnZpZXcuc3RhdGUuZmllbGQodGhpcy5zdGF0ZUZpZWxkLCAhMSkgPT0gZSAmJiB0aGlzLmFkZEluZm9QYW5lKG8sIHIpO1xuICAgICAgfSkuY2F0Y2goKG8pID0+IGhyKHRoaXMudmlldy5zdGF0ZSwgbywgXCJjb21wbGV0aW9uIGluZm9cIikpIDogdGhpcy5hZGRJbmZvUGFuZShzLCByKTtcbiAgICB9XG4gIH1cbiAgYWRkSW5mb1BhbmUoZSwgbikge1xuICAgIHRoaXMuZGVzdHJveUluZm8oKTtcbiAgICBsZXQgciA9IHRoaXMuaW5mbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgaWYgKHIuY2xhc3NOYW1lID0gXCJjbS10b29sdGlwIGNtLWNvbXBsZXRpb25JbmZvXCIsIGUubm9kZVR5cGUgIT0gbnVsbClcbiAgICAgIHIuYXBwZW5kQ2hpbGQoZSksIHRoaXMuaW5mb0Rlc3Ryb3kgPSBudWxsO1xuICAgIGVsc2Uge1xuICAgICAgbGV0IHsgZG9tOiBpLCBkZXN0cm95OiBzIH0gPSBlO1xuICAgICAgci5hcHBlbmRDaGlsZChpKSwgdGhpcy5pbmZvRGVzdHJveSA9IHMgfHwgbnVsbDtcbiAgICB9XG4gICAgdGhpcy5kb20uYXBwZW5kQ2hpbGQociksIHRoaXMudmlldy5yZXF1ZXN0TWVhc3VyZSh0aGlzLnBsYWNlSW5mb1JlcSk7XG4gIH1cbiAgdXBkYXRlU2VsZWN0ZWRPcHRpb24oZSkge1xuICAgIGxldCBuID0gbnVsbDtcbiAgICBmb3IgKGxldCByID0gdGhpcy5saXN0LmZpcnN0Q2hpbGQsIGkgPSB0aGlzLnJhbmdlLmZyb207IHI7IHIgPSByLm5leHRTaWJsaW5nLCBpKyspXG4gICAgICByLm5vZGVOYW1lICE9IFwiTElcIiB8fCAhci5pZCA/IGktLSA6IGkgPT0gZSA/IHIuaGFzQXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiKSB8fCAoci5zZXRBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIsIFwidHJ1ZVwiKSwgbiA9IHIpIDogci5oYXNBdHRyaWJ1dGUoXCJhcmlhLXNlbGVjdGVkXCIpICYmIHIucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1zZWxlY3RlZFwiKTtcbiAgICByZXR1cm4gbiAmJiBrWih0aGlzLmxpc3QsIG4pLCBuO1xuICB9XG4gIG1lYXN1cmVJbmZvKCkge1xuICAgIGxldCBlID0gdGhpcy5kb20ucXVlcnlTZWxlY3RvcihcIlthcmlhLXNlbGVjdGVkXVwiKTtcbiAgICBpZiAoIWUgfHwgIXRoaXMuaW5mbylcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBuID0gdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHIgPSB0aGlzLmluZm8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGkgPSBlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBzID0gdGhpcy5zcGFjZTtcbiAgICBpZiAoIXMpIHtcbiAgICAgIGxldCBvID0gdGhpcy5kb20ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gICAgICBzID0geyBsZWZ0OiAwLCB0b3A6IDAsIHJpZ2h0OiBvLmlubmVyV2lkdGgsIGJvdHRvbTogby5pbm5lckhlaWdodCB9O1xuICAgIH1cbiAgICByZXR1cm4gaS50b3AgPiBNYXRoLm1pbihzLmJvdHRvbSwgbi5ib3R0b20pIC0gMTAgfHwgaS5ib3R0b20gPCBNYXRoLm1heChzLnRvcCwgbi50b3ApICsgMTAgPyBudWxsIDogdGhpcy52aWV3LnN0YXRlLmZhY2V0KEZ0KS5wb3NpdGlvbkluZm8odGhpcy52aWV3LCBuLCBpLCByLCBzLCB0aGlzLmRvbSk7XG4gIH1cbiAgcGxhY2VJbmZvKGUpIHtcbiAgICB0aGlzLmluZm8gJiYgKGUgPyAoZS5zdHlsZSAmJiAodGhpcy5pbmZvLnN0eWxlLmNzc1RleHQgPSBlLnN0eWxlKSwgdGhpcy5pbmZvLmNsYXNzTmFtZSA9IFwiY20tdG9vbHRpcCBjbS1jb21wbGV0aW9uSW5mbyBcIiArIChlLmNsYXNzIHx8IFwiXCIpKSA6IHRoaXMuaW5mby5zdHlsZS5jc3NUZXh0ID0gXCJ0b3A6IC0xZTZweFwiKTtcbiAgfVxuICBjcmVhdGVMaXN0Qm94KGUsIG4sIHIpIHtcbiAgICBjb25zdCBpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInVsXCIpO1xuICAgIGkuaWQgPSBuLCBpLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJsaXN0Ym94XCIpLCBpLnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgXCJ0cnVlXCIpLCBpLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgdGhpcy52aWV3LnN0YXRlLnBocmFzZShcIkNvbXBsZXRpb25zXCIpKTtcbiAgICBsZXQgcyA9IG51bGw7XG4gICAgZm9yIChsZXQgbyA9IHIuZnJvbTsgbyA8IHIudG87IG8rKykge1xuICAgICAgbGV0IHsgY29tcGxldGlvbjogYSwgbWF0Y2g6IGwgfSA9IGVbb10sIHsgc2VjdGlvbjogYyB9ID0gYTtcbiAgICAgIGlmIChjKSB7XG4gICAgICAgIGxldCBmID0gdHlwZW9mIGMgPT0gXCJzdHJpbmdcIiA/IGMgOiBjLm5hbWU7XG4gICAgICAgIGlmIChmICE9IHMgJiYgKG8gPiByLmZyb20gfHwgci5mcm9tID09IDApKVxuICAgICAgICAgIGlmIChzID0gZiwgdHlwZW9mIGMgIT0gXCJzdHJpbmdcIiAmJiBjLmhlYWRlcilcbiAgICAgICAgICAgIGkuYXBwZW5kQ2hpbGQoYy5oZWFkZXIoYykpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGggPSBpLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjb21wbGV0aW9uLXNlY3Rpb25cIikpO1xuICAgICAgICAgICAgaC50ZXh0Q29udGVudCA9IGY7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgdSA9IGkuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpXCIpKTtcbiAgICAgIHUuaWQgPSBuICsgXCItXCIgKyBvLCB1LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJvcHRpb25cIik7XG4gICAgICBsZXQgZCA9IHRoaXMub3B0aW9uQ2xhc3MoYSk7XG4gICAgICBkICYmICh1LmNsYXNzTmFtZSA9IGQpO1xuICAgICAgZm9yIChsZXQgZiBvZiB0aGlzLm9wdGlvbkNvbnRlbnQpIHtcbiAgICAgICAgbGV0IGggPSBmKGEsIHRoaXMudmlldy5zdGF0ZSwgdGhpcy52aWV3LCBsKTtcbiAgICAgICAgaCAmJiB1LmFwcGVuZENoaWxkKGgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gci5mcm9tICYmIGkuY2xhc3NMaXN0LmFkZChcImNtLWNvbXBsZXRpb25MaXN0SW5jb21wbGV0ZVRvcFwiKSwgci50byA8IGUubGVuZ3RoICYmIGkuY2xhc3NMaXN0LmFkZChcImNtLWNvbXBsZXRpb25MaXN0SW5jb21wbGV0ZUJvdHRvbVwiKSwgaTtcbiAgfVxuICBkZXN0cm95SW5mbygpIHtcbiAgICB0aGlzLmluZm8gJiYgKHRoaXMuaW5mb0Rlc3Ryb3kgJiYgdGhpcy5pbmZvRGVzdHJveSgpLCB0aGlzLmluZm8ucmVtb3ZlKCksIHRoaXMuaW5mbyA9IG51bGwpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95SW5mbygpO1xuICB9XG59XG5mdW5jdGlvbiB3Wih0LCBlKSB7XG4gIHJldHVybiAobikgPT4gbmV3IFNaKG4sIHQsIGUpO1xufVxuZnVuY3Rpb24ga1oodCwgZSkge1xuICBsZXQgbiA9IHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHIgPSBlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBpID0gbi5oZWlnaHQgLyB0Lm9mZnNldEhlaWdodDtcbiAgci50b3AgPCBuLnRvcCA/IHQuc2Nyb2xsVG9wIC09IChuLnRvcCAtIHIudG9wKSAvIGkgOiByLmJvdHRvbSA+IG4uYm90dG9tICYmICh0LnNjcm9sbFRvcCArPSAoci5ib3R0b20gLSBuLmJvdHRvbSkgLyBpKTtcbn1cbmZ1bmN0aW9uIEd2KHQpIHtcbiAgcmV0dXJuICh0LmJvb3N0IHx8IDApICogMTAwICsgKHQuYXBwbHkgPyAxMCA6IDApICsgKHQuaW5mbyA/IDUgOiAwKSArICh0LnR5cGUgPyAxIDogMCk7XG59XG5mdW5jdGlvbiB4Wih0LCBlKSB7XG4gIGxldCBuID0gW10sIHIgPSBudWxsLCBpID0gKGwpID0+IHtcbiAgICBuLnB1c2gobCk7XG4gICAgbGV0IHsgc2VjdGlvbjogYyB9ID0gbC5jb21wbGV0aW9uO1xuICAgIGlmIChjKSB7XG4gICAgICByIHx8IChyID0gW10pO1xuICAgICAgbGV0IHUgPSB0eXBlb2YgYyA9PSBcInN0cmluZ1wiID8gYyA6IGMubmFtZTtcbiAgICAgIHIuc29tZSgoZCkgPT4gZC5uYW1lID09IHUpIHx8IHIucHVzaCh0eXBlb2YgYyA9PSBcInN0cmluZ1wiID8geyBuYW1lOiB1IH0gOiBjKTtcbiAgICB9XG4gIH07XG4gIGZvciAobGV0IGwgb2YgdClcbiAgICBpZiAobC5oYXNSZXN1bHQoKSkge1xuICAgICAgbGV0IGMgPSBsLnJlc3VsdC5nZXRNYXRjaDtcbiAgICAgIGlmIChsLnJlc3VsdC5maWx0ZXIgPT09ICExKVxuICAgICAgICBmb3IgKGxldCB1IG9mIGwucmVzdWx0Lm9wdGlvbnMpXG4gICAgICAgICAgaShuZXcgenYodSwgbC5zb3VyY2UsIGMgPyBjKHUpIDogW10sIDFlOSAtIG4ubGVuZ3RoKSk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgbGV0IHUgPSBuZXcgYlooZS5zbGljZURvYyhsLmZyb20sIGwudG8pKTtcbiAgICAgICAgZm9yIChsZXQgZCBvZiBsLnJlc3VsdC5vcHRpb25zKVxuICAgICAgICAgIGlmICh1Lm1hdGNoKGQubGFiZWwpKSB7XG4gICAgICAgICAgICBsZXQgZiA9IGQuZGlzcGxheUxhYmVsID8gYyA/IGMoZCwgdS5tYXRjaGVkKSA6IFtdIDogdS5tYXRjaGVkO1xuICAgICAgICAgICAgaShuZXcgenYoZCwgbC5zb3VyY2UsIGYsIHUuc2NvcmUgKyAoZC5ib29zdCB8fCAwKSkpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIGlmIChyKSB7XG4gICAgbGV0IGwgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgYyA9IDAsIHUgPSAoZCwgZikgPT4ge1xuICAgICAgdmFyIGgsIHA7XG4gICAgICByZXR1cm4gKChoID0gZC5yYW5rKSAhPT0gbnVsbCAmJiBoICE9PSB2b2lkIDAgPyBoIDogMWU5KSAtICgocCA9IGYucmFuaykgIT09IG51bGwgJiYgcCAhPT0gdm9pZCAwID8gcCA6IDFlOSkgfHwgKGQubmFtZSA8IGYubmFtZSA/IC0xIDogMSk7XG4gICAgfTtcbiAgICBmb3IgKGxldCBkIG9mIHIuc29ydCh1KSlcbiAgICAgIGMgLT0gMWU1LCBsW2QubmFtZV0gPSBjO1xuICAgIGZvciAobGV0IGQgb2Ygbikge1xuICAgICAgbGV0IHsgc2VjdGlvbjogZiB9ID0gZC5jb21wbGV0aW9uO1xuICAgICAgZiAmJiAoZC5zY29yZSArPSBsW3R5cGVvZiBmID09IFwic3RyaW5nXCIgPyBmIDogZi5uYW1lXSk7XG4gICAgfVxuICB9XG4gIGxldCBzID0gW10sIG8gPSBudWxsLCBhID0gZS5mYWNldChGdCkuY29tcGFyZUNvbXBsZXRpb25zO1xuICBmb3IgKGxldCBsIG9mIG4uc29ydCgoYywgdSkgPT4gdS5zY29yZSAtIGMuc2NvcmUgfHwgYShjLmNvbXBsZXRpb24sIHUuY29tcGxldGlvbikpKSB7XG4gICAgbGV0IGMgPSBsLmNvbXBsZXRpb247XG4gICAgIW8gfHwgby5sYWJlbCAhPSBjLmxhYmVsIHx8IG8uZGV0YWlsICE9IGMuZGV0YWlsIHx8IG8udHlwZSAhPSBudWxsICYmIGMudHlwZSAhPSBudWxsICYmIG8udHlwZSAhPSBjLnR5cGUgfHwgby5hcHBseSAhPSBjLmFwcGx5IHx8IG8uYm9vc3QgIT0gYy5ib29zdCA/IHMucHVzaChsKSA6IEd2KGwuY29tcGxldGlvbikgPiBHdihvKSAmJiAoc1tzLmxlbmd0aCAtIDFdID0gbCksIG8gPSBsLmNvbXBsZXRpb247XG4gIH1cbiAgcmV0dXJuIHM7XG59XG5jbGFzcyBnbyB7XG4gIGNvbnN0cnVjdG9yKGUsIG4sIHIsIGksIHMsIG8pIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBlLCB0aGlzLmF0dHJzID0gbiwgdGhpcy50b29sdGlwID0gciwgdGhpcy50aW1lc3RhbXAgPSBpLCB0aGlzLnNlbGVjdGVkID0gcywgdGhpcy5kaXNhYmxlZCA9IG87XG4gIH1cbiAgc2V0U2VsZWN0ZWQoZSwgbikge1xuICAgIHJldHVybiBlID09IHRoaXMuc2VsZWN0ZWQgfHwgZSA+PSB0aGlzLm9wdGlvbnMubGVuZ3RoID8gdGhpcyA6IG5ldyBnbyh0aGlzLm9wdGlvbnMsIEt2KG4sIGUpLCB0aGlzLnRvb2x0aXAsIHRoaXMudGltZXN0YW1wLCBlLCB0aGlzLmRpc2FibGVkKTtcbiAgfVxuICBzdGF0aWMgYnVpbGQoZSwgbiwgciwgaSwgcykge1xuICAgIGxldCBvID0geFooZSwgbik7XG4gICAgaWYgKCFvLmxlbmd0aClcbiAgICAgIHJldHVybiBpICYmIGUuc29tZShcbiAgICAgICAgKGwpID0+IGwuc3RhdGUgPT0gMVxuICAgICAgICAvKiBTdGF0ZS5QZW5kaW5nICovXG4gICAgICApID8gbmV3IGdvKGkub3B0aW9ucywgaS5hdHRycywgaS50b29sdGlwLCBpLnRpbWVzdGFtcCwgaS5zZWxlY3RlZCwgITApIDogbnVsbDtcbiAgICBsZXQgYSA9IG4uZmFjZXQoRnQpLnNlbGVjdE9uT3BlbiA/IDAgOiAtMTtcbiAgICBpZiAoaSAmJiBpLnNlbGVjdGVkICE9IGEgJiYgaS5zZWxlY3RlZCAhPSAtMSkge1xuICAgICAgbGV0IGwgPSBpLm9wdGlvbnNbaS5zZWxlY3RlZF0uY29tcGxldGlvbjtcbiAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgby5sZW5ndGg7IGMrKylcbiAgICAgICAgaWYgKG9bY10uY29tcGxldGlvbiA9PSBsKSB7XG4gICAgICAgICAgYSA9IGM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBnbyhvLCBLdihyLCBhKSwge1xuICAgICAgcG9zOiBlLnJlZHVjZSgobCwgYykgPT4gYy5oYXNSZXN1bHQoKSA/IE1hdGgubWluKGwsIGMuZnJvbSkgOiBsLCAxZTgpLFxuICAgICAgY3JlYXRlOiAkWixcbiAgICAgIGFib3ZlOiBzLmFib3ZlQ3Vyc29yXG4gICAgfSwgaSA/IGkudGltZXN0YW1wIDogRGF0ZS5ub3coKSwgYSwgITEpO1xuICB9XG4gIG1hcChlKSB7XG4gICAgcmV0dXJuIG5ldyBnbyh0aGlzLm9wdGlvbnMsIHRoaXMuYXR0cnMsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy50b29sdGlwKSwgeyBwb3M6IGUubWFwUG9zKHRoaXMudG9vbHRpcC5wb3MpIH0pLCB0aGlzLnRpbWVzdGFtcCwgdGhpcy5zZWxlY3RlZCwgdGhpcy5kaXNhYmxlZCk7XG4gIH1cbn1cbmNsYXNzIHF1IHtcbiAgY29uc3RydWN0b3IoZSwgbiwgcikge1xuICAgIHRoaXMuYWN0aXZlID0gZSwgdGhpcy5pZCA9IG4sIHRoaXMub3BlbiA9IHI7XG4gIH1cbiAgc3RhdGljIHN0YXJ0KCkge1xuICAgIHJldHVybiBuZXcgcXUoVFosIFwiY20tYWMtXCIgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyZTYpLnRvU3RyaW5nKDM2KSwgbnVsbCk7XG4gIH1cbiAgdXBkYXRlKGUpIHtcbiAgICBsZXQgeyBzdGF0ZTogbiB9ID0gZSwgciA9IG4uZmFjZXQoRnQpLCBzID0gKHIub3ZlcnJpZGUgfHwgbi5sYW5ndWFnZURhdGFBdChcImF1dG9jb21wbGV0ZVwiLCBKaShuKSkubWFwKG1aKSkubWFwKChhKSA9PiAodGhpcy5hY3RpdmUuZmluZCgoYykgPT4gYy5zb3VyY2UgPT0gYSkgfHwgbmV3IHduKFxuICAgICAgYSxcbiAgICAgIHRoaXMuYWN0aXZlLnNvbWUoXG4gICAgICAgIChjKSA9PiBjLnN0YXRlICE9IDBcbiAgICAgICAgLyogU3RhdGUuSW5hY3RpdmUgKi9cbiAgICAgICkgPyAxIDogMFxuICAgICAgLyogU3RhdGUuSW5hY3RpdmUgKi9cbiAgICApKS51cGRhdGUoZSwgcikpO1xuICAgIHMubGVuZ3RoID09IHRoaXMuYWN0aXZlLmxlbmd0aCAmJiBzLmV2ZXJ5KChhLCBsKSA9PiBhID09IHRoaXMuYWN0aXZlW2xdKSAmJiAocyA9IHRoaXMuYWN0aXZlKTtcbiAgICBsZXQgbyA9IHRoaXMub3BlbjtcbiAgICBvICYmIGUuZG9jQ2hhbmdlZCAmJiAobyA9IG8ubWFwKGUuY2hhbmdlcykpLCBlLnNlbGVjdGlvbiB8fCBzLnNvbWUoKGEpID0+IGEuaGFzUmVzdWx0KCkgJiYgZS5jaGFuZ2VzLnRvdWNoZXNSYW5nZShhLmZyb20sIGEudG8pKSB8fCAhUFoocywgdGhpcy5hY3RpdmUpID8gbyA9IGdvLmJ1aWxkKHMsIG4sIHRoaXMuaWQsIG8sIHIpIDogbyAmJiBvLmRpc2FibGVkICYmICFzLnNvbWUoXG4gICAgICAoYSkgPT4gYS5zdGF0ZSA9PSAxXG4gICAgICAvKiBTdGF0ZS5QZW5kaW5nICovXG4gICAgKSAmJiAobyA9IG51bGwpLCAhbyAmJiBzLmV2ZXJ5KFxuICAgICAgKGEpID0+IGEuc3RhdGUgIT0gMVxuICAgICAgLyogU3RhdGUuUGVuZGluZyAqL1xuICAgICkgJiYgcy5zb21lKChhKSA9PiBhLmhhc1Jlc3VsdCgpKSAmJiAocyA9IHMubWFwKChhKSA9PiBhLmhhc1Jlc3VsdCgpID8gbmV3IHduKFxuICAgICAgYS5zb3VyY2UsXG4gICAgICAwXG4gICAgICAvKiBTdGF0ZS5JbmFjdGl2ZSAqL1xuICAgICkgOiBhKSk7XG4gICAgZm9yIChsZXQgYSBvZiBlLmVmZmVjdHMpXG4gICAgICBhLmlzKGt4KSAmJiAobyA9IG8gJiYgby5zZXRTZWxlY3RlZChhLnZhbHVlLCB0aGlzLmlkKSk7XG4gICAgcmV0dXJuIHMgPT0gdGhpcy5hY3RpdmUgJiYgbyA9PSB0aGlzLm9wZW4gPyB0aGlzIDogbmV3IHF1KHMsIHRoaXMuaWQsIG8pO1xuICB9XG4gIGdldCB0b29sdGlwKCkge1xuICAgIHJldHVybiB0aGlzLm9wZW4gPyB0aGlzLm9wZW4udG9vbHRpcCA6IG51bGw7XG4gIH1cbiAgZ2V0IGF0dHJzKCkge1xuICAgIHJldHVybiB0aGlzLm9wZW4gPyB0aGlzLm9wZW4uYXR0cnMgOiBfWjtcbiAgfVxufVxuZnVuY3Rpb24gUFoodCwgZSkge1xuICBpZiAodCA9PSBlKVxuICAgIHJldHVybiAhMDtcbiAgZm9yIChsZXQgbiA9IDAsIHIgPSAwOyA7ICkge1xuICAgIGZvciAoOyBuIDwgdC5sZW5ndGggJiYgIXRbbl0uaGFzUmVzdWx0OyApXG4gICAgICBuKys7XG4gICAgZm9yICg7IHIgPCBlLmxlbmd0aCAmJiAhZVtyXS5oYXNSZXN1bHQ7IClcbiAgICAgIHIrKztcbiAgICBsZXQgaSA9IG4gPT0gdC5sZW5ndGgsIHMgPSByID09IGUubGVuZ3RoO1xuICAgIGlmIChpIHx8IHMpXG4gICAgICByZXR1cm4gaSA9PSBzO1xuICAgIGlmICh0W24rK10ucmVzdWx0ICE9IGVbcisrXS5yZXN1bHQpXG4gICAgICByZXR1cm4gITE7XG4gIH1cbn1cbmNvbnN0IF9aID0ge1xuICBcImFyaWEtYXV0b2NvbXBsZXRlXCI6IFwibGlzdFwiXG59O1xuZnVuY3Rpb24gS3YodCwgZSkge1xuICBsZXQgbiA9IHtcbiAgICBcImFyaWEtYXV0b2NvbXBsZXRlXCI6IFwibGlzdFwiLFxuICAgIFwiYXJpYS1oYXNwb3B1cFwiOiBcImxpc3Rib3hcIixcbiAgICBcImFyaWEtY29udHJvbHNcIjogdFxuICB9O1xuICByZXR1cm4gZSA+IC0xICYmIChuW1wiYXJpYS1hY3RpdmVkZXNjZW5kYW50XCJdID0gdCArIFwiLVwiICsgZSksIG47XG59XG5jb25zdCBUWiA9IFtdO1xuZnVuY3Rpb24gRXAodCkge1xuICByZXR1cm4gdC5pc1VzZXJFdmVudChcImlucHV0LnR5cGVcIikgPyBcImlucHV0XCIgOiB0LmlzVXNlckV2ZW50KFwiZGVsZXRlLmJhY2t3YXJkXCIpID8gXCJkZWxldGVcIiA6IG51bGw7XG59XG5jbGFzcyB3biB7XG4gIGNvbnN0cnVjdG9yKGUsIG4sIHIgPSAtMSkge1xuICAgIHRoaXMuc291cmNlID0gZSwgdGhpcy5zdGF0ZSA9IG4sIHRoaXMuZXhwbGljaXRQb3MgPSByO1xuICB9XG4gIGhhc1Jlc3VsdCgpIHtcbiAgICByZXR1cm4gITE7XG4gIH1cbiAgdXBkYXRlKGUsIG4pIHtcbiAgICBsZXQgciA9IEVwKGUpLCBpID0gdGhpcztcbiAgICByID8gaSA9IGkuaGFuZGxlVXNlckV2ZW50KGUsIHIsIG4pIDogZS5kb2NDaGFuZ2VkID8gaSA9IGkuaGFuZGxlQ2hhbmdlKGUpIDogZS5zZWxlY3Rpb24gJiYgaS5zdGF0ZSAhPSAwICYmIChpID0gbmV3IHduKFxuICAgICAgaS5zb3VyY2UsXG4gICAgICAwXG4gICAgICAvKiBTdGF0ZS5JbmFjdGl2ZSAqL1xuICAgICkpO1xuICAgIGZvciAobGV0IHMgb2YgZS5lZmZlY3RzKVxuICAgICAgaWYgKHMuaXMoVXUpKVxuICAgICAgICBpID0gbmV3IHduKGkuc291cmNlLCAxLCBzLnZhbHVlID8gSmkoZS5zdGF0ZSkgOiAtMSk7XG4gICAgICBlbHNlIGlmIChzLmlzKFNsKSlcbiAgICAgICAgaSA9IG5ldyB3bihcbiAgICAgICAgICBpLnNvdXJjZSxcbiAgICAgICAgICAwXG4gICAgICAgICAgLyogU3RhdGUuSW5hY3RpdmUgKi9cbiAgICAgICAgKTtcbiAgICAgIGVsc2UgaWYgKHMuaXMod3gpKVxuICAgICAgICBmb3IgKGxldCBvIG9mIHMudmFsdWUpXG4gICAgICAgICAgby5zb3VyY2UgPT0gaS5zb3VyY2UgJiYgKGkgPSBvKTtcbiAgICByZXR1cm4gaTtcbiAgfVxuICBoYW5kbGVVc2VyRXZlbnQoZSwgbiwgcikge1xuICAgIHJldHVybiBuID09IFwiZGVsZXRlXCIgfHwgIXIuYWN0aXZhdGVPblR5cGluZyA/IHRoaXMubWFwKGUuY2hhbmdlcykgOiBuZXcgd24oXG4gICAgICB0aGlzLnNvdXJjZSxcbiAgICAgIDFcbiAgICAgIC8qIFN0YXRlLlBlbmRpbmcgKi9cbiAgICApO1xuICB9XG4gIGhhbmRsZUNoYW5nZShlKSB7XG4gICAgcmV0dXJuIGUuY2hhbmdlcy50b3VjaGVzUmFuZ2UoSmkoZS5zdGFydFN0YXRlKSkgPyBuZXcgd24oXG4gICAgICB0aGlzLnNvdXJjZSxcbiAgICAgIDBcbiAgICAgIC8qIFN0YXRlLkluYWN0aXZlICovXG4gICAgKSA6IHRoaXMubWFwKGUuY2hhbmdlcyk7XG4gIH1cbiAgbWFwKGUpIHtcbiAgICByZXR1cm4gZS5lbXB0eSB8fCB0aGlzLmV4cGxpY2l0UG9zIDwgMCA/IHRoaXMgOiBuZXcgd24odGhpcy5zb3VyY2UsIHRoaXMuc3RhdGUsIGUubWFwUG9zKHRoaXMuZXhwbGljaXRQb3MpKTtcbiAgfVxufVxuY2xhc3MgUW8gZXh0ZW5kcyB3biB7XG4gIGNvbnN0cnVjdG9yKGUsIG4sIHIsIGksIHMpIHtcbiAgICBzdXBlcihlLCAyLCBuKSwgdGhpcy5yZXN1bHQgPSByLCB0aGlzLmZyb20gPSBpLCB0aGlzLnRvID0gcztcbiAgfVxuICBoYXNSZXN1bHQoKSB7XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIGhhbmRsZVVzZXJFdmVudChlLCBuLCByKSB7XG4gICAgdmFyIGk7XG4gICAgbGV0IHMgPSBlLmNoYW5nZXMubWFwUG9zKHRoaXMuZnJvbSksIG8gPSBlLmNoYW5nZXMubWFwUG9zKHRoaXMudG8sIDEpLCBhID0gSmkoZS5zdGF0ZSk7XG4gICAgaWYgKCh0aGlzLmV4cGxpY2l0UG9zIDwgMCA/IGEgPD0gcyA6IGEgPCB0aGlzLmZyb20pIHx8IGEgPiBvIHx8IG4gPT0gXCJkZWxldGVcIiAmJiBKaShlLnN0YXJ0U3RhdGUpID09IHRoaXMuZnJvbSlcbiAgICAgIHJldHVybiBuZXcgd24oXG4gICAgICAgIHRoaXMuc291cmNlLFxuICAgICAgICBuID09IFwiaW5wdXRcIiAmJiByLmFjdGl2YXRlT25UeXBpbmcgPyAxIDogMFxuICAgICAgICAvKiBTdGF0ZS5JbmFjdGl2ZSAqL1xuICAgICAgKTtcbiAgICBsZXQgbCA9IHRoaXMuZXhwbGljaXRQb3MgPCAwID8gLTEgOiBlLmNoYW5nZXMubWFwUG9zKHRoaXMuZXhwbGljaXRQb3MpLCBjO1xuICAgIHJldHVybiBFWih0aGlzLnJlc3VsdC52YWxpZEZvciwgZS5zdGF0ZSwgcywgbykgPyBuZXcgUW8odGhpcy5zb3VyY2UsIGwsIHRoaXMucmVzdWx0LCBzLCBvKSA6IHRoaXMucmVzdWx0LnVwZGF0ZSAmJiAoYyA9IHRoaXMucmVzdWx0LnVwZGF0ZSh0aGlzLnJlc3VsdCwgcywgbywgbmV3IGJ4KGUuc3RhdGUsIGEsIGwgPj0gMCkpKSA/IG5ldyBRbyh0aGlzLnNvdXJjZSwgbCwgYywgYy5mcm9tLCAoaSA9IGMudG8pICE9PSBudWxsICYmIGkgIT09IHZvaWQgMCA/IGkgOiBKaShlLnN0YXRlKSkgOiBuZXcgd24odGhpcy5zb3VyY2UsIDEsIGwpO1xuICB9XG4gIGhhbmRsZUNoYW5nZShlKSB7XG4gICAgcmV0dXJuIGUuY2hhbmdlcy50b3VjaGVzUmFuZ2UodGhpcy5mcm9tLCB0aGlzLnRvKSA/IG5ldyB3bihcbiAgICAgIHRoaXMuc291cmNlLFxuICAgICAgMFxuICAgICAgLyogU3RhdGUuSW5hY3RpdmUgKi9cbiAgICApIDogdGhpcy5tYXAoZS5jaGFuZ2VzKTtcbiAgfVxuICBtYXAoZSkge1xuICAgIHJldHVybiBlLmVtcHR5ID8gdGhpcyA6IG5ldyBRbyh0aGlzLnNvdXJjZSwgdGhpcy5leHBsaWNpdFBvcyA8IDAgPyAtMSA6IGUubWFwUG9zKHRoaXMuZXhwbGljaXRQb3MpLCB0aGlzLnJlc3VsdCwgZS5tYXBQb3ModGhpcy5mcm9tKSwgZS5tYXBQb3ModGhpcy50bywgMSkpO1xuICB9XG59XG5mdW5jdGlvbiBFWih0LCBlLCBuLCByKSB7XG4gIGlmICghdClcbiAgICByZXR1cm4gITE7XG4gIGxldCBpID0gZS5zbGljZURvYyhuLCByKTtcbiAgcmV0dXJuIHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIiA/IHQoaSwgbiwgciwgZSkgOiB5eCh0LCAhMCkudGVzdChpKTtcbn1cbmNvbnN0IHd4ID0gLyogQF9fUFVSRV9fICovIG90LmRlZmluZSh7XG4gIG1hcCh0LCBlKSB7XG4gICAgcmV0dXJuIHQubWFwKChuKSA9PiBuLm1hcChlKSk7XG4gIH1cbn0pLCBreCA9IC8qIEBfX1BVUkVfXyAqLyBvdC5kZWZpbmUoKSwgWm4gPSAvKiBAX19QVVJFX18gKi8geXIuZGVmaW5lKHtcbiAgY3JlYXRlKCkge1xuICAgIHJldHVybiBxdS5zdGFydCgpO1xuICB9LFxuICB1cGRhdGUodCwgZSkge1xuICAgIHJldHVybiB0LnVwZGF0ZShlKTtcbiAgfSxcbiAgcHJvdmlkZTogKHQpID0+IFtcbiAgICBZay5mcm9tKHQsIChlKSA9PiBlLnRvb2x0aXApLFxuICAgIFNlLmNvbnRlbnRBdHRyaWJ1dGVzLmZyb20odCwgKGUpID0+IGUuYXR0cnMpXG4gIF1cbn0pO1xuZnVuY3Rpb24geHgodCwgZSkge1xuICBjb25zdCBuID0gZS5jb21wbGV0aW9uLmFwcGx5IHx8IGUuY29tcGxldGlvbi5sYWJlbDtcbiAgbGV0IHIgPSB0LnN0YXRlLmZpZWxkKFpuKS5hY3RpdmUuZmluZCgoaSkgPT4gaS5zb3VyY2UgPT0gZS5zb3VyY2UpO1xuICByZXR1cm4gciBpbnN0YW5jZW9mIFFvID8gKHR5cGVvZiBuID09IFwic3RyaW5nXCIgPyB0LmRpc3BhdGNoKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZ1oodC5zdGF0ZSwgbiwgci5mcm9tLCByLnRvKSksIHsgYW5ub3RhdGlvbnM6IFN4Lm9mKGUuY29tcGxldGlvbikgfSkpIDogbih0LCBlLmNvbXBsZXRpb24sIHIuZnJvbSwgci50byksICEwKSA6ICExO1xufVxuY29uc3QgJFogPSAvKiBAX19QVVJFX18gKi8gd1ooWm4sIHh4KTtcbmZ1bmN0aW9uIFdjKHQsIGUgPSBcIm9wdGlvblwiKSB7XG4gIHJldHVybiAobikgPT4ge1xuICAgIGxldCByID0gbi5zdGF0ZS5maWVsZChabiwgITEpO1xuICAgIGlmICghciB8fCAhci5vcGVuIHx8IHIub3Blbi5kaXNhYmxlZCB8fCBEYXRlLm5vdygpIC0gci5vcGVuLnRpbWVzdGFtcCA8IG4uc3RhdGUuZmFjZXQoRnQpLmludGVyYWN0aW9uRGVsYXkpXG4gICAgICByZXR1cm4gITE7XG4gICAgbGV0IGkgPSAxLCBzO1xuICAgIGUgPT0gXCJwYWdlXCIgJiYgKHMgPSB6ayhuLCByLm9wZW4udG9vbHRpcCkpICYmIChpID0gTWF0aC5tYXgoMiwgTWF0aC5mbG9vcihzLmRvbS5vZmZzZXRIZWlnaHQgLyBzLmRvbS5xdWVyeVNlbGVjdG9yKFwibGlcIikub2Zmc2V0SGVpZ2h0KSAtIDEpKTtcbiAgICBsZXQgeyBsZW5ndGg6IG8gfSA9IHIub3Blbi5vcHRpb25zLCBhID0gci5vcGVuLnNlbGVjdGVkID4gLTEgPyByLm9wZW4uc2VsZWN0ZWQgKyBpICogKHQgPyAxIDogLTEpIDogdCA/IDAgOiBvIC0gMTtcbiAgICByZXR1cm4gYSA8IDAgPyBhID0gZSA9PSBcInBhZ2VcIiA/IDAgOiBvIC0gMSA6IGEgPj0gbyAmJiAoYSA9IGUgPT0gXCJwYWdlXCIgPyBvIC0gMSA6IDApLCBuLmRpc3BhdGNoKHsgZWZmZWN0czoga3gub2YoYSkgfSksICEwO1xuICB9O1xufVxuY29uc3QgUVogPSAodCkgPT4ge1xuICBsZXQgZSA9IHQuc3RhdGUuZmllbGQoWm4sICExKTtcbiAgcmV0dXJuIHQuc3RhdGUucmVhZE9ubHkgfHwgIWUgfHwgIWUub3BlbiB8fCBlLm9wZW4uc2VsZWN0ZWQgPCAwIHx8IGUub3Blbi5kaXNhYmxlZCB8fCBEYXRlLm5vdygpIC0gZS5vcGVuLnRpbWVzdGFtcCA8IHQuc3RhdGUuZmFjZXQoRnQpLmludGVyYWN0aW9uRGVsYXkgPyAhMSA6IHh4KHQsIGUub3Blbi5vcHRpb25zW2Uub3Blbi5zZWxlY3RlZF0pO1xufSwgQ1ogPSAodCkgPT4gdC5zdGF0ZS5maWVsZChabiwgITEpID8gKHQuZGlzcGF0Y2goeyBlZmZlY3RzOiBVdS5vZighMCkgfSksICEwKSA6ICExLCBBWiA9ICh0KSA9PiB7XG4gIGxldCBlID0gdC5zdGF0ZS5maWVsZChabiwgITEpO1xuICByZXR1cm4gIWUgfHwgIWUuYWN0aXZlLnNvbWUoXG4gICAgKG4pID0+IG4uc3RhdGUgIT0gMFxuICAgIC8qIFN0YXRlLkluYWN0aXZlICovXG4gICkgPyAhMSA6ICh0LmRpc3BhdGNoKHsgZWZmZWN0czogU2wub2YobnVsbCkgfSksICEwKTtcbn07XG5jbGFzcyBSWiB7XG4gIGNvbnN0cnVjdG9yKGUsIG4pIHtcbiAgICB0aGlzLmFjdGl2ZSA9IGUsIHRoaXMuY29udGV4dCA9IG4sIHRoaXMudGltZSA9IERhdGUubm93KCksIHRoaXMudXBkYXRlcyA9IFtdLCB0aGlzLmRvbmUgPSB2b2lkIDA7XG4gIH1cbn1cbmNvbnN0IE5aID0gNTAsIERaID0gMWUzLCBaWiA9IC8qIEBfX1BVUkVfXyAqLyByci5mcm9tQ2xhc3MoY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih0KSB7XG4gICAgdGhpcy52aWV3ID0gdCwgdGhpcy5kZWJvdW5jZVVwZGF0ZSA9IC0xLCB0aGlzLnJ1bm5pbmcgPSBbXSwgdGhpcy5kZWJvdW5jZUFjY2VwdCA9IC0xLCB0aGlzLnBlbmRpbmdTdGFydCA9ICExLCB0aGlzLmNvbXBvc2luZyA9IDA7XG4gICAgZm9yIChsZXQgZSBvZiB0LnN0YXRlLmZpZWxkKFpuKS5hY3RpdmUpXG4gICAgICBlLnN0YXRlID09IDEgJiYgdGhpcy5zdGFydFF1ZXJ5KGUpO1xuICB9XG4gIHVwZGF0ZSh0KSB7XG4gICAgbGV0IGUgPSB0LnN0YXRlLmZpZWxkKFpuKTtcbiAgICBpZiAoIXQuc2VsZWN0aW9uU2V0ICYmICF0LmRvY0NoYW5nZWQgJiYgdC5zdGFydFN0YXRlLmZpZWxkKFpuKSA9PSBlKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCBuID0gdC50cmFuc2FjdGlvbnMuc29tZSgoaSkgPT4gKGkuc2VsZWN0aW9uIHx8IGkuZG9jQ2hhbmdlZCkgJiYgIUVwKGkpKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucnVubmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHMgPSB0aGlzLnJ1bm5pbmdbaV07XG4gICAgICBpZiAobiB8fCBzLnVwZGF0ZXMubGVuZ3RoICsgdC50cmFuc2FjdGlvbnMubGVuZ3RoID4gTlogJiYgRGF0ZS5ub3coKSAtIHMudGltZSA+IERaKSB7XG4gICAgICAgIGZvciAobGV0IG8gb2Ygcy5jb250ZXh0LmFib3J0TGlzdGVuZXJzKVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvKCk7XG4gICAgICAgICAgfSBjYXRjaCAoYSkge1xuICAgICAgICAgICAgaHIodGhpcy52aWV3LnN0YXRlLCBhKTtcbiAgICAgICAgICB9XG4gICAgICAgIHMuY29udGV4dC5hYm9ydExpc3RlbmVycyA9IG51bGwsIHRoaXMucnVubmluZy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBzLnVwZGF0ZXMucHVzaCguLi50LnRyYW5zYWN0aW9ucyk7XG4gICAgfVxuICAgIHRoaXMuZGVib3VuY2VVcGRhdGUgPiAtMSAmJiBjbGVhclRpbWVvdXQodGhpcy5kZWJvdW5jZVVwZGF0ZSksIHQudHJhbnNhY3Rpb25zLnNvbWUoKGkpID0+IGkuZWZmZWN0cy5zb21lKChzKSA9PiBzLmlzKFV1KSkpICYmICh0aGlzLnBlbmRpbmdTdGFydCA9ICEwKTtcbiAgICBsZXQgciA9IHRoaXMucGVuZGluZ1N0YXJ0ID8gNTAgOiB0LnN0YXRlLmZhY2V0KEZ0KS5hY3RpdmF0ZU9uVHlwaW5nRGVsYXk7XG4gICAgaWYgKHRoaXMuZGVib3VuY2VVcGRhdGUgPSBlLmFjdGl2ZS5zb21lKChpKSA9PiBpLnN0YXRlID09IDEgJiYgIXRoaXMucnVubmluZy5zb21lKChzKSA9PiBzLmFjdGl2ZS5zb3VyY2UgPT0gaS5zb3VyY2UpKSA/IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zdGFydFVwZGF0ZSgpLCByKSA6IC0xLCB0aGlzLmNvbXBvc2luZyAhPSAwKVxuICAgICAgZm9yIChsZXQgaSBvZiB0LnRyYW5zYWN0aW9ucylcbiAgICAgICAgRXAoaSkgPT0gXCJpbnB1dFwiID8gdGhpcy5jb21wb3NpbmcgPSAyIDogdGhpcy5jb21wb3NpbmcgPT0gMiAmJiBpLnNlbGVjdGlvbiAmJiAodGhpcy5jb21wb3NpbmcgPSAzKTtcbiAgfVxuICBzdGFydFVwZGF0ZSgpIHtcbiAgICB0aGlzLmRlYm91bmNlVXBkYXRlID0gLTEsIHRoaXMucGVuZGluZ1N0YXJ0ID0gITE7XG4gICAgbGV0IHsgc3RhdGU6IHQgfSA9IHRoaXMudmlldywgZSA9IHQuZmllbGQoWm4pO1xuICAgIGZvciAobGV0IG4gb2YgZS5hY3RpdmUpXG4gICAgICBuLnN0YXRlID09IDEgJiYgIXRoaXMucnVubmluZy5zb21lKChyKSA9PiByLmFjdGl2ZS5zb3VyY2UgPT0gbi5zb3VyY2UpICYmIHRoaXMuc3RhcnRRdWVyeShuKTtcbiAgfVxuICBzdGFydFF1ZXJ5KHQpIHtcbiAgICBsZXQgeyBzdGF0ZTogZSB9ID0gdGhpcy52aWV3LCBuID0gSmkoZSksIHIgPSBuZXcgYngoZSwgbiwgdC5leHBsaWNpdFBvcyA9PSBuKSwgaSA9IG5ldyBSWih0LCByKTtcbiAgICB0aGlzLnJ1bm5pbmcucHVzaChpKSwgUHJvbWlzZS5yZXNvbHZlKHQuc291cmNlKHIpKS50aGVuKChzKSA9PiB7XG4gICAgICBpLmNvbnRleHQuYWJvcnRlZCB8fCAoaS5kb25lID0gcyB8fCBudWxsLCB0aGlzLnNjaGVkdWxlQWNjZXB0KCkpO1xuICAgIH0sIChzKSA9PiB7XG4gICAgICB0aGlzLnZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBTbC5vZihudWxsKSB9KSwgaHIodGhpcy52aWV3LnN0YXRlLCBzKTtcbiAgICB9KTtcbiAgfVxuICBzY2hlZHVsZUFjY2VwdCgpIHtcbiAgICB0aGlzLnJ1bm5pbmcuZXZlcnkoKHQpID0+IHQuZG9uZSAhPT0gdm9pZCAwKSA/IHRoaXMuYWNjZXB0KCkgOiB0aGlzLmRlYm91bmNlQWNjZXB0IDwgMCAmJiAodGhpcy5kZWJvdW5jZUFjY2VwdCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5hY2NlcHQoKSwgdGhpcy52aWV3LnN0YXRlLmZhY2V0KEZ0KS51cGRhdGVTeW5jVGltZSkpO1xuICB9XG4gIC8vIEZvciBlYWNoIGZpbmlzaGVkIHF1ZXJ5IGluIHRoaXMucnVubmluZywgdHJ5IHRvIGNyZWF0ZSBhIHJlc3VsdFxuICAvLyBvciwgaWYgYXBwcm9wcmlhdGUsIHJlc3RhcnQgdGhlIHF1ZXJ5LlxuICBhY2NlcHQoKSB7XG4gICAgdmFyIHQ7XG4gICAgdGhpcy5kZWJvdW5jZUFjY2VwdCA+IC0xICYmIGNsZWFyVGltZW91dCh0aGlzLmRlYm91bmNlQWNjZXB0KSwgdGhpcy5kZWJvdW5jZUFjY2VwdCA9IC0xO1xuICAgIGxldCBlID0gW10sIG4gPSB0aGlzLnZpZXcuc3RhdGUuZmFjZXQoRnQpO1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgdGhpcy5ydW5uaW5nLmxlbmd0aDsgcisrKSB7XG4gICAgICBsZXQgaSA9IHRoaXMucnVubmluZ1tyXTtcbiAgICAgIGlmIChpLmRvbmUgPT09IHZvaWQgMClcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAodGhpcy5ydW5uaW5nLnNwbGljZShyLS0sIDEpLCBpLmRvbmUpIHtcbiAgICAgICAgbGV0IG8gPSBuZXcgUW8oaS5hY3RpdmUuc291cmNlLCBpLmFjdGl2ZS5leHBsaWNpdFBvcywgaS5kb25lLCBpLmRvbmUuZnJvbSwgKHQgPSBpLmRvbmUudG8pICE9PSBudWxsICYmIHQgIT09IHZvaWQgMCA/IHQgOiBKaShpLnVwZGF0ZXMubGVuZ3RoID8gaS51cGRhdGVzWzBdLnN0YXJ0U3RhdGUgOiB0aGlzLnZpZXcuc3RhdGUpKTtcbiAgICAgICAgZm9yIChsZXQgYSBvZiBpLnVwZGF0ZXMpXG4gICAgICAgICAgbyA9IG8udXBkYXRlKGEsIG4pO1xuICAgICAgICBpZiAoby5oYXNSZXN1bHQoKSkge1xuICAgICAgICAgIGUucHVzaChvKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IHMgPSB0aGlzLnZpZXcuc3RhdGUuZmllbGQoWm4pLmFjdGl2ZS5maW5kKChvKSA9PiBvLnNvdXJjZSA9PSBpLmFjdGl2ZS5zb3VyY2UpO1xuICAgICAgaWYgKHMgJiYgcy5zdGF0ZSA9PSAxKVxuICAgICAgICBpZiAoaS5kb25lID09IG51bGwpIHtcbiAgICAgICAgICBsZXQgbyA9IG5ldyB3bihcbiAgICAgICAgICAgIGkuYWN0aXZlLnNvdXJjZSxcbiAgICAgICAgICAgIDBcbiAgICAgICAgICAgIC8qIFN0YXRlLkluYWN0aXZlICovXG4gICAgICAgICAgKTtcbiAgICAgICAgICBmb3IgKGxldCBhIG9mIGkudXBkYXRlcylcbiAgICAgICAgICAgIG8gPSBvLnVwZGF0ZShhLCBuKTtcbiAgICAgICAgICBvLnN0YXRlICE9IDEgJiYgZS5wdXNoKG8pO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICB0aGlzLnN0YXJ0UXVlcnkocyk7XG4gICAgfVxuICAgIGUubGVuZ3RoICYmIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IHd4Lm9mKGUpIH0pO1xuICB9XG59LCB7XG4gIGV2ZW50SGFuZGxlcnM6IHtcbiAgICBibHVyKHQpIHtcbiAgICAgIGxldCBlID0gdGhpcy52aWV3LnN0YXRlLmZpZWxkKFpuLCAhMSk7XG4gICAgICBpZiAoZSAmJiBlLnRvb2x0aXAgJiYgdGhpcy52aWV3LnN0YXRlLmZhY2V0KEZ0KS5jbG9zZU9uQmx1cikge1xuICAgICAgICBsZXQgbiA9IGUub3BlbiAmJiB6ayh0aGlzLnZpZXcsIGUub3Blbi50b29sdGlwKTtcbiAgICAgICAgKCFuIHx8ICFuLmRvbS5jb250YWlucyh0LnJlbGF0ZWRUYXJnZXQpKSAmJiBzZXRUaW1lb3V0KCgpID0+IHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IFNsLm9mKG51bGwpIH0pLCAxMCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjb21wb3NpdGlvbnN0YXJ0KCkge1xuICAgICAgdGhpcy5jb21wb3NpbmcgPSAxO1xuICAgIH0sXG4gICAgY29tcG9zaXRpb25lbmQoKSB7XG4gICAgICB0aGlzLmNvbXBvc2luZyA9PSAzICYmIHNldFRpbWVvdXQoKCkgPT4gdGhpcy52aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogVXUub2YoITEpIH0pLCAyMCksIHRoaXMuY29tcG9zaW5nID0gMDtcbiAgICB9XG4gIH1cbn0pLCBQeCA9IC8qIEBfX1BVUkVfXyAqLyBTZS5iYXNlVGhlbWUoe1xuICBcIi5jbS10b29sdGlwLmNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlXCI6IHtcbiAgICBcIiYgPiB1bFwiOiB7XG4gICAgICBmb250RmFtaWx5OiBcIm1vbm9zcGFjZVwiLFxuICAgICAgd2hpdGVTcGFjZTogXCJub3dyYXBcIixcbiAgICAgIG92ZXJmbG93OiBcImhpZGRlbiBhdXRvXCIsXG4gICAgICBtYXhXaWR0aF9mYWxsYmFjazogXCI3MDBweFwiLFxuICAgICAgbWF4V2lkdGg6IFwibWluKDcwMHB4LCA5NXZ3KVwiLFxuICAgICAgbWluV2lkdGg6IFwiMjUwcHhcIixcbiAgICAgIG1heEhlaWdodDogXCIxMGVtXCIsXG4gICAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgICAgbGlzdFN0eWxlOiBcIm5vbmVcIixcbiAgICAgIG1hcmdpbjogMCxcbiAgICAgIHBhZGRpbmc6IDAsXG4gICAgICBcIiYgPiBsaSwgJiA+IGNvbXBsZXRpb24tc2VjdGlvblwiOiB7XG4gICAgICAgIHBhZGRpbmc6IFwiMXB4IDNweFwiLFxuICAgICAgICBsaW5lSGVpZ2h0OiAxLjJcbiAgICAgIH0sXG4gICAgICBcIiYgPiBsaVwiOiB7XG4gICAgICAgIG92ZXJmbG93WDogXCJoaWRkZW5cIixcbiAgICAgICAgdGV4dE92ZXJmbG93OiBcImVsbGlwc2lzXCIsXG4gICAgICAgIGN1cnNvcjogXCJwb2ludGVyXCJcbiAgICAgIH0sXG4gICAgICBcIiYgPiBjb21wbGV0aW9uLXNlY3Rpb25cIjoge1xuICAgICAgICBkaXNwbGF5OiBcImxpc3QtaXRlbVwiLFxuICAgICAgICBib3JkZXJCb3R0b206IFwiMXB4IHNvbGlkIHNpbHZlclwiLFxuICAgICAgICBwYWRkaW5nTGVmdDogXCIwLjVlbVwiLFxuICAgICAgICBvcGFjaXR5OiAwLjdcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIFwiJmxpZ2h0IC5jbS10b29sdGlwLWF1dG9jb21wbGV0ZSB1bCBsaVthcmlhLXNlbGVjdGVkXVwiOiB7XG4gICAgYmFja2dyb3VuZDogXCIjMTdjXCIsXG4gICAgY29sb3I6IFwid2hpdGVcIlxuICB9LFxuICBcIiZsaWdodCAuY20tdG9vbHRpcC1hdXRvY29tcGxldGUtZGlzYWJsZWQgdWwgbGlbYXJpYS1zZWxlY3RlZF1cIjoge1xuICAgIGJhY2tncm91bmQ6IFwiIzc3N1wiXG4gIH0sXG4gIFwiJmRhcmsgLmNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlIHVsIGxpW2FyaWEtc2VsZWN0ZWRdXCI6IHtcbiAgICBiYWNrZ3JvdW5kOiBcIiMzNDdcIixcbiAgICBjb2xvcjogXCJ3aGl0ZVwiXG4gIH0sXG4gIFwiJmRhcmsgLmNtLXRvb2x0aXAtYXV0b2NvbXBsZXRlLWRpc2FibGVkIHVsIGxpW2FyaWEtc2VsZWN0ZWRdXCI6IHtcbiAgICBiYWNrZ3JvdW5kOiBcIiM0NDRcIlxuICB9LFxuICBcIi5jbS1jb21wbGV0aW9uTGlzdEluY29tcGxldGVUb3A6YmVmb3JlLCAuY20tY29tcGxldGlvbkxpc3RJbmNvbXBsZXRlQm90dG9tOmFmdGVyXCI6IHtcbiAgICBjb250ZW50OiAnXCLCt8K3wrdcIicsXG4gICAgb3BhY2l0eTogMC41LFxuICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICB0ZXh0QWxpZ246IFwiY2VudGVyXCJcbiAgfSxcbiAgXCIuY20tdG9vbHRpcC5jbS1jb21wbGV0aW9uSW5mb1wiOiB7XG4gICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIixcbiAgICBwYWRkaW5nOiBcIjNweCA5cHhcIixcbiAgICB3aWR0aDogXCJtYXgtY29udGVudFwiLFxuICAgIG1heFdpZHRoOiBcIjQwMHB4XCIsXG4gICAgYm94U2l6aW5nOiBcImJvcmRlci1ib3hcIlxuICB9LFxuICBcIi5jbS1jb21wbGV0aW9uSW5mby5jbS1jb21wbGV0aW9uSW5mby1sZWZ0XCI6IHsgcmlnaHQ6IFwiMTAwJVwiIH0sXG4gIFwiLmNtLWNvbXBsZXRpb25JbmZvLmNtLWNvbXBsZXRpb25JbmZvLXJpZ2h0XCI6IHsgbGVmdDogXCIxMDAlXCIgfSxcbiAgXCIuY20tY29tcGxldGlvbkluZm8uY20tY29tcGxldGlvbkluZm8tbGVmdC1uYXJyb3dcIjogeyByaWdodDogXCIzMHB4XCIgfSxcbiAgXCIuY20tY29tcGxldGlvbkluZm8uY20tY29tcGxldGlvbkluZm8tcmlnaHQtbmFycm93XCI6IHsgbGVmdDogXCIzMHB4XCIgfSxcbiAgXCImbGlnaHQgLmNtLXNuaXBwZXRGaWVsZFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjMDAwMDAwMjJcIiB9LFxuICBcIiZkYXJrIC5jbS1zbmlwcGV0RmllbGRcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2ZmZmZmZjIyXCIgfSxcbiAgXCIuY20tc25pcHBldEZpZWxkUG9zaXRpb25cIjoge1xuICAgIHZlcnRpY2FsQWxpZ246IFwidGV4dC10b3BcIixcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IFwiMS4xNWVtXCIsXG4gICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIixcbiAgICBtYXJnaW46IFwiMCAtMC43cHggLS43ZW1cIixcbiAgICBib3JkZXJMZWZ0OiBcIjEuNHB4IGRvdHRlZCAjODg4XCJcbiAgfSxcbiAgXCIuY20tY29tcGxldGlvbk1hdGNoZWRUZXh0XCI6IHtcbiAgICB0ZXh0RGVjb3JhdGlvbjogXCJ1bmRlcmxpbmVcIlxuICB9LFxuICBcIi5jbS1jb21wbGV0aW9uRGV0YWlsXCI6IHtcbiAgICBtYXJnaW5MZWZ0OiBcIjAuNWVtXCIsXG4gICAgZm9udFN0eWxlOiBcIml0YWxpY1wiXG4gIH0sXG4gIFwiLmNtLWNvbXBsZXRpb25JY29uXCI6IHtcbiAgICBmb250U2l6ZTogXCI5MCVcIixcbiAgICB3aWR0aDogXCIuOGVtXCIsXG4gICAgZGlzcGxheTogXCJpbmxpbmUtYmxvY2tcIixcbiAgICB0ZXh0QWxpZ246IFwiY2VudGVyXCIsXG4gICAgcGFkZGluZ1JpZ2h0OiBcIi42ZW1cIixcbiAgICBvcGFjaXR5OiBcIjAuNlwiLFxuICAgIGJveFNpemluZzogXCJjb250ZW50LWJveFwiXG4gIH0sXG4gIFwiLmNtLWNvbXBsZXRpb25JY29uLWZ1bmN0aW9uLCAuY20tY29tcGxldGlvbkljb24tbWV0aG9kXCI6IHtcbiAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifGkidcIiB9XG4gIH0sXG4gIFwiLmNtLWNvbXBsZXRpb25JY29uLWNsYXNzXCI6IHtcbiAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifil4snXCIgfVxuICB9LFxuICBcIi5jbS1jb21wbGV0aW9uSWNvbi1pbnRlcmZhY2VcIjoge1xuICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ+KXjCdcIiB9XG4gIH0sXG4gIFwiLmNtLWNvbXBsZXRpb25JY29uLXZhcmlhYmxlXCI6IHtcbiAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifwnZGlJ1wiIH1cbiAgfSxcbiAgXCIuY20tY29tcGxldGlvbkljb24tY29uc3RhbnRcIjoge1xuICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ/CdkLYnXCIgfVxuICB9LFxuICBcIi5jbS1jb21wbGV0aW9uSWNvbi10eXBlXCI6IHtcbiAgICBcIiY6YWZ0ZXJcIjogeyBjb250ZW50OiBcIifwnZGhJ1wiIH1cbiAgfSxcbiAgXCIuY20tY29tcGxldGlvbkljb24tZW51bVwiOiB7XG4gICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn4oiqJ1wiIH1cbiAgfSxcbiAgXCIuY20tY29tcGxldGlvbkljb24tcHJvcGVydHlcIjoge1xuICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ+KWoSdcIiB9XG4gIH0sXG4gIFwiLmNtLWNvbXBsZXRpb25JY29uLWtleXdvcmRcIjoge1xuICAgIFwiJjphZnRlclwiOiB7IGNvbnRlbnQ6IFwiJ/CflJHvuI4nXCIgfVxuICAgIC8vIERpc2FibGUgZW1vamkgcmVuZGVyaW5nXG4gIH0sXG4gIFwiLmNtLWNvbXBsZXRpb25JY29uLW5hbWVzcGFjZVwiOiB7XG4gICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCIn4paiJ1wiIH1cbiAgfSxcbiAgXCIuY20tY29tcGxldGlvbkljb24tdGV4dFwiOiB7XG4gICAgXCImOmFmdGVyXCI6IHsgY29udGVudDogXCInYWJjJ1wiLCBmb250U2l6ZTogXCI1MCVcIiwgdmVydGljYWxBbGlnbjogXCJtaWRkbGVcIiB9XG4gIH1cbn0pO1xuY2xhc3MgVloge1xuICBjb25zdHJ1Y3RvcihlLCBuLCByLCBpKSB7XG4gICAgdGhpcy5maWVsZCA9IGUsIHRoaXMubGluZSA9IG4sIHRoaXMuZnJvbSA9IHIsIHRoaXMudG8gPSBpO1xuICB9XG59XG5jbGFzcyBiZyB7XG4gIGNvbnN0cnVjdG9yKGUsIG4sIHIpIHtcbiAgICB0aGlzLmZpZWxkID0gZSwgdGhpcy5mcm9tID0gbiwgdGhpcy50byA9IHI7XG4gIH1cbiAgbWFwKGUpIHtcbiAgICBsZXQgbiA9IGUubWFwUG9zKHRoaXMuZnJvbSwgLTEsIG9uLlRyYWNrRGVsKSwgciA9IGUubWFwUG9zKHRoaXMudG8sIDEsIG9uLlRyYWNrRGVsKTtcbiAgICByZXR1cm4gbiA9PSBudWxsIHx8IHIgPT0gbnVsbCA/IG51bGwgOiBuZXcgYmcodGhpcy5maWVsZCwgbiwgcik7XG4gIH1cbn1cbmNsYXNzIHZnIHtcbiAgY29uc3RydWN0b3IoZSwgbikge1xuICAgIHRoaXMubGluZXMgPSBlLCB0aGlzLmZpZWxkUG9zaXRpb25zID0gbjtcbiAgfVxuICBpbnN0YW50aWF0ZShlLCBuKSB7XG4gICAgbGV0IHIgPSBbXSwgaSA9IFtuXSwgcyA9IGUuZG9jLmxpbmVBdChuKSwgbyA9IC9eXFxzKi8uZXhlYyhzLnRleHQpWzBdO1xuICAgIGZvciAobGV0IGwgb2YgdGhpcy5saW5lcykge1xuICAgICAgaWYgKHIubGVuZ3RoKSB7XG4gICAgICAgIGxldCBjID0gbywgdSA9IC9eXFx0Ki8uZXhlYyhsKVswXS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGQgPSAwOyBkIDwgdTsgZCsrKVxuICAgICAgICAgIGMgKz0gZS5mYWNldCh6ZCk7XG4gICAgICAgIGkucHVzaChuICsgYy5sZW5ndGggLSB1KSwgbCA9IGMgKyBsLnNsaWNlKHUpO1xuICAgICAgfVxuICAgICAgci5wdXNoKGwpLCBuICs9IGwubGVuZ3RoICsgMTtcbiAgICB9XG4gICAgbGV0IGEgPSB0aGlzLmZpZWxkUG9zaXRpb25zLm1hcCgobCkgPT4gbmV3IGJnKGwuZmllbGQsIGlbbC5saW5lXSArIGwuZnJvbSwgaVtsLmxpbmVdICsgbC50bykpO1xuICAgIHJldHVybiB7IHRleHQ6IHIsIHJhbmdlczogYSB9O1xuICB9XG4gIHN0YXRpYyBwYXJzZShlKSB7XG4gICAgbGV0IG4gPSBbXSwgciA9IFtdLCBpID0gW10sIHM7XG4gICAgZm9yIChsZXQgbyBvZiBlLnNwbGl0KC9cXHJcXG4/fFxcbi8pKSB7XG4gICAgICBmb3IgKDsgcyA9IC9bIyRdXFx7KD86KFxcZCspKD86OihbXn1dKikpP3woW159XSopKVxcfS8uZXhlYyhvKTsgKSB7XG4gICAgICAgIGxldCBhID0gc1sxXSA/ICtzWzFdIDogbnVsbCwgbCA9IHNbMl0gfHwgc1szXSB8fCBcIlwiLCBjID0gLTE7XG4gICAgICAgIGZvciAobGV0IHUgPSAwOyB1IDwgbi5sZW5ndGg7IHUrKylcbiAgICAgICAgICAoYSAhPSBudWxsID8gblt1XS5zZXEgPT0gYSA6IGwgJiYgblt1XS5uYW1lID09IGwpICYmIChjID0gdSk7XG4gICAgICAgIGlmIChjIDwgMCkge1xuICAgICAgICAgIGxldCB1ID0gMDtcbiAgICAgICAgICBmb3IgKDsgdSA8IG4ubGVuZ3RoICYmIChhID09IG51bGwgfHwgblt1XS5zZXEgIT0gbnVsbCAmJiBuW3VdLnNlcSA8IGEpOyApXG4gICAgICAgICAgICB1Kys7XG4gICAgICAgICAgbi5zcGxpY2UodSwgMCwgeyBzZXE6IGEsIG5hbWU6IGwgfSksIGMgPSB1O1xuICAgICAgICAgIGZvciAobGV0IGQgb2YgaSlcbiAgICAgICAgICAgIGQuZmllbGQgPj0gYyAmJiBkLmZpZWxkKys7XG4gICAgICAgIH1cbiAgICAgICAgaS5wdXNoKG5ldyBWWihjLCByLmxlbmd0aCwgcy5pbmRleCwgcy5pbmRleCArIGwubGVuZ3RoKSksIG8gPSBvLnNsaWNlKDAsIHMuaW5kZXgpICsgbCArIG8uc2xpY2Uocy5pbmRleCArIHNbMF0ubGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGE7IGEgPSAvXFxcXChbe31dKS8uZXhlYyhvKTsgKSB7XG4gICAgICAgIG8gPSBvLnNsaWNlKDAsIGEuaW5kZXgpICsgYVsxXSArIG8uc2xpY2UoYS5pbmRleCArIGFbMF0ubGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgbCBvZiBpKVxuICAgICAgICAgIGwubGluZSA9PSByLmxlbmd0aCAmJiBsLmZyb20gPiBhLmluZGV4ICYmIChsLmZyb20tLSwgbC50by0tKTtcbiAgICAgIH1cbiAgICAgIHIucHVzaChvKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyB2ZyhyLCBpKTtcbiAgfVxufVxubGV0IElaID0gLyogQF9fUFVSRV9fICovIEplLndpZGdldCh7IHdpZGdldDogLyogQF9fUFVSRV9fICovIG5ldyBjbGFzcyBleHRlbmRzIHJhIHtcbiAgdG9ET00oKSB7XG4gICAgbGV0IHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICByZXR1cm4gdC5jbGFzc05hbWUgPSBcImNtLXNuaXBwZXRGaWVsZFBvc2l0aW9uXCIsIHQ7XG4gIH1cbiAgaWdub3JlRXZlbnQoKSB7XG4gICAgcmV0dXJuICExO1xuICB9XG59KCkgfSksIFdaID0gLyogQF9fUFVSRV9fICovIEplLm1hcmsoeyBjbGFzczogXCJjbS1zbmlwcGV0RmllbGRcIiB9KTtcbmNsYXNzIG9hIHtcbiAgY29uc3RydWN0b3IoZSwgbikge1xuICAgIHRoaXMucmFuZ2VzID0gZSwgdGhpcy5hY3RpdmUgPSBuLCB0aGlzLmRlY28gPSBKZS5zZXQoZS5tYXAoKHIpID0+IChyLmZyb20gPT0gci50byA/IElaIDogV1opLnJhbmdlKHIuZnJvbSwgci50bykpKTtcbiAgfVxuICBtYXAoZSkge1xuICAgIGxldCBuID0gW107XG4gICAgZm9yIChsZXQgciBvZiB0aGlzLnJhbmdlcykge1xuICAgICAgbGV0IGkgPSByLm1hcChlKTtcbiAgICAgIGlmICghaSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBuLnB1c2goaSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgb2EobiwgdGhpcy5hY3RpdmUpO1xuICB9XG4gIHNlbGVjdGlvbkluc2lkZUZpZWxkKGUpIHtcbiAgICByZXR1cm4gZS5yYW5nZXMuZXZlcnkoKG4pID0+IHRoaXMucmFuZ2VzLnNvbWUoKHIpID0+IHIuZmllbGQgPT0gdGhpcy5hY3RpdmUgJiYgci5mcm9tIDw9IG4uZnJvbSAmJiByLnRvID49IG4udG8pKTtcbiAgfVxufVxuY29uc3QgZWMgPSAvKiBAX19QVVJFX18gKi8gb3QuZGVmaW5lKHtcbiAgbWFwKHQsIGUpIHtcbiAgICByZXR1cm4gdCAmJiB0Lm1hcChlKTtcbiAgfVxufSksIE1aID0gLyogQF9fUFVSRV9fICovIG90LmRlZmluZSgpLCB3bCA9IC8qIEBfX1BVUkVfXyAqLyB5ci5kZWZpbmUoe1xuICBjcmVhdGUoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG4gIHVwZGF0ZSh0LCBlKSB7XG4gICAgZm9yIChsZXQgbiBvZiBlLmVmZmVjdHMpIHtcbiAgICAgIGlmIChuLmlzKGVjKSlcbiAgICAgICAgcmV0dXJuIG4udmFsdWU7XG4gICAgICBpZiAobi5pcyhNWikgJiYgdClcbiAgICAgICAgcmV0dXJuIG5ldyBvYSh0LnJhbmdlcywgbi52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0ICYmIGUuZG9jQ2hhbmdlZCAmJiAodCA9IHQubWFwKGUuY2hhbmdlcykpLCB0ICYmIGUuc2VsZWN0aW9uICYmICF0LnNlbGVjdGlvbkluc2lkZUZpZWxkKGUuc2VsZWN0aW9uKSAmJiAodCA9IG51bGwpLCB0O1xuICB9LFxuICBwcm92aWRlOiAodCkgPT4gU2UuZGVjb3JhdGlvbnMuZnJvbSh0LCAoZSkgPT4gZSA/IGUuZGVjbyA6IEplLm5vbmUpXG59KTtcbmZ1bmN0aW9uIHlnKHQsIGUpIHtcbiAgcmV0dXJuIGFlLmNyZWF0ZSh0LmZpbHRlcigobikgPT4gbi5maWVsZCA9PSBlKS5tYXAoKG4pID0+IGFlLnJhbmdlKG4uZnJvbSwgbi50bykpKTtcbn1cbmZ1bmN0aW9uIFhaKHQpIHtcbiAgbGV0IGUgPSB2Zy5wYXJzZSh0KTtcbiAgcmV0dXJuIChuLCByLCBpLCBzKSA9PiB7XG4gICAgbGV0IHsgdGV4dDogbywgcmFuZ2VzOiBhIH0gPSBlLmluc3RhbnRpYXRlKG4uc3RhdGUsIGkpLCBsID0ge1xuICAgICAgY2hhbmdlczogeyBmcm9tOiBpLCB0bzogcywgaW5zZXJ0OiBGZS5vZihvKSB9LFxuICAgICAgc2Nyb2xsSW50b1ZpZXc6ICEwLFxuICAgICAgYW5ub3RhdGlvbnM6IHIgPyBbU3gub2YociksIEd0LnVzZXJFdmVudC5vZihcImlucHV0LmNvbXBsZXRlXCIpXSA6IHZvaWQgMFxuICAgIH07XG4gICAgaWYgKGEubGVuZ3RoICYmIChsLnNlbGVjdGlvbiA9IHlnKGEsIDApKSwgYS5zb21lKChjKSA9PiBjLmZpZWxkID4gMCkpIHtcbiAgICAgIGxldCBjID0gbmV3IG9hKGEsIDApLCB1ID0gbC5lZmZlY3RzID0gW2VjLm9mKGMpXTtcbiAgICAgIG4uc3RhdGUuZmllbGQod2wsICExKSA9PT0gdm9pZCAwICYmIHUucHVzaChvdC5hcHBlbmRDb25maWcub2YoW3dsLCBxWiwgWVosIFB4XSkpO1xuICAgIH1cbiAgICBuLmRpc3BhdGNoKG4uc3RhdGUudXBkYXRlKGwpKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIF94KHQpIHtcbiAgcmV0dXJuICh7IHN0YXRlOiBlLCBkaXNwYXRjaDogbiB9KSA9PiB7XG4gICAgbGV0IHIgPSBlLmZpZWxkKHdsLCAhMSk7XG4gICAgaWYgKCFyIHx8IHQgPCAwICYmIHIuYWN0aXZlID09IDApXG4gICAgICByZXR1cm4gITE7XG4gICAgbGV0IGkgPSByLmFjdGl2ZSArIHQsIHMgPSB0ID4gMCAmJiAhci5yYW5nZXMuc29tZSgobykgPT4gby5maWVsZCA9PSBpICsgdCk7XG4gICAgcmV0dXJuIG4oZS51cGRhdGUoe1xuICAgICAgc2VsZWN0aW9uOiB5ZyhyLnJhbmdlcywgaSksXG4gICAgICBlZmZlY3RzOiBlYy5vZihzID8gbnVsbCA6IG5ldyBvYShyLnJhbmdlcywgaSkpLFxuICAgICAgc2Nyb2xsSW50b1ZpZXc6ICEwXG4gICAgfSkpLCAhMDtcbiAgfTtcbn1cbmNvbnN0IGpaID0gKHsgc3RhdGU6IHQsIGRpc3BhdGNoOiBlIH0pID0+IHQuZmllbGQod2wsICExKSA/IChlKHQudXBkYXRlKHsgZWZmZWN0czogZWMub2YobnVsbCkgfSkpLCAhMCkgOiAhMSwgQlogPSAvKiBAX19QVVJFX18gKi8gX3goMSksIExaID0gLyogQF9fUFVSRV9fICovIF94KC0xKSwgVVogPSBbXG4gIHsga2V5OiBcIlRhYlwiLCBydW46IEJaLCBzaGlmdDogTFogfSxcbiAgeyBrZXk6IFwiRXNjYXBlXCIsIHJ1bjogalogfVxuXSwgSnYgPSAvKiBAX19QVVJFX18gKi8gdmUuZGVmaW5lKHtcbiAgY29tYmluZSh0KSB7XG4gICAgcmV0dXJuIHQubGVuZ3RoID8gdFswXSA6IFVaO1xuICB9XG59KSwgcVogPSAvKiBAX19QVVJFX18gKi8gemwuaGlnaGVzdCgvKiBAX19QVVJFX18gKi8gYmwuY29tcHV0ZShbSnZdLCAodCkgPT4gdC5mYWNldChKdikpKTtcbmZ1bmN0aW9uIHZuKHQsIGUpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZSksIHsgYXBwbHk6IFhaKHQpIH0pO1xufVxuY29uc3QgWVogPSAvKiBAX19QVVJFX18gKi8gU2UuZG9tRXZlbnRIYW5kbGVycyh7XG4gIG1vdXNlZG93bih0LCBlKSB7XG4gICAgbGV0IG4gPSBlLnN0YXRlLmZpZWxkKHdsLCAhMSksIHI7XG4gICAgaWYgKCFuIHx8IChyID0gZS5wb3NBdENvb3Jkcyh7IHg6IHQuY2xpZW50WCwgeTogdC5jbGllbnRZIH0pKSA9PSBudWxsKVxuICAgICAgcmV0dXJuICExO1xuICAgIGxldCBpID0gbi5yYW5nZXMuZmluZCgocykgPT4gcy5mcm9tIDw9IHIgJiYgcy50byA+PSByKTtcbiAgICByZXR1cm4gIWkgfHwgaS5maWVsZCA9PSBuLmFjdGl2ZSA/ICExIDogKGUuZGlzcGF0Y2goe1xuICAgICAgc2VsZWN0aW9uOiB5ZyhuLnJhbmdlcywgaS5maWVsZCksXG4gICAgICBlZmZlY3RzOiBlYy5vZihuLnJhbmdlcy5zb21lKChzKSA9PiBzLmZpZWxkID4gaS5maWVsZCkgPyBuZXcgb2Eobi5yYW5nZXMsIGkuZmllbGQpIDogbnVsbCksXG4gICAgICBzY3JvbGxJbnRvVmlldzogITBcbiAgICB9KSwgITApO1xuICB9XG59KSwga2wgPSB7XG4gIGJyYWNrZXRzOiBbXCIoXCIsIFwiW1wiLCBcIntcIiwgXCInXCIsICdcIiddLFxuICBiZWZvcmU6IFwiKV19Ojs+XCIsXG4gIHN0cmluZ1ByZWZpeGVzOiBbXVxufSwgX3MgPSAvKiBAX19QVVJFX18gKi8gb3QuZGVmaW5lKHtcbiAgbWFwKHQsIGUpIHtcbiAgICBsZXQgbiA9IGUubWFwUG9zKHQsIC0xLCBvbi5UcmFja0FmdGVyKTtcbiAgICByZXR1cm4gbiA/PyB2b2lkIDA7XG4gIH1cbn0pLCBTZyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgY2xhc3MgZXh0ZW5kcyBxcyB7XG59KCk7XG5TZy5zdGFydFNpZGUgPSAxO1xuU2cuZW5kU2lkZSA9IC0xO1xuY29uc3QgVHggPSAvKiBAX19QVVJFX18gKi8geXIuZGVmaW5lKHtcbiAgY3JlYXRlKCkge1xuICAgIHJldHVybiB6ZS5lbXB0eTtcbiAgfSxcbiAgdXBkYXRlKHQsIGUpIHtcbiAgICBpZiAodCA9IHQubWFwKGUuY2hhbmdlcyksIGUuc2VsZWN0aW9uKSB7XG4gICAgICBsZXQgbiA9IGUuc3RhdGUuZG9jLmxpbmVBdChlLnNlbGVjdGlvbi5tYWluLmhlYWQpO1xuICAgICAgdCA9IHQudXBkYXRlKHsgZmlsdGVyOiAocikgPT4gciA+PSBuLmZyb20gJiYgciA8PSBuLnRvIH0pO1xuICAgIH1cbiAgICBmb3IgKGxldCBuIG9mIGUuZWZmZWN0cylcbiAgICAgIG4uaXMoX3MpICYmICh0ID0gdC51cGRhdGUoeyBhZGQ6IFtTZy5yYW5nZShuLnZhbHVlLCBuLnZhbHVlICsgMSldIH0pKTtcbiAgICByZXR1cm4gdDtcbiAgfVxufSk7XG5mdW5jdGlvbiB6WigpIHtcbiAgcmV0dXJuIFtGWiwgVHhdO1xufVxuY29uc3QgWGYgPSBcIigpW117fTw+XCI7XG5mdW5jdGlvbiBFeCh0KSB7XG4gIGZvciAobGV0IGUgPSAwOyBlIDwgWGYubGVuZ3RoOyBlICs9IDIpXG4gICAgaWYgKFhmLmNoYXJDb2RlQXQoZSkgPT0gdClcbiAgICAgIHJldHVybiBYZi5jaGFyQXQoZSArIDEpO1xuICByZXR1cm4gSXcodCA8IDEyOCA/IHQgOiB0ICsgMSk7XG59XG5mdW5jdGlvbiAkeCh0LCBlKSB7XG4gIHJldHVybiB0Lmxhbmd1YWdlRGF0YUF0KFwiY2xvc2VCcmFja2V0c1wiLCBlKVswXSB8fCBrbDtcbn1cbmNvbnN0IEhaID0gdHlwZW9mIG5hdmlnYXRvciA9PSBcIm9iamVjdFwiICYmIC8qIEBfX1BVUkVfXyAqLyAvQW5kcm9pZFxcYi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSwgRlogPSAvKiBAX19QVVJFX18gKi8gU2UuaW5wdXRIYW5kbGVyLm9mKCh0LCBlLCBuLCByKSA9PiB7XG4gIGlmICgoSFogPyB0LmNvbXBvc2luZyA6IHQuY29tcG9zaXRpb25TdGFydGVkKSB8fCB0LnN0YXRlLnJlYWRPbmx5KVxuICAgIHJldHVybiAhMTtcbiAgbGV0IGkgPSB0LnN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICBpZiAoci5sZW5ndGggPiAyIHx8IHIubGVuZ3RoID09IDIgJiYgY3Iobm4ociwgMCkpID09IDEgfHwgZSAhPSBpLmZyb20gfHwgbiAhPSBpLnRvKVxuICAgIHJldHVybiAhMTtcbiAgbGV0IHMgPSBKWih0LnN0YXRlLCByKTtcbiAgcmV0dXJuIHMgPyAodC5kaXNwYXRjaChzKSwgITApIDogITE7XG59KSwgR1ogPSAoeyBzdGF0ZTogdCwgZGlzcGF0Y2g6IGUgfSkgPT4ge1xuICBpZiAodC5yZWFkT25seSlcbiAgICByZXR1cm4gITE7XG4gIGxldCByID0gJHgodCwgdC5zZWxlY3Rpb24ubWFpbi5oZWFkKS5icmFja2V0cyB8fCBrbC5icmFja2V0cywgaSA9IG51bGwsIHMgPSB0LmNoYW5nZUJ5UmFuZ2UoKG8pID0+IHtcbiAgICBpZiAoby5lbXB0eSkge1xuICAgICAgbGV0IGEgPSBlVih0LmRvYywgby5oZWFkKTtcbiAgICAgIGZvciAobGV0IGwgb2YgcilcbiAgICAgICAgaWYgKGwgPT0gYSAmJiBGZCh0LmRvYywgby5oZWFkKSA9PSBFeChubihsLCAwKSkpXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNoYW5nZXM6IHsgZnJvbTogby5oZWFkIC0gbC5sZW5ndGgsIHRvOiBvLmhlYWQgKyBsLmxlbmd0aCB9LFxuICAgICAgICAgICAgcmFuZ2U6IGFlLmN1cnNvcihvLmhlYWQgLSBsLmxlbmd0aClcbiAgICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4geyByYW5nZTogaSA9IG8gfTtcbiAgfSk7XG4gIHJldHVybiBpIHx8IGUodC51cGRhdGUocywgeyBzY3JvbGxJbnRvVmlldzogITAsIHVzZXJFdmVudDogXCJkZWxldGUuYmFja3dhcmRcIiB9KSksICFpO1xufSwgS1ogPSBbXG4gIHsga2V5OiBcIkJhY2tzcGFjZVwiLCBydW46IEdaIH1cbl07XG5mdW5jdGlvbiBKWih0LCBlKSB7XG4gIGxldCBuID0gJHgodCwgdC5zZWxlY3Rpb24ubWFpbi5oZWFkKSwgciA9IG4uYnJhY2tldHMgfHwga2wuYnJhY2tldHM7XG4gIGZvciAobGV0IGkgb2Ygcikge1xuICAgIGxldCBzID0gRXgobm4oaSwgMCkpO1xuICAgIGlmIChlID09IGkpXG4gICAgICByZXR1cm4gcyA9PSBpID8gclYodCwgaSwgci5pbmRleE9mKGkgKyBpICsgaSkgPiAtMSwgbikgOiB0Vih0LCBpLCBzLCBuLmJlZm9yZSB8fCBrbC5iZWZvcmUpO1xuICAgIGlmIChlID09IHMgJiYgUXgodCwgdC5zZWxlY3Rpb24ubWFpbi5mcm9tKSlcbiAgICAgIHJldHVybiBuVih0LCBpLCBzKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIFF4KHQsIGUpIHtcbiAgbGV0IG4gPSAhMTtcbiAgcmV0dXJuIHQuZmllbGQoVHgpLmJldHdlZW4oMCwgdC5kb2MubGVuZ3RoLCAocikgPT4ge1xuICAgIHIgPT0gZSAmJiAobiA9ICEwKTtcbiAgfSksIG47XG59XG5mdW5jdGlvbiBGZCh0LCBlKSB7XG4gIGxldCBuID0gdC5zbGljZVN0cmluZyhlLCBlICsgMik7XG4gIHJldHVybiBuLnNsaWNlKDAsIGNyKG5uKG4sIDApKSk7XG59XG5mdW5jdGlvbiBlVih0LCBlKSB7XG4gIGxldCBuID0gdC5zbGljZVN0cmluZyhlIC0gMiwgZSk7XG4gIHJldHVybiBjcihubihuLCAwKSkgPT0gbi5sZW5ndGggPyBuIDogbi5zbGljZSgxKTtcbn1cbmZ1bmN0aW9uIHRWKHQsIGUsIG4sIHIpIHtcbiAgbGV0IGkgPSBudWxsLCBzID0gdC5jaGFuZ2VCeVJhbmdlKChvKSA9PiB7XG4gICAgaWYgKCFvLmVtcHR5KVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2hhbmdlczogW3sgaW5zZXJ0OiBlLCBmcm9tOiBvLmZyb20gfSwgeyBpbnNlcnQ6IG4sIGZyb206IG8udG8gfV0sXG4gICAgICAgIGVmZmVjdHM6IF9zLm9mKG8udG8gKyBlLmxlbmd0aCksXG4gICAgICAgIHJhbmdlOiBhZS5yYW5nZShvLmFuY2hvciArIGUubGVuZ3RoLCBvLmhlYWQgKyBlLmxlbmd0aClcbiAgICAgIH07XG4gICAgbGV0IGEgPSBGZCh0LmRvYywgby5oZWFkKTtcbiAgICByZXR1cm4gIWEgfHwgL1xccy8udGVzdChhKSB8fCByLmluZGV4T2YoYSkgPiAtMSA/IHtcbiAgICAgIGNoYW5nZXM6IHsgaW5zZXJ0OiBlICsgbiwgZnJvbTogby5oZWFkIH0sXG4gICAgICBlZmZlY3RzOiBfcy5vZihvLmhlYWQgKyBlLmxlbmd0aCksXG4gICAgICByYW5nZTogYWUuY3Vyc29yKG8uaGVhZCArIGUubGVuZ3RoKVxuICAgIH0gOiB7IHJhbmdlOiBpID0gbyB9O1xuICB9KTtcbiAgcmV0dXJuIGkgPyBudWxsIDogdC51cGRhdGUocywge1xuICAgIHNjcm9sbEludG9WaWV3OiAhMCxcbiAgICB1c2VyRXZlbnQ6IFwiaW5wdXQudHlwZVwiXG4gIH0pO1xufVxuZnVuY3Rpb24gblYodCwgZSwgbikge1xuICBsZXQgciA9IG51bGwsIGkgPSB0LmNoYW5nZUJ5UmFuZ2UoKHMpID0+IHMuZW1wdHkgJiYgRmQodC5kb2MsIHMuaGVhZCkgPT0gbiA/IHtcbiAgICBjaGFuZ2VzOiB7IGZyb206IHMuaGVhZCwgdG86IHMuaGVhZCArIG4ubGVuZ3RoLCBpbnNlcnQ6IG4gfSxcbiAgICByYW5nZTogYWUuY3Vyc29yKHMuaGVhZCArIG4ubGVuZ3RoKVxuICB9IDogciA9IHsgcmFuZ2U6IHMgfSk7XG4gIHJldHVybiByID8gbnVsbCA6IHQudXBkYXRlKGksIHtcbiAgICBzY3JvbGxJbnRvVmlldzogITAsXG4gICAgdXNlckV2ZW50OiBcImlucHV0LnR5cGVcIlxuICB9KTtcbn1cbmZ1bmN0aW9uIHJWKHQsIGUsIG4sIHIpIHtcbiAgbGV0IGkgPSByLnN0cmluZ1ByZWZpeGVzIHx8IGtsLnN0cmluZ1ByZWZpeGVzLCBzID0gbnVsbCwgbyA9IHQuY2hhbmdlQnlSYW5nZSgoYSkgPT4ge1xuICAgIGlmICghYS5lbXB0eSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNoYW5nZXM6IFt7IGluc2VydDogZSwgZnJvbTogYS5mcm9tIH0sIHsgaW5zZXJ0OiBlLCBmcm9tOiBhLnRvIH1dLFxuICAgICAgICBlZmZlY3RzOiBfcy5vZihhLnRvICsgZS5sZW5ndGgpLFxuICAgICAgICByYW5nZTogYWUucmFuZ2UoYS5hbmNob3IgKyBlLmxlbmd0aCwgYS5oZWFkICsgZS5sZW5ndGgpXG4gICAgICB9O1xuICAgIGxldCBsID0gYS5oZWFkLCBjID0gRmQodC5kb2MsIGwpLCB1O1xuICAgIGlmIChjID09IGUpIHtcbiAgICAgIGlmIChlMCh0LCBsKSlcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjaGFuZ2VzOiB7IGluc2VydDogZSArIGUsIGZyb206IGwgfSxcbiAgICAgICAgICBlZmZlY3RzOiBfcy5vZihsICsgZS5sZW5ndGgpLFxuICAgICAgICAgIHJhbmdlOiBhZS5jdXJzb3IobCArIGUubGVuZ3RoKVxuICAgICAgICB9O1xuICAgICAgaWYgKFF4KHQsIGwpKSB7XG4gICAgICAgIGxldCBmID0gbiAmJiB0LnNsaWNlRG9jKGwsIGwgKyBlLmxlbmd0aCAqIDMpID09IGUgKyBlICsgZSA/IGUgKyBlICsgZSA6IGU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2hhbmdlczogeyBmcm9tOiBsLCB0bzogbCArIGYubGVuZ3RoLCBpbnNlcnQ6IGYgfSxcbiAgICAgICAgICByYW5nZTogYWUuY3Vyc29yKGwgKyBmLmxlbmd0aClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG4gJiYgdC5zbGljZURvYyhsIC0gMiAqIGUubGVuZ3RoLCBsKSA9PSBlICsgZSAmJiAodSA9IHQwKHQsIGwgLSAyICogZS5sZW5ndGgsIGkpKSA+IC0xICYmIGUwKHQsIHUpKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNoYW5nZXM6IHsgaW5zZXJ0OiBlICsgZSArIGUgKyBlLCBmcm9tOiBsIH0sXG4gICAgICAgICAgZWZmZWN0czogX3Mub2YobCArIGUubGVuZ3RoKSxcbiAgICAgICAgICByYW5nZTogYWUuY3Vyc29yKGwgKyBlLmxlbmd0aClcbiAgICAgICAgfTtcbiAgICAgIGlmICh0LmNoYXJDYXRlZ29yaXplcihsKShjKSAhPSBIbi5Xb3JkICYmIHQwKHQsIGwsIGkpID4gLTEgJiYgIWlWKHQsIGwsIGUsIGkpKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNoYW5nZXM6IHsgaW5zZXJ0OiBlICsgZSwgZnJvbTogbCB9LFxuICAgICAgICAgIGVmZmVjdHM6IF9zLm9mKGwgKyBlLmxlbmd0aCksXG4gICAgICAgICAgcmFuZ2U6IGFlLmN1cnNvcihsICsgZS5sZW5ndGgpXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IHJhbmdlOiBzID0gYSB9O1xuICB9KTtcbiAgcmV0dXJuIHMgPyBudWxsIDogdC51cGRhdGUobywge1xuICAgIHNjcm9sbEludG9WaWV3OiAhMCxcbiAgICB1c2VyRXZlbnQ6IFwiaW5wdXQudHlwZVwiXG4gIH0pO1xufVxuZnVuY3Rpb24gZTAodCwgZSkge1xuICBsZXQgbiA9IHVuKHQpLnJlc29sdmVJbm5lcihlICsgMSk7XG4gIHJldHVybiBuLnBhcmVudCAmJiBuLmZyb20gPT0gZTtcbn1cbmZ1bmN0aW9uIGlWKHQsIGUsIG4sIHIpIHtcbiAgbGV0IGkgPSB1bih0KS5yZXNvbHZlSW5uZXIoZSwgLTEpLCBzID0gci5yZWR1Y2UoKG8sIGEpID0+IE1hdGgubWF4KG8sIGEubGVuZ3RoKSwgMCk7XG4gIGZvciAobGV0IG8gPSAwOyBvIDwgNTsgbysrKSB7XG4gICAgbGV0IGEgPSB0LnNsaWNlRG9jKGkuZnJvbSwgTWF0aC5taW4oaS50bywgaS5mcm9tICsgbi5sZW5ndGggKyBzKSksIGwgPSBhLmluZGV4T2Yobik7XG4gICAgaWYgKCFsIHx8IGwgPiAtMSAmJiByLmluZGV4T2YoYS5zbGljZSgwLCBsKSkgPiAtMSkge1xuICAgICAgbGV0IHUgPSBpLmZpcnN0Q2hpbGQ7XG4gICAgICBmb3IgKDsgdSAmJiB1LmZyb20gPT0gaS5mcm9tICYmIHUudG8gLSB1LmZyb20gPiBuLmxlbmd0aCArIGw7ICkge1xuICAgICAgICBpZiAodC5zbGljZURvYyh1LnRvIC0gbi5sZW5ndGgsIHUudG8pID09IG4pXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICB1ID0gdS5maXJzdENoaWxkO1xuICAgICAgfVxuICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICBsZXQgYyA9IGkudG8gPT0gZSAmJiBpLnBhcmVudDtcbiAgICBpZiAoIWMpXG4gICAgICBicmVhaztcbiAgICBpID0gYztcbiAgfVxuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiB0MCh0LCBlLCBuKSB7XG4gIGxldCByID0gdC5jaGFyQ2F0ZWdvcml6ZXIoZSk7XG4gIGlmIChyKHQuc2xpY2VEb2MoZSAtIDEsIGUpKSAhPSBIbi5Xb3JkKVxuICAgIHJldHVybiBlO1xuICBmb3IgKGxldCBpIG9mIG4pIHtcbiAgICBsZXQgcyA9IGUgLSBpLmxlbmd0aDtcbiAgICBpZiAodC5zbGljZURvYyhzLCBlKSA9PSBpICYmIHIodC5zbGljZURvYyhzIC0gMSwgcykpICE9IEhuLldvcmQpXG4gICAgICByZXR1cm4gcztcbiAgfVxuICByZXR1cm4gLTE7XG59XG5mdW5jdGlvbiBzVih0ID0ge30pIHtcbiAgcmV0dXJuIFtcbiAgICBabixcbiAgICBGdC5vZih0KSxcbiAgICBaWixcbiAgICBvVixcbiAgICBQeFxuICBdO1xufVxuY29uc3QgQ3ggPSBbXG4gIHsga2V5OiBcIkN0cmwtU3BhY2VcIiwgcnVuOiBDWiB9LFxuICB7IGtleTogXCJFc2NhcGVcIiwgcnVuOiBBWiB9LFxuICB7IGtleTogXCJBcnJvd0Rvd25cIiwgcnVuOiAvKiBAX19QVVJFX18gKi8gV2MoITApIH0sXG4gIHsga2V5OiBcIkFycm93VXBcIiwgcnVuOiAvKiBAX19QVVJFX18gKi8gV2MoITEpIH0sXG4gIHsga2V5OiBcIlBhZ2VEb3duXCIsIHJ1bjogLyogQF9fUFVSRV9fICovIFdjKCEwLCBcInBhZ2VcIikgfSxcbiAgeyBrZXk6IFwiUGFnZVVwXCIsIHJ1bjogLyogQF9fUFVSRV9fICovIFdjKCExLCBcInBhZ2VcIikgfSxcbiAgeyBrZXk6IFwiRW50ZXJcIiwgcnVuOiBRWiB9XG5dLCBvViA9IC8qIEBfX1BVUkVfXyAqLyB6bC5oaWdoZXN0KC8qIEBfX1BVUkVfXyAqLyBibC5jb21wdXRlTihbRnRdLCAodCkgPT4gdC5mYWNldChGdCkuZGVmYXVsdEtleW1hcCA/IFtDeF0gOiBbXSkpO1xuZnVuY3Rpb24gQXgodCwgZSkge1xuICBsZXQgbiA9IC0xO1xuICByZXR1cm4gdC5jaGFuZ2VCeVJhbmdlKChyKSA9PiB7XG4gICAgbGV0IGkgPSBbXTtcbiAgICBmb3IgKGxldCBvID0gci5mcm9tOyBvIDw9IHIudG87ICkge1xuICAgICAgbGV0IGEgPSB0LmRvYy5saW5lQXQobyk7XG4gICAgICBhLm51bWJlciA+IG4gJiYgKHIuZW1wdHkgfHwgci50byA+IGEuZnJvbSkgJiYgKGUoYSwgaSwgciksIG4gPSBhLm51bWJlciksIG8gPSBhLnRvICsgMTtcbiAgICB9XG4gICAgbGV0IHMgPSB0LmNoYW5nZXMoaSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNoYW5nZXM6IGksXG4gICAgICByYW5nZTogYWUucmFuZ2Uocy5tYXBQb3Moci5hbmNob3IsIDEpLCBzLm1hcFBvcyhyLmhlYWQsIDEpKVxuICAgIH07XG4gIH0pO1xufVxuY29uc3QgYVYgPSAoeyBzdGF0ZTogdCwgZGlzcGF0Y2g6IGUgfSkgPT4gdC5yZWFkT25seSA/ICExIDogKGUodC51cGRhdGUoQXgodCwgKG4sIHIpID0+IHtcbiAgci5wdXNoKHsgZnJvbTogbi5mcm9tLCBpbnNlcnQ6IHQuZmFjZXQoemQpIH0pO1xufSksIHsgdXNlckV2ZW50OiBcImlucHV0LmluZGVudFwiIH0pKSwgITApLCBsViA9ICh7IHN0YXRlOiB0LCBkaXNwYXRjaDogZSB9KSA9PiB0LnJlYWRPbmx5ID8gITEgOiAoZSh0LnVwZGF0ZShBeCh0LCAobiwgcikgPT4ge1xuICBsZXQgaSA9IC9eXFxzKi8uZXhlYyhuLnRleHQpWzBdO1xuICBpZiAoIWkpXG4gICAgcmV0dXJuO1xuICBsZXQgcyA9IGlnKGksIHQudGFiU2l6ZSksIG8gPSAwLCBhID0gbHgodCwgTWF0aC5tYXgoMCwgcyAtIGF4KHQpKSk7XG4gIGZvciAoOyBvIDwgaS5sZW5ndGggJiYgbyA8IGEubGVuZ3RoICYmIGkuY2hhckNvZGVBdChvKSA9PSBhLmNoYXJDb2RlQXQobyk7IClcbiAgICBvKys7XG4gIHIucHVzaCh7IGZyb206IG4uZnJvbSArIG8sIHRvOiBuLmZyb20gKyBpLmxlbmd0aCwgaW5zZXJ0OiBhLnNsaWNlKG8pIH0pO1xufSksIHsgdXNlckV2ZW50OiBcImRlbGV0ZS5kZWRlbnRcIiB9KSksICEwKSwgY1YgPSB7IGtleTogXCJUYWJcIiwgcnVuOiBhViwgc2hpZnQ6IGxWIH07XG5jbGFzcyBZdSB7XG4gIC8qKlxuICBAaW50ZXJuYWxcbiAgKi9cbiAgY29uc3RydWN0b3IoZSwgbiwgciwgaSwgcywgbywgYSwgbCwgYywgdSA9IDAsIGQpIHtcbiAgICB0aGlzLnAgPSBlLCB0aGlzLnN0YWNrID0gbiwgdGhpcy5zdGF0ZSA9IHIsIHRoaXMucmVkdWNlUG9zID0gaSwgdGhpcy5wb3MgPSBzLCB0aGlzLnNjb3JlID0gbywgdGhpcy5idWZmZXIgPSBhLCB0aGlzLmJ1ZmZlckJhc2UgPSBsLCB0aGlzLmN1ckNvbnRleHQgPSBjLCB0aGlzLmxvb2tBaGVhZCA9IHUsIHRoaXMucGFyZW50ID0gZDtcbiAgfVxuICAvKipcbiAgQGludGVybmFsXG4gICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBgWyR7dGhpcy5zdGFjay5maWx0ZXIoKGUsIG4pID0+IG4gJSAzID09IDApLmNvbmNhdCh0aGlzLnN0YXRlKX1dQCR7dGhpcy5wb3N9JHt0aGlzLnNjb3JlID8gXCIhXCIgKyB0aGlzLnNjb3JlIDogXCJcIn1gO1xuICB9XG4gIC8vIFN0YXJ0IGFuIGVtcHR5IHN0YWNrXG4gIC8qKlxuICBAaW50ZXJuYWxcbiAgKi9cbiAgc3RhdGljIHN0YXJ0KGUsIG4sIHIgPSAwKSB7XG4gICAgbGV0IGkgPSBlLnBhcnNlci5jb250ZXh0O1xuICAgIHJldHVybiBuZXcgWXUoZSwgW10sIG4sIHIsIHIsIDAsIFtdLCAwLCBpID8gbmV3IG4wKGksIGkuc3RhcnQpIDogbnVsbCwgMCwgbnVsbCk7XG4gIH1cbiAgLyoqXG4gIFRoZSBzdGFjaydzIGN1cnJlbnQgW2NvbnRleHRdKCNsci5Db250ZXh0VHJhY2tlcikgdmFsdWUsIGlmXG4gIGFueS4gSXRzIHR5cGUgd2lsbCBkZXBlbmQgb24gdGhlIGNvbnRleHQgdHJhY2tlcidzIHR5cGVcbiAgcGFyYW1ldGVyLCBvciBpdCB3aWxsIGJlIGBudWxsYCBpZiB0aGVyZSBpcyBubyBjb250ZXh0XG4gIHRyYWNrZXIuXG4gICovXG4gIGdldCBjb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmN1ckNvbnRleHQgPyB0aGlzLmN1ckNvbnRleHQuY29udGV4dCA6IG51bGw7XG4gIH1cbiAgLy8gUHVzaCBhIHN0YXRlIG9udG8gdGhlIHN0YWNrLCB0cmFja2luZyBpdHMgc3RhcnQgcG9zaXRpb24gYXMgd2VsbFxuICAvLyBhcyB0aGUgYnVmZmVyIGJhc2UgYXQgdGhhdCBwb2ludC5cbiAgLyoqXG4gIEBpbnRlcm5hbFxuICAqL1xuICBwdXNoU3RhdGUoZSwgbikge1xuICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLnN0YXRlLCBuLCB0aGlzLmJ1ZmZlckJhc2UgKyB0aGlzLmJ1ZmZlci5sZW5ndGgpLCB0aGlzLnN0YXRlID0gZTtcbiAgfVxuICAvLyBBcHBseSBhIHJlZHVjZSBhY3Rpb25cbiAgLyoqXG4gIEBpbnRlcm5hbFxuICAqL1xuICByZWR1Y2UoZSkge1xuICAgIHZhciBuO1xuICAgIGxldCByID0gZSA+PiAxOSwgaSA9IGUgJiA2NTUzNSwgeyBwYXJzZXI6IHMgfSA9IHRoaXMucCwgbyA9IHMuZHluYW1pY1ByZWNlZGVuY2UoaSk7XG4gICAgaWYgKG8gJiYgKHRoaXMuc2NvcmUgKz0gbyksIHIgPT0gMCkge1xuICAgICAgdGhpcy5wdXNoU3RhdGUocy5nZXRHb3RvKHRoaXMuc3RhdGUsIGksICEwKSwgdGhpcy5yZWR1Y2VQb3MpLCBpIDwgcy5taW5SZXBlYXRUZXJtICYmIHRoaXMuc3RvcmVOb2RlKGksIHRoaXMucmVkdWNlUG9zLCB0aGlzLnJlZHVjZVBvcywgNCwgITApLCB0aGlzLnJlZHVjZUNvbnRleHQoaSwgdGhpcy5yZWR1Y2VQb3MpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgYSA9IHRoaXMuc3RhY2subGVuZ3RoIC0gKHIgLSAxKSAqIDMgLSAoZSAmIDI2MjE0NCA/IDYgOiAwKSwgbCA9IGEgPyB0aGlzLnN0YWNrW2EgLSAyXSA6IHRoaXMucC5yYW5nZXNbMF0uZnJvbSwgYyA9IHRoaXMucmVkdWNlUG9zIC0gbDtcbiAgICBjID49IDJlMyAmJiAhKCEoKG4gPSB0aGlzLnAucGFyc2VyLm5vZGVTZXQudHlwZXNbaV0pID09PSBudWxsIHx8IG4gPT09IHZvaWQgMCkgJiYgbi5pc0Fub255bW91cykgJiYgKGwgPT0gdGhpcy5wLmxhc3RCaWdSZWR1Y3Rpb25TdGFydCA/ICh0aGlzLnAuYmlnUmVkdWN0aW9uQ291bnQrKywgdGhpcy5wLmxhc3RCaWdSZWR1Y3Rpb25TaXplID0gYykgOiB0aGlzLnAubGFzdEJpZ1JlZHVjdGlvblNpemUgPCBjICYmICh0aGlzLnAuYmlnUmVkdWN0aW9uQ291bnQgPSAxLCB0aGlzLnAubGFzdEJpZ1JlZHVjdGlvblN0YXJ0ID0gbCwgdGhpcy5wLmxhc3RCaWdSZWR1Y3Rpb25TaXplID0gYykpO1xuICAgIGxldCB1ID0gYSA/IHRoaXMuc3RhY2tbYSAtIDFdIDogMCwgZCA9IHRoaXMuYnVmZmVyQmFzZSArIHRoaXMuYnVmZmVyLmxlbmd0aCAtIHU7XG4gICAgaWYgKGkgPCBzLm1pblJlcGVhdFRlcm0gfHwgZSAmIDEzMTA3Mikge1xuICAgICAgbGV0IGYgPSBzLnN0YXRlRmxhZyhcbiAgICAgICAgdGhpcy5zdGF0ZSxcbiAgICAgICAgMVxuICAgICAgICAvKiBTdGF0ZUZsYWcuU2tpcHBlZCAqL1xuICAgICAgKSA/IHRoaXMucG9zIDogdGhpcy5yZWR1Y2VQb3M7XG4gICAgICB0aGlzLnN0b3JlTm9kZShpLCBsLCBmLCBkICsgNCwgITApO1xuICAgIH1cbiAgICBpZiAoZSAmIDI2MjE0NClcbiAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0YWNrW2FdO1xuICAgIGVsc2Uge1xuICAgICAgbGV0IGYgPSB0aGlzLnN0YWNrW2EgLSAzXTtcbiAgICAgIHRoaXMuc3RhdGUgPSBzLmdldEdvdG8oZiwgaSwgITApO1xuICAgIH1cbiAgICBmb3IgKDsgdGhpcy5zdGFjay5sZW5ndGggPiBhOyApXG4gICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgIHRoaXMucmVkdWNlQ29udGV4dChpLCBsKTtcbiAgfVxuICAvLyBTaGlmdCBhIHZhbHVlIGludG8gdGhlIGJ1ZmZlclxuICAvKipcbiAgQGludGVybmFsXG4gICovXG4gIHN0b3JlTm9kZShlLCBuLCByLCBpID0gNCwgcyA9ICExKSB7XG4gICAgaWYgKGUgPT0gMCAmJiAoIXRoaXMuc3RhY2subGVuZ3RoIHx8IHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXSA8IHRoaXMuYnVmZmVyLmxlbmd0aCArIHRoaXMuYnVmZmVyQmFzZSkpIHtcbiAgICAgIGxldCBvID0gdGhpcywgYSA9IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICAgIGlmIChhID09IDAgJiYgby5wYXJlbnQgJiYgKGEgPSBvLmJ1ZmZlckJhc2UgLSBvLnBhcmVudC5idWZmZXJCYXNlLCBvID0gby5wYXJlbnQpLCBhID4gMCAmJiBvLmJ1ZmZlclthIC0gNF0gPT0gMCAmJiBvLmJ1ZmZlclthIC0gMV0gPiAtMSkge1xuICAgICAgICBpZiAobiA9PSByKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKG8uYnVmZmVyW2EgLSAyXSA+PSBuKSB7XG4gICAgICAgICAgby5idWZmZXJbYSAtIDJdID0gcjtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFzIHx8IHRoaXMucG9zID09IHIpXG4gICAgICB0aGlzLmJ1ZmZlci5wdXNoKGUsIG4sIHIsIGkpO1xuICAgIGVsc2Uge1xuICAgICAgbGV0IG8gPSB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gICAgICBpZiAobyA+IDAgJiYgdGhpcy5idWZmZXJbbyAtIDRdICE9IDApXG4gICAgICAgIGZvciAoOyBvID4gMCAmJiB0aGlzLmJ1ZmZlcltvIC0gMl0gPiByOyApXG4gICAgICAgICAgdGhpcy5idWZmZXJbb10gPSB0aGlzLmJ1ZmZlcltvIC0gNF0sIHRoaXMuYnVmZmVyW28gKyAxXSA9IHRoaXMuYnVmZmVyW28gLSAzXSwgdGhpcy5idWZmZXJbbyArIDJdID0gdGhpcy5idWZmZXJbbyAtIDJdLCB0aGlzLmJ1ZmZlcltvICsgM10gPSB0aGlzLmJ1ZmZlcltvIC0gMV0sIG8gLT0gNCwgaSA+IDQgJiYgKGkgLT0gNCk7XG4gICAgICB0aGlzLmJ1ZmZlcltvXSA9IGUsIHRoaXMuYnVmZmVyW28gKyAxXSA9IG4sIHRoaXMuYnVmZmVyW28gKyAyXSA9IHIsIHRoaXMuYnVmZmVyW28gKyAzXSA9IGk7XG4gICAgfVxuICB9XG4gIC8vIEFwcGx5IGEgc2hpZnQgYWN0aW9uXG4gIC8qKlxuICBAaW50ZXJuYWxcbiAgKi9cbiAgc2hpZnQoZSwgbiwgciwgaSkge1xuICAgIGlmIChlICYgMTMxMDcyKVxuICAgICAgdGhpcy5wdXNoU3RhdGUoZSAmIDY1NTM1LCB0aGlzLnBvcyk7XG4gICAgZWxzZSBpZiAoZSAmIDI2MjE0NClcbiAgICAgIHRoaXMucG9zID0gaSwgdGhpcy5zaGlmdENvbnRleHQobiwgciksIG4gPD0gdGhpcy5wLnBhcnNlci5tYXhOb2RlICYmIHRoaXMuYnVmZmVyLnB1c2gobiwgciwgaSwgNCk7XG4gICAgZWxzZSB7XG4gICAgICBsZXQgcyA9IGUsIHsgcGFyc2VyOiBvIH0gPSB0aGlzLnA7XG4gICAgICAoaSA+IHRoaXMucG9zIHx8IG4gPD0gby5tYXhOb2RlKSAmJiAodGhpcy5wb3MgPSBpLCBvLnN0YXRlRmxhZyhcbiAgICAgICAgcyxcbiAgICAgICAgMVxuICAgICAgICAvKiBTdGF0ZUZsYWcuU2tpcHBlZCAqL1xuICAgICAgKSB8fCAodGhpcy5yZWR1Y2VQb3MgPSBpKSksIHRoaXMucHVzaFN0YXRlKHMsIHIpLCB0aGlzLnNoaWZ0Q29udGV4dChuLCByKSwgbiA8PSBvLm1heE5vZGUgJiYgdGhpcy5idWZmZXIucHVzaChuLCByLCBpLCA0KTtcbiAgICB9XG4gIH1cbiAgLy8gQXBwbHkgYW4gYWN0aW9uXG4gIC8qKlxuICBAaW50ZXJuYWxcbiAgKi9cbiAgYXBwbHkoZSwgbiwgciwgaSkge1xuICAgIGUgJiA2NTUzNiA/IHRoaXMucmVkdWNlKGUpIDogdGhpcy5zaGlmdChlLCBuLCByLCBpKTtcbiAgfVxuICAvLyBBZGQgYSBwcmVidWlsdCAocmV1c2VkKSBub2RlIGludG8gdGhlIGJ1ZmZlci5cbiAgLyoqXG4gIEBpbnRlcm5hbFxuICAqL1xuICB1c2VOb2RlKGUsIG4pIHtcbiAgICBsZXQgciA9IHRoaXMucC5yZXVzZWQubGVuZ3RoIC0gMTtcbiAgICAociA8IDAgfHwgdGhpcy5wLnJldXNlZFtyXSAhPSBlKSAmJiAodGhpcy5wLnJldXNlZC5wdXNoKGUpLCByKyspO1xuICAgIGxldCBpID0gdGhpcy5wb3M7XG4gICAgdGhpcy5yZWR1Y2VQb3MgPSB0aGlzLnBvcyA9IGkgKyBlLmxlbmd0aCwgdGhpcy5wdXNoU3RhdGUobiwgaSksIHRoaXMuYnVmZmVyLnB1c2goXG4gICAgICByLFxuICAgICAgaSxcbiAgICAgIHRoaXMucmVkdWNlUG9zLFxuICAgICAgLTFcbiAgICAgIC8qIHNpemUgPT0gLTEgbWVhbnMgdGhpcyBpcyBhIHJldXNlZCB2YWx1ZSAqL1xuICAgICksIHRoaXMuY3VyQ29udGV4dCAmJiB0aGlzLnVwZGF0ZUNvbnRleHQodGhpcy5jdXJDb250ZXh0LnRyYWNrZXIucmV1c2UodGhpcy5jdXJDb250ZXh0LmNvbnRleHQsIGUsIHRoaXMsIHRoaXMucC5zdHJlYW0ucmVzZXQodGhpcy5wb3MgLSBlLmxlbmd0aCkpKTtcbiAgfVxuICAvLyBTcGxpdCB0aGUgc3RhY2suIER1ZSB0byB0aGUgYnVmZmVyIHNoYXJpbmcgYW5kIHRoZSBmYWN0XG4gIC8vIHRoYXQgYHRoaXMuc3RhY2tgIHRlbmRzIHRvIHN0YXkgcXVpdGUgc2hhbGxvdywgdGhpcyBpc24ndCB2ZXJ5XG4gIC8vIGV4cGVuc2l2ZS5cbiAgLyoqXG4gIEBpbnRlcm5hbFxuICAqL1xuICBzcGxpdCgpIHtcbiAgICBsZXQgZSA9IHRoaXMsIG4gPSBlLmJ1ZmZlci5sZW5ndGg7XG4gICAgZm9yICg7IG4gPiAwICYmIGUuYnVmZmVyW24gLSAyXSA+IGUucmVkdWNlUG9zOyApXG4gICAgICBuIC09IDQ7XG4gICAgbGV0IHIgPSBlLmJ1ZmZlci5zbGljZShuKSwgaSA9IGUuYnVmZmVyQmFzZSArIG47XG4gICAgZm9yICg7IGUgJiYgaSA9PSBlLmJ1ZmZlckJhc2U7IClcbiAgICAgIGUgPSBlLnBhcmVudDtcbiAgICByZXR1cm4gbmV3IFl1KHRoaXMucCwgdGhpcy5zdGFjay5zbGljZSgpLCB0aGlzLnN0YXRlLCB0aGlzLnJlZHVjZVBvcywgdGhpcy5wb3MsIHRoaXMuc2NvcmUsIHIsIGksIHRoaXMuY3VyQ29udGV4dCwgdGhpcy5sb29rQWhlYWQsIGUpO1xuICB9XG4gIC8vIFRyeSB0byByZWNvdmVyIGZyb20gYW4gZXJyb3IgYnkgJ2RlbGV0aW5nJyAoaWdub3JpbmcpIG9uZSB0b2tlbi5cbiAgLyoqXG4gIEBpbnRlcm5hbFxuICAqL1xuICByZWNvdmVyQnlEZWxldGUoZSwgbikge1xuICAgIGxldCByID0gZSA8PSB0aGlzLnAucGFyc2VyLm1heE5vZGU7XG4gICAgciAmJiB0aGlzLnN0b3JlTm9kZShlLCB0aGlzLnBvcywgbiwgNCksIHRoaXMuc3RvcmVOb2RlKDAsIHRoaXMucG9zLCBuLCByID8gOCA6IDQpLCB0aGlzLnBvcyA9IHRoaXMucmVkdWNlUG9zID0gbiwgdGhpcy5zY29yZSAtPSAxOTA7XG4gIH1cbiAgLyoqXG4gIENoZWNrIGlmIHRoZSBnaXZlbiB0ZXJtIHdvdWxkIGJlIGFibGUgdG8gYmUgc2hpZnRlZCAob3B0aW9uYWxseVxuICBhZnRlciBzb21lIHJlZHVjdGlvbnMpIG9uIHRoaXMgc3RhY2suIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3JcbiAgZXh0ZXJuYWwgdG9rZW5pemVycyB0aGF0IHdhbnQgdG8gbWFrZSBzdXJlIHRoZXkgb25seSBwcm92aWRlIGFcbiAgZ2l2ZW4gdG9rZW4gd2hlbiBpdCBhcHBsaWVzLlxuICAqL1xuICBjYW5TaGlmdChlKSB7XG4gICAgZm9yIChsZXQgbiA9IG5ldyB1Vih0aGlzKTsgOyApIHtcbiAgICAgIGxldCByID0gdGhpcy5wLnBhcnNlci5zdGF0ZVNsb3QoXG4gICAgICAgIG4uc3RhdGUsXG4gICAgICAgIDRcbiAgICAgICAgLyogUGFyc2VTdGF0ZS5EZWZhdWx0UmVkdWNlICovXG4gICAgICApIHx8IHRoaXMucC5wYXJzZXIuaGFzQWN0aW9uKG4uc3RhdGUsIGUpO1xuICAgICAgaWYgKHIgPT0gMClcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgaWYgKCEociAmIDY1NTM2KSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgbi5yZWR1Y2Uocik7XG4gICAgfVxuICB9XG4gIC8vIEFwcGx5IHVwIHRvIFJlY292ZXIuTWF4TmV4dCByZWNvdmVyeSBhY3Rpb25zIHRoYXQgY29uY2VwdHVhbGx5XG4gIC8vIGluc2VydHMgc29tZSBtaXNzaW5nIHRva2VuIG9yIHJ1bGUuXG4gIC8qKlxuICBAaW50ZXJuYWxcbiAgKi9cbiAgcmVjb3ZlckJ5SW5zZXJ0KGUpIHtcbiAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPj0gMzAwKVxuICAgICAgcmV0dXJuIFtdO1xuICAgIGxldCBuID0gdGhpcy5wLnBhcnNlci5uZXh0U3RhdGVzKHRoaXMuc3RhdGUpO1xuICAgIGlmIChuLmxlbmd0aCA+IDggfHwgdGhpcy5zdGFjay5sZW5ndGggPj0gMTIwKSB7XG4gICAgICBsZXQgaSA9IFtdO1xuICAgICAgZm9yIChsZXQgcyA9IDAsIG87IHMgPCBuLmxlbmd0aDsgcyArPSAyKVxuICAgICAgICAobyA9IG5bcyArIDFdKSAhPSB0aGlzLnN0YXRlICYmIHRoaXMucC5wYXJzZXIuaGFzQWN0aW9uKG8sIGUpICYmIGkucHVzaChuW3NdLCBvKTtcbiAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCA8IDEyMClcbiAgICAgICAgZm9yIChsZXQgcyA9IDA7IGkubGVuZ3RoIDwgOCAmJiBzIDwgbi5sZW5ndGg7IHMgKz0gMikge1xuICAgICAgICAgIGxldCBvID0gbltzICsgMV07XG4gICAgICAgICAgaS5zb21lKChhLCBsKSA9PiBsICYgMSAmJiBhID09IG8pIHx8IGkucHVzaChuW3NdLCBvKTtcbiAgICAgICAgfVxuICAgICAgbiA9IGk7XG4gICAgfVxuICAgIGxldCByID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuLmxlbmd0aCAmJiByLmxlbmd0aCA8IDQ7IGkgKz0gMikge1xuICAgICAgbGV0IHMgPSBuW2kgKyAxXTtcbiAgICAgIGlmIChzID09IHRoaXMuc3RhdGUpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgbGV0IG8gPSB0aGlzLnNwbGl0KCk7XG4gICAgICBvLnB1c2hTdGF0ZShzLCB0aGlzLnBvcyksIG8uc3RvcmVOb2RlKDAsIG8ucG9zLCBvLnBvcywgNCwgITApLCBvLnNoaWZ0Q29udGV4dChuW2ldLCB0aGlzLnBvcyksIG8ucmVkdWNlUG9zID0gdGhpcy5wb3MsIG8uc2NvcmUgLT0gMjAwLCByLnB1c2gobyk7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIC8vIEZvcmNlIGEgcmVkdWNlLCBpZiBwb3NzaWJsZS4gUmV0dXJuIGZhbHNlIGlmIHRoYXQgY2FuJ3RcbiAgLy8gYmUgZG9uZS5cbiAgLyoqXG4gIEBpbnRlcm5hbFxuICAqL1xuICBmb3JjZVJlZHVjZSgpIHtcbiAgICBsZXQgeyBwYXJzZXI6IGUgfSA9IHRoaXMucCwgbiA9IGUuc3RhdGVTbG90KFxuICAgICAgdGhpcy5zdGF0ZSxcbiAgICAgIDVcbiAgICAgIC8qIFBhcnNlU3RhdGUuRm9yY2VkUmVkdWNlICovXG4gICAgKTtcbiAgICBpZiAoIShuICYgNjU1MzYpKVxuICAgICAgcmV0dXJuICExO1xuICAgIGlmICghZS52YWxpZEFjdGlvbih0aGlzLnN0YXRlLCBuKSkge1xuICAgICAgbGV0IHIgPSBuID4+IDE5LCBpID0gbiAmIDY1NTM1LCBzID0gdGhpcy5zdGFjay5sZW5ndGggLSByICogMztcbiAgICAgIGlmIChzIDwgMCB8fCBlLmdldEdvdG8odGhpcy5zdGFja1tzXSwgaSwgITEpIDwgMCkge1xuICAgICAgICBsZXQgbyA9IHRoaXMuZmluZEZvcmNlZFJlZHVjdGlvbigpO1xuICAgICAgICBpZiAobyA9PSBudWxsKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgbiA9IG87XG4gICAgICB9XG4gICAgICB0aGlzLnN0b3JlTm9kZSgwLCB0aGlzLnBvcywgdGhpcy5wb3MsIDQsICEwKSwgdGhpcy5zY29yZSAtPSAxMDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnJlZHVjZVBvcyA9IHRoaXMucG9zLCB0aGlzLnJlZHVjZShuKSwgITA7XG4gIH1cbiAgLyoqXG4gIFRyeSB0byBzY2FuIHRocm91Z2ggdGhlIGF1dG9tYXRvbiB0byBmaW5kIHNvbWUga2luZCBvZiByZWR1Y3Rpb25cbiAgdGhhdCBjYW4gYmUgYXBwbGllZC4gVXNlZCB3aGVuIHRoZSByZWd1bGFyIEZvcmNlZFJlZHVjZSBmaWVsZFxuICBpc24ndCBhIHZhbGlkIGFjdGlvbi4gQGludGVybmFsXG4gICovXG4gIGZpbmRGb3JjZWRSZWR1Y3Rpb24oKSB7XG4gICAgbGV0IHsgcGFyc2VyOiBlIH0gPSB0aGlzLnAsIG4gPSBbXSwgciA9IChpLCBzKSA9PiB7XG4gICAgICBpZiAoIW4uaW5jbHVkZXMoaSkpXG4gICAgICAgIHJldHVybiBuLnB1c2goaSksIGUuYWxsQWN0aW9ucyhpLCAobykgPT4ge1xuICAgICAgICAgIGlmICghKG8gJiAzOTMyMTYpKVxuICAgICAgICAgICAgaWYgKG8gJiA2NTUzNikge1xuICAgICAgICAgICAgICBsZXQgYSA9IChvID4+IDE5KSAtIHM7XG4gICAgICAgICAgICAgIGlmIChhID4gMSkge1xuICAgICAgICAgICAgICAgIGxldCBsID0gbyAmIDY1NTM1LCBjID0gdGhpcy5zdGFjay5sZW5ndGggLSBhICogMztcbiAgICAgICAgICAgICAgICBpZiAoYyA+PSAwICYmIGUuZ2V0R290byh0aGlzLnN0YWNrW2NdLCBsLCAhMSkgPj0gMClcbiAgICAgICAgICAgICAgICAgIHJldHVybiBhIDw8IDE5IHwgNjU1MzYgfCBsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsZXQgYSA9IHIobywgcyArIDEpO1xuICAgICAgICAgICAgICBpZiAoYSAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiByKHRoaXMuc3RhdGUsIDApO1xuICB9XG4gIC8qKlxuICBAaW50ZXJuYWxcbiAgKi9cbiAgZm9yY2VBbGwoKSB7XG4gICAgZm9yICg7ICF0aGlzLnAucGFyc2VyLnN0YXRlRmxhZyhcbiAgICAgIHRoaXMuc3RhdGUsXG4gICAgICAyXG4gICAgICAvKiBTdGF0ZUZsYWcuQWNjZXB0aW5nICovXG4gICAgKTsgKVxuICAgICAgaWYgKCF0aGlzLmZvcmNlUmVkdWNlKCkpIHtcbiAgICAgICAgdGhpcy5zdG9yZU5vZGUoMCwgdGhpcy5wb3MsIHRoaXMucG9zLCA0LCAhMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICBDaGVjayB3aGV0aGVyIHRoaXMgc3RhdGUgaGFzIG5vIGZ1cnRoZXIgYWN0aW9ucyAoYXNzdW1lZCB0byBiZSBhIGRpcmVjdCBkZXNjZW5kYW50IG9mIHRoZVxuICB0b3Agc3RhdGUsIHNpbmNlIGFueSBvdGhlciBzdGF0ZXMgbXVzdCBiZSBhYmxlIHRvIGNvbnRpbnVlXG4gIHNvbWVob3cpLiBAaW50ZXJuYWxcbiAgKi9cbiAgZ2V0IGRlYWRFbmQoKSB7XG4gICAgaWYgKHRoaXMuc3RhY2subGVuZ3RoICE9IDMpXG4gICAgICByZXR1cm4gITE7XG4gICAgbGV0IHsgcGFyc2VyOiBlIH0gPSB0aGlzLnA7XG4gICAgcmV0dXJuIGUuZGF0YVtlLnN0YXRlU2xvdChcbiAgICAgIHRoaXMuc3RhdGUsXG4gICAgICAxXG4gICAgICAvKiBQYXJzZVN0YXRlLkFjdGlvbnMgKi9cbiAgICApXSA9PSA2NTUzNSAmJiAhZS5zdGF0ZVNsb3QoXG4gICAgICB0aGlzLnN0YXRlLFxuICAgICAgNFxuICAgICAgLyogUGFyc2VTdGF0ZS5EZWZhdWx0UmVkdWNlICovXG4gICAgKTtcbiAgfVxuICAvKipcbiAgUmVzdGFydCB0aGUgc3RhY2sgKHB1dCBpdCBiYWNrIGluIGl0cyBzdGFydCBzdGF0ZSkuIE9ubHkgc2FmZVxuICB3aGVuIHRoaXMuc3RhY2subGVuZ3RoID09IDMgKHN0YXRlIGlzIGRpcmVjdGx5IGJlbG93IHRoZSB0b3BcbiAgc3RhdGUpLiBAaW50ZXJuYWxcbiAgKi9cbiAgcmVzdGFydCgpIHtcbiAgICB0aGlzLnN0b3JlTm9kZSgwLCB0aGlzLnBvcywgdGhpcy5wb3MsIDQsICEwKSwgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhY2tbMF0sIHRoaXMuc3RhY2subGVuZ3RoID0gMDtcbiAgfVxuICAvKipcbiAgQGludGVybmFsXG4gICovXG4gIHNhbWVTdGF0ZShlKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT0gZS5zdGF0ZSB8fCB0aGlzLnN0YWNrLmxlbmd0aCAhPSBlLnN0YWNrLmxlbmd0aClcbiAgICAgIHJldHVybiAhMTtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IHRoaXMuc3RhY2subGVuZ3RoOyBuICs9IDMpXG4gICAgICBpZiAodGhpcy5zdGFja1tuXSAhPSBlLnN0YWNrW25dKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIC8qKlxuICBHZXQgdGhlIHBhcnNlciB1c2VkIGJ5IHRoaXMgc3RhY2suXG4gICovXG4gIGdldCBwYXJzZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucC5wYXJzZXI7XG4gIH1cbiAgLyoqXG4gIFRlc3Qgd2hldGhlciBhIGdpdmVuIGRpYWxlY3QgKGJ5IG51bWVyaWMgSUQsIGFzIGV4cG9ydGVkIGZyb21cbiAgdGhlIHRlcm1zIGZpbGUpIGlzIGVuYWJsZWQuXG4gICovXG4gIGRpYWxlY3RFbmFibGVkKGUpIHtcbiAgICByZXR1cm4gdGhpcy5wLnBhcnNlci5kaWFsZWN0LmZsYWdzW2VdO1xuICB9XG4gIHNoaWZ0Q29udGV4dChlLCBuKSB7XG4gICAgdGhpcy5jdXJDb250ZXh0ICYmIHRoaXMudXBkYXRlQ29udGV4dCh0aGlzLmN1ckNvbnRleHQudHJhY2tlci5zaGlmdCh0aGlzLmN1ckNvbnRleHQuY29udGV4dCwgZSwgdGhpcywgdGhpcy5wLnN0cmVhbS5yZXNldChuKSkpO1xuICB9XG4gIHJlZHVjZUNvbnRleHQoZSwgbikge1xuICAgIHRoaXMuY3VyQ29udGV4dCAmJiB0aGlzLnVwZGF0ZUNvbnRleHQodGhpcy5jdXJDb250ZXh0LnRyYWNrZXIucmVkdWNlKHRoaXMuY3VyQ29udGV4dC5jb250ZXh0LCBlLCB0aGlzLCB0aGlzLnAuc3RyZWFtLnJlc2V0KG4pKSk7XG4gIH1cbiAgLyoqXG4gIEBpbnRlcm5hbFxuICAqL1xuICBlbWl0Q29udGV4dCgpIHtcbiAgICBsZXQgZSA9IHRoaXMuYnVmZmVyLmxlbmd0aCAtIDE7XG4gICAgKGUgPCAwIHx8IHRoaXMuYnVmZmVyW2VdICE9IC0zKSAmJiB0aGlzLmJ1ZmZlci5wdXNoKHRoaXMuY3VyQ29udGV4dC5oYXNoLCB0aGlzLnBvcywgdGhpcy5wb3MsIC0zKTtcbiAgfVxuICAvKipcbiAgQGludGVybmFsXG4gICovXG4gIGVtaXRMb29rQWhlYWQoKSB7XG4gICAgbGV0IGUgPSB0aGlzLmJ1ZmZlci5sZW5ndGggLSAxO1xuICAgIChlIDwgMCB8fCB0aGlzLmJ1ZmZlcltlXSAhPSAtNCkgJiYgdGhpcy5idWZmZXIucHVzaCh0aGlzLmxvb2tBaGVhZCwgdGhpcy5wb3MsIHRoaXMucG9zLCAtNCk7XG4gIH1cbiAgdXBkYXRlQ29udGV4dChlKSB7XG4gICAgaWYgKGUgIT0gdGhpcy5jdXJDb250ZXh0LmNvbnRleHQpIHtcbiAgICAgIGxldCBuID0gbmV3IG4wKHRoaXMuY3VyQ29udGV4dC50cmFja2VyLCBlKTtcbiAgICAgIG4uaGFzaCAhPSB0aGlzLmN1ckNvbnRleHQuaGFzaCAmJiB0aGlzLmVtaXRDb250ZXh0KCksIHRoaXMuY3VyQ29udGV4dCA9IG47XG4gICAgfVxuICB9XG4gIC8qKlxuICBAaW50ZXJuYWxcbiAgKi9cbiAgc2V0TG9va0FoZWFkKGUpIHtcbiAgICBlID4gdGhpcy5sb29rQWhlYWQgJiYgKHRoaXMuZW1pdExvb2tBaGVhZCgpLCB0aGlzLmxvb2tBaGVhZCA9IGUpO1xuICB9XG4gIC8qKlxuICBAaW50ZXJuYWxcbiAgKi9cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5jdXJDb250ZXh0ICYmIHRoaXMuY3VyQ29udGV4dC50cmFja2VyLnN0cmljdCAmJiB0aGlzLmVtaXRDb250ZXh0KCksIHRoaXMubG9va0FoZWFkID4gMCAmJiB0aGlzLmVtaXRMb29rQWhlYWQoKTtcbiAgfVxufVxuY2xhc3MgbjAge1xuICBjb25zdHJ1Y3RvcihlLCBuKSB7XG4gICAgdGhpcy50cmFja2VyID0gZSwgdGhpcy5jb250ZXh0ID0gbiwgdGhpcy5oYXNoID0gZS5zdHJpY3QgPyBlLmhhc2gobikgOiAwO1xuICB9XG59XG5jbGFzcyB1ViB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLnN0YXJ0ID0gZSwgdGhpcy5zdGF0ZSA9IGUuc3RhdGUsIHRoaXMuc3RhY2sgPSBlLnN0YWNrLCB0aGlzLmJhc2UgPSB0aGlzLnN0YWNrLmxlbmd0aDtcbiAgfVxuICByZWR1Y2UoZSkge1xuICAgIGxldCBuID0gZSAmIDY1NTM1LCByID0gZSA+PiAxOTtcbiAgICByID09IDAgPyAodGhpcy5zdGFjayA9PSB0aGlzLnN0YXJ0LnN0YWNrICYmICh0aGlzLnN0YWNrID0gdGhpcy5zdGFjay5zbGljZSgpKSwgdGhpcy5zdGFjay5wdXNoKHRoaXMuc3RhdGUsIDAsIDApLCB0aGlzLmJhc2UgKz0gMykgOiB0aGlzLmJhc2UgLT0gKHIgLSAxKSAqIDM7XG4gICAgbGV0IGkgPSB0aGlzLnN0YXJ0LnAucGFyc2VyLmdldEdvdG8odGhpcy5zdGFja1t0aGlzLmJhc2UgLSAzXSwgbiwgITApO1xuICAgIHRoaXMuc3RhdGUgPSBpO1xuICB9XG59XG5jbGFzcyB6dSB7XG4gIGNvbnN0cnVjdG9yKGUsIG4sIHIpIHtcbiAgICB0aGlzLnN0YWNrID0gZSwgdGhpcy5wb3MgPSBuLCB0aGlzLmluZGV4ID0gciwgdGhpcy5idWZmZXIgPSBlLmJ1ZmZlciwgdGhpcy5pbmRleCA9PSAwICYmIHRoaXMubWF5YmVOZXh0KCk7XG4gIH1cbiAgc3RhdGljIGNyZWF0ZShlLCBuID0gZS5idWZmZXJCYXNlICsgZS5idWZmZXIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyB6dShlLCBuLCBuIC0gZS5idWZmZXJCYXNlKTtcbiAgfVxuICBtYXliZU5leHQoKSB7XG4gICAgbGV0IGUgPSB0aGlzLnN0YWNrLnBhcmVudDtcbiAgICBlICE9IG51bGwgJiYgKHRoaXMuaW5kZXggPSB0aGlzLnN0YWNrLmJ1ZmZlckJhc2UgLSBlLmJ1ZmZlckJhc2UsIHRoaXMuc3RhY2sgPSBlLCB0aGlzLmJ1ZmZlciA9IGUuYnVmZmVyKTtcbiAgfVxuICBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSA0XTtcbiAgfVxuICBnZXQgc3RhcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAzXTtcbiAgfVxuICBnZXQgZW5kKCkge1xuICAgIHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMl07XG4gIH1cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAxXTtcbiAgfVxuICBuZXh0KCkge1xuICAgIHRoaXMuaW5kZXggLT0gNCwgdGhpcy5wb3MgLT0gNCwgdGhpcy5pbmRleCA9PSAwICYmIHRoaXMubWF5YmVOZXh0KCk7XG4gIH1cbiAgZm9yaygpIHtcbiAgICByZXR1cm4gbmV3IHp1KHRoaXMuc3RhY2ssIHRoaXMucG9zLCB0aGlzLmluZGV4KTtcbiAgfVxufVxuZnVuY3Rpb24gVmEodCwgZSA9IFVpbnQxNkFycmF5KSB7XG4gIGlmICh0eXBlb2YgdCAhPSBcInN0cmluZ1wiKVxuICAgIHJldHVybiB0O1xuICBsZXQgbiA9IG51bGw7XG4gIGZvciAobGV0IHIgPSAwLCBpID0gMDsgciA8IHQubGVuZ3RoOyApIHtcbiAgICBsZXQgcyA9IDA7XG4gICAgZm9yICg7IDsgKSB7XG4gICAgICBsZXQgbyA9IHQuY2hhckNvZGVBdChyKyspLCBhID0gITE7XG4gICAgICBpZiAobyA9PSAxMjYpIHtcbiAgICAgICAgcyA9IDY1NTM1O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG8gPj0gOTIgJiYgby0tLCBvID49IDM0ICYmIG8tLTtcbiAgICAgIGxldCBsID0gbyAtIDMyO1xuICAgICAgaWYgKGwgPj0gNDYgJiYgKGwgLT0gNDYsIGEgPSAhMCksIHMgKz0gbCwgYSlcbiAgICAgICAgYnJlYWs7XG4gICAgICBzICo9IDQ2O1xuICAgIH1cbiAgICBuID8gbltpKytdID0gcyA6IG4gPSBuZXcgZShzKTtcbiAgfVxuICByZXR1cm4gbjtcbn1cbmNsYXNzIGN1IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zdGFydCA9IC0xLCB0aGlzLnZhbHVlID0gLTEsIHRoaXMuZW5kID0gLTEsIHRoaXMuZXh0ZW5kZWQgPSAtMSwgdGhpcy5sb29rQWhlYWQgPSAwLCB0aGlzLm1hc2sgPSAwLCB0aGlzLmNvbnRleHQgPSAwO1xuICB9XG59XG5jb25zdCByMCA9IG5ldyBjdSgpO1xuY2xhc3MgZFYge1xuICAvKipcbiAgQGludGVybmFsXG4gICovXG4gIGNvbnN0cnVjdG9yKGUsIG4pIHtcbiAgICB0aGlzLmlucHV0ID0gZSwgdGhpcy5yYW5nZXMgPSBuLCB0aGlzLmNodW5rID0gXCJcIiwgdGhpcy5jaHVua09mZiA9IDAsIHRoaXMuY2h1bmsyID0gXCJcIiwgdGhpcy5jaHVuazJQb3MgPSAwLCB0aGlzLm5leHQgPSAtMSwgdGhpcy50b2tlbiA9IHIwLCB0aGlzLnJhbmdlSW5kZXggPSAwLCB0aGlzLnBvcyA9IHRoaXMuY2h1bmtQb3MgPSBuWzBdLmZyb20sIHRoaXMucmFuZ2UgPSBuWzBdLCB0aGlzLmVuZCA9IG5bbi5sZW5ndGggLSAxXS50bywgdGhpcy5yZWFkTmV4dCgpO1xuICB9XG4gIC8qKlxuICBAaW50ZXJuYWxcbiAgKi9cbiAgcmVzb2x2ZU9mZnNldChlLCBuKSB7XG4gICAgbGV0IHIgPSB0aGlzLnJhbmdlLCBpID0gdGhpcy5yYW5nZUluZGV4LCBzID0gdGhpcy5wb3MgKyBlO1xuICAgIGZvciAoOyBzIDwgci5mcm9tOyApIHtcbiAgICAgIGlmICghaSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBsZXQgbyA9IHRoaXMucmFuZ2VzWy0taV07XG4gICAgICBzIC09IHIuZnJvbSAtIG8udG8sIHIgPSBvO1xuICAgIH1cbiAgICBmb3IgKDsgbiA8IDAgPyBzID4gci50byA6IHMgPj0gci50bzsgKSB7XG4gICAgICBpZiAoaSA9PSB0aGlzLnJhbmdlcy5sZW5ndGggLSAxKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGxldCBvID0gdGhpcy5yYW5nZXNbKytpXTtcbiAgICAgIHMgKz0gby5mcm9tIC0gci50bywgciA9IG87XG4gICAgfVxuICAgIHJldHVybiBzO1xuICB9XG4gIC8qKlxuICBAaW50ZXJuYWxcbiAgKi9cbiAgY2xpcFBvcyhlKSB7XG4gICAgaWYgKGUgPj0gdGhpcy5yYW5nZS5mcm9tICYmIGUgPCB0aGlzLnJhbmdlLnRvKVxuICAgICAgcmV0dXJuIGU7XG4gICAgZm9yIChsZXQgbiBvZiB0aGlzLnJhbmdlcylcbiAgICAgIGlmIChuLnRvID4gZSlcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KGUsIG4uZnJvbSk7XG4gICAgcmV0dXJuIHRoaXMuZW5kO1xuICB9XG4gIC8qKlxuICBMb29rIGF0IGEgY29kZSB1bml0IG5lYXIgdGhlIHN0cmVhbSBwb3NpdGlvbi4gYC5wZWVrKDApYCBlcXVhbHNcbiAgYC5uZXh0YCwgYC5wZWVrKC0xKWAgZ2l2ZXMgeW91IHRoZSBwcmV2aW91cyBjaGFyYWN0ZXIsIGFuZCBzb1xuICBvbi5cbiAgXG4gIE5vdGUgdGhhdCBsb29raW5nIGFyb3VuZCBkdXJpbmcgdG9rZW5pemluZyBjcmVhdGVzIGRlcGVuZGVuY2llc1xuICBvbiBwb3RlbnRpYWxseSBmYXItYXdheSBjb250ZW50LCB3aGljaCBtYXkgcmVkdWNlIHRoZVxuICBlZmZlY3RpdmVuZXNzIGluY3JlbWVudGFsIHBhcnNpbmfigJR3aGVuIGxvb2tpbmcgZm9yd2FyZOKAlG9yIGV2ZW5cbiAgY2F1c2UgaW52YWxpZCByZXBhcnNlcyB3aGVuIGxvb2tpbmcgYmFja3dhcmQgbW9yZSB0aGFuIDI1IGNvZGVcbiAgdW5pdHMsIHNpbmNlIHRoZSBsaWJyYXJ5IGRvZXMgbm90IHRyYWNrIGxvb2tiZWhpbmQuXG4gICovXG4gIHBlZWsoZSkge1xuICAgIGxldCBuID0gdGhpcy5jaHVua09mZiArIGUsIHIsIGk7XG4gICAgaWYgKG4gPj0gMCAmJiBuIDwgdGhpcy5jaHVuay5sZW5ndGgpXG4gICAgICByID0gdGhpcy5wb3MgKyBlLCBpID0gdGhpcy5jaHVuay5jaGFyQ29kZUF0KG4pO1xuICAgIGVsc2Uge1xuICAgICAgbGV0IHMgPSB0aGlzLnJlc29sdmVPZmZzZXQoZSwgMSk7XG4gICAgICBpZiAocyA9PSBudWxsKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICBpZiAociA9IHMsIHIgPj0gdGhpcy5jaHVuazJQb3MgJiYgciA8IHRoaXMuY2h1bmsyUG9zICsgdGhpcy5jaHVuazIubGVuZ3RoKVxuICAgICAgICBpID0gdGhpcy5jaHVuazIuY2hhckNvZGVBdChyIC0gdGhpcy5jaHVuazJQb3MpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGxldCBvID0gdGhpcy5yYW5nZUluZGV4LCBhID0gdGhpcy5yYW5nZTtcbiAgICAgICAgZm9yICg7IGEudG8gPD0gcjsgKVxuICAgICAgICAgIGEgPSB0aGlzLnJhbmdlc1srK29dO1xuICAgICAgICB0aGlzLmNodW5rMiA9IHRoaXMuaW5wdXQuY2h1bmsodGhpcy5jaHVuazJQb3MgPSByKSwgciArIHRoaXMuY2h1bmsyLmxlbmd0aCA+IGEudG8gJiYgKHRoaXMuY2h1bmsyID0gdGhpcy5jaHVuazIuc2xpY2UoMCwgYS50byAtIHIpKSwgaSA9IHRoaXMuY2h1bmsyLmNoYXJDb2RlQXQoMCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByID49IHRoaXMudG9rZW4ubG9va0FoZWFkICYmICh0aGlzLnRva2VuLmxvb2tBaGVhZCA9IHIgKyAxKSwgaTtcbiAgfVxuICAvKipcbiAgQWNjZXB0IGEgdG9rZW4uIEJ5IGRlZmF1bHQsIHRoZSBlbmQgb2YgdGhlIHRva2VuIGlzIHNldCB0byB0aGVcbiAgY3VycmVudCBzdHJlYW0gcG9zaXRpb24sIGJ1dCB5b3UgY2FuIHBhc3MgYW4gb2Zmc2V0IChyZWxhdGl2ZSB0b1xuICB0aGUgc3RyZWFtIHBvc2l0aW9uKSB0byBjaGFuZ2UgdGhhdC5cbiAgKi9cbiAgYWNjZXB0VG9rZW4oZSwgbiA9IDApIHtcbiAgICBsZXQgciA9IG4gPyB0aGlzLnJlc29sdmVPZmZzZXQobiwgLTEpIDogdGhpcy5wb3M7XG4gICAgaWYgKHIgPT0gbnVsbCB8fCByIDwgdGhpcy50b2tlbi5zdGFydClcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVG9rZW4gZW5kIG91dCBvZiBib3VuZHNcIik7XG4gICAgdGhpcy50b2tlbi52YWx1ZSA9IGUsIHRoaXMudG9rZW4uZW5kID0gcjtcbiAgfVxuICAvKipcbiAgQWNjZXB0IGEgdG9rZW4gZW5kaW5nIGF0IGEgc3BlY2lmaWMgZ2l2ZW4gcG9zaXRpb24uXG4gICovXG4gIGFjY2VwdFRva2VuVG8oZSwgbikge1xuICAgIHRoaXMudG9rZW4udmFsdWUgPSBlLCB0aGlzLnRva2VuLmVuZCA9IG47XG4gIH1cbiAgZ2V0Q2h1bmsoKSB7XG4gICAgaWYgKHRoaXMucG9zID49IHRoaXMuY2h1bmsyUG9zICYmIHRoaXMucG9zIDwgdGhpcy5jaHVuazJQb3MgKyB0aGlzLmNodW5rMi5sZW5ndGgpIHtcbiAgICAgIGxldCB7IGNodW5rOiBlLCBjaHVua1BvczogbiB9ID0gdGhpcztcbiAgICAgIHRoaXMuY2h1bmsgPSB0aGlzLmNodW5rMiwgdGhpcy5jaHVua1BvcyA9IHRoaXMuY2h1bmsyUG9zLCB0aGlzLmNodW5rMiA9IGUsIHRoaXMuY2h1bmsyUG9zID0gbiwgdGhpcy5jaHVua09mZiA9IHRoaXMucG9zIC0gdGhpcy5jaHVua1BvcztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jaHVuazIgPSB0aGlzLmNodW5rLCB0aGlzLmNodW5rMlBvcyA9IHRoaXMuY2h1bmtQb3M7XG4gICAgICBsZXQgZSA9IHRoaXMuaW5wdXQuY2h1bmsodGhpcy5wb3MpLCBuID0gdGhpcy5wb3MgKyBlLmxlbmd0aDtcbiAgICAgIHRoaXMuY2h1bmsgPSBuID4gdGhpcy5yYW5nZS50byA/IGUuc2xpY2UoMCwgdGhpcy5yYW5nZS50byAtIHRoaXMucG9zKSA6IGUsIHRoaXMuY2h1bmtQb3MgPSB0aGlzLnBvcywgdGhpcy5jaHVua09mZiA9IDA7XG4gICAgfVxuICB9XG4gIHJlYWROZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmNodW5rT2ZmID49IHRoaXMuY2h1bmsubGVuZ3RoICYmICh0aGlzLmdldENodW5rKCksIHRoaXMuY2h1bmtPZmYgPT0gdGhpcy5jaHVuay5sZW5ndGgpID8gdGhpcy5uZXh0ID0gLTEgOiB0aGlzLm5leHQgPSB0aGlzLmNodW5rLmNoYXJDb2RlQXQodGhpcy5jaHVua09mZik7XG4gIH1cbiAgLyoqXG4gIE1vdmUgdGhlIHN0cmVhbSBmb3J3YXJkIE4gKGRlZmF1bHRzIHRvIDEpIGNvZGUgdW5pdHMuIFJldHVybnNcbiAgdGhlIG5ldyB2YWx1ZSBvZiBbYG5leHRgXSgjbHIuSW5wdXRTdHJlYW0ubmV4dCkuXG4gICovXG4gIGFkdmFuY2UoZSA9IDEpIHtcbiAgICBmb3IgKHRoaXMuY2h1bmtPZmYgKz0gZTsgdGhpcy5wb3MgKyBlID49IHRoaXMucmFuZ2UudG87ICkge1xuICAgICAgaWYgKHRoaXMucmFuZ2VJbmRleCA9PSB0aGlzLnJhbmdlcy5sZW5ndGggLSAxKVxuICAgICAgICByZXR1cm4gdGhpcy5zZXREb25lKCk7XG4gICAgICBlIC09IHRoaXMucmFuZ2UudG8gLSB0aGlzLnBvcywgdGhpcy5yYW5nZSA9IHRoaXMucmFuZ2VzWysrdGhpcy5yYW5nZUluZGV4XSwgdGhpcy5wb3MgPSB0aGlzLnJhbmdlLmZyb207XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnBvcyArPSBlLCB0aGlzLnBvcyA+PSB0aGlzLnRva2VuLmxvb2tBaGVhZCAmJiAodGhpcy50b2tlbi5sb29rQWhlYWQgPSB0aGlzLnBvcyArIDEpLCB0aGlzLnJlYWROZXh0KCk7XG4gIH1cbiAgc2V0RG9uZSgpIHtcbiAgICByZXR1cm4gdGhpcy5wb3MgPSB0aGlzLmNodW5rUG9zID0gdGhpcy5lbmQsIHRoaXMucmFuZ2UgPSB0aGlzLnJhbmdlc1t0aGlzLnJhbmdlSW5kZXggPSB0aGlzLnJhbmdlcy5sZW5ndGggLSAxXSwgdGhpcy5jaHVuayA9IFwiXCIsIHRoaXMubmV4dCA9IC0xO1xuICB9XG4gIC8qKlxuICBAaW50ZXJuYWxcbiAgKi9cbiAgcmVzZXQoZSwgbikge1xuICAgIGlmIChuID8gKHRoaXMudG9rZW4gPSBuLCBuLnN0YXJ0ID0gZSwgbi5sb29rQWhlYWQgPSBlICsgMSwgbi52YWx1ZSA9IG4uZXh0ZW5kZWQgPSAtMSkgOiB0aGlzLnRva2VuID0gcjAsIHRoaXMucG9zICE9IGUpIHtcbiAgICAgIGlmICh0aGlzLnBvcyA9IGUsIGUgPT0gdGhpcy5lbmQpXG4gICAgICAgIHJldHVybiB0aGlzLnNldERvbmUoKSwgdGhpcztcbiAgICAgIGZvciAoOyBlIDwgdGhpcy5yYW5nZS5mcm9tOyApXG4gICAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLnJhbmdlc1stLXRoaXMucmFuZ2VJbmRleF07XG4gICAgICBmb3IgKDsgZSA+PSB0aGlzLnJhbmdlLnRvOyApXG4gICAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLnJhbmdlc1srK3RoaXMucmFuZ2VJbmRleF07XG4gICAgICBlID49IHRoaXMuY2h1bmtQb3MgJiYgZSA8IHRoaXMuY2h1bmtQb3MgKyB0aGlzLmNodW5rLmxlbmd0aCA/IHRoaXMuY2h1bmtPZmYgPSBlIC0gdGhpcy5jaHVua1BvcyA6ICh0aGlzLmNodW5rID0gXCJcIiwgdGhpcy5jaHVua09mZiA9IDApLCB0aGlzLnJlYWROZXh0KCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICBAaW50ZXJuYWxcbiAgKi9cbiAgcmVhZChlLCBuKSB7XG4gICAgaWYgKGUgPj0gdGhpcy5jaHVua1BvcyAmJiBuIDw9IHRoaXMuY2h1bmtQb3MgKyB0aGlzLmNodW5rLmxlbmd0aClcbiAgICAgIHJldHVybiB0aGlzLmNodW5rLnNsaWNlKGUgLSB0aGlzLmNodW5rUG9zLCBuIC0gdGhpcy5jaHVua1Bvcyk7XG4gICAgaWYgKGUgPj0gdGhpcy5jaHVuazJQb3MgJiYgbiA8PSB0aGlzLmNodW5rMlBvcyArIHRoaXMuY2h1bmsyLmxlbmd0aClcbiAgICAgIHJldHVybiB0aGlzLmNodW5rMi5zbGljZShlIC0gdGhpcy5jaHVuazJQb3MsIG4gLSB0aGlzLmNodW5rMlBvcyk7XG4gICAgaWYgKGUgPj0gdGhpcy5yYW5nZS5mcm9tICYmIG4gPD0gdGhpcy5yYW5nZS50bylcbiAgICAgIHJldHVybiB0aGlzLmlucHV0LnJlYWQoZSwgbik7XG4gICAgbGV0IHIgPSBcIlwiO1xuICAgIGZvciAobGV0IGkgb2YgdGhpcy5yYW5nZXMpIHtcbiAgICAgIGlmIChpLmZyb20gPj0gbilcbiAgICAgICAgYnJlYWs7XG4gICAgICBpLnRvID4gZSAmJiAociArPSB0aGlzLmlucHV0LnJlYWQoTWF0aC5tYXgoaS5mcm9tLCBlKSwgTWF0aC5taW4oaS50bywgbikpKTtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbn1cbmNsYXNzIENvIHtcbiAgY29uc3RydWN0b3IoZSwgbikge1xuICAgIHRoaXMuZGF0YSA9IGUsIHRoaXMuaWQgPSBuO1xuICB9XG4gIHRva2VuKGUsIG4pIHtcbiAgICBsZXQgeyBwYXJzZXI6IHIgfSA9IG4ucDtcbiAgICBSeCh0aGlzLmRhdGEsIGUsIG4sIHRoaXMuaWQsIHIuZGF0YSwgci50b2tlblByZWNUYWJsZSk7XG4gIH1cbn1cbkNvLnByb3RvdHlwZS5jb250ZXh0dWFsID0gQ28ucHJvdG90eXBlLmZhbGxiYWNrID0gQ28ucHJvdG90eXBlLmV4dGVuZCA9ICExO1xuY2xhc3MgSHUge1xuICBjb25zdHJ1Y3RvcihlLCBuLCByKSB7XG4gICAgdGhpcy5wcmVjVGFibGUgPSBuLCB0aGlzLmVsc2VUb2tlbiA9IHIsIHRoaXMuZGF0YSA9IHR5cGVvZiBlID09IFwic3RyaW5nXCIgPyBWYShlKSA6IGU7XG4gIH1cbiAgdG9rZW4oZSwgbikge1xuICAgIGxldCByID0gZS5wb3MsIGkgPSAwO1xuICAgIGZvciAoOyA7ICkge1xuICAgICAgbGV0IHMgPSBlLm5leHQgPCAwLCBvID0gZS5yZXNvbHZlT2Zmc2V0KDEsIDEpO1xuICAgICAgaWYgKFJ4KHRoaXMuZGF0YSwgZSwgbiwgMCwgdGhpcy5kYXRhLCB0aGlzLnByZWNUYWJsZSksIGUudG9rZW4udmFsdWUgPiAtMSlcbiAgICAgICAgYnJlYWs7XG4gICAgICBpZiAodGhpcy5lbHNlVG9rZW4gPT0gbnVsbClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKHMgfHwgaSsrLCBvID09IG51bGwpXG4gICAgICAgIGJyZWFrO1xuICAgICAgZS5yZXNldChvLCBlLnRva2VuKTtcbiAgICB9XG4gICAgaSAmJiAoZS5yZXNldChyLCBlLnRva2VuKSwgZS5hY2NlcHRUb2tlbih0aGlzLmVsc2VUb2tlbiwgaSkpO1xuICB9XG59XG5IdS5wcm90b3R5cGUuY29udGV4dHVhbCA9IENvLnByb3RvdHlwZS5mYWxsYmFjayA9IENvLnByb3RvdHlwZS5leHRlbmQgPSAhMTtcbmNsYXNzIGduIHtcbiAgLyoqXG4gIENyZWF0ZSBhIHRva2VuaXplci4gVGhlIGZpcnN0IGFyZ3VtZW50IGlzIHRoZSBmdW5jdGlvbiB0aGF0LFxuICBnaXZlbiBhbiBpbnB1dCBzdHJlYW0sIHNjYW5zIGZvciB0aGUgdHlwZXMgb2YgdG9rZW5zIGl0XG4gIHJlY29nbml6ZXMgYXQgdGhlIHN0cmVhbSdzIHBvc2l0aW9uLCBhbmQgY2FsbHNcbiAgW2BhY2NlcHRUb2tlbmBdKCNsci5JbnB1dFN0cmVhbS5hY2NlcHRUb2tlbikgd2hlbiBpdCBmaW5kc1xuICBvbmUuXG4gICovXG4gIGNvbnN0cnVjdG9yKGUsIG4gPSB7fSkge1xuICAgIHRoaXMudG9rZW4gPSBlLCB0aGlzLmNvbnRleHR1YWwgPSAhIW4uY29udGV4dHVhbCwgdGhpcy5mYWxsYmFjayA9ICEhbi5mYWxsYmFjaywgdGhpcy5leHRlbmQgPSAhIW4uZXh0ZW5kO1xuICB9XG59XG5mdW5jdGlvbiBSeCh0LCBlLCBuLCByLCBpLCBzKSB7XG4gIGxldCBvID0gMCwgYSA9IDEgPDwgciwgeyBkaWFsZWN0OiBsIH0gPSBuLnAucGFyc2VyO1xuICBlOlxuICAgIGZvciAoOyBhICYgdFtvXTsgKSB7XG4gICAgICBsZXQgYyA9IHRbbyArIDFdO1xuICAgICAgZm9yIChsZXQgaCA9IG8gKyAzOyBoIDwgYzsgaCArPSAyKVxuICAgICAgICBpZiAoKHRbaCArIDFdICYgYSkgPiAwKSB7XG4gICAgICAgICAgbGV0IHAgPSB0W2hdO1xuICAgICAgICAgIGlmIChsLmFsbG93cyhwKSAmJiAoZS50b2tlbi52YWx1ZSA9PSAtMSB8fCBlLnRva2VuLnZhbHVlID09IHAgfHwgZlYocCwgZS50b2tlbi52YWx1ZSwgaSwgcykpKSB7XG4gICAgICAgICAgICBlLmFjY2VwdFRva2VuKHApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBsZXQgdSA9IGUubmV4dCwgZCA9IDAsIGYgPSB0W28gKyAyXTtcbiAgICAgIGlmIChlLm5leHQgPCAwICYmIGYgPiBkICYmIHRbYyArIGYgKiAzIC0gM10gPT0gNjU1MzUpIHtcbiAgICAgICAgbyA9IHRbYyArIGYgKiAzIC0gMV07XG4gICAgICAgIGNvbnRpbnVlIGU7XG4gICAgICB9XG4gICAgICBmb3IgKDsgZCA8IGY7ICkge1xuICAgICAgICBsZXQgaCA9IGQgKyBmID4+IDEsIHAgPSBjICsgaCArIChoIDw8IDEpLCBPID0gdFtwXSwgbSA9IHRbcCArIDFdIHx8IDY1NTM2O1xuICAgICAgICBpZiAodSA8IE8pXG4gICAgICAgICAgZiA9IGg7XG4gICAgICAgIGVsc2UgaWYgKHUgPj0gbSlcbiAgICAgICAgICBkID0gaCArIDE7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIG8gPSB0W3AgKyAyXSwgZS5hZHZhbmNlKCk7XG4gICAgICAgICAgY29udGludWUgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxufVxuZnVuY3Rpb24gaTAodCwgZSwgbikge1xuICBmb3IgKGxldCByID0gZSwgaTsgKGkgPSB0W3JdKSAhPSA2NTUzNTsgcisrKVxuICAgIGlmIChpID09IG4pXG4gICAgICByZXR1cm4gciAtIGU7XG4gIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIGZWKHQsIGUsIG4sIHIpIHtcbiAgbGV0IGkgPSBpMChuLCByLCBlKTtcbiAgcmV0dXJuIGkgPCAwIHx8IGkwKG4sIHIsIHQpIDwgaTtcbn1cbmNvbnN0IFFuID0gdHlwZW9mIHByb2Nlc3MgPCBcInVcIiAmJiBwcm9jZXNzLmVudiAmJiAvXFxicGFyc2VcXGIvLnRlc3QocHJvY2Vzcy5lbnYuTE9HKTtcbmxldCBqZiA9IG51bGw7XG5mdW5jdGlvbiBzMCh0LCBlLCBuKSB7XG4gIGxldCByID0gdC5jdXJzb3IobHQuSW5jbHVkZUFub255bW91cyk7XG4gIGZvciAoci5tb3ZlVG8oZSk7IDsgKVxuICAgIGlmICghKG4gPCAwID8gci5jaGlsZEJlZm9yZShlKSA6IHIuY2hpbGRBZnRlcihlKSkpXG4gICAgICBmb3IgKDsgOyApIHtcbiAgICAgICAgaWYgKChuIDwgMCA/IHIudG8gPCBlIDogci5mcm9tID4gZSkgJiYgIXIudHlwZS5pc0Vycm9yKVxuICAgICAgICAgIHJldHVybiBuIDwgMCA/IE1hdGgubWF4KDAsIE1hdGgubWluKFxuICAgICAgICAgICAgci50byAtIDEsXG4gICAgICAgICAgICBlIC0gMjVcbiAgICAgICAgICAgIC8qIFNhZmV0eS5NYXJnaW4gKi9cbiAgICAgICAgICApKSA6IE1hdGgubWluKHQubGVuZ3RoLCBNYXRoLm1heChcbiAgICAgICAgICAgIHIuZnJvbSArIDEsXG4gICAgICAgICAgICBlICsgMjVcbiAgICAgICAgICAgIC8qIFNhZmV0eS5NYXJnaW4gKi9cbiAgICAgICAgICApKTtcbiAgICAgICAgaWYgKG4gPCAwID8gci5wcmV2U2libGluZygpIDogci5uZXh0U2libGluZygpKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBpZiAoIXIucGFyZW50KCkpXG4gICAgICAgICAgcmV0dXJuIG4gPCAwID8gMCA6IHQubGVuZ3RoO1xuICAgICAgfVxufVxuY2xhc3MgaFYge1xuICBjb25zdHJ1Y3RvcihlLCBuKSB7XG4gICAgdGhpcy5mcmFnbWVudHMgPSBlLCB0aGlzLm5vZGVTZXQgPSBuLCB0aGlzLmkgPSAwLCB0aGlzLmZyYWdtZW50ID0gbnVsbCwgdGhpcy5zYWZlRnJvbSA9IC0xLCB0aGlzLnNhZmVUbyA9IC0xLCB0aGlzLnRyZWVzID0gW10sIHRoaXMuc3RhcnQgPSBbXSwgdGhpcy5pbmRleCA9IFtdLCB0aGlzLm5leHRGcmFnbWVudCgpO1xuICB9XG4gIG5leHRGcmFnbWVudCgpIHtcbiAgICBsZXQgZSA9IHRoaXMuZnJhZ21lbnQgPSB0aGlzLmkgPT0gdGhpcy5mcmFnbWVudHMubGVuZ3RoID8gbnVsbCA6IHRoaXMuZnJhZ21lbnRzW3RoaXMuaSsrXTtcbiAgICBpZiAoZSkge1xuICAgICAgZm9yICh0aGlzLnNhZmVGcm9tID0gZS5vcGVuU3RhcnQgPyBzMChlLnRyZWUsIGUuZnJvbSArIGUub2Zmc2V0LCAxKSAtIGUub2Zmc2V0IDogZS5mcm9tLCB0aGlzLnNhZmVUbyA9IGUub3BlbkVuZCA/IHMwKGUudHJlZSwgZS50byArIGUub2Zmc2V0LCAtMSkgLSBlLm9mZnNldCA6IGUudG87IHRoaXMudHJlZXMubGVuZ3RoOyApXG4gICAgICAgIHRoaXMudHJlZXMucG9wKCksIHRoaXMuc3RhcnQucG9wKCksIHRoaXMuaW5kZXgucG9wKCk7XG4gICAgICB0aGlzLnRyZWVzLnB1c2goZS50cmVlKSwgdGhpcy5zdGFydC5wdXNoKC1lLm9mZnNldCksIHRoaXMuaW5kZXgucHVzaCgwKSwgdGhpcy5uZXh0U3RhcnQgPSB0aGlzLnNhZmVGcm9tO1xuICAgIH0gZWxzZVxuICAgICAgdGhpcy5uZXh0U3RhcnQgPSAxZTk7XG4gIH1cbiAgLy8gYHBvc2AgbXVzdCBiZSA+PSBhbnkgcHJldmlvdXNseSBnaXZlbiBgcG9zYCBmb3IgdGhpcyBjdXJzb3JcbiAgbm9kZUF0KGUpIHtcbiAgICBpZiAoZSA8IHRoaXMubmV4dFN0YXJ0KVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgZm9yICg7IHRoaXMuZnJhZ21lbnQgJiYgdGhpcy5zYWZlVG8gPD0gZTsgKVxuICAgICAgdGhpcy5uZXh0RnJhZ21lbnQoKTtcbiAgICBpZiAoIXRoaXMuZnJhZ21lbnQpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBmb3IgKDsgOyApIHtcbiAgICAgIGxldCBuID0gdGhpcy50cmVlcy5sZW5ndGggLSAxO1xuICAgICAgaWYgKG4gPCAwKVxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0RnJhZ21lbnQoKSwgbnVsbDtcbiAgICAgIGxldCByID0gdGhpcy50cmVlc1tuXSwgaSA9IHRoaXMuaW5kZXhbbl07XG4gICAgICBpZiAoaSA9PSByLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICB0aGlzLnRyZWVzLnBvcCgpLCB0aGlzLnN0YXJ0LnBvcCgpLCB0aGlzLmluZGV4LnBvcCgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxldCBzID0gci5jaGlsZHJlbltpXSwgbyA9IHRoaXMuc3RhcnRbbl0gKyByLnBvc2l0aW9uc1tpXTtcbiAgICAgIGlmIChvID4gZSlcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dFN0YXJ0ID0gbywgbnVsbDtcbiAgICAgIGlmIChzIGluc3RhbmNlb2YgZ3QpIHtcbiAgICAgICAgaWYgKG8gPT0gZSkge1xuICAgICAgICAgIGlmIChvIDwgdGhpcy5zYWZlRnJvbSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIGxldCBhID0gbyArIHMubGVuZ3RoO1xuICAgICAgICAgIGlmIChhIDw9IHRoaXMuc2FmZVRvKSB7XG4gICAgICAgICAgICBsZXQgbCA9IHMucHJvcChSZS5sb29rQWhlYWQpO1xuICAgICAgICAgICAgaWYgKCFsIHx8IGEgKyBsIDwgdGhpcy5mcmFnbWVudC50bylcbiAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5kZXhbbl0rKywgbyArIHMubGVuZ3RoID49IE1hdGgubWF4KHRoaXMuc2FmZUZyb20sIGUpICYmICh0aGlzLnRyZWVzLnB1c2gocyksIHRoaXMuc3RhcnQucHVzaChvKSwgdGhpcy5pbmRleC5wdXNoKDApKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICB0aGlzLmluZGV4W25dKyssIHRoaXMubmV4dFN0YXJ0ID0gbyArIHMubGVuZ3RoO1xuICAgIH1cbiAgfVxufVxuY2xhc3MgcFYge1xuICBjb25zdHJ1Y3RvcihlLCBuKSB7XG4gICAgdGhpcy5zdHJlYW0gPSBuLCB0aGlzLnRva2VucyA9IFtdLCB0aGlzLm1haW5Ub2tlbiA9IG51bGwsIHRoaXMuYWN0aW9ucyA9IFtdLCB0aGlzLnRva2VucyA9IGUudG9rZW5pemVycy5tYXAoKHIpID0+IG5ldyBjdSgpKTtcbiAgfVxuICBnZXRBY3Rpb25zKGUpIHtcbiAgICBsZXQgbiA9IDAsIHIgPSBudWxsLCB7IHBhcnNlcjogaSB9ID0gZS5wLCB7IHRva2VuaXplcnM6IHMgfSA9IGksIG8gPSBpLnN0YXRlU2xvdChcbiAgICAgIGUuc3RhdGUsXG4gICAgICAzXG4gICAgICAvKiBQYXJzZVN0YXRlLlRva2VuaXplck1hc2sgKi9cbiAgICApLCBhID0gZS5jdXJDb250ZXh0ID8gZS5jdXJDb250ZXh0Lmhhc2ggOiAwLCBsID0gMDtcbiAgICBmb3IgKGxldCBjID0gMDsgYyA8IHMubGVuZ3RoOyBjKyspIHtcbiAgICAgIGlmICghKDEgPDwgYyAmIG8pKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGxldCB1ID0gc1tjXSwgZCA9IHRoaXMudG9rZW5zW2NdO1xuICAgICAgaWYgKCEociAmJiAhdS5mYWxsYmFjaykgJiYgKCh1LmNvbnRleHR1YWwgfHwgZC5zdGFydCAhPSBlLnBvcyB8fCBkLm1hc2sgIT0gbyB8fCBkLmNvbnRleHQgIT0gYSkgJiYgKHRoaXMudXBkYXRlQ2FjaGVkVG9rZW4oZCwgdSwgZSksIGQubWFzayA9IG8sIGQuY29udGV4dCA9IGEpLCBkLmxvb2tBaGVhZCA+IGQuZW5kICsgMjUgJiYgKGwgPSBNYXRoLm1heChkLmxvb2tBaGVhZCwgbCkpLCBkLnZhbHVlICE9IDApKSB7XG4gICAgICAgIGxldCBmID0gbjtcbiAgICAgICAgaWYgKGQuZXh0ZW5kZWQgPiAtMSAmJiAobiA9IHRoaXMuYWRkQWN0aW9ucyhlLCBkLmV4dGVuZGVkLCBkLmVuZCwgbikpLCBuID0gdGhpcy5hZGRBY3Rpb25zKGUsIGQudmFsdWUsIGQuZW5kLCBuKSwgIXUuZXh0ZW5kICYmIChyID0gZCwgbiA+IGYpKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKDsgdGhpcy5hY3Rpb25zLmxlbmd0aCA+IG47IClcbiAgICAgIHRoaXMuYWN0aW9ucy5wb3AoKTtcbiAgICByZXR1cm4gbCAmJiBlLnNldExvb2tBaGVhZChsKSwgIXIgJiYgZS5wb3MgPT0gdGhpcy5zdHJlYW0uZW5kICYmIChyID0gbmV3IGN1KCksIHIudmFsdWUgPSBlLnAucGFyc2VyLmVvZlRlcm0sIHIuc3RhcnQgPSByLmVuZCA9IGUucG9zLCBuID0gdGhpcy5hZGRBY3Rpb25zKGUsIHIudmFsdWUsIHIuZW5kLCBuKSksIHRoaXMubWFpblRva2VuID0gciwgdGhpcy5hY3Rpb25zO1xuICB9XG4gIGdldE1haW5Ub2tlbihlKSB7XG4gICAgaWYgKHRoaXMubWFpblRva2VuKVxuICAgICAgcmV0dXJuIHRoaXMubWFpblRva2VuO1xuICAgIGxldCBuID0gbmV3IGN1KCksIHsgcG9zOiByLCBwOiBpIH0gPSBlO1xuICAgIHJldHVybiBuLnN0YXJ0ID0gciwgbi5lbmQgPSBNYXRoLm1pbihyICsgMSwgaS5zdHJlYW0uZW5kKSwgbi52YWx1ZSA9IHIgPT0gaS5zdHJlYW0uZW5kID8gaS5wYXJzZXIuZW9mVGVybSA6IDAsIG47XG4gIH1cbiAgdXBkYXRlQ2FjaGVkVG9rZW4oZSwgbiwgcikge1xuICAgIGxldCBpID0gdGhpcy5zdHJlYW0uY2xpcFBvcyhyLnBvcyk7XG4gICAgaWYgKG4udG9rZW4odGhpcy5zdHJlYW0ucmVzZXQoaSwgZSksIHIpLCBlLnZhbHVlID4gLTEpIHtcbiAgICAgIGxldCB7IHBhcnNlcjogcyB9ID0gci5wO1xuICAgICAgZm9yIChsZXQgbyA9IDA7IG8gPCBzLnNwZWNpYWxpemVkLmxlbmd0aDsgbysrKVxuICAgICAgICBpZiAocy5zcGVjaWFsaXplZFtvXSA9PSBlLnZhbHVlKSB7XG4gICAgICAgICAgbGV0IGEgPSBzLnNwZWNpYWxpemVyc1tvXSh0aGlzLnN0cmVhbS5yZWFkKGUuc3RhcnQsIGUuZW5kKSwgcik7XG4gICAgICAgICAgaWYgKGEgPj0gMCAmJiByLnAucGFyc2VyLmRpYWxlY3QuYWxsb3dzKGEgPj4gMSkpIHtcbiAgICAgICAgICAgIGEgJiAxID8gZS5leHRlbmRlZCA9IGEgPj4gMSA6IGUudmFsdWUgPSBhID4+IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2VcbiAgICAgIGUudmFsdWUgPSAwLCBlLmVuZCA9IHRoaXMuc3RyZWFtLmNsaXBQb3MoaSArIDEpO1xuICB9XG4gIHB1dEFjdGlvbihlLCBuLCByLCBpKSB7XG4gICAgZm9yIChsZXQgcyA9IDA7IHMgPCBpOyBzICs9IDMpXG4gICAgICBpZiAodGhpcy5hY3Rpb25zW3NdID09IGUpXG4gICAgICAgIHJldHVybiBpO1xuICAgIHJldHVybiB0aGlzLmFjdGlvbnNbaSsrXSA9IGUsIHRoaXMuYWN0aW9uc1tpKytdID0gbiwgdGhpcy5hY3Rpb25zW2krK10gPSByLCBpO1xuICB9XG4gIGFkZEFjdGlvbnMoZSwgbiwgciwgaSkge1xuICAgIGxldCB7IHN0YXRlOiBzIH0gPSBlLCB7IHBhcnNlcjogbyB9ID0gZS5wLCB7IGRhdGE6IGEgfSA9IG87XG4gICAgZm9yIChsZXQgbCA9IDA7IGwgPCAyOyBsKyspXG4gICAgICBmb3IgKGxldCBjID0gby5zdGF0ZVNsb3QoXG4gICAgICAgIHMsXG4gICAgICAgIGwgPyAyIDogMVxuICAgICAgICAvKiBQYXJzZVN0YXRlLkFjdGlvbnMgKi9cbiAgICAgICk7IDsgYyArPSAzKSB7XG4gICAgICAgIGlmIChhW2NdID09IDY1NTM1KVxuICAgICAgICAgIGlmIChhW2MgKyAxXSA9PSAxKVxuICAgICAgICAgICAgYyA9IHRpKGEsIGMgKyAyKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGkgPT0gMCAmJiBhW2MgKyAxXSA9PSAyICYmIChpID0gdGhpcy5wdXRBY3Rpb24odGkoYSwgYyArIDIpLCBuLCByLCBpKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGFbY10gPT0gbiAmJiAoaSA9IHRoaXMucHV0QWN0aW9uKHRpKGEsIGMgKyAxKSwgbiwgciwgaSkpO1xuICAgICAgfVxuICAgIHJldHVybiBpO1xuICB9XG59XG5jbGFzcyBPViB7XG4gIGNvbnN0cnVjdG9yKGUsIG4sIHIsIGkpIHtcbiAgICB0aGlzLnBhcnNlciA9IGUsIHRoaXMuaW5wdXQgPSBuLCB0aGlzLnJhbmdlcyA9IGksIHRoaXMucmVjb3ZlcmluZyA9IDAsIHRoaXMubmV4dFN0YWNrSUQgPSA5ODEyLCB0aGlzLm1pblN0YWNrUG9zID0gMCwgdGhpcy5yZXVzZWQgPSBbXSwgdGhpcy5zdG9wcGVkQXQgPSBudWxsLCB0aGlzLmxhc3RCaWdSZWR1Y3Rpb25TdGFydCA9IC0xLCB0aGlzLmxhc3RCaWdSZWR1Y3Rpb25TaXplID0gMCwgdGhpcy5iaWdSZWR1Y3Rpb25Db3VudCA9IDAsIHRoaXMuc3RyZWFtID0gbmV3IGRWKG4sIGkpLCB0aGlzLnRva2VucyA9IG5ldyBwVihlLCB0aGlzLnN0cmVhbSksIHRoaXMudG9wVGVybSA9IGUudG9wWzFdO1xuICAgIGxldCB7IGZyb206IHMgfSA9IGlbMF07XG4gICAgdGhpcy5zdGFja3MgPSBbWXUuc3RhcnQodGhpcywgZS50b3BbMF0sIHMpXSwgdGhpcy5mcmFnbWVudHMgPSByLmxlbmd0aCAmJiB0aGlzLnN0cmVhbS5lbmQgLSBzID4gZS5idWZmZXJMZW5ndGggKiA0ID8gbmV3IGhWKHIsIGUubm9kZVNldCkgOiBudWxsO1xuICB9XG4gIGdldCBwYXJzZWRQb3MoKSB7XG4gICAgcmV0dXJuIHRoaXMubWluU3RhY2tQb3M7XG4gIH1cbiAgLy8gTW92ZSB0aGUgcGFyc2VyIGZvcndhcmQuIFRoaXMgd2lsbCBwcm9jZXNzIGFsbCBwYXJzZSBzdGFja3MgYXRcbiAgLy8gYHRoaXMucG9zYCBhbmQgdHJ5IHRvIGFkdmFuY2UgdGhlbSB0byBhIGZ1cnRoZXIgcG9zaXRpb24uIElmIG5vXG4gIC8vIHN0YWNrIGZvciBzdWNoIGEgcG9zaXRpb24gaXMgZm91bmQsIGl0J2xsIHN0YXJ0IGVycm9yLXJlY292ZXJ5LlxuICAvL1xuICAvLyBXaGVuIHRoZSBwYXJzZSBpcyBmaW5pc2hlZCwgdGhpcyB3aWxsIHJldHVybiBhIHN5bnRheCB0cmVlLiBXaGVuXG4gIC8vIG5vdCwgaXQgcmV0dXJucyBgbnVsbGAuXG4gIGFkdmFuY2UoKSB7XG4gICAgbGV0IGUgPSB0aGlzLnN0YWNrcywgbiA9IHRoaXMubWluU3RhY2tQb3MsIHIgPSB0aGlzLnN0YWNrcyA9IFtdLCBpLCBzO1xuICAgIGlmICh0aGlzLmJpZ1JlZHVjdGlvbkNvdW50ID4gMzAwICYmIGUubGVuZ3RoID09IDEpIHtcbiAgICAgIGxldCBbb10gPSBlO1xuICAgICAgZm9yICg7IG8uZm9yY2VSZWR1Y2UoKSAmJiBvLnN0YWNrLmxlbmd0aCAmJiBvLnN0YWNrW28uc3RhY2subGVuZ3RoIC0gMl0gPj0gdGhpcy5sYXN0QmlnUmVkdWN0aW9uU3RhcnQ7IClcbiAgICAgICAgO1xuICAgICAgdGhpcy5iaWdSZWR1Y3Rpb25Db3VudCA9IHRoaXMubGFzdEJpZ1JlZHVjdGlvblNpemUgPSAwO1xuICAgIH1cbiAgICBmb3IgKGxldCBvID0gMDsgbyA8IGUubGVuZ3RoOyBvKyspIHtcbiAgICAgIGxldCBhID0gZVtvXTtcbiAgICAgIGZvciAoOyA7ICkge1xuICAgICAgICBpZiAodGhpcy50b2tlbnMubWFpblRva2VuID0gbnVsbCwgYS5wb3MgPiBuKVxuICAgICAgICAgIHIucHVzaChhKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuYWR2YW5jZVN0YWNrKGEsIHIsIGUpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAge1xuICAgICAgICAgICAgaSB8fCAoaSA9IFtdLCBzID0gW10pLCBpLnB1c2goYSk7XG4gICAgICAgICAgICBsZXQgbCA9IHRoaXMudG9rZW5zLmdldE1haW5Ub2tlbihhKTtcbiAgICAgICAgICAgIHMucHVzaChsLnZhbHVlLCBsLmVuZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXIubGVuZ3RoKSB7XG4gICAgICBsZXQgbyA9IGkgJiYgbVYoaSk7XG4gICAgICBpZiAobylcbiAgICAgICAgcmV0dXJuIFFuICYmIGNvbnNvbGUubG9nKFwiRmluaXNoIHdpdGggXCIgKyB0aGlzLnN0YWNrSUQobykpLCB0aGlzLnN0YWNrVG9UcmVlKG8pO1xuICAgICAgaWYgKHRoaXMucGFyc2VyLnN0cmljdClcbiAgICAgICAgdGhyb3cgUW4gJiYgaSAmJiBjb25zb2xlLmxvZyhcIlN0dWNrIHdpdGggdG9rZW4gXCIgKyAodGhpcy50b2tlbnMubWFpblRva2VuID8gdGhpcy5wYXJzZXIuZ2V0TmFtZSh0aGlzLnRva2Vucy5tYWluVG9rZW4udmFsdWUpIDogXCJub25lXCIpKSwgbmV3IFN5bnRheEVycm9yKFwiTm8gcGFyc2UgYXQgXCIgKyBuKTtcbiAgICAgIHRoaXMucmVjb3ZlcmluZyB8fCAodGhpcy5yZWNvdmVyaW5nID0gNSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnJlY292ZXJpbmcgJiYgaSkge1xuICAgICAgbGV0IG8gPSB0aGlzLnN0b3BwZWRBdCAhPSBudWxsICYmIGlbMF0ucG9zID4gdGhpcy5zdG9wcGVkQXQgPyBpWzBdIDogdGhpcy5ydW5SZWNvdmVyeShpLCBzLCByKTtcbiAgICAgIGlmIChvKVxuICAgICAgICByZXR1cm4gUW4gJiYgY29uc29sZS5sb2coXCJGb3JjZS1maW5pc2ggXCIgKyB0aGlzLnN0YWNrSUQobykpLCB0aGlzLnN0YWNrVG9UcmVlKG8uZm9yY2VBbGwoKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnJlY292ZXJpbmcpIHtcbiAgICAgIGxldCBvID0gdGhpcy5yZWNvdmVyaW5nID09IDEgPyAxIDogdGhpcy5yZWNvdmVyaW5nICogMztcbiAgICAgIGlmIChyLmxlbmd0aCA+IG8pXG4gICAgICAgIGZvciAoci5zb3J0KChhLCBsKSA9PiBsLnNjb3JlIC0gYS5zY29yZSk7IHIubGVuZ3RoID4gbzsgKVxuICAgICAgICAgIHIucG9wKCk7XG4gICAgICByLnNvbWUoKGEpID0+IGEucmVkdWNlUG9zID4gbikgJiYgdGhpcy5yZWNvdmVyaW5nLS07XG4gICAgfSBlbHNlIGlmIChyLmxlbmd0aCA+IDEpIHtcbiAgICAgIGU6XG4gICAgICAgIGZvciAobGV0IG8gPSAwOyBvIDwgci5sZW5ndGggLSAxOyBvKyspIHtcbiAgICAgICAgICBsZXQgYSA9IHJbb107XG4gICAgICAgICAgZm9yIChsZXQgbCA9IG8gKyAxOyBsIDwgci5sZW5ndGg7IGwrKykge1xuICAgICAgICAgICAgbGV0IGMgPSByW2xdO1xuICAgICAgICAgICAgaWYgKGEuc2FtZVN0YXRlKGMpIHx8IGEuYnVmZmVyLmxlbmd0aCA+IDUwMCAmJiBjLmJ1ZmZlci5sZW5ndGggPiA1MDApXG4gICAgICAgICAgICAgIGlmICgoYS5zY29yZSAtIGMuc2NvcmUgfHwgYS5idWZmZXIubGVuZ3RoIC0gYy5idWZmZXIubGVuZ3RoKSA+IDApXG4gICAgICAgICAgICAgICAgci5zcGxpY2UobC0tLCAxKTtcbiAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgci5zcGxpY2Uoby0tLCAxKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZSBlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICByLmxlbmd0aCA+IDEyICYmIHIuc3BsaWNlKFxuICAgICAgICAxMixcbiAgICAgICAgci5sZW5ndGggLSAxMlxuICAgICAgICAvKiBSZWMuTWF4U3RhY2tDb3VudCAqL1xuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5taW5TdGFja1BvcyA9IHJbMF0ucG9zO1xuICAgIGZvciAobGV0IG8gPSAxOyBvIDwgci5sZW5ndGg7IG8rKylcbiAgICAgIHJbb10ucG9zIDwgdGhpcy5taW5TdGFja1BvcyAmJiAodGhpcy5taW5TdGFja1BvcyA9IHJbb10ucG9zKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBzdG9wQXQoZSkge1xuICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsICYmIHRoaXMuc3RvcHBlZEF0IDwgZSlcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuJ3QgbW92ZSBzdG9wcGVkQXQgZm9yd2FyZFwiKTtcbiAgICB0aGlzLnN0b3BwZWRBdCA9IGU7XG4gIH1cbiAgLy8gUmV0dXJucyBhbiB1cGRhdGVkIHZlcnNpb24gb2YgdGhlIGdpdmVuIHN0YWNrLCBvciBudWxsIGlmIHRoZVxuICAvLyBzdGFjayBjYW4ndCBhZHZhbmNlIG5vcm1hbGx5LiBXaGVuIGBzcGxpdGAgYW5kIGBzdGFja3NgIGFyZVxuICAvLyBnaXZlbiwgc3RhY2tzIHNwbGl0IG9mZiBieSBhbWJpZ3VvdXMgb3BlcmF0aW9ucyB3aWxsIGJlIHB1c2hlZCB0b1xuICAvLyBgc3BsaXRgLCBvciBhZGRlZCB0byBgc3RhY2tzYCBpZiB0aGV5IG1vdmUgYHBvc2AgZm9yd2FyZC5cbiAgYWR2YW5jZVN0YWNrKGUsIG4sIHIpIHtcbiAgICBsZXQgaSA9IGUucG9zLCB7IHBhcnNlcjogcyB9ID0gdGhpcywgbyA9IFFuID8gdGhpcy5zdGFja0lEKGUpICsgXCIgLT4gXCIgOiBcIlwiO1xuICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsICYmIGkgPiB0aGlzLnN0b3BwZWRBdClcbiAgICAgIHJldHVybiBlLmZvcmNlUmVkdWNlKCkgPyBlIDogbnVsbDtcbiAgICBpZiAodGhpcy5mcmFnbWVudHMpIHtcbiAgICAgIGxldCBjID0gZS5jdXJDb250ZXh0ICYmIGUuY3VyQ29udGV4dC50cmFja2VyLnN0cmljdCwgdSA9IGMgPyBlLmN1ckNvbnRleHQuaGFzaCA6IDA7XG4gICAgICBmb3IgKGxldCBkID0gdGhpcy5mcmFnbWVudHMubm9kZUF0KGkpOyBkOyApIHtcbiAgICAgICAgbGV0IGYgPSB0aGlzLnBhcnNlci5ub2RlU2V0LnR5cGVzW2QudHlwZS5pZF0gPT0gZC50eXBlID8gcy5nZXRHb3RvKGUuc3RhdGUsIGQudHlwZS5pZCkgOiAtMTtcbiAgICAgICAgaWYgKGYgPiAtMSAmJiBkLmxlbmd0aCAmJiAoIWMgfHwgKGQucHJvcChSZS5jb250ZXh0SGFzaCkgfHwgMCkgPT0gdSkpXG4gICAgICAgICAgcmV0dXJuIGUudXNlTm9kZShkLCBmKSwgUW4gJiYgY29uc29sZS5sb2cobyArIHRoaXMuc3RhY2tJRChlKSArIGAgKHZpYSByZXVzZSBvZiAke3MuZ2V0TmFtZShkLnR5cGUuaWQpfSlgKSwgITA7XG4gICAgICAgIGlmICghKGQgaW5zdGFuY2VvZiBndCkgfHwgZC5jaGlsZHJlbi5sZW5ndGggPT0gMCB8fCBkLnBvc2l0aW9uc1swXSA+IDApXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGxldCBoID0gZC5jaGlsZHJlblswXTtcbiAgICAgICAgaWYgKGggaW5zdGFuY2VvZiBndCAmJiBkLnBvc2l0aW9uc1swXSA9PSAwKVxuICAgICAgICAgIGQgPSBoO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBhID0gcy5zdGF0ZVNsb3QoXG4gICAgICBlLnN0YXRlLFxuICAgICAgNFxuICAgICAgLyogUGFyc2VTdGF0ZS5EZWZhdWx0UmVkdWNlICovXG4gICAgKTtcbiAgICBpZiAoYSA+IDApXG4gICAgICByZXR1cm4gZS5yZWR1Y2UoYSksIFFuICYmIGNvbnNvbGUubG9nKG8gKyB0aGlzLnN0YWNrSUQoZSkgKyBgICh2aWEgYWx3YXlzLXJlZHVjZSAke3MuZ2V0TmFtZShcbiAgICAgICAgYSAmIDY1NTM1XG4gICAgICAgIC8qIEFjdGlvbi5WYWx1ZU1hc2sgKi9cbiAgICAgICl9KWApLCAhMDtcbiAgICBpZiAoZS5zdGFjay5sZW5ndGggPj0gODQwMClcbiAgICAgIGZvciAoOyBlLnN0YWNrLmxlbmd0aCA+IDZlMyAmJiBlLmZvcmNlUmVkdWNlKCk7IClcbiAgICAgICAgO1xuICAgIGxldCBsID0gdGhpcy50b2tlbnMuZ2V0QWN0aW9ucyhlKTtcbiAgICBmb3IgKGxldCBjID0gMDsgYyA8IGwubGVuZ3RoOyApIHtcbiAgICAgIGxldCB1ID0gbFtjKytdLCBkID0gbFtjKytdLCBmID0gbFtjKytdLCBoID0gYyA9PSBsLmxlbmd0aCB8fCAhciwgcCA9IGggPyBlIDogZS5zcGxpdCgpLCBPID0gdGhpcy50b2tlbnMubWFpblRva2VuO1xuICAgICAgaWYgKHAuYXBwbHkodSwgZCwgTyA/IE8uc3RhcnQgOiBwLnBvcywgZiksIFFuICYmIGNvbnNvbGUubG9nKG8gKyB0aGlzLnN0YWNrSUQocCkgKyBgICh2aWEgJHt1ICYgNjU1MzYgPyBgcmVkdWNlIG9mICR7cy5nZXROYW1lKFxuICAgICAgICB1ICYgNjU1MzVcbiAgICAgICAgLyogQWN0aW9uLlZhbHVlTWFzayAqL1xuICAgICAgKX1gIDogXCJzaGlmdFwifSBmb3IgJHtzLmdldE5hbWUoZCl9IEAgJHtpfSR7cCA9PSBlID8gXCJcIiA6IFwiLCBzcGxpdFwifSlgKSwgaClcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgcC5wb3MgPiBpID8gbi5wdXNoKHApIDogci5wdXNoKHApO1xuICAgIH1cbiAgICByZXR1cm4gITE7XG4gIH1cbiAgLy8gQWR2YW5jZSBhIGdpdmVuIHN0YWNrIGZvcndhcmQgYXMgZmFyIGFzIGl0IHdpbGwgZ28uIFJldHVybnMgdGhlXG4gIC8vIChwb3NzaWJseSB1cGRhdGVkKSBzdGFjayBpZiBpdCBnb3Qgc3R1Y2ssIG9yIG51bGwgaWYgaXQgbW92ZWRcbiAgLy8gZm9yd2FyZCBhbmQgd2FzIGdpdmVuIHRvIGBwdXNoU3RhY2tEZWR1cGAuXG4gIGFkdmFuY2VGdWxseShlLCBuKSB7XG4gICAgbGV0IHIgPSBlLnBvcztcbiAgICBmb3IgKDsgOyApIHtcbiAgICAgIGlmICghdGhpcy5hZHZhbmNlU3RhY2soZSwgbnVsbCwgbnVsbCkpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGlmIChlLnBvcyA+IHIpXG4gICAgICAgIHJldHVybiBvMChlLCBuKSwgITA7XG4gICAgfVxuICB9XG4gIHJ1blJlY292ZXJ5KGUsIG4sIHIpIHtcbiAgICBsZXQgaSA9IG51bGwsIHMgPSAhMTtcbiAgICBmb3IgKGxldCBvID0gMDsgbyA8IGUubGVuZ3RoOyBvKyspIHtcbiAgICAgIGxldCBhID0gZVtvXSwgbCA9IG5bbyA8PCAxXSwgYyA9IG5bKG8gPDwgMSkgKyAxXSwgdSA9IFFuID8gdGhpcy5zdGFja0lEKGEpICsgXCIgLT4gXCIgOiBcIlwiO1xuICAgICAgaWYgKGEuZGVhZEVuZCAmJiAocyB8fCAocyA9ICEwLCBhLnJlc3RhcnQoKSwgUW4gJiYgY29uc29sZS5sb2codSArIHRoaXMuc3RhY2tJRChhKSArIFwiIChyZXN0YXJ0ZWQpXCIpLCB0aGlzLmFkdmFuY2VGdWxseShhLCByKSkpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGxldCBkID0gYS5zcGxpdCgpLCBmID0gdTtcbiAgICAgIGZvciAobGV0IGggPSAwOyBkLmZvcmNlUmVkdWNlKCkgJiYgaCA8IDEwICYmIChRbiAmJiBjb25zb2xlLmxvZyhmICsgdGhpcy5zdGFja0lEKGQpICsgXCIgKHZpYSBmb3JjZS1yZWR1Y2UpXCIpLCAhdGhpcy5hZHZhbmNlRnVsbHkoZCwgcikpOyBoKyspXG4gICAgICAgIFFuICYmIChmID0gdGhpcy5zdGFja0lEKGQpICsgXCIgLT4gXCIpO1xuICAgICAgZm9yIChsZXQgaCBvZiBhLnJlY292ZXJCeUluc2VydChsKSlcbiAgICAgICAgUW4gJiYgY29uc29sZS5sb2codSArIHRoaXMuc3RhY2tJRChoKSArIFwiICh2aWEgcmVjb3Zlci1pbnNlcnQpXCIpLCB0aGlzLmFkdmFuY2VGdWxseShoLCByKTtcbiAgICAgIHRoaXMuc3RyZWFtLmVuZCA+IGEucG9zID8gKGMgPT0gYS5wb3MgJiYgKGMrKywgbCA9IDApLCBhLnJlY292ZXJCeURlbGV0ZShsLCBjKSwgUW4gJiYgY29uc29sZS5sb2codSArIHRoaXMuc3RhY2tJRChhKSArIGAgKHZpYSByZWNvdmVyLWRlbGV0ZSAke3RoaXMucGFyc2VyLmdldE5hbWUobCl9KWApLCBvMChhLCByKSkgOiAoIWkgfHwgaS5zY29yZSA8IGEuc2NvcmUpICYmIChpID0gYSk7XG4gICAgfVxuICAgIHJldHVybiBpO1xuICB9XG4gIC8vIENvbnZlcnQgdGhlIHN0YWNrJ3MgYnVmZmVyIHRvIGEgc3ludGF4IHRyZWUuXG4gIHN0YWNrVG9UcmVlKGUpIHtcbiAgICByZXR1cm4gZS5jbG9zZSgpLCBndC5idWlsZCh7XG4gICAgICBidWZmZXI6IHp1LmNyZWF0ZShlKSxcbiAgICAgIG5vZGVTZXQ6IHRoaXMucGFyc2VyLm5vZGVTZXQsXG4gICAgICB0b3BJRDogdGhpcy50b3BUZXJtLFxuICAgICAgbWF4QnVmZmVyTGVuZ3RoOiB0aGlzLnBhcnNlci5idWZmZXJMZW5ndGgsXG4gICAgICByZXVzZWQ6IHRoaXMucmV1c2VkLFxuICAgICAgc3RhcnQ6IHRoaXMucmFuZ2VzWzBdLmZyb20sXG4gICAgICBsZW5ndGg6IGUucG9zIC0gdGhpcy5yYW5nZXNbMF0uZnJvbSxcbiAgICAgIG1pblJlcGVhdFR5cGU6IHRoaXMucGFyc2VyLm1pblJlcGVhdFRlcm1cbiAgICB9KTtcbiAgfVxuICBzdGFja0lEKGUpIHtcbiAgICBsZXQgbiA9IChqZiB8fCAoamYgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSkpLmdldChlKTtcbiAgICByZXR1cm4gbiB8fCBqZi5zZXQoZSwgbiA9IFN0cmluZy5mcm9tQ29kZVBvaW50KHRoaXMubmV4dFN0YWNrSUQrKykpLCBuICsgZTtcbiAgfVxufVxuZnVuY3Rpb24gbzAodCwgZSkge1xuICBmb3IgKGxldCBuID0gMDsgbiA8IGUubGVuZ3RoOyBuKyspIHtcbiAgICBsZXQgciA9IGVbbl07XG4gICAgaWYgKHIucG9zID09IHQucG9zICYmIHIuc2FtZVN0YXRlKHQpKSB7XG4gICAgICBlW25dLnNjb3JlIDwgdC5zY29yZSAmJiAoZVtuXSA9IHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBlLnB1c2godCk7XG59XG5jbGFzcyBnViB7XG4gIGNvbnN0cnVjdG9yKGUsIG4sIHIpIHtcbiAgICB0aGlzLnNvdXJjZSA9IGUsIHRoaXMuZmxhZ3MgPSBuLCB0aGlzLmRpc2FibGVkID0gcjtcbiAgfVxuICBhbGxvd3MoZSkge1xuICAgIHJldHVybiAhdGhpcy5kaXNhYmxlZCB8fCB0aGlzLmRpc2FibGVkW2VdID09IDA7XG4gIH1cbn1cbmNvbnN0IEJmID0gKHQpID0+IHQ7XG5jbGFzcyB3ZyB7XG4gIC8qKlxuICBEZWZpbmUgYSBjb250ZXh0IHRyYWNrZXIuXG4gICovXG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLnN0YXJ0ID0gZS5zdGFydCwgdGhpcy5zaGlmdCA9IGUuc2hpZnQgfHwgQmYsIHRoaXMucmVkdWNlID0gZS5yZWR1Y2UgfHwgQmYsIHRoaXMucmV1c2UgPSBlLnJldXNlIHx8IEJmLCB0aGlzLmhhc2ggPSBlLmhhc2ggfHwgKCgpID0+IDApLCB0aGlzLnN0cmljdCA9IGUuc3RyaWN0ICE9PSAhMTtcbiAgfVxufVxuY2xhc3MgdXMgZXh0ZW5kcyB0eCB7XG4gIC8qKlxuICBAaW50ZXJuYWxcbiAgKi9cbiAgY29uc3RydWN0b3IoZSkge1xuICAgIGlmIChzdXBlcigpLCB0aGlzLndyYXBwZXJzID0gW10sIGUudmVyc2lvbiAhPSAxNClcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBQYXJzZXIgdmVyc2lvbiAoJHtlLnZlcnNpb259KSBkb2Vzbid0IG1hdGNoIHJ1bnRpbWUgdmVyc2lvbiAoMTQpYCk7XG4gICAgbGV0IG4gPSBlLm5vZGVOYW1lcy5zcGxpdChcIiBcIik7XG4gICAgdGhpcy5taW5SZXBlYXRUZXJtID0gbi5sZW5ndGg7XG4gICAgZm9yIChsZXQgYSA9IDA7IGEgPCBlLnJlcGVhdE5vZGVDb3VudDsgYSsrKVxuICAgICAgbi5wdXNoKFwiXCIpO1xuICAgIGxldCByID0gT2JqZWN0LmtleXMoZS50b3BSdWxlcykubWFwKChhKSA9PiBlLnRvcFJ1bGVzW2FdWzFdKSwgaSA9IFtdO1xuICAgIGZvciAobGV0IGEgPSAwOyBhIDwgbi5sZW5ndGg7IGErKylcbiAgICAgIGkucHVzaChbXSk7XG4gICAgZnVuY3Rpb24gcyhhLCBsLCBjKSB7XG4gICAgICBpW2FdLnB1c2goW2wsIGwuZGVzZXJpYWxpemUoU3RyaW5nKGMpKV0pO1xuICAgIH1cbiAgICBpZiAoZS5ub2RlUHJvcHMpXG4gICAgICBmb3IgKGxldCBhIG9mIGUubm9kZVByb3BzKSB7XG4gICAgICAgIGxldCBsID0gYVswXTtcbiAgICAgICAgdHlwZW9mIGwgPT0gXCJzdHJpbmdcIiAmJiAobCA9IFJlW2xdKTtcbiAgICAgICAgZm9yIChsZXQgYyA9IDE7IGMgPCBhLmxlbmd0aDsgKSB7XG4gICAgICAgICAgbGV0IHUgPSBhW2MrK107XG4gICAgICAgICAgaWYgKHUgPj0gMClcbiAgICAgICAgICAgIHModSwgbCwgYVtjKytdKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBkID0gYVtjICsgLXVdO1xuICAgICAgICAgICAgZm9yIChsZXQgZiA9IC11OyBmID4gMDsgZi0tKVxuICAgICAgICAgICAgICBzKGFbYysrXSwgbCwgZCk7XG4gICAgICAgICAgICBjKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgdGhpcy5ub2RlU2V0ID0gbmV3IGZnKG4ubWFwKChhLCBsKSA9PiBPbi5kZWZpbmUoe1xuICAgICAgbmFtZTogbCA+PSB0aGlzLm1pblJlcGVhdFRlcm0gPyB2b2lkIDAgOiBhLFxuICAgICAgaWQ6IGwsXG4gICAgICBwcm9wczogaVtsXSxcbiAgICAgIHRvcDogci5pbmRleE9mKGwpID4gLTEsXG4gICAgICBlcnJvcjogbCA9PSAwLFxuICAgICAgc2tpcHBlZDogZS5za2lwcGVkTm9kZXMgJiYgZS5za2lwcGVkTm9kZXMuaW5kZXhPZihsKSA+IC0xXG4gICAgfSkpKSwgZS5wcm9wU291cmNlcyAmJiAodGhpcy5ub2RlU2V0ID0gdGhpcy5ub2RlU2V0LmV4dGVuZCguLi5lLnByb3BTb3VyY2VzKSksIHRoaXMuc3RyaWN0ID0gITEsIHRoaXMuYnVmZmVyTGVuZ3RoID0gRms7XG4gICAgbGV0IG8gPSBWYShlLnRva2VuRGF0YSk7XG4gICAgdGhpcy5jb250ZXh0ID0gZS5jb250ZXh0LCB0aGlzLnNwZWNpYWxpemVyU3BlY3MgPSBlLnNwZWNpYWxpemVkIHx8IFtdLCB0aGlzLnNwZWNpYWxpemVkID0gbmV3IFVpbnQxNkFycmF5KHRoaXMuc3BlY2lhbGl6ZXJTcGVjcy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGEgPSAwOyBhIDwgdGhpcy5zcGVjaWFsaXplclNwZWNzLmxlbmd0aDsgYSsrKVxuICAgICAgdGhpcy5zcGVjaWFsaXplZFthXSA9IHRoaXMuc3BlY2lhbGl6ZXJTcGVjc1thXS50ZXJtO1xuICAgIHRoaXMuc3BlY2lhbGl6ZXJzID0gdGhpcy5zcGVjaWFsaXplclNwZWNzLm1hcChhMCksIHRoaXMuc3RhdGVzID0gVmEoZS5zdGF0ZXMsIFVpbnQzMkFycmF5KSwgdGhpcy5kYXRhID0gVmEoZS5zdGF0ZURhdGEpLCB0aGlzLmdvdG8gPSBWYShlLmdvdG8pLCB0aGlzLm1heFRlcm0gPSBlLm1heFRlcm0sIHRoaXMudG9rZW5pemVycyA9IGUudG9rZW5pemVycy5tYXAoKGEpID0+IHR5cGVvZiBhID09IFwibnVtYmVyXCIgPyBuZXcgQ28obywgYSkgOiBhKSwgdGhpcy50b3BSdWxlcyA9IGUudG9wUnVsZXMsIHRoaXMuZGlhbGVjdHMgPSBlLmRpYWxlY3RzIHx8IHt9LCB0aGlzLmR5bmFtaWNQcmVjZWRlbmNlcyA9IGUuZHluYW1pY1ByZWNlZGVuY2VzIHx8IG51bGwsIHRoaXMudG9rZW5QcmVjVGFibGUgPSBlLnRva2VuUHJlYywgdGhpcy50ZXJtTmFtZXMgPSBlLnRlcm1OYW1lcyB8fCBudWxsLCB0aGlzLm1heE5vZGUgPSB0aGlzLm5vZGVTZXQudHlwZXMubGVuZ3RoIC0gMSwgdGhpcy5kaWFsZWN0ID0gdGhpcy5wYXJzZURpYWxlY3QoKSwgdGhpcy50b3AgPSB0aGlzLnRvcFJ1bGVzW09iamVjdC5rZXlzKHRoaXMudG9wUnVsZXMpWzBdXTtcbiAgfVxuICBjcmVhdGVQYXJzZShlLCBuLCByKSB7XG4gICAgbGV0IGkgPSBuZXcgT1YodGhpcywgZSwgbiwgcik7XG4gICAgZm9yIChsZXQgcyBvZiB0aGlzLndyYXBwZXJzKVxuICAgICAgaSA9IHMoaSwgZSwgbiwgcik7XG4gICAgcmV0dXJuIGk7XG4gIH1cbiAgLyoqXG4gIEdldCBhIGdvdG8gdGFibGUgZW50cnkgQGludGVybmFsXG4gICovXG4gIGdldEdvdG8oZSwgbiwgciA9ICExKSB7XG4gICAgbGV0IGkgPSB0aGlzLmdvdG87XG4gICAgaWYgKG4gPj0gaVswXSlcbiAgICAgIHJldHVybiAtMTtcbiAgICBmb3IgKGxldCBzID0gaVtuICsgMV07IDsgKSB7XG4gICAgICBsZXQgbyA9IGlbcysrXSwgYSA9IG8gJiAxLCBsID0gaVtzKytdO1xuICAgICAgaWYgKGEgJiYgcilcbiAgICAgICAgcmV0dXJuIGw7XG4gICAgICBmb3IgKGxldCBjID0gcyArIChvID4+IDEpOyBzIDwgYzsgcysrKVxuICAgICAgICBpZiAoaVtzXSA9PSBlKVxuICAgICAgICAgIHJldHVybiBsO1xuICAgICAgaWYgKGEpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gIENoZWNrIGlmIHRoaXMgc3RhdGUgaGFzIGFuIGFjdGlvbiBmb3IgYSBnaXZlbiB0ZXJtaW5hbCBAaW50ZXJuYWxcbiAgKi9cbiAgaGFzQWN0aW9uKGUsIG4pIHtcbiAgICBsZXQgciA9IHRoaXMuZGF0YTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI7IGkrKylcbiAgICAgIGZvciAobGV0IHMgPSB0aGlzLnN0YXRlU2xvdChcbiAgICAgICAgZSxcbiAgICAgICAgaSA/IDIgOiAxXG4gICAgICAgIC8qIFBhcnNlU3RhdGUuQWN0aW9ucyAqL1xuICAgICAgKSwgbzsgOyBzICs9IDMpIHtcbiAgICAgICAgaWYgKChvID0gcltzXSkgPT0gNjU1MzUpXG4gICAgICAgICAgaWYgKHJbcyArIDFdID09IDEpXG4gICAgICAgICAgICBvID0gcltzID0gdGkociwgcyArIDIpXTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChyW3MgKyAxXSA9PSAyKVxuICAgICAgICAgICAgICByZXR1cm4gdGkociwgcyArIDIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBpZiAobyA9PSBuIHx8IG8gPT0gMClcbiAgICAgICAgICByZXR1cm4gdGkociwgcyArIDEpO1xuICAgICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIC8qKlxuICBAaW50ZXJuYWxcbiAgKi9cbiAgc3RhdGVTbG90KGUsIG4pIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZXNbZSAqIDYgKyBuXTtcbiAgfVxuICAvKipcbiAgQGludGVybmFsXG4gICovXG4gIHN0YXRlRmxhZyhlLCBuKSB7XG4gICAgcmV0dXJuICh0aGlzLnN0YXRlU2xvdChcbiAgICAgIGUsXG4gICAgICAwXG4gICAgICAvKiBQYXJzZVN0YXRlLkZsYWdzICovXG4gICAgKSAmIG4pID4gMDtcbiAgfVxuICAvKipcbiAgQGludGVybmFsXG4gICovXG4gIHZhbGlkQWN0aW9uKGUsIG4pIHtcbiAgICByZXR1cm4gISF0aGlzLmFsbEFjdGlvbnMoZSwgKHIpID0+IHIgPT0gbiA/ICEwIDogbnVsbCk7XG4gIH1cbiAgLyoqXG4gIEBpbnRlcm5hbFxuICAqL1xuICBhbGxBY3Rpb25zKGUsIG4pIHtcbiAgICBsZXQgciA9IHRoaXMuc3RhdGVTbG90KFxuICAgICAgZSxcbiAgICAgIDRcbiAgICAgIC8qIFBhcnNlU3RhdGUuRGVmYXVsdFJlZHVjZSAqL1xuICAgICksIGkgPSByID8gbihyKSA6IHZvaWQgMDtcbiAgICBmb3IgKGxldCBzID0gdGhpcy5zdGF0ZVNsb3QoXG4gICAgICBlLFxuICAgICAgMVxuICAgICAgLyogUGFyc2VTdGF0ZS5BY3Rpb25zICovXG4gICAgKTsgaSA9PSBudWxsOyBzICs9IDMpIHtcbiAgICAgIGlmICh0aGlzLmRhdGFbc10gPT0gNjU1MzUpXG4gICAgICAgIGlmICh0aGlzLmRhdGFbcyArIDFdID09IDEpXG4gICAgICAgICAgcyA9IHRpKHRoaXMuZGF0YSwgcyArIDIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgYnJlYWs7XG4gICAgICBpID0gbih0aSh0aGlzLmRhdGEsIHMgKyAxKSk7XG4gICAgfVxuICAgIHJldHVybiBpO1xuICB9XG4gIC8qKlxuICBHZXQgdGhlIHN0YXRlcyB0aGF0IGNhbiBmb2xsb3cgdGhpcyBvbmUgdGhyb3VnaCBzaGlmdCBhY3Rpb25zIG9yXG4gIGdvdG8ganVtcHMuIEBpbnRlcm5hbFxuICAqL1xuICBuZXh0U3RhdGVzKGUpIHtcbiAgICBsZXQgbiA9IFtdO1xuICAgIGZvciAobGV0IHIgPSB0aGlzLnN0YXRlU2xvdChcbiAgICAgIGUsXG4gICAgICAxXG4gICAgICAvKiBQYXJzZVN0YXRlLkFjdGlvbnMgKi9cbiAgICApOyA7IHIgKz0gMykge1xuICAgICAgaWYgKHRoaXMuZGF0YVtyXSA9PSA2NTUzNSlcbiAgICAgICAgaWYgKHRoaXMuZGF0YVtyICsgMV0gPT0gMSlcbiAgICAgICAgICByID0gdGkodGhpcy5kYXRhLCByICsgMik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBicmVhaztcbiAgICAgIGlmICghKHRoaXMuZGF0YVtyICsgMl0gJiAxKSkge1xuICAgICAgICBsZXQgaSA9IHRoaXMuZGF0YVtyICsgMV07XG4gICAgICAgIG4uc29tZSgocywgbykgPT4gbyAmIDEgJiYgcyA9PSBpKSB8fCBuLnB1c2godGhpcy5kYXRhW3JdLCBpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH1cbiAgLyoqXG4gIENvbmZpZ3VyZSB0aGUgcGFyc2VyLiBSZXR1cm5zIGEgbmV3IHBhcnNlciBpbnN0YW5jZSB0aGF0IGhhcyB0aGVcbiAgZ2l2ZW4gc2V0dGluZ3MgbW9kaWZpZWQuIFNldHRpbmdzIG5vdCBwcm92aWRlZCBpbiBgY29uZmlnYCBhcmVcbiAga2VwdCBmcm9tIHRoZSBvcmlnaW5hbCBwYXJzZXIuXG4gICovXG4gIGNvbmZpZ3VyZShlKSB7XG4gICAgbGV0IG4gPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUodXMucHJvdG90eXBlKSwgdGhpcyk7XG4gICAgaWYgKGUucHJvcHMgJiYgKG4ubm9kZVNldCA9IHRoaXMubm9kZVNldC5leHRlbmQoLi4uZS5wcm9wcykpLCBlLnRvcCkge1xuICAgICAgbGV0IHIgPSB0aGlzLnRvcFJ1bGVzW2UudG9wXTtcbiAgICAgIGlmICghcilcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgdG9wIHJ1bGUgbmFtZSAke2UudG9wfWApO1xuICAgICAgbi50b3AgPSByO1xuICAgIH1cbiAgICByZXR1cm4gZS50b2tlbml6ZXJzICYmIChuLnRva2VuaXplcnMgPSB0aGlzLnRva2VuaXplcnMubWFwKChyKSA9PiB7XG4gICAgICBsZXQgaSA9IGUudG9rZW5pemVycy5maW5kKChzKSA9PiBzLmZyb20gPT0gcik7XG4gICAgICByZXR1cm4gaSA/IGkudG8gOiByO1xuICAgIH0pKSwgZS5zcGVjaWFsaXplcnMgJiYgKG4uc3BlY2lhbGl6ZXJzID0gdGhpcy5zcGVjaWFsaXplcnMuc2xpY2UoKSwgbi5zcGVjaWFsaXplclNwZWNzID0gdGhpcy5zcGVjaWFsaXplclNwZWNzLm1hcCgociwgaSkgPT4ge1xuICAgICAgbGV0IHMgPSBlLnNwZWNpYWxpemVycy5maW5kKChhKSA9PiBhLmZyb20gPT0gci5leHRlcm5hbCk7XG4gICAgICBpZiAoIXMpXG4gICAgICAgIHJldHVybiByO1xuICAgICAgbGV0IG8gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHIpLCB7IGV4dGVybmFsOiBzLnRvIH0pO1xuICAgICAgcmV0dXJuIG4uc3BlY2lhbGl6ZXJzW2ldID0gYTAobyksIG87XG4gICAgfSkpLCBlLmNvbnRleHRUcmFja2VyICYmIChuLmNvbnRleHQgPSBlLmNvbnRleHRUcmFja2VyKSwgZS5kaWFsZWN0ICYmIChuLmRpYWxlY3QgPSB0aGlzLnBhcnNlRGlhbGVjdChlLmRpYWxlY3QpKSwgZS5zdHJpY3QgIT0gbnVsbCAmJiAobi5zdHJpY3QgPSBlLnN0cmljdCksIGUud3JhcCAmJiAobi53cmFwcGVycyA9IG4ud3JhcHBlcnMuY29uY2F0KGUud3JhcCkpLCBlLmJ1ZmZlckxlbmd0aCAhPSBudWxsICYmIChuLmJ1ZmZlckxlbmd0aCA9IGUuYnVmZmVyTGVuZ3RoKSwgbjtcbiAgfVxuICAvKipcbiAgVGVsbHMgeW91IHdoZXRoZXIgYW55IFtwYXJzZSB3cmFwcGVyc10oI2xyLlBhcnNlckNvbmZpZy53cmFwKVxuICBhcmUgcmVnaXN0ZXJlZCBmb3IgdGhpcyBwYXJzZXIuXG4gICovXG4gIGhhc1dyYXBwZXJzKCkge1xuICAgIHJldHVybiB0aGlzLndyYXBwZXJzLmxlbmd0aCA+IDA7XG4gIH1cbiAgLyoqXG4gIFJldHVybnMgdGhlIG5hbWUgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gdGVybS4gVGhpcyB3aWxsIG9ubHlcbiAgd29yayBmb3IgYWxsIHRlcm1zIHdoZW4gdGhlIHBhcnNlciB3YXMgZ2VuZXJhdGVkIHdpdGggdGhlXG4gIGAtLW5hbWVzYCBvcHRpb24uIEJ5IGRlZmF1bHQsIG9ubHkgdGhlIG5hbWVzIG9mIHRhZ2dlZCB0ZXJtcyBhcmVcbiAgc3RvcmVkLlxuICAqL1xuICBnZXROYW1lKGUpIHtcbiAgICByZXR1cm4gdGhpcy50ZXJtTmFtZXMgPyB0aGlzLnRlcm1OYW1lc1tlXSA6IFN0cmluZyhlIDw9IHRoaXMubWF4Tm9kZSAmJiB0aGlzLm5vZGVTZXQudHlwZXNbZV0ubmFtZSB8fCBlKTtcbiAgfVxuICAvKipcbiAgVGhlIGVvZiB0ZXJtIGlkIGlzIGFsd2F5cyBhbGxvY2F0ZWQgZGlyZWN0bHkgYWZ0ZXIgdGhlIG5vZGVcbiAgdHlwZXMuIEBpbnRlcm5hbFxuICAqL1xuICBnZXQgZW9mVGVybSgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXhOb2RlICsgMTtcbiAgfVxuICAvKipcbiAgVGhlIHR5cGUgb2YgdG9wIG5vZGUgcHJvZHVjZWQgYnkgdGhlIHBhcnNlci5cbiAgKi9cbiAgZ2V0IHRvcE5vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZVNldC50eXBlc1t0aGlzLnRvcFsxXV07XG4gIH1cbiAgLyoqXG4gIEBpbnRlcm5hbFxuICAqL1xuICBkeW5hbWljUHJlY2VkZW5jZShlKSB7XG4gICAgbGV0IG4gPSB0aGlzLmR5bmFtaWNQcmVjZWRlbmNlcztcbiAgICByZXR1cm4gbiA9PSBudWxsID8gMCA6IG5bZV0gfHwgMDtcbiAgfVxuICAvKipcbiAgQGludGVybmFsXG4gICovXG4gIHBhcnNlRGlhbGVjdChlKSB7XG4gICAgbGV0IG4gPSBPYmplY3Qua2V5cyh0aGlzLmRpYWxlY3RzKSwgciA9IG4ubWFwKCgpID0+ICExKTtcbiAgICBpZiAoZSlcbiAgICAgIGZvciAobGV0IHMgb2YgZS5zcGxpdChcIiBcIikpIHtcbiAgICAgICAgbGV0IG8gPSBuLmluZGV4T2Yocyk7XG4gICAgICAgIG8gPj0gMCAmJiAocltvXSA9ICEwKTtcbiAgICAgIH1cbiAgICBsZXQgaSA9IG51bGw7XG4gICAgZm9yIChsZXQgcyA9IDA7IHMgPCBuLmxlbmd0aDsgcysrKVxuICAgICAgaWYgKCFyW3NdKVxuICAgICAgICBmb3IgKGxldCBvID0gdGhpcy5kaWFsZWN0c1tuW3NdXSwgYTsgKGEgPSB0aGlzLmRhdGFbbysrXSkgIT0gNjU1MzU7IClcbiAgICAgICAgICAoaSB8fCAoaSA9IG5ldyBVaW50OEFycmF5KHRoaXMubWF4VGVybSArIDEpKSlbYV0gPSAxO1xuICAgIHJldHVybiBuZXcgZ1YoZSwgciwgaSk7XG4gIH1cbiAgLyoqXG4gIFVzZWQgYnkgdGhlIG91dHB1dCBvZiB0aGUgcGFyc2VyIGdlbmVyYXRvci4gTm90IGF2YWlsYWJsZSB0b1xuICB1c2VyIGNvZGUuIEBoaWRlXG4gICovXG4gIHN0YXRpYyBkZXNlcmlhbGl6ZShlKSB7XG4gICAgcmV0dXJuIG5ldyB1cyhlKTtcbiAgfVxufVxuZnVuY3Rpb24gdGkodCwgZSkge1xuICByZXR1cm4gdFtlXSB8IHRbZSArIDFdIDw8IDE2O1xufVxuZnVuY3Rpb24gbVYodCkge1xuICBsZXQgZSA9IG51bGw7XG4gIGZvciAobGV0IG4gb2YgdCkge1xuICAgIGxldCByID0gbi5wLnN0b3BwZWRBdDtcbiAgICAobi5wb3MgPT0gbi5wLnN0cmVhbS5lbmQgfHwgciAhPSBudWxsICYmIG4ucG9zID4gcikgJiYgbi5wLnBhcnNlci5zdGF0ZUZsYWcoXG4gICAgICBuLnN0YXRlLFxuICAgICAgMlxuICAgICAgLyogU3RhdGVGbGFnLkFjY2VwdGluZyAqL1xuICAgICkgJiYgKCFlIHx8IGUuc2NvcmUgPCBuLnNjb3JlKSAmJiAoZSA9IG4pO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gYTAodCkge1xuICBpZiAodC5leHRlcm5hbCkge1xuICAgIGxldCBlID0gdC5leHRlbmQgPyAxIDogMDtcbiAgICByZXR1cm4gKG4sIHIpID0+IHQuZXh0ZXJuYWwobiwgcikgPDwgMSB8IGU7XG4gIH1cbiAgcmV0dXJuIHQuZ2V0O1xufVxuY29uc3QgYlYgPSA5OSwgbDAgPSAxLCB2ViA9IDEwMCwgeVYgPSAxMDEsIGMwID0gMiwgTnggPSBbXG4gIDksXG4gIDEwLFxuICAxMSxcbiAgMTIsXG4gIDEzLFxuICAzMixcbiAgMTMzLFxuICAxNjAsXG4gIDU3NjAsXG4gIDgxOTIsXG4gIDgxOTMsXG4gIDgxOTQsXG4gIDgxOTUsXG4gIDgxOTYsXG4gIDgxOTcsXG4gIDgxOTgsXG4gIDgxOTksXG4gIDgyMDAsXG4gIDgyMDEsXG4gIDgyMDIsXG4gIDgyMzIsXG4gIDgyMzMsXG4gIDgyMzksXG4gIDgyODcsXG4gIDEyMjg4XG5dLCBTViA9IDU4LCB3ViA9IDQwLCBEeCA9IDk1LCBrViA9IDkxLCB1dSA9IDQ1LCB4ViA9IDQ2LCBQViA9IDM1LCBfViA9IDM3LCBUViA9IDM4LCBFViA9IDkyLCAkViA9IDEwO1xuZnVuY3Rpb24geGwodCkge1xuICByZXR1cm4gdCA+PSA2NSAmJiB0IDw9IDkwIHx8IHQgPj0gOTcgJiYgdCA8PSAxMjIgfHwgdCA+PSAxNjE7XG59XG5mdW5jdGlvbiBaeCh0KSB7XG4gIHJldHVybiB0ID49IDQ4ICYmIHQgPD0gNTc7XG59XG5jb25zdCBRViA9IG5ldyBnbigodCwgZSkgPT4ge1xuICBmb3IgKGxldCBuID0gITEsIHIgPSAwLCBpID0gMDsgOyBpKyspIHtcbiAgICBsZXQgeyBuZXh0OiBzIH0gPSB0O1xuICAgIGlmICh4bChzKSB8fCBzID09IHV1IHx8IHMgPT0gRHggfHwgbiAmJiBaeChzKSlcbiAgICAgICFuICYmIChzICE9IHV1IHx8IGkgPiAwKSAmJiAobiA9ICEwKSwgciA9PT0gaSAmJiBzID09IHV1ICYmIHIrKywgdC5hZHZhbmNlKCk7XG4gICAgZWxzZSBpZiAocyA9PSBFViAmJiB0LnBlZWsoMSkgIT0gJFYpXG4gICAgICB0LmFkdmFuY2UoKSwgdC5uZXh0ID4gLTEgJiYgdC5hZHZhbmNlKCksIG4gPSAhMDtcbiAgICBlbHNlIHtcbiAgICAgIG4gJiYgdC5hY2NlcHRUb2tlbihzID09IHdWID8gdlYgOiByID09IDIgJiYgZS5jYW5TaGlmdChjMCkgPyBjMCA6IHlWKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufSksIENWID0gbmV3IGduKCh0KSA9PiB7XG4gIGlmIChOeC5pbmNsdWRlcyh0LnBlZWsoLTEpKSkge1xuICAgIGxldCB7IG5leHQ6IGUgfSA9IHQ7XG4gICAgKHhsKGUpIHx8IGUgPT0gRHggfHwgZSA9PSBQViB8fCBlID09IHhWIHx8IGUgPT0ga1YgfHwgZSA9PSBTViAmJiB4bCh0LnBlZWsoMSkpIHx8IGUgPT0gdXUgfHwgZSA9PSBUVikgJiYgdC5hY2NlcHRUb2tlbihiVik7XG4gIH1cbn0pLCBBViA9IG5ldyBnbigodCkgPT4ge1xuICBpZiAoIU54LmluY2x1ZGVzKHQucGVlaygtMSkpKSB7XG4gICAgbGV0IHsgbmV4dDogZSB9ID0gdDtcbiAgICBpZiAoZSA9PSBfViAmJiAodC5hZHZhbmNlKCksIHQuYWNjZXB0VG9rZW4obDApKSwgeGwoZSkpIHtcbiAgICAgIGRvXG4gICAgICAgIHQuYWR2YW5jZSgpO1xuICAgICAgd2hpbGUgKHhsKHQubmV4dCkgfHwgWngodC5uZXh0KSk7XG4gICAgICB0LmFjY2VwdFRva2VuKGwwKTtcbiAgICB9XG4gIH1cbn0pLCBSViA9IGlhKHtcbiAgXCJBdEtleXdvcmQgaW1wb3J0IGNoYXJzZXQgbmFtZXNwYWNlIGtleWZyYW1lcyBtZWRpYSBzdXBwb3J0c1wiOiBQLmRlZmluaXRpb25LZXl3b3JkLFxuICBcImZyb20gdG8gc2VsZWN0b3JcIjogUC5rZXl3b3JkLFxuICBOYW1lc3BhY2VOYW1lOiBQLm5hbWVzcGFjZSxcbiAgS2V5ZnJhbWVOYW1lOiBQLmxhYmVsTmFtZSxcbiAgS2V5ZnJhbWVSYW5nZU5hbWU6IFAub3BlcmF0b3JLZXl3b3JkLFxuICBUYWdOYW1lOiBQLnRhZ05hbWUsXG4gIENsYXNzTmFtZTogUC5jbGFzc05hbWUsXG4gIFBzZXVkb0NsYXNzTmFtZTogUC5jb25zdGFudChQLmNsYXNzTmFtZSksXG4gIElkTmFtZTogUC5sYWJlbE5hbWUsXG4gIFwiRmVhdHVyZU5hbWUgUHJvcGVydHlOYW1lXCI6IFAucHJvcGVydHlOYW1lLFxuICBBdHRyaWJ1dGVOYW1lOiBQLmF0dHJpYnV0ZU5hbWUsXG4gIE51bWJlckxpdGVyYWw6IFAubnVtYmVyLFxuICBLZXl3b3JkUXVlcnk6IFAua2V5d29yZCxcbiAgVW5hcnlRdWVyeU9wOiBQLm9wZXJhdG9yS2V5d29yZCxcbiAgXCJDYWxsVGFnIFZhbHVlTmFtZVwiOiBQLmF0b20sXG4gIFZhcmlhYmxlTmFtZTogUC52YXJpYWJsZU5hbWUsXG4gIENhbGxlZTogUC5vcGVyYXRvcktleXdvcmQsXG4gIFVuaXQ6IFAudW5pdCxcbiAgXCJVbml2ZXJzYWxTZWxlY3RvciBOZXN0aW5nU2VsZWN0b3JcIjogUC5kZWZpbml0aW9uT3BlcmF0b3IsXG4gIE1hdGNoT3A6IFAuY29tcGFyZU9wZXJhdG9yLFxuICBcIkNoaWxkT3AgU2libGluZ09wLCBMb2dpY09wXCI6IFAubG9naWNPcGVyYXRvcixcbiAgQmluT3A6IFAuYXJpdGhtZXRpY09wZXJhdG9yLFxuICBJbXBvcnRhbnQ6IFAubW9kaWZpZXIsXG4gIENvbW1lbnQ6IFAuYmxvY2tDb21tZW50LFxuICBDb2xvckxpdGVyYWw6IFAuY29sb3IsXG4gIFwiUGFyZW50aGVzaXplZENvbnRlbnQgU3RyaW5nTGl0ZXJhbFwiOiBQLnN0cmluZyxcbiAgXCI6XCI6IFAucHVuY3R1YXRpb24sXG4gIFwiUHNldWRvT3AgI1wiOiBQLmRlcmVmT3BlcmF0b3IsXG4gIFwiOyAsXCI6IFAuc2VwYXJhdG9yLFxuICBcIiggKVwiOiBQLnBhcmVuLFxuICBcIlsgXVwiOiBQLnNxdWFyZUJyYWNrZXQsXG4gIFwieyB9XCI6IFAuYnJhY2Vcbn0pLCBOViA9IHsgX19wcm90b19fOiBudWxsLCBsYW5nOiAzMiwgXCJudGgtY2hpbGRcIjogMzIsIFwibnRoLWxhc3QtY2hpbGRcIjogMzIsIFwibnRoLW9mLXR5cGVcIjogMzIsIFwibnRoLWxhc3Qtb2YtdHlwZVwiOiAzMiwgZGlyOiAzMiwgXCJob3N0LWNvbnRleHRcIjogMzIsIHVybDogNjAsIFwidXJsLXByZWZpeFwiOiA2MCwgZG9tYWluOiA2MCwgcmVnZXhwOiA2MCwgc2VsZWN0b3I6IDEzOCB9LCBEViA9IHsgX19wcm90b19fOiBudWxsLCBcIkBpbXBvcnRcIjogMTE4LCBcIkBtZWRpYVwiOiAxNDIsIFwiQGNoYXJzZXRcIjogMTQ2LCBcIkBuYW1lc3BhY2VcIjogMTUwLCBcIkBrZXlmcmFtZXNcIjogMTU2LCBcIkBzdXBwb3J0c1wiOiAxNjggfSwgWlYgPSB7IF9fcHJvdG9fXzogbnVsbCwgbm90OiAxMzIsIG9ubHk6IDEzMiB9LCBWViA9IHVzLmRlc2VyaWFsaXplKHtcbiAgdmVyc2lvbjogMTQsXG4gIHN0YXRlczogXCI6XlFZUVtPT08jX1FbT09QI2ZPV09PT09RUCcjQ2QnI0NkT09RUCcjQ2MnI0NjTyNrUVtPJyNDZk8kX1FYTycjQ2FPJGZRW08nI0NoTyRxUVtPJyNEVE8kdlFbTycjRFdPT1FQJyNFbScjRW1PJHtRZE8nI0RnTyVqUVtPJyNEdE8ke1FkTycjRHZPJXtRW08nI0R4TyZXUVtPJyNEe08mYFFbTycjRVJPJm5RW08nI0VUT09RUycjRWwnI0VsT09RUycjRVcnI0VXUVlRW09PTyZ1UVhPJyNDZE8nalFXTycjRGNPJ29RV08nI0VzTyd6UVtPJyNFc1FPUVdPT1AoVU8jdE8nI0NfUE9PTylDQFspQ0BbT09RUCcjQ2cnI0NnT09RUCw1OVEsNTlRTyNrUVtPLDU5UU8oYVFbTycjRVtPKHtRV08sNTh7TylUUVtPLDU5U08kcVFbTyw1OW9PJHZRW08sNTlyTyhhUVtPLDU5dU8oYVFbTyw1OXdPKGFRW08sNTl4TylgUVtPJyNEYk9PUVMsNTh7LDU4e09PUVAnI0NrJyNDa09PUU8nI0RSJyNEUk9PUVAsNTlTLDU5U08pZ1FXTyw1OVNPKWxRV08sNTlTT09RUCcjRFYnI0RWT09RUCw1OW8sNTlvT09RTycjRFgnI0RYTylxUWBPLDU5ck9PUVMnI0NwJyNDcE8ke1FkTycjQ3FPKXlRdk8nI0NzTytaUXRPLDU6Uk9PUU8nI0N4JyNDeE8pbFFXTycjQ3dPK29RV08nI0N5Tyt0UVtPJyNET09PUVMnI0VwJyNFcE9PUU8nI0RqJyNEak8rfFFbTycjRHFPLFtRV08nI0V0TyZgUVtPJyNEb08salFXTycjRHJPT1FPJyNFdScjRXVPKU9RV08sNTpgTyxvUXBPLDU6Yk9PUVMnI0R6JyNEek8sd1FXTyw1OmRPLHxRW08sNTpkT09RTycjRH0nI0R9Ty1VUVdPLDU6Z08tWlFXTyw1Om1PLWNRV08sNTpvT09RUy1FOFUtRThVTyR7UWRPLDU5fU8ta1FbTycjRV5PLXhRV08sNTtfTy14UVdPLDU7X1BPT08nI0VWJyNFVlAuVE8jdE8sNTh5UE9PTyw1OHksNTh5T09RUDFHLmwxRy5sTy56UVhPLDU6dk9PUU8tRThZLUU4WU9PUVMxRy5nMUcuZ09PUVAxRy5uMUcubk8pZ1FXTzFHLm5PKWxRV08xRy5uT09RUDFHL1oxRy9aTy9YUWBPMUcvXk8vclFYTzFHL2FPMFlRWE8xRy9jTzBwUVhPMUcvZE8xV1FXTyw1OXxPMV1RW08nI0RTTzFkUWRPJyNDb09PUVAxRy9eMUcvXk8ke1FkTzFHL15PMWtRcE8sNTldT09RUyw1OV8sNTlfTyR7UWRPLDU5YU8xc1FXTzFHL21PT1FTLDU5Yyw1OWNPMXhRIWJPLDU5ZU9PUVMnI0RQJyNEUE9PUVMnI0VZJyNFWU8yUVFbTyw1OWpPT1FTLDU5aiw1OWpPMllRV08nI0RqTzJlUVdPLDU6Vk8yalFXTyw1Ol1PJmBRW08sNTpYTyZgUVtPJyNFX08yclFXTyw1O2BPMn1RV08sNTpaTyhhUVtPLDU6Xk9PUVMxRy96MUcvek9PUVMxRy98MUcvfE9PUVMxRzBPMUcwT08zYFFXTzFHME9PM2VRZE8nI0VPT09RUzFHMFIxRzBST09RUzFHMFgxRzBYT09RUzFHMFoxRzBaTzNwUXRPMUcvaU9PUU8sNTp4LDU6eE80V1FbTyw1OnhPT1FPLUU4Wy1FOFtPNGVRV08xRzB5UE9PTy1FOFQtRThUUE9PTzFHLmUxRy5lT09RUDcrJFk3KyRZT09RUDcrJHg3KyR4TyR7UWRPNyskeE9PUVMxRy9oMUcvaE80cFFYTycjRXJPNHdRV08sNTluTzR8UXRPJyNFWE81dFFkTycjRW9PNk9RV08sNTlaTzZUUXBPNyskeE9PUVMxRy53MUcud09PUVMxRy57MUcue09PUVM3KyVYNyslWE82XVFXTzFHL1BPT1FTLUU4Vy1FOFdPT1FTMUcvVTFHL1VPJHtRZE8xRy9xT09RTzFHL3cxRy93T09RTzFHL3MxRy9zTzZiUVdPLDU6eU9PUU8tRThdLUU4XU82cFFYTzFHL3hPT1FTNyslajcrJWpPNndRWU8nI0NzT09RTycjRVEnI0VRTzdTUWBPJyNFUE9PUU8nI0VQJyNFUE83X1FXTycjRWBPN2dRZE8sNTpqT09RUyw1OmosNTpqTzdyUXRPJyNFXU8ke1FkTycjRV1POHNRZE83KyVUT09RTzcrJVQ3KyVUT09RTzFHMGQxRzBkTzlXUXBPPDxIZE85YFFXTyw1O15PT1FQMUcvWTFHL1lPT1FTLUU4Vi1FOFZPJHtRZE8nI0VaTzloUVdPLDU7Wk9PUVQxRy51MUcudU9PUVA8PEhkPDxIZE9PUVM3KyRrNyska085cFFkTzcrJV1PT1FPNyslZDcrJWRPT1FPLDU6ayw1OmtPM2hRZE8nI0VhTzdfUVdPLDU6ek9PUVMsNTp6LDU6ek9PUVMtRTheLUU4Xk9PUVMxRzBVMUcwVU85d1F0Tyw1OndPT1FTLUU4Wi1FOFpPT1FPPDxIbzw8SG9PT1FQQU4+T0FOPk9POnhRZE8sNTp1T09RTy1FOFgtRThYT09RTzw8SHc8PEh3T09RTyw1OnssNTp7T09RTy1FOF8tRThfT09RUzFHMGYxRzBmXCIsXG4gIHN0YXRlRGF0YTogXCI7W35PI1pPUyNbUVF+T1VZT1hZT11WT15WT3FYT3hXTyFbYU8hXVpPIWlbTyFrXU8hbV5PIXBfTyF2YE8jWFJPI2JUT35PUWZPVVlPWFlPXVZPXlZPcVhPeFdPIVthTyFdWk8haVtPIWtdTyFtXk8hcF9PIXZgTyNYZU8jYlRPfk8jVSNnUH5QIVpPI1tqT35PI1hsT35PXXFPXnFPcXNPdG9PeHJPIU90TyFSdk8jVnVPI2JuT35PIVR3T35QI3BPYH1PI1d6TyNYeU9+TyNYIU9Pfk8jWCFRT35PUSFbT2IhVE9mIVtPaCFbT24hWU9xIVpPI1chV08jWCFTTyNlIVVPfk9iIV5PIWQhYE8hZyFhTyNYIV1PIVQjaFB+T2ghZk9uIVlPI1ghZU9+T2ghaE8jWCFoT35PYiFeTyFkIWBPIWchYU8jWCFdT35PIVkjaFB+UCVqT11XWF0hV1heV1hxV1h0V1h4V1ghT1dYIVJXWCFUV1gjVldYI2JXWH5PXSFtT35PIVkhbk8jVSNnWCFTI2dYfk8jVSNnWCFTI2dYflAhWk8jXSFxTyNeIXFPI18hc09+T1VZT1hZT11WT15WT3FYT3hXTyNYUk8jYlRPfk90b08hVHdPfk9gIXpPI1d6TyNYeU9+TyFTI2dQflAhWk9iI1JPfk9iI1NPfk9wI1RPfCNVT35PUCNXT2JnWGpnWCFZZ1ghZGdYIWdnWCNYZ1hhZ1hRZ1hmZ1hoZ1huZ1hxZ1h0Z1ghWGdYI1VnWCNXZ1gjZWdYcGdYIVNnWH5PYiFeT2ojWE8hZCFgTyFnIWFPI1ghXU8hWSNoUH5PYiNbT35PcCNgTyNYI11Pfk9iIV5PIWQhYE8hZyFhTyNYI2FPfk90I2VPIWIjZE8hVCNoWCFZI2hYfk9iI2hPfk9qI1hPIVkjak9+TyFZI2tPfk9oI2xPbiFZT35PIVQjbU9+TyFUd08hYiNkT35PIVR3TyFZI3BPfk8hWSNRWCNVI1FYIVMjUVh+UCFaTyFZIW5PI1UjZ2EhUyNnYX5PI10hcU8jXiFxTyNfI3dPfk9dcU9ecU9xc094ck8hT3RPIVJ2TyNWdU8jYm5Pfk90I09hIVQjT2FhI09hflAuYE9wI3lPfCN6T35PXXFPXnFPcXNPeHJPI2JuT35PdH1pIU99aSFSfWkhVH1pI1Z9aWF9aX5QL2FPdCFQaSFPIVBpIVIhUGkhVCFQaSNWIVBpYSFQaX5QL2FPdCFRaSFPIVFpIVIhUWkhVCFRaSNWIVFpYSFRaX5QL2FPIVMje09+T2EjZlB+UChhT2EjY1B+UCR7T2EkU09qI1hPfk8hWSRVT35PaCRWT28kVk9+T3AkWE8jWCNdT35PXSFgWGEhXlghYiFeWH5PXSRZT35PYSRaTyFiI2RPfk90I2VPIVQjaGEhWSNoYX5PIWIjZE90IWNhIVQhY2EhWSFjYWEhY2F+TyFZJGBPfk8hUyRnTyNYJGJPI2UkYU9+T2ojWE90JGlPIVgka08hWSFWaSNVIVZpIVMhVml+UCR7TyFZI1FhI1UjUWEhUyNRYX5QIVpPIVkhbk8jVSNnaSFTI2dpfk9hI2ZYflAjcE9hJG9Pfk9qI1hPUSF7WGEhe1hiIXtYZiF7WGghe1huIXtYcSF7WHQhe1gjVyF7WCNYIXtYI2Uhe1h+T3QkcU9hI2NYflAke09hJHNPfk9qI1hPcCR0T35PYSR1T35PIWIjZE90I1JhIVQjUmEhWSNSYX5PYSR3T35QLmBPUCNXT3RnWCFUZ1h+TyNlJGFPdCFzWCFUIXNYfk90JHlPIVR3T35PIVMkfU8jWCRiTyNlJGFPfk9qI1hPUSNQWGIjUFhmI1BYaCNQWG4jUFhxI1BYdCNQWCFYI1BYIVkjUFgjVSNQWCNXI1BYI1gjUFgjZSNQWCFTI1BYfk90JGlPIVglUU8hWSFWcSNVIVZxIVMhVnF+UCR7T2ojWE9wJVJPfk90b09hI2Zhfk90JHFPYSNjYX5PYSVVT35QJHtPaiNYT1EjUGFiI1BhZiNQYWgjUGFuI1BhcSNQYXQjUGEhWCNQYSFZI1BhI1UjUGEjVyNQYSNYI1BhI2UjUGEhUyNQYX5PYSF9YXQhfWF+UCR7TyNabyNbI2VqIVIjZX5cIixcbiAgZ290bzogXCItZyNqUFBQI2tQI25QI3ckV1AjdyRnI3dQUCRtUFBQJHMkfCR8UCVgUCR8UCR8JXomXlBQUFAkfCZ2UCZ6J1Ejd1AnVyN3J15QI3dQI3cjd1BQUCdkJ3koV1BQI25QUChfKF8oaShfUChfUChfKF9QI25QI25QI25QKGwjblAobyhyKHUofCNuUCNuUClSKVgpaCl2KXwqUypeKmQqbip0KnpQUFBQUFBQUFBQK1ErWlArdit5UCxvLHIseC1SUmtRX2JPUGRodyFuI3NrWU9QZGhvdHV2dyFuI1IjaCNza1NPUGRob3R1dnchbiNSI2gjc1FtVFIhdG5Re1ZSIXhxUSF4fVEjWiFYUiN4IXpxIVtaXSFUIW0jUyNVI1gjcSN6JFAkWSRpJGokcSR2JVNwIVtaXSFUIW0jUyNVI1gjcSN6JFAkWSRpJGokcSR2JVNVJGQjbSRmJHlSJHgkY3EhWFpdIVQhbSNTI1UjWCNxI3okUCRZJGkkaiRxJHYlU3AhW1pdIVQhbSNTI1UjWCNxI3okUCRZJGkkaiRxJHYlU1EhZl5SI2whZ1QjXiFaI19RfFZSIXlxUSF4fFIjeCF5USFQV1Ihe3JRIVJYUiF8c1F4VVEhd3BRI2khY1EjbyFqUSNwIWtRJHskZVIlWCR6U2dQd1EhcGhRI3IhblIkbCNzWmZQaHchbiNzYSFiW2BhIVYhXiFgI2QjZVIjYiFeUiFnXlIhaV9SI24haVMkZSNtJGZSJVYkeVYkYyNtJGYkeVEhcmpSI3YhclFkT1NoUHdVIWxkaCNzUiNzIW5RJFAjU1UkcCRQJHYlU1EkdiRZUiVTJHFRI18hWlIkVyNfUSRyJFBSJVQkclFwVVMhdnAkblIkbiN8USRqI3FSJVAkalEhb2dTI3QhbyN1UiN1IXBRI2YhX1IkXiNmUSRmI21SJHwkZlEkeiRlUiVXJHpfY09QZGh3IW4jc15VT1BkaHchbiNzUSF1b1EhfXRRI091USNQdlEjfCNSUiRfI2hSJFEjU1EhVlpRIWRdUSNWIVRRI3EhbVskTyNTJFAkWSRxJHYlU1EkUiNVUSRUI1hTJGgjcSRqUSRtI3pSJU8kaVIjfSNSUWlQUiNRd1EhY1tRIWthUiNZIVZVIV9bYSFWUSFqYFEjYyFeUSNnIWBRJFsjZFIkXSNlXCIsXG4gIG5vZGVOYW1lczogXCLimqAgVW5pdCBWYXJpYWJsZU5hbWUgQ29tbWVudCBTdHlsZVNoZWV0IFJ1bGVTZXQgVW5pdmVyc2FsU2VsZWN0b3IgVGFnU2VsZWN0b3IgVGFnTmFtZSBOZXN0aW5nU2VsZWN0b3IgQ2xhc3NTZWxlY3RvciBDbGFzc05hbWUgUHNldWRvQ2xhc3NTZWxlY3RvciA6IDo6IFBzZXVkb0NsYXNzTmFtZSBQc2V1ZG9DbGFzc05hbWUgKSAoIEFyZ0xpc3QgVmFsdWVOYW1lIFBhcmVudGhlc2l6ZWRWYWx1ZSBDb2xvckxpdGVyYWwgTnVtYmVyTGl0ZXJhbCBTdHJpbmdMaXRlcmFsIEJpbmFyeUV4cHJlc3Npb24gQmluT3AgQ2FsbEV4cHJlc3Npb24gQ2FsbGVlIENhbGxMaXRlcmFsIENhbGxUYWcgUGFyZW50aGVzaXplZENvbnRlbnQgXSBbIExpbmVOYW1lcyBMaW5lTmFtZSAsIFBzZXVkb0NsYXNzTmFtZSBBcmdMaXN0IElkU2VsZWN0b3IgIyBJZE5hbWUgQXR0cmlidXRlU2VsZWN0b3IgQXR0cmlidXRlTmFtZSBNYXRjaE9wIENoaWxkU2VsZWN0b3IgQ2hpbGRPcCBEZXNjZW5kYW50U2VsZWN0b3IgU2libGluZ1NlbGVjdG9yIFNpYmxpbmdPcCB9IHsgQmxvY2sgRGVjbGFyYXRpb24gUHJvcGVydHlOYW1lIEltcG9ydGFudCA7IEltcG9ydFN0YXRlbWVudCBBdEtleXdvcmQgaW1wb3J0IEtleXdvcmRRdWVyeSBGZWF0dXJlUXVlcnkgRmVhdHVyZU5hbWUgQmluYXJ5UXVlcnkgTG9naWNPcCBVbmFyeVF1ZXJ5IFVuYXJ5UXVlcnlPcCBQYXJlbnRoZXNpemVkUXVlcnkgU2VsZWN0b3JRdWVyeSBzZWxlY3RvciBNZWRpYVN0YXRlbWVudCBtZWRpYSBDaGFyc2V0U3RhdGVtZW50IGNoYXJzZXQgTmFtZXNwYWNlU3RhdGVtZW50IG5hbWVzcGFjZSBOYW1lc3BhY2VOYW1lIEtleWZyYW1lc1N0YXRlbWVudCBrZXlmcmFtZXMgS2V5ZnJhbWVOYW1lIEtleWZyYW1lTGlzdCBLZXlmcmFtZVNlbGVjdG9yIEtleWZyYW1lUmFuZ2VOYW1lIFN1cHBvcnRzU3RhdGVtZW50IHN1cHBvcnRzIEF0UnVsZSBTdHlsZXNcIixcbiAgbWF4VGVybTogMTE3LFxuICBub2RlUHJvcHM6IFtcbiAgICBbXCJpc29sYXRlXCIsIC0yLCAzLCAyNCwgXCJcIl0sXG4gICAgW1wib3BlbmVkQnlcIiwgMTcsIFwiKFwiLCAzMiwgXCJbXCIsIDUwLCBcIntcIl0sXG4gICAgW1wiY2xvc2VkQnlcIiwgMTgsIFwiKVwiLCAzMywgXCJdXCIsIDUxLCBcIn1cIl1cbiAgXSxcbiAgcHJvcFNvdXJjZXM6IFtSVl0sXG4gIHNraXBwZWROb2RlczogWzAsIDMsIDg3XSxcbiAgcmVwZWF0Tm9kZUNvdW50OiAxMSxcbiAgdG9rZW5EYXRhOiBcIkpeflIhXk9YJH1YXiV1XnAkfXBxJXVxcilYcnMuUnN0L3V0dTZkdXYkfXZ3N153eDdveHk5Xnl6OW96ezl0e3w6X3x9P1F9IU8/YyFPIVBAUSFQIVFAaSFRIVtBYiFbIV1CXSFdIV5DWCFeIV8kfSFfIWBDaiFgIWFDeyFhIWIkfSFiIWNEdyFjIX0kfSF9I09GYSNPI1AkfSNQI1FGciNRI1I2ZCNSI1QkfSNUI1VHVCNVI2MkfSNjI2RIZiNkI28kfSNvI3BIeyNwI3E2ZCNxI3JJXiNyI3NJbyNzI3kkfSN5I3oldSN6JGYkfSRmJGcldSRnI0JZJH0jQlkjQloldSNCWiRJUyR9JElTJElfJXUkSV8kSXwkfSRJfCRKTyV1JEpPJEpUJH0kSlQkSlUldSRKVSRLViR9JEtWJEtXJXUkS1cmRlUkfSZGVSZGViV1JkZWOydTJH07J1M7PWBKVzwlbE8kfWAlUVNPeSVeejsnUyVeOydTOz1gJW88JWxPJV5gJWNTb2BPeSVeejsnUyVeOydTOz1gJW88JWxPJV5gJXJQOz1gPCVsJV5+JXpoI1p+T1glXlheJ2ZecCVecHEnZnF5JV56I3klXiN5I3onZiN6JGYlXiRmJGcnZiRnI0JZJV4jQlkjQlonZiNCWiRJUyVeJElTJElfJ2YkSV8kSXwlXiRJfCRKTydmJEpPJEpUJV4kSlQkSlUnZiRKVSRLViVeJEtWJEtXJ2YkS1cmRlUlXiZGVSZGVidmJkZWOydTJV47J1M7PWAlbzwlbE8lXn4nbWgjWn5vYE9YJV5YXidmXnAlXnBxJ2ZxeSVeeiN5JV4jeSN6J2YjeiRmJV4kZiRnJ2YkZyNCWSVeI0JZI0JaJ2YjQlokSVMlXiRJUyRJXydmJElfJEl8JV4kSXwkSk8nZiRKTyRKVCVeJEpUJEpVJ2YkSlUkS1YlXiRLViRLVydmJEtXJkZVJV4mRlUmRlYnZiZGVjsnUyVeOydTOz1gJW88JWxPJV5sKVtVT3klXnojXSVeI10jXiluI147J1MlXjsnUzs9YCVvPCVsTyVebClzVW9gT3klXnojYSVeI2EjYipWI2I7J1MlXjsnUzs9YCVvPCVsTyVebCpbVW9gT3klXnojZCVeI2QjZSpuI2U7J1MlXjsnUzs9YCVvPCVsTyVebCpzVW9gT3klXnojYyVeI2MjZCtWI2Q7J1MlXjsnUzs9YCVvPCVsTyVebCtbVW9gT3klXnojZiVeI2YjZytuI2c7J1MlXjsnUzs9YCVvPCVsTyVebCtzVW9gT3klXnojaCVeI2gjaSxWI2k7J1MlXjsnUzs9YCVvPCVsTyVebCxbVW9gT3klXnojVCVeI1QjVSxuI1U7J1MlXjsnUzs9YCVvPCVsTyVebCxzVW9gT3klXnojYiVeI2IjYy1WI2M7J1MlXjsnUzs9YCVvPCVsTyVebC1bVW9gT3klXnojaCVeI2gjaS1uI2k7J1MlXjsnUzs9YCVvPCVsTyVebC11UyFYW29gT3klXno7J1MlXjsnUzs9YCVvPCVsTyVefi5VV09ZLlJaci5ScnMubnMjTy5SI08jUC5zI1A7J1MuUjsnUzs9YC9vPCVsTy5Sfi5zT2h+fi52Uk87J1MuUjsnUzs9YC9QOz1gTy5Sfi9TWE9ZLlJaci5ScnMubnMjTy5SI08jUC5zI1A7J1MuUjsnUzs9YC9vOz1gPCVsLlI8JWxPLlJ+L3JQOz1gPCVsLlJuL3pZeFFPeSVeeiFRJV4hUSFbMGohWyFjJV4hYyFpMGohaSNUJV4jVCNaMGojWjsnUyVeOydTOz1gJW88JWxPJV5sMG9Zb2BPeSVeeiFRJV4hUSFbMV8hWyFjJV4hYyFpMV8haSNUJV4jVCNaMV8jWjsnUyVeOydTOz1gJW88JWxPJV5sMWRZb2BPeSVeeiFRJV4hUSFbMlMhWyFjJV4hYyFpMlMhaSNUJV4jVCNaMlMjWjsnUyVeOydTOz1gJW88JWxPJV5sMlpZZltvYE95JV56IVElXiFRIVsyeSFbIWMlXiFjIWkyeSFpI1QlXiNUI1oyeSNaOydTJV47J1M7PWAlbzwlbE8lXmwzUVlmW29gT3klXnohUSVeIVEhWzNwIVshYyVeIWMhaTNwIWkjVCVeI1QjWjNwI1o7J1MlXjsnUzs9YCVvPCVsTyVebDN1WW9gT3klXnohUSVeIVEhWzRlIVshYyVeIWMhaTRlIWkjVCVeI1QjWjRlI1o7J1MlXjsnUzs9YCVvPCVsTyVebDRsWWZbb2BPeSVeeiFRJV4hUSFbNVshWyFjJV4hYyFpNVshaSNUJV4jVCNaNVsjWjsnUyVeOydTOz1gJW88JWxPJV5sNWFZb2BPeSVeeiFRJV4hUSFbNlAhWyFjJV4hYyFpNlAhaSNUJV4jVCNaNlAjWjsnUyVeOydTOz1gJW88JWxPJV5sNldTZltvYE95JV56OydTJV47J1M7PWAlbzwlbE8lXmQ2Z1VPeSVeeiFfJV4hXyFgNnkhYDsnUyVeOydTOz1gJW88JWxPJV5kN1FTfFNvYE95JV56OydTJV47J1M7PWAlbzwlbE8lXmI3Y1NYUU95JV56OydTJV47J1M7PWAlbzwlbE8lXn43cldPWTdvWnc3b3d4Lm54I083byNPI1A4WyNQOydTN287J1M7PWA5VzwlbE83b344X1JPOydTN287J1M7PWA4aDs9YE83b344a1hPWTdvWnc3b3d4Lm54I083byNPI1A4WyNQOydTN287J1M7PWA5Vzs9YDwlbDdvPCVsTzdvfjlaUDs9YDwlbDdvbjljU2JeT3klXno7J1MlXjsnUzs9YCVvPCVsTyVefjl0T2F+bjl7VVVRaldPeSVeeiFfJV4hXyFgNnkhYDsnUyVeOydTOz1gJW88JWxPJV5uOmZXalchUlFPeSVeeiFPJV4hTyFQO08hUCFRJV4hUSFbPlQhWzsnUyVeOydTOz1gJW88JWxPJV5sO1RVb2BPeSVeeiFRJV4hUSFbO2chWzsnUyVeOydTOz1gJW88JWxPJV5sO25Zb2AjZVtPeSVeeiFRJV4hUSFbO2chWyFnJV4hZyFoPF4haCNYJV4jWCNZPF4jWTsnUyVeOydTOz1gJW88JWxPJV5sPGNZb2BPeSVeenslXnt8PVJ8fSVefSFPPVIhTyFRJV4hUSFbPWohWzsnUyVeOydTOz1gJW88JWxPJV5sPVdVb2BPeSVeeiFRJV4hUSFbPWohWzsnUyVeOydTOz1gJW88JWxPJV5sPXFVb2AjZVtPeSVeeiFRJV4hUSFbPWohWzsnUyVeOydTOz1gJW88JWxPJV5sPltbb2AjZVtPeSVeeiFPJV4hTyFQO2chUCFRJV4hUSFbPlQhWyFnJV4hZyFoPF4haCNYJV4jWCNZPF4jWTsnUyVeOydTOz1gJW88JWxPJV5uP1ZTdF5PeSVeejsnUyVeOydTOz1gJW88JWxPJV5sP2hXaldPeSVeeiFPJV4hTyFQO08hUCFRJV4hUSFbPlQhWzsnUyVeOydTOz1gJW88JWxPJV5uQFZVI2JRT3klXnohUSVeIVEhWztnIVs7J1MlXjsnUzs9YCVvPCVsTyVefkBuVGpXT3klXnp7QH17OydTJV47J1M7PWAlbzwlbE8lXn5BVVNvYCNbfk95JV56OydTJV47J1M7PWAlbzwlbE8lXmxBZ1sjZVtPeSVeeiFPJV4hTyFQO2chUCFRJV4hUSFbPlQhWyFnJV4hZyFoPF4haCNYJV4jWCNZPF4jWTsnUyVeOydTOz1gJW88JWxPJV5iQmJVXVFPeSVeeiFbJV4hWyFdQnQhXTsnUyVeOydTOz1gJW88JWxPJV5iQntTXlFvYE95JV56OydTJV47J1M7PWAlbzwlbE8lXm5DXlMhWV5PeSVeejsnUyVeOydTOz1gJW88JWxPJV5kQ29TfFNPeSVeejsnUyVeOydTOz1gJW88JWxPJV5iRFFVIU9RT3klXnohYCVeIWAhYURkIWE7J1MlXjsnUzs9YCVvPCVsTyVeYkRrUyFPUW9gT3klXno7J1MlXjsnUzs9YCVvPCVsTyVeYkR6V095JV56IWMlXiFjIX1FZCF9I1QlXiNUI29FZCNvOydTJV47J1M7PWAlbzwlbE8lXmJFa1shW1FvYE95JV56fSVefSFPRWQhTyFRJV4hUSFbRWQhWyFjJV4hYyF9RWQhfSNUJV4jVCNvRWQjbzsnUyVeOydTOz1gJW88JWxPJV5uRmZTcV5PeSVeejsnUyVeOydTOz1gJW88JWxPJV5uRndTcF5PeSVeejsnUyVeOydTOz1gJW88JWxPJV5iR1dVT3klXnojYiVeI2IjY0dqI2M7J1MlXjsnUzs9YCVvPCVsTyVeYkdvVW9gT3klXnojVyVeI1cjWEhSI1g7J1MlXjsnUzs9YCVvPCVsTyVeYkhZUyFiUW9gT3klXno7J1MlXjsnUzs9YCVvPCVsTyVeYkhpVU95JV56I2YlXiNmI2dIUiNnOydTJV47J1M7PWAlbzwlbE8lXmZJUVMhVFVPeSVeejsnUyVeOydTOz1gJW88JWxPJV5uSWNTIVNeT3klXno7J1MlXjsnUzs9YCVvPCVsTyVeZkl0VSFSUU95JV56IV8lXiFfIWA2eSFgOydTJV47J1M7PWAlbzwlbE8lXmBKWlA7PWA8JWwkfVwiLFxuICB0b2tlbml6ZXJzOiBbQ1YsIEFWLCBRViwgMSwgMiwgMywgNCwgbmV3IEh1KFwibX5SUllaW3p7YX5+Z35hTyNefn5kUCFQIVFnfmxPI19+flwiLCAyOCwgMTA1KV0sXG4gIHRvcFJ1bGVzOiB7IFN0eWxlU2hlZXQ6IFswLCA0XSwgU3R5bGVzOiBbMSwgODZdIH0sXG4gIHNwZWNpYWxpemVkOiBbeyB0ZXJtOiAxMDAsIGdldDogKHQpID0+IE5WW3RdIHx8IC0xIH0sIHsgdGVybTogNTgsIGdldDogKHQpID0+IERWW3RdIHx8IC0xIH0sIHsgdGVybTogMTAxLCBnZXQ6ICh0KSA9PiBaVlt0XSB8fCAtMSB9XSxcbiAgdG9rZW5QcmVjOiAxMjAwXG59KTtcbmxldCBMZiA9IG51bGw7XG5mdW5jdGlvbiBVZigpIHtcbiAgaWYgKCFMZiAmJiB0eXBlb2YgZG9jdW1lbnQgPT0gXCJvYmplY3RcIiAmJiBkb2N1bWVudC5ib2R5KSB7XG4gICAgbGV0IHsgc3R5bGU6IHQgfSA9IGRvY3VtZW50LmJvZHksIGUgPSBbXSwgbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgZm9yIChsZXQgciBpbiB0KVxuICAgICAgciAhPSBcImNzc1RleHRcIiAmJiByICE9IFwiY3NzRmxvYXRcIiAmJiB0eXBlb2YgdFtyXSA9PSBcInN0cmluZ1wiICYmICgvW0EtWl0vLnRlc3QocikgJiYgKHIgPSByLnJlcGxhY2UoL1tBLVpdL2csIChpKSA9PiBcIi1cIiArIGkudG9Mb3dlckNhc2UoKSkpLCBuLmhhcyhyKSB8fCAoZS5wdXNoKHIpLCBuLmFkZChyKSkpO1xuICAgIExmID0gZS5zb3J0KCkubWFwKChyKSA9PiAoeyB0eXBlOiBcInByb3BlcnR5XCIsIGxhYmVsOiByIH0pKTtcbiAgfVxuICByZXR1cm4gTGYgfHwgW107XG59XG5jb25zdCB1MCA9IC8qIEBfX1BVUkVfXyAqLyBbXG4gIFwiYWN0aXZlXCIsXG4gIFwiYWZ0ZXJcIixcbiAgXCJhbnktbGlua1wiLFxuICBcImF1dG9maWxsXCIsXG4gIFwiYmFja2Ryb3BcIixcbiAgXCJiZWZvcmVcIixcbiAgXCJjaGVja2VkXCIsXG4gIFwiY3VlXCIsXG4gIFwiZGVmYXVsdFwiLFxuICBcImRlZmluZWRcIixcbiAgXCJkaXNhYmxlZFwiLFxuICBcImVtcHR5XCIsXG4gIFwiZW5hYmxlZFwiLFxuICBcImZpbGUtc2VsZWN0b3ItYnV0dG9uXCIsXG4gIFwiZmlyc3RcIixcbiAgXCJmaXJzdC1jaGlsZFwiLFxuICBcImZpcnN0LWxldHRlclwiLFxuICBcImZpcnN0LWxpbmVcIixcbiAgXCJmaXJzdC1vZi10eXBlXCIsXG4gIFwiZm9jdXNcIixcbiAgXCJmb2N1cy12aXNpYmxlXCIsXG4gIFwiZm9jdXMtd2l0aGluXCIsXG4gIFwiZnVsbHNjcmVlblwiLFxuICBcImhhc1wiLFxuICBcImhvc3RcIixcbiAgXCJob3N0LWNvbnRleHRcIixcbiAgXCJob3ZlclwiLFxuICBcImluLXJhbmdlXCIsXG4gIFwiaW5kZXRlcm1pbmF0ZVwiLFxuICBcImludmFsaWRcIixcbiAgXCJpc1wiLFxuICBcImxhbmdcIixcbiAgXCJsYXN0LWNoaWxkXCIsXG4gIFwibGFzdC1vZi10eXBlXCIsXG4gIFwibGVmdFwiLFxuICBcImxpbmtcIixcbiAgXCJtYXJrZXJcIixcbiAgXCJtb2RhbFwiLFxuICBcIm5vdFwiLFxuICBcIm50aC1jaGlsZFwiLFxuICBcIm50aC1sYXN0LWNoaWxkXCIsXG4gIFwibnRoLWxhc3Qtb2YtdHlwZVwiLFxuICBcIm50aC1vZi10eXBlXCIsXG4gIFwib25seS1jaGlsZFwiLFxuICBcIm9ubHktb2YtdHlwZVwiLFxuICBcIm9wdGlvbmFsXCIsXG4gIFwib3V0LW9mLXJhbmdlXCIsXG4gIFwicGFydFwiLFxuICBcInBsYWNlaG9sZGVyXCIsXG4gIFwicGxhY2Vob2xkZXItc2hvd25cIixcbiAgXCJyZWFkLW9ubHlcIixcbiAgXCJyZWFkLXdyaXRlXCIsXG4gIFwicmVxdWlyZWRcIixcbiAgXCJyaWdodFwiLFxuICBcInJvb3RcIixcbiAgXCJzY29wZVwiLFxuICBcInNlbGVjdGlvblwiLFxuICBcInNsb3R0ZWRcIixcbiAgXCJ0YXJnZXRcIixcbiAgXCJ0YXJnZXQtdGV4dFwiLFxuICBcInZhbGlkXCIsXG4gIFwidmlzaXRlZFwiLFxuICBcIndoZXJlXCJcbl0ubWFwKCh0KSA9PiAoeyB0eXBlOiBcImNsYXNzXCIsIGxhYmVsOiB0IH0pKSwgZDAgPSAvKiBAX19QVVJFX18gKi8gW1xuICBcImFib3ZlXCIsXG4gIFwiYWJzb2x1dGVcIixcbiAgXCJhY3RpdmVib3JkZXJcIixcbiAgXCJhZGRpdGl2ZVwiLFxuICBcImFjdGl2ZWNhcHRpb25cIixcbiAgXCJhZnRlci13aGl0ZS1zcGFjZVwiLFxuICBcImFoZWFkXCIsXG4gIFwiYWxpYXNcIixcbiAgXCJhbGxcIixcbiAgXCJhbGwtc2Nyb2xsXCIsXG4gIFwiYWxwaGFiZXRpY1wiLFxuICBcImFsdGVybmF0ZVwiLFxuICBcImFsd2F5c1wiLFxuICBcImFudGlhbGlhc2VkXCIsXG4gIFwiYXBwd29ya3NwYWNlXCIsXG4gIFwiYXN0ZXJpc2tzXCIsXG4gIFwiYXR0clwiLFxuICBcImF1dG9cIixcbiAgXCJhdXRvLWZsb3dcIixcbiAgXCJhdm9pZFwiLFxuICBcImF2b2lkLWNvbHVtblwiLFxuICBcImF2b2lkLXBhZ2VcIixcbiAgXCJhdm9pZC1yZWdpb25cIixcbiAgXCJheGlzLXBhblwiLFxuICBcImJhY2tncm91bmRcIixcbiAgXCJiYWNrd2FyZHNcIixcbiAgXCJiYXNlbGluZVwiLFxuICBcImJlbG93XCIsXG4gIFwiYmlkaS1vdmVycmlkZVwiLFxuICBcImJsaW5rXCIsXG4gIFwiYmxvY2tcIixcbiAgXCJibG9jay1heGlzXCIsXG4gIFwiYm9sZFwiLFxuICBcImJvbGRlclwiLFxuICBcImJvcmRlclwiLFxuICBcImJvcmRlci1ib3hcIixcbiAgXCJib3RoXCIsXG4gIFwiYm90dG9tXCIsXG4gIFwiYnJlYWtcIixcbiAgXCJicmVhay1hbGxcIixcbiAgXCJicmVhay13b3JkXCIsXG4gIFwiYnVsbGV0c1wiLFxuICBcImJ1dHRvblwiLFxuICBcImJ1dHRvbi1iZXZlbFwiLFxuICBcImJ1dHRvbmZhY2VcIixcbiAgXCJidXR0b25oaWdobGlnaHRcIixcbiAgXCJidXR0b25zaGFkb3dcIixcbiAgXCJidXR0b250ZXh0XCIsXG4gIFwiY2FsY1wiLFxuICBcImNhcGl0YWxpemVcIixcbiAgXCJjYXBzLWxvY2staW5kaWNhdG9yXCIsXG4gIFwiY2FwdGlvblwiLFxuICBcImNhcHRpb250ZXh0XCIsXG4gIFwiY2FyZXRcIixcbiAgXCJjZWxsXCIsXG4gIFwiY2VudGVyXCIsXG4gIFwiY2hlY2tib3hcIixcbiAgXCJjaXJjbGVcIixcbiAgXCJjamstZGVjaW1hbFwiLFxuICBcImNsZWFyXCIsXG4gIFwiY2xpcFwiLFxuICBcImNsb3NlLXF1b3RlXCIsXG4gIFwiY29sLXJlc2l6ZVwiLFxuICBcImNvbGxhcHNlXCIsXG4gIFwiY29sb3JcIixcbiAgXCJjb2xvci1idXJuXCIsXG4gIFwiY29sb3ItZG9kZ2VcIixcbiAgXCJjb2x1bW5cIixcbiAgXCJjb2x1bW4tcmV2ZXJzZVwiLFxuICBcImNvbXBhY3RcIixcbiAgXCJjb25kZW5zZWRcIixcbiAgXCJjb250YWluXCIsXG4gIFwiY29udGVudFwiLFxuICBcImNvbnRlbnRzXCIsXG4gIFwiY29udGVudC1ib3hcIixcbiAgXCJjb250ZXh0LW1lbnVcIixcbiAgXCJjb250aW51b3VzXCIsXG4gIFwiY29weVwiLFxuICBcImNvdW50ZXJcIixcbiAgXCJjb3VudGVyc1wiLFxuICBcImNvdmVyXCIsXG4gIFwiY3JvcFwiLFxuICBcImNyb3NzXCIsXG4gIFwiY3Jvc3NoYWlyXCIsXG4gIFwiY3VycmVudGNvbG9yXCIsXG4gIFwiY3Vyc2l2ZVwiLFxuICBcImN5Y2xpY1wiLFxuICBcImRhcmtlblwiLFxuICBcImRhc2hlZFwiLFxuICBcImRlY2ltYWxcIixcbiAgXCJkZWNpbWFsLWxlYWRpbmctemVyb1wiLFxuICBcImRlZmF1bHRcIixcbiAgXCJkZWZhdWx0LWJ1dHRvblwiLFxuICBcImRlbnNlXCIsXG4gIFwiZGVzdGluYXRpb24tYXRvcFwiLFxuICBcImRlc3RpbmF0aW9uLWluXCIsXG4gIFwiZGVzdGluYXRpb24tb3V0XCIsXG4gIFwiZGVzdGluYXRpb24tb3ZlclwiLFxuICBcImRpZmZlcmVuY2VcIixcbiAgXCJkaXNjXCIsXG4gIFwiZGlzY2FyZFwiLFxuICBcImRpc2Nsb3N1cmUtY2xvc2VkXCIsXG4gIFwiZGlzY2xvc3VyZS1vcGVuXCIsXG4gIFwiZG9jdW1lbnRcIixcbiAgXCJkb3QtZGFzaFwiLFxuICBcImRvdC1kb3QtZGFzaFwiLFxuICBcImRvdHRlZFwiLFxuICBcImRvdWJsZVwiLFxuICBcImRvd25cIixcbiAgXCJlLXJlc2l6ZVwiLFxuICBcImVhc2VcIixcbiAgXCJlYXNlLWluXCIsXG4gIFwiZWFzZS1pbi1vdXRcIixcbiAgXCJlYXNlLW91dFwiLFxuICBcImVsZW1lbnRcIixcbiAgXCJlbGxpcHNlXCIsXG4gIFwiZWxsaXBzaXNcIixcbiAgXCJlbWJlZFwiLFxuICBcImVuZFwiLFxuICBcImV0aGlvcGljLWFiZWdlZGUtZ2V6XCIsXG4gIFwiZXRoaW9waWMtaGFsZWhhbWUtYWEtZXJcIixcbiAgXCJldGhpb3BpYy1oYWxlaGFtZS1nZXpcIixcbiAgXCJldy1yZXNpemVcIixcbiAgXCJleGNsdXNpb25cIixcbiAgXCJleHBhbmRlZFwiLFxuICBcImV4dGVuZHNcIixcbiAgXCJleHRyYS1jb25kZW5zZWRcIixcbiAgXCJleHRyYS1leHBhbmRlZFwiLFxuICBcImZhbnRhc3lcIixcbiAgXCJmYXN0XCIsXG4gIFwiZmlsbFwiLFxuICBcImZpbGwtYm94XCIsXG4gIFwiZml4ZWRcIixcbiAgXCJmbGF0XCIsXG4gIFwiZmxleFwiLFxuICBcImZsZXgtZW5kXCIsXG4gIFwiZmxleC1zdGFydFwiLFxuICBcImZvb3Rub3Rlc1wiLFxuICBcImZvcndhcmRzXCIsXG4gIFwiZnJvbVwiLFxuICBcImdlb21ldHJpY1ByZWNpc2lvblwiLFxuICBcImdyYXl0ZXh0XCIsXG4gIFwiZ3JpZFwiLFxuICBcImdyb292ZVwiLFxuICBcImhhbmRcIixcbiAgXCJoYXJkLWxpZ2h0XCIsXG4gIFwiaGVscFwiLFxuICBcImhpZGRlblwiLFxuICBcImhpZGVcIixcbiAgXCJoaWdoZXJcIixcbiAgXCJoaWdobGlnaHRcIixcbiAgXCJoaWdobGlnaHR0ZXh0XCIsXG4gIFwiaG9yaXpvbnRhbFwiLFxuICBcImhzbFwiLFxuICBcImhzbGFcIixcbiAgXCJodWVcIixcbiAgXCJpY29uXCIsXG4gIFwiaWdub3JlXCIsXG4gIFwiaW5hY3RpdmVib3JkZXJcIixcbiAgXCJpbmFjdGl2ZWNhcHRpb25cIixcbiAgXCJpbmFjdGl2ZWNhcHRpb250ZXh0XCIsXG4gIFwiaW5maW5pdGVcIixcbiAgXCJpbmZvYmFja2dyb3VuZFwiLFxuICBcImluZm90ZXh0XCIsXG4gIFwiaW5oZXJpdFwiLFxuICBcImluaXRpYWxcIixcbiAgXCJpbmxpbmVcIixcbiAgXCJpbmxpbmUtYXhpc1wiLFxuICBcImlubGluZS1ibG9ja1wiLFxuICBcImlubGluZS1mbGV4XCIsXG4gIFwiaW5saW5lLWdyaWRcIixcbiAgXCJpbmxpbmUtdGFibGVcIixcbiAgXCJpbnNldFwiLFxuICBcImluc2lkZVwiLFxuICBcImludHJpbnNpY1wiLFxuICBcImludmVydFwiLFxuICBcIml0YWxpY1wiLFxuICBcImp1c3RpZnlcIixcbiAgXCJrZWVwLWFsbFwiLFxuICBcImxhbmRzY2FwZVwiLFxuICBcImxhcmdlXCIsXG4gIFwibGFyZ2VyXCIsXG4gIFwibGVmdFwiLFxuICBcImxldmVsXCIsXG4gIFwibGlnaHRlclwiLFxuICBcImxpZ2h0ZW5cIixcbiAgXCJsaW5lLXRocm91Z2hcIixcbiAgXCJsaW5lYXJcIixcbiAgXCJsaW5lYXItZ3JhZGllbnRcIixcbiAgXCJsaW5lc1wiLFxuICBcImxpc3QtaXRlbVwiLFxuICBcImxpc3Rib3hcIixcbiAgXCJsaXN0aXRlbVwiLFxuICBcImxvY2FsXCIsXG4gIFwibG9naWNhbFwiLFxuICBcImxvdWRcIixcbiAgXCJsb3dlclwiLFxuICBcImxvd2VyLWhleGFkZWNpbWFsXCIsXG4gIFwibG93ZXItbGF0aW5cIixcbiAgXCJsb3dlci1ub3J3ZWdpYW5cIixcbiAgXCJsb3dlcmNhc2VcIixcbiAgXCJsdHJcIixcbiAgXCJsdW1pbm9zaXR5XCIsXG4gIFwibWFuaXB1bGF0aW9uXCIsXG4gIFwibWF0Y2hcIixcbiAgXCJtYXRyaXhcIixcbiAgXCJtYXRyaXgzZFwiLFxuICBcIm1lZGl1bVwiLFxuICBcIm1lbnVcIixcbiAgXCJtZW51dGV4dFwiLFxuICBcIm1lc3NhZ2UtYm94XCIsXG4gIFwibWlkZGxlXCIsXG4gIFwibWluLWludHJpbnNpY1wiLFxuICBcIm1peFwiLFxuICBcIm1vbm9zcGFjZVwiLFxuICBcIm1vdmVcIixcbiAgXCJtdWx0aXBsZVwiLFxuICBcIm11bHRpcGxlX21hc2tfaW1hZ2VzXCIsXG4gIFwibXVsdGlwbHlcIixcbiAgXCJuLXJlc2l6ZVwiLFxuICBcIm5hcnJvd2VyXCIsXG4gIFwibmUtcmVzaXplXCIsXG4gIFwibmVzdy1yZXNpemVcIixcbiAgXCJuby1jbG9zZS1xdW90ZVwiLFxuICBcIm5vLWRyb3BcIixcbiAgXCJuby1vcGVuLXF1b3RlXCIsXG4gIFwibm8tcmVwZWF0XCIsXG4gIFwibm9uZVwiLFxuICBcIm5vcm1hbFwiLFxuICBcIm5vdC1hbGxvd2VkXCIsXG4gIFwibm93cmFwXCIsXG4gIFwibnMtcmVzaXplXCIsXG4gIFwibnVtYmVyc1wiLFxuICBcIm51bWVyaWNcIixcbiAgXCJudy1yZXNpemVcIixcbiAgXCJud3NlLXJlc2l6ZVwiLFxuICBcIm9ibGlxdWVcIixcbiAgXCJvcGFjaXR5XCIsXG4gIFwib3Blbi1xdW90ZVwiLFxuICBcIm9wdGltaXplTGVnaWJpbGl0eVwiLFxuICBcIm9wdGltaXplU3BlZWRcIixcbiAgXCJvdXRzZXRcIixcbiAgXCJvdXRzaWRlXCIsXG4gIFwib3V0c2lkZS1zaGFwZVwiLFxuICBcIm92ZXJsYXlcIixcbiAgXCJvdmVybGluZVwiLFxuICBcInBhZGRpbmdcIixcbiAgXCJwYWRkaW5nLWJveFwiLFxuICBcInBhaW50ZWRcIixcbiAgXCJwYWdlXCIsXG4gIFwicGF1c2VkXCIsXG4gIFwicGVyc3BlY3RpdmVcIixcbiAgXCJwaW5jaC16b29tXCIsXG4gIFwicGx1cy1kYXJrZXJcIixcbiAgXCJwbHVzLWxpZ2h0ZXJcIixcbiAgXCJwb2ludGVyXCIsXG4gIFwicG9seWdvblwiLFxuICBcInBvcnRyYWl0XCIsXG4gIFwicHJlXCIsXG4gIFwicHJlLWxpbmVcIixcbiAgXCJwcmUtd3JhcFwiLFxuICBcInByZXNlcnZlLTNkXCIsXG4gIFwicHJvZ3Jlc3NcIixcbiAgXCJwdXNoLWJ1dHRvblwiLFxuICBcInJhZGlhbC1ncmFkaWVudFwiLFxuICBcInJhZGlvXCIsXG4gIFwicmVhZC1vbmx5XCIsXG4gIFwicmVhZC13cml0ZVwiLFxuICBcInJlYWQtd3JpdGUtcGxhaW50ZXh0LW9ubHlcIixcbiAgXCJyZWN0YW5nbGVcIixcbiAgXCJyZWdpb25cIixcbiAgXCJyZWxhdGl2ZVwiLFxuICBcInJlcGVhdFwiLFxuICBcInJlcGVhdGluZy1saW5lYXItZ3JhZGllbnRcIixcbiAgXCJyZXBlYXRpbmctcmFkaWFsLWdyYWRpZW50XCIsXG4gIFwicmVwZWF0LXhcIixcbiAgXCJyZXBlYXQteVwiLFxuICBcInJlc2V0XCIsXG4gIFwicmV2ZXJzZVwiLFxuICBcInJnYlwiLFxuICBcInJnYmFcIixcbiAgXCJyaWRnZVwiLFxuICBcInJpZ2h0XCIsXG4gIFwicm90YXRlXCIsXG4gIFwicm90YXRlM2RcIixcbiAgXCJyb3RhdGVYXCIsXG4gIFwicm90YXRlWVwiLFxuICBcInJvdGF0ZVpcIixcbiAgXCJyb3VuZFwiLFxuICBcInJvd1wiLFxuICBcInJvdy1yZXNpemVcIixcbiAgXCJyb3ctcmV2ZXJzZVwiLFxuICBcInJ0bFwiLFxuICBcInJ1bi1pblwiLFxuICBcInJ1bm5pbmdcIixcbiAgXCJzLXJlc2l6ZVwiLFxuICBcInNhbnMtc2VyaWZcIixcbiAgXCJzYXR1cmF0aW9uXCIsXG4gIFwic2NhbGVcIixcbiAgXCJzY2FsZTNkXCIsXG4gIFwic2NhbGVYXCIsXG4gIFwic2NhbGVZXCIsXG4gIFwic2NhbGVaXCIsXG4gIFwic2NyZWVuXCIsXG4gIFwic2Nyb2xsXCIsXG4gIFwic2Nyb2xsYmFyXCIsXG4gIFwic2Nyb2xsLXBvc2l0aW9uXCIsXG4gIFwic2UtcmVzaXplXCIsXG4gIFwic2VsZi1zdGFydFwiLFxuICBcInNlbGYtZW5kXCIsXG4gIFwic2VtaS1jb25kZW5zZWRcIixcbiAgXCJzZW1pLWV4cGFuZGVkXCIsXG4gIFwic2VwYXJhdGVcIixcbiAgXCJzZXJpZlwiLFxuICBcInNob3dcIixcbiAgXCJzaW5nbGVcIixcbiAgXCJza2V3XCIsXG4gIFwic2tld1hcIixcbiAgXCJza2V3WVwiLFxuICBcInNraXAtd2hpdGUtc3BhY2VcIixcbiAgXCJzbGlkZVwiLFxuICBcInNsaWRlci1ob3Jpem9udGFsXCIsXG4gIFwic2xpZGVyLXZlcnRpY2FsXCIsXG4gIFwic2xpZGVydGh1bWItaG9yaXpvbnRhbFwiLFxuICBcInNsaWRlcnRodW1iLXZlcnRpY2FsXCIsXG4gIFwic2xvd1wiLFxuICBcInNtYWxsXCIsXG4gIFwic21hbGwtY2Fwc1wiLFxuICBcInNtYWxsLWNhcHRpb25cIixcbiAgXCJzbWFsbGVyXCIsXG4gIFwic29mdC1saWdodFwiLFxuICBcInNvbGlkXCIsXG4gIFwic291cmNlLWF0b3BcIixcbiAgXCJzb3VyY2UtaW5cIixcbiAgXCJzb3VyY2Utb3V0XCIsXG4gIFwic291cmNlLW92ZXJcIixcbiAgXCJzcGFjZVwiLFxuICBcInNwYWNlLWFyb3VuZFwiLFxuICBcInNwYWNlLWJldHdlZW5cIixcbiAgXCJzcGFjZS1ldmVubHlcIixcbiAgXCJzcGVsbC1vdXRcIixcbiAgXCJzcXVhcmVcIixcbiAgXCJzdGFydFwiLFxuICBcInN0YXRpY1wiLFxuICBcInN0YXR1cy1iYXJcIixcbiAgXCJzdHJldGNoXCIsXG4gIFwic3Ryb2tlXCIsXG4gIFwic3Ryb2tlLWJveFwiLFxuICBcInN1YlwiLFxuICBcInN1YnBpeGVsLWFudGlhbGlhc2VkXCIsXG4gIFwic3ZnX21hc2tzXCIsXG4gIFwic3VwZXJcIixcbiAgXCJzdy1yZXNpemVcIixcbiAgXCJzeW1ib2xpY1wiLFxuICBcInN5bWJvbHNcIixcbiAgXCJzeXN0ZW0tdWlcIixcbiAgXCJ0YWJsZVwiLFxuICBcInRhYmxlLWNhcHRpb25cIixcbiAgXCJ0YWJsZS1jZWxsXCIsXG4gIFwidGFibGUtY29sdW1uXCIsXG4gIFwidGFibGUtY29sdW1uLWdyb3VwXCIsXG4gIFwidGFibGUtZm9vdGVyLWdyb3VwXCIsXG4gIFwidGFibGUtaGVhZGVyLWdyb3VwXCIsXG4gIFwidGFibGUtcm93XCIsXG4gIFwidGFibGUtcm93LWdyb3VwXCIsXG4gIFwidGV4dFwiLFxuICBcInRleHQtYm90dG9tXCIsXG4gIFwidGV4dC10b3BcIixcbiAgXCJ0ZXh0YXJlYVwiLFxuICBcInRleHRmaWVsZFwiLFxuICBcInRoaWNrXCIsXG4gIFwidGhpblwiLFxuICBcInRocmVlZGRhcmtzaGFkb3dcIixcbiAgXCJ0aHJlZWRmYWNlXCIsXG4gIFwidGhyZWVkaGlnaGxpZ2h0XCIsXG4gIFwidGhyZWVkbGlnaHRzaGFkb3dcIixcbiAgXCJ0aHJlZWRzaGFkb3dcIixcbiAgXCJ0b1wiLFxuICBcInRvcFwiLFxuICBcInRyYW5zZm9ybVwiLFxuICBcInRyYW5zbGF0ZVwiLFxuICBcInRyYW5zbGF0ZTNkXCIsXG4gIFwidHJhbnNsYXRlWFwiLFxuICBcInRyYW5zbGF0ZVlcIixcbiAgXCJ0cmFuc2xhdGVaXCIsXG4gIFwidHJhbnNwYXJlbnRcIixcbiAgXCJ1bHRyYS1jb25kZW5zZWRcIixcbiAgXCJ1bHRyYS1leHBhbmRlZFwiLFxuICBcInVuZGVybGluZVwiLFxuICBcInVuaWRpcmVjdGlvbmFsLXBhblwiLFxuICBcInVuc2V0XCIsXG4gIFwidXBcIixcbiAgXCJ1cHBlci1sYXRpblwiLFxuICBcInVwcGVyY2FzZVwiLFxuICBcInVybFwiLFxuICBcInZhclwiLFxuICBcInZlcnRpY2FsXCIsXG4gIFwidmVydGljYWwtdGV4dFwiLFxuICBcInZpZXctYm94XCIsXG4gIFwidmlzaWJsZVwiLFxuICBcInZpc2libGVGaWxsXCIsXG4gIFwidmlzaWJsZVBhaW50ZWRcIixcbiAgXCJ2aXNpYmxlU3Ryb2tlXCIsXG4gIFwidmlzdWFsXCIsXG4gIFwidy1yZXNpemVcIixcbiAgXCJ3YWl0XCIsXG4gIFwid2F2ZVwiLFxuICBcIndpZGVyXCIsXG4gIFwid2luZG93XCIsXG4gIFwid2luZG93ZnJhbWVcIixcbiAgXCJ3aW5kb3d0ZXh0XCIsXG4gIFwid29yZHNcIixcbiAgXCJ3cmFwXCIsXG4gIFwid3JhcC1yZXZlcnNlXCIsXG4gIFwieC1sYXJnZVwiLFxuICBcIngtc21hbGxcIixcbiAgXCJ4b3JcIixcbiAgXCJ4eC1sYXJnZVwiLFxuICBcInh4LXNtYWxsXCJcbl0ubWFwKCh0KSA9PiAoeyB0eXBlOiBcImtleXdvcmRcIiwgbGFiZWw6IHQgfSkpLmNvbmNhdCgvKiBAX19QVVJFX18gKi8gW1xuICBcImFsaWNlYmx1ZVwiLFxuICBcImFudGlxdWV3aGl0ZVwiLFxuICBcImFxdWFcIixcbiAgXCJhcXVhbWFyaW5lXCIsXG4gIFwiYXp1cmVcIixcbiAgXCJiZWlnZVwiLFxuICBcImJpc3F1ZVwiLFxuICBcImJsYWNrXCIsXG4gIFwiYmxhbmNoZWRhbG1vbmRcIixcbiAgXCJibHVlXCIsXG4gIFwiYmx1ZXZpb2xldFwiLFxuICBcImJyb3duXCIsXG4gIFwiYnVybHl3b29kXCIsXG4gIFwiY2FkZXRibHVlXCIsXG4gIFwiY2hhcnRyZXVzZVwiLFxuICBcImNob2NvbGF0ZVwiLFxuICBcImNvcmFsXCIsXG4gIFwiY29ybmZsb3dlcmJsdWVcIixcbiAgXCJjb3Juc2lsa1wiLFxuICBcImNyaW1zb25cIixcbiAgXCJjeWFuXCIsXG4gIFwiZGFya2JsdWVcIixcbiAgXCJkYXJrY3lhblwiLFxuICBcImRhcmtnb2xkZW5yb2RcIixcbiAgXCJkYXJrZ3JheVwiLFxuICBcImRhcmtncmVlblwiLFxuICBcImRhcmtraGFraVwiLFxuICBcImRhcmttYWdlbnRhXCIsXG4gIFwiZGFya29saXZlZ3JlZW5cIixcbiAgXCJkYXJrb3JhbmdlXCIsXG4gIFwiZGFya29yY2hpZFwiLFxuICBcImRhcmtyZWRcIixcbiAgXCJkYXJrc2FsbW9uXCIsXG4gIFwiZGFya3NlYWdyZWVuXCIsXG4gIFwiZGFya3NsYXRlYmx1ZVwiLFxuICBcImRhcmtzbGF0ZWdyYXlcIixcbiAgXCJkYXJrdHVycXVvaXNlXCIsXG4gIFwiZGFya3Zpb2xldFwiLFxuICBcImRlZXBwaW5rXCIsXG4gIFwiZGVlcHNreWJsdWVcIixcbiAgXCJkaW1ncmF5XCIsXG4gIFwiZG9kZ2VyYmx1ZVwiLFxuICBcImZpcmVicmlja1wiLFxuICBcImZsb3JhbHdoaXRlXCIsXG4gIFwiZm9yZXN0Z3JlZW5cIixcbiAgXCJmdWNoc2lhXCIsXG4gIFwiZ2FpbnNib3JvXCIsXG4gIFwiZ2hvc3R3aGl0ZVwiLFxuICBcImdvbGRcIixcbiAgXCJnb2xkZW5yb2RcIixcbiAgXCJncmF5XCIsXG4gIFwiZ3JleVwiLFxuICBcImdyZWVuXCIsXG4gIFwiZ3JlZW55ZWxsb3dcIixcbiAgXCJob25leWRld1wiLFxuICBcImhvdHBpbmtcIixcbiAgXCJpbmRpYW5yZWRcIixcbiAgXCJpbmRpZ29cIixcbiAgXCJpdm9yeVwiLFxuICBcImtoYWtpXCIsXG4gIFwibGF2ZW5kZXJcIixcbiAgXCJsYXZlbmRlcmJsdXNoXCIsXG4gIFwibGF3bmdyZWVuXCIsXG4gIFwibGVtb25jaGlmZm9uXCIsXG4gIFwibGlnaHRibHVlXCIsXG4gIFwibGlnaHRjb3JhbFwiLFxuICBcImxpZ2h0Y3lhblwiLFxuICBcImxpZ2h0Z29sZGVucm9keWVsbG93XCIsXG4gIFwibGlnaHRncmF5XCIsXG4gIFwibGlnaHRncmVlblwiLFxuICBcImxpZ2h0cGlua1wiLFxuICBcImxpZ2h0c2FsbW9uXCIsXG4gIFwibGlnaHRzZWFncmVlblwiLFxuICBcImxpZ2h0c2t5Ymx1ZVwiLFxuICBcImxpZ2h0c2xhdGVncmF5XCIsXG4gIFwibGlnaHRzdGVlbGJsdWVcIixcbiAgXCJsaWdodHllbGxvd1wiLFxuICBcImxpbWVcIixcbiAgXCJsaW1lZ3JlZW5cIixcbiAgXCJsaW5lblwiLFxuICBcIm1hZ2VudGFcIixcbiAgXCJtYXJvb25cIixcbiAgXCJtZWRpdW1hcXVhbWFyaW5lXCIsXG4gIFwibWVkaXVtYmx1ZVwiLFxuICBcIm1lZGl1bW9yY2hpZFwiLFxuICBcIm1lZGl1bXB1cnBsZVwiLFxuICBcIm1lZGl1bXNlYWdyZWVuXCIsXG4gIFwibWVkaXVtc2xhdGVibHVlXCIsXG4gIFwibWVkaXVtc3ByaW5nZ3JlZW5cIixcbiAgXCJtZWRpdW10dXJxdW9pc2VcIixcbiAgXCJtZWRpdW12aW9sZXRyZWRcIixcbiAgXCJtaWRuaWdodGJsdWVcIixcbiAgXCJtaW50Y3JlYW1cIixcbiAgXCJtaXN0eXJvc2VcIixcbiAgXCJtb2NjYXNpblwiLFxuICBcIm5hdmFqb3doaXRlXCIsXG4gIFwibmF2eVwiLFxuICBcIm9sZGxhY2VcIixcbiAgXCJvbGl2ZVwiLFxuICBcIm9saXZlZHJhYlwiLFxuICBcIm9yYW5nZVwiLFxuICBcIm9yYW5nZXJlZFwiLFxuICBcIm9yY2hpZFwiLFxuICBcInBhbGVnb2xkZW5yb2RcIixcbiAgXCJwYWxlZ3JlZW5cIixcbiAgXCJwYWxldHVycXVvaXNlXCIsXG4gIFwicGFsZXZpb2xldHJlZFwiLFxuICBcInBhcGF5YXdoaXBcIixcbiAgXCJwZWFjaHB1ZmZcIixcbiAgXCJwZXJ1XCIsXG4gIFwicGlua1wiLFxuICBcInBsdW1cIixcbiAgXCJwb3dkZXJibHVlXCIsXG4gIFwicHVycGxlXCIsXG4gIFwicmViZWNjYXB1cnBsZVwiLFxuICBcInJlZFwiLFxuICBcInJvc3licm93blwiLFxuICBcInJveWFsYmx1ZVwiLFxuICBcInNhZGRsZWJyb3duXCIsXG4gIFwic2FsbW9uXCIsXG4gIFwic2FuZHlicm93blwiLFxuICBcInNlYWdyZWVuXCIsXG4gIFwic2Vhc2hlbGxcIixcbiAgXCJzaWVubmFcIixcbiAgXCJzaWx2ZXJcIixcbiAgXCJza3libHVlXCIsXG4gIFwic2xhdGVibHVlXCIsXG4gIFwic2xhdGVncmF5XCIsXG4gIFwic25vd1wiLFxuICBcInNwcmluZ2dyZWVuXCIsXG4gIFwic3RlZWxibHVlXCIsXG4gIFwidGFuXCIsXG4gIFwidGVhbFwiLFxuICBcInRoaXN0bGVcIixcbiAgXCJ0b21hdG9cIixcbiAgXCJ0dXJxdW9pc2VcIixcbiAgXCJ2aW9sZXRcIixcbiAgXCJ3aGVhdFwiLFxuICBcIndoaXRlXCIsXG4gIFwid2hpdGVzbW9rZVwiLFxuICBcInllbGxvd1wiLFxuICBcInllbGxvd2dyZWVuXCJcbl0ubWFwKCh0KSA9PiAoeyB0eXBlOiBcImNvbnN0YW50XCIsIGxhYmVsOiB0IH0pKSksIElWID0gLyogQF9fUFVSRV9fICovIFtcbiAgXCJhXCIsXG4gIFwiYWJiclwiLFxuICBcImFkZHJlc3NcIixcbiAgXCJhcnRpY2xlXCIsXG4gIFwiYXNpZGVcIixcbiAgXCJiXCIsXG4gIFwiYmRpXCIsXG4gIFwiYmRvXCIsXG4gIFwiYmxvY2txdW90ZVwiLFxuICBcImJvZHlcIixcbiAgXCJiclwiLFxuICBcImJ1dHRvblwiLFxuICBcImNhbnZhc1wiLFxuICBcImNhcHRpb25cIixcbiAgXCJjaXRlXCIsXG4gIFwiY29kZVwiLFxuICBcImNvbFwiLFxuICBcImNvbGdyb3VwXCIsXG4gIFwiZGRcIixcbiAgXCJkZWxcIixcbiAgXCJkZXRhaWxzXCIsXG4gIFwiZGZuXCIsXG4gIFwiZGlhbG9nXCIsXG4gIFwiZGl2XCIsXG4gIFwiZGxcIixcbiAgXCJkdFwiLFxuICBcImVtXCIsXG4gIFwiZmlnY2FwdGlvblwiLFxuICBcImZpZ3VyZVwiLFxuICBcImZvb3RlclwiLFxuICBcImZvcm1cIixcbiAgXCJoZWFkZXJcIixcbiAgXCJoZ3JvdXBcIixcbiAgXCJoMVwiLFxuICBcImgyXCIsXG4gIFwiaDNcIixcbiAgXCJoNFwiLFxuICBcImg1XCIsXG4gIFwiaDZcIixcbiAgXCJoclwiLFxuICBcImh0bWxcIixcbiAgXCJpXCIsXG4gIFwiaWZyYW1lXCIsXG4gIFwiaW1nXCIsXG4gIFwiaW5wdXRcIixcbiAgXCJpbnNcIixcbiAgXCJrYmRcIixcbiAgXCJsYWJlbFwiLFxuICBcImxlZ2VuZFwiLFxuICBcImxpXCIsXG4gIFwibWFpblwiLFxuICBcIm1ldGVyXCIsXG4gIFwibmF2XCIsXG4gIFwib2xcIixcbiAgXCJvdXRwdXRcIixcbiAgXCJwXCIsXG4gIFwicHJlXCIsXG4gIFwicnVieVwiLFxuICBcInNlY3Rpb25cIixcbiAgXCJzZWxlY3RcIixcbiAgXCJzbWFsbFwiLFxuICBcInNvdXJjZVwiLFxuICBcInNwYW5cIixcbiAgXCJzdHJvbmdcIixcbiAgXCJzdWJcIixcbiAgXCJzdW1tYXJ5XCIsXG4gIFwic3VwXCIsXG4gIFwidGFibGVcIixcbiAgXCJ0Ym9keVwiLFxuICBcInRkXCIsXG4gIFwidGVtcGxhdGVcIixcbiAgXCJ0ZXh0YXJlYVwiLFxuICBcInRmb290XCIsXG4gIFwidGhcIixcbiAgXCJ0aGVhZFwiLFxuICBcInRyXCIsXG4gIFwidVwiLFxuICBcInVsXCJcbl0ubWFwKCh0KSA9PiAoeyB0eXBlOiBcInR5cGVcIiwgbGFiZWw6IHQgfSkpLCB4aSA9IC9eKFxcd1tcXHctXSp8LVxcd1tcXHctXSp8KSQvLCBXViA9IC9eLSgtW1xcdy1dKik/JC87XG5mdW5jdGlvbiBNVih0LCBlKSB7XG4gIHZhciBuO1xuICBpZiAoKHQubmFtZSA9PSBcIihcIiB8fCB0LnR5cGUuaXNFcnJvcikgJiYgKHQgPSB0LnBhcmVudCB8fCB0KSwgdC5uYW1lICE9IFwiQXJnTGlzdFwiKVxuICAgIHJldHVybiAhMTtcbiAgbGV0IHIgPSAobiA9IHQucGFyZW50KSA9PT0gbnVsbCB8fCBuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuLmZpcnN0Q2hpbGQ7XG4gIHJldHVybiAociA9PSBudWxsID8gdm9pZCAwIDogci5uYW1lKSAhPSBcIkNhbGxlZVwiID8gITEgOiBlLnNsaWNlU3RyaW5nKHIuZnJvbSwgci50bykgPT0gXCJ2YXJcIjtcbn1cbmNvbnN0IGYwID0gLyogQF9fUFVSRV9fICovIG5ldyBleCgpLCBYViA9IFtcIkRlY2xhcmF0aW9uXCJdO1xuZnVuY3Rpb24galYodCkge1xuICBmb3IgKGxldCBlID0gdDsgOyApIHtcbiAgICBpZiAoZS50eXBlLmlzVG9wKVxuICAgICAgcmV0dXJuIGU7XG4gICAgaWYgKCEoZSA9IGUucGFyZW50KSlcbiAgICAgIHJldHVybiB0O1xuICB9XG59XG5mdW5jdGlvbiBWeCh0LCBlLCBuKSB7XG4gIGlmIChlLnRvIC0gZS5mcm9tID4gNDA5Nikge1xuICAgIGxldCByID0gZjAuZ2V0KGUpO1xuICAgIGlmIChyKVxuICAgICAgcmV0dXJuIHI7XG4gICAgbGV0IGkgPSBbXSwgcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksIG8gPSBlLmN1cnNvcihsdC5JbmNsdWRlQW5vbnltb3VzKTtcbiAgICBpZiAoby5maXJzdENoaWxkKCkpXG4gICAgICBkb1xuICAgICAgICBmb3IgKGxldCBhIG9mIFZ4KHQsIG8ubm9kZSwgbikpXG4gICAgICAgICAgcy5oYXMoYS5sYWJlbCkgfHwgKHMuYWRkKGEubGFiZWwpLCBpLnB1c2goYSkpO1xuICAgICAgd2hpbGUgKG8ubmV4dFNpYmxpbmcoKSk7XG4gICAgcmV0dXJuIGYwLnNldChlLCBpKSwgaTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgciA9IFtdLCBpID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICByZXR1cm4gZS5jdXJzb3IoKS5pdGVyYXRlKChzKSA9PiB7XG4gICAgICB2YXIgbztcbiAgICAgIGlmIChuKHMpICYmIHMubWF0Y2hDb250ZXh0KFhWKSAmJiAoKG8gPSBzLm5vZGUubmV4dFNpYmxpbmcpID09PSBudWxsIHx8IG8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG8ubmFtZSkgPT0gXCI6XCIpIHtcbiAgICAgICAgbGV0IGEgPSB0LnNsaWNlU3RyaW5nKHMuZnJvbSwgcy50byk7XG4gICAgICAgIGkuaGFzKGEpIHx8IChpLmFkZChhKSwgci5wdXNoKHsgbGFiZWw6IGEsIHR5cGU6IFwidmFyaWFibGVcIiB9KSk7XG4gICAgICB9XG4gICAgfSksIHI7XG4gIH1cbn1cbmNvbnN0IEJWID0gKHQpID0+IChlKSA9PiB7XG4gIGxldCB7IHN0YXRlOiBuLCBwb3M6IHIgfSA9IGUsIGkgPSB1bihuKS5yZXNvbHZlSW5uZXIociwgLTEpLCBzID0gaS50eXBlLmlzRXJyb3IgJiYgaS5mcm9tID09IGkudG8gLSAxICYmIG4uZG9jLnNsaWNlU3RyaW5nKGkuZnJvbSwgaS50bykgPT0gXCItXCI7XG4gIGlmIChpLm5hbWUgPT0gXCJQcm9wZXJ0eU5hbWVcIiB8fCAocyB8fCBpLm5hbWUgPT0gXCJUYWdOYW1lXCIpICYmIC9eKEJsb2NrfFN0eWxlcykkLy50ZXN0KGkucmVzb2x2ZShpLnRvKS5uYW1lKSlcbiAgICByZXR1cm4geyBmcm9tOiBpLmZyb20sIG9wdGlvbnM6IFVmKCksIHZhbGlkRm9yOiB4aSB9O1xuICBpZiAoaS5uYW1lID09IFwiVmFsdWVOYW1lXCIpXG4gICAgcmV0dXJuIHsgZnJvbTogaS5mcm9tLCBvcHRpb25zOiBkMCwgdmFsaWRGb3I6IHhpIH07XG4gIGlmIChpLm5hbWUgPT0gXCJQc2V1ZG9DbGFzc05hbWVcIilcbiAgICByZXR1cm4geyBmcm9tOiBpLmZyb20sIG9wdGlvbnM6IHUwLCB2YWxpZEZvcjogeGkgfTtcbiAgaWYgKHQoaSkgfHwgKGUuZXhwbGljaXQgfHwgcykgJiYgTVYoaSwgbi5kb2MpKVxuICAgIHJldHVybiB7XG4gICAgICBmcm9tOiB0KGkpIHx8IHMgPyBpLmZyb20gOiByLFxuICAgICAgb3B0aW9uczogVngobi5kb2MsIGpWKGkpLCB0KSxcbiAgICAgIHZhbGlkRm9yOiBXVlxuICAgIH07XG4gIGlmIChpLm5hbWUgPT0gXCJUYWdOYW1lXCIpIHtcbiAgICBmb3IgKGxldCB7IHBhcmVudDogbCB9ID0gaTsgbDsgbCA9IGwucGFyZW50KVxuICAgICAgaWYgKGwubmFtZSA9PSBcIkJsb2NrXCIpXG4gICAgICAgIHJldHVybiB7IGZyb206IGkuZnJvbSwgb3B0aW9uczogVWYoKSwgdmFsaWRGb3I6IHhpIH07XG4gICAgcmV0dXJuIHsgZnJvbTogaS5mcm9tLCBvcHRpb25zOiBJViwgdmFsaWRGb3I6IHhpIH07XG4gIH1cbiAgaWYgKCFlLmV4cGxpY2l0KVxuICAgIHJldHVybiBudWxsO1xuICBsZXQgbyA9IGkucmVzb2x2ZShyKSwgYSA9IG8uY2hpbGRCZWZvcmUocik7XG4gIHJldHVybiBhICYmIGEubmFtZSA9PSBcIjpcIiAmJiBvLm5hbWUgPT0gXCJQc2V1ZG9DbGFzc1NlbGVjdG9yXCIgPyB7IGZyb206IHIsIG9wdGlvbnM6IHUwLCB2YWxpZEZvcjogeGkgfSA6IGEgJiYgYS5uYW1lID09IFwiOlwiICYmIG8ubmFtZSA9PSBcIkRlY2xhcmF0aW9uXCIgfHwgby5uYW1lID09IFwiQXJnTGlzdFwiID8geyBmcm9tOiByLCBvcHRpb25zOiBkMCwgdmFsaWRGb3I6IHhpIH0gOiBvLm5hbWUgPT0gXCJCbG9ja1wiIHx8IG8ubmFtZSA9PSBcIlN0eWxlc1wiID8geyBmcm9tOiByLCBvcHRpb25zOiBVZigpLCB2YWxpZEZvcjogeGkgfSA6IG51bGw7XG59LCBMViA9IC8qIEBfX1BVUkVfXyAqLyBCVigodCkgPT4gdC5uYW1lID09IFwiVmFyaWFibGVOYW1lXCIpLCBGdSA9IC8qIEBfX1BVUkVfXyAqLyBjcy5kZWZpbmUoe1xuICBuYW1lOiBcImNzc1wiLFxuICBwYXJzZXI6IC8qIEBfX1BVUkVfXyAqLyBWVi5jb25maWd1cmUoe1xuICAgIHByb3BzOiBbXG4gICAgICAvKiBAX19QVVJFX18gKi8gc2EuYWRkKHtcbiAgICAgICAgRGVjbGFyYXRpb246IC8qIEBfX1BVUkVfXyAqLyAkbygpXG4gICAgICB9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBLbC5hZGQoe1xuICAgICAgICBcIkJsb2NrIEtleWZyYW1lTGlzdFwiOiBIZFxuICAgICAgfSlcbiAgICBdXG4gIH0pLFxuICBsYW5ndWFnZURhdGE6IHtcbiAgICBjb21tZW50VG9rZW5zOiB7IGJsb2NrOiB7IG9wZW46IFwiLypcIiwgY2xvc2U6IFwiKi9cIiB9IH0sXG4gICAgaW5kZW50T25JbnB1dDogL15cXHMqXFx9JC8sXG4gICAgd29yZENoYXJzOiBcIi1cIlxuICB9XG59KTtcbmZ1bmN0aW9uIEl4KCkge1xuICByZXR1cm4gbmV3IEdsKEZ1LCBGdS5kYXRhLm9mKHsgYXV0b2NvbXBsZXRlOiBMViB9KSk7XG59XG5jb25zdCBVViA9IDU0LCBxViA9IDEsIFlWID0gNTUsIHpWID0gMiwgSFYgPSA1NiwgRlYgPSAzLCBoMCA9IDQsIEdWID0gNSwgR3UgPSA2LCBXeCA9IDcsIE14ID0gOCwgWHggPSA5LCBqeCA9IDEwLCBLViA9IDExLCBKViA9IDEyLCBlMyA9IDEzLCBxZiA9IDU3LCB0MyA9IDE0LCBwMCA9IDU4LCBCeCA9IDIwLCBuMyA9IDIyLCBMeCA9IDIzLCByMyA9IDI0LCAkcCA9IDI2LCBVeCA9IDI3LCBpMyA9IDI4LCBzMyA9IDMxLCBvMyA9IDM0LCBhMyA9IDM2LCBsMyA9IDM3LCBjMyA9IDAsIHUzID0gMSwgZDMgPSB7XG4gIGFyZWE6ICEwLFxuICBiYXNlOiAhMCxcbiAgYnI6ICEwLFxuICBjb2w6ICEwLFxuICBjb21tYW5kOiAhMCxcbiAgZW1iZWQ6ICEwLFxuICBmcmFtZTogITAsXG4gIGhyOiAhMCxcbiAgaW1nOiAhMCxcbiAgaW5wdXQ6ICEwLFxuICBrZXlnZW46ICEwLFxuICBsaW5rOiAhMCxcbiAgbWV0YTogITAsXG4gIHBhcmFtOiAhMCxcbiAgc291cmNlOiAhMCxcbiAgdHJhY2s6ICEwLFxuICB3YnI6ICEwLFxuICBtZW51aXRlbTogITBcbn0sIGYzID0ge1xuICBkZDogITAsXG4gIGxpOiAhMCxcbiAgb3B0Z3JvdXA6ICEwLFxuICBvcHRpb246ICEwLFxuICBwOiAhMCxcbiAgcnA6ICEwLFxuICBydDogITAsXG4gIHRib2R5OiAhMCxcbiAgdGQ6ICEwLFxuICB0Zm9vdDogITAsXG4gIHRoOiAhMCxcbiAgdHI6ICEwXG59LCBPMCA9IHtcbiAgZGQ6IHsgZGQ6ICEwLCBkdDogITAgfSxcbiAgZHQ6IHsgZGQ6ICEwLCBkdDogITAgfSxcbiAgbGk6IHsgbGk6ICEwIH0sXG4gIG9wdGlvbjogeyBvcHRpb246ICEwLCBvcHRncm91cDogITAgfSxcbiAgb3B0Z3JvdXA6IHsgb3B0Z3JvdXA6ICEwIH0sXG4gIHA6IHtcbiAgICBhZGRyZXNzOiAhMCxcbiAgICBhcnRpY2xlOiAhMCxcbiAgICBhc2lkZTogITAsXG4gICAgYmxvY2txdW90ZTogITAsXG4gICAgZGlyOiAhMCxcbiAgICBkaXY6ICEwLFxuICAgIGRsOiAhMCxcbiAgICBmaWVsZHNldDogITAsXG4gICAgZm9vdGVyOiAhMCxcbiAgICBmb3JtOiAhMCxcbiAgICBoMTogITAsXG4gICAgaDI6ICEwLFxuICAgIGgzOiAhMCxcbiAgICBoNDogITAsXG4gICAgaDU6ICEwLFxuICAgIGg2OiAhMCxcbiAgICBoZWFkZXI6ICEwLFxuICAgIGhncm91cDogITAsXG4gICAgaHI6ICEwLFxuICAgIG1lbnU6ICEwLFxuICAgIG5hdjogITAsXG4gICAgb2w6ICEwLFxuICAgIHA6ICEwLFxuICAgIHByZTogITAsXG4gICAgc2VjdGlvbjogITAsXG4gICAgdGFibGU6ICEwLFxuICAgIHVsOiAhMFxuICB9LFxuICBycDogeyBycDogITAsIHJ0OiAhMCB9LFxuICBydDogeyBycDogITAsIHJ0OiAhMCB9LFxuICB0Ym9keTogeyB0Ym9keTogITAsIHRmb290OiAhMCB9LFxuICB0ZDogeyB0ZDogITAsIHRoOiAhMCB9LFxuICB0Zm9vdDogeyB0Ym9keTogITAgfSxcbiAgdGg6IHsgdGQ6ICEwLCB0aDogITAgfSxcbiAgdGhlYWQ6IHsgdGJvZHk6ICEwLCB0Zm9vdDogITAgfSxcbiAgdHI6IHsgdHI6ICEwIH1cbn07XG5mdW5jdGlvbiBoMyh0KSB7XG4gIHJldHVybiB0ID09IDQ1IHx8IHQgPT0gNDYgfHwgdCA9PSA1OCB8fCB0ID49IDY1ICYmIHQgPD0gOTAgfHwgdCA9PSA5NSB8fCB0ID49IDk3ICYmIHQgPD0gMTIyIHx8IHQgPj0gMTYxO1xufVxuZnVuY3Rpb24gcXgodCkge1xuICByZXR1cm4gdCA9PSA5IHx8IHQgPT0gMTAgfHwgdCA9PSAxMyB8fCB0ID09IDMyO1xufVxubGV0IGcwID0gbnVsbCwgbTAgPSBudWxsLCBiMCA9IDA7XG5mdW5jdGlvbiBRcCh0LCBlKSB7XG4gIGxldCBuID0gdC5wb3MgKyBlO1xuICBpZiAoYjAgPT0gbiAmJiBtMCA9PSB0KVxuICAgIHJldHVybiBnMDtcbiAgbGV0IHIgPSB0LnBlZWsoZSk7XG4gIGZvciAoOyBxeChyKTsgKVxuICAgIHIgPSB0LnBlZWsoKytlKTtcbiAgbGV0IGkgPSBcIlwiO1xuICBmb3IgKDsgaDMocik7IClcbiAgICBpICs9IFN0cmluZy5mcm9tQ2hhckNvZGUociksIHIgPSB0LnBlZWsoKytlKTtcbiAgcmV0dXJuIG0wID0gdCwgYjAgPSBuLCBnMCA9IGkgPyBpLnRvTG93ZXJDYXNlKCkgOiByID09IHAzIHx8IHIgPT0gTzMgPyB2b2lkIDAgOiBudWxsO1xufVxuY29uc3QgWXggPSA2MCwgS3UgPSA2Miwga2cgPSA0NywgcDMgPSA2MywgTzMgPSAzMywgZzMgPSA0NTtcbmZ1bmN0aW9uIHYwKHQsIGUpIHtcbiAgdGhpcy5uYW1lID0gdCwgdGhpcy5wYXJlbnQgPSBlLCB0aGlzLmhhc2ggPSBlID8gZS5oYXNoIDogMDtcbiAgZm9yIChsZXQgbiA9IDA7IG4gPCB0Lmxlbmd0aDsgbisrKVxuICAgIHRoaXMuaGFzaCArPSAodGhpcy5oYXNoIDw8IDQpICsgdC5jaGFyQ29kZUF0KG4pICsgKHQuY2hhckNvZGVBdChuKSA8PCA4KTtcbn1cbmNvbnN0IG0zID0gW0d1LCBqeCwgV3gsIE14LCBYeF0sIGIzID0gbmV3IHdnKHtcbiAgc3RhcnQ6IG51bGwsXG4gIHNoaWZ0KHQsIGUsIG4sIHIpIHtcbiAgICByZXR1cm4gbTMuaW5kZXhPZihlKSA+IC0xID8gbmV3IHYwKFFwKHIsIDEpIHx8IFwiXCIsIHQpIDogdDtcbiAgfSxcbiAgcmVkdWNlKHQsIGUpIHtcbiAgICByZXR1cm4gZSA9PSBCeCAmJiB0ID8gdC5wYXJlbnQgOiB0O1xuICB9LFxuICByZXVzZSh0LCBlLCBuLCByKSB7XG4gICAgbGV0IGkgPSBlLnR5cGUuaWQ7XG4gICAgcmV0dXJuIGkgPT0gR3UgfHwgaSA9PSBhMyA/IG5ldyB2MChRcChyLCAxKSB8fCBcIlwiLCB0KSA6IHQ7XG4gIH0sXG4gIGhhc2godCkge1xuICAgIHJldHVybiB0ID8gdC5oYXNoIDogMDtcbiAgfSxcbiAgc3RyaWN0OiAhMVxufSksIHYzID0gbmV3IGduKCh0LCBlKSA9PiB7XG4gIGlmICh0Lm5leHQgIT0gWXgpIHtcbiAgICB0Lm5leHQgPCAwICYmIGUuY29udGV4dCAmJiB0LmFjY2VwdFRva2VuKHFmKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdC5hZHZhbmNlKCk7XG4gIGxldCBuID0gdC5uZXh0ID09IGtnO1xuICBuICYmIHQuYWR2YW5jZSgpO1xuICBsZXQgciA9IFFwKHQsIDApO1xuICBpZiAociA9PT0gdm9pZCAwKVxuICAgIHJldHVybjtcbiAgaWYgKCFyKVxuICAgIHJldHVybiB0LmFjY2VwdFRva2VuKG4gPyB0MyA6IEd1KTtcbiAgbGV0IGkgPSBlLmNvbnRleHQgPyBlLmNvbnRleHQubmFtZSA6IG51bGw7XG4gIGlmIChuKSB7XG4gICAgaWYgKHIgPT0gaSlcbiAgICAgIHJldHVybiB0LmFjY2VwdFRva2VuKEtWKTtcbiAgICBpZiAoaSAmJiBmM1tpXSlcbiAgICAgIHJldHVybiB0LmFjY2VwdFRva2VuKHFmLCAtMik7XG4gICAgaWYgKGUuZGlhbGVjdEVuYWJsZWQoYzMpKVxuICAgICAgcmV0dXJuIHQuYWNjZXB0VG9rZW4oSlYpO1xuICAgIGZvciAobGV0IHMgPSBlLmNvbnRleHQ7IHM7IHMgPSBzLnBhcmVudClcbiAgICAgIGlmIChzLm5hbWUgPT0gcilcbiAgICAgICAgcmV0dXJuO1xuICAgIHQuYWNjZXB0VG9rZW4oZTMpO1xuICB9IGVsc2Uge1xuICAgIGlmIChyID09IFwic2NyaXB0XCIpXG4gICAgICByZXR1cm4gdC5hY2NlcHRUb2tlbihXeCk7XG4gICAgaWYgKHIgPT0gXCJzdHlsZVwiKVxuICAgICAgcmV0dXJuIHQuYWNjZXB0VG9rZW4oTXgpO1xuICAgIGlmIChyID09IFwidGV4dGFyZWFcIilcbiAgICAgIHJldHVybiB0LmFjY2VwdFRva2VuKFh4KTtcbiAgICBpZiAoZDMuaGFzT3duUHJvcGVydHkocikpXG4gICAgICByZXR1cm4gdC5hY2NlcHRUb2tlbihqeCk7XG4gICAgaSAmJiBPMFtpXSAmJiBPMFtpXVtyXSA/IHQuYWNjZXB0VG9rZW4ocWYsIC0xKSA6IHQuYWNjZXB0VG9rZW4oR3UpO1xuICB9XG59LCB7IGNvbnRleHR1YWw6ICEwIH0pLCB5MyA9IG5ldyBnbigodCkgPT4ge1xuICBmb3IgKGxldCBlID0gMCwgbiA9IDA7IDsgbisrKSB7XG4gICAgaWYgKHQubmV4dCA8IDApIHtcbiAgICAgIG4gJiYgdC5hY2NlcHRUb2tlbihwMCk7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKHQubmV4dCA9PSBnMylcbiAgICAgIGUrKztcbiAgICBlbHNlIGlmICh0Lm5leHQgPT0gS3UgJiYgZSA+PSAyKSB7XG4gICAgICBuID49IDMgJiYgdC5hY2NlcHRUb2tlbihwMCwgLTIpO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlXG4gICAgICBlID0gMDtcbiAgICB0LmFkdmFuY2UoKTtcbiAgfVxufSk7XG5mdW5jdGlvbiBTMyh0KSB7XG4gIGZvciAoOyB0OyB0ID0gdC5wYXJlbnQpXG4gICAgaWYgKHQubmFtZSA9PSBcInN2Z1wiIHx8IHQubmFtZSA9PSBcIm1hdGhcIilcbiAgICAgIHJldHVybiAhMDtcbiAgcmV0dXJuICExO1xufVxuY29uc3QgdzMgPSBuZXcgZ24oKHQsIGUpID0+IHtcbiAgaWYgKHQubmV4dCA9PSBrZyAmJiB0LnBlZWsoMSkgPT0gS3UpIHtcbiAgICBsZXQgbiA9IGUuZGlhbGVjdEVuYWJsZWQodTMpIHx8IFMzKGUuY29udGV4dCk7XG4gICAgdC5hY2NlcHRUb2tlbihuID8gR1YgOiBoMCwgMik7XG4gIH0gZWxzZVxuICAgIHQubmV4dCA9PSBLdSAmJiB0LmFjY2VwdFRva2VuKGgwLCAxKTtcbn0pO1xuZnVuY3Rpb24geGcodCwgZSwgbikge1xuICBsZXQgciA9IDIgKyB0Lmxlbmd0aDtcbiAgcmV0dXJuIG5ldyBnbigoaSkgPT4ge1xuICAgIGZvciAobGV0IHMgPSAwLCBvID0gMCwgYSA9IDA7IDsgYSsrKSB7XG4gICAgICBpZiAoaS5uZXh0IDwgMCkge1xuICAgICAgICBhICYmIGkuYWNjZXB0VG9rZW4oZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHMgPT0gMCAmJiBpLm5leHQgPT0gWXggfHwgcyA9PSAxICYmIGkubmV4dCA9PSBrZyB8fCBzID49IDIgJiYgcyA8IHIgJiYgaS5uZXh0ID09IHQuY2hhckNvZGVBdChzIC0gMikpXG4gICAgICAgIHMrKywgbysrO1xuICAgICAgZWxzZSBpZiAoKHMgPT0gMiB8fCBzID09IHIpICYmIHF4KGkubmV4dCkpXG4gICAgICAgIG8rKztcbiAgICAgIGVsc2UgaWYgKHMgPT0gciAmJiBpLm5leHQgPT0gS3UpIHtcbiAgICAgICAgYSA+IG8gPyBpLmFjY2VwdFRva2VuKGUsIC1vKSA6IGkuYWNjZXB0VG9rZW4obiwgLShvIC0gMikpO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoKGkubmV4dCA9PSAxMCB8fCBpLm5leHQgPT0gMTMpICYmIGEpIHtcbiAgICAgICAgaS5hY2NlcHRUb2tlbihlLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2VcbiAgICAgICAgcyA9IG8gPSAwO1xuICAgICAgaS5hZHZhbmNlKCk7XG4gICAgfVxuICB9KTtcbn1cbmNvbnN0IGszID0geGcoXCJzY3JpcHRcIiwgVVYsIHFWKSwgeDMgPSB4ZyhcInN0eWxlXCIsIFlWLCB6ViksIFAzID0geGcoXCJ0ZXh0YXJlYVwiLCBIViwgRlYpLCBfMyA9IGlhKHtcbiAgXCJUZXh0IFJhd1RleHRcIjogUC5jb250ZW50LFxuICBcIlN0YXJ0VGFnIFN0YXJ0Q2xvc2VUYWcgU2VsZkNsb3NpbmdFbmRUYWcgRW5kVGFnXCI6IFAuYW5nbGVCcmFja2V0LFxuICBUYWdOYW1lOiBQLnRhZ05hbWUsXG4gIFwiTWlzbWF0Y2hlZENsb3NlVGFnL1RhZ05hbWVcIjogW1AudGFnTmFtZSwgUC5pbnZhbGlkXSxcbiAgQXR0cmlidXRlTmFtZTogUC5hdHRyaWJ1dGVOYW1lLFxuICBcIkF0dHJpYnV0ZVZhbHVlIFVucXVvdGVkQXR0cmlidXRlVmFsdWVcIjogUC5hdHRyaWJ1dGVWYWx1ZSxcbiAgSXM6IFAuZGVmaW5pdGlvbk9wZXJhdG9yLFxuICBcIkVudGl0eVJlZmVyZW5jZSBDaGFyYWN0ZXJSZWZlcmVuY2VcIjogUC5jaGFyYWN0ZXIsXG4gIENvbW1lbnQ6IFAuYmxvY2tDb21tZW50LFxuICBQcm9jZXNzaW5nSW5zdDogUC5wcm9jZXNzaW5nSW5zdHJ1Y3Rpb24sXG4gIERvY3R5cGVEZWNsOiBQLmRvY3VtZW50TWV0YVxufSksIFQzID0gdXMuZGVzZXJpYWxpemUoe1xuICB2ZXJzaW9uOiAxNCxcbiAgc3RhdGVzOiBcIix4T1ZPIXJPT08hV1EjdE8nI0NxTyFdUSN0TycjQ3pPIWJRI3RPJyNDfU8hZ1EjdE8nI0RRTyFsUSN0TycjRFNPIXFPYU8nI0NwTyF8T2JPJyNDcE8jWE9kTycjQ3BPJGVPIXJPJyNDcE9PT2AnI0NwJyNDcE8kbE8kZk8nI0RUTyR0USN0TycjRFZPJHlRI3RPJyNEV09PT2AnI0RrJyNEa09PT2AnI0RZJyNEWVFWTyFyT09PJU9RJnJPLDU5XU8lWlEmck8sNTlmTyVmUSZyTyw1OWlPJXFRJnJPLDU5bE8lfFEmck8sNTluT09PYScjRF4nI0ReTyZYT2FPJyNDeE8mZE9hTyw1OVtPT09iJyNEXycjRF9PJmxPYk8nI0N7TyZ3T2JPLDU5W09PT2QnI0RgJyNEYE8nUE9kTycjRE9PJ1tPZE8sNTlbT09PYCcjRGEnI0RhTydkTyFyTyw1OVtPJ2tRI3RPJyNEUk9PT2AsNTlbLDU5W09PT3AnI0RiJyNEYk8ncE8kZk8sNTlvT09PYCw1OW8sNTlvTyd4USN8Tyw1OXFPJ31RI3xPLDU5ck9PT2AtRTdXLUU3V08oU1Emck8nI0NzT09RVycjRFonI0RaTyhiUSZyTzFHLndPT09hMUcudzFHLndPT09gMUcvWTFHL1lPKG1RJnJPMUcvUU9PT2IxRy9RMUcvUU8oeFEmck8xRy9UT09PZDFHL1QxRy9UTylUUSZyTzFHL1dPT09gMUcvVzFHL1dPKWBRJnJPMUcvWU9PT2EtRTdbLUU3W08pa1EjdE8nI0N5T09PYDFHLnYxRy52T09PYi1FN10tRTddTylwUSN0TycjQ3xPT09kLUU3Xi1FN15PKXVRI3RPJyNEUE9PT2AtRTdfLUU3X08pelEjfE8sNTltT09PcC1FN2AtRTdgT09PYDFHL1oxRy9aT09PYDFHL10xRy9dT09PYDFHL14xRy9eTypQUSxVTyw1OV9PT1FXLUU3WC1FN1hPT09hNyskYzcrJGNPT09gNyskdDcrJHRPT09iNyskbDcrJGxPT09kNyskbzcrJG9PT09gNyskcjcrJHJPKltRI3xPLDU5ZU8qYVEjfE8sNTloTypmUSN8Tyw1OWtPT09gMUcvWDFHL1hPKmtPN1tPJyNDdk8qfE9NaE8nI0N2T09RVzFHLnkxRy55T09PYDFHL1AxRy9QT09PYDFHL1MxRy9TT09PYDFHL1YxRy9WT09PTycjRFsnI0RbTytfTzdbTyw1OWJPT1FXLDU5Yiw1OWJPT09PJyNEXScjRF1PK3BPTWhPLDU5Yk9PT08tRTdZLUU3WU9PUVcxRy58MUcufE9PT08tRTdaLUU3WlwiLFxuICBzdGF0ZURhdGE6IFwiLF1+TyFeT1N+T1VTT1ZQT1dRT1hST1lUT1tdT11bT15eT2BeT2FeT2JeT2NeT3heT3tfTyFkWk9+T2ZhT35PZmJPfk9mY09+T2ZkT35PZmVPfk8hV2ZPUGxQIVpsUH5PIVhpT1FvUCFab1B+TyFZbE9SclAhWnJQfk9VU09WUE9XUU9YUk9ZVE9acU9bXU9dW09eXk9gXk9hXk9iXk9jXk94Xk8hZFpPfk8hWnJPflAjZE8hW3NPIWV1T35PZnZPfk9md09+T1N8T1R9T2h5T35PUyFQT1R9T2h5T35PUyFST1R9T2h5T35PUyFUT1R9T2h5T35PU31PVH1PaHlPfk8hV2ZPUGxYIVpsWH5PUCFXTyFaIVhPfk8hWGlPUW9YIVpvWH5PUSFaTyFaIVhPfk8hWWxPUnJYIVpyWH5PUiFdTyFaIVhPfk8hWiFYT35QI2RPZiFfT35PIVtzTyFlIWFPfk9TIWJPfk9TIWNPfk9pIWRPU2dYVGdYaGdYfk9TIWZPVCFnT2h5T35PUyFoT1QhZ09oeU9+T1MhaU9UIWdPaHlPfk9TIWpPVCFnT2h5T35PUyFnT1QhZ09oeU9+T2Yha09+T2YhbE9+T2YhbU9+T1Mhbk9+T2shcU8hYCFvTyFiIXBPfk9TIXJPfk9TIXNPfk9TIXRPfk9hIXVPYiF1T2MhdU8hYCF3TyFhIXVPfk9hIXhPYiF4T2MheE8hYiF3TyFjIXhPfk9hIXVPYiF1T2MhdU8hYCF7TyFhIXVPfk9hIXhPYiF4T2MheE8hYiF7TyFjIXhPfk9UfmJhYyFkeHshZH5cIixcbiAgZ290bzogXCIlcCFgUFBQUFBQUFBQUFBQUFBQUFBQUFAhYSFnUCFtUFAheVAhfCNQI1MjWSNdI2AjZiNpI2wjciN4IWFQIWEhYVAkTyRVJGwkciR4JU8lVSVbJWJQUFBQUFBQUCVoWF5PWGBwWFVPWGBwZXphYmNkZXshTyFRIVMhVVIhcSFkUmhVUiFYaFhWT1hgcFJrVlIhWGtYV09YYHBSbldSIVhuWFhPWGBwUXJYUiFYcFhZT1hgcFFgT1J4YFF7YVEhT2JRIVFjUSFTZFEhVWVaIWV7IU8hUSFTIVVRIXYhb1IheiF2USF5IXBSIXwheVFnVVIhVmdRalZSIVlqUW1XUiFbbVFwWFIhXnBRdFpSIWB0U19PYFRvWHBcIixcbiAgbm9kZU5hbWVzOiBcIuKaoCBTdGFydENsb3NlVGFnIFN0YXJ0Q2xvc2VUYWcgU3RhcnRDbG9zZVRhZyBFbmRUYWcgU2VsZkNsb3NpbmdFbmRUYWcgU3RhcnRUYWcgU3RhcnRUYWcgU3RhcnRUYWcgU3RhcnRUYWcgU3RhcnRUYWcgU3RhcnRDbG9zZVRhZyBTdGFydENsb3NlVGFnIFN0YXJ0Q2xvc2VUYWcgSW5jb21wbGV0ZUNsb3NlVGFnIERvY3VtZW50IFRleHQgRW50aXR5UmVmZXJlbmNlIENoYXJhY3RlclJlZmVyZW5jZSBJbnZhbGlkRW50aXR5IEVsZW1lbnQgT3BlblRhZyBUYWdOYW1lIEF0dHJpYnV0ZSBBdHRyaWJ1dGVOYW1lIElzIEF0dHJpYnV0ZVZhbHVlIFVucXVvdGVkQXR0cmlidXRlVmFsdWUgU2NyaXB0VGV4dCBDbG9zZVRhZyBPcGVuVGFnIFN0eWxlVGV4dCBDbG9zZVRhZyBPcGVuVGFnIFRleHRhcmVhVGV4dCBDbG9zZVRhZyBPcGVuVGFnIENsb3NlVGFnIFNlbGZDbG9zaW5nVGFnIENvbW1lbnQgUHJvY2Vzc2luZ0luc3QgTWlzbWF0Y2hlZENsb3NlVGFnIENsb3NlVGFnIERvY3R5cGVEZWNsXCIsXG4gIG1heFRlcm06IDY3LFxuICBjb250ZXh0OiBiMyxcbiAgbm9kZVByb3BzOiBbXG4gICAgW1wiY2xvc2VkQnlcIiwgLTEwLCAxLCAyLCAzLCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgXCJFbmRUYWdcIiwgNiwgXCJFbmRUYWcgU2VsZkNsb3NpbmdFbmRUYWdcIiwgLTQsIDIxLCAzMCwgMzMsIDM2LCBcIkNsb3NlVGFnXCJdLFxuICAgIFtcIm9wZW5lZEJ5XCIsIDQsIFwiU3RhcnRUYWcgU3RhcnRDbG9zZVRhZ1wiLCA1LCBcIlN0YXJ0VGFnXCIsIC00LCAyOSwgMzIsIDM1LCAzNywgXCJPcGVuVGFnXCJdLFxuICAgIFtcImdyb3VwXCIsIC05LCAxNCwgMTcsIDE4LCAxOSwgMjAsIDM5LCA0MCwgNDEsIDQyLCBcIkVudGl0eVwiLCAxNiwgXCJFbnRpdHkgVGV4dENvbnRlbnRcIiwgLTMsIDI4LCAzMSwgMzQsIFwiVGV4dENvbnRlbnQgRW50aXR5XCJdLFxuICAgIFtcImlzb2xhdGVcIiwgLTExLCAyMSwgMjksIDMwLCAzMiwgMzMsIDM1LCAzNiwgMzcsIDM4LCA0MSwgNDIsIFwibHRyXCIsIC0zLCAyNiwgMjcsIDM5LCBcIlwiXVxuICBdLFxuICBwcm9wU291cmNlczogW18zXSxcbiAgc2tpcHBlZE5vZGVzOiBbMF0sXG4gIHJlcGVhdE5vZGVDb3VudDogOSxcbiAgdG9rZW5EYXRhOiBcIiE8cCFhUiFZT1gkcVhZLFFZWixRWlskcVtdJlhdXixRXnAkcXBxLFFxci1fcnMzX3N2LV92dzN9d3hIWXh9LV99IU9IeyFPIVAtXyFQIVEkcSFRIVstXyFbIV1NeiFdIV4tXyFeIV8hJFMhXyFgITt4IWAhYSZYIWEhYy1fIWMhfU16IX0jUi1fI1IjU016I1MjVDFrI1Qjb016I28jcy1fI3MkZiRxJGYlVy1fJVclb016JW8lcC1fJXAmYU16JmEmYi1fJmIxcE16MXA0VS1fNFU0ZE16NGQ0ZS1fNGUkSVNNeiRJUyRJYC1fJElgJEliTXokSWIkS2gtXyRLaCUjdE16JSN0Ji94LV8mL3gmRXRNeiZFdCZGVi1fJkZWOydTTXo7J1M7OmohI3w7Omo7PWAzWDwlbD8mci1fPyZyP0FoTXo/QWg/QlkkcT9CWT9Nbk16P01uTyRxIVokfGNgUGtXIWFgIWNwT1gkcVhaJlhaWyRxW14mWF5wJHFwcSZYcXIkcXJzJn1zdiRxdncrUHd4KHR4IV4kcSFeIV8qViFfIWEmWCFhI1MkcSNTI1QmWCNUOydTJHE7J1M7PWArejwlbE8kcSFSJmJYYFAhYWAhY3BPciZYcnMmfXN2Jlh3eCh0eCFeJlghXiFfKlYhXzsnUyZYOydTOz1gKnk8JWxPJlhxJ1VWYFAhY3BPdiZ9d3gna3ghXiZ9IV4hXyhWIV87J1MmfTsnUzs9YChuPCVsTyZ9UCdwVGBQT3Yna3chXidrIV87J1MnazsnUzs9YChQPCVsTydrUChTUDs9YDwlbCdrcChbUyFjcE92KFZ4OydTKFY7J1M7PWAoaDwlbE8oVnAoa1A7PWA8JWwoVnEocVA7PWA8JWwmfWEoe1dgUCFhYE9yKHRycydrc3YodHchXih0IV4hXyllIV87J1ModDsnUzs9YCpQPCVsTyh0YClqVCFhYE9yKWVzdilldzsnUyllOydTOz1gKXk8JWxPKWVgKXxQOz1gPCVsKWVhKlNQOz1gPCVsKHQhUSpeViFhYCFjcE9yKlZycyhWc3YqVnd4KWV4OydTKlY7J1M7PWAqczwlbE8qViFRKnZQOz1gPCVsKlYhUip8UDs9YDwlbCZYVytVWWtXT1grUFpbK1BecCtQcXIrUHN3K1B4IV4rUCFhI1MrUCNUOydTK1A7J1M7PWArdDwlbE8rUFcrd1A7PWA8JWwrUCFaK31QOz1gPCVsJHEhYSxdYGBQIWFgIWNwIV5eT1gmWFhZLFFZWixRWl0mWF1eLFFecCZYcHEsUXFyJlhycyZ9c3YmWHd4KHR4IV4mWCFeIV8qViFfOydTJlg7J1M7PWAqeTwlbE8mWCFfLWxqaFNgUGtXIWFgIWNwT1gkcVhaJlhaWyRxW14mWF5wJHFwcSZYcXItX3JzJn1zdi1fdncvXnd4KHR4IVAtXyFQIVEkcSFRIV4tXyFeIV8qViFfIWEmWCFhI1MtXyNTI1QxayNUI3MtXyNzJGYkcSRmOydTLV87J1M7PWAzWDwlbD9BaC1fP0FoP0JZJHE/Qlk/TW4tXz9Nbk8kcVsvZWJoU2tXT1grUFpbK1BecCtQcXIvXnN3L154IVAvXiFQIVErUCFRIV4vXiFhI1MvXiNTI1QwbSNUI3MvXiNzJGYrUCRmOydTL147J1M7PWAxZTwlbD9BaC9eP0FoP0JZK1A/Qlk/TW4vXj9Nbk8rUFMwclhoU3FyMG1zdzBteCFQMG0hUSFeMG0hYSNzMG0kZjsnUzBtOydTOz1gMV88JWw/QWgwbT9CWT9NbjBtUzFiUDs9YDwlbDBtWzFoUDs9YDwlbC9eIVYxdmNoU2BQIWFgIWNwT3EmWHFyMWtycyZ9c3Yxa3Z3MG13eCh0eCFQMWshUCFRJlghUSFeMWshXiFfKlYhXyFhJlghYSNzMWsjcyRmJlgkZjsnUzFrOydTOz1gM1I8JWw/QWgxaz9BaD9CWSZYP0JZP01uMWs/TW5PJlghVjNVUDs9YDwlbDFrIV8zW1A7PWA8JWwtXyFaM2hWIWBoYFAhY3BPdiZ9d3gna3ghXiZ9IV4hXyhWIV87J1MmfTsnUzs9YChuPCVsTyZ9IV80V2loU2tXYyFST1g1dVhaN1NaWzV1W143U15wNXVxcjh0cnM3U3N0Pl10dzh0d3g3U3ghUDh0IVAhUTV1IVEhXTh0IV0hXi9eIV4hYTdTIWEjUzh0I1MjVDt7I1Qjczh0I3MkZjV1JGY7J1M4dDsnUzs9YD5WPCVsP0FoOHQ/QWg/Qlk1dT9CWT9Nbjh0P01uTzV1IVo1emJrV09YNXVYWjdTWls1dVteN1NecDV1cXI1dXJzN1NzdCtQdHc1dXd4N1N4IV01dSFdIV43dyFeIWE3UyFhI1M1dSNTI1Q3UyNUOydTNXU7J1M7PWA4bjwlbE81dSFSN1ZWT3A3U3FzN1N0IV03UyFdIV43bCFeOydTN1M7J1M7PWA3cTwlbE83UyFSN3FPYSFSIVI3dFA7PWA8JWw3UyFaOE9Za1dhIVJPWCtQWlsrUF5wK1BxcitQc3crUHghXitQIWEjUytQI1Q7J1MrUDsnUzs9YCt0PCVsTytQIVo4cVA7PWA8JWw1dSFfOHtpaFNrV09YNXVYWjdTWls1dVteN1NecDV1cXI4dHJzN1NzdC9edHc4dHd4N1N4IVA4dCFQIVE1dSFRIV04dCFdIV46aiFeIWE3UyFhI1M4dCNTI1Q7eyNUI3M4dCNzJGY1dSRmOydTOHQ7J1M7PWA+VjwlbD9BaDh0P0FoP0JZNXU/Qlk/TW44dD9Nbk81dSFfOnNiaFNrV2EhUk9YK1BaWytQXnArUHFyL15zdy9eeCFQL14hUCFRK1AhUSFeL14hYSNTL14jUyNUMG0jVCNzL14jcyRmK1AkZjsnUy9eOydTOz1gMWU8JWw/QWgvXj9BaD9CWStQP0JZP01uL14/TW5PK1AhVjxRY2hTT3A3U3FyO3tyczdTc3QwbXR3O3t3eDdTeCFQO3shUCFRN1MhUSFdO3shXSFePV0hXiFhN1MhYSNzO3sjcyRmN1MkZjsnUzt7OydTOz1gPlA8JWw/QWg7ez9BaD9CWTdTP0JZP01uO3s/TW5PN1MhVj1kWGhTYSFScXIwbXN3MG14IVAwbSFRIV4wbSFhI3MwbSRmOydTMG07J1M7PWAxXzwlbD9BaDBtP0JZP01uMG0hVj5TUDs9YDwlbDt7IV8+WVA7PWA8JWw4dCFfPmRoaFNrV09YQE9YWkFZWltAT1teQVlecEBPcXJCd3JzQVlzd0J3d3hBWXghUEJ3IVAhUUBPIVEhXUJ3IV0hXi9eIV4hYUFZIWEjU0J3I1MjVEV7I1Qjc0J3I3MkZkBPJGY7J1NCdzsnUzs9YEhTPCVsP0FoQnc/QWg/QllATz9CWT9NbkJ3P01uT0BPIVpAVGFrV09YQE9YWkFZWltAT1teQVlecEBPcXJAT3JzQVlzd0BPd3hBWXghXUBPIV0hXkF6IV4hYUFZIWEjU0BPI1MjVEFZI1Q7J1NATzsnUzs9YEJxPCVsT0BPIVJBXVVPcEFZcSFdQVkhXSFeQW8hXjsnU0FZOydTOz1gQXQ8JWxPQVkhUkF0T2IhUiFSQXdQOz1gPCVsQVkhWkJSWWtXYiFST1grUFpbK1BecCtQcXIrUHN3K1B4IV4rUCFhI1MrUCNUOydTK1A7J1M7PWArdDwlbE8rUCFaQnRQOz1gPCVsQE8hX0NPaGhTa1dPWEBPWFpBWVpbQE9bXkFZXnBAT3FyQndyc0FZc3dCd3d4QVl4IVBCdyFQIVFATyFRIV1CdyFdIV5EaiFeIWFBWSFhI1NCdyNTI1RFeyNUI3NCdyNzJGZATyRmOydTQnc7J1M7PWBIUzwlbD9BaEJ3P0FoP0JZQE8/Qlk/TW5Cdz9Nbk9ATyFfRHNiaFNrV2IhUk9YK1BaWytQXnArUHFyL15zdy9eeCFQL14hUCFRK1AhUSFeL14hYSNTL14jUyNUMG0jVCNzL14jcyRmK1AkZjsnUy9eOydTOz1gMWU8JWw/QWgvXj9BaD9CWStQP0JZP01uL14/TW5PK1AhVkZRYmhTT3BBWXFyRXtyc0FZc3dFe3d4QVl4IVBFeyFQIVFBWSFRIV1FeyFdIV5HWSFeIWFBWSFhI3NFeyNzJGZBWSRmOydTRXs7J1M7PWBHfDwlbD9BaEV7P0FoP0JZQVk/Qlk/TW5Fez9Nbk9BWSFWR2FYaFNiIVJxcjBtc3cwbXghUDBtIVEhXjBtIWEjczBtJGY7J1MwbTsnUzs9YDFfPCVsP0FoMG0/Qlk/TW4wbSFWSFBQOz1gPCVsRXshX0hWUDs9YDwlbEJ3IVpIY1chYnhgUCFhYE9yKHRycydrc3YodHchXih0IV4hXyllIV87J1ModDsnUzs9YCpQPCVsTyh0IWFJWWxoU2BQa1chYWAhY3BPWCRxWFomWFpbJHFbXiZYXnAkcXBxJlhxci1fcnMmfXN2LV92dy9ed3godHh9LV99IU9LUSFPIVAtXyFQIVEkcSFRIV4tXyFeIV8qViFfIWEmWCFhI1MtXyNTI1QxayNUI3MtXyNzJGYkcSRmOydTLV87J1M7PWAzWDwlbD9BaC1fP0FoP0JZJHE/Qlk/TW4tXz9Nbk8kcSFhS19raFNgUGtXIWFgIWNwT1gkcVhaJlhaWyRxW14mWF5wJHFwcSZYcXItX3JzJn1zdi1fdncvXnd4KHR4IVAtXyFQIVEkcSFRIV4tXyFeIV8qViFfIWAmWCFgIWFNUyFhI1MtXyNTI1QxayNUI3MtXyNzJGYkcSRmOydTLV87J1M7PWAzWDwlbD9BaC1fP0FoP0JZJHE/Qlk/TW4tXz9Nbk8kcSFUTV9YYFAhYWAhY3AhZVFPciZYcnMmfXN2Jlh3eCh0eCFeJlghXiFfKlYhXzsnUyZYOydTOz1gKnk8JWxPJlghYU5aIVpoU2ZRYFBrVyFhYCFjcE9YJHFYWiZYWlskcVteJlhecCRxcHEmWHFyLV9ycyZ9c3YtX3Z3L153eCh0eH0tX30hT016IU8hUE16IVAhUSRxIVEhW016IVshXU16IV0hXi1fIV4hXypWIV8hYSZYIWEhYy1fIWMhfU16IX0jUi1fI1IjU016I1MjVDFrI1Qjb016I28jcy1fI3MkZiRxJGYkfS1fJH0lT016JU8lVy1fJVclb016JW8lcC1fJXAmYU16JmEmYi1fJmIxcE16MXA0VU16NFU0ZE16NGQ0ZS1fNGUkSVNNeiRJUyRJYC1fJElgJEliTXokSWIkSmUtXyRKZSRKZ016JEpnJEtoLV8kS2glI3RNeiUjdCYveC1fJi94JkV0TXomRXQmRlYtXyZGVjsnU016OydTOzpqISN8OzpqOz1gM1g8JWw/JnItXz8mcj9BaE16P0FoP0JZJHE/Qlk/TW5Nej9Nbk8kcSFhISRQUDs9YDwlbE16IVIhJFpZIWFgIWNwT3EqVnFyISR5cnMoVnN2KlZ3eClleCFhKlYhYSFiITR0IWI7J1MqVjsnUzs9YCpzPCVsTypWIVIhJVFdIWFgIWNwT3IqVnJzKFZzdipWd3gpZXh9KlZ9IU8hJXkhTyFmKlYhZiFnISddIWcjVypWI1cjWCEwYCNYOydTKlY7J1M7PWAqczwlbE8qViFSISZRWCFhYCFjcE9yKlZycyhWc3YqVnd4KWV4fSpWfSFPISZtIU87J1MqVjsnUzs9YCpzPCVsTypWIVIhJnZWIWFgIWNwIWRQT3IqVnJzKFZzdipWd3gpZXg7J1MqVjsnUzs9YCpzPCVsTypWIVIhJ2RYIWFgIWNwT3IqVnJzKFZzdipWd3gpZXghcSpWIXEhciEoUCFyOydTKlY7J1M7PWAqczwlbE8qViFSIShXWCFhYCFjcE9yKlZycyhWc3YqVnd4KWV4IWUqViFlIWYhKHMhZjsnUypWOydTOz1gKnM8JWxPKlYhUiEoelghYWAhY3BPcipWcnMoVnN2KlZ3eClleCF2KlYhdiF3ISlnIXc7J1MqVjsnUzs9YCpzPCVsTypWIVIhKW5YIWFgIWNwT3IqVnJzKFZzdipWd3gpZXgheypWIXshfCEqWiF8OydTKlY7J1M7PWAqczwlbE8qViFSISpiWCFhYCFjcE9yKlZycyhWc3YqVnd4KWV4IXIqViFyIXMhKn0hczsnUypWOydTOz1gKnM8JWxPKlYhUiErVVghYWAhY3BPcipWcnMoVnN2KlZ3eClleCFnKlYhZyFoIStxIWg7J1MqVjsnUzs9YCpzPCVsTypWIVIhK3hZIWFgIWNwT3IhK3FycyEsaHN2IStxdnchLVN3eCEuW3ghYCErcSFgIWEhL2ohYTsnUyErcTsnUzs9YCEwWTwlbE8hK3FxISxtViFjcE92ISxodnghLVN4IWAhLGghYCFhIS1xIWE7J1MhLGg7J1M7PWAhLlU8JWxPISxoUCEtVlRPIWAhLVMhYCFhIS1mIWE7J1MhLVM7J1M7PWAhLWs8JWxPIS1TUCEta097UFAhLW5QOz1gPCVsIS1TcSEteFMhY3B7UE92KFZ4OydTKFY7J1M7PWAoaDwlbE8oVnEhLlhQOz1gPCVsISxoYSEuYVghYWBPciEuW3JzIS1Tc3YhLlt2dyEtU3chYCEuWyFgIWEhLnwhYTsnUyEuWzsnUzs9YCEvZDwlbE8hLlthIS9UVCFhYHtQT3IpZXN2KWV3OydTKWU7J1M7PWApeTwlbE8pZWEhL2dQOz1gPCVsIS5bIVIhL3NWIWFgIWNwe1BPcipWcnMoVnN2KlZ3eClleDsnUypWOydTOz1gKnM8JWxPKlYhUiEwXVA7PWA8JWwhK3EhUiEwZ1ghYWAhY3BPcipWcnMoVnN2KlZ3eClleCNjKlYjYyNkITFTI2Q7J1MqVjsnUzs9YCpzPCVsTypWIVIhMVpYIWFgIWNwT3IqVnJzKFZzdipWd3gpZXgjVipWI1YjVyExdiNXOydTKlY7J1M7PWAqczwlbE8qViFSITF9WCFhYCFjcE9yKlZycyhWc3YqVnd4KWV4I2gqViNoI2khMmojaTsnUypWOydTOz1gKnM8JWxPKlYhUiEycVghYWAhY3BPcipWcnMoVnN2KlZ3eClleCNtKlYjbSNuITNeI247J1MqVjsnUzs9YCpzPCVsTypWIVIhM2VYIWFgIWNwT3IqVnJzKFZzdipWd3gpZXgjZCpWI2QjZSE0USNlOydTKlY7J1M7PWAqczwlbE8qViFSITRYWCFhYCFjcE9yKlZycyhWc3YqVnd4KWV4I1gqViNYI1khK3EjWTsnUypWOydTOz1gKnM8JWxPKlYhUiE0e1khYWAhY3BPciE0dHJzITVrc3YhNHR2dyE2Vnd4IThdeCFhITR0IWEhYiE6XSFiOydTITR0OydTOz1gITtyPCVsTyE0dHEhNXBWIWNwT3YhNWt2eCE2VnghYSE1ayFhIWIhN1chYjsnUyE1azsnUzs9YCE4VjwlbE8hNWtQITZZVE8hYSE2ViFhIWIhNmkhYjsnUyE2VjsnUzs9YCE3UTwlbE8hNlZQITZsVE8hYCE2ViFgIWEhNnshYTsnUyE2VjsnUzs9YCE3UTwlbE8hNlZQITdRT3hQUCE3VFA7PWA8JWwhNlZxITddViFjcE92ITVrdnghNlZ4IWAhNWshYCFhITdyIWE7J1MhNWs7J1M7PWAhOFY8JWxPITVrcSE3eVMhY3B4UE92KFZ4OydTKFY7J1M7PWAoaDwlbE8oVnEhOFlQOz1gPCVsITVrYSE4YlghYWBPciE4XXJzITZWc3YhOF12dyE2VnchYSE4XSFhIWIhOH0hYjsnUyE4XTsnUzs9YCE6VjwlbE8hOF1hITlTWCFhYE9yIThdcnMhNlZzdiE4XXZ3ITZWdyFgIThdIWAhYSE5byFhOydTIThdOydTOz1gITpWPCVsTyE4XWEhOXZUIWFgeFBPcillc3YpZXc7J1MpZTsnUzs9YCl5PCVsTyllYSE6WVA7PWA8JWwhOF0hUiE6ZFkhYWAhY3BPciE0dHJzITVrc3YhNHR2dyE2Vnd4IThdeCFgITR0IWAhYSE7UyFhOydTITR0OydTOz1gITtyPCVsTyE0dCFSITtdViFhYCFjcHhQT3IqVnJzKFZzdipWd3gpZXg7J1MqVjsnUzs9YCpzPCVsTypWIVIhO3VQOz1gPCVsITR0IVYhPFRYaVNgUCFhYCFjcE9yJlhycyZ9c3YmWHd4KHR4IV4mWCFeIV8qViFfOydTJlg7J1M7PWAqeTwlbE8mWFwiLFxuICB0b2tlbml6ZXJzOiBbazMsIHgzLCBQMywgdzMsIHYzLCB5MywgMCwgMSwgMiwgMywgNCwgNV0sXG4gIHRvcFJ1bGVzOiB7IERvY3VtZW50OiBbMCwgMTVdIH0sXG4gIGRpYWxlY3RzOiB7IG5vTWF0Y2g6IDAsIHNlbGZDbG9zaW5nOiA1MDkgfSxcbiAgdG9rZW5QcmVjOiA1MTFcbn0pO1xuZnVuY3Rpb24gengodCwgZSkge1xuICBsZXQgbiA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmb3IgKGxldCByIG9mIHQuZ2V0Q2hpbGRyZW4oTHgpKSB7XG4gICAgbGV0IGkgPSByLmdldENoaWxkKHIzKSwgcyA9IHIuZ2V0Q2hpbGQoJHApIHx8IHIuZ2V0Q2hpbGQoVXgpO1xuICAgIGkgJiYgKG5bZS5yZWFkKGkuZnJvbSwgaS50byldID0gcyA/IHMudHlwZS5pZCA9PSAkcCA/IGUucmVhZChzLmZyb20gKyAxLCBzLnRvIC0gMSkgOiBlLnJlYWQocy5mcm9tLCBzLnRvKSA6IFwiXCIpO1xuICB9XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24geTAodCwgZSkge1xuICBsZXQgbiA9IHQuZ2V0Q2hpbGQobjMpO1xuICByZXR1cm4gbiA/IGUucmVhZChuLmZyb20sIG4udG8pIDogXCIgXCI7XG59XG5mdW5jdGlvbiBZZih0LCBlLCBuKSB7XG4gIGxldCByO1xuICBmb3IgKGxldCBpIG9mIG4pXG4gICAgaWYgKCFpLmF0dHJzIHx8IGkuYXR0cnMociB8fCAociA9IHp4KHQubm9kZS5wYXJlbnQuZmlyc3RDaGlsZCwgZSkpKSlcbiAgICAgIHJldHVybiB7IHBhcnNlcjogaS5wYXJzZXIgfTtcbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBIeCh0ID0gW10sIGUgPSBbXSkge1xuICBsZXQgbiA9IFtdLCByID0gW10sIGkgPSBbXSwgcyA9IFtdO1xuICBmb3IgKGxldCBhIG9mIHQpXG4gICAgKGEudGFnID09IFwic2NyaXB0XCIgPyBuIDogYS50YWcgPT0gXCJzdHlsZVwiID8gciA6IGEudGFnID09IFwidGV4dGFyZWFcIiA/IGkgOiBzKS5wdXNoKGEpO1xuICBsZXQgbyA9IGUubGVuZ3RoID8gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCkgOiBudWxsO1xuICBmb3IgKGxldCBhIG9mIGUpXG4gICAgKG9bYS5uYW1lXSB8fCAob1thLm5hbWVdID0gW10pKS5wdXNoKGEpO1xuICByZXR1cm4gUEQoKGEsIGwpID0+IHtcbiAgICBsZXQgYyA9IGEudHlwZS5pZDtcbiAgICBpZiAoYyA9PSBpMylcbiAgICAgIHJldHVybiBZZihhLCBsLCBuKTtcbiAgICBpZiAoYyA9PSBzMylcbiAgICAgIHJldHVybiBZZihhLCBsLCByKTtcbiAgICBpZiAoYyA9PSBvMylcbiAgICAgIHJldHVybiBZZihhLCBsLCBpKTtcbiAgICBpZiAoYyA9PSBCeCAmJiBzLmxlbmd0aCkge1xuICAgICAgbGV0IHUgPSBhLm5vZGUsIGQgPSB1LmZpcnN0Q2hpbGQsIGYgPSBkICYmIHkwKGQsIGwpLCBoO1xuICAgICAgaWYgKGYpIHtcbiAgICAgICAgZm9yIChsZXQgcCBvZiBzKVxuICAgICAgICAgIGlmIChwLnRhZyA9PSBmICYmICghcC5hdHRycyB8fCBwLmF0dHJzKGggfHwgKGggPSB6eCh1LCBsKSkpKSkge1xuICAgICAgICAgICAgbGV0IE8gPSB1Lmxhc3RDaGlsZCwgbSA9IE8udHlwZS5pZCA9PSBsMyA/IE8uZnJvbSA6IHUudG87XG4gICAgICAgICAgICBpZiAobSA+IGQudG8pXG4gICAgICAgICAgICAgIHJldHVybiB7IHBhcnNlcjogcC5wYXJzZXIsIG92ZXJsYXk6IFt7IGZyb206IGQudG8sIHRvOiBtIH1dIH07XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobyAmJiBjID09IEx4KSB7XG4gICAgICBsZXQgdSA9IGEubm9kZSwgZDtcbiAgICAgIGlmIChkID0gdS5maXJzdENoaWxkKSB7XG4gICAgICAgIGxldCBmID0gb1tsLnJlYWQoZC5mcm9tLCBkLnRvKV07XG4gICAgICAgIGlmIChmKVxuICAgICAgICAgIGZvciAobGV0IGggb2YgZikge1xuICAgICAgICAgICAgaWYgKGgudGFnTmFtZSAmJiBoLnRhZ05hbWUgIT0geTAodS5wYXJlbnQsIGwpKVxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCBwID0gdS5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICBpZiAocC50eXBlLmlkID09ICRwKSB7XG4gICAgICAgICAgICAgIGxldCBPID0gcC5mcm9tICsgMSwgbSA9IHAubGFzdENoaWxkLCB5ID0gcC50byAtIChtICYmIG0uaXNFcnJvciA/IDAgOiAxKTtcbiAgICAgICAgICAgICAgaWYgKHkgPiBPKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHBhcnNlcjogaC5wYXJzZXIsIG92ZXJsYXk6IFt7IGZyb206IE8sIHRvOiB5IH1dIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHAudHlwZS5pZCA9PSBVeClcbiAgICAgICAgICAgICAgcmV0dXJuIHsgcGFyc2VyOiBoLnBhcnNlciwgb3ZlcmxheTogW3sgZnJvbTogcC5mcm9tLCB0bzogcC50byB9XSB9O1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0pO1xufVxuY29uc3QgRTMgPSAzMDksIFMwID0gMSwgJDMgPSAyLCBRMyA9IDMsIEMzID0gMzEwLCBBMyA9IDMxMiwgUjMgPSAzMTMsIE4zID0gNCwgRDMgPSA1LCBaMyA9IDAsIENwID0gW1xuICA5LFxuICAxMCxcbiAgMTEsXG4gIDEyLFxuICAxMyxcbiAgMzIsXG4gIDEzMyxcbiAgMTYwLFxuICA1NzYwLFxuICA4MTkyLFxuICA4MTkzLFxuICA4MTk0LFxuICA4MTk1LFxuICA4MTk2LFxuICA4MTk3LFxuICA4MTk4LFxuICA4MTk5LFxuICA4MjAwLFxuICA4MjAxLFxuICA4MjAyLFxuICA4MjMyLFxuICA4MjMzLFxuICA4MjM5LFxuICA4Mjg3LFxuICAxMjI4OFxuXSwgRnggPSAxMjUsIFYzID0gNTksIEFwID0gNDcsIEkzID0gNDIsIFczID0gNDMsIE0zID0gNDUsIFgzID0gNjAsIGozID0gNDQsIEIzID0gbmV3IHdnKHtcbiAgc3RhcnQ6ICExLFxuICBzaGlmdCh0LCBlKSB7XG4gICAgcmV0dXJuIGUgPT0gTjMgfHwgZSA9PSBEMyB8fCBlID09IEEzID8gdCA6IGUgPT0gUjM7XG4gIH0sXG4gIHN0cmljdDogITFcbn0pLCBMMyA9IG5ldyBnbigodCwgZSkgPT4ge1xuICBsZXQgeyBuZXh0OiBuIH0gPSB0O1xuICAobiA9PSBGeCB8fCBuID09IC0xIHx8IGUuY29udGV4dCkgJiYgdC5hY2NlcHRUb2tlbihDMyk7XG59LCB7IGNvbnRleHR1YWw6ICEwLCBmYWxsYmFjazogITAgfSksIFUzID0gbmV3IGduKCh0LCBlKSA9PiB7XG4gIGxldCB7IG5leHQ6IG4gfSA9IHQsIHI7XG4gIENwLmluZGV4T2YobikgPiAtMSB8fCBuID09IEFwICYmICgociA9IHQucGVlaygxKSkgPT0gQXAgfHwgciA9PSBJMykgfHwgbiAhPSBGeCAmJiBuICE9IFYzICYmIG4gIT0gLTEgJiYgIWUuY29udGV4dCAmJiB0LmFjY2VwdFRva2VuKEUzKTtcbn0sIHsgY29udGV4dHVhbDogITAgfSksIHEzID0gbmV3IGduKCh0LCBlKSA9PiB7XG4gIGxldCB7IG5leHQ6IG4gfSA9IHQ7XG4gIGlmICgobiA9PSBXMyB8fCBuID09IE0zKSAmJiAodC5hZHZhbmNlKCksIG4gPT0gdC5uZXh0KSkge1xuICAgIHQuYWR2YW5jZSgpO1xuICAgIGxldCByID0gIWUuY29udGV4dCAmJiBlLmNhblNoaWZ0KFMwKTtcbiAgICB0LmFjY2VwdFRva2VuKHIgPyBTMCA6ICQzKTtcbiAgfVxufSwgeyBjb250ZXh0dWFsOiAhMCB9KTtcbmZ1bmN0aW9uIHpmKHQsIGUpIHtcbiAgcmV0dXJuIHQgPj0gNjUgJiYgdCA8PSA5MCB8fCB0ID49IDk3ICYmIHQgPD0gMTIyIHx8IHQgPT0gOTUgfHwgdCA+PSAxOTIgfHwgIWUgJiYgdCA+PSA0OCAmJiB0IDw9IDU3O1xufVxuY29uc3QgWTMgPSBuZXcgZ24oKHQsIGUpID0+IHtcbiAgaWYgKHQubmV4dCAhPSBYMyB8fCAhZS5kaWFsZWN0RW5hYmxlZChaMykgfHwgKHQuYWR2YW5jZSgpLCB0Lm5leHQgPT0gQXApKVxuICAgIHJldHVybjtcbiAgbGV0IG4gPSAwO1xuICBmb3IgKDsgQ3AuaW5kZXhPZih0Lm5leHQpID4gLTE7IClcbiAgICB0LmFkdmFuY2UoKSwgbisrO1xuICBpZiAoemYodC5uZXh0LCAhMCkpIHtcbiAgICBmb3IgKHQuYWR2YW5jZSgpLCBuKys7IHpmKHQubmV4dCwgITEpOyApXG4gICAgICB0LmFkdmFuY2UoKSwgbisrO1xuICAgIGZvciAoOyBDcC5pbmRleE9mKHQubmV4dCkgPiAtMTsgKVxuICAgICAgdC5hZHZhbmNlKCksIG4rKztcbiAgICBpZiAodC5uZXh0ID09IGozKVxuICAgICAgcmV0dXJuO1xuICAgIGZvciAobGV0IHIgPSAwOyA7IHIrKykge1xuICAgICAgaWYgKHIgPT0gNykge1xuICAgICAgICBpZiAoIXpmKHQubmV4dCwgITApKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAodC5uZXh0ICE9IFwiZXh0ZW5kc1wiLmNoYXJDb2RlQXQocikpXG4gICAgICAgIGJyZWFrO1xuICAgICAgdC5hZHZhbmNlKCksIG4rKztcbiAgICB9XG4gIH1cbiAgdC5hY2NlcHRUb2tlbihRMywgLW4pO1xufSksIHozID0gaWEoe1xuICBcImdldCBzZXQgYXN5bmMgc3RhdGljXCI6IFAubW9kaWZpZXIsXG4gIFwiZm9yIHdoaWxlIGRvIGlmIGVsc2Ugc3dpdGNoIHRyeSBjYXRjaCBmaW5hbGx5IHJldHVybiB0aHJvdyBicmVhayBjb250aW51ZSBkZWZhdWx0IGNhc2VcIjogUC5jb250cm9sS2V5d29yZCxcbiAgXCJpbiBvZiBhd2FpdCB5aWVsZCB2b2lkIHR5cGVvZiBkZWxldGUgaW5zdGFuY2VvZlwiOiBQLm9wZXJhdG9yS2V5d29yZCxcbiAgXCJsZXQgdmFyIGNvbnN0IHVzaW5nIGZ1bmN0aW9uIGNsYXNzIGV4dGVuZHNcIjogUC5kZWZpbml0aW9uS2V5d29yZCxcbiAgXCJpbXBvcnQgZXhwb3J0IGZyb21cIjogUC5tb2R1bGVLZXl3b3JkLFxuICBcIndpdGggZGVidWdnZXIgYXMgbmV3XCI6IFAua2V5d29yZCxcbiAgVGVtcGxhdGVTdHJpbmc6IFAuc3BlY2lhbChQLnN0cmluZyksXG4gIHN1cGVyOiBQLmF0b20sXG4gIEJvb2xlYW5MaXRlcmFsOiBQLmJvb2wsXG4gIHRoaXM6IFAuc2VsZixcbiAgbnVsbDogUC5udWxsLFxuICBTdGFyOiBQLm1vZGlmaWVyLFxuICBWYXJpYWJsZU5hbWU6IFAudmFyaWFibGVOYW1lLFxuICBcIkNhbGxFeHByZXNzaW9uL1ZhcmlhYmxlTmFtZSBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24vVmFyaWFibGVOYW1lXCI6IFAuZnVuY3Rpb24oUC52YXJpYWJsZU5hbWUpLFxuICBWYXJpYWJsZURlZmluaXRpb246IFAuZGVmaW5pdGlvbihQLnZhcmlhYmxlTmFtZSksXG4gIExhYmVsOiBQLmxhYmVsTmFtZSxcbiAgUHJvcGVydHlOYW1lOiBQLnByb3BlcnR5TmFtZSxcbiAgUHJpdmF0ZVByb3BlcnR5TmFtZTogUC5zcGVjaWFsKFAucHJvcGVydHlOYW1lKSxcbiAgXCJDYWxsRXhwcmVzc2lvbi9NZW1iZXJFeHByZXNzaW9uL1Byb3BlcnR5TmFtZVwiOiBQLmZ1bmN0aW9uKFAucHJvcGVydHlOYW1lKSxcbiAgXCJGdW5jdGlvbkRlY2xhcmF0aW9uL1ZhcmlhYmxlRGVmaW5pdGlvblwiOiBQLmZ1bmN0aW9uKFAuZGVmaW5pdGlvbihQLnZhcmlhYmxlTmFtZSkpLFxuICBcIkNsYXNzRGVjbGFyYXRpb24vVmFyaWFibGVEZWZpbml0aW9uXCI6IFAuZGVmaW5pdGlvbihQLmNsYXNzTmFtZSksXG4gIFByb3BlcnR5RGVmaW5pdGlvbjogUC5kZWZpbml0aW9uKFAucHJvcGVydHlOYW1lKSxcbiAgUHJpdmF0ZVByb3BlcnR5RGVmaW5pdGlvbjogUC5kZWZpbml0aW9uKFAuc3BlY2lhbChQLnByb3BlcnR5TmFtZSkpLFxuICBVcGRhdGVPcDogUC51cGRhdGVPcGVyYXRvcixcbiAgXCJMaW5lQ29tbWVudCBIYXNoYmFuZ1wiOiBQLmxpbmVDb21tZW50LFxuICBCbG9ja0NvbW1lbnQ6IFAuYmxvY2tDb21tZW50LFxuICBOdW1iZXI6IFAubnVtYmVyLFxuICBTdHJpbmc6IFAuc3RyaW5nLFxuICBFc2NhcGU6IFAuZXNjYXBlLFxuICBBcml0aE9wOiBQLmFyaXRobWV0aWNPcGVyYXRvcixcbiAgTG9naWNPcDogUC5sb2dpY09wZXJhdG9yLFxuICBCaXRPcDogUC5iaXR3aXNlT3BlcmF0b3IsXG4gIENvbXBhcmVPcDogUC5jb21wYXJlT3BlcmF0b3IsXG4gIFJlZ0V4cDogUC5yZWdleHAsXG4gIEVxdWFsczogUC5kZWZpbml0aW9uT3BlcmF0b3IsXG4gIEFycm93OiBQLmZ1bmN0aW9uKFAucHVuY3R1YXRpb24pLFxuICBcIjogU3ByZWFkXCI6IFAucHVuY3R1YXRpb24sXG4gIFwiKCApXCI6IFAucGFyZW4sXG4gIFwiWyBdXCI6IFAuc3F1YXJlQnJhY2tldCxcbiAgXCJ7IH1cIjogUC5icmFjZSxcbiAgXCJJbnRlcnBvbGF0aW9uU3RhcnQgSW50ZXJwb2xhdGlvbkVuZFwiOiBQLnNwZWNpYWwoUC5icmFjZSksXG4gIFwiLlwiOiBQLmRlcmVmT3BlcmF0b3IsXG4gIFwiLCA7XCI6IFAuc2VwYXJhdG9yLFxuICBcIkBcIjogUC5tZXRhLFxuICBUeXBlTmFtZTogUC50eXBlTmFtZSxcbiAgVHlwZURlZmluaXRpb246IFAuZGVmaW5pdGlvbihQLnR5cGVOYW1lKSxcbiAgXCJ0eXBlIGVudW0gaW50ZXJmYWNlIGltcGxlbWVudHMgbmFtZXNwYWNlIG1vZHVsZSBkZWNsYXJlXCI6IFAuZGVmaW5pdGlvbktleXdvcmQsXG4gIFwiYWJzdHJhY3QgZ2xvYmFsIFByaXZhY3kgcmVhZG9ubHkgb3ZlcnJpZGVcIjogUC5tb2RpZmllcixcbiAgXCJpcyBrZXlvZiB1bmlxdWUgaW5mZXJcIjogUC5vcGVyYXRvcktleXdvcmQsXG4gIEpTWEF0dHJpYnV0ZVZhbHVlOiBQLmF0dHJpYnV0ZVZhbHVlLFxuICBKU1hUZXh0OiBQLmNvbnRlbnQsXG4gIFwiSlNYU3RhcnRUYWcgSlNYU3RhcnRDbG9zZVRhZyBKU1hTZWxmQ2xvc2VFbmRUYWcgSlNYRW5kVGFnXCI6IFAuYW5nbGVCcmFja2V0LFxuICBcIkpTWElkZW50aWZpZXIgSlNYTmFtZVNwYWNlZE5hbWVcIjogUC50YWdOYW1lLFxuICBcIkpTWEF0dHJpYnV0ZS9KU1hJZGVudGlmaWVyIEpTWEF0dHJpYnV0ZS9KU1hOYW1lU3BhY2VkTmFtZVwiOiBQLmF0dHJpYnV0ZU5hbWUsXG4gIFwiSlNYQnVpbHRpbi9KU1hJZGVudGlmaWVyXCI6IFAuc3RhbmRhcmQoUC50YWdOYW1lKVxufSksIEgzID0geyBfX3Byb3RvX186IG51bGwsIGV4cG9ydDogMTgsIGFzOiAyMywgZnJvbTogMzEsIGRlZmF1bHQ6IDM0LCBhc3luYzogMzksIGZ1bmN0aW9uOiA0MCwgZXh0ZW5kczogNTIsIHRoaXM6IDU2LCB0cnVlOiA2NCwgZmFsc2U6IDY0LCBudWxsOiA3Niwgdm9pZDogODAsIHR5cGVvZjogODQsIHN1cGVyOiAxMDIsIG5ldzogMTM2LCBkZWxldGU6IDE1MiwgeWllbGQ6IDE2MSwgYXdhaXQ6IDE2NSwgY2xhc3M6IDE3MCwgcHVibGljOiAyMjcsIHByaXZhdGU6IDIyNywgcHJvdGVjdGVkOiAyMjcsIHJlYWRvbmx5OiAyMjksIGluc3RhbmNlb2Y6IDI0OCwgc2F0aXNmaWVzOiAyNTEsIGluOiAyNTIsIGNvbnN0OiAyNTQsIGltcG9ydDogMjg2LCBrZXlvZjogMzM5LCB1bmlxdWU6IDM0MywgaW5mZXI6IDM0OSwgaXM6IDM4NSwgYWJzdHJhY3Q6IDQwNSwgaW1wbGVtZW50czogNDA3LCB0eXBlOiA0MDksIGxldDogNDEyLCB2YXI6IDQxNCwgdXNpbmc6IDQxNywgaW50ZXJmYWNlOiA0MjMsIGVudW06IDQyNywgbmFtZXNwYWNlOiA0MzMsIG1vZHVsZTogNDM1LCBkZWNsYXJlOiA0MzksIGdsb2JhbDogNDQzLCBmb3I6IDQ2Miwgb2Y6IDQ3MSwgd2hpbGU6IDQ3NCwgd2l0aDogNDc4LCBkbzogNDgyLCBpZjogNDg2LCBlbHNlOiA0ODgsIHN3aXRjaDogNDkyLCBjYXNlOiA0OTgsIHRyeTogNTA0LCBjYXRjaDogNTA4LCBmaW5hbGx5OiA1MTIsIHJldHVybjogNTE2LCB0aHJvdzogNTIwLCBicmVhazogNTI0LCBjb250aW51ZTogNTI4LCBkZWJ1Z2dlcjogNTMyIH0sIEYzID0geyBfX3Byb3RvX186IG51bGwsIGFzeW5jOiAxMjMsIGdldDogMTI1LCBzZXQ6IDEyNywgZGVjbGFyZTogMTg3LCBwdWJsaWM6IDE4OSwgcHJpdmF0ZTogMTg5LCBwcm90ZWN0ZWQ6IDE4OSwgc3RhdGljOiAxOTEsIGFic3RyYWN0OiAxOTMsIG92ZXJyaWRlOiAxOTUsIHJlYWRvbmx5OiAyMDEsIGFjY2Vzc29yOiAyMDMsIG5ldzogMzg5IH0sIEczID0geyBfX3Byb3RvX186IG51bGwsIFwiPFwiOiAxNDMgfSwgSzMgPSB1cy5kZXNlcmlhbGl6ZSh7XG4gIHZlcnNpb246IDE0LFxuICBzdGF0ZXM6IFwiJDxVTyVUUV5PT08lW1FeT09PJ19RYE9PUChsT1dPT08qelEwOFNPJyNDaE8rUk8hYk8nI0NpTythTyN0TycjQ2lPK29PP01wTycjRF5PLlFRXk8nI0RkTy5iUV5PJyNEb08lW1FeTycjRHlPMGZRXk8nI0VST09RMDdiJyNFWicjRVpPMVBRV08nI0VXT09RTycjRWwnI0VsT09RTycjSWUnI0llTzFYUVdPJyNHbU8xZFFXTycjRWtPMWlRV08nI0VrTzNrUTA4U08nI0ppTzZbUTA4U08nI0pqTzZ4UVdPJyNGWk82fVEmak8nI0ZxT09RMDdiJyNGYycjRmNPN1lPLFlPJyNGY083aFE3W08nI0Z4TzlVUVdPJyNGd09PUTA3YicjSmonI0pqT09RMDdgJyNKaScjSmlPOVpRV08nI0dxT09RVScjS1UnI0tVTzlmUVdPJyNJUk85a1EwN2hPJyNJU09PUVUnI0pXJyNKV09PUVUnI0lXJyNJV1FgUV5PT09gUV5PT08lW1FeTycjRHFPOXNRXk8nI0R9Tzl6UV5PJyNFUE85YVFXTycjR21POlJRN1tPJyNDbk86YVFXTycjRWpPOmxRV08nI0V1TzpxUTdbTycjRmJPO2BRV08nI0dtT09RTycjS1YnI0tWTztlUVdPJyNLVk87c1FXTycjR3VPO3NRV08nI0d2TztzUVdPJyNHeE85YVFXTycjR3tPPGpRV08nI0hPTz5SUVdPJyNDZE8+Y1FXTycjSFtPPmtRV08nI0hiTz5rUVdPJyNIZE9gUV5PJyNIZk8+a1FXTycjSGhPPmtRV08nI0hrTz5wUVdPJyNIcU8+dVEwN2lPJyNId08lW1FeTycjSHlPP1FRMDdpTycjSHtPP11RMDdpTycjSH1POWtRMDdoTycjSVBPP2hRMDhTTycjQ2hPQGpRYE8nI0RpUU9RV09PTyVbUV5PJyNFUE9BUVFXTycjRVNPOlJRN1tPJyNFak9BXVFXTycjRWpPQWhRcE8nI0ZiT09RVScjQ2YnI0NmT09RMDdgJyNEbicjRG5PT1EwN2AnI0ptJyNKbU8lW1FeTycjSm1PT1FPJyNKcScjSnFPT1FPJyNJYicjSWJPQmhRYE8nI0VjT09RMDdgJyNFYicjRWJPQ2RRMDdwTycjRWNPQ25RYE8nI0VWT09RTycjSnAnI0pwT0RTUWBPJyNKcU9FYVFgTycjRVZPQ25RYE8nI0VjUEVuTyEwTGJPJyNDYVBPT08pQ0R1KUNEdU9PT08nI0lYJyNJWE9FeU8hYk8sNTlUT09RMDdiLDU5VCw1OVRPT09PJyNJWScjSVlPRlhPI3RPLDU5VE8lW1FeTycjRGBPT09PJyNJWycjSVtPRmdPP01wTyw1OXhPT1EwN2IsNTl4LDU5eE9GdVFeTycjSV1PR1lRV08nI0prT0lbUXJPJyNKa08rfVFeTycjSmtPSWNRV08sNTpPT0l5UVdPJyNFbE9KV1FXTycjSnlPSmNRV08nI0p4T0pjUVdPJyNKeE9Ka1FXTyw1O1lPSnBRV08nI0p3T09RMDdmLDU6Wiw1OlpPSndRXk8sNTpaT0x4UTA4U08sNTplT01pUVdPLDU6bU9OU1EwN2hPJyNKdk9OWlFXTycjSnVPOVpRV08nI0p1T05vUVdPJyNKdU9Od1FXTyw1O1hPTnxRV08nI0p1TyEjVVFyTycjSmpPT1EwN2InI0NoJyNDaE8lW1FeTycjRVJPISN0UXBPLDU6ck9PUU8nI0pyJyNKck9PUU8tRTxjLUU8Y085YVFXTyw1PVhPISRbUVdPLDU9WE8hJGFRXk8sNTtWTyEmZFE3W08nI0VnTyEnfVFXTyw1O1ZPISltUTdbTycjRHNPISl0UV5PJyNEeE8hKk9RYE8sNTtgTyEqV1FgTyw1O2BPJVtRXk8sNTtgT09RVScjRlInI0ZST09RVScjRlQnI0ZUTyVbUV5PLDU7YU8lW1FeTyw1O2FPJVtRXk8sNTthTyVbUV5PLDU7YU8lW1FeTyw1O2FPJVtRXk8sNTthTyVbUV5PLDU7YU8lW1FeTyw1O2FPJVtRXk8sNTthTyVbUV5PLDU7YU8lW1FeTyw1O2FPT1FVJyNGWCcjRlhPISpmUV5PLDU7ck9PUTA3Yiw1O3csNTt3T09RMDdiLDU7eCw1O3hPISxpUVdPLDU7eE9PUTA3Yiw1O3ksNTt5TyVbUV5PJyNJaU8hLHFRMDdoTyw1PGVPISZkUTdbTyw1O2FPIS1gUTdbTyw1O2FPJVtRXk8sNTt1TyEtZ1Emak8nI0ZnTyEuZFEmak8nI0p9TyEuT1Emak8nI0p9TyEua1Emak8nI0p9T09RTycjSn0nI0p9TyEvUFEmak8sNTxQT09PUyw1PF0sNTxdTyEvYlFeTycjRnNPT09TJyNJaCcjSWhPN1lPLFlPLDU7fU8hL2lRJmpPJyNGdU9PUTA3Yiw1O30sNTt9TyEwWVFNaE8nI0N1T09RMDdiJyNDeScjQ3lPITBtUVdPJyNDeU8hMHJPP01wTycjQ31PITFgUTdbTyw1PGJPITFnUVdPLDU8ZE8hM1NRIUxRTycjR1NPITNhUVdPJyNHVE8hM2ZRV08nI0dUTyEza1EhTFFPJyNHWE8hNGpRYE8nI0ddT09RTycjR2gnI0doTyEoU1E3W08nI0dnT09RTycjR2onI0dqTyEoU1E3W08nI0dpTyE1XVFNaE8nI0pkT09RMDdiJyNKZCcjSmRPITVnUVdPJyNKY08hNXVRV08nI0piTyE1fVFXTycjQ3RPT1EwN2InI0N3JyNDd09PUTA3YicjRFInI0RST09RMDdiJyNEVCcjRFRPMVNRV08nI0RWTyEoU1E3W08nI0Z6TyEoU1E3W08nI0Z8TyE2VlFXTycjR09PITZbUVdPJyNHUE8hM2ZRV08nI0dWTyEoU1E3W08nI0dbTyE2YVFXTycjRW1PITdPUVdPLDU8Y09PUTA3YCcjQ3EnI0NxTyE3V1FXTycjRW5PIThRUWBPJyNFb09PUTA3YCcjSncnI0p3TyE4WFEwN2hPJyNLV085a1EwN2hPLDU9XU9gUV5PLDU+bU9PUVUnI0pgJyNKYE9PUVUsNT5uLDU+bk9PUVUtRTxVLUU8VU8hOlpRMDhTTyw1Ol1PITx3UTA4U08sNTppTyVbUV5PLDU6aU8hP2JRMDhTTyw1OmtPT1FPLDVAcSw1QHFPIUBSUTdbTyw1PVhPIUBhUTA3aE8nI0phTzlVUVdPJyNKYU8hQHJRMDdoTyw1OVlPIUB9UWBPLDU5WU8hQVZRN1tPLDU5WU86UlE3W08sNTlZTyFBYlFXTyw1O1ZPIUFqUVdPJyNIWk8hQk9RV08nI0taTyVbUV5PLDU7ek8hN3tRYE8sNTt8TyFCV1FXTyw1PXRPIUJdUVdPLDU9dE8hQmJRV08sNT10TzlrUTA3aE8sNT10TztzUVdPLDU9ZE9PUU8nI0N1JyNDdU8hQnBRYE8sNT1hTyFCeFE3W08sNT1iTyFDVFFXTyw1PWRPIUNZUXBPLDU9Z08hQ2JRV08nI0tWTz5wUVdPJyNIUU85YVFXTycjSFNPIUNnUVdPJyNIU086UlE3W08nI0hVTyFDbFFXTycjSFVPT1FVLDU9aiw1PWpPIUNxUVdPJyNIVk8hRFNRV08nI0NuTyFEWFFXTyw1OU9PIURjUVdPLDU5T08hRmhRXk8sNTlPT09RVSw1OU8sNTlPTyFGeFEwN2hPLDU5T08lW1FeTyw1OU9PIUlUUV5PJyNIXk9PUVUnI0hfJyNIX09PUVUnI0hgJyNIYE9gUV5PLDU9dk8hSWtRV08sNT12T2BRXk8sNT18T2BRXk8sNT5PTyFJcFFXTyw1PlFPYFFeTyw1PlNPIUl1UVdPLDU+Vk8hSXpRXk8sNT5dT09RVSw1PmMsNT5jTyVbUV5PLDU+Y085a1EwN2hPLDU+ZU9PUVUsNT5nLDU+Z08hTlVRV08sNT5nT09RVSw1PmksNT5pTyFOVVFXTyw1PmlPT1FVLDU+ayw1PmtPIU5aUWBPJyNEW08lW1FeTycjSm1PIU54UWBPJyNKbU8jIGdRYE8nI0RqTyMgeFFgTycjRGpPIyRaUV5PJyNEak8jJGJRV08nI0psTyMkalFXTyw1OlRPIyRvUVdPJyNFcE8jJH1RV08nI0p6TyMlVlFXTyw1O1pPIyVbUWBPJyNEak8jJWlRYE8nI0VVT09RMDdiLDU6biw1Om5PJVtRXk8sNTpuTyMlcFFXTyw1Om5PPnBRV08sNTtVTyFAfVFgTyw1O1VPIUFWUTdbTyw1O1VPOlJRN1tPLDU7VU8jJXhRV08sNUBYTyMlfVEkSVNPLDU6ck9PUU8tRTxgLUU8YE8jJ1RRMDdwTyw1On1PQ25RYE8sNTpxTyMnX1FgTyw1OnFPQ25RYE8sNTp9TyFAclEwN2hPLDU6cU9PUTA3YCcjRWYnI0VmT09RTyw1On0sNTp9TyVbUV5PLDU6fU8jJ2xRMDdoTyw1On1PIyd3UTA3aE8sNTp9TyFAfVFgTyw1OnFPT1FPLDU7VCw1O1RPIyhWUTA3aE8sNTp9UE9PTycjSVYnI0lWUCMoa08hMExiTyw1OHtQT09PLDU4eyw1OHtPT09PLUU8Vi1FPFZPT1EwN2IxRy5vMUcub09PT08tRTxXLUU8V08jKHZRcE8sNTl6T09PTy1FPFktRTxZT09RMDdiMUcvZDFHL2RPIyh7UXJPLDU+d08rfVFeTyw1PndPT1FPLDU+fSw1Pn1PIylWUV5PJyNJXU9PUU8tRTxaLUU8Wk8jKWRRV08sNUBWTyMpbFFyTyw1QFZPIylzUVdPLDVAZE9PUTA3YjFHL2oxRy9qTyVbUV5PLDVAZU8jKXtRV08nI0ljT09RTy1FPGEtRTxhTyMpc1FXTyw1QGRPT1EwN2AxRzB0MUcwdE9PUTA3ZjFHL3UxRy91T09RMDdmMUcwWDFHMFhPJVtRXk8sNUBiTyMqYVEwN2hPLDVAYk8jKnJRMDdoTyw1QGJPIyp5UVdPLDVAYU85WlFXTyw1QGFPIytSUVdPLDVAYU8jK2FRV08nI0lmTyMqeVFXTyw1QGFPT1EwN2AxRzBzMUcwc08hKk9RYE8sNTp0TyEqWlFgTyw1OnRPT1FPLDU6diw1OnZPIyxSUVdPLDU6dk8jLFpRN1tPMUcyc085YVFXTzFHMnNPT1EwN2IxRzBxMUcwcU8jLGlRMDhTTzFHMHFPIy1uUTA4UU8sNTtST09RMDdiJyNHUicjR1JPIy5bUTA4U08nI0pkTyEkYVFeTzFHMHFPIzBkUTdbTycjSm5PIzBuUVdPLDU6X08jMHNRck8nI0pvTyVbUV5PJyNKb08jMH1RV08sNTpkT09RMDdiJyNEWycjRFtPT1EwN2IxRzB6MUcwek8lW1FeTzFHMHpPT1EwN2IxRzFkMUcxZE8jMVNRV08xRzB6TyMza1EwOFNPMUcwe08jM3JRMDhTTzFHMHtPIzZdUTA4U08xRzB7TyM2ZFEwOFNPMUcwe08jOG5RMDhTTzFHMHtPIzlVUTA4U08xRzB7TyM8T1EwOFNPMUcwe08jPFZRMDhTTzFHMHtPIz5qUTA4U08xRzB7TyM+d1EwOFNPMUcwe08jQHVRMDhTTzFHMHtPI0N1UShDWU8nI0NoTyNFc1EoQ1lPMUcxXk8jRXpRKENZTycjSmpPISxsUVdPMUcxZE8jRltRMDhTTyw1P1RPT1EwN2AtRTxnLUU8Z08jR09RMDhTTzFHMHtPT1EwN2IxRzB7MUcwe08jSVpRMDhTTzFHMWFPI0l9USZqTyw1PFRPI0pWUSZqTyw1PFVPI0pfUSZqTycjRmxPI0p2UVdPJyNGa09PUU8nI0tPJyNLT09PUU8nI0lnJyNJZ08jSntRJmpPMUcxa09PUTA3YjFHMWsxRzFrT09PUzFHMXYxRzF2TyNLXlEoQ1lPJyNKaU8jS2hRV08sNTxfTyEqZlFeTyw1PF9PT09TLUU8Zi1FPGZPT1EwN2IxRzFpMUcxaU8jS21RYE8nI0p9T09RMDdiLDU8YSw1PGFPI0t1UWBPLDU8YU9PUTA3Yiw1OWUsNTllTyEmZFE3W08nI0RQT09PTycjSVonI0laTyNLek8/TXBPLDU5aU9PUTA3Yiw1OWksNTlpTyVbUV5PMUcxfE8hNltRV08nI0lrTyNMVlE3W08sNTx1T09RMDdiLDU8ciw1PHJPIShTUTdbTycjSW5PI0x1UTdbTyw1PVJPIShTUTdbTycjSXBPI01oUTdbTyw1PVRPISZkUTdbTyw1PVZPT1FPMUcyTzFHMk9PI01yUXBPJyNDcU8jTlZRcE8sNTxuTyNOXlFXTycjS1JPOWFRV08nI0tSTyNObFFXTyw1PHBPIShTUTdbTyw1PG9PI05xUVdPJyNHVU8jTnxRV08sNTxvTyQgUlFwTycjR1JPJCBgUXBPJyNLU08kIGpRV08nI0tTTyEmZFE3W08nI0tTTyQgb1FXTyw1PHNPJCB0UWBPJyNHXk8hNGVRYE8nI0deTyQhVlFXTycjR2BPJCFbUVdPJyNHYk8hM2ZRV08nI0dlTyQhYVEwN2hPJyNJbU8kIWxRYE8sNTx3T09RMDdmLDU8dyw1PHdPJCFzUWBPJyNHXk8kI1JRYE8nI0dfTyQjWlFgTycjR19PJCNgUTdbTyw1PVJPJCNwUTdbTyw1PVRPT1EwN2IsNT1XLDU9V08hKFNRN1tPLDU/fU8hKFNRN1tPLDU/fU8kJFFRV08nI0lyTyQkXVFXTyw1P3xPJCRlUVdPLDU5YE8kJVVRN1tPLDU5cU9PUTA3Yiw1OXEsNTlxTyQld1E3W08sNTxmTyQmalE3W08sNTxoT0BiUVdPLDU8ak9PUTA3Yiw1PGssNTxrTyQmdFFXTyw1PHFPJCZ5UTdbTyw1PHZPJCdaUVdPJyNKdU8hJGFRXk8xRzF9TyQnYFFXTzFHMX1POVpRV08nI0p4TzlaUVdPJyNFcE8lW1FeTycjRXBPOVpRV08nI0l0TyQnZVEwN2hPLDVAck9PUVUxRzJ3MUcyd09PUVUxRzRYMUc0WE9PUTA3YjFHL3cxRy93TyEsaVFXTzFHL3dPJClqUTA4U08xRzBUT09RVTFHMnMxRzJzTyEmZFE3W08xRzJzTyVbUV5PMUcyc08jLF5RV08xRzJzTyQrblE3W08nI0VnT09RMDdgLDU/eyw1P3tPJCt4UTA3aE8sNT97T09RVTFHLnQxRy50TyFAclEwN2hPMUcudE8hQH1RYE8xRy50TyFBVlE3W08xRy50TyQsWlFXTzFHMHFPJCxgUVdPJyNDaE8kLGtRV08nI0tbTyQsc1FXTyw1PXVPJCx4UVdPJyNLW08kLH1RV08nI0tbTyQtXVFXTycjSXpPJC1rUVdPLDVAdU8kLXNRck8xRzFmT09RMDdiMUcxaDFHMWhPOWFRV08xRzNgT0BiUVdPMUczYE8kLXpRV08xRzNgTyQuUFFXTzFHM2BPT1FVMUczYDFHM2BPIUNUUVdPMUczT08hJmRRN1tPMUcye08kLlVRV08xRzJ7T09RVTFHMnwxRzJ8TyEmZFE3W08xRzJ8TyQuWlFXTzFHMnxPJC5jUWBPJyNHek9PUVUxRzNPMUczT08hNGVRYE8nI0l2TyFDWVFwTzFHM1JPT1FVMUczUjFHM1JPT1FVLDU9bCw1PWxPJC5rUTdbTyw1PW5POWFRV08sNT1uTyQhW1FXTyw1PXBPOVVRV08sNT1wTyFAfVFgTyw1PXBPIUFWUTdbTyw1PXBPOlJRN1tPLDU9cE8kLnlRV08nI0tZTyQvVVFXTyw1PXFPT1FVMUcuajFHLmpPJC9aUTA3aE8xRy5qT0BiUVdPMUcuak8kL2ZRV08xRy5qTzlrUTA3aE8xRy5qTyQxa1FyTyw1QHdPJDF7UVdPLDVAd085WlFXTyw1QHdPJDJXUV5PLDU9eE8kMl9RV08sNT14T09RVTFHM2IxRzNiT2BRXk8xRzNiT09RVTFHM2gxRzNoT09RVTFHM2oxRzNqTz5rUVdPMUczbE8kMmRRXk8xRzNuTyQ2aFFeTycjSG1PT1FVMUczcTFHM3FPJDZ1UVdPJyNIc08+cFFXTycjSHVPT1FVMUczdzFHM3dPJDZ9UV5PMUczd085a1EwN2hPMUczfU9PUVUxRzRQMUc0UE9PUTA3YCcjR1knI0dZTzlrUTA3aE8xRzRSTzlrUTA3aE8xRzRUTyQ7VVFXTyw1QFhPISpmUV5PLDU7W085WlFXTyw1O1tPPnBRV08sNTpVTyEqZlFeTyw1OlVPIUB9UWBPLDU6VU8kO1pRKENZTyw1OlVPT1FPLDU7Wyw1O1tPJDtlUWBPJyNJXk8kO3tRV08sNUBXT09RMDdiMUcvbzFHL29PJDxUUWBPJyNJZE8kPF9RV08sNUBmT09RMDdgMUcwdTFHMHVPIyB4UWBPLDU6VU9PUU8nI0lhJyNJYU8kPGdRYE8sNTpwT09RMDdmLDU6cCw1OnBPIyVzUVdPMUcwWU9PUTA3YjFHMFkxRzBZTyVbUV5PMUcwWU9PUTA3YjFHMHAxRzBwTz5wUVdPMUcwcE8hQH1RYE8xRzBwTyFBVlE3W08xRzBwT09RMDdgMUc1czFHNXNPIUByUTA3aE8xRzBdT09RTzFHMGkxRzBpTyVbUV5PMUcwaU8kPG5RMDdoTzFHMGlPJDx5UTA3aE8xRzBpTyFAfVFgTzFHMF1PQ25RYE8xRzBdTyQ9WFEwN2hPMUcwaU9PUU8xRzBdMUcwXU8kPW1RMDhTTzFHMGlQT09PLUU8VC1FPFRQT09PMUcuZzFHLmdPT09PMUcvZjFHL2ZPJD13UXBPLDU8ZU8kPlBRck8xRzRjT09RTzFHNGkxRzRpTyVbUV5PLDU+d08kPlpRV08xRzVxTyQ+Y1FXTzFHNk9PJD5rUXJPMUc2UE85WlFXTyw1Pn1PJD51UTA4U08xRzV8TyVbUV5PMUc1fE8kP1ZRMDdoTzFHNXxPJD9oUVdPMUc1e08kP2hRV08xRzV7TzlaUVdPMUc1e08kP3BRV08sNT9RTzlaUVdPLDU/UU9PUU8sNT9RLDU/UU8kQFVRV08sNT9RTyQnWlFXTyw1P1FPT1FPLUU8ZC1FPGRPT1FPMUcwYDFHMGBPT1FPMUcwYjFHMGJPISxsUVdPMUcwYk9PUVU3KyhfNysoX08hJmRRN1tPNysoX08lW1FeTzcrKF9PJEBkUVdPNysoX08kQG9RN1tPNysoX08kQH1RMDhTTyw1PVJPJENZUTA4U08sNT1UTyRFZVEwOFNPLDU9Uk8kR3ZRMDhTTyw1PVRPJEpYUTA4U08sNTlxTyRMYVEwOFNPLDU8Zk8kTmxRMDhTTyw1PGhPJSF3UTA4U08sNTx2T09RMDdiNysmXTcrJl1PJSVZUTA4U083KyZdTyUlfFE3W08nI0lfTyUmV1FXTyw1QFlPT1EwN2IxRy95MUcveU8lJmBRXk8nI0lgTyUmbVFXTyw1QFpPJSZ1UXJPLDVAWk9PUTA3YjFHME8xRzBPTyUnUFFXTzcrJmZPT1EwN2I3KyZmNysmZk8lJ1VRKENZTyw1OmVPJVtRXk83KyZ4TyUnYFEoQ1lPLDU6XU8lJ21RKENZTyw1OmlPJSd3UShDWU8sNTprT09RMDdiNysnTzcrJ09PT1FPMUcxbzFHMW9PT1FPMUcxcDFHMXBPJShSUXRPLDU8V08hKmZRXk8sNTxWT09RTy1FPGUtRTxlT09RMDdiNysnVjcrJ1ZPT09TNysnYjcrJ2JPT09TMUcxeTFHMXlPJSheUVdPMUcxeU9PUTA3YjFHMXsxRzF7TyUoY1FwTyw1OWtPT09PLUU8WC1FPFhPT1EwN2IxRy9UMUcvVE8lKGpRMDhTTzcrJ2hPT1EwN2IsNT9WLDU/Vk8lKV5RcE8sNT9WT09RMDdiMUcyYTFHMmFQISZkUTdbTycjSWtQT1EwN2ItRTxpLUU8aU8lKXxRN1tPLDU/WU9PUTA3Yi1FPGwtRTxsTyUqb1E3W08sNT9bT09RMDdiLUU8bi1FPG5PJSp5UXBPMUcycU9PUTA3YjFHMlkxRzJZTyUrUVFXTycjSWpPJStgUVdPLDVAbU8lK2BRV08sNUBtTyUraFFXTyw1QG1PJStzUVdPLDVAbU9PUU8xRzJbMUcyW08lLFJRN1tPMUcyWk8hKFNRN1tPMUcyWk8lLGNRIUxRTycjSWxPJSxzUVdPLDVAbk8hJmRRN1tPLDVAbk8lLHtRcE8sNUBuT09RMDdiMUcyXzFHMl9PT1EwN2AsNTx4LDU8eE9PUTA3YCw1PHksNTx5TyQnWlFXTyw1PHlPQ19RV08sNTx5TyFAfVFgTyw1PHhPT1FPJyNHYScjR2FPJS1WUVdPLDU8ek9PUTA3YCw1PHwsNTx8TyQnWlFXTyw1PVBPT1FPLDU/WCw1P1hPT1FPLUU8ay1FPGtPT1EwN2YxRzJjMUcyY08hNGVRYE8sNTx4TyUtX1FXTyw1PHlPJCFWUVdPLDU8ek8hNGVRYE8sNTx5TyEoU1E3W08nI0luTyUuUlE3W08xRzJtTyEoU1E3W08nI0lwTyUudFE3W08xRzJvTyUvT1E3W08xRzVpTyUvWVE3W08xRzVpT09RTyw1P14sNT9eT09RTy1FPHAtRTxwT09RTzFHLnoxRy56TyE3e1FgTyw1OXNPJVtRXk8sNTlzTyUvZ1FXTzFHMlVPIShTUTdbTzFHMl1PJS9sUTA4U083KydpT09RMDdiNysnaTcrJ2lPISRhUV5PNysnaU8lMGBRV08sNTtbT09RMDdgLDU/YCw1P2BPT1EwN2AtRTxyLUU8ck9PUTA3YjcrJWM3KyVjTyUwZVFwTycjS1RPIyVzUVdPNysoX08lMG9Rck83KyhfTyRAZ1FXTzcrKF9PJTB2UTA4UU8nI0NoTyUxWlEwOFFPLDU8fU8lMXtRV08sNTx9T09RMDdgMUc1ZzFHNWdPT1FVNyskYDcrJGBPIUByUTA3aE83KyRgTyFAfVFgTzcrJGBPISRhUV5PNysmXU8lMlFRV08nI0l5TyUyaVFXTyw1QHZPT1FPMUczYTFHM2FPOWFRV08sNUB2TyUyaVFXTyw1QHZPJTJxUVdPLDVAdk9PUU8sNT9mLDU/Zk9PUU8tRTx4LUU8eE9PUTA3YjcrJ1E3KydRTyUydlFXTzcrKHpPOWtRMDdoTzcrKHpPOWFRV083Kyh6T0BiUVdPNysoek9PUVU3KyhqNysoak8lMntRMDhRTzcrKGdPISZkUTdbTzcrKGdPJTNWUXBPNysoaE9PUVU3KyhoNysoaE8hJmRRN1tPNysoaE8lM15RV08nI0tYTyUzaVFXTyw1PWZPT1FPLDU/Yiw1P2JPT1FPLUU8dC1FPHRPT1FVNysobTcrKG1PJTR4UWBPJyNIVE9PUVUxRzNZMUczWU8hJmRRN1tPMUczWU8lW1FeTzFHM1lPJTVQUVdPMUczWU8lNVtRN1tPMUczWU85a1EwN2hPMUczW08kIVtRV08xRzNbTzlVUVdPMUczW08hQH1RYE8xRzNbTyFBVlE3W08xRzNbTyU1alFXTycjSXhPJTZPUVdPLDVAdE8lNldRYE8sNUB0T09RMDdgMUczXTFHM11PT1FVNyskVTcrJFVPQGJRV083KyRVTzlrUTA3aE83KyRVTyU2Y1FXTzcrJFVPJVtRXk8xRzZjTyVbUV5PMUc2ZE8lNmhRMDdoTzFHNmNPJTZyUV5PMUczZE8lNnlRV08xRzNkTyU3T1FeTzFHM2RPT1FVNysofDcrKHxPOWtRMDdoTzcrKVdPYFFeTzcrKVlPT1FVJyNLXycjS19PT1FVJyNJeycjSXtPJTdWUV5PLDU+WE9PUVUsNT5YLDU+WE8lW1FeTycjSG5PJTdkUVdPJyNIcE9PUVUsNT5fLDU+X085WlFXTyw1Pl9PT1FVLDU+YSw1PmFPT1FVNyspYzcrKWNPT1FVNyspaTcrKWlPT1FVNyspbTcrKW1PT1FVNyspbzcrKW9PJTdpUWBPMUc1c08lN31RKENZTzFHMHZPJThYUVdPMUcwdk9PUU8xRy9wMUcvcE8lOGRRKENZTzFHL3BPPnBRV08xRy9wTyEqZlFeTycjRGpPT1FPLDU+eCw1PnhPT1FPLUU8Wy1FPFtPT1FPLDU/Tyw1P09PT1FPLUU8Yi1FPGJPIUB9UWBPMUcvcE9PUU8tRTxfLUU8X09PUTA3ZjFHMFsxRzBbT09RMDdiNysldDcrJXRPIyVzUVdPNysldE9PUTA3YjcrJls3KyZbTz5wUVdPNysmW08hQH1RYE83KyZbT09RTzcrJXc3KyV3TyQ9bVEwOFNPNysmVE9PUU83KyZUNysmVE8lW1FeTzcrJlRPJThuUTA3aE83KyZUTyFAclEwN2hPNysld08hQH1RYE83KyV3TyU4eVEwN2hPNysmVE8lOVhRMDhTTzcrK2hPJVtRXk83KytoTyU5aVFXTzcrK2dPJTlpUVdPNysrZ09PUU8xRzRsMUc0bE85WlFXTzFHNGxPJTlxUVdPMUc0bE9PUU83KyV8NyslfE8jJXNRV088PEt5TyUwb1FyTzw8S3lPJTpQUVdPPDxLeU9PUVU8PEt5PDxLeU8hJmRRN1tPPDxLeU8lW1FeTzw8S3lPJTpYUVdPPDxLeU8lOmRRMDhTTyw1P1lPJTxvUTA4U08sNT9bTyU+elEwOFNPMUcyWk8lQV1RMDhTTzFHMm1PJUNoUTA4U08xRzJvTyVFc1E3W08sNT55T09RTy1FPF0tRTxdTyVFfVFyTyw1PnpPJVtRXk8sNT56T09RTy1FPF4tRTxeTyVGWFFXTzFHNXVPT1EwN2I8PEpRPDxKUU8lRmFRKENZTzFHMHFPJUhrUShDWU8xRzB7TyVIclEoQ1lPMUcwe08lSnZRKENZTzFHMHtPJUp9UShDWU8xRzB7TyVMclEoQ1lPMUcwe08lTVlRKENZTzFHMHtPJiBtUShDWU8xRzB7TyYgdFEoQ1lPMUcwe08mI3JRKENZTzFHMHtPJiRQUShDWU8xRzB7TyYlfVEoQ1lPMUcwe08mJmJRMDhTTzw8SmRPJidnUShDWU8xRzB7TyYpXVEoQ1lPJyNKZE8mK2BRKENZTzFHMWFPJittUShDWU8xRzBUTyEqZlFeTycjRm5PT1FPJyNLUCcjS1BPT1FPMUcxcjFHMXJPJit3UVdPMUcxcU8mK3xRKENZTyw1P1RPT09TNysnZTcrJ2VPT09PMUcvVjFHL1ZPT1EwN2IxRzRxMUc0cU8hKFNRN1tPNysoXU8mLFdRV08sNT9VTzlhUVdPLDU/VU9PUU8tRTxoLUU8aE8mLGZRV08xRzZYTyYsZlFXTzFHNlhPJixuUVdPMUc2WE8mLHlRN1tPNysndU8mLVpRcE8sNT9XTyYtZVFXTyw1P1dPISZkUTdbTyw1P1dPT1FPLUU8ai1FPGpPJi1qUXBPMUc2WU8mLXRRV08xRzZZT09RMDdgMUcyZTFHMmVPJCdaUVdPMUcyZU9PUTA3YDFHMmQxRzJkTyYtfFFXTzFHMmZPISZkUTdbTzFHMmZPT1EwN2AxRzJrMUcya08hQH1RYE8xRzJkT0NfUVdPMUcyZU8mLlJRV08xRzJmTyYuWlFXTzFHMmVPJi59UTdbTyw1P1lPT1EwN2ItRTxtLUU8bU8mL3BRN1tPLDU/W09PUTA3Yi1FPG8tRTxvTyEoU1E3W083KytUT09RMDdiMUcvXzFHL19PJi96UVdPMUcvX09PUTA3YjcrJ3A3KydwTyYwUFE3W083Kyd3TyYwYVEwOFNPPDxLVE9PUTA3Yjw8S1Q8PEtUTyYxVFFXTzFHMHZPISZkUTdbTycjSXNPJjFZUVdPLDVAb08hJmRRN1tPMUcyaU9PUVU8PEd6PDxHek8hQHJRMDdoTzw8R3pPJjFiUTA4U088PEl3T09RMDdiPDxJdzw8SXdPT1FPLDU/ZSw1P2VPJjJVUVdPLDU/ZU8mMlpRV08sNT9lT09RTy1FPHctRTx3TyYyaVFXTzFHNmJPJjJpUVdPMUc2Yk85YVFXTzFHNmJPQGJRV088PExmT09RVTw8TGY8PExmTyYycVFXTzw8TGZPOWtRMDdoTzw8TGZPT1FVPDxMUjw8TFJPJTJ7UTA4UU88PExST09RVTw8TFM8PExTTyUzVlFwTzw8TFNPJjJ2UWBPJyNJdU8mM1JRV08sNUBzTyEqZlFeTyw1QHNPT1FVMUczUTFHM1FPJjNaUV5PJyNKbU9PUU8nI0l3JyNJd085a1EwN2hPJyNJd08mM2VRYE8sNT1vT09RVSw1PW8sNT1vTyYzbFFgTycjRWNPJjRRUVdPNysodE8mNFZRV083Kyh0T09RVTcrKHQ3Kyh0TyEmZFE3W083Kyh0TyVbUV5PNysodE8mNF9RV083Kyh0T09RVTcrKHY3Kyh2TzlrUTA3aE83Kyh2TyQhW1FXTzcrKHZPOVVRV083Kyh2TyFAfVFgTzcrKHZPJjRqUVdPLDU/ZE9PUU8tRTx2LUU8dk9PUU8nI0hXJyNIV08mNHVRV08xRzZgTzlrUTA3aE88PEdwT09RVTw8R3A8PEdwT0BiUVdPPDxHcE8mNH1RV083Kyt9TyY1U1FXTzcrLE9PJVtRXk83Kyt9TyVbUV5PNyssT09PUVU3KylPNyspT08mNVhRV083KylPTyY1XlFeTzcrKU9PJjVlUVdPNyspT09PUVU8PExyPDxMck9PUVU8PEx0PDxMdE9PUVUtRTx5LUU8eU9PUVUxRzNzMUczc08mNWpRV08sNT5ZT09RVSw1PlssNT5bTyY1b1FXTzFHM3lPOVpRV083KyZiTyEqZlFeTzcrJmJPT1FPNyslWzcrJVtPJjV0UShDWU8xRzZQTz5wUVdPNyslW09PUTA3Yjw8SWA8PElgT09RMDdiPDxJdjw8SXZPPnBRV088PEl2T09RTzw8SW88PElvTyQ9bVEwOFNPPDxJb08lW1FeTzw8SW9PT1FPPDxJYzw8SWNPIUByUTA3aE88PEljTyY2T1EwN2hPPDxJb08mNlpRMDhTTzw9IFNPJjZrUVdPPD0gUk9PUU83KypXNysqV085WlFXTzcrKldPT1FVQU5BZUFOQWVPJjZzUVdPQU5BZU8hJmRRN1tPQU5BZU8jJXNRV09BTkFlTyUwb1FyT0FOQWVPJVtRXk9BTkFlTyY2e1EwOFNPNysndU8mOV5RMDhTTyw1P1lPJjtpUTA4U08sNT9bTyY9dFEwOFNPNysnd08mQFZRck8xRzRmTyZAYVEoQ1lPNysmXU8mQmVRKENZTyw1PVJPJkRsUShDWU8sNT1UTyZEfFEoQ1lPLDU9Uk8mRV5RKENZTyw1PVRPJkVuUShDWU8sNTlxTyZHcVEoQ1lPLDU8Zk8mSXRRKENZTyw1PGhPJkt3UShDWU8sNTx2TyZNbVEoQ1lPNysnaE8mTXpRKENZTzcrJ2lPJk5YUVdPLDU8WU9PUU83KyddNysnXU8mTl5RN1tPPDxLd09PUU8xRzRwMUc0cE8mTmVRV08xRzRwTyZOcFFXTzFHNHBPJyBPUVdPNysrc08nIE9RV083KytzTyEmZFE3W08xRzRyTycgV1FwTzFHNHJPJyBiUVdPNysrdE9PUTA3YDcrKFA3KyhQTyQnWlFXTzcrKFFPJyBqUXBPNysoUU9PUTA3YDcrKE83KyhPTyQnWlFXTzcrKFBPJyBxUVdPNysoUU8hJmRRN1tPNysoUU9DX1FXTzcrKFBPJyB2UTdbTzw8Tm9PT1EwN2I3KyR5NyskeU8nIVFRcE8sNT9fT09RTy1FPHEtRTxxTychW1EwOFFPNysoVE9PUVVBTj1mQU49Zk85YVFXTzFHNVBPT1FPMUc1UDFHNVBPJyFsUVdPMUc1UE8nIXFRV083Kyt8TychcVFXTzcrK3xPOWtRMDdoT0FOQlFPQGJRV09BTkJRT09RVUFOQlFBTkJRT09RVUFOQW1BTkFtT09RVUFOQW5BTkFuTycheVFXTyw1P2FPT1FPLUU8cy1FPHNPJyNVUShDWU8xRzZfTyclZlFyTycjQ2hPT1FPLDU/Yyw1P2NPT1FPLUU8dS1FPHVPT1FVMUczWjFHM1pPJjNaUV5PLDU8ek9PUVU8PExgPDxMYE8hJmRRN1tPPDxMYE8mNFFRV088PExgTyclcFFXTzw8TGBPJVtRXk88PExgT09RVTw8TGI8PExiTzlrUTA3aE88PExiTyQhW1FXTzw8TGJPOVVRV088PExiTycleFFgTzFHNU9PJyZUUVdPNysrek9PUVVBTj1bQU49W085a1EwN2hPQU49W09PUVU8PSBpPD0gaU9PUVU8PSBqPD0gak8nJl1RV088PSBpTycmYlFXTzw9IGpPT1FVPDxMajw8TGpPJyZnUVdPPDxMak8nJmxRXk88PExqT09RVTFHM3QxRzN0Tz5wUVdPNyspZU8nJnNRV088PEl8TycnT1EoQ1lPPDxJfE9PUU88PEh2PDxIdk9PUTA3YkFOP2JBTj9iT09RT0FOP1pBTj9aTyQ9bVEwOFNPQU4/Wk9PUU9BTj59QU4+fU8lW1FeT0FOP1pPT1FPPDxNcjw8TXJPT1FVRzI3UEcyN1BPISZkUTdbT0cyN1BPIyVzUVdPRzI3UE8nJ1lRV09HMjdQTyUwb1FyT0cyN1BPJydiUShDWU88PEpkTycnb1EoQ1lPMUcyWk8nKWVRKENZTyw1P1lPJytoUShDWU8sNT9bTycta1EoQ1lPMUcybU8nL25RKENZTzFHMm9PJzFxUShDWU88PEtUTycyT1EoQ1lPPDxJd09PUU8xRzF0MUcxdE8hKFNRN1tPQU5BY09PUU83KypbNysqW08nMl1RV083KypbTycyaFFXTzw9IF9PJzJwUXBPNysqXk9PUTA3YDw8S2w8PEtsTyQnWlFXTzw8S2xPT1EwN2A8PEtrPDxLa08nMnpRcE88PEtsTyQnWlFXTzw8S2tPT1FPNysqazcrKmtPOWFRV083KyprTyczUlFXTzw9IGhPT1FVRzI3bEcyN2xPOWtRMDdoT0cyN2xPISpmUV5PMUc0e08nM1pRV083Kyt5TyY0UVFXT0FOQXpPT1FVQU5BekFOQXpPISZkUTdbT0FOQXpPJzNjUVdPQU5Bek9PUVVBTkF8QU5BfE85a1EwN2hPQU5BfE8kIVtRV09BTkF8T09RTycjSFgnI0hYT09RTzcrKmo3KypqT09RVUcyMnZHMjJ2T09RVUFORVRBTkVUT09RVUFORVVBTkVVT09RVUFOQlVBTkJVTycza1FXT0FOQlVPT1FVPDxNUDw8TVBPISpmUV5PQU4/aE9PUU9HMjR1RzI0dU8kPW1RMDhTT0cyNHVPIyVzUVdPTEQsa09PUVVMRCxrTEQsa08hJmRRN1tPTEQsa08nM3BRV09MRCxrTyczeFEoQ1lPNysndU8nNW5RKENZTyw1P1lPJzdxUShDWU8sNT9bTyc5dFEoQ1lPNysnd08nO2pRN1tPRzI2fU9PUU88PE12PDxNdk9PUTA3YEFOQVdBTkFXTyQnWlFXT0FOQVdPT1EwN2BBTkFWQU5BVk9PUU88PE5WPDxOVk9PUVVMRC1XTEQtV08nO3pRKENZTzcrKmdPT1FVRzI3ZkcyN2ZPJjRRUVdPRzI3Zk8hJmRRN1tPRzI3Zk9PUVVHMjdoRzI3aE85a1EwN2hPRzI3aE9PUVVHMjdwRzI3cE8nPFVRKENZT0cyNVNPT1FPTEQqYUxEKmFPT1FVISQoIVYhJCghVk8jJXNRV08hJCghVk8hJmRRN1tPISQoIVZPJzxgUTA4U09HMjZ9T09RMDdgRzI2ckcyNnJPT1FVTEQtUUxELVFPJjRRUVdPTEQtUU9PUVVMRC1TTEQtU09PUVUhKTlFcSEpOUVxTyMlc1FXTyEpOUVxT09RVSEkKCFsISQoIWxPT1FVIS5LO10hLks7XU8nPnFRKENZT0cyNn1PISpmUV5PJyNEeU8xUFFXTycjRVdPJ0BnUXJPJyNKaU8hKmZRXk8nI0RxTydAblFeTycjRH1PJ0B1UXJPJyNDaE8nQ11Rck8nI0NoTyEqZlFeTycjRVBPJ0NtUV5PLDU7Vk8hKmZRXk8sNTthTyEqZlFeTyw1O2FPISpmUV5PLDU7YU8hKmZRXk8sNTthTyEqZlFeTyw1O2FPISpmUV5PLDU7YU8hKmZRXk8sNTthTyEqZlFeTyw1O2FPISpmUV5PLDU7YU8hKmZRXk8sNTthTyEqZlFeTyw1O2FPISpmUV5PJyNJaU8nRXBRV08sNTxlTydFeFE3W08sNTthTydHY1E3W08sNTthTyEqZlFeTyw1O3VPISZkUTdbTycjR2dPJ0V4UTdbTycjR2dPISZkUTdbTycjR2lPJ0V4UTdbTycjR2lPMVNRV08nI0RWTzFTUVdPJyNEVk8hJmRRN1tPJyNGek8nRXhRN1tPJyNGek8hJmRRN1tPJyNGfE8nRXhRN1tPJyNGfE8hJmRRN1tPJyNHW08nRXhRN1tPJyNHW08hKmZRXk8sNTppTyEqZlFeTyw1QGVPJ0NtUV5PMUcwcU8nR2pRKENZTycjQ2hPISpmUV5PMUcxfE8hJmRRN1tPJyNJbk8nRXhRN1tPJyNJbk8hJmRRN1tPJyNJcE8nRXhRN1tPJyNJcE8hJmRRN1tPLDU8b08nRXhRN1tPLDU8b08nQ21RXk8xRzF9TyEqZlFeTzcrJnhPISZkUTdbTzFHMlpPJ0V4UTdbTzFHMlpPISZkUTdbTycjSW5PJ0V4UTdbTycjSW5PISZkUTdbTycjSXBPJ0V4UTdbTycjSXBPISZkUTdbTzFHMl1PJ0V4UTdbTzFHMl1PJ0NtUV5PNysnaU8nQ21RXk83KyZdTyEmZFE3W09BTkFjTydFeFE3W09BTkFjTydHdFFXTycjRWtPJ0d5UVdPJyNFa08nSFJRV08nI0ZaTydIV1FXTycjRXVPJ0hdUVdPJyNKeU8nSGhRV08nI0p3TydIc1FXTyw1O1ZPJ0h4UTdbTyw1PGJPJ0lQUVdPJyNHVE8nSVVRV08nI0dUTydJWlFXTyw1PGNPJ0ljUVdPLDU7Vk8nSWtRKENZTzFHMV5PJ0lyUVdPLDU8b08nSXdRV08sNTxvTydJfFFXTyw1PHFPJ0pSUVdPLDU8cU8nSldRV08xRzF9TydKXVFXTzFHMHFPJ0piUTdbTzw8S3dPJ0ppUTdbTzw8S3dPN2hRN1tPJyNGeE85VVFXTycjRndPQV1RV08nI0VqTyEqZlFeTyw1O3JPITNmUVdPJyNHVE8hM2ZRV08nI0dUTyEzZlFXTycjR1ZPITNmUVdPJyNHVk8hKFNRN1tPNysoXU8hKFNRN1tPNysoXU8lKnlRcE8xRzJxTyUqeVFwTzFHMnFPISZkUTdbTyw1PVZPISZkUTdbTyw1PVZcIixcbiAgc3RhdGVEYXRhOiBcIidLbX5PJ3RPUyd1T1NTT1MndlJRfk9QWU9RWU9SZk9YIVZPYHFPY3pPZHlPbGtPbllPb2tPcGtPdmtPeFlPellPIVBXTyFUa08hVWtPIVtYTyFmdU8ha1pPIW5ZTyFvWU8hcFlPIXJ2TyF0d08hd3hPIXtdTyNzIVBPJFR8TyVifU8lZCFRTyVmIU9PJWchT08laCFPTyVrIVJPJW0hU08lcCFUTyVxIVRPJXMhVU8mUCFXTyZWIVhPJlghWU8mWiFaTyZdIVtPJmAhXU8mZiFeTyZsIV9PJm4hYE8mcCFhTyZyIWJPJnQhY08ne1NPJ31UTyhRVU8oWFZPKGdbTyh0aU9+T1Z0T35QYE9QWU9RWU9SZk9jIWpPZCFpT2xrT25ZT29rT3BrT3ZrT3hZT3pZTyFQV08hVGtPIVVrTyFbIWVPIWZ1TyFrWk8hbllPIW9ZTyFwWU8hcnZPIXQhZ08hdyFoTyRUIWtPJ3shZE8nfVRPKFFVTyhYVk8oZ1tPKHRpT35PYCF2T28hbk8hUCFvTyFfIXhPIWAhdU8hYSF1TyF7OmRPI1AhcE8jUSFwTyNSIXdPI1MhcE8jVCFwTyNXIXlPI1gheU8nfCFsTyd9VE8oUVVPKFshbU8oZyFzT35PJ3Yhek9+T1BbWFpbWGBbWG5bWHxbWH1bWCFQW1ghWVtYIWhbWCFpW1gha1tYIW9bWCNbW1gjZ2VYI2pbWCNrW1gjbFtYI21bWCNuW1gjb1tYI3BbWCNxW1gjcltYI3RbWCN2W1gjeFtYI3lbWCRPW1gncltYKFhbWChoW1gob1tYKHBbWH5PIWQkfFh+UChxT14hfE8nfSNPTyhPIXxPKFAjT09+T14jUE8oUCNPTyhRI09PKFIjUE9+T3QjUk8hUiNTTyhZI1NPKFojVU9+T1BZT1FZT1JmT2Mhak9kIWlPbGtPbllPb2tPcGtPdmtPeFlPellPIVBXTyFUa08hVWtPIVshZU8hZnVPIWtaTyFuWU8hb1lPIXBZTyFydk8hdCFnTyF3IWhPJFQha08nezpoTyd9VE8oUVVPKFhWTyhnW08odGlPfk8hWCNZTyFZI1ZPIVYoX1AhVihsUH5QK31PIVojYk9+UGBPUFlPUVlPUmZPYyFqT2QhaU9uWU9va09wa092a094WU96WU8hUFdPIVRrTyFVa08hWyFlTyFmdU8ha1pPIW5ZTyFvWU8hcFlPIXJ2TyF0IWdPIXchaE8kVCFrTyd9VE8oUVVPKFhWTyhnW08odGlPfk9sI2xPIVgjaE8he11PI2Uja08jZiNoTyd7OmlPIWooaVB+UC5pTyFrI25PJ3sjbU9+TyF3I3JPIXtdTyViI3NPfk8jZyN0T35PIWQjdU8jZyN0T35PUCRdT1okZE9uJFFPfCN5T30jek8hUCN7TyFZJGFPIWgkU08haSN3TyFrI3hPIW8kXU8jaiRPTyNrJFBPI2wkUE8jbSRQTyNuJFJPI28kU08jcCRTTyNxJGNPI3IkU08jdCRUTyN2JFZPI3gkWE8jeSRZTyhYVk8oaCRaTyhvI3xPKHAjfU9+T2AoXVgncihdWCdwKF1YIWooXVghVihdWCFbKF1YJWMoXVghZChdWH5QMXFPI1skZU8kTyRlT1AoXlhaKF5YbiheWHwoXlh9KF5YIVAoXlghWSheWCFoKF5YIWsoXlghbyheWCNqKF5YI2soXlgjbCheWCNtKF5YI24oXlgjbyheWCNwKF5YI3EoXlgjciheWCN0KF5YI3YoXlgjeCheWCN5KF5YKFgoXlgoaCheWChvKF5YKHAoXlghWyheWCVjKF5Yfk9gKF5YIWkoXlgnciheWCdwKF5YIVYoXlghaiheWHIoXlghZCheWH5QNFhPI1skZU9+TyRZJGdPJFskZk8kYyRsT35PUmZPIVskbU8kZiRuTyRoJHBPfk9nJVZPbCVXT24kdE9vJHNPcCRzT3YlWE94JVlPeiVaTyFQJHtPIVskfE8hZiVgTyFrJHhPI2YlYU8kVCVeTyRvJVtPJHElXU8kdCVfTyd7JHJPJ31UTyhRVU8oWCR1TyhvJH1PKHAlUE9mKFVQfk8hayViT35PIVAlZU8hWyVmTyd7JWRPfk8hZCVqT35PYCVrTydyJWtPfk8nfCFsT35QJVtPJWglck9+UCVbT2clVk8hayViTyd7JWRPJ3whbE9+T2QleU8hayViTyd7JWRPfk8jciRTT35PfCZPTyFbJXtPIWslfU8lZCZSTyd7JWRPJ3whbE8nfVRPKFFVT18ofVB+TyF3I3JPfk8lbSZUTyFQKHlYIVsoeVgneyh5WH5PJ3smVU9+TyF0JlpPI3MhUE8lZCFRTyVmIU9PJWchT08laCFPTyVrIVJPJW0hU08lcCFUTyVxIVRPfk9jJmBPZCZfTyF3Jl1PJWImXk8ldSZbT35QO3hPYyZjT2R5TyFbJmJPIXQmWk8hd3hPIXtdTyNzIVBPJWJ9TyVmIU9PJWchT08laCFPTyVrIVJPJW0hU08lcCFUTyVxIVRPJXMhVU9+T2EmZk8jWyZpTyVkJmRPJ3whbE9+UDx9TyFrJmpPIXQmbk9+TyFrI25Pfk8hW1hPfk9gJWtPJ3Emdk8nciVrT35PYCVrTydxJnlPJ3Ila09+T2Ala08ncSZ7TydyJWtPfk8ncFtYIVZbWHJbWCFqW1gmVFtYIVtbWCVjW1ghZFtYflAocU8hXydZTyFgJ1JPIWEnUk8nfCFsTyd9VE8oUVVPfk9vJ1BPIVAnT08hWCdTTyhbJn1PIVooYFAhWihuUH5QQFVPaiddTyFbJ1pPJ3slZE9+T2QnYk8hayViTyd7JWRPfk98Jk9PIWslfU9+T28hbk8hUCFvTyF7OmRPI1AhcE8jUSFwTyNTIXBPI1QhcE8nfCFsTyd9VE8oUVVPKFshbU8oZyFzT35PIV8naE8hYCdnTyFhJ2dPI1IhcE8jVydpTyNYJ2lPflBBcE9gJWtPZyVWTyFkI3VPIWslYk8nciVrTyhoJ2tPfk8hbydvTyNbJ21PflBDT09vIW5PIVAhb08nfVRPKFFVTyhbIW1PKGchc09+TyFbWE9vKGVYIVAoZVghXyhlWCFgKGVYIWEoZVgheyhlWCNQKGVYI1EoZVgjUihlWCNTKGVYI1QoZVgjVyhlWCNYKGVYJ3woZVgnfShlWChRKGVYKFsoZVgoZyhlWH5PIWAnZ08hYSdnTyd8IWxPflBDbk8ndydzTyd4J3NPJ3kndU9+T14hfE8nfSd3TyhPIXxPKFAnd09+T14jUE8oUCd3TyhRJ3dPKFIjUE9+T3QjUk8hUiNTTyhZI1NPKFone09+TyFYJ31PIVYnUFghVidWWCFZJ1BYIVknVlh+UCt9TyFZKFBPIVYoX1h+T1AkXU9aJGRPbiRRT3wjeU99I3pPIVAje08hWShQTyFoJFNPIWkjd08hayN4TyFvJF1PI2okT08jayRQTyNsJFBPI20kUE8jbiRSTyNvJFNPI3AkU08jcSRjTyNyJFNPI3QkVE8jdiRWTyN4JFhPI3kkWU8oWFZPKGgkWk8obyN8TyhwI31Pfk8hVihfWH5QR2JPIVYoVU9+TyFWKGtYIVkoa1ghZChrWCFqKGtYKGgoa1h+TyNbKGtYI2cjYFghWihrWH5QSWhPI1soVk8hVihtWCFZKG1Yfk8hWShXTyFWKGxYfk8hVihaT35PI1skZU9+UEloTyFaKFtPflBgT3wjeU99I3pPIVAje08haSN3TyFrI3hPKFhWT1AhbWFaIW1hbiFtYSFZIW1hIWghbWEhbyFtYSNqIW1hI2shbWEjbCFtYSNtIW1hI24hbWEjbyFtYSNwIW1hI3EhbWEjciFtYSN0IW1hI3YhbWEjeCFtYSN5IW1hKGghbWEobyFtYShwIW1hfk9gIW1hJ3IhbWEncCFtYSFWIW1hIWohbWFyIW1hIVshbWElYyFtYSFkIW1hflBLT08haihdT35PIWQjdU8jWyheTyhoJ2tPIVkoalhgKGpYJ3Ioalh+TyFqKGpYflBNbk8hUCVlTyFbJWZPIXtdTyNlKGNPI2YoYk8neyVkT35PIVkoZE8haihpWH5PIWooZk9+TyFQJWVPIVslZk8jZihiTyd7JWRPfk9QKF5YWiheWG4oXlh8KF5YfSheWCFQKF5YIVkoXlghaCheWCFpKF5YIWsoXlghbyheWCNqKF5YI2soXlgjbCheWCNtKF5YI24oXlgjbyheWCNwKF5YI3EoXlgjciheWCN0KF5YI3YoXlgjeCheWCN5KF5YKFgoXlgoaCheWChvKF5YKHAoXlh+TyFkI3VPIWooXlh+UCEgW098KGdPfShoTyFpI3dPIWsjeE8heyF6YSFQIXphfk8hdyF6YSViIXphIVshemEjZSF6YSNmIXphJ3shemF+UCEjYE8hdyhsT35PUFlPUVlPUmZPYyFqT2QhaU9sa09uWU9va09wa092a094WU96WU8hUFdPIVRrTyFVa08hW1hPIWZ1TyFrWk8hbllPIW9ZTyFwWU8hcnZPIXQhZ08hdyFoTyRUIWtPJ3shZE8nfVRPKFFVTyhYVk8oZ1tPKHRpT35PZyVWT2wlV09uJHRPbyRzT3Akc092JVhPeCVZT3o7UU8hUCR7TyFbJHxPIWY8YE8hayR4TyNmO1dPJFQlXk8kbztTTyRxO1VPJHQlX08neyhwTyd9VE8oUVVPKFgkdU8obyR9TyhwJVBPfk8jZyhyT35PZyVWT2wlV09uJHRPbyRzT3Akc092JVhPeCVZT3olWk8hUCR7TyFbJHxPIWYlYE8hayR4TyNmJWFPJFQlXk8kbyVbTyRxJV1PJHQlX08neyhwTyd9VE8oUVVPKFgkdU8obyR9TyhwJVBPfk9mKGJQflAhKFNPIVgodk8haihjUH5QJVtPKFsoeE8oZ1tPfk8hUCh6TyFrI3hPKFsoeE8oZ1tPfk9QOmNPUTpjT1JmT2M8W09kIWlPbGtPbjpjT29rT3BrT3ZrT3g6Y096OmNPIVBXTyFUa08hVWtPIVshZU8hZjpmTyFrWk8hbjpjTyFvOmNPIXA6Y08hcjpnTyF0OmpPIXchaE8kVCFrTyd7KVlPJ31UTyhRVU8oWFZPKGdbTyh0PFlPfk99KV1PIWsjeE9+TyFZJGFPYCRtYSdyJG1hJ3AkbWEhaiRtYSFWJG1hIVskbWElYyRtYSFkJG1hfk8jcylhT35QISZkT3wpZE8hZCljTyFbJFpYJFckWlgkWSRaWCRbJFpYJGMkWlh+TyFkKWNPIVsocVgkVyhxWCRZKHFYJFsocVgkYyhxWH5PfClkT35QIS5PT3wpZE8hWyhxWCRXKHFYJFkocVgkWyhxWCRjKHFYfk8hWylmTyRXKWpPJFkpZU8kWyllTyRjKWtPfk8hWCluT35QISpmTyRZJGdPJFskZk8kYylyT35PaiR1WHwkdVghUCR1WCFpJHVYKG8kdVgocCR1WH5PZmlYZiR1WGppWCFZaVgjW2lYflAhL3RPbyl0T35PdCl1TyhZKXZPKFopeE9+T2oqUk98KXpPIVApe08obyR9TyhwJVBPfk9mKXlPflAhMH1PZipTT35PZyVWT2wlV09uJHRPbyRzT3Akc092JVhPeCVZT3o7UU8hUCR7TyFbJHxPIWY8YE8hayR4TyNmO1dPJFQlXk8kbztTTyRxO1VPJHQlX08nfVRPKFFVTyhYJHVPKG8kfU8ocCVQT35PIVgqV08neypUTyFqKHVQflAhMWxPI2cqWU9+TyFrKlpPfk8hWCpgTyd7Kl1PIVYodlB+UCExbE9uKmxPIVAqZE8hXypqTyFgKmNPIWEqY08haypaTyNXKmtPJVkqZk8nfCFsTyhbIW1Pfk8hWippT35QITN4TyFpI3dPaihXWHwoV1ghUChXWChvKFdYKHAoV1ghWShXWCNbKFdYfk9mKFdYI3woV1h+UCE0cU9qKnFPI1sqcE9mKFZYIVkoVlh+TyFZKnJPZihVWH5PJ3smVU9mKFVQfk8hayp5T35PJ3socE9+T2wqfU8hUCVlTyFYI2hPIVslZk8he11PI2Uja08jZiNoTyd7JWRPIWooaVB+TyFkI3VPI2crT09+TyFQJWVPIVgrUU8hWShXTyFbJWZPJ3slZE8hVihsUH5PbydWTyFQK1NPIVgrUk8nfVRPKFFVTyhbKHhPfk8hWihuUH5QITdsTyFZK1RPYCh6WCdyKHpYfk9QJF1PWiRkT24kUU98I3lPfSN6TyFQI3tPIWgkU08haSN3TyFrI3hPIW8kXU8jaiRPTyNrJFBPI2wkUE8jbSRQTyNuJFJPI28kU08jcCRTTyNxJGNPI3IkU08jdCRUTyN2JFZPI3gkWE8jeSRZTyhYVk8oaCRaTyhvI3xPKHAjfU9+T2AhZWEhWSFlYSdyIWVhJ3AhZWEhViFlYSFqIWVhciFlYSFbIWVhJWMhZWEhZCFlYX5QIThkT3wjeU99I3pPIVAje08haSN3TyFrI3hPKFhWT1AhcWFaIXFhbiFxYSFZIXFhIWghcWEhbyFxYSNqIXFhI2shcWEjbCFxYSNtIXFhI24hcWEjbyFxYSNwIXFhI3EhcWEjciFxYSN0IXFhI3YhcWEjeCFxYSN5IXFhKGghcWEobyFxYShwIXFhfk9gIXFhJ3IhcWEncCFxYSFWIXFhIWohcWFyIXFhIVshcWElYyFxYSFkIXFhflAhOn1PfCN5T30jek8hUCN7TyFpI3dPIWsjeE8oWFZPUCFzYVohc2FuIXNhIVkhc2EhaCFzYSFvIXNhI2ohc2EjayFzYSNsIXNhI20hc2EjbiFzYSNvIXNhI3Ahc2EjcSFzYSNyIXNhI3Qhc2EjdiFzYSN4IXNhI3khc2EoaCFzYShvIXNhKHAhc2F+T2Ahc2EnciFzYSdwIXNhIVYhc2EhaiFzYXIhc2EhWyFzYSVjIXNhIWQhc2F+UCE9aE9nJVZPaiteTyFbJ1pPJWMrXU9+TyFkK2BPYChUWCFbKFRYJ3IoVFghWShUWH5PYCVrTyFbWE8nciVrT35PZyVWTyFrJWJPfk9nJVZPIWslYk8neyVkT35PIWQjdU8jZyhyT35PYStrTyVkK2xPJ3sraE8nfVRPKFFVTyFaKU9Qfk8hWSttT18ofVh+T1orcU9+T18rck9+TyFbJXtPJ3slZE8nfCFsT18ofVB+T2clVk8jWyt3T35PZyVWT2orek8hWyR8T35PIVsrfE9+T3wsT08hW1hPfk8laCVyT35PIXcsVE9+T2QsWU9+T2EsWk8neyNtTyd9VE8oUVVPIVoofFB+T2QleU9+TyVkIVFPJ3smVU9+UDx9T1osYE9fLF9Pfk9QWU9RWU9SZk9jek9keU9sa09uWU9va09wa092a094WU96WU8hUFdPIVRrTyFVa08hZnVPIWtaTyFuWU8hb1lPIXBZTyFydk8hd3hPIXtdTyVifU8nfVRPKFFVTyhYVk8oZ1tPKHRpT35PIVshZU8hdCFnTyRUIWtPJ3shZE9+UCFEa09fLF9PYCVrTydyJWtPfk9QWU9RWU9SZk9jIWpPZCFpT2xrT25ZT29rT3BrT3ZrT3hZT3pZTyFQV08hVGtPIVVrTyFbIWVPIWZ1TyFrWk8hbllPIW9ZTyFwWU8hcnZPIXchaE8kVCFrTyd7IWRPJ31UTyhRVU8oWFZPKGdbTyh0aU9+T2AsZU8hdHdPI3MhT08lZiFPTyVnIU9PJWghT09+UCFHVE8hayZqT35PJlYsa09+TyFbLG1Pfk8maCxvTyZqLHBPUCZlYVEmZWFSJmVhWCZlYWAmZWFjJmVhZCZlYWwmZWFuJmVhbyZlYXAmZWF2JmVheCZlYXomZWEhUCZlYSFUJmVhIVUmZWEhWyZlYSFmJmVhIWsmZWEhbiZlYSFvJmVhIXAmZWEhciZlYSF0JmVhIXcmZWEheyZlYSNzJmVhJFQmZWElYiZlYSVkJmVhJWYmZWElZyZlYSVoJmVhJWsmZWElbSZlYSVwJmVhJXEmZWElcyZlYSZQJmVhJlYmZWEmWCZlYSZaJmVhJl0mZWEmYCZlYSZmJmVhJmwmZWEmbiZlYSZwJmVhJnImZWEmdCZlYSdwJmVhJ3smZWEnfSZlYShRJmVhKFgmZWEoZyZlYSh0JmVhIVomZWEmXiZlYWEmZWEmYyZlYX5PJ3ssdU9+T2chYlghWSFPWCFZIWJYIVohT1ghWiFiWCFkIU9YIWQhYlghayFiWCNbIU9Yfk8hZCx6TyNbLHlPZyhhWCFZI2RYIVkoYVghWiNkWCFaKGFYIWQoYVghayhhWH5PZyVWTyFkLHxPIWslYk8hWSFeWCFaIV5Yfk9vIW5PIVAhb08nfVRPKFFVTyhbIW1Pfk9QOmNPUTpjT1JmT2M8W09kIWlPbGtPbjpjT29rT3BrT3ZrT3g6Y096OmNPIVBXTyFUa08hVWtPIVshZU8hZjpmTyFrWk8hbjpjTyFvOmNPIXA6Y08hcjpnTyF0OmpPIXchaE8kVCFrTyd9VE8oUVVPKFhWTyhnW08odDxZT35PJ3s7XU9+UCMhWk8hWS1RTyFaKGBYfk8hWi1TT35PIWQsek8jWyx5TyFZI2RYIVojZFh+TyFZLVRPIVooblh+TyFaLVZPfk8hYC1XTyFhLVdPJ3whbE9+UCMgeE8hWi1aT35QJ19Pai1eTyFbJ1pPfk8hVi1jT35PbyF6YSFfIXphIWAhemEhYSF6YSNQIXphI1EhemEjUiF6YSNTIXphI1QhemEjVyF6YSNYIXphJ3whemEnfSF6YShRIXphKFshemEoZyF6YX5QISNgTyFvLWhPI1stZk9+UENPTyFgLWpPIWEtak8nfCFsT35QQ25PYCVrTyNbLWZPJ3Ila09+T2Ala08hZCN1TyNbLWZPJ3Ila09+T2Ala08hZCN1TyFvLWhPI1stZk8nciVrTyhoJ2tPfk8ndydzTyd4J3NPJ3ktb09+T3ItcE9+TyFWJ1BhIVknUGF+UCE4ZE8hWC10TyFWJ1BYIVknUFh+UCVbTyFZKFBPIVYoX2F+TyFWKF9hflBHYk8hWShXTyFWKGxhfk8hUCVlTyFYLXhPIVslZk8neyVkTyFWJ1ZYIVknVlh+TyNbLXpPIVkoamEhaihqYWAoamEncihqYX5PIWQjdU9+UCMqYU8hWShkTyFqKGlhfk8hUCVlTyFbJWZPI2YuT08neyVkT35PbC5UTyFQJWVPIVguUU8hWyVmTyF7XU8jZS5TTyNmLlFPJ3slZE8hWSdZWCFqJ1lYfk99LlhPIWsjeE9+T2clVk9qLltPIVsnWk8lYy5aT35PYCNfaSFZI19pJ3IjX2kncCNfaSFWI19pIWojX2lyI19pIVsjX2klYyNfaSFkI19pflAhOGRPajxmT3wpek8hUCl7TyhvJH1PKHAlUE9+TyNnI1phYCNaYSNbI1phJ3IjWmEhWSNaYSFqI1phIVsjWmEhViNaYX5QIy1dTyNnKFdYUChXWFooV1hgKFdYbihXWH0oV1ghaChXWCFrKFdYIW8oV1gjaihXWCNrKFdYI2woV1gjbShXWCNuKFdYI28oV1gjcChXWCNxKFdYI3IoV1gjdChXWCN2KFdYI3goV1gjeShXWCdyKFdYKFgoV1goaChXWCFqKFdYIVYoV1gncChXWHIoV1ghWyhXWCVjKFdYIWQoV1h+UCE0cU8hWS5pT2YoYlh+UCEwfU9mLmtPfk8hWS5sTyFqKGNYflAhOGRPIWoub09+TyFWLnFPfk9QJF1PfCN5T30jek8hUCN7TyFpI3dPIWsjeE8hbyRdTyhYVk9aI2lpYCNpaW4jaWkhWSNpaSFoI2lpI2sjaWkjbCNpaSNtI2lpI24jaWkjbyNpaSNwI2lpI3EjaWkjciNpaSN0I2lpI3YjaWkjeCNpaSN5I2lpJ3IjaWkoaCNpaShvI2lpKHAjaWkncCNpaSFWI2lpIWojaWlyI2lpIVsjaWklYyNpaSFkI2lpfk8jaiNpaX5QIzFYTyNqJE9PflAjMVhPUCRdT3wjeU99I3pPIVAje08haSN3TyFrI3hPIW8kXU8jaiRPTyNrJFBPI2wkUE8jbSRQTyhYVk9aI2lpYCNpaSFZI2lpIWgjaWkjbiNpaSNvI2lpI3AjaWkjcSNpaSNyI2lpI3QjaWkjdiNpaSN4I2lpI3kjaWknciNpaShoI2lpKG8jaWkocCNpaSdwI2lpIVYjaWkhaiNpaXIjaWkhWyNpaSVjI2lpIWQjaWl+T24jaWl+UCMzeU9uJFFPflAjM3lPUCRdT24kUU98I3lPfSN6TyFQI3tPIWkjd08hayN4TyFvJF1PI2okT08jayRQTyNsJFBPI20kUE8jbiRSTyhYVk9gI2lpIVkjaWkjdCNpaSN2I2lpI3gjaWkjeSNpaSdyI2lpKGgjaWkobyNpaShwI2lpJ3AjaWkhViNpaSFqI2lpciNpaSFbI2lpJWMjaWkhZCNpaX5PWiNpaSFoI2lpI28jaWkjcCNpaSNxI2lpI3IjaWl+UCM2a09aJGRPIWgkU08jbyRTTyNwJFNPI3EkY08jciRTT35QIzZrT1AkXU9aJGRPbiRRT3wjeU99I3pPIVAje08haCRTTyFpI3dPIWsjeE8hbyRdTyNqJE9PI2skUE8jbCRQTyNtJFBPI24kUk8jbyRTTyNwJFNPI3EkY08jciRTTyN0JFRPKFhWTyhwI31PYCNpaSFZI2lpI3gjaWkjeSNpaSdyI2lpKGgjaWkobyNpaSdwI2lpIVYjaWkhaiNpaXIjaWkhWyNpaSVjI2lpIWQjaWl+TyN2JFZPflAjOWxPI3YjaWl+UCM5bE9QJF1PWiRkT24kUU98I3lPfSN6TyFQI3tPIWgkU08haSN3TyFrI3hPIW8kXU8jaiRPTyNrJFBPI2wkUE8jbSRQTyNuJFJPI28kU08jcCRTTyNxJGNPI3IkU08jdCRUTyhYVk9gI2lpIVkjaWkjeCNpaSN5I2lpJ3IjaWkoaCNpaSdwI2lpIVYjaWkhaiNpaXIjaWkhWyNpaSVjI2lpIWQjaWl+TyN2I2lpKG8jaWkocCNpaX5QIzxeTyN2JFZPKG8jfE8ocCN9T35QIzxeT1AkXU9aJGRPbiRRT3wjeU99I3pPIVAje08haCRTTyFpI3dPIWsjeE8hbyRdTyNqJE9PI2skUE8jbCRQTyNtJFBPI24kUk8jbyRTTyNwJFNPI3EkY08jciRTTyN0JFRPI3YkVk8jeCRYTyhYVk8obyN8TyhwI31Pfk9gI2lpIVkjaWkjeSNpaSdyI2lpKGgjaWkncCNpaSFWI2lpIWojaWlyI2lpIVsjaWklYyNpaSFkI2lpflAjP1VPUFtYWltYbltYfFtYfVtYIVBbWCFoW1ghaVtYIWtbWCFvW1gjW1tYI2dlWCNqW1gja1tYI2xbWCNtW1gjbltYI29bWCNwW1gjcVtYI3JbWCN0W1gjdltYI3hbWCN5W1gkT1tYKFhbWChoW1gob1tYKHBbWCFZW1ghWltYfk8jfFtYflAjQW9PUCRdT1o6ek9uOm5PfCN5T30jek8hUCN7TyFoOnBPIWkjd08hayN4TyFvJF1PI2o6bE8jazptTyNsOm1PI206bU8jbjpvTyNvOnBPI3A6cE8jcTp5TyNyOnBPI3Q6cU8jdjpzTyN4OnVPI3k6dk8oWFZPKGgkWk8obyN8TyhwI31Pfk8jfC5zT35QI0N8TyNbOntPJE86e08jfCheWCFaKF5YflAhIFtPYCddYSFZJ11hJ3InXWEncCddYSFqJ11hIVYnXWFyJ11hIVsnXWElYyddYSFkJ11hflAhOGRPUCNpaVojaWlgI2lpbiNpaX0jaWkhWSNpaSFoI2lpIWkjaWkhayNpaSFvI2lpI2ojaWkjayNpaSNsI2lpI20jaWkjbiNpaSNvI2lpI3AjaWkjcSNpaSNyI2lpI3QjaWkjdiNpaSN4I2lpI3kjaWknciNpaShYI2lpKGgjaWkncCNpaSFWI2lpIWojaWlyI2lpIVsjaWklYyNpaSFkI2lpflAjLV1PYCN9aSFZI31pJ3IjfWkncCN9aSFWI31pIWojfWlyI31pIVsjfWklYyN9aSFkI31pflAhOGRPJFkueE8kWy54T35PJFkueU8kWy55T35PIWQpY08jWy56TyFbJGBYJFckYFgkWSRgWCRbJGBYJGMkYFh+TyFYLntPfk8hWylmTyRXLn1PJFkpZU8kWyllTyRjL09Pfk8hWTp3TyFaKF1YflAjQ3xPIVovUE9+TyFkKWNPJGMocVh+TyRjL1JPfk90KXVPKFkpdk8oWi9VT35PIVYvWU9+UCEmZE8obyR9T2olWmF8JVphIVAlWmEocCVaYSFZJVphI1slWmF+T2YlWmEjfCVaYX5QI0xeTyhwJVBPaiVdYXwlXWEhUCVdYShvJV1hIVklXWEjWyVdYX5PZiVdYSN8JV1hflAjTVBPIVllWCFkZVghamVYIWokdVgoaGVYflAhL3RPIWovYk9+UCMtXU8hWS9jTyFkI3VPKGgna08haih1WH5PIWovaE9+TyFYKldPJ3slZE8haih1UH5PI2cvak9+TyFWJHVYIVkkdVghZCR8WH5QIS90TyFZL2tPIVYodlh+UCMtXU8hZC9tT35PIVYvb09+T2clVk9uL3NPIWQjdU8hayViTyhoJ2tPfk8ney91T35PIWQrYE9+T2Ala08hWS95TydyJWtPfk8hWi97T35QITN4TyFgL3xPIWEvfE8nfCFsTyhbIW1Pfk8hUDBPTyhbIW1Pfk8jVzBQT35PZiVaYSFZJVphI1slWmEjfCVaYX5QITB9T2YlXWEhWSVdYSNbJV1hI3wlXWF+UCEwfU8neyZVT2YnZlghWSdmWH5PIVkqck9mKFVhfk9mMFlPfk98MFpPfTBaTyFQMFtPanlhKG95YShweWEhWXlhI1t5YX5PZnlhI3x5YX5QJCRqT3wpek8hUCl7T2okbmEobyRuYShwJG5hIVkkbmEjWyRuYX5PZiRuYSN8JG5hflAkJWBPfCl6TyFQKXtPaiRwYShvJHBhKHAkcGEhWSRwYSNbJHBhfk9mJHBhI3wkcGF+UCQmUk8jZzBeT35PZiVPYSFZJU9hI1slT2EjfCVPYX5QITB9TyFkI3VPfk8jZzBhT35PIVkrVE9gKHphJ3IoemF+T3wjeU99I3pPIVAje08haSN3TyFrI3hPKFhWT1AhcWlaIXFpbiFxaSFZIXFpIWghcWkhbyFxaSNqIXFpI2shcWkjbCFxaSNtIXFpI24hcWkjbyFxaSNwIXFpI3EhcWkjciFxaSN0IXFpI3YhcWkjeCFxaSN5IXFpKGghcWkobyFxaShwIXFpfk9gIXFpJ3IhcWkncCFxaSFWIXFpIWohcWlyIXFpIVshcWklYyFxaSFkIXFpflAkJ3BPZyVWT24kdE9vJHNPcCRzT3YlWE94JVlPejtRTyFQJHtPIVskfE8hZjxgTyFrJHhPI2Y7V08kVCVeTyRvO1NPJHE7VU8kdCVfTyd9VE8oUVVPKFgkdU8obyR9TyhwJVBPfk9sMGtPJ3swak9+UCQqWk8hZCtgT2AoVGEhWyhUYSdyKFRhIVkoVGF+TyNnMHFPfk9aW1ghWWVYIVplWH5PIVkwck8hWilPWH5PIVowdE9+T1owdU9+T2Ewd08neytoTyd9VE8oUVVPfk8hWyV7Tyd7JWRPXyduWCFZJ25Yfk8hWSttT18ofWF+TyFqMHpPflAhOGRPWjB9T35PXzFPT35PI1sxUk9+T2oxVU8hWyR8T35PKFsoeE8hWih7UH5PZyVWT2oxX08hWzFbTyVjMV5Pfk9aMWlPIVkxZ08hWih8WH5PIVoxak9+T18xbE9gJWtPJ3Ila09+Tyd7I21PJ31UTyhRVU9+TyNbJGVPJE8kZU9QKF5YWiheWG4oXlh8KF5YfSheWCFQKF5YIVkoXlghaCheWCFrKF5YIW8oXlgjaiheWCNrKF5YI2woXlgjbSheWCNuKF5YI28oXlgjcCheWCNxKF5YI3QoXlgjdiheWCN4KF5YI3koXlgoWCheWChoKF5YKG8oXlgocCheWH5PI3Ixb08mVDFwT2AoXlghaSheWH5QJC9xTyNbJGVPI3Ixb08mVDFwT35PYDFyT35QJVtPYDF0T35PJl4xd09QJltpUSZbaVImW2lYJltpYCZbaWMmW2lkJltpbCZbaW4mW2lvJltpcCZbaXYmW2l4JltpeiZbaSFQJltpIVQmW2khVSZbaSFbJltpIWYmW2khayZbaSFuJltpIW8mW2khcCZbaSFyJltpIXQmW2khdyZbaSF7JltpI3MmW2kkVCZbaSViJltpJWQmW2klZiZbaSVnJltpJWgmW2klayZbaSVtJltpJXAmW2klcSZbaSVzJltpJlAmW2kmViZbaSZYJltpJlomW2kmXSZbaSZgJltpJmYmW2kmbCZbaSZuJltpJnAmW2kmciZbaSZ0JltpJ3AmW2kneyZbaSd9JltpKFEmW2koWCZbaShnJltpKHQmW2khWiZbaWEmW2kmYyZbaX5PYTF9TyFaMXtPJmMxfE9+UGBPIVtYTyFrMlBPfk8maixwT1AmZWlRJmVpUiZlaVgmZWlgJmVpYyZlaWQmZWlsJmVpbiZlaW8mZWlwJmVpdiZlaXgmZWl6JmVpIVAmZWkhVCZlaSFVJmVpIVsmZWkhZiZlaSFrJmVpIW4mZWkhbyZlaSFwJmVpIXImZWkhdCZlaSF3JmVpIXsmZWkjcyZlaSRUJmVpJWImZWklZCZlaSVmJmVpJWcmZWklaCZlaSVrJmVpJW0mZWklcCZlaSVxJmVpJXMmZWkmUCZlaSZWJmVpJlgmZWkmWiZlaSZdJmVpJmAmZWkmZiZlaSZsJmVpJm4mZWkmcCZlaSZyJmVpJnQmZWkncCZlaSd7JmVpJ30mZWkoUSZlaShYJmVpKGcmZWkodCZlaSFaJmVpJl4mZWlhJmVpJmMmZWl+TyFWMlZPfk8hWSFeYSFaIV5hflAjQ3xPbyFuTyFQIW9PIVgyXU8oWyFtTyFZJ1FYIVonUVh+UEBVTyFZLVFPIVooYGF+TyFZJ1dYIVonV1h+UCE3bE8hWS1UTyFaKG5hfk8hWjJkT35QJ19PYCVrTyNbMm1PJ3Ila09+T2Ala08hZCN1TyNbMm1PJ3Ila09+T2Ala08hZCN1TyFvMnFPI1sybU8nciVrTyhoJ2tPfk9gJWtPJ3Ila09+UCE4ZE8hWSRhT3IkbWF+TyFWJ1BpIVknUGl+UCE4ZE8hWShQTyFWKF9pfk8hWShXTyFWKGxpfk8hVihtaSFZKG1pflAhOGRPIVkoamkhaihqaWAoamkncihqaX5QIThkTyNbMnNPIVkoamkhaihqaWAoamkncihqaX5PIVkoZE8haihpaX5PIVAlZU8hWyVmTyF7XU8jZTJ4TyNmMndPJ3slZE9+TyFQJWVPIVslZk8jZjJ3Tyd7JWRPfk9qM1BPIVsnWk8lYzNPT35PZyVWT2ozUE8hWydaTyVjM09Pfk8jZyVaYVAlWmFaJVphYCVaYW4lWmF9JVphIWglWmEhaSVaYSFrJVphIW8lWmEjaiVaYSNrJVphI2wlWmEjbSVaYSNuJVphI28lWmEjcCVaYSNxJVphI3IlWmEjdCVaYSN2JVphI3glWmEjeSVaYSdyJVphKFglWmEoaCVaYSFqJVphIVYlWmEncCVaYXIlWmEhWyVaYSVjJVphIWQlWmF+UCNMXk8jZyVdYVAlXWFaJV1hYCVdYW4lXWF9JV1hIWglXWEhaSVdYSFrJV1hIW8lXWEjaiVdYSNrJV1hI2wlXWEjbSVdYSNuJV1hI28lXWEjcCVdYSNxJV1hI3IlXWEjdCVdYSN2JV1hI3glXWEjeSVdYSdyJV1hKFglXWEoaCVdYSFqJV1hIVYlXWEncCVdYXIlXWEhWyVdYSVjJV1hIWQlXWF+UCNNUE8jZyVaYVAlWmFaJVphYCVaYW4lWmF9JVphIVklWmEhaCVaYSFpJVphIWslWmEhbyVaYSNqJVphI2slWmEjbCVaYSNtJVphI24lWmEjbyVaYSNwJVphI3ElWmEjciVaYSN0JVphI3YlWmEjeCVaYSN5JVphJ3IlWmEoWCVaYShoJVphIWolWmEhViVaYSdwJVphI1slWmFyJVphIVslWmElYyVaYSFkJVphflAjLV1PI2clXWFQJV1hWiVdYWAlXWFuJV1hfSVdYSFZJV1hIWglXWEhaSVdYSFrJV1hIW8lXWEjaiVdYSNrJV1hI2wlXWEjbSVdYSNuJV1hI28lXWEjcCVdYSNxJV1hI3IlXWEjdCVdYSN2JV1hI3glXWEjeSVdYSdyJV1hKFglXWEoaCVdYSFqJV1hIVYlXWEncCVdYSNbJV1hciVdYSFbJV1hJWMlXWEhZCVdYX5QIy1dTyNneWFQeWFaeWFgeWFueWEhaHlhIWl5YSFreWEhb3lhI2p5YSNreWEjbHlhI215YSNueWEjb3lhI3B5YSNxeWEjcnlhI3R5YSN2eWEjeHlhI3l5YSdyeWEoWHlhKGh5YSFqeWEhVnlhJ3B5YXJ5YSFbeWElY3lhIWR5YX5QJCRqTyNnJG5hUCRuYVokbmFgJG5hbiRuYX0kbmEhaCRuYSFpJG5hIWskbmEhbyRuYSNqJG5hI2skbmEjbCRuYSNtJG5hI24kbmEjbyRuYSNwJG5hI3EkbmEjciRuYSN0JG5hI3YkbmEjeCRuYSN5JG5hJ3IkbmEoWCRuYShoJG5hIWokbmEhViRuYSdwJG5hciRuYSFbJG5hJWMkbmEhZCRuYX5QJCVgTyNnJHBhUCRwYVokcGFgJHBhbiRwYX0kcGEhaCRwYSFpJHBhIWskcGEhbyRwYSNqJHBhI2skcGEjbCRwYSNtJHBhI24kcGEjbyRwYSNwJHBhI3EkcGEjciRwYSN0JHBhI3YkcGEjeCRwYSN5JHBhJ3IkcGEoWCRwYShoJHBhIWokcGEhViRwYSdwJHBhciRwYSFbJHBhJWMkcGEhZCRwYX5QJCZSTyNnJU9hUCVPYVolT2FgJU9hbiVPYX0lT2EhWSVPYSFoJU9hIWklT2EhayVPYSFvJU9hI2olT2EjayVPYSNsJU9hI20lT2EjbiVPYSNvJU9hI3AlT2EjcSVPYSNyJU9hI3QlT2EjdiVPYSN4JU9hI3klT2EnciVPYShYJU9hKGglT2EhaiVPYSFWJU9hJ3AlT2EjWyVPYXIlT2EhWyVPYSVjJU9hIWQlT2F+UCMtXU9gI19xIVkjX3EnciNfcSdwI19xIVYjX3EhaiNfcXIjX3EhWyNfcSVjI19xIWQjX3F+UCE4ZE9mJ1JYIVknUlh+UCEoU08hWS5pT2YoYmF+TyFYM1pPIVknU1ghaidTWH5QJVtPIVkubE8haihjYX5PIVkubE8haihjYX5QIThkTyFWM15Pfk8jfCFtYSFaIW1hflBLT08jfCFlYSFZIWVhIVohZWF+UCNDfE8jfCFxYSFaIXFhflAhOn1PI3whc2EhWiFzYX5QIT1oT1JmTyFbM3BPJGEzcU9+TyFaM3VPfk9yM3ZPflAjLV1PYCRqcSFZJGpxJ3IkanEncCRqcSFWJGpxIWokanFyJGpxIVskanElYyRqcSFkJGpxflAhOGRPIVYzd09+UCMtXU98KXpPIVApe08ocCVQT2onYmEobydiYSFZJ2JhI1snYmF+T2YnYmEjfCdiYX5QJSllT3wpek8hUCl7T2onZGEobydkYShwJ2RhIVknZGEjWydkYX5PZidkYSN8J2RhflAlKldPKGgkWk9+UCMtXU8hWDN6Tyd7JWRPIVknXlghaideWH5PIVkvY08haih1YX5PIVkvY08hZCN1TyFqKHVhfk8hWS9jTyFkI3VPKGgna08haih1YX5PZiR3aSFZJHdpI1skd2kjfCR3aX5QITB9TyFYNFNPJ3sqXU8hVidgWCFZJ2BYflAhMWxPIVkva08hVih2YX5PIVkva08hVih2YX5QIy1dTyFkI3VPI3I0W09+T240X08hZCN1TyhoJ2tPfk8obyR9T2olWml8JVppIVAlWmkocCVaaSFZJVppI1slWml+T2YlWmkjfCVaaX5QJS1qTyhwJVBPaiVdaXwlXWkhUCVdaShvJV1pIVklXWkjWyVdaX5PZiVdaSN8JV1pflAlLl1PZihWaSFZKFZpflAhMH1PI1s0Zk9mKFZpIVkoVml+UCEwfU8hajRpT35PYCRrcSFZJGtxJ3Ika3EncCRrcSFWJGtxIWoka3FyJGtxIVska3ElYyRrcSFkJGtxflAhOGRPIVY0bU9+TyFZNG5PIVsod1h+UCMtXU8haSN3T35QNFhPYCR1WCFbJHVYJVdbWCdyJHVYIVkkdVh+UCEvdE8lVzRwT2BrWGprWHxrWCFQa1ghW2tYJ3JrWChva1gocGtYIVlrWH5PJVc0cE9+T2E0dk8lZDR3Tyd7K2hPJ31UTyhRVU8hWSdtWCFaJ21Yfk8hWTByTyFaKU9hfk9aNHtPfk9fNHxPfk9gJWtPJ3Ila09+UCMtXU8hWyR8T35QIy1dTyFZNVVPI1s1V08hWih7WH5PIVo1WE9+T28hbk8hUDVZTyFfIXhPIWAhdU8hYSF1TyF7OmRPI1AhcE8jUSFwTyNSIXBPI1MhcE8jVCFwTyNXNV9PI1gheU8nfCFsTyd9VE8oUVVPKFshbU8oZyFzT35PIVo1Xk9+UCUzbk9qNWRPIVsxW08lYzVjT35PZyVWT2o1ZE8hWzFbTyVjNWNPfk9hNWtPJ3sjbU8nfVRPKFFVTyFZJ2xYIVonbFh+TyFZMWdPIVoofGF+Tyd9VE8oUVVPKFs1bU9+T181cU9+TyNyNXRPJlQ1dU9+UE1uTyFqNXZPflAlW09gNXhPfk9gNXhPflAlW09hMX1PIVo1fU8mYzF8T35QYE8hZDZQT35PIWQ2Uk9nKGFpIVkoYWkhWihhaSFkKGFpIWsoYWl+TyFZI2RpIVojZGl+UCNDfE8jWzZTTyFZI2RpIVojZGl+TyFZIV5pIVohXml+UCNDfE9gJWtPI1s2XU8nciVrT35PYCVrTyFkI3VPI1s2XU8nciVrT35PIVkoanEhaihqcWAoanEncihqcX5QIThkTyFZKGRPIWooaXF+TyFQJWVPIVslZk8jZjZkTyd7JWRPfk8hWydaTyVjNmdPfk9qNmpPIVsnWk8lYzZnT35PI2cnYmFQJ2JhWidiYWAnYmFuJ2JhfSdiYSFoJ2JhIWknYmEhaydiYSFvJ2JhI2onYmEjaydiYSNsJ2JhI20nYmEjbidiYSNvJ2JhI3AnYmEjcSdiYSNyJ2JhI3QnYmEjdidiYSN4J2JhI3knYmEncidiYShYJ2JhKGgnYmEhaidiYSFWJ2JhJ3AnYmFyJ2JhIVsnYmElYydiYSFkJ2JhflAlKWVPI2cnZGFQJ2RhWidkYWAnZGFuJ2RhfSdkYSFoJ2RhIWknZGEhaydkYSFvJ2RhI2onZGEjaydkYSNsJ2RhI20nZGEjbidkYSNvJ2RhI3AnZGEjcSdkYSNyJ2RhI3QnZGEjdidkYSN4J2RhI3knZGEncidkYShYJ2RhKGgnZGEhaidkYSFWJ2RhJ3AnZGFyJ2RhIVsnZGElYydkYSFkJ2RhflAlKldPI2ckd2lQJHdpWiR3aWAkd2luJHdpfSR3aSFZJHdpIWgkd2khaSR3aSFrJHdpIW8kd2kjaiR3aSNrJHdpI2wkd2kjbSR3aSNuJHdpI28kd2kjcCR3aSNxJHdpI3Ikd2kjdCR3aSN2JHdpI3gkd2kjeSR3aSdyJHdpKFgkd2koaCR3aSFqJHdpIVYkd2kncCR3aSNbJHdpciR3aSFbJHdpJWMkd2khZCR3aX5QIy1dTyNnJVppUCVaaVolWmlgJVppbiVaaX0lWmkhaCVaaSFpJVppIWslWmkhbyVaaSNqJVppI2slWmkjbCVaaSNtJVppI24lWmkjbyVaaSNwJVppI3ElWmkjciVaaSN0JVppI3YlWmkjeCVaaSN5JVppJ3IlWmkoWCVaaShoJVppIWolWmkhViVaaSdwJVppciVaaSFbJVppJWMlWmkhZCVaaX5QJS1qTyNnJV1pUCVdaVolXWlgJV1pbiVdaX0lXWkhaCVdaSFpJV1pIWslXWkhbyVdaSNqJV1pI2slXWkjbCVdaSNtJV1pI24lXWkjbyVdaSNwJV1pI3ElXWkjciVdaSN0JV1pI3YlXWkjeCVdaSN5JV1pJ3IlXWkoWCVdaShoJV1pIWolXWkhViVdaSdwJV1pciVdaSFbJV1pJWMlXWkhZCVdaX5QJS5dT2YnUmEhWSdSYX5QITB9TyFZJ1NhIWonU2F+UCE4ZE8hWS5sTyFqKGNpfk8jfCNfaSFZI19pIVojX2l+UCNDfE9QJF1PfCN5T30jek8hUCN7TyFpI3dPIWsjeE8hbyRdTyhYVk9aI2lpbiNpaSFoI2lpI2sjaWkjbCNpaSNtI2lpI24jaWkjbyNpaSNwI2lpI3EjaWkjciNpaSN0I2lpI3YjaWkjeCNpaSN5I2lpI3wjaWkoaCNpaShvI2lpKHAjaWkhWSNpaSFaI2lpfk8jaiNpaX5QJUZuTyNqOmxPflAlRm5PUCRdT3wjeU99I3pPIVAje08haSN3TyFrI3hPIW8kXU8jajpsTyNrOm1PI2w6bU8jbTptTyhYVk9aI2lpIWgjaWkjbiNpaSNvI2lpI3AjaWkjcSNpaSNyI2lpI3QjaWkjdiNpaSN4I2lpI3kjaWkjfCNpaShoI2lpKG8jaWkocCNpaSFZI2lpIVojaWl+T24jaWl+UCVIeU9uOm5PflAlSHlPUCRdT246bk98I3lPfSN6TyFQI3tPIWkjd08hayN4TyFvJF1PI2o6bE8jazptTyNsOm1PI206bU8jbjpvTyhYVk8jdCNpaSN2I2lpI3gjaWkjeSNpaSN8I2lpKGgjaWkobyNpaShwI2lpIVkjaWkhWiNpaX5PWiNpaSFoI2lpI28jaWkjcCNpaSNxI2lpI3IjaWl+UCVLVU9aOnpPIWg6cE8jbzpwTyNwOnBPI3E6eU8jcjpwT35QJUtVT1AkXU9aOnpPbjpuT3wjeU99I3pPIVAje08haDpwTyFpI3dPIWsjeE8hbyRdTyNqOmxPI2s6bU8jbDptTyNtOm1PI246b08jbzpwTyNwOnBPI3E6eU8jcjpwTyN0OnFPKFhWTyhwI31PI3gjaWkjeSNpaSN8I2lpKGgjaWkobyNpaSFZI2lpIVojaWl+TyN2OnNPflAlTXBPI3YjaWl+UCVNcE9QJF1PWjp6T246bk98I3lPfSN6TyFQI3tPIWg6cE8haSN3TyFrI3hPIW8kXU8jajpsTyNrOm1PI2w6bU8jbTptTyNuOm9PI286cE8jcDpwTyNxOnlPI3I6cE8jdDpxTyhYVk8jeCNpaSN5I2lpI3wjaWkoaCNpaSFZI2lpIVojaWl+TyN2I2lpKG8jaWkocCNpaX5QJiB7TyN2OnNPKG8jfE8ocCN9T35QJiB7T1AkXU9aOnpPbjpuT3wjeU99I3pPIVAje08haDpwTyFpI3dPIWsjeE8hbyRdTyNqOmxPI2s6bU8jbDptTyNtOm1PI246b08jbzpwTyNwOnBPI3E6eU8jcjpwTyN0OnFPI3Y6c08jeDp1TyhYVk8obyN8TyhwI31Pfk8jeSNpaSN8I2lpKGgjaWkhWSNpaSFaI2lpflAmJF5PYCN6eSFZI3p5J3IjenkncCN6eSFWI3p5IWojenlyI3p5IVsjenklYyN6eSFkI3p5flAhOGRPajxnT3wpek8hUCl7TyhvJH1PKHAlUE9+T1AjaWlaI2lpbiNpaX0jaWkhaCNpaSFpI2lpIWsjaWkhbyNpaSNqI2lpI2sjaWkjbCNpaSNtI2lpI24jaWkjbyNpaSNwI2lpI3EjaWkjciNpaSN0I2lpI3YjaWkjeCNpaSN5I2lpI3wjaWkoWCNpaShoI2lpIVkjaWkhWiNpaX5QJidVTyFpI3dPUChXWFooV1hqKFdYbihXWHwoV1h9KFdYIVAoV1ghaChXWCFrKFdYIW8oV1gjaihXWCNrKFdYI2woV1gjbShXWCNuKFdYI28oV1gjcChXWCNxKFdYI3IoV1gjdChXWCN2KFdYI3goV1gjeShXWCN8KFdYKFgoV1goaChXWChvKFdYKHAoV1ghWShXWCFaKFdYfk8jfCN9aSFZI31pIVojfWl+UCNDfE8jfCFxaSFaIXFpflAkJ3BPIVo2fE9+TyFZJ11hIVonXWF+UCNDfE8hZCN1TyhoJ2tPIVknXmEhaideYX5PIVkvY08haih1aX5PIVkvY08hZCN1TyFqKHVpfk9mJHdxIVkkd3EjWyR3cSN8JHdxflAhMH1PIVYnYGEhWSdgYX5QIy1dTyFkN1RPfk8hWS9rTyFWKHZpflAjLV1PIVkva08hVih2aX5PIVY3WE9+TyFkI3VPI3I3Xk9+T243X08hZCN1TyhoJ2tPfk98KXpPIVApe08ocCVQT2onY2EobydjYSFZJ2NhI1snY2F+T2YnY2EjfCdjYX5QJi5mT3wpek8hUCl7T2onZWEobydlYShwJ2VhIVknZWEjWydlYX5PZidlYSN8J2VhflAmL1hPIVY3YU9+T2YkeXEhWSR5cSNbJHlxI3wkeXF+UCEwfU9gJGt5IVkka3knciRreSdwJGt5IVYka3khaiRreXIka3khWyRreSVjJGt5IWQka3l+UCE4ZE8hZDZST35PIVk0bk8hWyh3YX5PYCNfeSFZI195J3IjX3kncCNfeSFWI195IWojX3lyI195IVsjX3klYyNfeSFkI195flAhOGRPWjdmT35PYTdoTyd7K2hPJ31UTyhRVU9+TyFZMHJPIVopT2l+T183bE9+TyhbKHhPIVknaVghWidpWH5PIVk1VU8hWih7YX5PbGtPJ3s3c09+UC5pTyFaN3ZPflAlM25PbyFuTyFQN3dPJ31UTyhRVU8oWyFtTyhnIXNPfk8hWzFbT35PIVsxW08lYzd5T35Pajd8TyFbMVtPJWM3eU9+T1o4Uk8hWSdsYSFaJ2xhfk8hWTFnTyFaKHxpfk8hajhWT35PIWo4V09+TyFqOFpPfk8hajhaT35QJVtPYDhdT35PIWQ4Xk9+TyFqOF9Pfk8hWShtaSFaKG1pflAjQ3xPYCVrTyNbOGdPJ3Ila09+TyFZKGp5IWooanlgKGp5J3Ioanl+UCE4ZE8hWShkTyFqKGl5fk8hWydaTyVjOGpPfk8jZyR3cVAkd3FaJHdxYCR3cW4kd3F9JHdxIVkkd3EhaCR3cSFpJHdxIWskd3EhbyR3cSNqJHdxI2skd3EjbCR3cSNtJHdxI24kd3EjbyR3cSNwJHdxI3Ekd3EjciR3cSN0JHdxI3Ykd3EjeCR3cSN5JHdxJ3Ikd3EoWCR3cShoJHdxIWokd3EhViR3cSdwJHdxI1skd3FyJHdxIVskd3ElYyR3cSFkJHdxflAjLV1PI2cnY2FQJ2NhWidjYWAnY2FuJ2NhfSdjYSFoJ2NhIWknY2EhaydjYSFvJ2NhI2onY2EjaydjYSNsJ2NhI20nY2EjbidjYSNvJ2NhI3AnY2EjcSdjYSNyJ2NhI3QnY2EjdidjYSN4J2NhI3knY2EncidjYShYJ2NhKGgnY2EhaidjYSFWJ2NhJ3AnY2FyJ2NhIVsnY2ElYydjYSFkJ2NhflAmLmZPI2cnZWFQJ2VhWidlYWAnZWFuJ2VhfSdlYSFoJ2VhIWknZWEhaydlYSFvJ2VhI2onZWEjaydlYSNsJ2VhI20nZWEjbidlYSNvJ2VhI3AnZWEjcSdlYSNyJ2VhI3QnZWEjdidlYSN4J2VhI3knZWEncidlYShYJ2VhKGgnZWEhaidlYSFWJ2VhJ3AnZWFyJ2VhIVsnZWElYydlYSFkJ2VhflAmL1hPI2ckeXFQJHlxWiR5cWAkeXFuJHlxfSR5cSFZJHlxIWgkeXEhaSR5cSFrJHlxIW8keXEjaiR5cSNrJHlxI2wkeXEjbSR5cSNuJHlxI28keXEjcCR5cSNxJHlxI3IkeXEjdCR5cSN2JHlxI3gkeXEjeSR5cSdyJHlxKFgkeXEoaCR5cSFqJHlxIVYkeXEncCR5cSNbJHlxciR5cSFbJHlxJWMkeXEhZCR5cX5QIy1dTyFZJ1NpIWonU2l+UCE4ZE8jfCNfcSFZI19xIVojX3F+UCNDfE8obyR9T1AlWmFaJVphbiVaYX0lWmEhaCVaYSFpJVphIWslWmEhbyVaYSNqJVphI2slWmEjbCVaYSNtJVphI24lWmEjbyVaYSNwJVphI3ElWmEjciVaYSN0JVphI3YlWmEjeCVaYSN5JVphI3wlWmEoWCVaYShoJVphIVklWmEhWiVaYX5PaiVaYXwlWmEhUCVaYShwJVphflAmQG5PKHAlUE9QJV1hWiVdYW4lXWF9JV1hIWglXWEhaSVdYSFrJV1hIW8lXWEjaiVdYSNrJV1hI2wlXWEjbSVdYSNuJV1hI28lXWEjcCVdYSNxJV1hI3IlXWEjdCVdYSN2JV1hI3glXWEjeSVdYSN8JV1hKFglXWEoaCVdYSFZJV1hIVolXWF+T2olXWF8JV1hIVAlXWEobyVdYX5QJkJ1T2o8Z098KXpPIVApe08ocCVQT35QJkBuT2o8Z098KXpPIVApe08obyR9T35QJkJ1T3wwWk99MFpPIVAwW09QeWFaeWFqeWFueWEhaHlhIWl5YSFreWEhb3lhI2p5YSNreWEjbHlhI215YSNueWEjb3lhI3B5YSNxeWEjcnlhI3R5YSN2eWEjeHlhI3l5YSN8eWEoWHlhKGh5YShveWEocHlhIVl5YSFaeWF+T3wpek8hUCl7T1AkbmFaJG5haiRuYW4kbmF9JG5hIWgkbmEhaSRuYSFrJG5hIW8kbmEjaiRuYSNrJG5hI2wkbmEjbSRuYSNuJG5hI28kbmEjcCRuYSNxJG5hI3IkbmEjdCRuYSN2JG5hI3gkbmEjeSRuYSN8JG5hKFgkbmEoaCRuYShvJG5hKHAkbmEhWSRuYSFaJG5hfk98KXpPIVApe09QJHBhWiRwYWokcGFuJHBhfSRwYSFoJHBhIWkkcGEhayRwYSFvJHBhI2okcGEjayRwYSNsJHBhI20kcGEjbiRwYSNvJHBhI3AkcGEjcSRwYSNyJHBhI3QkcGEjdiRwYSN4JHBhI3kkcGEjfCRwYShYJHBhKGgkcGEobyRwYShwJHBhIVkkcGEhWiRwYX5PUCVPYVolT2FuJU9hfSVPYSFoJU9hIWklT2EhayVPYSFvJU9hI2olT2EjayVPYSNsJU9hI20lT2EjbiVPYSNvJU9hI3AlT2EjcSVPYSNyJU9hI3QlT2EjdiVPYSN4JU9hI3klT2EjfCVPYShYJU9hKGglT2EhWSVPYSFaJU9hflAmJ1VPI3wkanEhWSRqcSFaJGpxflAjQ3xPI3wka3EhWSRrcSFaJGtxflAjQ3xPIVo4dk9+TyN8OHdPflAhMH1PIWQjdU8hWSdeaSFqJ15pfk8hZCN1TyhoJ2tPIVknXmkhaideaX5PIVkvY08haih1cX5PIVYnYGkhWSdgaX5QIy1dTyFZL2tPIVYodnF+TyFWOH1PflAjLV1PIVY4fU9+T2YoVnkhWShWeX5QITB9TyFZJ2dhIVsnZ2F+UCMtXU9gJVZxIVslVnEnciVWcSFZJVZxflAjLV1PWjlTT35PIVkwck8hWilPcX5PI1s5V08hWSdpYSFaJ2lhfk8hWTVVTyFaKHtpflAjQ3xPUFtYWltYbltYfFtYfVtYIVBbWCFWW1ghWVtYIWhbWCFpW1gha1tYIW9bWCNbW1gjZ2VYI2pbWCNrW1gjbFtYI21bWCNuW1gjb1tYI3BbWCNxW1gjcltYI3RbWCN2W1gjeFtYI3lbWCRPW1goWFtYKGhbWChvW1gocFtYfk8hZCVUWCNyJVRYflAnI2BPIVsxW08lYzlbT35PJ31UTyhRVU8oWzlhT35PIVkxZ08hWih8cX5PIWo5ZE9+TyFqOWVPfk8hajlmT35PIWo5Zk9+UCVbTyNbOWlPIVkjZHkhWiNkeX5PIVkjZHkhWiNkeX5QI0N8TyFbJ1pPJWM5bk9+TyN8I3p5IVkjenkhWiN6eX5QI0N8T1Akd2laJHdpbiR3aX0kd2khaCR3aSFpJHdpIWskd2khbyR3aSNqJHdpI2skd2kjbCR3aSNtJHdpI24kd2kjbyR3aSNwJHdpI3Ekd2kjciR3aSN0JHdpI3Ykd2kjeCR3aSN5JHdpI3wkd2koWCR3aShoJHdpIVkkd2khWiR3aX5QJidVT3wpek8hUCl7TyhwJVBPUCdiYVonYmFqJ2JhbidiYX0nYmEhaCdiYSFpJ2JhIWsnYmEhbydiYSNqJ2JhI2snYmEjbCdiYSNtJ2JhI24nYmEjbydiYSNwJ2JhI3EnYmEjcidiYSN0J2JhI3YnYmEjeCdiYSN5J2JhI3wnYmEoWCdiYShoJ2JhKG8nYmEhWSdiYSFaJ2Jhfk98KXpPIVApe09QJ2RhWidkYWonZGFuJ2RhfSdkYSFoJ2RhIWknZGEhaydkYSFvJ2RhI2onZGEjaydkYSNsJ2RhI20nZGEjbidkYSNvJ2RhI3AnZGEjcSdkYSNyJ2RhI3QnZGEjdidkYSN4J2RhI3knZGEjfCdkYShYJ2RhKGgnZGEobydkYShwJ2RhIVknZGEhWidkYX5PKG8kfU9QJVppWiVaaWolWmluJVppfCVaaX0lWmkhUCVaaSFoJVppIWklWmkhayVaaSFvJVppI2olWmkjayVaaSNsJVppI20lWmkjbiVaaSNvJVppI3AlWmkjcSVaaSNyJVppI3QlWmkjdiVaaSN4JVppI3klWmkjfCVaaShYJVppKGglWmkocCVaaSFZJVppIVolWml+TyhwJVBPUCVdaVolXWlqJV1pbiVdaXwlXWl9JV1pIVAlXWkhaCVdaSFpJV1pIWslXWkhbyVdaSNqJV1pI2slXWkjbCVdaSNtJV1pI24lXWkjbyVdaSNwJV1pI3ElXWkjciVdaSN0JV1pI3YlXWkjeCVdaSN5JV1pI3wlXWkoWCVdaShoJV1pKG8lXWkhWSVdaSFaJV1pfk8jfCRreSFZJGt5IVoka3l+UCNDfE8jfCNfeSFZI195IVojX3l+UCNDfE8hZCN1TyFZJ15xIWonXnF+TyFZL2NPIWoodXl+TyFWJ2BxIVknYHF+UCMtXU8hVjl3T35QIy1dTyFZMHJPIVopT3l+TyFZNVVPIVooe3F+TyFbMVtPJWM6T09+TyFqOlJPfk8hWydaTyVjOldPfk9QJHdxWiR3cW4kd3F9JHdxIWgkd3EhaSR3cSFrJHdxIW8kd3EjaiR3cSNrJHdxI2wkd3EjbSR3cSNuJHdxI28kd3EjcCR3cSNxJHdxI3Ikd3EjdCR3cSN2JHdxI3gkd3EjeSR3cSN8JHdxKFgkd3EoaCR3cSFZJHdxIVokd3F+UCYnVU98KXpPIVApe08ocCVQT1AnY2FaJ2NhaidjYW4nY2F9J2NhIWgnY2EhaSdjYSFrJ2NhIW8nY2EjaidjYSNrJ2NhI2wnY2EjbSdjYSNuJ2NhI28nY2EjcCdjYSNxJ2NhI3InY2EjdCdjYSN2J2NhI3gnY2EjeSdjYSN8J2NhKFgnY2EoaCdjYShvJ2NhIVknY2EhWidjYX5PfCl6TyFQKXtPUCdlYVonZWFqJ2VhbidlYX0nZWEhaCdlYSFpJ2VhIWsnZWEhbydlYSNqJ2VhI2snZWEjbCdlYSNtJ2VhI24nZWEjbydlYSNwJ2VhI3EnZWEjcidlYSN0J2VhI3YnZWEjeCdlYSN5J2VhI3wnZWEoWCdlYShoJ2VhKG8nZWEocCdlYSFZJ2VhIVonZWF+T1AkeXFaJHlxbiR5cX0keXEhaCR5cSFpJHlxIWskeXEhbyR5cSNqJHlxI2skeXEjbCR5cSNtJHlxI24keXEjbyR5cSNwJHlxI3EkeXEjciR5cSN0JHlxI3YkeXEjeCR5cSN5JHlxI3wkeXEoWCR5cShoJHlxIVkkeXEhWiR5cX5QJidVT2YlXyFaIVklXyFaI1slXyFaI3wlXyFaflAhMH1PIVknaXEhWidpcX5QI0N8TyFZI2QhWiFaI2QhWn5QI0N8TyNnJV8hWlAlXyFaWiVfIVpgJV8hWm4lXyFafSVfIVohWSVfIVohaCVfIVohaSVfIVohayVfIVohbyVfIVojaiVfIVojayVfIVojbCVfIVojbSVfIVojbiVfIVojbyVfIVojcCVfIVojcSVfIVojciVfIVojdCVfIVojdiVfIVojeCVfIVojeSVfIVonciVfIVooWCVfIVooaCVfIVohaiVfIVohViVfIVoncCVfIVojWyVfIVpyJV8hWiFbJV8hWiVjJV8hWiFkJV8hWn5QIy1dT1AlXyFaWiVfIVpuJV8hWn0lXyFaIWglXyFaIWklXyFaIWslXyFaIW8lXyFaI2olXyFaI2slXyFaI2wlXyFaI20lXyFaI24lXyFaI28lXyFaI3AlXyFaI3ElXyFaI3IlXyFaI3QlXyFaI3YlXyFaI3glXyFaI3klXyFaI3wlXyFaKFglXyFaKGglXyFaIVklXyFaIVolXyFaflAmJ1VPcihdWH5QMXFPJ3whbE9+UCEqZk8hVmVYIVllWCNbZVh+UCcjYE9QW1haW1huW1h8W1h9W1ghUFtYIVlbWCFZZVghaFtYIWlbWCFrW1ghb1tYI1tbWCNbZVgjZ2VYI2pbWCNrW1gjbFtYI21bWCNuW1gjb1tYI3BbWCNxW1gjcltYI3RbWCN2W1gjeFtYI3lbWCRPW1goWFtYKGhbWChvW1gocFtYfk8hZGVYIWpbWCFqZVgoaGVYflAnQVNPUDpjT1E6Y09SZk9jPFtPZCFpT2xrT246Y09va09wa092a094OmNPejpjTyFQV08hVGtPIVVrTyFbWE8hZjpmTyFrWk8hbjpjTyFvOmNPIXA6Y08hcjpnTyF0OmpPIXchaE8kVCFrTyd7KVlPJ31UTyhRVU8oWFZPKGdbTyh0PFlPfk8hWTp3TyFaJG1hfk9nJVZPbCVXT24kdE9vJHNPcCRzT3YlWE94JVlPejtSTyFQJHtPIVskfE8hZjxhTyFrJHhPI2Y7WE8kVCVeTyRvO1RPJHE7Vk8kdCVfTyd7KHBPJ31UTyhRVU8oWCR1TyhvJH1PKHAlUE9+TyNzKWFPflAnRXhPIVpbWCFaZVh+UCdBU08jZzprT35PIWQjdU8jZzprT35PI1s6e09+TyNyOnBPfk8jWztaTyFZKG1YIVoobVh+TyNbOntPIVkoa1ghWihrWH5PI2c7W09+T2Y7Xk9+UCEwfU8jZztjT35PI2c7ZE9+TyFkI3VPI2c7ZU9+TyFkI3VPI2c7W09+TyN8O2ZPflAjQ3xPI2c7Z09+TyNnO2hPfk8jZzttT35PI2c7bk9+TyNnO29Pfk8jZztwT35PI3w7cU9+UCEwfU8jfDtyT35QITB9TyFpI1AjUSNTI1QjVyNlI2YjcSh0JG8kcSR0JVclYiVjJWQlayVtJXAlcSVzJXV+J3ZTI2shVSd0J3wjbG8jaiNtbnwndSRZJ3UneyRbKFt+XCIsXG4gIGdvdG86IFwiJDJwKVNQUFBQUClUUFApV1ApaVAqeC58UFBQUDVwUFA2V1BQPFM/Z1A/elA/elBQUD96UEF4UD96UD96UD96UEF8UFBCUlBCbFBHZFBQUEdoUFBQUEdoSmlQUFBKb0tqUEdoUE14UFBQUCEhV0doUFBQR2hQR2hQISRmR2hQISd6ISh8ISlWUCEpeSEpfSEpeVBQUFBQIS1ZISh8UFAhLXYhLnBQITFkR2hHaCExaSE0cyE5WSE5WSE9T1BQUCE9VkdoUFBQUFBQUFBQUFAhQGRQIUFxUFBHaCFDU1BHaFBHaEdoR2hHaFBHaCFEZlAhR25QIUpyUCFKdiFLUSFLVSFLVVAhR2tQIUtZIUtZUCFOXlAhTmJHaEdoIU5oIyNrP3pQP3pQP3o/elAjJHY/ej96IydPP3ojKWs/eiMrbT96P3ojLFsjLmYjLmYjLmojLnIjLmYjLnpQIy5mUD96Iy9kP3ojM1I/ej96NXBQUFAjNnZQUFAjN2EjN2FQIzdhUCM3dyM3YVBQIzd9UCM3dFAjN3QjOGIjN3QjOHwjOVM1bSlXIzlWKVdQIzleIzleIzleUClXUClXUClXUClXUFApV1AjOWQjOWdQIzlnKVdQIzlrUCM5blApV1ApV1ApV1ApV1ApV1ApVylXUFAjOXQjOXojOlYjOl0jOmMjOmkjOm8jOn0jO1QjO1ojO2UjO2sjO3UjPFUjPFsjPHwjPWAjPWYjPWwjPXojPmEjQE8jQF4jQGQjQXgjQlcjQ3IjRFEjRFcjRF4jRGQjRG4jRHQjRHojRVUjRWgjRW5QUFBQUFBQUFBQI0V0UFBQUFBQUCNGaSNJcCNLUCNLVyNLYFBQUFAkIWQkJVokK3IkK3UkK3gkLHEkLHQkLHckLU8kLVdQUCQtXiQtYiQuWSQvWCQvXSQvcVBQJC91JC97JDBQUCQwUyQwVyQwWiQxUCQxaCQyUCQyVCQyVyQyWiQyYSQyZCQyaCQybFIhe1JvcU9Yc3QhWiNjJWombSZvJnAmcixoLG0xdzF6WSF1USdaLVkxWzVdUSVwdlEleHlRJlB8USZlIVZTJ1IhZS1RUSdhIWlTJ2chciF4UypjJHwqaFErZiV5UStzJlJRLFgmX1EtVydZUS1iJ2JRLWonaFEvfCpqUTFmLFlSO1k6ZyVPZE9QV1hZWnN0dXZ3IVohYCFnIW8jUiNWI1kjYyNuI3QjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkWSRhJGUlaiVwJX0mZiZpJm0mbyZwJnImdidPJ10nbSd9KFAoViheKHIodih6KXkrTytTLGUsaCxtLV4tZi10LXoubC5zMFswYTBxMV8xbzFwMXIxdDF3MXoxfDJtMnMzWjVZNWQ1dDV1NXg2XTd3N3w4XThnUyNwXTpkIXIpWyRbJG0nUyluLHksfC57Ml0zcDVXNlM5VzlpOmM6ZjpnOmo6azpsOm06bjpvOnA6cTpyOnM6dDp1OnY6dzp7O1k7WjtbO147ZTtmO287cDxdUSp1JVpRK2sle1EsWiZiUSxiJmpRLmM7UVEwaCteUTBsK2BRMHcrbFExbixgUTJ7LltRNHYwclE1azFnUTZpM1BRNnU7UlE3aDR3UjhtNmomfGtPUFdYWVpzdHV2dyFaIWAhZyFvI1IjViNZI2MjbiN0I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJFkkWyRhJGUkbSVqJXAlfSZmJmkmaiZtJm8mcCZyJnYnTydTJ10nbSd9KFAoViheKHIodih6KW4peStPK1MrXixlLGgsbSx5LHwtXi1mLXQtei5bLmwucy57MFswYTBxMV8xbzFwMXIxdDF3MXoxfDJdMm0yczNQM1ozcDVXNVk1ZDV0NXU1eDZTNl02ajd3N3w4XThnOVc5aTpjOmY6ZzpqOms6bDptOm46bzpwOnE6cjpzOnQ6dTp2Onc6eztZO1o7WzteO2U7ZjtvO3A8XXQhblEhciF1IXgheSdSJ1knWidnJ2gnaS1RLVctWS1qMVs1XTVfJHYkc2kjdSN3JGMkZCR4JHslTyVRJVslXSVhKXUpeyl9KlAqUipZKmAqcCpxK10rYCt3K3ouWi5pL1ovai9rL20wUTBTMF4xUjFVMV4zTzN4NFM0WzRmNG40cDVjNmc3VDdeN3k4ajh3OVs5bjpPOlc6eTp6Onw6fTtPO1A7UztUO1U7VjtXO1g7XztgO2E7YjtjO2Q7ZztoO2k7ajtrO2w7bTtuO3E7cjxZPGI8YzxmPGdRJlN8USdQIWVTJ1YlZi1UUStrJXtRLFomYlEwXSp5UTB3K2xRMHwrclExbSxfUTFuLGBRNHYwclE1UDFPUTVrMWdRNW4xaVE1bzFsUTdoNHdRN2s0fFE4VTVxUTlWN2xSOWI4UnJuT1hzdCFWIVojYyVqJmQmbSZvJnAmcixoLG0xdzF6UixdJmYmdl5PUFhZc3R1dnd6IVohYCFnIWohbyNSI2MjbiN0I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJFkkWyRhJGUkbSVqJXAlfSZmJmkmaiZtJm8mcCZyJnYnTyddJ20oUChWKF4ocih2KHopbil5K08rUyteLGUsaCxtLHksfC1eLWYtdC16LlsubC5zLnswWzBhMHExXzFvMXAxcjF0MXcxejF8Ml0ybTJzM1AzWjNwNVc1WTVkNXQ1dTV4NlM2XTZqN3c3fDhdOGc5VzlpOmM6ZjpnOmo6azpsOm06bjpvOnA6cTpyOnM6dDp1OnY6dzp7O1k7WjtbO147ZTtmO287cDxbPF1bI1tXWiNWI1knUyd9IVMlZ20jZyNoI2slYiVlKFcoYihjKGQrUStSK1QsZCx6LXguTy5QLlEuUzJQMncyeDZSNmRRJXN4USV3eVMlfHwmUlEmWSFUUSdeIWhRJ2AhaVEoayNyUypWJHgqWlMrZSV4JXlRK2kle1EsUyZdUSxXJl9TLWEnYSdiUS5eKGxRL2cqV1EwcCtmUTB2K2xRMHgrbVEweytxUTFhLFRTMWUsWCxZUTJpLWJRM3kvY1E0dTByUTR5MHVRNU8wfVE1ajFmUTdRM3pRN2c0d1E3ajR7UTlSN2ZSOXk5UyFPJHppI3clTyVRJVslXSVhKX0qUCpZKnAqcS5pL2owUTBTMF4zeDRmOHc8WTxiPGMhUyV1eSFpIXQldyV4JXknUSdgJ2EnYidmJ3AqYitlK2YsfS1hLWItaS90MHAyYjJpMnA0XlErXyVzUSt4JlZRK3smV1EsViZfUS5dKGtRMWAsU1UxZCxXLFgsWVEzUS5eUTVlMWFTNWkxZTFmUThRNWojVzxeI3UkYyRkJHgkeyl1KXsqUipgK10rYCt3K3ouWi9aL2svbTFSMVUxXjNPNFM0WzRuNHA1YzZnN1Q3Xjd5OGo5WzluOk86Vzp8O087UztVO1c7XzthO2M7ZztpO2s7bTtxPGY8Z288Xzp5Ono6fTtQO1Q7VjtYO2A7YjtkO2g7ajtsO247clclVGklVipyPFlTJlYhUSZkUSZXIVJRJlghU1IrdiZUJHclU2kjdSN3JGMkZCR4JHslTyVRJVslXSVhKXUpeyl9KlAqUipZKmAqcCpxK10rYCt3K3ouWi5pL1ovai9rL20wUTBTMF4xUjFVMV4zTzN4NFM0WzRmNG40cDVjNmc3VDdeN3k4ajh3OVs5bjpPOlc6eTp6Onw6fTtPO1A7UztUO1U7VjtXO1g7XztgO2E7YjtjO2Q7ZztoO2k7ajtrO2w7bTtuO3E7cjxZPGI8YzxmPGdUKXYkdSl3Vip2JVo7UTtSVSdWIWUlZi1UUyh5I3kjelErcCZPUy5WKGcoaFExVit8UTRnMFpSN3A1VSZ8a09QV1hZWnN0dXZ3IVohYCFnIW8jUiNWI1kjYyNuI3QjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkWSRbJGEkZSRtJWolcCV9JmYmaSZqJm0mbyZwJnImdidPJ1MnXSdtJ30oUChWKF4ocih2KHopbil5K08rUyteLGUsaCxtLHksfC1eLWYtdC16LlsubC5zLnswWzBhMHExXzFvMXAxcjF0MXcxejF8Ml0ybTJzM1AzWjNwNVc1WTVkNXQ1dTV4NlM2XTZqN3c3fDhdOGc5VzlpOmM6ZjpnOmo6azpsOm06bjpvOnA6cTpyOnM6dDp1OnY6dzp7O1k7WjtbO147ZTtmO287cDxdJGkkYGMjWCNkJW4lbyVxJ3woUyhuKHUofSlPKVApUSlSKVMpVClVKVYpVylYKVopXiliKWwrWitvLU8tbS1yLXcteS5oLm4uci50LnUudi9WMF8yVzJaMmsycjNZM18zYDNhM2IzYzNkM2UzZjNnM2gzaTNqM2szbjNvM3Q0azRzNlU2WzZhNm82cDZ5Nno3cjhhOGU4bjh0OHU5azl7OlM6ZTxQVCNTViNUJn1rT1BXWFlac3R1dnchWiFgIWchbyNSI1YjWSNjI24jdCN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRZJFskYSRlJG0laiVwJX0mZiZpJmombSZvJnAmciZ2J08nUyddJ20nfShQKFYoXihyKHYoeiluKXkrTytTK14sZSxoLG0seSx8LV4tZi10LXouWy5sLnMuezBbMGEwcTFfMW8xcDFyMXQxdzF6MXwyXTJtMnMzUDNaM3A1VzVZNWQ1dDV1NXg2UzZdNmo3dzd8OF04ZzlXOWk6YzpmOmc6ajprOmw6bTpuOm86cDpxOnI6czp0OnU6djp3Ons7WTtaO1s7XjtlO2Y7bztwPF1RJ1QhZVIyXi1RdiFuUSFlIXIhdSF4IXknUidZJ1onZydoJ2ktUS1XLVktajFbNV01X1MqYiR8KmhTL3QqYypqUS99KmtRMVgsT1E0Xi98UjRhMFBucU9Yc3QhWiNjJWombSZvJnAmcixoLG0xdzF6USZ0IV5RJ3Ehd1MobSN0OmtRK2MldlEsUSZZUSxSJltRLV8nX1EtbCdqUy5nKHI7W1MwYCtPO2VRMG4rZFExWixQUTJPLG9RMlEscFEyWSx7UTJnLWBRMmotZFM0bDBhO29RNHEwb1M0dDBxO3BRNlQyW1E2WDJoUTZeMm9RN2U0clE4YjZWUThjNllROGY2X1I5aDhfJGQkX2MjWCNkJW8lcSd8KFMobih1KH0pTylQKVEpUilTKVQpVSlWKVcpWClaKV4pYilsK1orby1PLW0tci13LXkuaC5uLnIudS52L1YwXzJXMloyazJyM1kzXzNgM2EzYjNjM2QzZTNmM2czaDNpM2ozazNuM28zdDRrNHM2VTZbNmE2bzZwNnk2ejdyOGE4ZThuOHQ4dTlrOXs6UzplPFBTKGojbydkVSpvJVIocTNtUytZJW4udFEyfDBoUTZmMntROGw2aVI5bzhtJGQkXmMjWCNkJW8lcSd8KFMobih1KH0pTylQKVEpUilTKVQpVSlWKVcpWClaKV4pYilsK1orby1PLW0tci13LXkuaC5uLnIudS52L1YwXzJXMloyazJyM1kzXzNgM2EzYjNjM2QzZTNmM2czaDNpM2ozazNuM28zdDRrNHM2VTZbNmE2bzZwNnk2ejdyOGE4ZThuOHQ4dTlrOXs6UzplPFBTKGkjbydkUyh7I3okX1MrWCVuLnRTLlcoaChqUS53KV1RMGUrWVIyeS5YJnxrT1BXWFlac3R1dnchWiFgIWchbyNSI1YjWSNjI24jdCN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRZJFskYSRlJG0laiVwJX0mZiZpJmombSZvJnAmciZ2J08nUyddJ20nfShQKFYoXihyKHYoeiluKXkrTytTK14sZSxoLG0seSx8LV4tZi10LXouWy5sLnMuezBbMGEwcTFfMW8xcDFyMXQxdzF6MXwyXTJtMnMzUDNaM3A1VzVZNWQ1dDV1NXg2UzZdNmo3dzd8OF04ZzlXOWk6YzpmOmc6ajprOmw6bTpuOm86cDpxOnI6czp0OnU6djp3Ons7WTtaO1s7XjtlO2Y7bztwPF1TI3BdOmRRJm8hWFEmcCFZUSZyIVtRJnMhXVIxdixrUSdbIWhRK1slc1EtXSdeUy5ZKGsrX1EyZS1bVzJ9Ll0uXjBnMGlRNlcyZlU2ZTJ6MnwzUVM4aTZmNmhTOW04azhsUzpVOWw5b1E6XjpWUjphOl9VIXZRJ1otWVQ1WjFbNV0hUV9PWFpgc3QhViFaI2MjZyViJWomZCZmJm0mbyZwJnIoZCxoLG0uUDF3MXpdIXBRIXInWi1ZMVs1XVQjcF06ZCVZe09QV1hZWnN0dXZ3IVohYCFnIW8jUiNWI1kjYyNuI3QjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkWSRhJGUlaiVwJX0mZiZpJmombSZvJnAmciZ2J08nXSdtJ30oUChWKF4ocih2KHopeStPK1MrXixlLGgsbS1eLWYtdC16LlsubC5zMFswYTBxMV8xbzFwMXIxdDF3MXoxfDJtMnMzUDNaNVk1ZDV0NXU1eDZdNmo3dzd8OF04Z1MoeSN5I3pTLlYoZyhoIXM7diRbJG0nUyluLHksfC57Ml0zcDVXNlM5VzlpOmM6ZjpnOmo6azpsOm06bjpvOnA6cTpyOnM6dDp1OnY6dzp7O1k7WjtbO147ZTtmO287cDxdWSF0USdaLVkxWzVdUSdmIXJTJ3AhdSF4UydyIXk1X1MtaSdnJ2hRLWsnaVIycC1qUSdvIXRTKGAjZjFxUy1oJ2YnclEvZipWUS9yKmJRMnEta1E0Ty9nUzRYL3MvfVE3UDN5UzdbNF80YVE4eTdRUjlRN19RI3ZiUSduIXRTKF8jZjFxUyhhI2wqfVErUCVjUSthJXRRK2clelUtZydmJ28nclEteyhgUS9lKlZRL3EqYlEvdyplUTBtK2JRMWIsVVMybi1oLWtRMnYuVFMzfS9mL2dTNFcvci99UTRaL3ZRNF0veFE1ZzFjUTZgMnFRN08zeVE3UzRPUzdXNFg0YVE3XTRgUThPNWhTOHg3UDdRUTh8N1hROU83W1E5XzhQUTl1OHlROXY4fVE5eDlRUTpROWBROlk5d1E7eTt0UTxVO31SPFY8T1YhdlEnWi1ZJVlhT1BXWFlac3R1dnchWiFgIWchbyNSI1YjWSNjI24jdCN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRZJGEkZSVqJXAlfSZmJmkmaiZtJm8mcCZyJnYnTyddJ20nfShQKFYoXihyKHYoeil5K08rUyteLGUsaCxtLV4tZi10LXouWy5sLnMwWzBhMHExXzFvMXAxcjF0MXcxejF8Mm0yczNQM1o1WTVkNXQ1dTV4Nl02ajd3N3w4XThnUyN2eiFqIXI7cyRbJG0nUyluLHksfC57Ml0zcDVXNlM5VzlpOmM6ZjpnOmo6azpsOm06bjpvOnA6cTpyOnM6dDp1OnY6dzp7O1k7WjtbO147ZTtmO287cDxdUjt5PFslWWJPUFdYWVpzdHV2dyFaIWAhZyFvI1IjViNZI2MjbiN0I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJFkkYSRlJWolcCV9JmYmaSZqJm0mbyZwJnImdidPJ10nbSd9KFAoViheKHIodih6KXkrTytTK14sZSxoLG0tXi1mLXQtei5bLmwuczBbMGEwcTFfMW8xcDFyMXQxdzF6MXwybTJzM1AzWjVZNWQ1dDV1NXg2XTZqN3c3fDhdOGdRJWNqIVMldHkhaSF0JXcleCV5J1EnYCdhJ2InZidwKmIrZStmLH0tYS1iLWkvdDBwMmIyaTJwNF5TJXp6IWpRK2IldVEsVSZfVzFjLFYsVyxYLFlVNWgxZDFlMWZTOFA1aTVqUTlgOFEhcjt0JFskbSdTKW4seSx8LnsyXTNwNVc2UzlXOWk6YzpmOmc6ajprOmw6bTpuOm86cDpxOnI6czp0OnU6djp3Ons7WTtaO1s7XjtlO2Y7bztwPF1RO308WlI8TzxbJHxlT1BYWXN0dXZ3IVohYCFnIW8jUiNjI24jdCN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRZJGEkZSVqJXAlfSZmJmkmbSZvJnAmciZ2J08nXSdtKFAoViheKHIodih6KXkrTytTK14sZSxoLG0tXi1mLXQtei5bLmwuczBbMGEwcTFfMW8xcDFyMXQxdzF6MXwybTJzM1AzWjVZNWQ1dDV1NXg2XTZqN3c3fDhdOGdZI2FXWiNWI1knfSFTJWdtI2cjaCNrJWIlZShXKGIoYyhkK1ErUitULGQsei14Lk8uUC5RLlMyUDJ3Mng2UjZkUSxjJmohcDt1JFskbSluLHksfC57Ml0zcDVXNlM5VzlpOmM6ZjpnOmo6azpsOm06bjpvOnA6cTpyOnM6dDp1OnY6dzp7O1k7WjtbO147ZTtmO287cDxdUjt4J1NTJ1chZSVmUjJgLVQlT2RPUFdYWVpzdHV2dyFaIWAhZyFvI1IjViNZI2MjbiN0I3gjeyRPJFAkUSRSJFMkVCRVJFYkVyRYJFkkYSRlJWolcCV9JmYmaSZtJm8mcCZyJnYnTyddJ20nfShQKFYoXihyKHYoeil5K08rUyxlLGgsbS1eLWYtdC16LmwuczBbMGEwcTFfMW8xcDFyMXQxdzF6MXwybTJzM1o1WTVkNXQ1dTV4Nl03dzd8OF04ZyFyKVskWyRtJ1Mpbix5LHwuezJdM3A1VzZTOVc5aTpjOmY6ZzpqOms6bDptOm46bzpwOnE6cjpzOnQ6dTp2Onc6eztZO1o7WzteO2U7ZjtvO3A8XVEsYiZqUTBoK15RMnsuW1E2aTNQUjhtNmohYiRVYyNYJW4nfChTKG4odSlXKVgpXiliK28tbS1yLXcteS5oLm4vVjBfMmsycjNZM2s0azRzNls2YTZvOGU5azplIVA6cilaKWwtTy50MlcyWjNfM2kzajNuM3Q2VTZwNnk2ejdyOGE4bjh0OHU5ezpTPFAhZiRXYyNYJW4nfChTKG4odSlUKVUpVylYKV4pYitvLW0tci13LXkuaC5uL1YwXzJrMnIzWTNrNGs0czZbNmE2bzhlOWs6ZSFUOnQpWilsLU8udDJXMlozXzNmM2czaTNqM24zdDZVNnA2eTZ6N3I4YThuOHQ4dTl7OlM8UCFeJFtjI1glbid8KFMobih1KV4pYitvLW0tci13LXkuaC5uL1YwXzJrMnIzWTNrNGs0czZbNmE2bzhlOWs6ZVEzeC9hejxdKVopbC1PLnQyVzJaM18zbjN0NlU2cDZ5Nno3cjhhOG44dDh1OXs6UzxQUTxiPGRSPGM8ZSZ8a09QV1hZWnN0dXZ3IVohYCFnIW8jUiNWI1kjYyNuI3QjeCN7JE8kUCRRJFIkUyRUJFUkViRXJFgkWSRbJGEkZSRtJWolcCV9JmYmaSZqJm0mbyZwJnImdidPJ1MnXSdtJ30oUChWKF4ocih2KHopbil5K08rUyteLGUsaCxtLHksfC1eLWYtdC16LlsubC5zLnswWzBhMHExXzFvMXAxcjF0MXcxejF8Ml0ybTJzM1AzWjNwNVc1WTVkNXQ1dTV4NlM2XTZqN3c3fDhdOGc5VzlpOmM6ZjpnOmo6azpsOm06bjpvOnA6cTpyOnM6dDp1OnY6dzp7O1k7WjtbO147ZTtmO287cDxdUyRuaCRvUjNxLnonVGdPUFdYWVpoc3R1dnchWiFgIWchbyNSI1YjWSNjI24jdCN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRZJFskYSRlJG0kbyVqJXAlfSZmJmkmaiZtJm8mcCZyJnYnTydTJ10nbSd9KFAoViheKHIodih6KW4peStPK1MrXixlLGgsbSx5LHwtXi1mLXQtei5bLmwucy56LnswWzBhMHExXzFvMXAxcjF0MXcxejF8Ml0ybTJzM1AzWjNwNVc1WTVkNXQ1dTV4NlM2XTZqN3c3fDhdOGc5VzlpOmM6ZjpnOmo6azpsOm06bjpvOnA6cTpyOnM6dDp1OnY6dzp7O1k7WjtbO147ZTtmO287cDxdVCRqZiRwUSRoZlMpZSRrKWlSKXEkcFQkaWYkcFQpZyRrKWknVGhPUFdYWVpoc3R1dnchWiFgIWchbyNSI1YjWSNjI24jdCN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRZJFskYSRlJG0kbyVqJXAlfSZmJmkmaiZtJm8mcCZyJnYnTydTJ10nbSd9KFAoViheKHIodih6KW4peStPK1MrXixlLGgsbSx5LHwtXi1mLXQtei5bLmwucy56LnswWzBhMHExXzFvMXAxcjF0MXcxejF8Ml0ybTJzM1AzWjNwNVc1WTVkNXQ1dTV4NlM2XTZqN3c3fDhdOGc5VzlpOmM6ZjpnOmo6azpsOm06bjpvOnA6cTpyOnM6dDp1OnY6dzp7O1k7WjtbO147ZTtmO287cDxdVCRuaCRvUSRxaFIpcCRvJVlqT1BXWFlac3R1dnchWiFgIWchbyNSI1YjWSNjI24jdCN4I3skTyRQJFEkUiRTJFQkVSRWJFckWCRZJGEkZSVqJXAlfSZmJmkmaiZtJm8mcCZyJnYnTyddJ20nfShQKFYoXihyKHYoeil5K08rUyteLGUsaCxtLV4tZi10LXouWy5sLnMwWzBhMHExXzFvMXAxcjF0MXcxejF8Mm0yczNQM1o1WTVkNXQ1dTV4Nl02ajd3N3w4XThnIXM8WiRbJG0nUyluLHksfC57Ml0zcDVXNlM5VzlpOmM6ZjpnOmo6azpsOm06bjpvOnA6cTpyOnM6dDp1OnY6dzp7O1k7WjtbO147ZTtmO287cDxdI2NsT1BYWnN0IVohYCFvI1IjYyNuI3skbSVqJmYmaSZqJm0mbyZwJnImdidPJ10oeiluK1MrXixlLGgsbS1eLlsuezBbMV8xbzFwMXIxdDF3MXoxfDNQM3A1WTVkNXQ1dTV4Nmo3dzd8OF0hTyVSaSN3JU8lUSVbJV0lYSl9KlAqWSpwKnEuaS9qMFEwUzBeM3g0Zjh3PFk8YjxjI1cocSN1JGMkZCR4JHspdSl7KlIqYCtdK2Ardyt6LlovWi9rL20xUjFVMV4zTzRTNFs0bjRwNWM2ZzdUN143eThqOVs5bjpPOlc6fDtPO1M7VTtXO187YTtjO2c7aTtrO207cTxmPGdRKnolX1EvVyl6bzNtOnk6ejp9O1A7VDtWO1g7YDtiO2Q7aDtqO2w7bjtyIU8keWkjdyVPJVElWyVdJWEpfSpQKlkqcCpxLmkvajBRMFMwXjN4NGY4dzxZPGI8Y1EqWyR6UyplJHwqaFEqeyVgUS94KmYjVzt7I3UkYyRkJHgkeyl1KXsqUipgK10rYCt3K3ouWi9aL2svbTFSMVUxXjNPNFM0WzRuNHA1YzZnN1Q3Xjd5OGo5WzluOk86Vzp8O087UztVO1c7XzthO2M7ZztpO2s7bTtxPGY8Z247fDp5Ono6fTtQO1Q7VjtYO2A7YjtkO2g7ajtsO247clE8UTxeUTxSPF9RPFM8YFI8VDxhIU8lUmkjdyVPJVElWyVdJWEpfSpQKlkqcCpxLmkvajBRMFMwXjN4NGY4dzxZPGI8YyNXKHEjdSRjJGQkeCR7KXUpeypSKmArXStgK3crei5aL1ovay9tMVIxVTFeM080UzRbNG40cDVjNmc3VDdeN3k4ajlbOW46TzpXOnw7TztTO1U7VztfO2E7YztnO2k7azttO3E8ZjxnbzNtOnk6ejp9O1A7VDtWO1g7YDtiO2Q7aDtqO2w7bjtybm9PWHN0IVojYyVqJm0mbyZwJnIsaCxtMXcxelEqXyR7USx2JnlRLHcme1I0Ui9rJHYlU2kjdSN3JGMkZCR4JHslTyVRJVslXSVhKXUpeyl9KlAqUipZKmAqcCpxK10rYCt3K3ouWi5pL1ovai9rL20wUTBTMF4xUjFVMV4zTzN4NFM0WzRmNG40cDVjNmc3VDdeN3k4ajh3OVs5bjpPOlc6eTp6Onw6fTtPO1A7UztUO1U7VjtXO1g7XztgO2E7YjtjO2Q7ZztoO2k7ajtrO2w7bTtuO3E7cjxZPGI8YzxmPGdRK3kmV1ExVCt7UTVTMVNSN281VFQqZyR8KmhTKmckfCpoVDVbMVs1XVMvdipkNVlUNGAwTzd3USthJXRRL3cqZVEwbStiUTFiLFVRNWcxY1E4TzVoUTlfOFBSOlE5YCFPJU9pI3clTyVRJVslXSVhKX0qUCpZKnAqcS5pL2owUTBTMF4zeDRmOHc8WTxiPGNyKX0kdihzKk8qbip8L2kwVTBWM1c0UDRqNn03YDl0O3o8VzxYUzBRKm0wUiNXOnwjdSRjJGQkeCR7KXUpeypSKmArXStgK3crei5aL1ovay9tMVIxVTFeM080UzRbNG40cDVjNmc3VDdeN3k4ajlbOW46TzpXOnw7TztTO1U7VztfO2E7YztnO2k7azttO3E8Zjxnbjp9Onk6ejp9O1A7VDtWO1g7YDtiO2Q7aDtqO2w7bjtyIV47XyhvKWAqVSpeLl8uYi5mL1MvWC9hL24wZjFRMVMzVDRRNFU1UjVUNms2bjdVN1k3YjdkOHs5UDpYPGQ8ZWA7YDNsNnE2dDZ4OG85cDlzOmJTO2kuYTNVVDtqNnM4ciFPJVFpI3clTyVRJVslXSVhKX0qUCpZKnAqcS5pL2owUTBTMF4zeDRmOHc8WTxiPGN2KlAkdihzKlEqbSp8L10vaTBVMFYzVzRQNGI0ajZ9N2A5dDt6PFc8WFMwUypuMFQjVztPI3UkYyRkJHgkeyl1KXsqUipgK10rYCt3K3ouWi9aL2svbTFSMVUxXjNPNFM0WzRuNHA1YzZnN1Q3Xjd5OGo5WzluOk86Vzp8O087UztVO1c7XzthO2M7ZztpO2s7bTtxPGY8Z247UDp5Ono6fTtQO1Q7VjtYO2A7YjtkO2g7ajtsO247ciFiO2EobylgKlUqXi5gLmEuZi9TL1gvYS9uMGYxUTFTM1IzVDRRNFU1UjVUNms2bDZuN1U3WTdiN2Q4ezlQOlg8ZDxlZDtiM2w2cjZzNng4bzhwOXA5cTlzOmJTO2suYjNWVDtsNnQ4c3JuT1hzdCFWIVojYyVqJmQmbSZvJnAmcixoLG0xdzF6USZhIVVSLGUmanJuT1hzdCFWIVojYyVqJmQmbSZvJnAmcixoLG0xdzF6UiZhIVVRK30mWFIxUCt2c25PWHN0IVYhWiNjJWomZCZtJm8mcCZyLGgsbTF3MXpRMV0sU1M1YjFgMWFVN3g1YDVhNWVTOVo3ejd7Uzl8OVk5XVE6Wjl9UjpgOltRJmghVlIsXiZkUjVuMWlTJXx8JlJSMHgrbVEmbSFXUixoJm5SLG4mc1QxeCxtMXpSLHImdFEscSZ0UjJSLHJRJ3QhelItbid0U3NPdFEjY1hUJW1zI2NRIX1UUid2IX1RI1FVUid4I1FRKXckdVIvVCl3USNUVlIneiNUUSNXV1UoUSNXKFItdVEoUiNYUi11KFNRLVInVFIyXy1SUS5qKHNSM1gualEubSh1UzNbLm0zXVIzXS5uUS1ZJ1pSMmMtWVkhclEnWi1ZMVs1XVInZSFyUyNeVyVlVShYI14oWS12UShZI19SLXYoVFEtVSdXUjJhLVV0YE9Yc3QhViFaI2MlaiZkJmYmbSZvJnAmcixoLG0xdzF6UyNnWiViVSNxYCNnLlBSLlAoZFEoZSNpUS18KGFXLlUoZS18MnQ2YlEydC19UjZiMnVRKWkka1IufClpUSRvaFIpbyRvUSRiY1UpXyRiLXE6eFEtcTplUjp4KWxRL2QqVlczey9kM3w3Ujh6VTN8L2UvZi9nUzdSM300T1I4ejdTJFgpfCR2KG8ocylgKlUqXiptKm4qdyp4KnwuYS5iLmQuZS5mL1MvWC9dL18vYS9pL24wVTBWMGYxUTFTM1IzUzNUM1czbDRQNFE0VTRiNGQ0ajVSNVQ2azZsNm02bjZzNnQ2djZ3Nng2fTdVN1k3YDdiN2Q4bzhwOHE4ezlQOXA5cTlyOXM5dDpYOmI7ejxXPFg8ZDxlUS9sKl5VNFQvbDRWN1ZRNFYvblI3VjRVUSpoJHxSL3oqaHIqTyR2KHMqbSpuKnwvaTBVMFYzVzRQNGo2fTdgOXQ7ejxXPFghXi5fKG8pYCpVKl4uYS5iLmYvUy9YL2EvbjBmMVExUzNUNFE0VTVSNVQ2azZuN1U3WTdiN2Q4ezlQOlg8ZDxlVS9eKk8uXzZxYTZxM2w2czZ0Nng4bzlwOXM6YlEwUiptUTNVLmFVNGMwUjNVOHJSOHI2c3YqUSR2KHMqbSpuKnwvXS9pMFUwVjNXNFA0YjRqNn03YDl0O3o8VzxYIWIuYChvKWAqVSpeLmEuYi5mL1MvWC9hL24wZjFRMVMzUjNUNFE0VTVSNVQ2azZsNm43VTdZN2I3ZDh7OVA6WDxkPGVVL2AqUS5gNnJlNnIzbDZzNnQ2eDhvOHA5cDlxOXM6YlEwVCpuUTNWLmJVNGUwVDNWOHNSOHM2dFEqcyVVUjBYKnNRNG8wZlI3YzRvUStVJWhSMGQrVVE1VjFWUzdxNVY5WFI5WDdyUSxQJllSMVksUFE1XTFbUjd1NV1RMWgsWlM1bDFoOFNSOFM1blEwcytpVzR4MHM0ejdpOVRRNHowdlE3aTR5UjlUN2pRK24lfFIweStuUTF6LG1SNXwxellyT1hzdCNjUSZxIVpRK1clalEsZyZtUSxpJm9RLGomcFEsbCZyUTF1LGhTMXgsbTF6UjV7MXdRJWxwUSZ1IV9RJnghYVEmeiFiUSZ8IWNRJ2whdFErViVpUStjJXZRK3UmU1EsXSZoUSx0JndXLWUnZiduJ28nclEtbCdqUS95KmdRMG4rZFMxayxeLGFRMlMsc1EyVCx2UTJVLHdRMmotZFcybC1nLWgtay1tUTRxMG9RNH0wfFE1UTFRUTVmMWJRNXAxbVE1ejF2VTZaMmsybjJxUTZeMm9RN2U0clE3bTVQUTduNVJRN3Q1W1E3fTVnUThUNW9TOGQ2WzZgUThmNl9ROVU3a1E5XjhPUTljOFVROWo4ZVE5ejlWUTpQOV9ROlQ5a1I6XTpRUSV2eVEnXyFpUSdqIXRVK2QldyV4JXlRLHsnUVUtYCdgJ2EnYlMtZCdmJ3BRL3AqYlMwbytlK2ZRMlssfVMyaC1hLWJRMm8taVE0WS90UTRyMHBRNlYyYlE2WTJpUTZfMnBSN1o0XlMkd2k8WVIqdCVWVSVVaSVWPFlSMFcqclEkdmlTKG8jdStgUShzI3dTKWAkYyRkUSpVJHhRKl4ke1EqbSVPUSpuJVFRKnclW1EqeCVdUSp8JWFRLmE6fFEuYjtPUS5kO1NRLmU7VVEuZjtXUS9TKXVTL1gpey9aUS9dKX1RL18qUFEvYSpSUS9pKllRL24qYFEwVSpwUTBWKnFoMGYrXS5aMV4zTzVjNmc3eThqOVs5bjpPOldRMVErd1ExUyt6UTNSO19RM1M7YVEzVDtjUTNXLmlTM2w6eTp6UTRQL2pRNFEva1E0VS9tUTRiMFFRNGQwU1E0ajBeUTVSMVJRNVQxVVE2aztnUTZsO2lRNm07a1E2bjttUTZzOn1RNnQ7UFE2djtUUTZ3O1ZRNng7WFE2fTN4UTdVNFNRN1k0W1E3YDRmUTdiNG5RN2Q0cFE4bztkUThwO2BROHE7YlE4ezdUUTlQN15ROXA7aFE5cTtqUTlyO2xROXM7blE5dDh3UTpYO3FROmI7clE7ejxZUTxXPGJRPFg8Y1E8ZDxmUjxlPGducE9Yc3QhWiNjJWombSZvJnAmcixoLG0xdzF6USFmUFMjZVojblEmdyFgVSdjIW81WTd3USd5I1JRKHwje1EpbSRtUyxhJmYmaVEsZiZqUSxzJnZRLHgnT1EtWyddUS5wKHpRL1EpblEwYitTUTBpK15RMXMsZVEyZi1eUTJ8LltRM3Mue1E0aDBbUTVhMV9RNXIxb1E1czFwUTV3MXJRNXkxdFE2TzF8UTZmM1BRNnszcFE3ezVkUThYNXRROFk1dVE4WzV4UThsNmpROV03fFI5ZzhdI1djT1BYWnN0IVohYCFvI2MjbiN7JWomZiZpJmombSZvJnAmciZ2J08nXSh6K1MrXixlLGgsbS1eLlswWzFfMW8xcDFyMXQxdzF6MXwzUDVZNWQ1dDV1NXg2ajd3N3w4XVEjWFdRI2RZUSVudVElb3ZTJXF3IWdTJ3wjVihQUShTI1lRKG4jdFEodSN4USh9JE9RKU8kUFEpUCRRUSlRJFJRKVIkU1EpUyRUUSlUJFVRKVUkVlEpViRXUSlXJFhRKVgkWVEpWiRbUSleJGFRKWIkZVcpbCRtKW4uezNwUStaJXBRK28lfVMtTydTMl1RLW0nbVMtcid9LXRRLXcoVlEteSheUS5oKHJRLm4odlEucjpjUS50OmZRLnU6Z1EudjpqUS9WKXlRMF8rT1EyVyx5UTJaLHxRMmstZlEyci16UTNZLmxRM186a1EzYDpsUTNhOm1RM2I6blEzYzpvUTNkOnBRM2U6cVEzZjpyUTNnOnNRM2g6dFEzaTp1UTNqOnZRM2suc1Ezbjp7UTNvO1lRM3Q6d1E0azBhUTRzMHFRNlU7WlE2WzJtUTZhMnNRNm8zWlE2cDtbUTZ5O15RNno7ZVE3cjVXUThhNlNROGU2XVE4bjtmUTh0O29ROHU7cFE5azhnUTl7OVdROlM5aVE6ZSNSUjxQPF1SI1pXUidVIWVZIXRRJ1otWTFbNV1TJ1EhZS1RUSdmIXJTJ3AhdSF4UydyIXk1X1MsfSdSJ1lTLWknZydoUS1rJ2lRMmItV1IycC1qUih0I3dSKHcjeFEhZlFULVgnWi1ZXSFxUSFyJ1otWTFbNV1RI29dUidkOmRUI2paJWJTI2laJWJTJWhtLGRVKGEjZyNoI2tTLX0oYihjUS5SKGRRMGMrVFEydS5PVTJ2LlAuUS5TUzZjMncyeFI4aDZkYCNdVyNWI1klZSd9KFcrUS14ciNmWm0jZyNoI2slYihiKGMoZCtULk8uUC5RLlMydzJ4NmRRMXEsZFEyWCx6UTZRMlBROGA2UlQ7dydTK1JUI2BXJWVTI19XJWVTKE8jVihXUyhUI1krUVMtUCdTK1JULXMnfS14VCdYIWUlZlEka2ZSKXMkcFQpaCRrKWlSM3IuelQqWCR4KlpSKmEke1EwZytdUTJ6LlpRNWAxXlE2aDNPUTd6NWNROGs2Z1E5WTd5UTlsOGpROX05W1E6VjluUTpbOk9SOl86V25xT1hzdCFaI2MlaiZtJm8mcCZyLGgsbTF3MXpRJmchVlIsXSZkdG1PWHN0IVUhViFaI2MlaiZkJm0mbyZwJnIsaCxtMXcxelIsZCZqVCVpbSxkUjFXK3xSLFsmYlEmUXxSK3QmUlIraiV7VCZrIVcmblQmbCFXJm5UMXksbTF6XCIsXG4gIG5vZGVOYW1lczogXCLimqAgQXJpdGhPcCBBcml0aE9wIEpTWFN0YXJ0VGFnIExpbmVDb21tZW50IEJsb2NrQ29tbWVudCBTY3JpcHQgSGFzaGJhbmcgRXhwb3J0RGVjbGFyYXRpb24gZXhwb3J0IFN0YXIgYXMgVmFyaWFibGVOYW1lIFN0cmluZyBFc2NhcGUgZnJvbSA7IGRlZmF1bHQgRnVuY3Rpb25EZWNsYXJhdGlvbiBhc3luYyBmdW5jdGlvbiBWYXJpYWJsZURlZmluaXRpb24gPiA8IFR5cGVQYXJhbUxpc3QgVHlwZURlZmluaXRpb24gZXh0ZW5kcyBUaGlzVHlwZSB0aGlzIExpdGVyYWxUeXBlIEFyaXRoT3AgTnVtYmVyIEJvb2xlYW5MaXRlcmFsIFRlbXBsYXRlVHlwZSBJbnRlcnBvbGF0aW9uRW5kIEludGVycG9sYXRpb24gSW50ZXJwb2xhdGlvblN0YXJ0IE51bGxUeXBlIG51bGwgVm9pZFR5cGUgdm9pZCBUeXBlb2ZUeXBlIHR5cGVvZiBNZW1iZXJFeHByZXNzaW9uIC4gPy4gUHJvcGVydHlOYW1lIFsgVGVtcGxhdGVTdHJpbmcgRXNjYXBlIEludGVycG9sYXRpb24gc3VwZXIgUmVnRXhwIF0gQXJyYXlFeHByZXNzaW9uIFNwcmVhZCAsIH0geyBPYmplY3RFeHByZXNzaW9uIFByb3BlcnR5IGFzeW5jIGdldCBzZXQgUHJvcGVydHlEZWZpbml0aW9uIEJsb2NrIDogTmV3RXhwcmVzc2lvbiBuZXcgVHlwZUFyZ0xpc3QgQ29tcGFyZU9wIDwgKSAoIEFyZ0xpc3QgVW5hcnlFeHByZXNzaW9uIGRlbGV0ZSBMb2dpY09wIEJpdE9wIFlpZWxkRXhwcmVzc2lvbiB5aWVsZCBBd2FpdEV4cHJlc3Npb24gYXdhaXQgUGFyZW50aGVzaXplZEV4cHJlc3Npb24gQ2xhc3NFeHByZXNzaW9uIGNsYXNzIENsYXNzQm9keSBNZXRob2REZWNsYXJhdGlvbiBEZWNvcmF0b3IgQCBNZW1iZXJFeHByZXNzaW9uIFByaXZhdGVQcm9wZXJ0eU5hbWUgQ2FsbEV4cHJlc3Npb24gZGVjbGFyZSBQcml2YWN5IHN0YXRpYyBhYnN0cmFjdCBvdmVycmlkZSBQcml2YXRlUHJvcGVydHlEZWZpbml0aW9uIFByb3BlcnR5RGVjbGFyYXRpb24gcmVhZG9ubHkgYWNjZXNzb3IgT3B0aW9uYWwgVHlwZUFubm90YXRpb24gRXF1YWxzIFN0YXRpY0Jsb2NrIEZ1bmN0aW9uRXhwcmVzc2lvbiBBcnJvd0Z1bmN0aW9uIFBhcmFtTGlzdCBQYXJhbUxpc3QgQXJyYXlQYXR0ZXJuIE9iamVjdFBhdHRlcm4gUGF0dGVyblByb3BlcnR5IFByaXZhY3kgcmVhZG9ubHkgQXJyb3cgTWVtYmVyRXhwcmVzc2lvbiBCaW5hcnlFeHByZXNzaW9uIEFyaXRoT3AgQXJpdGhPcCBBcml0aE9wIEFyaXRoT3AgQml0T3AgQ29tcGFyZU9wIGluc3RhbmNlb2Ygc2F0aXNmaWVzIGluIGNvbnN0IENvbXBhcmVPcCBCaXRPcCBCaXRPcCBCaXRPcCBMb2dpY09wIExvZ2ljT3AgQ29uZGl0aW9uYWxFeHByZXNzaW9uIExvZ2ljT3AgTG9naWNPcCBBc3NpZ25tZW50RXhwcmVzc2lvbiBVcGRhdGVPcCBQb3N0Zml4RXhwcmVzc2lvbiBDYWxsRXhwcmVzc2lvbiBUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24gRHluYW1pY0ltcG9ydCBpbXBvcnQgSW1wb3J0TWV0YSBKU1hFbGVtZW50IEpTWFNlbGZDbG9zZUVuZFRhZyBKU1hTZWxmQ2xvc2luZ1RhZyBKU1hJZGVudGlmaWVyIEpTWEJ1aWx0aW4gSlNYSWRlbnRpZmllciBKU1hOYW1lc3BhY2VkTmFtZSBKU1hNZW1iZXJFeHByZXNzaW9uIEpTWFNwcmVhZEF0dHJpYnV0ZSBKU1hBdHRyaWJ1dGUgSlNYQXR0cmlidXRlVmFsdWUgSlNYRXNjYXBlIEpTWEVuZFRhZyBKU1hPcGVuVGFnIEpTWEZyYWdtZW50VGFnIEpTWFRleHQgSlNYRXNjYXBlIEpTWFN0YXJ0Q2xvc2VUYWcgSlNYQ2xvc2VUYWcgUHJlZml4Q2FzdCBBcnJvd0Z1bmN0aW9uIFR5cGVQYXJhbUxpc3QgU2VxdWVuY2VFeHByZXNzaW9uIEtleW9mVHlwZSBrZXlvZiBVbmlxdWVUeXBlIHVuaXF1ZSBJbXBvcnRUeXBlIEluZmVycmVkVHlwZSBpbmZlciBUeXBlTmFtZSBQYXJlbnRoZXNpemVkVHlwZSBGdW5jdGlvblNpZ25hdHVyZSBQYXJhbUxpc3QgTmV3U2lnbmF0dXJlIEluZGV4ZWRUeXBlIFR1cGxlVHlwZSBMYWJlbCBBcnJheVR5cGUgUmVhZG9ubHlUeXBlIE9iamVjdFR5cGUgTWV0aG9kVHlwZSBQcm9wZXJ0eVR5cGUgSW5kZXhTaWduYXR1cmUgUHJvcGVydHlEZWZpbml0aW9uIENhbGxTaWduYXR1cmUgVHlwZVByZWRpY2F0ZSBpcyBOZXdTaWduYXR1cmUgbmV3IFVuaW9uVHlwZSBMb2dpY09wIEludGVyc2VjdGlvblR5cGUgTG9naWNPcCBDb25kaXRpb25hbFR5cGUgUGFyYW1ldGVyaXplZFR5cGUgQ2xhc3NEZWNsYXJhdGlvbiBhYnN0cmFjdCBpbXBsZW1lbnRzIHR5cGUgVmFyaWFibGVEZWNsYXJhdGlvbiBsZXQgdmFyIHVzaW5nIFR5cGVBbGlhc0RlY2xhcmF0aW9uIEludGVyZmFjZURlY2xhcmF0aW9uIGludGVyZmFjZSBFbnVtRGVjbGFyYXRpb24gZW51bSBFbnVtQm9keSBOYW1lc3BhY2VEZWNsYXJhdGlvbiBuYW1lc3BhY2UgbW9kdWxlIEFtYmllbnREZWNsYXJhdGlvbiBkZWNsYXJlIEdsb2JhbERlY2xhcmF0aW9uIGdsb2JhbCBDbGFzc0RlY2xhcmF0aW9uIENsYXNzQm9keSBBbWJpZW50RnVuY3Rpb25EZWNsYXJhdGlvbiBFeHBvcnRHcm91cCBWYXJpYWJsZU5hbWUgVmFyaWFibGVOYW1lIEltcG9ydERlY2xhcmF0aW9uIEltcG9ydEdyb3VwIEZvclN0YXRlbWVudCBmb3IgRm9yU3BlYyBGb3JJblNwZWMgRm9yT2ZTcGVjIG9mIFdoaWxlU3RhdGVtZW50IHdoaWxlIFdpdGhTdGF0ZW1lbnQgd2l0aCBEb1N0YXRlbWVudCBkbyBJZlN0YXRlbWVudCBpZiBlbHNlIFN3aXRjaFN0YXRlbWVudCBzd2l0Y2ggU3dpdGNoQm9keSBDYXNlTGFiZWwgY2FzZSBEZWZhdWx0TGFiZWwgVHJ5U3RhdGVtZW50IHRyeSBDYXRjaENsYXVzZSBjYXRjaCBGaW5hbGx5Q2xhdXNlIGZpbmFsbHkgUmV0dXJuU3RhdGVtZW50IHJldHVybiBUaHJvd1N0YXRlbWVudCB0aHJvdyBCcmVha1N0YXRlbWVudCBicmVhayBDb250aW51ZVN0YXRlbWVudCBjb250aW51ZSBEZWJ1Z2dlclN0YXRlbWVudCBkZWJ1Z2dlciBMYWJlbGVkU3RhdGVtZW50IEV4cHJlc3Npb25TdGF0ZW1lbnQgU2luZ2xlRXhwcmVzc2lvbiBTaW5nbGVDbGFzc0l0ZW1cIixcbiAgbWF4VGVybTogMzcxLFxuICBjb250ZXh0OiBCMyxcbiAgbm9kZVByb3BzOiBbXG4gICAgW1wiaXNvbGF0ZVwiLCAtOCwgNCwgNSwgMTMsIDMzLCAzNSwgNDgsIDUwLCA1MiwgXCJcIl0sXG4gICAgW1wiZ3JvdXBcIiwgLTI2LCA4LCAxNiwgMTgsIDY1LCAyMDEsIDIwNSwgMjA5LCAyMTAsIDIxMiwgMjE1LCAyMTgsIDIyOCwgMjMwLCAyMzYsIDIzOCwgMjQwLCAyNDIsIDI0NSwgMjUxLCAyNTcsIDI1OSwgMjYxLCAyNjMsIDI2NSwgMjY3LCAyNjgsIFwiU3RhdGVtZW50XCIsIC0zMiwgMTIsIDEzLCAyOCwgMzEsIDMyLCAzOCwgNDgsIDUxLCA1MiwgNTQsIDU5LCA2NywgNzUsIDc5LCA4MSwgODMsIDg0LCAxMDYsIDEwNywgMTE2LCAxMTcsIDEzNCwgMTM3LCAxMzksIDE0MCwgMTQxLCAxNDIsIDE0NCwgMTQ1LCAxNjQsIDE2NSwgMTY3LCBcIkV4cHJlc3Npb25cIiwgLTIzLCAyNywgMjksIDMzLCAzNywgMzksIDQxLCAxNjgsIDE3MCwgMTcyLCAxNzMsIDE3NSwgMTc2LCAxNzcsIDE3OSwgMTgwLCAxODEsIDE4MywgMTg0LCAxODUsIDE5NSwgMTk3LCAxOTksIDIwMCwgXCJUeXBlXCIsIC0zLCA4NywgOTksIDEwNSwgXCJDbGFzc0l0ZW1cIl0sXG4gICAgW1wib3BlbmVkQnlcIiwgMjIsIFwiPFwiLCAzNCwgXCJJbnRlcnBvbGF0aW9uU3RhcnRcIiwgNTMsIFwiW1wiLCA1NywgXCJ7XCIsIDcyLCBcIihcIiwgMTU3LCBcIkpTWFN0YXJ0Q2xvc2VUYWdcIl0sXG4gICAgW1wiY2xvc2VkQnlcIiwgMjMsIFwiPlwiLCAzNiwgXCJJbnRlcnBvbGF0aW9uRW5kXCIsIDQ3LCBcIl1cIiwgNTgsIFwifVwiLCA3MywgXCIpXCIsIDE2MiwgXCJKU1hFbmRUYWdcIl1cbiAgXSxcbiAgcHJvcFNvdXJjZXM6IFt6M10sXG4gIHNraXBwZWROb2RlczogWzAsIDQsIDUsIDI3MV0sXG4gIHJlcGVhdE5vZGVDb3VudDogMzcsXG4gIHRva2VuRGF0YTogXCIkRmooQ1NSIWJPWCVaWFkrZ1laLXlaWytnW10lWl1eLmNecCVacHErZ3FyL21yczNjc3Q6X3R1RXJ1dkpTdndMa3d4ISBZeHkhJ2l5eiEoc3p7ISl9e3whLHF8fSEuT30hTyEscSFPIVAhL1khUCFRITlqIVEhUiM4ZyFSIVsjOnYhWyFdI0d2IV0hXiNJUyFeIV8jSl4hXyFgI05zIWAhYSQjXyFhIWIkKGwhYiFjJCxrIWMhfUVyIX0jTyQtdSNPI1AkL1AjUCNRJDRoI1EjUiQ1ciNSI1NFciNTI1QkN1AjVCNvJDhaI28jcCQ8ayNwI3EkPWEjcSNyJD5xI3IjcyQ/fSNzJGYlWiRmJGcrZyRnI0JZRXIjQlkjQlokQVgjQlokSVNFciRJUyRJXyRBWCRJXyRJfEVyJEl8JEl9JERkJEl9JEpPJERkJEpPJEpURXIkSlQkSlUkQVgkSlUkS1ZFciRLViRLVyRBWCRLVyZGVUVyJkZVJkZWJEFYJkZWOydTRXI7J1M7PWBJfDwlbD9IVEVyP0hUP0hVJEFYP0hVT0VyKG4lZF8kZiZqKE9wKFIhYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJmomaFQkZiZqTyFeJmMhXyNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmMmaiZ6UDs9YDwlbCZjJ3wnVV0kZiZqKFIhYk9ZJn1ZWiZjWncmfXd4JmN4IV4mfSFeIV8nfSFfI08mfSNPI1AmYyNQI28mfSNvI3AnfSNwOydTJn07J1M7PWAobDwlbE8mfSFiKFNVKFIhYk9ZJ31adyd9eCNPJ30jUDsnUyd9OydTOz1gKGY8JWxPJ30hYihpUDs9YDwlbCd9J3wob1A7PWA8JWwmfSdbKHldJGYmaihPcE9ZKHJZWiZjWnIocnJzJmNzIV4ociFeIV8pciFfI08ociNPI1AmYyNQI28ociNvI3ApciNwOydTKHI7J1M7PWAqYTwlbE8ocnApd1UoT3BPWSlyWnIpcnMjTylyI1A7J1MpcjsnUzs9YCpaPCVsTylycCpeUDs9YDwlbClyJ1sqZFA7PWA8JWwociNTKm5YKE9wKFIhYk9ZKmdacipncnMnfXN3Kmd3eClyeCNPKmcjUDsnUypnOydTOz1gK1o8JWxPKmcjUyteUDs9YDwlbCpnKG4rZFA7PWA8JWwlWihDUytycSRmJmooT3AoUiFiJ3QoO2RPWCVaWFkrZ1laJmNaWytnW3AlWnBxK2dxciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcCRmJVokZiRnK2ckZyNCWSVaI0JZI0JaK2cjQlokSVMlWiRJUyRJXytnJElfJEpUJVokSlQkSlUrZyRKVSRLViVaJEtWJEtXK2ckS1cmRlUlWiZGVSZGVitnJkZWOydTJVo7J1M7PWArYTwlbD9IVCVaP0hUP0hVK2c/SFVPJVooQ1MuU1QoUCNTJGYmaid1KDtkTyFeJmMhXyNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmMoQ1Mubl8kZiZqKE9wKFIhYid1KDtkT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVolI2AveGAkZiZqIW8kSXAoT3AoUiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgMHohYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVolI1MxVmAjdCRJZCRmJmooT3AoUiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgMlghYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVolI1MyZF8jdCRJZCRmJmooT3AoUiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVokL3wzbF8nfSQobiRmJmooUiFiT1k0a1laNXFacjRrcnM3bnN3NGt3eDVxeCFeNGshXiFfOHAhXyNPNGsjTyNQNXEjUCNvNGsjbyNwOHAjcDsnUzRrOydTOz1gOlg8JWxPNGsoXjRyXyRmJmooUiFiT1k0a1laNXFacjRrcnM3bnN3NGt3eDVxeCFeNGshXiFfOHAhXyNPNGsjTyNQNXEjUCNvNGsjbyNwOHAjcDsnUzRrOydTOz1gOlg8JWxPNGsmejV2WCRmJmpPcjVxcnM2Y3MhXjVxIV4hXzZ5IV8jbzVxI28jcDZ5I3A7J1M1cTsnUzs9YDdoPCVsTzVxJno2alQkYWAkZiZqTyFeJmMhXyNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmNgNnxUT3I2eXJzN11zOydTNnk7J1M7PWA3YjwlbE82eWA3Yk8kYWBgN2VQOz1gPCVsNnkmejdrUDs9YDwlbDVxKF43d10kYWAkZiZqKFIhYk9ZJn1ZWiZjWncmfXd4JmN4IV4mfSFeIV8nfSFfI08mfSNPI1AmYyNQI28mfSNvI3AnfSNwOydTJn07J1M7PWAobDwlbE8mfSFyOHVaKFIhYk9ZOHBZWjZ5WnI4cHJzOWhzdzhwd3g2eXgjTzhwI08jUDZ5I1A7J1M4cDsnUzs9YDpSPCVsTzhwIXI5b1UkYWAoUiFiT1knfVp3J314I08nfSNQOydTJ307J1M7PWAoZjwlbE8nfSFyOlVQOz1gPCVsOHAoXjpbUDs9YDwlbDRrIyV8OmhoJGYmaihPcChSIWJPWSVaWVomY1pxJVpxcjxTcnMmfXN0JVp0dUNydXclWnd4KHJ4IV4lWiFeIV8qZyFfIWMlWiFjIX1DciF9I08lWiNPI1AmYyNQI1IlWiNSI1NDciNTI1QlWiNUI29DciNvI3AqZyNwJGclWiRnOydTQ3I7J1M7PWBFbDwlbE9DcihyPF9fVlMkZiZqKE9wKFIhYk9ZPFNZWiZjWnI8U3JzPV5zdzxTd3hAbnghXjxTIV4hX0JtIV8jTzxTI08jUD5gI1AjbzxTI28jcEJtI3A7J1M8UzsnUzs9YENsPCVsTzxTKFE9Z11WUyRmJmooUiFiT1k9XllaJmNadz1ed3g+YHghXj1eIV4hXz9xIV8jTz1eI08jUD5gI1Ajbz1eI28jcD9xI3A7J1M9XjsnUzs9YEBoPCVsTz1eJm4+Z1hWUyRmJmpPWT5gWVomY1ohXj5gIV4hXz9TIV8jbz5gI28jcD9TI3A7J1M+YDsnUzs9YD9rPCVsTz5gUz9YU1ZTT1k/U1o7J1M/UzsnUzs9YD9lPCVsTz9TUz9oUDs9YDwlbD9TJm4/blA7PWA8JWw+YCFmP3hXVlMoUiFiT1k/cVp3P3F3eD9TeCNPP3EjTyNQP1MjUDsnUz9xOydTOz1gQGI8JWxPP3EhZkBlUDs9YDwlbD9xKFFAa1A7PWA8JWw9XidgQHddVlMkZiZqKE9wT1lAbllaJmNackBucnM+YHMhXkBuIV4hX0FwIV8jT0BuI08jUD5gI1Ajb0BuI28jcEFwI3A7J1NAbjsnUzs9YEJnPCVsT0BudEF3V1ZTKE9wT1lBcFpyQXBycz9TcyNPQXAjTyNQP1MjUDsnU0FwOydTOz1gQmE8JWxPQXB0QmRQOz1gPCVsQXAnYEJqUDs9YDwlbEBuI1dCdllWUyhPcChSIWJPWUJtWnJCbXJzP3Fzd0Jtd3hBcHgjT0JtI08jUD9TI1A7J1NCbTsnUzs9YENmPCVsT0JtI1dDaVA7PWA8JWxCbShyQ29QOz1gPCVsPFMjJXxDfWkkZiZqKGchTF4oT3AoUiFiT1klWllaJmNaciVacnMmfXN0JVp0dUNydXclWnd4KHJ4IVElWiFRIVtDciFbIV4lWiFeIV8qZyFfIWMlWiFjIX1DciF9I08lWiNPI1AmYyNQI1IlWiNSI1NDciNTI1QlWiNUI29DciNvI3AqZyNwJGclWiRnOydTQ3I7J1M7PWBFbDwlbE9DciMlfEVvUDs9YDwlbENyKENTRlJrJGYmaihPcChSIWIkWSN0J3smO2QoWyFMWU9ZJVpZWiZjWnIlWnJzJn1zdCVadHVFcnV3JVp3eChyeH0lWn0hT0d2IU8hUSVaIVEhW0VyIVshXiVaIV4hXypnIV8hYyVaIWMhfUVyIX0jTyVaI08jUCZjI1AjUiVaI1IjU0VyI1MjVCVaI1Qjb0VyI28jcCpnI3AkZyVaJGc7J1NFcjsnUzs9YEl8PCVsT0VyK2RIUmskZiZqKE9wKFIhYiRZI3RPWSVaWVomY1pyJVpycyZ9c3QlWnR1R3Z1dyVad3gocnh9JVp9IU9HdiFPIVElWiFRIVtHdiFbIV4lWiFeIV8qZyFfIWMlWiFjIX1HdiF9I08lWiNPI1AmYyNQI1IlWiNSI1NHdiNTI1QlWiNUI29HdiNvI3AqZyNwJGclWiRnOydTR3Y7J1M7PWBJdjwlbE9HditkSXlQOz1gPCVsR3YoQ1NKUFA7PWA8JWxFciUjU0pfYCRmJmooT3AoUiFiI2wkSWRPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWBLYSFgI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiUjU0tsXyRmJmokTyRJZChPcChSIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiZDT0x2YShwJjtgJGYmaihPcChSIWJPWSVaWVomY1pyJVpycyZ9c3YlWnZ3TXt3eChyeCFeJVohXiFfKmchXyFgS2EhYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVolI1NOV2AkZiZqI3gkSWQoT3AoUiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgS2EhYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVokL3whIGNfKFEkKWAkZiZqKE9wT1khIWJZWiEjaFpyISFicnMhI2hzdyEhYnd4ISR4eCFeISFiIV4hXyEleiFfI08hIWIjTyNQISNoI1AjbyEhYiNvI3AhJXojcDsnUyEhYjsnUzs9YCEnYzwlbE8hIWInbCEhaV8kZiZqKE9wT1khIWJZWiEjaFpyISFicnMhI2hzdyEhYnd4ISR4eCFeISFiIV4hXyEleiFfI08hIWIjTyNQISNoI1AjbyEhYiNvI3AhJXojcDsnUyEhYjsnUzs9YCEnYzwlbE8hIWImeiEjbVgkZiZqT3chI2h3eDZjeCFeISNoIV4hXyEkWSFfI28hI2gjbyNwISRZI3A7J1MhI2g7J1M7PWAhJHI8JWxPISNoYCEkXVRPdyEkWXd4N114OydTISRZOydTOz1gISRsPCVsTyEkWWAhJG9QOz1gPCVsISRZJnohJHVQOz1gPCVsISNoJ2whJVJdJGFgJGYmaihPcE9ZKHJZWiZjWnIocnJzJmNzIV4ociFeIV8pciFfI08ociNPI1AmYyNQI28ociNvI3ApciNwOydTKHI7J1M7PWAqYTwlbE8ociFRISZQWihPcE9ZISV6WVohJFlaciElenJzISRZc3chJXp3eCEmcngjTyEleiNPI1AhJFkjUDsnUyElejsnUzs9YCEnXTwlbE8hJXohUSEmeVUkYWAoT3BPWSlyWnIpcnMjTylyI1A7J1MpcjsnUzs9YCpaPCVsTylyIVEhJ2BQOz1gPCVsISV6J2whJ2ZQOz1gPCVsISFiKCpRISd0XyFrKCFiJGYmaihPcChSIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiEnbCEpT18hak18JGYmaihPcChSIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWicraCEqW2IkZiZqKE9wKFIhYid8IylkI20kSWRPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4eiVaenshK2R7IV4lWiFeIV8qZyFfIWBLYSFgI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiUjUyErb2AkZiZqKE9wKFIhYiNqJElkT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgS2EhYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVomLU8hLHxgJGYmaihPcChSIWJuJiVgT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgS2EhYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVomQ1shLlpfIVkmO2wkZiZqKE9wKFIhYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKENTIS9lYyRmJmooT3AoUiFifCc8bk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghTyVaIU8hUCEwcCFQIVElWiFRIVshM1khWyFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVohJ2QhMHlhJGYmaihPcChSIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IU8lWiFPIVAhMk8hUCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVohJ2QhMlpfIVhNdCRmJmooT3AoUiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVokL2whM2VnJGYmaihPcChSIWJvJCd8T1klWllaJmNaciVacnMmfXN3JVp3eChyeCFRJVohUSFbITNZIVshXiVaIV4hXypnIV8hZyVaIWchaCE0fCFoI08lWiNPI1AmYyNQI1IlWiNSI1MhM1kjUyNYJVojWCNZITR8I1kjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJC9sITVWZyRmJmooT3AoUiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeHslWnt8ITZufH0lWn0hTyE2biFPIVElWiFRIVshOFMhWyFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNSJVojUiNTIThTI1MjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJC9sITZ3YyRmJmooT3AoUiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFRJVohUSFbIThTIVshXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjUiVaI1IjUyE4UyNTI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiQvbCE4X2MkZiZqKE9wKFIhYm8kJ3xPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IVElWiFRIVshOFMhWyFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNSJVojUiNTIThTI1MjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKENTITl1ZiRmJmooT3AoUiFiI2skSWRPWSE7WllaJmNaciE7WnJzITxuc3chO1p3eCFLcHh6ITtaensjLGZ7IVAhO1ohUCFRIy17IVEhXiE7WiFeIV8jJ1ohXyFgIzVrIWAhYSM3USFhIX0hO1ohfSNPIyp9I08jUCFEaiNQI28hO1ojbyNwIydaI3A7J1MhO1o7J1M7PWAjLGA8JWxPITtaKHIhO2ZiJGYmaihPcChSIWIhVVNPWSE7WllaJmNaciE7WnJzITxuc3chO1p3eCFLcHghUCE7WiFQIVEjJVohUSFeITtaIV4hXyMnWiFfIX0hO1ohfSNPIyp9I08jUCFEaiNQI28hO1ojbyNwIydaI3A7J1MhO1o7J1M7PWAjLGA8JWxPITtaKFEhPHdgJGYmaihSIWIhVVNPWSE8bllaJmNadyE8bnd4IT15eCFQITxuIVAhUSFFYiFRIV4hPG4hXiFfIUdZIV8hfSE8biF9I08hSmEjTyNQIURqI1AjbyE8biNvI3AhR1kjcDsnUyE8bjsnUzs9YCFLajwlbE8hPG4mbiE+UV4kZiZqIVVTT1khPXlZWiZjWiFQIT15IVAhUSE+fCFRIV4hPXkhXiFfIUBZIV8hfSE9eSF9I08hQncjTyNQIURqI1AjbyE9eSNvI3AhQFkjcDsnUyE9eTsnUzs9YCFFWzwlbE8hPXkmbiE/VGEkZiZqIVVTTyFeJmMhXyNaJmMjWiNbIT58I1sjXSZjI10jXiE+fCNeI2EmYyNhI2IhPnwjYiNnJmMjZyNoIT58I2gjaSZjI2kjaiE+fCNqI20mYyNtI24hPnwjbiNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmNTIUBfWCFVU09ZIUBZWiFQIUBZIVAhUSFAeiFRIX0hQFkhfSNPIUFjI08jUCFCYiNQOydTIUBZOydTOz1gIUJxPCVsTyFAWVMhQVBVIVVTI1ojWyFAeiNdI14hQHojYSNiIUB6I2cjaCFAeiNpI2ohQHojbSNuIUB6UyFBZlZPWSFBY1ojTyFBYyNPI1AhQXsjUCNRIUBZI1E7J1MhQWM7J1M7PWAhQls8JWxPIUFjUyFCT1NPWSFBY1o7J1MhQWM7J1M7PWAhQls8JWxPIUFjUyFCX1A7PWA8JWwhQWNTIUJlU09ZIUBZWjsnUyFAWTsnUzs9YCFCcTwlbE8hQFlTIUJ0UDs9YDwlbCFAWSZuIUJ8WyRmJmpPWSFCd1laJmNaIV4hQnchXiFfIUFjIV8jTyFCdyNPI1AhQ3IjUCNRIT15I1EjbyFCdyNvI3AhQWMjcDsnUyFCdzsnUzs9YCFEZDwlbE8hQncmbiFDd1gkZiZqT1khQndZWiZjWiFeIUJ3IV4hXyFBYyFfI28hQncjbyNwIUFjI3A7J1MhQnc7J1M7PWAhRGQ8JWxPIUJ3Jm4hRGdQOz1gPCVsIUJ3Jm4hRG9YJGYmak9ZIT15WVomY1ohXiE9eSFeIV8hQFkhXyNvIT15I28jcCFAWSNwOydTIT15OydTOz1gIUVbPCVsTyE9eSZuIUVfUDs9YDwlbCE9eShRIUVraSRmJmooUiFiIVVTT1kmfVlaJmNadyZ9d3gmY3ghXiZ9IV4hXyd9IV8jTyZ9I08jUCZjI1AjWiZ9I1ojWyFFYiNbI10mfSNdI14hRWIjXiNhJn0jYSNiIUViI2IjZyZ9I2cjaCFFYiNoI2kmfSNpI2ohRWIjaiNtJn0jbSNuIUViI24jbyZ9I28jcCd9I3A7J1MmfTsnUzs9YChsPCVsTyZ9IWYhR2FaKFIhYiFVU09ZIUdZWnchR1l3eCFAWXghUCFHWSFQIVEhSFMhUSF9IUdZIX0jTyFJYyNPI1AhQmIjUDsnUyFHWTsnUzs9YCFKWjwlbE8hR1khZiFIWmIoUiFiIVVTT1knfVp3J314I08nfSNQI1onfSNaI1shSFMjWyNdJ30jXSNeIUhTI14jYSd9I2EjYiFIUyNiI2cnfSNnI2ghSFMjaCNpJ30jaSNqIUhTI2ojbSd9I20jbiFIUyNuOydTJ307J1M7PWAoZjwlbE8nfSFmIUloWChSIWJPWSFJY1p3IUljd3ghQWN4I08hSWMjTyNQIUF7I1AjUSFHWSNROydTIUljOydTOz1gIUpUPCVsTyFJYyFmIUpXUDs9YDwlbCFJYyFmIUpeUDs9YDwlbCFHWShRIUpoXiRmJmooUiFiT1khSmFZWiZjWnchSmF3eCFCd3ghXiFKYSFeIV8hSWMhXyNPIUphI08jUCFDciNQI1EhPG4jUSNvIUphI28jcCFJYyNwOydTIUphOydTOz1gIUtkPCVsTyFKYShRIUtnUDs9YDwlbCFKYShRIUttUDs9YDwlbCE8bidgIUt5YCRmJmooT3AhVVNPWSFLcFlaJmNaciFLcHJzIT15cyFQIUtwIVAhUSFMeyFRIV4hS3AhXiFfIU5zIV8hfSFLcCF9I08jI3ojTyNQIURqI1AjbyFLcCNvI3AhTnMjcDsnUyFLcDsnUzs9YCMlVDwlbE8hS3AnYCFNVWkkZiZqKE9wIVVTT1kocllaJmNacihycnMmY3MhXihyIV4hXylyIV8jTyhyI08jUCZjI1AjWihyI1ojWyFMeyNbI10ociNdI14hTHsjXiNhKHIjYSNiIUx7I2IjZyhyI2cjaCFMeyNoI2kociNpI2ohTHsjaiNtKHIjbSNuIUx7I24jbyhyI28jcClyI3A7J1MocjsnUzs9YCphPCVsTyhydCFOelooT3AhVVNPWSFOc1pyIU5zcnMhQFlzIVAhTnMhUCFRIyBtIVEhfSFOcyF9I08jIXwjTyNQIUJiI1A7J1MhTnM7J1M7PWAjI3Q8JWxPIU5zdCMgdGIoT3AhVVNPWSlyWnIpcnMjTylyI1AjWilyI1ojWyMgbSNbI10pciNdI14jIG0jXiNhKXIjYSNiIyBtI2IjZylyI2cjaCMgbSNoI2kpciNpI2ojIG0jaiNtKXIjbSNuIyBtI247J1MpcjsnUzs9YCpaPCVsTylydCMjUlgoT3BPWSMhfFpyIyF8cnMhQWNzI08jIXwjTyNQIUF7I1AjUSFOcyNROydTIyF8OydTOz1gIyNuPCVsTyMhfHQjI3FQOz1gPCVsIyF8dCMjd1A7PWA8JWwhTnMnYCMkUl4kZiZqKE9wT1kjI3pZWiZjWnIjI3pycyFCd3MhXiMjeiFeIV8jIXwhXyNPIyN6I08jUCFDciNQI1EhS3AjUSNvIyN6I28jcCMhfCNwOydTIyN6OydTOz1gIyR9PCVsTyMjeidgIyVRUDs9YDwlbCMjeidgIyVXUDs9YDwlbCFLcChyIyVmayRmJmooT3AoUiFiIVVTT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNaJVojWiNbIyVaI1sjXSVaI10jXiMlWiNeI2ElWiNhI2IjJVojYiNnJVojZyNoIyVaI2gjaSVaI2kjaiMlWiNqI20lWiNtI24jJVojbiNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVojVyMnZF0oT3AoUiFiIVVTT1kjJ1paciMnWnJzIUdZc3cjJ1p3eCFOc3ghUCMnWiFQIVEjKF0hUSF9IydaIX0jTyMpdyNPI1AhQmIjUDsnUyMnWjsnUzs9YCMqdzwlbE8jJ1ojVyMoZmUoT3AoUiFiIVVTT1kqZ1pyKmdycyd9c3cqZ3d4KXJ4I08qZyNQI1oqZyNaI1sjKF0jWyNdKmcjXSNeIyhdI14jYSpnI2EjYiMoXSNiI2cqZyNnI2gjKF0jaCNpKmcjaSNqIyhdI2ojbSpnI20jbiMoXSNuOydTKmc7J1M7PWArWjwlbE8qZyNXIypPWihPcChSIWJPWSMpd1pyIyl3cnMhSWNzdyMpd3d4IyF8eCNPIyl3I08jUCFBeyNQI1EjJ1ojUTsnUyMpdzsnUzs9YCMqcTwlbE8jKXcjVyMqdFA7PWA8JWwjKXcjVyMqelA7PWA8JWwjJ1oociMrV2AkZiZqKE9wKFIhYk9ZIyp9WVomY1pyIyp9cnMhSmFzdyMqfXd4IyN6eCFeIyp9IV4hXyMpdyFfI08jKn0jTyNQIUNyI1AjUSE7WiNRI28jKn0jbyNwIyl3I3A7J1MjKn07J1M7PWAjLFk8JWxPIyp9KHIjLF1QOz1gPCVsIyp9KHIjLGNQOz1gPCVsITtaKENTIyxzYiRmJmooT3AoUiFiJ3YoO2QhVVNPWSE7WllaJmNaciE7WnJzITxuc3chO1p3eCFLcHghUCE7WiFQIVEjJVohUSFeITtaIV4hXyMnWiFfIX0hO1ohfSNPIyp9I08jUCFEaiNQI28hO1ojbyNwIydaI3A7J1MhO1o7J1M7PWAjLGA8JWxPITtaKENTIy5XXyRmJmooT3AoUiFiUyg7ZE9ZIy17WVomY1pyIy17cnMjL1ZzdyMte3d4IzJneCFeIy17IV4hXyM0ZiFfI08jLXsjTyNQIzBYI1AjbyMteyNvI3AjNGYjcDsnUyMtezsnUzs9YCM1ZTwlbE8jLXsoQmIjL2BdJGYmaihSIWJTKDtkT1kjL1ZZWiZjWncjL1Z3eCMwWHghXiMvViFeIV8jMWohXyNPIy9WI08jUCMwWCNQI28jL1YjbyNwIzFqI3A7J1MjL1Y7J1M7PWAjMmE8JWxPIy9WKEFPIzBgWCRmJmpTKDtkT1kjMFhZWiZjWiFeIzBYIV4hXyMweyFfI28jMFgjbyNwIzB7I3A7J1MjMFg7J1M7PWAjMWQ8JWxPIzBYKDtkIzFRU1MoO2RPWSMwe1o7J1MjMHs7J1M7PWAjMV48JWxPIzB7KDtkIzFhUDs9YDwlbCMweyhBTyMxZ1A7PWA8JWwjMFgoPHYjMXFXKFIhYlMoO2RPWSMxalp3IzFqd3gjMHt4I08jMWojTyNQIzB7I1A7J1MjMWo7J1M7PWAjMlo8JWxPIzFqKDx2IzJeUDs9YDwlbCMxaihCYiMyZFA7PWA8JWwjL1YoQXAjMnBdJGYmaihPcFMoO2RPWSMyZ1laJmNaciMyZ3JzIzBYcyFeIzJnIV4hXyMzaSFfI08jMmcjTyNQIzBYI1AjbyMyZyNvI3AjM2kjcDsnUyMyZzsnUzs9YCM0YDwlbE8jMmcoPFUjM3BXKE9wUyg7ZE9ZIzNpWnIjM2lycyMwe3MjTyMzaSNPI1AjMHsjUDsnUyMzaTsnUzs9YCM0WTwlbE8jM2koPFUjNF1QOz1gPCVsIzNpKEFwIzRjUDs9YDwlbCMyZyg9aCM0b1koT3AoUiFiUyg7ZE9ZIzRmWnIjNGZycyMxanN3IzRmd3gjM2l4I08jNGYjTyNQIzB7I1A7J1MjNGY7J1M7PWAjNV88JWxPIzRmKD1oIzViUDs9YDwlbCM0ZihDUyM1aFA7PWA8JWwjLXslI1cjNXhiJGYmaiRPJElkKE9wKFIhYiFVU09ZITtaWVomY1pyITtacnMhPG5zdyE7Wnd4IUtweCFQITtaIVAhUSMlWiFRIV4hO1ohXiFfIydaIV8hfSE7WiF9I08jKn0jTyNQIURqI1AjbyE7WiNvI3AjJ1ojcDsnUyE7WjsnUzs9YCMsYDwlbE8hO1oraCM3X2IkVyN0JGYmaihPcChSIWIhVVNPWSE7WllaJmNaciE7WnJzITxuc3chO1p3eCFLcHghUCE7WiFQIVEjJVohUSFeITtaIV4hXyMnWiFfIX0hO1ohfSNPIyp9I08jUCFEaiNQI28hO1ojbyNwIydaI3A7J1MhO1o7J1M7PWAjLGA8JWxPITtaJC9sIzhycCRmJmooT3AoUiFibyQnfE9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghTyVaIU8hUCEzWSFQIVElWiFRIVsjOnYhWyFeJVohXiFfKmchXyFnJVohZyFoITR8IWgjTyVaI08jUCZjI1AjUiVaI1IjUyM6diNTI1UlWiNVI1YjPlEjViNYJVojWCNZITR8I1kjYiVaI2IjYyM8diNjI2QjQVkjZCNsJVojbCNtI0RbI20jbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJC9sIztSayRmJmooT3AoUiFibyQnfE9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghTyVaIU8hUCEzWSFQIVElWiFRIVsjOnYhWyFeJVohXiFfKmchXyFnJVohZyFoITR8IWgjTyVaI08jUCZjI1AjUiVaI1IjUyM6diNTI1glWiNYI1khNHwjWSNiJVojYiNjIzx2I2MjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJC9sIz1SXyRmJmooT3AoUiFibyQnfE9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJC9sIz5aZCRmJmooT3AoUiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFRJVohUSFSIz9pIVIhUyM/aSFTIV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI1IlWiNSI1MjP2kjUyNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVokL2wjP3RmJGYmaihPcChSIWJvJCd8T1klWllaJmNaciVacnMmfXN3JVp3eChyeCFRJVohUSFSIz9pIVIhUyM/aSFTIV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI1IlWiNSI1MjP2kjUyNiJVojYiNjIzx2I2MjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJC9sI0FjYyRmJmooT3AoUiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFRJVohUSFZI0JuIVkhXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjUiVaI1IjUyNCbiNTI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiQvbCNCeWUkZiZqKE9wKFIhYm8kJ3xPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IVElWiFRIVkjQm4hWSFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNSJVojUiNTI0JuI1MjYiVaI2IjYyM8diNjI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiQvbCNEZWckZiZqKE9wKFIhYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghUSVaIVEhWyNFfCFbIV4lWiFeIV8qZyFfIWMlWiFjIWkjRXwhaSNPJVojTyNQJmMjUCNSJVojUiNTI0V8I1MjVCVaI1QjWiNFfCNaI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiQvbCNGWGkkZiZqKE9wKFIhYm8kJ3xPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IVElWiFRIVsjRXwhWyFeJVohXiFfKmchXyFjJVohYyFpI0V8IWkjTyVaI08jUCZjI1AjUiVaI1IjUyNFfCNTI1QlWiNUI1ojRXwjWiNiJVojYiNjIzx2I2MjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJUdoI0hUXyFkJGIkZiZqI3wlPGYoT3AoUiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVopWyNJX19gbCRmJmooT3AoUiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVooQF4jSmteZyEqdiFoJy5yKE9wKFIhYih0U09ZKmdacipncnMnfXN3Kmd3eClyeCFQKmchUCFRI0tnIVEhXipnIV4hXyNMXSFfIWAjTX0hYCNPKmcjUDsnUypnOydTOz1gK1o8JWxPKmcobiNLcFgkaCZqKE9wKFIhYk9ZKmdacipncnMnfXN3Kmd3eClyeCNPKmcjUDsnUypnOydTOz1gK1o8JWxPKmckS2gjTGZaI24kSWQoT3AoUiFiT1kqZ1pyKmdycyd9c3cqZ3d4KXJ4IV8qZyFfIWAjTVghYCNPKmcjUDsnUypnOydTOz1gK1o8JWxPKmckS2gjTWJYJE8kSWQoT3AoUiFiT1kqZ1pyKmdycyd9c3cqZ3d4KXJ4I08qZyNQOydTKmc7J1M7PWArWjwlbE8qZyRLaCNOV1gjbyRJZChPcChSIWJPWSpnWnIqZ3JzJ31zdypnd3gpcngjTypnI1A7J1MqZzsnUzs9YCtaPCVsTypnJUdoJCBPYSNbJT94JGYmaihPcChSIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWAweiFgIWEkIVQhYSNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVolI1ckIWBfI2ckSWgkZiZqKE9wKFIhYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaJUdoJCNuYWZCZiNvJElkJGMjfCRmJmooT3AoUiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgJCRzIWAhYSQlfSFhI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiUjUyQlT18jbyRJZCRmJmooT3AoUiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVolI1MkJllhI24kSWQkZiZqKE9wKFIhYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYEthIWAhYSQnXyFhI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiUjUyQnamAjbiRJZCRmJmooT3AoUiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgS2EhYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonK2gkKHdjKGgkSXAkZiZqKE9wKFIhYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghTyVaIU8hUCQqUyFQIV4lWiFeIV8qZyFfIWElWiFhIWIkK14hYiNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVonK2AkKl9ffScjcCRmJmooT3AoUiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVolI1MkK2lgJGYmaiN5JElkKE9wKFIhYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8hYEthIWAjTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaIyZeJCx2XyF7IUxuJGYmaihPcChSIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWihAXiQuUV8hUCg4biRmJmooT3AoUiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVoobiQvVVokZiZqTyFeJC93IV4hXyQwXyFfI2kkL3cjaSNqJDBkI2ojbCQvdyNsI20kMlYjbSNvJC93I28jcCQwXyNwOydTJC93OydTOz1gJDRiPCVsTyQvdyhuJDBPVF4jUyRmJmpPIV4mYyFfI28mYyNwOydTJmM7J1M7PWAmdzwlbE8mYyNTJDBkT14jUyhuJDBpWyRmJmpPIVEmYyFRIVskMV8hWyFeJmMhXyFjJmMhYyFpJDFfIWkjVCZjI1QjWiQxXyNaI28mYyNvI3AkM3UjcDsnUyZjOydTOz1gJnc8JWxPJmMobiQxZFokZiZqTyFRJmMhUSFbJDJWIVshXiZjIV8hYyZjIWMhaSQyViFpI1QmYyNUI1okMlYjWiNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmMobiQyW1okZiZqTyFRJmMhUSFbJDJ9IVshXiZjIV8hYyZjIWMhaSQyfSFpI1QmYyNUI1okMn0jWiNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmMobiQzU1okZiZqTyFRJmMhUSFbJC93IVshXiZjIV8hYyZjIWMhaSQvdyFpI1QmYyNUI1okL3cjWiNvJmMjcDsnUyZjOydTOz1gJnc8JWxPJmMjUyQzeFIhUSFbJDRSIWMhaSQ0UiNUI1okNFIjUyQ0VVMhUSFbJDRSIWMhaSQ0UiNUI1okNFIjcSNyJDBfKG4kNGVQOz1gPCVsJC93ITJyJDRzXyFWIStTJGYmaihPcChSIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwOydTJVo7J1M7PWArYTwlbE8lWiUjUyQ1fWAjdiRJZCRmJmooT3AoUiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyFgS2EhYCNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVomLHYkN1tfJGYmaihPcChSIWIoWCYlV09ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKENTJDhqayRmJmooT3AoUiFiJ3smO2QkWyN0KFshTFlPWSVaWVomY1pyJVpycyZ9c3QlWnR1JDhadXclWnd4KHJ4fSVafSFPJDpfIU8hUSVaIVEhWyQ4WiFbIV4lWiFeIV8qZyFfIWMlWiFjIX0kOFohfSNPJVojTyNQJmMjUCNSJVojUiNTJDhaI1MjVCVaI1QjbyQ4WiNvI3AqZyNwJGclWiRnOydTJDhaOydTOz1gJDxlPCVsTyQ4WitkJDpqayRmJmooT3AoUiFiJFsjdE9ZJVpZWiZjWnIlWnJzJn1zdCVadHUkOl91dyVad3gocnh9JVp9IU8kOl8hTyFRJVohUSFbJDpfIVshXiVaIV4hXypnIV8hYyVaIWMhfSQ6XyF9I08lWiNPI1AmYyNQI1IlWiNSI1MkOl8jUyNUJVojVCNvJDpfI28jcCpnI3AkZyVaJGc7J1MkOl87J1M7PWAkPF88JWxPJDpfK2QkPGJQOz1gPCVsJDpfKENTJDxoUDs9YDwlbCQ4WiE1cCQ8dFghWyEzbChPcChSIWJPWSpnWnIqZ3JzJ31zdypnd3gpcngjTypnI1A7J1MqZzsnUzs9YCtaPCVsTypnJkNPJD1sYShvJjtgJGYmaihPcChSIWJPWSVaWVomY1pyJVpycyZ9c3clWnd4KHJ4IV4lWiFeIV8qZyFfIWBLYSFgI08lWiNPI1AmYyNQI28lWiNvI3AqZyNwI3EkK14jcTsnUyVaOydTOz1gK2E8JWxPJVolI2AkP09fIVokSWByYCRmJmooT3AoUiFiT1klWllaJmNaciVacnMmfXN3JVp3eChyeCFeJVohXiFfKmchXyNPJVojTyNQJmMjUCNvJVojbyNwKmcjcDsnUyVaOydTOz1gK2E8JWxPJVoociRAWV8hcFMkZiZqKE9wKFIhYk9ZJVpZWiZjWnIlWnJzJn1zdyVad3gocnghXiVaIV4hXypnIV8jTyVaI08jUCZjI1AjbyVaI28jcCpnI3A7J1MlWjsnUzs9YCthPCVsTyVaKENTJEFqfCRmJmooT3AoUiFiJ3QoO2QkWSN0J3smO2QoWyFMWU9YJVpYWStnWVomY1pbK2dbcCVacHErZ3FyJVpycyZ9c3QlWnR1RXJ1dyVad3gocnh9JVp9IU9HdiFPIVElWiFRIVtFciFbIV4lWiFeIV8qZyFfIWMlWiFjIX1FciF9I08lWiNPI1AmYyNQI1IlWiNSI1NFciNTI1QlWiNUI29FciNvI3AqZyNwJGYlWiRmJGcrZyRnI0JZRXIjQlkjQlokQVgjQlokSVNFciRJUyRJXyRBWCRJXyRKVEVyJEpUJEpVJEFYJEpVJEtWRXIkS1YkS1ckQVgkS1cmRlVFciZGVSZGViRBWCZGVjsnU0VyOydTOz1gSXw8JWw/SFRFcj9IVD9IVSRBWD9IVU9FcihDUyREdWskZiZqKE9wKFIhYid1KDtkJFkjdCd7JjtkKFshTFlPWSVaWVomY1pyJVpycyZ9c3QlWnR1RXJ1dyVad3gocnh9JVp9IU9HdiFPIVElWiFRIVtFciFbIV4lWiFeIV8qZyFfIWMlWiFjIX1FciF9I08lWiNPI1AmYyNQI1IlWiNSI1NFciNTI1QlWiNUI29FciNvI3AqZyNwJGclWiRnOydTRXI7J1M7PWBJfDwlbE9FclwiLFxuICB0b2tlbml6ZXJzOiBbVTMsIHEzLCBZMywgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMiwgMTMsIEwzLCBuZXcgSHUoXCIkU35SUnR1WyNPI1BnI1MjVCN8fl9QI28jcGJ+Z090fn5qVk8jaSFQI2kjaiFVI2ojbCFQI2wjbSFxI207J1MhUDsnUzs9YCN2PCVsTyFQfiFVTyFSfn4hWFMhUSFbIWUhYyFpIWUjVCNaIWUjbyNwI1p+IWhSIVEhWyFxIWMhaSFxI1QjWiFxfiF0UiFRIVshfSFjIWkhfSNUI1ohfX4jUVIhUSFbIVAhYyFpIVAjVCNaIVB+I15SIVEhWyNnIWMhaSNnI1QjWiNnfiNqUyFRIVsjZyFjIWkjZyNUI1ojZyNxI3IhUH4jeVA7PWA8JWwhUH4kUk8oWn5+XCIsIDE0MSwgMzMyKSwgbmV3IEh1KFwian5SUVlaWHp7Xn5eTyd4fn5hUCFQIVFkfmlPJ3l+flwiLCAyNSwgMzE1KV0sXG4gIHRvcFJ1bGVzOiB7IFNjcmlwdDogWzAsIDZdLCBTaW5nbGVFeHByZXNzaW9uOiBbMSwgMjY5XSwgU2luZ2xlQ2xhc3NJdGVtOiBbMiwgMjcwXSB9LFxuICBkaWFsZWN0czogeyBqc3g6IDAsIHRzOiAxNDYxNCB9LFxuICBkeW5hbWljUHJlY2VkZW5jZXM6IHsgNjk6IDEsIDc5OiAxLCA4MTogMSwgMTY1OiAxLCAxOTM6IDEgfSxcbiAgc3BlY2lhbGl6ZWQ6IFt7IHRlcm06IDMxOSwgZ2V0OiAodCkgPT4gSDNbdF0gfHwgLTEgfSwgeyB0ZXJtOiAzMzQsIGdldDogKHQpID0+IEYzW3RdIHx8IC0xIH0sIHsgdGVybTogNzAsIGdldDogKHQpID0+IEczW3RdIHx8IC0xIH1dLFxuICB0b2tlblByZWM6IDE0NjM4XG59KSwgR3ggPSBbXG4gIC8qIEBfX1BVUkVfXyAqLyB2bihcImZ1bmN0aW9uICR7bmFtZX0oJHtwYXJhbXN9KSB7XFxuXHQke31cXG59XCIsIHtcbiAgICBsYWJlbDogXCJmdW5jdGlvblwiLFxuICAgIGRldGFpbDogXCJkZWZpbml0aW9uXCIsXG4gICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgfSksXG4gIC8qIEBfX1BVUkVfXyAqLyB2bihcImZvciAobGV0ICR7aW5kZXh9ID0gMDsgJHtpbmRleH0gPCAke2JvdW5kfTsgJHtpbmRleH0rKykge1xcblx0JHt9XFxufVwiLCB7XG4gICAgbGFiZWw6IFwiZm9yXCIsXG4gICAgZGV0YWlsOiBcImxvb3BcIixcbiAgICB0eXBlOiBcImtleXdvcmRcIlxuICB9KSxcbiAgLyogQF9fUFVSRV9fICovIHZuKFwiZm9yIChsZXQgJHtuYW1lfSBvZiAke2NvbGxlY3Rpb259KSB7XFxuXHQke31cXG59XCIsIHtcbiAgICBsYWJlbDogXCJmb3JcIixcbiAgICBkZXRhaWw6IFwib2YgbG9vcFwiLFxuICAgIHR5cGU6IFwia2V5d29yZFwiXG4gIH0pLFxuICAvKiBAX19QVVJFX18gKi8gdm4oXCJkbyB7XFxuXHQke31cXG59IHdoaWxlICgke30pXCIsIHtcbiAgICBsYWJlbDogXCJkb1wiLFxuICAgIGRldGFpbDogXCJsb29wXCIsXG4gICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgfSksXG4gIC8qIEBfX1BVUkVfXyAqLyB2bihcIndoaWxlICgke30pIHtcXG5cdCR7fVxcbn1cIiwge1xuICAgIGxhYmVsOiBcIndoaWxlXCIsXG4gICAgZGV0YWlsOiBcImxvb3BcIixcbiAgICB0eXBlOiBcImtleXdvcmRcIlxuICB9KSxcbiAgLyogQF9fUFVSRV9fICovIHZuKGB0cnkge1xuXHRcXCR7fVxufSBjYXRjaCAoXFwke2Vycm9yfSkge1xuXHRcXCR7fVxufWAsIHtcbiAgICBsYWJlbDogXCJ0cnlcIixcbiAgICBkZXRhaWw6IFwiLyBjYXRjaCBibG9ja1wiLFxuICAgIHR5cGU6IFwia2V5d29yZFwiXG4gIH0pLFxuICAvKiBAX19QVVJFX18gKi8gdm4oXCJpZiAoJHt9KSB7XFxuXHQke31cXG59XCIsIHtcbiAgICBsYWJlbDogXCJpZlwiLFxuICAgIGRldGFpbDogXCJibG9ja1wiLFxuICAgIHR5cGU6IFwia2V5d29yZFwiXG4gIH0pLFxuICAvKiBAX19QVVJFX18gKi8gdm4oYGlmIChcXCR7fSkge1xuXHRcXCR7fVxufSBlbHNlIHtcblx0XFwke31cbn1gLCB7XG4gICAgbGFiZWw6IFwiaWZcIixcbiAgICBkZXRhaWw6IFwiLyBlbHNlIGJsb2NrXCIsXG4gICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgfSksXG4gIC8qIEBfX1BVUkVfXyAqLyB2bihgY2xhc3MgXFwke25hbWV9IHtcblx0Y29uc3RydWN0b3IoXFwke3BhcmFtc30pIHtcblx0XHRcXCR7fVxuXHR9XG59YCwge1xuICAgIGxhYmVsOiBcImNsYXNzXCIsXG4gICAgZGV0YWlsOiBcImRlZmluaXRpb25cIixcbiAgICB0eXBlOiBcImtleXdvcmRcIlxuICB9KSxcbiAgLyogQF9fUFVSRV9fICovIHZuKCdpbXBvcnQgeyR7bmFtZXN9fSBmcm9tIFwiJHttb2R1bGV9XCJcXG4ke30nLCB7XG4gICAgbGFiZWw6IFwiaW1wb3J0XCIsXG4gICAgZGV0YWlsOiBcIm5hbWVkXCIsXG4gICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgfSksXG4gIC8qIEBfX1BVUkVfXyAqLyB2bignaW1wb3J0ICR7bmFtZX0gZnJvbSBcIiR7bW9kdWxlfVwiXFxuJHt9Jywge1xuICAgIGxhYmVsOiBcImltcG9ydFwiLFxuICAgIGRldGFpbDogXCJkZWZhdWx0XCIsXG4gICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgfSlcbl0sIEozID0gLyogQF9fUFVSRV9fICovIEd4LmNvbmNhdChbXG4gIC8qIEBfX1BVUkVfXyAqLyB2bihcImludGVyZmFjZSAke25hbWV9IHtcXG5cdCR7fVxcbn1cIiwge1xuICAgIGxhYmVsOiBcImludGVyZmFjZVwiLFxuICAgIGRldGFpbDogXCJkZWZpbml0aW9uXCIsXG4gICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgfSksXG4gIC8qIEBfX1BVUkVfXyAqLyB2bihcInR5cGUgJHtuYW1lfSA9ICR7dHlwZX1cIiwge1xuICAgIGxhYmVsOiBcInR5cGVcIixcbiAgICBkZXRhaWw6IFwiZGVmaW5pdGlvblwiLFxuICAgIHR5cGU6IFwia2V5d29yZFwiXG4gIH0pLFxuICAvKiBAX19QVVJFX18gKi8gdm4oXCJlbnVtICR7bmFtZX0ge1xcblx0JHt9XFxufVwiLCB7XG4gICAgbGFiZWw6IFwiZW51bVwiLFxuICAgIGRldGFpbDogXCJkZWZpbml0aW9uXCIsXG4gICAgdHlwZTogXCJrZXl3b3JkXCJcbiAgfSlcbl0pLCB3MCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgZXgoKSwgS3ggPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXG4gIFwiU2NyaXB0XCIsXG4gIFwiQmxvY2tcIixcbiAgXCJGdW5jdGlvbkV4cHJlc3Npb25cIixcbiAgXCJGdW5jdGlvbkRlY2xhcmF0aW9uXCIsXG4gIFwiQXJyb3dGdW5jdGlvblwiLFxuICBcIk1ldGhvZERlY2xhcmF0aW9uXCIsXG4gIFwiRm9yU3RhdGVtZW50XCJcbl0pO1xuZnVuY3Rpb24ga2EodCkge1xuICByZXR1cm4gKGUsIG4pID0+IHtcbiAgICBsZXQgciA9IGUubm9kZS5nZXRDaGlsZChcIlZhcmlhYmxlRGVmaW5pdGlvblwiKTtcbiAgICByZXR1cm4gciAmJiBuKHIsIHQpLCAhMDtcbiAgfTtcbn1cbmNvbnN0IGVJID0gW1wiRnVuY3Rpb25EZWNsYXJhdGlvblwiXSwgdEkgPSB7XG4gIEZ1bmN0aW9uRGVjbGFyYXRpb246IC8qIEBfX1BVUkVfXyAqLyBrYShcImZ1bmN0aW9uXCIpLFxuICBDbGFzc0RlY2xhcmF0aW9uOiAvKiBAX19QVVJFX18gKi8ga2EoXCJjbGFzc1wiKSxcbiAgQ2xhc3NFeHByZXNzaW9uOiAoKSA9PiAhMCxcbiAgRW51bURlY2xhcmF0aW9uOiAvKiBAX19QVVJFX18gKi8ga2EoXCJjb25zdGFudFwiKSxcbiAgVHlwZUFsaWFzRGVjbGFyYXRpb246IC8qIEBfX1BVUkVfXyAqLyBrYShcInR5cGVcIiksXG4gIE5hbWVzcGFjZURlY2xhcmF0aW9uOiAvKiBAX19QVVJFX18gKi8ga2EoXCJuYW1lc3BhY2VcIiksXG4gIFZhcmlhYmxlRGVmaW5pdGlvbih0LCBlKSB7XG4gICAgdC5tYXRjaENvbnRleHQoZUkpIHx8IGUodCwgXCJ2YXJpYWJsZVwiKTtcbiAgfSxcbiAgVHlwZURlZmluaXRpb24odCwgZSkge1xuICAgIGUodCwgXCJ0eXBlXCIpO1xuICB9LFxuICBfX3Byb3RvX186IG51bGxcbn07XG5mdW5jdGlvbiBKeCh0LCBlKSB7XG4gIGxldCBuID0gdzAuZ2V0KGUpO1xuICBpZiAobilcbiAgICByZXR1cm4gbjtcbiAgbGV0IHIgPSBbXSwgaSA9ICEwO1xuICBmdW5jdGlvbiBzKG8sIGEpIHtcbiAgICBsZXQgbCA9IHQuc2xpY2VTdHJpbmcoby5mcm9tLCBvLnRvKTtcbiAgICByLnB1c2goeyBsYWJlbDogbCwgdHlwZTogYSB9KTtcbiAgfVxuICByZXR1cm4gZS5jdXJzb3IobHQuSW5jbHVkZUFub255bW91cykuaXRlcmF0ZSgobykgPT4ge1xuICAgIGlmIChpKVxuICAgICAgaSA9ICExO1xuICAgIGVsc2UgaWYgKG8ubmFtZSkge1xuICAgICAgbGV0IGEgPSB0SVtvLm5hbWVdO1xuICAgICAgaWYgKGEgJiYgYShvLCBzKSB8fCBLeC5oYXMoby5uYW1lKSlcbiAgICAgICAgcmV0dXJuICExO1xuICAgIH0gZWxzZSBpZiAoby50byAtIG8uZnJvbSA+IDgxOTIpIHtcbiAgICAgIGZvciAobGV0IGEgb2YgSngodCwgby5ub2RlKSlcbiAgICAgICAgci5wdXNoKGEpO1xuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgfSksIHcwLnNldChlLCByKSwgcjtcbn1cbmNvbnN0IGswID0gL15bXFx3JFxceGExLVxcdWZmZmZdW1xcdyRcXGRcXHhhMS1cXHVmZmZmXSokLywgZVAgPSBbXG4gIFwiVGVtcGxhdGVTdHJpbmdcIixcbiAgXCJTdHJpbmdcIixcbiAgXCJSZWdFeHBcIixcbiAgXCJMaW5lQ29tbWVudFwiLFxuICBcIkJsb2NrQ29tbWVudFwiLFxuICBcIlZhcmlhYmxlRGVmaW5pdGlvblwiLFxuICBcIlR5cGVEZWZpbml0aW9uXCIsXG4gIFwiTGFiZWxcIixcbiAgXCJQcm9wZXJ0eURlZmluaXRpb25cIixcbiAgXCJQcm9wZXJ0eU5hbWVcIixcbiAgXCJQcml2YXRlUHJvcGVydHlEZWZpbml0aW9uXCIsXG4gIFwiUHJpdmF0ZVByb3BlcnR5TmFtZVwiLFxuICBcIi5cIixcbiAgXCI/LlwiXG5dO1xuZnVuY3Rpb24gbkkodCkge1xuICBsZXQgZSA9IHVuKHQuc3RhdGUpLnJlc29sdmVJbm5lcih0LnBvcywgLTEpO1xuICBpZiAoZVAuaW5kZXhPZihlLm5hbWUpID4gLTEpXG4gICAgcmV0dXJuIG51bGw7XG4gIGxldCBuID0gZS5uYW1lID09IFwiVmFyaWFibGVOYW1lXCIgfHwgZS50byAtIGUuZnJvbSA8IDIwICYmIGswLnRlc3QodC5zdGF0ZS5zbGljZURvYyhlLmZyb20sIGUudG8pKTtcbiAgaWYgKCFuICYmICF0LmV4cGxpY2l0KVxuICAgIHJldHVybiBudWxsO1xuICBsZXQgciA9IFtdO1xuICBmb3IgKGxldCBpID0gZTsgaTsgaSA9IGkucGFyZW50KVxuICAgIEt4LmhhcyhpLm5hbWUpICYmIChyID0gci5jb25jYXQoSngodC5zdGF0ZS5kb2MsIGkpKSk7XG4gIHJldHVybiB7XG4gICAgb3B0aW9uczogcixcbiAgICBmcm9tOiBuID8gZS5mcm9tIDogdC5wb3MsXG4gICAgdmFsaWRGb3I6IGswXG4gIH07XG59XG5jb25zdCBJciA9IC8qIEBfX1BVUkVfXyAqLyBjcy5kZWZpbmUoe1xuICBuYW1lOiBcImphdmFzY3JpcHRcIixcbiAgcGFyc2VyOiAvKiBAX19QVVJFX18gKi8gSzMuY29uZmlndXJlKHtcbiAgICBwcm9wczogW1xuICAgICAgLyogQF9fUFVSRV9fICovIHNhLmFkZCh7XG4gICAgICAgIElmU3RhdGVtZW50OiAvKiBAX19QVVJFX18gKi8gJG8oeyBleGNlcHQ6IC9eXFxzKih7fGVsc2VcXGIpLyB9KSxcbiAgICAgICAgVHJ5U3RhdGVtZW50OiAvKiBAX19QVVJFX18gKi8gJG8oeyBleGNlcHQ6IC9eXFxzKih7fGNhdGNoXFxifGZpbmFsbHlcXGIpLyB9KSxcbiAgICAgICAgTGFiZWxlZFN0YXRlbWVudDogRkQsXG4gICAgICAgIFN3aXRjaEJvZHk6ICh0KSA9PiB7XG4gICAgICAgICAgbGV0IGUgPSB0LnRleHRBZnRlciwgbiA9IC9eXFxzKlxcfS8udGVzdChlKSwgciA9IC9eXFxzKihjYXNlfGRlZmF1bHQpXFxiLy50ZXN0KGUpO1xuICAgICAgICAgIHJldHVybiB0LmJhc2VJbmRlbnQgKyAobiA/IDAgOiByID8gMSA6IDIpICogdC51bml0O1xuICAgICAgICB9LFxuICAgICAgICBCbG9jazogLyogQF9fUFVSRV9fICovIHhwKHsgY2xvc2luZzogXCJ9XCIgfSksXG4gICAgICAgIEFycm93RnVuY3Rpb246ICh0KSA9PiB0LmJhc2VJbmRlbnQgKyB0LnVuaXQsXG4gICAgICAgIFwiVGVtcGxhdGVTdHJpbmcgQmxvY2tDb21tZW50XCI6ICgpID0+IG51bGwsXG4gICAgICAgIFwiU3RhdGVtZW50IFByb3BlcnR5XCI6IC8qIEBfX1BVUkVfXyAqLyAkbyh7IGV4Y2VwdDogL157LyB9KSxcbiAgICAgICAgSlNYRWxlbWVudCh0KSB7XG4gICAgICAgICAgbGV0IGUgPSAvXlxccyo8XFwvLy50ZXN0KHQudGV4dEFmdGVyKTtcbiAgICAgICAgICByZXR1cm4gdC5saW5lSW5kZW50KHQubm9kZS5mcm9tKSArIChlID8gMCA6IHQudW5pdCk7XG4gICAgICAgIH0sXG4gICAgICAgIEpTWEVzY2FwZSh0KSB7XG4gICAgICAgICAgbGV0IGUgPSAvXFxzKlxcfS8udGVzdCh0LnRleHRBZnRlcik7XG4gICAgICAgICAgcmV0dXJuIHQubGluZUluZGVudCh0Lm5vZGUuZnJvbSkgKyAoZSA/IDAgOiB0LnVuaXQpO1xuICAgICAgICB9LFxuICAgICAgICBcIkpTWE9wZW5UYWcgSlNYU2VsZkNsb3NpbmdUYWdcIih0KSB7XG4gICAgICAgICAgcmV0dXJuIHQuY29sdW1uKHQubm9kZS5mcm9tKSArIHQudW5pdDtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICAvKiBAX19QVVJFX18gKi8gS2wuYWRkKHtcbiAgICAgICAgXCJCbG9jayBDbGFzc0JvZHkgU3dpdGNoQm9keSBFbnVtQm9keSBPYmplY3RFeHByZXNzaW9uIEFycmF5RXhwcmVzc2lvbiBPYmplY3RUeXBlXCI6IEhkLFxuICAgICAgICBCbG9ja0NvbW1lbnQodCkge1xuICAgICAgICAgIHJldHVybiB7IGZyb206IHQuZnJvbSArIDIsIHRvOiB0LnRvIC0gMiB9O1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIF1cbiAgfSksXG4gIGxhbmd1YWdlRGF0YToge1xuICAgIGNsb3NlQnJhY2tldHM6IHsgYnJhY2tldHM6IFtcIihcIiwgXCJbXCIsIFwie1wiLCBcIidcIiwgJ1wiJywgXCJgXCJdIH0sXG4gICAgY29tbWVudFRva2VuczogeyBsaW5lOiBcIi8vXCIsIGJsb2NrOiB7IG9wZW46IFwiLypcIiwgY2xvc2U6IFwiKi9cIiB9IH0sXG4gICAgaW5kZW50T25JbnB1dDogL15cXHMqKD86Y2FzZSB8ZGVmYXVsdDp8XFx7fFxcfXw8XFwvKSQvLFxuICAgIHdvcmRDaGFyczogXCIkXCJcbiAgfVxufSksIHRQID0ge1xuICB0ZXN0OiAodCkgPT4gL15KU1gvLnRlc3QodC5uYW1lKSxcbiAgZmFjZXQ6IC8qIEBfX1BVUkVfXyAqLyBzeCh7IGNvbW1lbnRUb2tlbnM6IHsgYmxvY2s6IHsgb3BlbjogXCJ7LypcIiwgY2xvc2U6IFwiKi99XCIgfSB9IH0pXG59LCBuUCA9IC8qIEBfX1BVUkVfXyAqLyBJci5jb25maWd1cmUoeyBkaWFsZWN0OiBcInRzXCIgfSwgXCJ0eXBlc2NyaXB0XCIpLCByUCA9IC8qIEBfX1BVUkVfXyAqLyBJci5jb25maWd1cmUoe1xuICBkaWFsZWN0OiBcImpzeFwiLFxuICBwcm9wczogWy8qIEBfX1BVUkVfXyAqLyBnZy5hZGQoKHQpID0+IHQuaXNUb3AgPyBbdFBdIDogdm9pZCAwKV1cbn0pLCBpUCA9IC8qIEBfX1BVUkVfXyAqLyBJci5jb25maWd1cmUoe1xuICBkaWFsZWN0OiBcImpzeCB0c1wiLFxuICBwcm9wczogWy8qIEBfX1BVUkVfXyAqLyBnZy5hZGQoKHQpID0+IHQuaXNUb3AgPyBbdFBdIDogdm9pZCAwKV1cbn0sIFwidHlwZXNjcmlwdFwiKTtcbmxldCBzUCA9ICh0KSA9PiAoeyBsYWJlbDogdCwgdHlwZTogXCJrZXl3b3JkXCIgfSk7XG5jb25zdCBvUCA9IC8qIEBfX1BVUkVfXyAqLyBcImJyZWFrIGNhc2UgY29uc3QgY29udGludWUgZGVmYXVsdCBkZWxldGUgZXhwb3J0IGV4dGVuZHMgZmFsc2UgZmluYWxseSBpbiBpbnN0YW5jZW9mIGxldCBuZXcgcmV0dXJuIHN0YXRpYyBzdXBlciBzd2l0Y2ggdGhpcyB0aHJvdyB0cnVlIHR5cGVvZiB2YXIgeWllbGRcIi5zcGxpdChcIiBcIikubWFwKHNQKSwgckkgPSAvKiBAX19QVVJFX18gKi8gb1AuY29uY2F0KC8qIEBfX1BVUkVfXyAqLyBbXCJkZWNsYXJlXCIsIFwiaW1wbGVtZW50c1wiLCBcInByaXZhdGVcIiwgXCJwcm90ZWN0ZWRcIiwgXCJwdWJsaWNcIl0ubWFwKHNQKSk7XG5mdW5jdGlvbiBpSSh0ID0ge30pIHtcbiAgbGV0IGUgPSB0LmpzeCA/IHQudHlwZXNjcmlwdCA/IGlQIDogclAgOiB0LnR5cGVzY3JpcHQgPyBuUCA6IElyLCBuID0gdC50eXBlc2NyaXB0ID8gSjMuY29uY2F0KHJJKSA6IEd4LmNvbmNhdChvUCk7XG4gIHJldHVybiBuZXcgR2woZSwgW1xuICAgIElyLmRhdGEub2Yoe1xuICAgICAgYXV0b2NvbXBsZXRlOiBPWihlUCwgdngobikpXG4gICAgfSksXG4gICAgSXIuZGF0YS5vZih7XG4gICAgICBhdXRvY29tcGxldGU6IG5JXG4gICAgfSksXG4gICAgdC5qc3ggPyBhSSA6IFtdXG4gIF0pO1xufVxuZnVuY3Rpb24gc0kodCkge1xuICBmb3IgKDsgOyApIHtcbiAgICBpZiAodC5uYW1lID09IFwiSlNYT3BlblRhZ1wiIHx8IHQubmFtZSA9PSBcIkpTWFNlbGZDbG9zaW5nVGFnXCIgfHwgdC5uYW1lID09IFwiSlNYRnJhZ21lbnRUYWdcIilcbiAgICAgIHJldHVybiB0O1xuICAgIGlmICh0Lm5hbWUgPT0gXCJKU1hFc2NhcGVcIiB8fCAhdC5wYXJlbnQpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB0ID0gdC5wYXJlbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHgwKHQsIGUsIG4gPSB0Lmxlbmd0aCkge1xuICBmb3IgKGxldCByID0gZSA9PSBudWxsID8gdm9pZCAwIDogZS5maXJzdENoaWxkOyByOyByID0gci5uZXh0U2libGluZylcbiAgICBpZiAoci5uYW1lID09IFwiSlNYSWRlbnRpZmllclwiIHx8IHIubmFtZSA9PSBcIkpTWEJ1aWx0aW5cIiB8fCByLm5hbWUgPT0gXCJKU1hOYW1lc3BhY2VkTmFtZVwiIHx8IHIubmFtZSA9PSBcIkpTWE1lbWJlckV4cHJlc3Npb25cIilcbiAgICAgIHJldHVybiB0LnNsaWNlU3RyaW5nKHIuZnJvbSwgTWF0aC5taW4oci50bywgbikpO1xuICByZXR1cm4gXCJcIjtcbn1cbmNvbnN0IG9JID0gdHlwZW9mIG5hdmlnYXRvciA9PSBcIm9iamVjdFwiICYmIC8qIEBfX1BVUkVfXyAqLyAvQW5kcm9pZFxcYi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSwgYUkgPSAvKiBAX19QVVJFX18gKi8gU2UuaW5wdXRIYW5kbGVyLm9mKCh0LCBlLCBuLCByLCBpKSA9PiB7XG4gIGlmICgob0kgPyB0LmNvbXBvc2luZyA6IHQuY29tcG9zaXRpb25TdGFydGVkKSB8fCB0LnN0YXRlLnJlYWRPbmx5IHx8IGUgIT0gbiB8fCByICE9IFwiPlwiICYmIHIgIT0gXCIvXCIgfHwgIUlyLmlzQWN0aXZlQXQodC5zdGF0ZSwgZSwgLTEpKVxuICAgIHJldHVybiAhMTtcbiAgbGV0IHMgPSBpKCksIHsgc3RhdGU6IG8gfSA9IHMsIGEgPSBvLmNoYW5nZUJ5UmFuZ2UoKGwpID0+IHtcbiAgICB2YXIgYztcbiAgICBsZXQgeyBoZWFkOiB1IH0gPSBsLCBkID0gdW4obykucmVzb2x2ZUlubmVyKHUgLSAxLCAtMSksIGY7XG4gICAgaWYgKGQubmFtZSA9PSBcIkpTWFN0YXJ0VGFnXCIgJiYgKGQgPSBkLnBhcmVudCksICEoby5kb2Muc2xpY2VTdHJpbmcodSAtIDEsIHUpICE9IHIgfHwgZC5uYW1lID09IFwiSlNYQXR0cmlidXRlVmFsdWVcIiAmJiBkLnRvID4gdSkpIHtcbiAgICAgIGlmIChyID09IFwiPlwiICYmIGQubmFtZSA9PSBcIkpTWEZyYWdtZW50VGFnXCIpXG4gICAgICAgIHJldHVybiB7IHJhbmdlOiBsLCBjaGFuZ2VzOiB7IGZyb206IHUsIGluc2VydDogXCI8Lz5cIiB9IH07XG4gICAgICBpZiAociA9PSBcIi9cIiAmJiBkLm5hbWUgPT0gXCJKU1hTdGFydENsb3NlVGFnXCIpIHtcbiAgICAgICAgbGV0IGggPSBkLnBhcmVudCwgcCA9IGgucGFyZW50O1xuICAgICAgICBpZiAocCAmJiBoLmZyb20gPT0gdSAtIDIgJiYgKChmID0geDAoby5kb2MsIHAuZmlyc3RDaGlsZCwgdSkpIHx8ICgoYyA9IHAuZmlyc3RDaGlsZCkgPT09IG51bGwgfHwgYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYy5uYW1lKSA9PSBcIkpTWEZyYWdtZW50VGFnXCIpKSB7XG4gICAgICAgICAgbGV0IE8gPSBgJHtmfT5gO1xuICAgICAgICAgIHJldHVybiB7IHJhbmdlOiBhZS5jdXJzb3IodSArIE8ubGVuZ3RoLCAtMSksIGNoYW5nZXM6IHsgZnJvbTogdSwgaW5zZXJ0OiBPIH0gfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChyID09IFwiPlwiKSB7XG4gICAgICAgIGxldCBoID0gc0koZCk7XG4gICAgICAgIGlmIChoICYmIGgubmFtZSA9PSBcIkpTWE9wZW5UYWdcIiAmJiAhL15cXC8/PnxePFxcLy8udGVzdChvLmRvYy5zbGljZVN0cmluZyh1LCB1ICsgMikpICYmIChmID0geDAoby5kb2MsIGgsIHUpKSlcbiAgICAgICAgICByZXR1cm4geyByYW5nZTogbCwgY2hhbmdlczogeyBmcm9tOiB1LCBpbnNlcnQ6IGA8LyR7Zn0+YCB9IH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHJhbmdlOiBsIH07XG4gIH0pO1xuICByZXR1cm4gYS5jaGFuZ2VzLmVtcHR5ID8gITEgOiAodC5kaXNwYXRjaChbXG4gICAgcyxcbiAgICBvLnVwZGF0ZShhLCB7IHVzZXJFdmVudDogXCJpbnB1dC5jb21wbGV0ZVwiLCBzY3JvbGxJbnRvVmlldzogITAgfSlcbiAgXSksICEwKTtcbn0pLCB4YSA9IFtcIl9ibGFua1wiLCBcIl9zZWxmXCIsIFwiX3RvcFwiLCBcIl9wYXJlbnRcIl0sIEhmID0gW1wiYXNjaWlcIiwgXCJ1dGYtOFwiLCBcInV0Zi0xNlwiLCBcImxhdGluMVwiLCBcImxhdGluMVwiXSwgRmYgPSBbXCJnZXRcIiwgXCJwb3N0XCIsIFwicHV0XCIsIFwiZGVsZXRlXCJdLCBHZiA9IFtcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLCBcIm11bHRpcGFydC9mb3JtLWRhdGFcIiwgXCJ0ZXh0L3BsYWluXCJdLCBDbiA9IFtcInRydWVcIiwgXCJmYWxzZVwiXSwgZmUgPSB7fSwgbEkgPSB7XG4gIGE6IHtcbiAgICBhdHRyczoge1xuICAgICAgaHJlZjogbnVsbCxcbiAgICAgIHBpbmc6IG51bGwsXG4gICAgICB0eXBlOiBudWxsLFxuICAgICAgbWVkaWE6IG51bGwsXG4gICAgICB0YXJnZXQ6IHhhLFxuICAgICAgaHJlZmxhbmc6IG51bGxcbiAgICB9XG4gIH0sXG4gIGFiYnI6IGZlLFxuICBhZGRyZXNzOiBmZSxcbiAgYXJlYToge1xuICAgIGF0dHJzOiB7XG4gICAgICBhbHQ6IG51bGwsXG4gICAgICBjb29yZHM6IG51bGwsXG4gICAgICBocmVmOiBudWxsLFxuICAgICAgdGFyZ2V0OiBudWxsLFxuICAgICAgcGluZzogbnVsbCxcbiAgICAgIG1lZGlhOiBudWxsLFxuICAgICAgaHJlZmxhbmc6IG51bGwsXG4gICAgICB0eXBlOiBudWxsLFxuICAgICAgc2hhcGU6IFtcImRlZmF1bHRcIiwgXCJyZWN0XCIsIFwiY2lyY2xlXCIsIFwicG9seVwiXVxuICAgIH1cbiAgfSxcbiAgYXJ0aWNsZTogZmUsXG4gIGFzaWRlOiBmZSxcbiAgYXVkaW86IHtcbiAgICBhdHRyczoge1xuICAgICAgc3JjOiBudWxsLFxuICAgICAgbWVkaWFncm91cDogbnVsbCxcbiAgICAgIGNyb3Nzb3JpZ2luOiBbXCJhbm9ueW1vdXNcIiwgXCJ1c2UtY3JlZGVudGlhbHNcIl0sXG4gICAgICBwcmVsb2FkOiBbXCJub25lXCIsIFwibWV0YWRhdGFcIiwgXCJhdXRvXCJdLFxuICAgICAgYXV0b3BsYXk6IFtcImF1dG9wbGF5XCJdLFxuICAgICAgbG9vcDogW1wibG9vcFwiXSxcbiAgICAgIGNvbnRyb2xzOiBbXCJjb250cm9sc1wiXVxuICAgIH1cbiAgfSxcbiAgYjogZmUsXG4gIGJhc2U6IHsgYXR0cnM6IHsgaHJlZjogbnVsbCwgdGFyZ2V0OiB4YSB9IH0sXG4gIGJkaTogZmUsXG4gIGJkbzogZmUsXG4gIGJsb2NrcXVvdGU6IHsgYXR0cnM6IHsgY2l0ZTogbnVsbCB9IH0sXG4gIGJvZHk6IGZlLFxuICBicjogZmUsXG4gIGJ1dHRvbjoge1xuICAgIGF0dHJzOiB7XG4gICAgICBmb3JtOiBudWxsLFxuICAgICAgZm9ybWFjdGlvbjogbnVsbCxcbiAgICAgIG5hbWU6IG51bGwsXG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGF1dG9mb2N1czogW1wiYXV0b2ZvY3VzXCJdLFxuICAgICAgZGlzYWJsZWQ6IFtcImF1dG9mb2N1c1wiXSxcbiAgICAgIGZvcm1lbmN0eXBlOiBHZixcbiAgICAgIGZvcm1tZXRob2Q6IEZmLFxuICAgICAgZm9ybW5vdmFsaWRhdGU6IFtcIm5vdmFsaWRhdGVcIl0sXG4gICAgICBmb3JtdGFyZ2V0OiB4YSxcbiAgICAgIHR5cGU6IFtcInN1Ym1pdFwiLCBcInJlc2V0XCIsIFwiYnV0dG9uXCJdXG4gICAgfVxuICB9LFxuICBjYW52YXM6IHsgYXR0cnM6IHsgd2lkdGg6IG51bGwsIGhlaWdodDogbnVsbCB9IH0sXG4gIGNhcHRpb246IGZlLFxuICBjZW50ZXI6IGZlLFxuICBjaXRlOiBmZSxcbiAgY29kZTogZmUsXG4gIGNvbDogeyBhdHRyczogeyBzcGFuOiBudWxsIH0gfSxcbiAgY29sZ3JvdXA6IHsgYXR0cnM6IHsgc3BhbjogbnVsbCB9IH0sXG4gIGNvbW1hbmQ6IHtcbiAgICBhdHRyczoge1xuICAgICAgdHlwZTogW1wiY29tbWFuZFwiLCBcImNoZWNrYm94XCIsIFwicmFkaW9cIl0sXG4gICAgICBsYWJlbDogbnVsbCxcbiAgICAgIGljb246IG51bGwsXG4gICAgICByYWRpb2dyb3VwOiBudWxsLFxuICAgICAgY29tbWFuZDogbnVsbCxcbiAgICAgIHRpdGxlOiBudWxsLFxuICAgICAgZGlzYWJsZWQ6IFtcImRpc2FibGVkXCJdLFxuICAgICAgY2hlY2tlZDogW1wiY2hlY2tlZFwiXVxuICAgIH1cbiAgfSxcbiAgZGF0YTogeyBhdHRyczogeyB2YWx1ZTogbnVsbCB9IH0sXG4gIGRhdGFncmlkOiB7IGF0dHJzOiB7IGRpc2FibGVkOiBbXCJkaXNhYmxlZFwiXSwgbXVsdGlwbGU6IFtcIm11bHRpcGxlXCJdIH0gfSxcbiAgZGF0YWxpc3Q6IHsgYXR0cnM6IHsgZGF0YTogbnVsbCB9IH0sXG4gIGRkOiBmZSxcbiAgZGVsOiB7IGF0dHJzOiB7IGNpdGU6IG51bGwsIGRhdGV0aW1lOiBudWxsIH0gfSxcbiAgZGV0YWlsczogeyBhdHRyczogeyBvcGVuOiBbXCJvcGVuXCJdIH0gfSxcbiAgZGZuOiBmZSxcbiAgZGl2OiBmZSxcbiAgZGw6IGZlLFxuICBkdDogZmUsXG4gIGVtOiBmZSxcbiAgZW1iZWQ6IHsgYXR0cnM6IHsgc3JjOiBudWxsLCB0eXBlOiBudWxsLCB3aWR0aDogbnVsbCwgaGVpZ2h0OiBudWxsIH0gfSxcbiAgZXZlbnRzb3VyY2U6IHsgYXR0cnM6IHsgc3JjOiBudWxsIH0gfSxcbiAgZmllbGRzZXQ6IHsgYXR0cnM6IHsgZGlzYWJsZWQ6IFtcImRpc2FibGVkXCJdLCBmb3JtOiBudWxsLCBuYW1lOiBudWxsIH0gfSxcbiAgZmlnY2FwdGlvbjogZmUsXG4gIGZpZ3VyZTogZmUsXG4gIGZvb3RlcjogZmUsXG4gIGZvcm06IHtcbiAgICBhdHRyczoge1xuICAgICAgYWN0aW9uOiBudWxsLFxuICAgICAgbmFtZTogbnVsbCxcbiAgICAgIFwiYWNjZXB0LWNoYXJzZXRcIjogSGYsXG4gICAgICBhdXRvY29tcGxldGU6IFtcIm9uXCIsIFwib2ZmXCJdLFxuICAgICAgZW5jdHlwZTogR2YsXG4gICAgICBtZXRob2Q6IEZmLFxuICAgICAgbm92YWxpZGF0ZTogW1wibm92YWxpZGF0ZVwiXSxcbiAgICAgIHRhcmdldDogeGFcbiAgICB9XG4gIH0sXG4gIGgxOiBmZSxcbiAgaDI6IGZlLFxuICBoMzogZmUsXG4gIGg0OiBmZSxcbiAgaDU6IGZlLFxuICBoNjogZmUsXG4gIGhlYWQ6IHtcbiAgICBjaGlsZHJlbjogW1widGl0bGVcIiwgXCJiYXNlXCIsIFwibGlua1wiLCBcInN0eWxlXCIsIFwibWV0YVwiLCBcInNjcmlwdFwiLCBcIm5vc2NyaXB0XCIsIFwiY29tbWFuZFwiXVxuICB9LFxuICBoZWFkZXI6IGZlLFxuICBoZ3JvdXA6IGZlLFxuICBocjogZmUsXG4gIGh0bWw6IHtcbiAgICBhdHRyczogeyBtYW5pZmVzdDogbnVsbCB9XG4gIH0sXG4gIGk6IGZlLFxuICBpZnJhbWU6IHtcbiAgICBhdHRyczoge1xuICAgICAgc3JjOiBudWxsLFxuICAgICAgc3JjZG9jOiBudWxsLFxuICAgICAgbmFtZTogbnVsbCxcbiAgICAgIHdpZHRoOiBudWxsLFxuICAgICAgaGVpZ2h0OiBudWxsLFxuICAgICAgc2FuZGJveDogW1wiYWxsb3ctdG9wLW5hdmlnYXRpb25cIiwgXCJhbGxvdy1zYW1lLW9yaWdpblwiLCBcImFsbG93LWZvcm1zXCIsIFwiYWxsb3ctc2NyaXB0c1wiXSxcbiAgICAgIHNlYW1sZXNzOiBbXCJzZWFtbGVzc1wiXVxuICAgIH1cbiAgfSxcbiAgaW1nOiB7XG4gICAgYXR0cnM6IHtcbiAgICAgIGFsdDogbnVsbCxcbiAgICAgIHNyYzogbnVsbCxcbiAgICAgIGlzbWFwOiBudWxsLFxuICAgICAgdXNlbWFwOiBudWxsLFxuICAgICAgd2lkdGg6IG51bGwsXG4gICAgICBoZWlnaHQ6IG51bGwsXG4gICAgICBjcm9zc29yaWdpbjogW1wiYW5vbnltb3VzXCIsIFwidXNlLWNyZWRlbnRpYWxzXCJdXG4gICAgfVxuICB9LFxuICBpbnB1dDoge1xuICAgIGF0dHJzOiB7XG4gICAgICBhbHQ6IG51bGwsXG4gICAgICBkaXJuYW1lOiBudWxsLFxuICAgICAgZm9ybTogbnVsbCxcbiAgICAgIGZvcm1hY3Rpb246IG51bGwsXG4gICAgICBoZWlnaHQ6IG51bGwsXG4gICAgICBsaXN0OiBudWxsLFxuICAgICAgbWF4OiBudWxsLFxuICAgICAgbWF4bGVuZ3RoOiBudWxsLFxuICAgICAgbWluOiBudWxsLFxuICAgICAgbmFtZTogbnVsbCxcbiAgICAgIHBhdHRlcm46IG51bGwsXG4gICAgICBwbGFjZWhvbGRlcjogbnVsbCxcbiAgICAgIHNpemU6IG51bGwsXG4gICAgICBzcmM6IG51bGwsXG4gICAgICBzdGVwOiBudWxsLFxuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICB3aWR0aDogbnVsbCxcbiAgICAgIGFjY2VwdDogW1wiYXVkaW8vKlwiLCBcInZpZGVvLypcIiwgXCJpbWFnZS8qXCJdLFxuICAgICAgYXV0b2NvbXBsZXRlOiBbXCJvblwiLCBcIm9mZlwiXSxcbiAgICAgIGF1dG9mb2N1czogW1wiYXV0b2ZvY3VzXCJdLFxuICAgICAgY2hlY2tlZDogW1wiY2hlY2tlZFwiXSxcbiAgICAgIGRpc2FibGVkOiBbXCJkaXNhYmxlZFwiXSxcbiAgICAgIGZvcm1lbmN0eXBlOiBHZixcbiAgICAgIGZvcm1tZXRob2Q6IEZmLFxuICAgICAgZm9ybW5vdmFsaWRhdGU6IFtcIm5vdmFsaWRhdGVcIl0sXG4gICAgICBmb3JtdGFyZ2V0OiB4YSxcbiAgICAgIG11bHRpcGxlOiBbXCJtdWx0aXBsZVwiXSxcbiAgICAgIHJlYWRvbmx5OiBbXCJyZWFkb25seVwiXSxcbiAgICAgIHJlcXVpcmVkOiBbXCJyZXF1aXJlZFwiXSxcbiAgICAgIHR5cGU6IFtcbiAgICAgICAgXCJoaWRkZW5cIixcbiAgICAgICAgXCJ0ZXh0XCIsXG4gICAgICAgIFwic2VhcmNoXCIsXG4gICAgICAgIFwidGVsXCIsXG4gICAgICAgIFwidXJsXCIsXG4gICAgICAgIFwiZW1haWxcIixcbiAgICAgICAgXCJwYXNzd29yZFwiLFxuICAgICAgICBcImRhdGV0aW1lXCIsXG4gICAgICAgIFwiZGF0ZVwiLFxuICAgICAgICBcIm1vbnRoXCIsXG4gICAgICAgIFwid2Vla1wiLFxuICAgICAgICBcInRpbWVcIixcbiAgICAgICAgXCJkYXRldGltZS1sb2NhbFwiLFxuICAgICAgICBcIm51bWJlclwiLFxuICAgICAgICBcInJhbmdlXCIsXG4gICAgICAgIFwiY29sb3JcIixcbiAgICAgICAgXCJjaGVja2JveFwiLFxuICAgICAgICBcInJhZGlvXCIsXG4gICAgICAgIFwiZmlsZVwiLFxuICAgICAgICBcInN1Ym1pdFwiLFxuICAgICAgICBcImltYWdlXCIsXG4gICAgICAgIFwicmVzZXRcIixcbiAgICAgICAgXCJidXR0b25cIlxuICAgICAgXVxuICAgIH1cbiAgfSxcbiAgaW5zOiB7IGF0dHJzOiB7IGNpdGU6IG51bGwsIGRhdGV0aW1lOiBudWxsIH0gfSxcbiAga2JkOiBmZSxcbiAga2V5Z2VuOiB7XG4gICAgYXR0cnM6IHtcbiAgICAgIGNoYWxsZW5nZTogbnVsbCxcbiAgICAgIGZvcm06IG51bGwsXG4gICAgICBuYW1lOiBudWxsLFxuICAgICAgYXV0b2ZvY3VzOiBbXCJhdXRvZm9jdXNcIl0sXG4gICAgICBkaXNhYmxlZDogW1wiZGlzYWJsZWRcIl0sXG4gICAgICBrZXl0eXBlOiBbXCJSU0FcIl1cbiAgICB9XG4gIH0sXG4gIGxhYmVsOiB7IGF0dHJzOiB7IGZvcjogbnVsbCwgZm9ybTogbnVsbCB9IH0sXG4gIGxlZ2VuZDogZmUsXG4gIGxpOiB7IGF0dHJzOiB7IHZhbHVlOiBudWxsIH0gfSxcbiAgbGluazoge1xuICAgIGF0dHJzOiB7XG4gICAgICBocmVmOiBudWxsLFxuICAgICAgdHlwZTogbnVsbCxcbiAgICAgIGhyZWZsYW5nOiBudWxsLFxuICAgICAgbWVkaWE6IG51bGwsXG4gICAgICBzaXplczogW1wiYWxsXCIsIFwiMTZ4MTZcIiwgXCIxNngxNiAzMngzMlwiLCBcIjE2eDE2IDMyeDMyIDY0eDY0XCJdXG4gICAgfVxuICB9LFxuICBtYXA6IHsgYXR0cnM6IHsgbmFtZTogbnVsbCB9IH0sXG4gIG1hcms6IGZlLFxuICBtZW51OiB7IGF0dHJzOiB7IGxhYmVsOiBudWxsLCB0eXBlOiBbXCJsaXN0XCIsIFwiY29udGV4dFwiLCBcInRvb2xiYXJcIl0gfSB9LFxuICBtZXRhOiB7XG4gICAgYXR0cnM6IHtcbiAgICAgIGNvbnRlbnQ6IG51bGwsXG4gICAgICBjaGFyc2V0OiBIZixcbiAgICAgIG5hbWU6IFtcInZpZXdwb3J0XCIsIFwiYXBwbGljYXRpb24tbmFtZVwiLCBcImF1dGhvclwiLCBcImRlc2NyaXB0aW9uXCIsIFwiZ2VuZXJhdG9yXCIsIFwia2V5d29yZHNcIl0sXG4gICAgICBcImh0dHAtZXF1aXZcIjogW1wiY29udGVudC1sYW5ndWFnZVwiLCBcImNvbnRlbnQtdHlwZVwiLCBcImRlZmF1bHQtc3R5bGVcIiwgXCJyZWZyZXNoXCJdXG4gICAgfVxuICB9LFxuICBtZXRlcjogeyBhdHRyczogeyB2YWx1ZTogbnVsbCwgbWluOiBudWxsLCBsb3c6IG51bGwsIGhpZ2g6IG51bGwsIG1heDogbnVsbCwgb3B0aW11bTogbnVsbCB9IH0sXG4gIG5hdjogZmUsXG4gIG5vc2NyaXB0OiBmZSxcbiAgb2JqZWN0OiB7XG4gICAgYXR0cnM6IHtcbiAgICAgIGRhdGE6IG51bGwsXG4gICAgICB0eXBlOiBudWxsLFxuICAgICAgbmFtZTogbnVsbCxcbiAgICAgIHVzZW1hcDogbnVsbCxcbiAgICAgIGZvcm06IG51bGwsXG4gICAgICB3aWR0aDogbnVsbCxcbiAgICAgIGhlaWdodDogbnVsbCxcbiAgICAgIHR5cGVtdXN0bWF0Y2g6IFtcInR5cGVtdXN0bWF0Y2hcIl1cbiAgICB9XG4gIH0sXG4gIG9sOiB7XG4gICAgYXR0cnM6IHsgcmV2ZXJzZWQ6IFtcInJldmVyc2VkXCJdLCBzdGFydDogbnVsbCwgdHlwZTogW1wiMVwiLCBcImFcIiwgXCJBXCIsIFwiaVwiLCBcIklcIl0gfSxcbiAgICBjaGlsZHJlbjogW1wibGlcIiwgXCJzY3JpcHRcIiwgXCJ0ZW1wbGF0ZVwiLCBcInVsXCIsIFwib2xcIl1cbiAgfSxcbiAgb3B0Z3JvdXA6IHsgYXR0cnM6IHsgZGlzYWJsZWQ6IFtcImRpc2FibGVkXCJdLCBsYWJlbDogbnVsbCB9IH0sXG4gIG9wdGlvbjogeyBhdHRyczogeyBkaXNhYmxlZDogW1wiZGlzYWJsZWRcIl0sIGxhYmVsOiBudWxsLCBzZWxlY3RlZDogW1wic2VsZWN0ZWRcIl0sIHZhbHVlOiBudWxsIH0gfSxcbiAgb3V0cHV0OiB7IGF0dHJzOiB7IGZvcjogbnVsbCwgZm9ybTogbnVsbCwgbmFtZTogbnVsbCB9IH0sXG4gIHA6IGZlLFxuICBwYXJhbTogeyBhdHRyczogeyBuYW1lOiBudWxsLCB2YWx1ZTogbnVsbCB9IH0sXG4gIHByZTogZmUsXG4gIHByb2dyZXNzOiB7IGF0dHJzOiB7IHZhbHVlOiBudWxsLCBtYXg6IG51bGwgfSB9LFxuICBxOiB7IGF0dHJzOiB7IGNpdGU6IG51bGwgfSB9LFxuICBycDogZmUsXG4gIHJ0OiBmZSxcbiAgcnVieTogZmUsXG4gIHNhbXA6IGZlLFxuICBzY3JpcHQ6IHtcbiAgICBhdHRyczoge1xuICAgICAgdHlwZTogW1widGV4dC9qYXZhc2NyaXB0XCJdLFxuICAgICAgc3JjOiBudWxsLFxuICAgICAgYXN5bmM6IFtcImFzeW5jXCJdLFxuICAgICAgZGVmZXI6IFtcImRlZmVyXCJdLFxuICAgICAgY2hhcnNldDogSGZcbiAgICB9XG4gIH0sXG4gIHNlY3Rpb246IGZlLFxuICBzZWxlY3Q6IHtcbiAgICBhdHRyczoge1xuICAgICAgZm9ybTogbnVsbCxcbiAgICAgIG5hbWU6IG51bGwsXG4gICAgICBzaXplOiBudWxsLFxuICAgICAgYXV0b2ZvY3VzOiBbXCJhdXRvZm9jdXNcIl0sXG4gICAgICBkaXNhYmxlZDogW1wiZGlzYWJsZWRcIl0sXG4gICAgICBtdWx0aXBsZTogW1wibXVsdGlwbGVcIl1cbiAgICB9XG4gIH0sXG4gIHNsb3Q6IHsgYXR0cnM6IHsgbmFtZTogbnVsbCB9IH0sXG4gIHNtYWxsOiBmZSxcbiAgc291cmNlOiB7IGF0dHJzOiB7IHNyYzogbnVsbCwgdHlwZTogbnVsbCwgbWVkaWE6IG51bGwgfSB9LFxuICBzcGFuOiBmZSxcbiAgc3Ryb25nOiBmZSxcbiAgc3R5bGU6IHtcbiAgICBhdHRyczoge1xuICAgICAgdHlwZTogW1widGV4dC9jc3NcIl0sXG4gICAgICBtZWRpYTogbnVsbCxcbiAgICAgIHNjb3BlZDogbnVsbFxuICAgIH1cbiAgfSxcbiAgc3ViOiBmZSxcbiAgc3VtbWFyeTogZmUsXG4gIHN1cDogZmUsXG4gIHRhYmxlOiBmZSxcbiAgdGJvZHk6IGZlLFxuICB0ZDogeyBhdHRyczogeyBjb2xzcGFuOiBudWxsLCByb3dzcGFuOiBudWxsLCBoZWFkZXJzOiBudWxsIH0gfSxcbiAgdGVtcGxhdGU6IGZlLFxuICB0ZXh0YXJlYToge1xuICAgIGF0dHJzOiB7XG4gICAgICBkaXJuYW1lOiBudWxsLFxuICAgICAgZm9ybTogbnVsbCxcbiAgICAgIG1heGxlbmd0aDogbnVsbCxcbiAgICAgIG5hbWU6IG51bGwsXG4gICAgICBwbGFjZWhvbGRlcjogbnVsbCxcbiAgICAgIHJvd3M6IG51bGwsXG4gICAgICBjb2xzOiBudWxsLFxuICAgICAgYXV0b2ZvY3VzOiBbXCJhdXRvZm9jdXNcIl0sXG4gICAgICBkaXNhYmxlZDogW1wiZGlzYWJsZWRcIl0sXG4gICAgICByZWFkb25seTogW1wicmVhZG9ubHlcIl0sXG4gICAgICByZXF1aXJlZDogW1wicmVxdWlyZWRcIl0sXG4gICAgICB3cmFwOiBbXCJzb2Z0XCIsIFwiaGFyZFwiXVxuICAgIH1cbiAgfSxcbiAgdGZvb3Q6IGZlLFxuICB0aDogeyBhdHRyczogeyBjb2xzcGFuOiBudWxsLCByb3dzcGFuOiBudWxsLCBoZWFkZXJzOiBudWxsLCBzY29wZTogW1wicm93XCIsIFwiY29sXCIsIFwicm93Z3JvdXBcIiwgXCJjb2xncm91cFwiXSB9IH0sXG4gIHRoZWFkOiBmZSxcbiAgdGltZTogeyBhdHRyczogeyBkYXRldGltZTogbnVsbCB9IH0sXG4gIHRpdGxlOiBmZSxcbiAgdHI6IGZlLFxuICB0cmFjazoge1xuICAgIGF0dHJzOiB7XG4gICAgICBzcmM6IG51bGwsXG4gICAgICBsYWJlbDogbnVsbCxcbiAgICAgIGRlZmF1bHQ6IG51bGwsXG4gICAgICBraW5kOiBbXCJzdWJ0aXRsZXNcIiwgXCJjYXB0aW9uc1wiLCBcImRlc2NyaXB0aW9uc1wiLCBcImNoYXB0ZXJzXCIsIFwibWV0YWRhdGFcIl0sXG4gICAgICBzcmNsYW5nOiBudWxsXG4gICAgfVxuICB9LFxuICB1bDogeyBjaGlsZHJlbjogW1wibGlcIiwgXCJzY3JpcHRcIiwgXCJ0ZW1wbGF0ZVwiLCBcInVsXCIsIFwib2xcIl0gfSxcbiAgdmFyOiBmZSxcbiAgdmlkZW86IHtcbiAgICBhdHRyczoge1xuICAgICAgc3JjOiBudWxsLFxuICAgICAgcG9zdGVyOiBudWxsLFxuICAgICAgd2lkdGg6IG51bGwsXG4gICAgICBoZWlnaHQ6IG51bGwsXG4gICAgICBjcm9zc29yaWdpbjogW1wiYW5vbnltb3VzXCIsIFwidXNlLWNyZWRlbnRpYWxzXCJdLFxuICAgICAgcHJlbG9hZDogW1wiYXV0b1wiLCBcIm1ldGFkYXRhXCIsIFwibm9uZVwiXSxcbiAgICAgIGF1dG9wbGF5OiBbXCJhdXRvcGxheVwiXSxcbiAgICAgIG1lZGlhZ3JvdXA6IFtcIm1vdmllXCJdLFxuICAgICAgbXV0ZWQ6IFtcIm11dGVkXCJdLFxuICAgICAgY29udHJvbHM6IFtcImNvbnRyb2xzXCJdXG4gICAgfVxuICB9LFxuICB3YnI6IGZlXG59LCBhUCA9IHtcbiAgYWNjZXNza2V5OiBudWxsLFxuICBjbGFzczogbnVsbCxcbiAgY29udGVudGVkaXRhYmxlOiBDbixcbiAgY29udGV4dG1lbnU6IG51bGwsXG4gIGRpcjogW1wibHRyXCIsIFwicnRsXCIsIFwiYXV0b1wiXSxcbiAgZHJhZ2dhYmxlOiBbXCJ0cnVlXCIsIFwiZmFsc2VcIiwgXCJhdXRvXCJdLFxuICBkcm9wem9uZTogW1wiY29weVwiLCBcIm1vdmVcIiwgXCJsaW5rXCIsIFwic3RyaW5nOlwiLCBcImZpbGU6XCJdLFxuICBoaWRkZW46IFtcImhpZGRlblwiXSxcbiAgaWQ6IG51bGwsXG4gIGluZXJ0OiBbXCJpbmVydFwiXSxcbiAgaXRlbWlkOiBudWxsLFxuICBpdGVtcHJvcDogbnVsbCxcbiAgaXRlbXJlZjogbnVsbCxcbiAgaXRlbXNjb3BlOiBbXCJpdGVtc2NvcGVcIl0sXG4gIGl0ZW10eXBlOiBudWxsLFxuICBsYW5nOiBbXCJhclwiLCBcImJuXCIsIFwiZGVcIiwgXCJlbi1HQlwiLCBcImVuLVVTXCIsIFwiZXNcIiwgXCJmclwiLCBcImhpXCIsIFwiaWRcIiwgXCJqYVwiLCBcInBhXCIsIFwicHRcIiwgXCJydVwiLCBcInRyXCIsIFwiemhcIl0sXG4gIHNwZWxsY2hlY2s6IENuLFxuICBhdXRvY29ycmVjdDogQ24sXG4gIGF1dG9jYXBpdGFsaXplOiBDbixcbiAgc3R5bGU6IG51bGwsXG4gIHRhYmluZGV4OiBudWxsLFxuICB0aXRsZTogbnVsbCxcbiAgdHJhbnNsYXRlOiBbXCJ5ZXNcIiwgXCJub1wiXSxcbiAgcmVsOiBbXCJzdHlsZXNoZWV0XCIsIFwiYWx0ZXJuYXRlXCIsIFwiYXV0aG9yXCIsIFwiYm9va21hcmtcIiwgXCJoZWxwXCIsIFwibGljZW5zZVwiLCBcIm5leHRcIiwgXCJub2ZvbGxvd1wiLCBcIm5vcmVmZXJyZXJcIiwgXCJwcmVmZXRjaFwiLCBcInByZXZcIiwgXCJzZWFyY2hcIiwgXCJ0YWdcIl0sXG4gIHJvbGU6IC8qIEBfX1BVUkVfXyAqLyBcImFsZXJ0IGFwcGxpY2F0aW9uIGFydGljbGUgYmFubmVyIGJ1dHRvbiBjZWxsIGNoZWNrYm94IGNvbXBsZW1lbnRhcnkgY29udGVudGluZm8gZGlhbG9nIGRvY3VtZW50IGZlZWQgZmlndXJlIGZvcm0gZ3JpZCBncmlkY2VsbCBoZWFkaW5nIGltZyBsaXN0IGxpc3Rib3ggbGlzdGl0ZW0gbWFpbiBuYXZpZ2F0aW9uIHJlZ2lvbiByb3cgcm93Z3JvdXAgc2VhcmNoIHN3aXRjaCB0YWIgdGFibGUgdGFicGFuZWwgdGV4dGJveCB0aW1lclwiLnNwbGl0KFwiIFwiKSxcbiAgXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIjogbnVsbCxcbiAgXCJhcmlhLWF0b21pY1wiOiBDbixcbiAgXCJhcmlhLWF1dG9jb21wbGV0ZVwiOiBbXCJpbmxpbmVcIiwgXCJsaXN0XCIsIFwiYm90aFwiLCBcIm5vbmVcIl0sXG4gIFwiYXJpYS1idXN5XCI6IENuLFxuICBcImFyaWEtY2hlY2tlZFwiOiBbXCJ0cnVlXCIsIFwiZmFsc2VcIiwgXCJtaXhlZFwiLCBcInVuZGVmaW5lZFwiXSxcbiAgXCJhcmlhLWNvbnRyb2xzXCI6IG51bGwsXG4gIFwiYXJpYS1kZXNjcmliZWRieVwiOiBudWxsLFxuICBcImFyaWEtZGlzYWJsZWRcIjogQ24sXG4gIFwiYXJpYS1kcm9wZWZmZWN0XCI6IG51bGwsXG4gIFwiYXJpYS1leHBhbmRlZFwiOiBbXCJ0cnVlXCIsIFwiZmFsc2VcIiwgXCJ1bmRlZmluZWRcIl0sXG4gIFwiYXJpYS1mbG93dG9cIjogbnVsbCxcbiAgXCJhcmlhLWdyYWJiZWRcIjogW1widHJ1ZVwiLCBcImZhbHNlXCIsIFwidW5kZWZpbmVkXCJdLFxuICBcImFyaWEtaGFzcG9wdXBcIjogQ24sXG4gIFwiYXJpYS1oaWRkZW5cIjogQ24sXG4gIFwiYXJpYS1pbnZhbGlkXCI6IFtcInRydWVcIiwgXCJmYWxzZVwiLCBcImdyYW1tYXJcIiwgXCJzcGVsbGluZ1wiXSxcbiAgXCJhcmlhLWxhYmVsXCI6IG51bGwsXG4gIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IG51bGwsXG4gIFwiYXJpYS1sZXZlbFwiOiBudWxsLFxuICBcImFyaWEtbGl2ZVwiOiBbXCJvZmZcIiwgXCJwb2xpdGVcIiwgXCJhc3NlcnRpdmVcIl0sXG4gIFwiYXJpYS1tdWx0aWxpbmVcIjogQ24sXG4gIFwiYXJpYS1tdWx0aXNlbGVjdGFibGVcIjogQ24sXG4gIFwiYXJpYS1vd25zXCI6IG51bGwsXG4gIFwiYXJpYS1wb3NpbnNldFwiOiBudWxsLFxuICBcImFyaWEtcHJlc3NlZFwiOiBbXCJ0cnVlXCIsIFwiZmFsc2VcIiwgXCJtaXhlZFwiLCBcInVuZGVmaW5lZFwiXSxcbiAgXCJhcmlhLXJlYWRvbmx5XCI6IENuLFxuICBcImFyaWEtcmVsZXZhbnRcIjogbnVsbCxcbiAgXCJhcmlhLXJlcXVpcmVkXCI6IENuLFxuICBcImFyaWEtc2VsZWN0ZWRcIjogW1widHJ1ZVwiLCBcImZhbHNlXCIsIFwidW5kZWZpbmVkXCJdLFxuICBcImFyaWEtc2V0c2l6ZVwiOiBudWxsLFxuICBcImFyaWEtc29ydFwiOiBbXCJhc2NlbmRpbmdcIiwgXCJkZXNjZW5kaW5nXCIsIFwibm9uZVwiLCBcIm90aGVyXCJdLFxuICBcImFyaWEtdmFsdWVtYXhcIjogbnVsbCxcbiAgXCJhcmlhLXZhbHVlbWluXCI6IG51bGwsXG4gIFwiYXJpYS12YWx1ZW5vd1wiOiBudWxsLFxuICBcImFyaWEtdmFsdWV0ZXh0XCI6IG51bGxcbn0sIGxQID0gLyogQF9fUFVSRV9fICovIFwiYmVmb3JldW5sb2FkIGNvcHkgY3V0IGRyYWdzdGFydCBkcmFnb3ZlciBkcmFnbGVhdmUgZHJhZ2VudGVyIGRyYWdlbmQgZHJhZyBwYXN0ZSBmb2N1cyBibHVyIGNoYW5nZSBjbGljayBsb2FkIG1vdXNlZG93biBtb3VzZWVudGVyIG1vdXNlbGVhdmUgbW91c2V1cCBrZXlkb3duIGtleXVwIHJlc2l6ZSBzY3JvbGwgdW5sb2FkXCIuc3BsaXQoXCIgXCIpLm1hcCgodCkgPT4gXCJvblwiICsgdCk7XG5mb3IgKGxldCB0IG9mIGxQKVxuICBhUFt0XSA9IG51bGw7XG5jbGFzcyBKdSB7XG4gIGNvbnN0cnVjdG9yKGUsIG4pIHtcbiAgICB0aGlzLnRhZ3MgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxJKSwgZSksIHRoaXMuZ2xvYmFsQXR0cnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFQKSwgbiksIHRoaXMuYWxsVGFncyA9IE9iamVjdC5rZXlzKHRoaXMudGFncyksIHRoaXMuZ2xvYmFsQXR0ck5hbWVzID0gT2JqZWN0LmtleXModGhpcy5nbG9iYWxBdHRycyk7XG4gIH1cbn1cbkp1LmRlZmF1bHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IEp1KCk7XG5mdW5jdGlvbiBxbyh0LCBlLCBuID0gdC5sZW5ndGgpIHtcbiAgaWYgKCFlKVxuICAgIHJldHVybiBcIlwiO1xuICBsZXQgciA9IGUuZmlyc3RDaGlsZCwgaSA9IHIgJiYgci5nZXRDaGlsZChcIlRhZ05hbWVcIik7XG4gIHJldHVybiBpID8gdC5zbGljZVN0cmluZyhpLmZyb20sIE1hdGgubWluKGkudG8sIG4pKSA6IFwiXCI7XG59XG5mdW5jdGlvbiBZbyh0LCBlID0gITEpIHtcbiAgZm9yICg7IHQ7IHQgPSB0LnBhcmVudClcbiAgICBpZiAodC5uYW1lID09IFwiRWxlbWVudFwiKVxuICAgICAgaWYgKGUpXG4gICAgICAgIGUgPSAhMTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHQ7XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY1AodCwgZSwgbikge1xuICBsZXQgciA9IG4udGFnc1txbyh0LCBZbyhlKSldO1xuICByZXR1cm4gKHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIuY2hpbGRyZW4pIHx8IG4uYWxsVGFncztcbn1cbmZ1bmN0aW9uIFBnKHQsIGUpIHtcbiAgbGV0IG4gPSBbXTtcbiAgZm9yIChsZXQgciA9IFlvKGUpOyByICYmICFyLnR5cGUuaXNUb3A7IHIgPSBZbyhyLnBhcmVudCkpIHtcbiAgICBsZXQgaSA9IHFvKHQsIHIpO1xuICAgIGlmIChpICYmIHIubGFzdENoaWxkLm5hbWUgPT0gXCJDbG9zZVRhZ1wiKVxuICAgICAgYnJlYWs7XG4gICAgaSAmJiBuLmluZGV4T2YoaSkgPCAwICYmIChlLm5hbWUgPT0gXCJFbmRUYWdcIiB8fCBlLmZyb20gPj0gci5maXJzdENoaWxkLnRvKSAmJiBuLnB1c2goaSk7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5jb25zdCB1UCA9IC9eWzpcXC1cXC5cXHdcXHUwMGI3LVxcdWZmZmZdKiQvO1xuZnVuY3Rpb24gUDAodCwgZSwgbiwgciwgaSkge1xuICBsZXQgcyA9IC9cXHMqPi8udGVzdCh0LnNsaWNlRG9jKGksIGkgKyA1KSkgPyBcIlwiIDogXCI+XCIsIG8gPSBZbyhuLCAhMCk7XG4gIHJldHVybiB7XG4gICAgZnJvbTogcixcbiAgICB0bzogaSxcbiAgICBvcHRpb25zOiBjUCh0LmRvYywgbywgZSkubWFwKChhKSA9PiAoeyBsYWJlbDogYSwgdHlwZTogXCJ0eXBlXCIgfSkpLmNvbmNhdChQZyh0LmRvYywgbikubWFwKChhLCBsKSA9PiAoe1xuICAgICAgbGFiZWw6IFwiL1wiICsgYSxcbiAgICAgIGFwcGx5OiBcIi9cIiArIGEgKyBzLFxuICAgICAgdHlwZTogXCJ0eXBlXCIsXG4gICAgICBib29zdDogOTkgLSBsXG4gICAgfSkpKSxcbiAgICB2YWxpZEZvcjogL15cXC8/WzpcXC1cXC5cXHdcXHUwMGI3LVxcdWZmZmZdKiQvXG4gIH07XG59XG5mdW5jdGlvbiBfMCh0LCBlLCBuLCByKSB7XG4gIGxldCBpID0gL1xccyo+Ly50ZXN0KHQuc2xpY2VEb2MociwgciArIDUpKSA/IFwiXCIgOiBcIj5cIjtcbiAgcmV0dXJuIHtcbiAgICBmcm9tOiBuLFxuICAgIHRvOiByLFxuICAgIG9wdGlvbnM6IFBnKHQuZG9jLCBlKS5tYXAoKHMsIG8pID0+ICh7IGxhYmVsOiBzLCBhcHBseTogcyArIGksIHR5cGU6IFwidHlwZVwiLCBib29zdDogOTkgLSBvIH0pKSxcbiAgICB2YWxpZEZvcjogdVBcbiAgfTtcbn1cbmZ1bmN0aW9uIGNJKHQsIGUsIG4sIHIpIHtcbiAgbGV0IGkgPSBbXSwgcyA9IDA7XG4gIGZvciAobGV0IG8gb2YgY1AodC5kb2MsIG4sIGUpKVxuICAgIGkucHVzaCh7IGxhYmVsOiBcIjxcIiArIG8sIHR5cGU6IFwidHlwZVwiIH0pO1xuICBmb3IgKGxldCBvIG9mIFBnKHQuZG9jLCBuKSlcbiAgICBpLnB1c2goeyBsYWJlbDogXCI8L1wiICsgbyArIFwiPlwiLCB0eXBlOiBcInR5cGVcIiwgYm9vc3Q6IDk5IC0gcysrIH0pO1xuICByZXR1cm4geyBmcm9tOiByLCB0bzogciwgb3B0aW9uczogaSwgdmFsaWRGb3I6IC9ePFxcLz9bOlxcLVxcLlxcd1xcdTAwYjctXFx1ZmZmZl0qJC8gfTtcbn1cbmZ1bmN0aW9uIHVJKHQsIGUsIG4sIHIsIGkpIHtcbiAgbGV0IHMgPSBZbyhuKSwgbyA9IHMgPyBlLnRhZ3NbcW8odC5kb2MsIHMpXSA6IG51bGwsIGEgPSBvICYmIG8uYXR0cnMgPyBPYmplY3Qua2V5cyhvLmF0dHJzKSA6IFtdLCBsID0gbyAmJiBvLmdsb2JhbEF0dHJzID09PSAhMSA/IGEgOiBhLmxlbmd0aCA/IGEuY29uY2F0KGUuZ2xvYmFsQXR0ck5hbWVzKSA6IGUuZ2xvYmFsQXR0ck5hbWVzO1xuICByZXR1cm4ge1xuICAgIGZyb206IHIsXG4gICAgdG86IGksXG4gICAgb3B0aW9uczogbC5tYXAoKGMpID0+ICh7IGxhYmVsOiBjLCB0eXBlOiBcInByb3BlcnR5XCIgfSkpLFxuICAgIHZhbGlkRm9yOiB1UFxuICB9O1xufVxuZnVuY3Rpb24gZEkodCwgZSwgbiwgciwgaSkge1xuICB2YXIgcztcbiAgbGV0IG8gPSAocyA9IG4ucGFyZW50KSA9PT0gbnVsbCB8fCBzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzLmdldENoaWxkKFwiQXR0cmlidXRlTmFtZVwiKSwgYSA9IFtdLCBsO1xuICBpZiAobykge1xuICAgIGxldCBjID0gdC5zbGljZURvYyhvLmZyb20sIG8udG8pLCB1ID0gZS5nbG9iYWxBdHRyc1tjXTtcbiAgICBpZiAoIXUpIHtcbiAgICAgIGxldCBkID0gWW8obiksIGYgPSBkID8gZS50YWdzW3FvKHQuZG9jLCBkKV0gOiBudWxsO1xuICAgICAgdSA9IChmID09IG51bGwgPyB2b2lkIDAgOiBmLmF0dHJzKSAmJiBmLmF0dHJzW2NdO1xuICAgIH1cbiAgICBpZiAodSkge1xuICAgICAgbGV0IGQgPSB0LnNsaWNlRG9jKHIsIGkpLnRvTG93ZXJDYXNlKCksIGYgPSAnXCInLCBoID0gJ1wiJztcbiAgICAgIC9eWydcIl0vLnRlc3QoZCkgPyAobCA9IGRbMF0gPT0gJ1wiJyA/IC9eW15cIl0qJC8gOiAvXlteJ10qJC8sIGYgPSBcIlwiLCBoID0gdC5zbGljZURvYyhpLCBpICsgMSkgPT0gZFswXSA/IFwiXCIgOiBkWzBdLCBkID0gZC5zbGljZSgxKSwgcisrKSA6IGwgPSAvXlteXFxzPD49J1wiXSokLztcbiAgICAgIGZvciAobGV0IHAgb2YgdSlcbiAgICAgICAgYS5wdXNoKHsgbGFiZWw6IHAsIGFwcGx5OiBmICsgcCArIGgsIHR5cGU6IFwiY29uc3RhbnRcIiB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgZnJvbTogciwgdG86IGksIG9wdGlvbnM6IGEsIHZhbGlkRm9yOiBsIH07XG59XG5mdW5jdGlvbiBmSSh0LCBlKSB7XG4gIGxldCB7IHN0YXRlOiBuLCBwb3M6IHIgfSA9IGUsIGkgPSB1bihuKS5yZXNvbHZlSW5uZXIociwgLTEpLCBzID0gaS5yZXNvbHZlKHIpO1xuICBmb3IgKGxldCBvID0gciwgYTsgcyA9PSBpICYmIChhID0gaS5jaGlsZEJlZm9yZShvKSk7ICkge1xuICAgIGxldCBsID0gYS5sYXN0Q2hpbGQ7XG4gICAgaWYgKCFsIHx8ICFsLnR5cGUuaXNFcnJvciB8fCBsLmZyb20gPCBsLnRvKVxuICAgICAgYnJlYWs7XG4gICAgcyA9IGkgPSBhLCBvID0gbC5mcm9tO1xuICB9XG4gIHJldHVybiBpLm5hbWUgPT0gXCJUYWdOYW1lXCIgPyBpLnBhcmVudCAmJiAvQ2xvc2VUYWckLy50ZXN0KGkucGFyZW50Lm5hbWUpID8gXzAobiwgaSwgaS5mcm9tLCByKSA6IFAwKG4sIHQsIGksIGkuZnJvbSwgcikgOiBpLm5hbWUgPT0gXCJTdGFydFRhZ1wiID8gUDAobiwgdCwgaSwgciwgcikgOiBpLm5hbWUgPT0gXCJTdGFydENsb3NlVGFnXCIgfHwgaS5uYW1lID09IFwiSW5jb21wbGV0ZUNsb3NlVGFnXCIgPyBfMChuLCBpLCByLCByKSA6IGkubmFtZSA9PSBcIk9wZW5UYWdcIiB8fCBpLm5hbWUgPT0gXCJTZWxmQ2xvc2luZ1RhZ1wiIHx8IGkubmFtZSA9PSBcIkF0dHJpYnV0ZU5hbWVcIiA/IHVJKG4sIHQsIGksIGkubmFtZSA9PSBcIkF0dHJpYnV0ZU5hbWVcIiA/IGkuZnJvbSA6IHIsIHIpIDogaS5uYW1lID09IFwiSXNcIiB8fCBpLm5hbWUgPT0gXCJBdHRyaWJ1dGVWYWx1ZVwiIHx8IGkubmFtZSA9PSBcIlVucXVvdGVkQXR0cmlidXRlVmFsdWVcIiA/IGRJKG4sIHQsIGksIGkubmFtZSA9PSBcIklzXCIgPyByIDogaS5mcm9tLCByKSA6IGUuZXhwbGljaXQgJiYgKHMubmFtZSA9PSBcIkVsZW1lbnRcIiB8fCBzLm5hbWUgPT0gXCJUZXh0XCIgfHwgcy5uYW1lID09IFwiRG9jdW1lbnRcIikgPyBjSShuLCB0LCBpLCByKSA6IG51bGw7XG59XG5mdW5jdGlvbiBoSSh0KSB7XG4gIGxldCB7IGV4dHJhVGFnczogZSwgZXh0cmFHbG9iYWxBdHRyaWJ1dGVzOiBuIH0gPSB0LCByID0gbiB8fCBlID8gbmV3IEp1KGUsIG4pIDogSnUuZGVmYXVsdDtcbiAgcmV0dXJuIChpKSA9PiBmSShyLCBpKTtcbn1cbmNvbnN0IHBJID0gLyogQF9fUFVSRV9fICovIElyLnBhcnNlci5jb25maWd1cmUoeyB0b3A6IFwiU2luZ2xlRXhwcmVzc2lvblwiIH0pLCBkUCA9IFtcbiAge1xuICAgIHRhZzogXCJzY3JpcHRcIixcbiAgICBhdHRyczogKHQpID0+IHQudHlwZSA9PSBcInRleHQvdHlwZXNjcmlwdFwiIHx8IHQubGFuZyA9PSBcInRzXCIsXG4gICAgcGFyc2VyOiBuUC5wYXJzZXJcbiAgfSxcbiAge1xuICAgIHRhZzogXCJzY3JpcHRcIixcbiAgICBhdHRyczogKHQpID0+IHQudHlwZSA9PSBcInRleHQvYmFiZWxcIiB8fCB0LnR5cGUgPT0gXCJ0ZXh0L2pzeFwiLFxuICAgIHBhcnNlcjogclAucGFyc2VyXG4gIH0sXG4gIHtcbiAgICB0YWc6IFwic2NyaXB0XCIsXG4gICAgYXR0cnM6ICh0KSA9PiB0LnR5cGUgPT0gXCJ0ZXh0L3R5cGVzY3JpcHQtanN4XCIsXG4gICAgcGFyc2VyOiBpUC5wYXJzZXJcbiAgfSxcbiAge1xuICAgIHRhZzogXCJzY3JpcHRcIixcbiAgICBhdHRycyh0KSB7XG4gICAgICByZXR1cm4gL14oaW1wb3J0bWFwfHNwZWN1bGF0aW9ucnVsZXN8YXBwbGljYXRpb25cXC8oLitcXCspP2pzb24pJC9pLnRlc3QodC50eXBlKTtcbiAgICB9LFxuICAgIHBhcnNlcjogcElcbiAgfSxcbiAge1xuICAgIHRhZzogXCJzY3JpcHRcIixcbiAgICBhdHRycyh0KSB7XG4gICAgICByZXR1cm4gIXQudHlwZSB8fCAvXig/OnRleHR8YXBwbGljYXRpb24pXFwvKD86eC0pPyg/OmphdmF8ZWNtYSlzY3JpcHQkfF5tb2R1bGUkfF4kL2kudGVzdCh0LnR5cGUpO1xuICAgIH0sXG4gICAgcGFyc2VyOiBJci5wYXJzZXJcbiAgfSxcbiAge1xuICAgIHRhZzogXCJzdHlsZVwiLFxuICAgIGF0dHJzKHQpIHtcbiAgICAgIHJldHVybiAoIXQubGFuZyB8fCB0LmxhbmcgPT0gXCJjc3NcIikgJiYgKCF0LnR5cGUgfHwgL14odGV4dFxcLyk/KHgtKT8oc3R5bGVzaGVldHxjc3MpJC9pLnRlc3QodC50eXBlKSk7XG4gICAgfSxcbiAgICBwYXJzZXI6IEZ1LnBhcnNlclxuICB9XG5dLCBmUCA9IC8qIEBfX1BVUkVfXyAqLyBbXG4gIHtcbiAgICBuYW1lOiBcInN0eWxlXCIsXG4gICAgcGFyc2VyOiAvKiBAX19QVVJFX18gKi8gRnUucGFyc2VyLmNvbmZpZ3VyZSh7IHRvcDogXCJTdHlsZXNcIiB9KVxuICB9XG5dLmNvbmNhdCgvKiBAX19QVVJFX18gKi8gbFAubWFwKCh0KSA9PiAoeyBuYW1lOiB0LCBwYXJzZXI6IElyLnBhcnNlciB9KSkpLCBoUCA9IC8qIEBfX1BVUkVfXyAqLyBjcy5kZWZpbmUoe1xuICBuYW1lOiBcImh0bWxcIixcbiAgcGFyc2VyOiAvKiBAX19QVVJFX18gKi8gVDMuY29uZmlndXJlKHtcbiAgICBwcm9wczogW1xuICAgICAgLyogQF9fUFVSRV9fICovIHNhLmFkZCh7XG4gICAgICAgIEVsZW1lbnQodCkge1xuICAgICAgICAgIGxldCBlID0gL14oXFxzKikoPFxcLyk/Ly5leGVjKHQudGV4dEFmdGVyKTtcbiAgICAgICAgICByZXR1cm4gdC5ub2RlLnRvIDw9IHQucG9zICsgZVswXS5sZW5ndGggPyB0LmNvbnRpbnVlKCkgOiB0LmxpbmVJbmRlbnQodC5ub2RlLmZyb20pICsgKGVbMl0gPyAwIDogdC51bml0KTtcbiAgICAgICAgfSxcbiAgICAgICAgXCJPcGVuVGFnIENsb3NlVGFnIFNlbGZDbG9zaW5nVGFnXCIodCkge1xuICAgICAgICAgIHJldHVybiB0LmNvbHVtbih0Lm5vZGUuZnJvbSkgKyB0LnVuaXQ7XG4gICAgICAgIH0sXG4gICAgICAgIERvY3VtZW50KHQpIHtcbiAgICAgICAgICBpZiAodC5wb3MgKyAvXFxzKi8uZXhlYyh0LnRleHRBZnRlcilbMF0ubGVuZ3RoIDwgdC5ub2RlLnRvKVxuICAgICAgICAgICAgcmV0dXJuIHQuY29udGludWUoKTtcbiAgICAgICAgICBsZXQgZSA9IG51bGwsIG47XG4gICAgICAgICAgZm9yIChsZXQgciA9IHQubm9kZTsgOyApIHtcbiAgICAgICAgICAgIGxldCBpID0gci5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICBpZiAoIWkgfHwgaS5uYW1lICE9IFwiRWxlbWVudFwiIHx8IGkudG8gIT0gci50bylcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBlID0gciA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBlICYmICEoKG4gPSBlLmxhc3RDaGlsZCkgJiYgKG4ubmFtZSA9PSBcIkNsb3NlVGFnXCIgfHwgbi5uYW1lID09IFwiU2VsZkNsb3NpbmdUYWdcIikpID8gdC5saW5lSW5kZW50KGUuZnJvbSkgKyB0LnVuaXQgOiBudWxsO1xuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBLbC5hZGQoe1xuICAgICAgICBFbGVtZW50KHQpIHtcbiAgICAgICAgICBsZXQgZSA9IHQuZmlyc3RDaGlsZCwgbiA9IHQubGFzdENoaWxkO1xuICAgICAgICAgIHJldHVybiAhZSB8fCBlLm5hbWUgIT0gXCJPcGVuVGFnXCIgPyBudWxsIDogeyBmcm9tOiBlLnRvLCB0bzogbi5uYW1lID09IFwiQ2xvc2VUYWdcIiA/IG4uZnJvbSA6IHQudG8gfTtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICAvKiBAX19QVVJFX18gKi8gbXguYWRkKHtcbiAgICAgICAgXCJPcGVuVGFnIENsb3NlVGFnXCI6ICh0KSA9PiB0LmdldENoaWxkKFwiVGFnTmFtZVwiKVxuICAgICAgfSlcbiAgICBdXG4gIH0pLFxuICBsYW5ndWFnZURhdGE6IHtcbiAgICBjb21tZW50VG9rZW5zOiB7IGJsb2NrOiB7IG9wZW46IFwiPCEtLVwiLCBjbG9zZTogXCItLT5cIiB9IH0sXG4gICAgaW5kZW50T25JbnB1dDogL15cXHMqPFxcL1xcdytcXFckLyxcbiAgICB3b3JkQ2hhcnM6IFwiLS5fXCJcbiAgfVxufSksIGR1ID0gLyogQF9fUFVSRV9fICovIGhQLmNvbmZpZ3VyZSh7XG4gIHdyYXA6IC8qIEBfX1BVUkVfXyAqLyBIeChkUCwgZlApXG59KTtcbmZ1bmN0aW9uIE9JKHQgPSB7fSkge1xuICBsZXQgZSA9IFwiXCIsIG47XG4gIHQubWF0Y2hDbG9zaW5nVGFncyA9PT0gITEgJiYgKGUgPSBcIm5vTWF0Y2hcIiksIHQuc2VsZkNsb3NpbmdUYWdzID09PSAhMCAmJiAoZSA9IChlID8gZSArIFwiIFwiIDogXCJcIikgKyBcInNlbGZDbG9zaW5nXCIpLCAodC5uZXN0ZWRMYW5ndWFnZXMgJiYgdC5uZXN0ZWRMYW5ndWFnZXMubGVuZ3RoIHx8IHQubmVzdGVkQXR0cmlidXRlcyAmJiB0Lm5lc3RlZEF0dHJpYnV0ZXMubGVuZ3RoKSAmJiAobiA9IEh4KCh0Lm5lc3RlZExhbmd1YWdlcyB8fCBbXSkuY29uY2F0KGRQKSwgKHQubmVzdGVkQXR0cmlidXRlcyB8fCBbXSkuY29uY2F0KGZQKSkpO1xuICBsZXQgciA9IG4gPyBoUC5jb25maWd1cmUoeyB3cmFwOiBuLCBkaWFsZWN0OiBlIH0pIDogZSA/IGR1LmNvbmZpZ3VyZSh7IGRpYWxlY3Q6IGUgfSkgOiBkdTtcbiAgcmV0dXJuIG5ldyBHbChyLCBbXG4gICAgZHUuZGF0YS5vZih7IGF1dG9jb21wbGV0ZTogaEkodCkgfSksXG4gICAgdC5hdXRvQ2xvc2VUYWdzICE9PSAhMSA/IGdJIDogW10sXG4gICAgaUkoKS5zdXBwb3J0LFxuICAgIEl4KCkuc3VwcG9ydFxuICBdKTtcbn1cbmNvbnN0IFQwID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoLyogQF9fUFVSRV9fICovIFwiYXJlYSBiYXNlIGJyIGNvbCBjb21tYW5kIGVtYmVkIGZyYW1lIGhyIGltZyBpbnB1dCBrZXlnZW4gbGluayBtZXRhIHBhcmFtIHNvdXJjZSB0cmFjayB3YnIgbWVudWl0ZW1cIi5zcGxpdChcIiBcIikpLCBnSSA9IC8qIEBfX1BVUkVfXyAqLyBTZS5pbnB1dEhhbmRsZXIub2YoKHQsIGUsIG4sIHIsIGkpID0+IHtcbiAgaWYgKHQuY29tcG9zaW5nIHx8IHQuc3RhdGUucmVhZE9ubHkgfHwgZSAhPSBuIHx8IHIgIT0gXCI+XCIgJiYgciAhPSBcIi9cIiB8fCAhZHUuaXNBY3RpdmVBdCh0LnN0YXRlLCBlLCAtMSkpXG4gICAgcmV0dXJuICExO1xuICBsZXQgcyA9IGkoKSwgeyBzdGF0ZTogbyB9ID0gcywgYSA9IG8uY2hhbmdlQnlSYW5nZSgobCkgPT4ge1xuICAgIHZhciBjLCB1LCBkO1xuICAgIGxldCBmID0gby5kb2Muc2xpY2VTdHJpbmcobC5mcm9tIC0gMSwgbC50bykgPT0gciwgeyBoZWFkOiBoIH0gPSBsLCBwID0gdW4obykucmVzb2x2ZUlubmVyKGggLSAxLCAtMSksIE87XG4gICAgaWYgKChwLm5hbWUgPT0gXCJUYWdOYW1lXCIgfHwgcC5uYW1lID09IFwiU3RhcnRUYWdcIikgJiYgKHAgPSBwLnBhcmVudCksIGYgJiYgciA9PSBcIj5cIiAmJiBwLm5hbWUgPT0gXCJPcGVuVGFnXCIpIHtcbiAgICAgIGlmICgoKHUgPSAoYyA9IHAucGFyZW50KSA9PT0gbnVsbCB8fCBjID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjLmxhc3RDaGlsZCkgPT09IG51bGwgfHwgdSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdS5uYW1lKSAhPSBcIkNsb3NlVGFnXCIgJiYgKE8gPSBxbyhvLmRvYywgcC5wYXJlbnQsIGgpKSAmJiAhVDAuaGFzKE8pKSB7XG4gICAgICAgIGxldCBtID0gaCArIChvLmRvYy5zbGljZVN0cmluZyhoLCBoICsgMSkgPT09IFwiPlwiID8gMSA6IDApLCB5ID0gYDwvJHtPfT5gO1xuICAgICAgICByZXR1cm4geyByYW5nZTogbCwgY2hhbmdlczogeyBmcm9tOiBoLCB0bzogbSwgaW5zZXJ0OiB5IH0gfTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGYgJiYgciA9PSBcIi9cIiAmJiBwLm5hbWUgPT0gXCJJbmNvbXBsZXRlQ2xvc2VUYWdcIikge1xuICAgICAgbGV0IG0gPSBwLnBhcmVudDtcbiAgICAgIGlmIChwLmZyb20gPT0gaCAtIDIgJiYgKChkID0gbS5sYXN0Q2hpbGQpID09PSBudWxsIHx8IGQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGQubmFtZSkgIT0gXCJDbG9zZVRhZ1wiICYmIChPID0gcW8oby5kb2MsIG0sIGgpKSAmJiAhVDAuaGFzKE8pKSB7XG4gICAgICAgIGxldCB5ID0gaCArIChvLmRvYy5zbGljZVN0cmluZyhoLCBoICsgMSkgPT09IFwiPlwiID8gMSA6IDApLCBiID0gYCR7T30+YDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByYW5nZTogYWUuY3Vyc29yKGggKyBiLmxlbmd0aCwgLTEpLFxuICAgICAgICAgIGNoYW5nZXM6IHsgZnJvbTogaCwgdG86IHksIGluc2VydDogYiB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHJhbmdlOiBsIH07XG4gIH0pO1xuICByZXR1cm4gYS5jaGFuZ2VzLmVtcHR5ID8gITEgOiAodC5kaXNwYXRjaChbXG4gICAgcyxcbiAgICBvLnVwZGF0ZShhLCB7XG4gICAgICB1c2VyRXZlbnQ6IFwiaW5wdXQuY29tcGxldGVcIixcbiAgICAgIHNjcm9sbEludG9WaWV3OiAhMFxuICAgIH0pXG4gIF0pLCAhMCk7XG59KSwgbUkgPSBpYSh7XG4gIFN0cmluZzogUC5zdHJpbmcsXG4gIE51bWJlcjogUC5udW1iZXIsXG4gIFwiVHJ1ZSBGYWxzZVwiOiBQLmJvb2wsXG4gIFByb3BlcnR5TmFtZTogUC5wcm9wZXJ0eU5hbWUsXG4gIE51bGw6IFAubnVsbCxcbiAgXCIsXCI6IFAuc2VwYXJhdG9yLFxuICBcIlsgXVwiOiBQLnNxdWFyZUJyYWNrZXQsXG4gIFwieyB9XCI6IFAuYnJhY2Vcbn0pLCBiSSA9IHVzLmRlc2VyaWFsaXplKHtcbiAgdmVyc2lvbjogMTQsXG4gIHN0YXRlczogXCIkYk9WUVBPT09PUU8nI0NiJyNDYk9uUVBPJyNDZU92UVBPJyNDak9PUU8nI0NwJyNDcFFPUVBPT09PUU8nI0NnJyNDZ099UVBPJyNDZk8hU1FQTycjQ3JPT1FPLDU5UCw1OVBPIVtRUE8sNTlQTyFhUVBPJyNDdU9PUU8sNTlVLDU5VU8haVFQTyw1OVVPVlFQTyw1OVFPcVFQTycjQ2tPIW5RUE8sNTleT09RTzFHLmsxRy5rT1ZRUE8nI0NsTyF2UVBPLDU5YU9PUU8xRy5wMUcucE9PUU8xRy5sMUcubE9PUU8sNTlWLDU5Vk9PUU8tRTZpLUU2aU9PUU8sNTlXLDU5V09PUU8tRTZqLUU2alwiLFxuICBzdGF0ZURhdGE6IFwiI09+T2NPU35PUVNPUlNPU1NPVFNPV1FPXVJPZVBPfk9WWE9lVU9+T1tbT35QVk9nXk9+T2hfT1ZmWH5PVmFPfk9oYk9baVh+T1tkT35PaF9PVmZhfk9oYk9baWF+T1wiLFxuICBnb3RvOiBcIiFralBQUFBQUGtQUGtxd1BQa3shUlBQUCFYUCFlUFAhaFhTT1JeYlFXUVJmX1RWUV9RYFdSZ2BRY1pSaWNRVE9RWlJRZV5SaGJSWVFSXVJcIixcbiAgbm9kZU5hbWVzOiBcIuKaoCBKc29uVGV4dCBUcnVlIEZhbHNlIE51bGwgTnVtYmVyIFN0cmluZyB9IHsgT2JqZWN0IFByb3BlcnR5IFByb3BlcnR5TmFtZSBdIFsgQXJyYXlcIixcbiAgbWF4VGVybTogMjUsXG4gIG5vZGVQcm9wczogW1xuICAgIFtcImlzb2xhdGVcIiwgLTIsIDYsIDExLCBcIlwiXSxcbiAgICBbXCJvcGVuZWRCeVwiLCA3LCBcIntcIiwgMTIsIFwiW1wiXSxcbiAgICBbXCJjbG9zZWRCeVwiLCA4LCBcIn1cIiwgMTMsIFwiXVwiXVxuICBdLFxuICBwcm9wU291cmNlczogW21JXSxcbiAgc2tpcHBlZE5vZGVzOiBbMF0sXG4gIHJlcGVhdE5vZGVDb3VudDogMixcbiAgdG9rZW5EYXRhOiBcIih8flJhWFkhV1laIVddXiFXcHEhV3JzIV18fSR1fSFPJHohUSFSJVQhUiFbJmMhWyFdJnQhfSNPJnkjUCNRJ08jWSNaJ1QjYiNjJ3IjaCNpKFojbyNwKHIjcSNyKHd+IV1PY35+IWBXcHEhXXFyIV1ycyF4cyNPIV0jTyNQIX0jUDsnUyFdOydTOz1gJG88JWxPIV1+IX1PZX5+I1FYcnMhXSFQIVEhXSNPI1AhXSNVI1YhXSNZI1ohXSNiI2MhXSNmI2chXSNoI2khXSNpI2ojbX4jcFIhUSFbI3khYyFpI3kjVCNaI3l+I3xSIVEhWyRWIWMhaSRWI1QjWiRWfiRZUiFRIVskYyFjIWkkYyNUI1okY34kZlIhUSFbIV0hYyFpIV0jVCNaIV1+JHJQOz1gPCVsIV1+JHpPaH5+JH1RIVEhUiVUIVIhWyZjfiVZUlR+IU8hUCVjIWchaCV3I1gjWSV3fiVmUCFRIVslaX4lblJUfiFRIVslaSFnIWgldyNYI1kld34lelJ7fCZUfSFPJlQhUSFbJlp+JldQIVEhWyZafiZgUFR+IVEhWyZafiZoU1R+IU8hUCVjIVEhWyZjIWchaCV3I1gjWSV3fiZ5T2d+fidPT11+fidUT1t+fidXUCNUI1UnWn4nXlAjYCNhJ2F+J2RQI2cjaCdnfidqUCNYI1knbX4nck9Sfn4ndVAjaSNqJ3h+J3tQI2AjYShPfihSUCNgI2EoVX4oWk9Tfn4oXlAjZiNnKGF+KGRQI2kjaihnfihqUCNYI1kobX4ock9Rfn4od09Xfn4ofE9WflwiLFxuICB0b2tlbml6ZXJzOiBbMF0sXG4gIHRvcFJ1bGVzOiB7IEpzb25UZXh0OiBbMCwgMV0gfSxcbiAgdG9rZW5QcmVjOiAwXG59KSwgdkkgPSAvKiBAX19QVVJFX18gKi8gY3MuZGVmaW5lKHtcbiAgbmFtZTogXCJqc29uXCIsXG4gIHBhcnNlcjogLyogQF9fUFVSRV9fICovIGJJLmNvbmZpZ3VyZSh7XG4gICAgcHJvcHM6IFtcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBzYS5hZGQoe1xuICAgICAgICBPYmplY3Q6IC8qIEBfX1BVUkVfXyAqLyAkbyh7IGV4Y2VwdDogL15cXHMqXFx9LyB9KSxcbiAgICAgICAgQXJyYXk6IC8qIEBfX1BVUkVfXyAqLyAkbyh7IGV4Y2VwdDogL15cXHMqXFxdLyB9KVxuICAgICAgfSksXG4gICAgICAvKiBAX19QVVJFX18gKi8gS2wuYWRkKHtcbiAgICAgICAgXCJPYmplY3QgQXJyYXlcIjogSGRcbiAgICAgIH0pXG4gICAgXVxuICB9KSxcbiAgbGFuZ3VhZ2VEYXRhOiB7XG4gICAgY2xvc2VCcmFja2V0czogeyBicmFja2V0czogW1wiW1wiLCBcIntcIiwgJ1wiJ10gfSxcbiAgICBpbmRlbnRPbklucHV0OiAvXlxccypbXFx9XFxdXSQvXG4gIH1cbn0pO1xuZnVuY3Rpb24geUkoKSB7XG4gIHJldHVybiBuZXcgR2wodkkpO1xufVxuY29uc3QgZm8gPSA2MywgRTAgPSA2NCwgU0kgPSAxLCB3SSA9IDIsIHBQID0gMywga0kgPSA0LCBPUCA9IDUsIHhJID0gNiwgUEkgPSA3LCBnUCA9IDY1LCBfSSA9IDY2LCBUSSA9IDgsIEVJID0gOSwgJEkgPSAxMCwgUUkgPSAxMSwgQ0kgPSAxMiwgbVAgPSAxMywgQUkgPSAxOSwgUkkgPSAyMCwgTkkgPSAyOSwgREkgPSAzMywgWkkgPSAzNCwgVkkgPSA0NywgSUkgPSAwLCBfZyA9IDEsIFJwID0gMiwgUGwgPSAzLCBOcCA9IDQsIERwID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihlLCBuLCByKSB7XG4gICAgdGhpcy5wYXJlbnQgPSBlLCB0aGlzLmRlcHRoID0gbiwgdGhpcy50eXBlID0gciwgdGhpcy5oYXNoID0gKGUgPyBlLmhhc2ggKyBlLmhhc2ggPDwgOCA6IDApICsgbiArIChuIDw8IDQpICsgcjtcbiAgfVxufTtcbl93KERwLCBcInRvcFwiLCBuZXcgRHAobnVsbCwgLTEsIElJKSk7XG5sZXQgUGEgPSBEcDtcbmZ1bmN0aW9uIEZhKHQsIGUpIHtcbiAgZm9yIChsZXQgbiA9IDAsIHIgPSBlIC0gdC5wb3MgLSAxOyA7IHItLSwgbisrKSB7XG4gICAgbGV0IGkgPSB0LnBlZWsocik7XG4gICAgaWYgKE9pKGkpIHx8IGkgPT0gLTEpXG4gICAgICByZXR1cm4gbjtcbiAgfVxufVxuZnVuY3Rpb24gWnAodCkge1xuICByZXR1cm4gdCA9PSAzMiB8fCB0ID09IDk7XG59XG5mdW5jdGlvbiBPaSh0KSB7XG4gIHJldHVybiB0ID09IDEwIHx8IHQgPT0gMTM7XG59XG5mdW5jdGlvbiBiUCh0KSB7XG4gIHJldHVybiBacCh0KSB8fCBPaSh0KTtcbn1cbmZ1bmN0aW9uIFRzKHQpIHtcbiAgcmV0dXJuIHQgPCAwIHx8IGJQKHQpO1xufVxuY29uc3QgV0kgPSBuZXcgd2coe1xuICBzdGFydDogUGEudG9wLFxuICByZWR1Y2UodCwgZSkge1xuICAgIHJldHVybiB0LnR5cGUgPT0gUGwgJiYgKGUgPT0gUkkgfHwgZSA9PSBaSSkgPyB0LnBhcmVudCA6IHQ7XG4gIH0sXG4gIHNoaWZ0KHQsIGUsIG4sIHIpIHtcbiAgICBpZiAoZSA9PSBwUClcbiAgICAgIHJldHVybiBuZXcgUGEodCwgRmEociwgci5wb3MpLCBfZyk7XG4gICAgaWYgKGUgPT0gZ1AgfHwgZSA9PSBPUClcbiAgICAgIHJldHVybiBuZXcgUGEodCwgRmEociwgci5wb3MpLCBScCk7XG4gICAgaWYgKGUgPT0gZm8pXG4gICAgICByZXR1cm4gdC5wYXJlbnQ7XG4gICAgaWYgKGUgPT0gQUkgfHwgZSA9PSBESSlcbiAgICAgIHJldHVybiBuZXcgUGEodCwgMCwgUGwpO1xuICAgIGlmIChlID09IG1QICYmIHQudHlwZSA9PSBOcClcbiAgICAgIHJldHVybiB0LnBhcmVudDtcbiAgICBpZiAoZSA9PSBWSSkge1xuICAgICAgbGV0IGkgPSAvWzEtOV0vLmV4ZWMoci5yZWFkKHIucG9zLCBuLnBvcykpO1xuICAgICAgaWYgKGkpXG4gICAgICAgIHJldHVybiBuZXcgUGEodCwgdC5kZXB0aCArICtpWzBdLCBOcCk7XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9LFxuICBoYXNoKHQpIHtcbiAgICByZXR1cm4gdC5oYXNoO1xuICB9XG59KTtcbmZ1bmN0aW9uIHpvKHQsIGUsIG4gPSAwKSB7XG4gIHJldHVybiB0LnBlZWsobikgPT0gZSAmJiB0LnBlZWsobiArIDEpID09IGUgJiYgdC5wZWVrKG4gKyAyKSA9PSBlICYmIFRzKHQucGVlayhuICsgMykpO1xufVxuY29uc3QgTUkgPSBuZXcgZ24oKHQsIGUpID0+IHtcbiAgaWYgKHQubmV4dCA9PSAtMSAmJiBlLmNhblNoaWZ0KEUwKSlcbiAgICByZXR1cm4gdC5hY2NlcHRUb2tlbihFMCk7XG4gIGxldCBuID0gdC5wZWVrKC0xKTtcbiAgaWYgKChPaShuKSB8fCBuIDwgMCkgJiYgZS5jb250ZXh0LnR5cGUgIT0gUGwpIHtcbiAgICBpZiAoem8oXG4gICAgICB0LFxuICAgICAgNDVcbiAgICAgIC8qICctJyAqL1xuICAgICkpXG4gICAgICBpZiAoZS5jYW5TaGlmdChmbykpXG4gICAgICAgIHQuYWNjZXB0VG9rZW4oZm8pO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gdC5hY2NlcHRUb2tlbihTSSwgMyk7XG4gICAgaWYgKHpvKFxuICAgICAgdCxcbiAgICAgIDQ2XG4gICAgICAvKiAnLicgKi9cbiAgICApKVxuICAgICAgaWYgKGUuY2FuU2hpZnQoZm8pKVxuICAgICAgICB0LmFjY2VwdFRva2VuKGZvKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuIHQuYWNjZXB0VG9rZW4od0ksIDMpO1xuICAgIGxldCByID0gMDtcbiAgICBmb3IgKDsgdC5uZXh0ID09IDMyOyApXG4gICAgICByKyssIHQuYWR2YW5jZSgpO1xuICAgIChyIDwgZS5jb250ZXh0LmRlcHRoIHx8IHIgPT0gZS5jb250ZXh0LmRlcHRoICYmIGUuY29udGV4dC50eXBlID09IF9nICYmICh0Lm5leHQgIT0gNDUgfHwgIVRzKHQucGVlaygxKSkpKSAmJiAvLyBOb3QgYmxhbmtcbiAgICB0Lm5leHQgIT0gLTEgJiYgIU9pKHQubmV4dCkgJiYgdC5uZXh0ICE9IDM1ICYmIHQuYWNjZXB0VG9rZW4oZm8sIC1yKTtcbiAgfVxufSwgeyBjb250ZXh0dWFsOiAhMCB9KSwgWEkgPSBuZXcgZ24oKHQsIGUpID0+IHtcbiAgaWYgKGUuY29udGV4dC50eXBlID09IFBsKSB7XG4gICAgdC5uZXh0ID09IDYzICYmICh0LmFkdmFuY2UoKSwgVHModC5uZXh0KSAmJiB0LmFjY2VwdFRva2VuKFBJKSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh0Lm5leHQgPT0gNDUpXG4gICAgdC5hZHZhbmNlKCksIFRzKHQubmV4dCkgJiYgdC5hY2NlcHRUb2tlbihlLmNvbnRleHQudHlwZSA9PSBfZyAmJiBlLmNvbnRleHQuZGVwdGggPT0gRmEodCwgdC5wb3MgLSAxKSA/IGtJIDogcFApO1xuICBlbHNlIGlmICh0Lm5leHQgPT0gNjMpXG4gICAgdC5hZHZhbmNlKCksIFRzKHQubmV4dCkgJiYgdC5hY2NlcHRUb2tlbihlLmNvbnRleHQudHlwZSA9PSBScCAmJiBlLmNvbnRleHQuZGVwdGggPT0gRmEodCwgdC5wb3MgLSAxKSA/IHhJIDogT1ApO1xuICBlbHNlIHtcbiAgICBsZXQgbiA9IHQucG9zO1xuICAgIGZvciAoOyA7IClcbiAgICAgIGlmIChacCh0Lm5leHQpKSB7XG4gICAgICAgIGlmICh0LnBvcyA9PSBuKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdC5hZHZhbmNlKCk7XG4gICAgICB9IGVsc2UgaWYgKHQubmV4dCA9PSAzMylcbiAgICAgICAgdlAodCk7XG4gICAgICBlbHNlIGlmICh0Lm5leHQgPT0gMzgpXG4gICAgICAgIFZwKHQpO1xuICAgICAgZWxzZSBpZiAodC5uZXh0ID09IDQyKSB7XG4gICAgICAgIFZwKHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAodC5uZXh0ID09IDM5IHx8IHQubmV4dCA9PSAzNCkge1xuICAgICAgICBpZiAoVGcodCwgITApKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2UgaWYgKHQubmV4dCA9PSA5MSB8fCB0Lm5leHQgPT0gMTIzKSB7XG4gICAgICAgIGlmICghQkkodCkpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlQKHQsICEwLCAhMSwgMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIGZvciAoOyBacCh0Lm5leHQpOyApXG4gICAgICB0LmFkdmFuY2UoKTtcbiAgICBpZiAodC5uZXh0ID09IDU4KSB7XG4gICAgICBpZiAodC5wb3MgPT0gbiAmJiBlLmNhblNoaWZ0KE5JKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbGV0IHIgPSB0LnBlZWsoMSk7XG4gICAgICBUcyhyKSAmJiB0LmFjY2VwdFRva2VuVG8oZS5jb250ZXh0LnR5cGUgPT0gUnAgJiYgZS5jb250ZXh0LmRlcHRoID09IEZhKHQsIG4pID8gX0kgOiBnUCwgbik7XG4gICAgfVxuICB9XG59LCB7IGNvbnRleHR1YWw6ICEwIH0pO1xuZnVuY3Rpb24gakkodCkge1xuICByZXR1cm4gdCA+IDMyICYmIHQgPCAxMjcgJiYgdCAhPSAzNCAmJiB0ICE9IDM3ICYmIHQgIT0gNDQgJiYgdCAhPSA2MCAmJiB0ICE9IDYyICYmIHQgIT0gOTIgJiYgdCAhPSA5NCAmJiB0ICE9IDk2ICYmIHQgIT0gMTIzICYmIHQgIT0gMTI0ICYmIHQgIT0gMTI1O1xufVxuZnVuY3Rpb24gJDAodCkge1xuICByZXR1cm4gdCA+PSA0OCAmJiB0IDw9IDU3IHx8IHQgPj0gOTcgJiYgdCA8PSAxMDIgfHwgdCA+PSA2NSAmJiB0IDw9IDcwO1xufVxuZnVuY3Rpb24gUTAodCwgZSkge1xuICByZXR1cm4gdC5uZXh0ID09IDM3ID8gKHQuYWR2YW5jZSgpLCAkMCh0Lm5leHQpICYmIHQuYWR2YW5jZSgpLCAkMCh0Lm5leHQpICYmIHQuYWR2YW5jZSgpLCAhMCkgOiBqSSh0Lm5leHQpIHx8IGUgJiYgdC5uZXh0ID09IDQ0ID8gKHQuYWR2YW5jZSgpLCAhMCkgOiAhMTtcbn1cbmZ1bmN0aW9uIHZQKHQpIHtcbiAgaWYgKHQuYWR2YW5jZSgpLCB0Lm5leHQgPT0gNjApIHtcbiAgICBmb3IgKHQuYWR2YW5jZSgpOyA7IClcbiAgICAgIGlmICghUTAodCwgITApKSB7XG4gICAgICAgIHQubmV4dCA9PSA2MiAmJiB0LmFkdmFuY2UoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH0gZWxzZVxuICAgIGZvciAoOyBRMCh0LCAhMSk7IClcbiAgICAgIDtcbn1cbmZ1bmN0aW9uIFZwKHQpIHtcbiAgZm9yICh0LmFkdmFuY2UoKTsgIVRzKHQubmV4dCkgJiYgZWQodC50YWcpICE9IFwiZlwiOyApXG4gICAgdC5hZHZhbmNlKCk7XG59XG5mdW5jdGlvbiBUZyh0LCBlKSB7XG4gIGxldCBuID0gdC5uZXh0LCByID0gITEsIGkgPSB0LnBvcztcbiAgZm9yICh0LmFkdmFuY2UoKTsgOyApIHtcbiAgICBsZXQgcyA9IHQubmV4dDtcbiAgICBpZiAocyA8IDApXG4gICAgICBicmVhaztcbiAgICBpZiAodC5hZHZhbmNlKCksIHMgPT0gbilcbiAgICAgIGlmIChzID09IDM5KVxuICAgICAgICBpZiAodC5uZXh0ID09IDM5KVxuICAgICAgICAgIHQuYWR2YW5jZSgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgYnJlYWs7XG4gICAgICBlbHNlXG4gICAgICAgIGJyZWFrO1xuICAgIGVsc2UgaWYgKHMgPT0gOTIgJiYgbiA9PSAzNClcbiAgICAgIHQubmV4dCA+PSAwICYmIHQuYWR2YW5jZSgpO1xuICAgIGVsc2UgaWYgKE9pKHMpKSB7XG4gICAgICBpZiAoZSlcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgciA9ICEwO1xuICAgIH0gZWxzZSBpZiAoZSAmJiB0LnBvcyA+PSBpICsgMTAyNClcbiAgICAgIHJldHVybiAhMTtcbiAgfVxuICByZXR1cm4gIXI7XG59XG5mdW5jdGlvbiBCSSh0KSB7XG4gIGZvciAobGV0IGUgPSBbXSwgbiA9IHQucG9zICsgMTAyNDsgOyApXG4gICAgaWYgKHQubmV4dCA9PSA5MSB8fCB0Lm5leHQgPT0gMTIzKVxuICAgICAgZS5wdXNoKHQubmV4dCksIHQuYWR2YW5jZSgpO1xuICAgIGVsc2UgaWYgKHQubmV4dCA9PSAzOSB8fCB0Lm5leHQgPT0gMzQpIHtcbiAgICAgIGlmICghVGcodCwgITApKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgfSBlbHNlIGlmICh0Lm5leHQgPT0gOTMgfHwgdC5uZXh0ID09IDEyNSkge1xuICAgICAgaWYgKGVbZS5sZW5ndGggLSAxXSAhPSB0Lm5leHQgLSAyKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgICBpZiAoZS5wb3AoKSwgdC5hZHZhbmNlKCksICFlLmxlbmd0aClcbiAgICAgICAgcmV0dXJuICEwO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodC5uZXh0IDwgMCB8fCB0LnBvcyA+IG4gfHwgT2kodC5uZXh0KSlcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgdC5hZHZhbmNlKCk7XG4gICAgfVxufVxuY29uc3QgTEkgPSBcImlpaXNpaWlzc2lzZmlzc3Nzc3Nzc3Nzc3Npc3NzaWlpc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nmc2Zzc2lzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc2ZpZlwiO1xuZnVuY3Rpb24gZWQodCkge1xuICByZXR1cm4gdCA8IDMzID8gXCJ1XCIgOiB0ID4gMTI1ID8gXCJzXCIgOiBMSVt0IC0gMzNdO1xufVxuZnVuY3Rpb24gS2YodCwgZSkge1xuICBsZXQgbiA9IGVkKHQpO1xuICByZXR1cm4gbiAhPSBcInVcIiAmJiAhKGUgJiYgbiA9PSBcImZcIik7XG59XG5mdW5jdGlvbiB5UCh0LCBlLCBuLCByKSB7XG4gIGlmIChlZCh0Lm5leHQpID09IFwic1wiIHx8ICh0Lm5leHQgPT0gNjMgfHwgdC5uZXh0ID09IDU4IHx8IHQubmV4dCA9PSA0NSkgJiYgS2YodC5wZWVrKDEpLCBuKSlcbiAgICB0LmFkdmFuY2UoKTtcbiAgZWxzZVxuICAgIHJldHVybiAhMTtcbiAgbGV0IGkgPSB0LnBvcztcbiAgZm9yICg7IDsgKSB7XG4gICAgbGV0IHMgPSB0Lm5leHQsIG8gPSAwLCBhID0gciArIDE7XG4gICAgZm9yICg7IGJQKHMpOyApIHtcbiAgICAgIGlmIChPaShzKSkge1xuICAgICAgICBpZiAoZSlcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIGEgPSAwO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGErKztcbiAgICAgIHMgPSB0LnBlZWsoKytvKTtcbiAgICB9XG4gICAgaWYgKCEocyA+PSAwICYmIChzID09IDU4ID8gS2YodC5wZWVrKG8gKyAxKSwgbikgOiBzID09IDM1ID8gdC5wZWVrKG8gLSAxKSAhPSAzMiA6IEtmKHMsIG4pKSkgfHwgIW4gJiYgYSA8PSByIHx8IGEgPT0gMCAmJiAhbiAmJiAoem8odCwgNDUsIG8pIHx8IHpvKHQsIDQ2LCBvKSkpXG4gICAgICBicmVhaztcbiAgICBpZiAoZSAmJiBlZChzKSA9PSBcImZcIilcbiAgICAgIHJldHVybiAhMTtcbiAgICBmb3IgKGxldCBjID0gbzsgYyA+PSAwOyBjLS0pXG4gICAgICB0LmFkdmFuY2UoKTtcbiAgICBpZiAoZSAmJiB0LnBvcyA+IGkgKyAxMDI0KVxuICAgICAgcmV0dXJuICExO1xuICB9XG4gIHJldHVybiAhMDtcbn1cbmNvbnN0IFVJID0gbmV3IGduKCh0LCBlKSA9PiB7XG4gIGlmICh0Lm5leHQgPT0gMzMpXG4gICAgdlAodCksIHQuYWNjZXB0VG9rZW4oQ0kpO1xuICBlbHNlIGlmICh0Lm5leHQgPT0gMzggfHwgdC5uZXh0ID09IDQyKSB7XG4gICAgbGV0IG4gPSB0Lm5leHQgPT0gMzggPyAkSSA6IFFJO1xuICAgIFZwKHQpLCB0LmFjY2VwdFRva2VuKG4pO1xuICB9IGVsc2VcbiAgICB0Lm5leHQgPT0gMzkgfHwgdC5uZXh0ID09IDM0ID8gKFRnKHQsICExKSwgdC5hY2NlcHRUb2tlbihFSSkpIDogeVAodCwgITEsIGUuY29udGV4dC50eXBlID09IFBsLCBlLmNvbnRleHQuZGVwdGgpICYmIHQuYWNjZXB0VG9rZW4oVEkpO1xufSksIHFJID0gbmV3IGduKCh0LCBlKSA9PiB7XG4gIGxldCBuID0gZS5jb250ZXh0LnR5cGUgPT0gTnAgPyBlLmNvbnRleHQuZGVwdGggOiAtMSwgciA9IHQucG9zO1xuICBlOlxuICAgIGZvciAoOyA7ICkge1xuICAgICAgbGV0IGkgPSAwLCBzID0gdC5uZXh0O1xuICAgICAgZm9yICg7IHMgPT0gMzI7IClcbiAgICAgICAgcyA9IHQucGVlaygrK2kpO1xuICAgICAgaWYgKCFpICYmICh6byh0LCA0NSwgaSkgfHwgem8odCwgNDYsIGkpKSB8fCAhT2kocykgJiYgKG4gPCAwICYmIChuID0gTWF0aC5tYXgoZS5jb250ZXh0LmRlcHRoICsgMSwgaSkpLCBpIDwgbikpXG4gICAgICAgIGJyZWFrO1xuICAgICAgZm9yICg7IDsgKSB7XG4gICAgICAgIGlmICh0Lm5leHQgPCAwKVxuICAgICAgICAgIGJyZWFrIGU7XG4gICAgICAgIGxldCBvID0gT2kodC5uZXh0KTtcbiAgICAgICAgaWYgKHQuYWR2YW5jZSgpLCBvKVxuICAgICAgICAgIGNvbnRpbnVlIGU7XG4gICAgICAgIHIgPSB0LnBvcztcbiAgICAgIH1cbiAgICB9XG4gIHQuYWNjZXB0VG9rZW5UbyhtUCwgcik7XG59KSwgWUkgPSBpYSh7XG4gIERpcmVjdGl2ZU5hbWU6IFAua2V5d29yZCxcbiAgRGlyZWN0aXZlQ29udGVudDogUC5hdHRyaWJ1dGVWYWx1ZSxcbiAgXCJEaXJlY3RpdmVFbmQgRG9jRW5kXCI6IFAubWV0YSxcbiAgUXVvdGVkTGl0ZXJhbDogUC5zdHJpbmcsXG4gIEJsb2NrTGl0ZXJhbEhlYWRlcjogUC5zcGVjaWFsKFAuc3RyaW5nKSxcbiAgQmxvY2tMaXRlcmFsQ29udGVudDogUC5jb250ZW50LFxuICBMaXRlcmFsOiBQLmNvbnRlbnQsXG4gIFwiS2V5L0xpdGVyYWwgS2V5L1F1b3RlZExpdGVyYWxcIjogUC5kZWZpbml0aW9uKFAucHJvcGVydHlOYW1lKSxcbiAgXCJBbmNob3IgQWxpYXNcIjogUC5sYWJlbE5hbWUsXG4gIFRhZzogUC50eXBlTmFtZSxcbiAgQ29tbWVudDogUC5saW5lQ29tbWVudCxcbiAgXCI6ICwgLVwiOiBQLnNlcGFyYXRvcixcbiAgXCI/XCI6IFAucHVuY3R1YXRpb24sXG4gIFwiWyBdXCI6IFAuc3F1YXJlQnJhY2tldCxcbiAgXCJ7IH1cIjogUC5icmFjZVxufSksIHpJID0gdXMuZGVzZXJpYWxpemUoe1xuICB2ZXJzaW9uOiAxNCxcbiAgc3RhdGVzOiBcIjVsUSFaUWdPT08jUFFmTycjQ3BPI3VRZk8nI0RPT09RUicjRHYnI0R2TyRxUWdPJyNEUk8lZ1FkTycjRFVPJW5RZ08nI0RVTyZST2FPJyNEW09PUVInI0R1JyNEdU8me1FnTycjRF5PJ3JRZ08nI0RgT09RUicjRHQnI0R0TyhpT3FPJyNEYk9PUVAnI0RqJyNEak8oelFhTycjQ21PKVlRZ08nI0NtT09RUCcjQ20nI0NtUSlqUWFPT1EpdVFnT09RXVFnT09PKlBRZE8nI0NyTypuUWRPJyNDdE9PUU8nI0R3JyNEd08rXVFgTycjQ3hPK2hRZE8nI0N3TytyUWBPJyNDd09PUU8nI0N2JyNDdk8rd1FkTycjQ3ZPT1FPJyNDcScjQ3FPLFVRYE8sNTlbTyxeUWZPLDU5W09PUVIsNTlbLDU5W09PUU8nI0N4JyNDeE8sZVFgTycjRFBPLHBRZE8nI0RQT09RTycjRHgnI0R4Tyx6UWRPJyNEeE8tWFFgTyw1OWpPLWFRZk8sNTlqT09RUiw1OWosNTlqT09RUicjRFMnI0RTTy1oUWNPLDU5bU8tc1FnTycjRFZPLlRRYE8nI0RWTy5ZUWNPLDU5cE9PUVInI0RYJyNEWE8jfFFmTycjRFdPLmhRY08nI0RXT09RUiw1OXYsNTl2Ty55T1dPLDU5dk8vT09hTyw1OXZPL1dPYU8sNTl2Ty9jUWdPJyNEX09PUVIsNTl4LDU5eE8wVlFnTycjRGFPT1FSLDU5eiw1OXpPT1FQLDU5fCw1OXxPMHlPYU8sNTl8TzFST2FPLDU5fE8xYU9xTyw1OXxPT1FQLUU3aC1FN2hPMW9RZ08sNTlYT09RUCw1OVgsNTlYTzJQUWFPJyNEZU8yX1FnTycjRGVPMm9RZ08nI0RrT09RUCcjRGsnI0RrUSlqUWFPT08zUFFkTycjQ3NPT1FPLDU5Xiw1OV5PM2tRZE8nI0N1T09RTyw1OWAsNTlgT09RTyw1OWMsNTljTzRWUWRPLDU5Y080YVFkTycjQ3pPNGtRYE8nI0N6T09RTyw1OWIsNTliT09RVSw1OlEsNTpRT09RUjFHLnYxRy52TzRwUWBPMUcudk9PUVUtRTdkLUU3ZE80eFFkTyw1OWtPT1FPLDU5ayw1OWtPNVNRZE8nI0RRTzVeUWBPJyNEUU9PUU8sNTpkLDU6ZE9PUVUsNTpSLDU6Uk9PUVIxRy9VMUcvVU81Y1FgTzFHL1VPT1FVLUU3ZS1FN2VPNWtRZ08nI0RoTzV4UWNPMUcvWE9PUVIxRy9YMUcvWE9PUVIsNTlxLDU5cU82VFFnTyw1OXFPNmVRZE8nI0RpTzZsUWdPJyNEaU83UFFjTzFHL1tPT1FSMUcvWzFHL1tPT1FSLDU5ciw1OXJPI3xRZk8sNTlyT09RUjFHL2IxRy9iTzdfT1dPMUcvYk83ZE9hTzFHL2JPT1FSLDU5eSw1OXlPT1FSLDU5eyw1OXtPT1FQMUcvaDFHL2hPN2xPYU8xRy9oTzd0T2FPMUcvaE84UE9hTzFHL2hPT1FQMUcuczFHLnNPOF9RZ08sNTpQT09RUCw1OlAsNTpQT09RUCw1OlYsNTpWT09RUC1FN2ktRTdpT09RTyw1OV8sNTlfT09RTyw1OWEsNTlhT09RTzFHLn0xRy59T09RTyw1OWYsNTlmTzhvUWRPLDU5Zk9PUVI3KyRiNyskYlAsWFFgTycjRGZPT1FPMUcvVjFHL1ZPT1FPLDU5bCw1OWxPOHlRZE8sNTlsT09RUjcrJHA3KyRwUDlUUWBPJyNEZ09PUVInI0RUJyNEVE9PUVIsNTpTLDU6U09PUVItRTdmLUU3Zk9PUVI3KyRzNyskc09PUVIxRy9dMUcvXU85WVFnTycjRFlPOWpRYE8nI0RZT09RUiw1OlQsNTpUTyN8UWZPJyNEWk85b1FjTycjRFpPT1FSLUU3Zy1FN2dPT1FSNyskdjcrJHZPT1FSMUcvXjFHL15PT1FSNyskfDcrJHxPOlFPV083KyR8T09RUDcrJVM3KyVTTzpWT2FPNyslU086X09hTzcrJVNPT1FQMUcvazFHL2tPT1FPMUcvUTFHL1FPT1FPMUcvVzFHL1dPT1FSLDU5dCw1OXRPOmpRZ08sNTl0T09RUiw1OXUsNTl1TyN8UWZPLDU5dU9PUVI8PEhoPDxIaE9PUVA8PEhuPDxIbk86ek9hTzw8SG5PT1FSMUcvYDFHL2BPT1FSMUcvYTFHL2FPT1FQQU4+WUFOPllcIixcbiAgc3RhdGVEYXRhOiBcIjtTfk8hZk9TIWdPU15PU35PUF9PUWJPUlNPVFVPV1JPWFJPWVlPWlpPW1hPY1BPcVFPIVBWTyFWW08hY1RPfk9gY09+UF1PVmtPV1JPWFJPWWVPWmZPW2RPY1BPbWhPcVFPfk9ib09+UCFiT1Z0T1dST1hST1llT1pmT1tkT2NQT21yT3FRT35PcHdPflAjV09SU09UVU9XUk9YUk9ZWU9aWk9bWE9jUE9xUU8hUFZPIWNUT35PU3ZQIWF2UCFidlB+UCN8T1dST1hST1llT1pmT1tkT2NQT3FRT35PbXpPflAlT09tIU9PVXpQIWF6UCFielAhZHpQflAjfE9eIVNPIWIhUU8hZiFUTyFnIVJPfk9SU09UVU9XUk9YUk9jUE9xUU8hUFZPIWNUT35PWSFVT1AhUVhRIVFYIVYhUVghYCFRWFMhUVghYSFRWCFiIVFYVSFRWG0hUVghZCFRWH5QJmFPWyFXT1AhU1hRIVNYIVYhU1ghYCFTWFMhU1ghYSFTWCFiIVNYVSFTWG0hU1ghZCFTWH5QJmFPXiFaTyFXIVtPIWIhWU8hZiFdTyFnIVlPfk9QIV9PIVZbT1FhWCFgYVh+T1BhWFFhWCFWYVghYGFYflAjfE9QIWJPUSFjTyFWW09+T1BfTyFWW09+UCN8T1dST1hST1khZk9jUE9xUU9iZlhtZlhvZlhwZlh+T1dST1hST1shaE9jUE9xUU9iaFhtaFhvaFhwaFh+T2JlWG1sWG9lWH5PYmtYb2tYflAlT09tIWtPfk9tIWxPYm5Qb25QflAlT09iIXBPbyFvT35PYiFwT35QIWJPbSFzT29zWHBzWH5Pb3NYcHNYflAlT09tIXVPb3RQcHRQflAlT09vIXhPcCF5T35PcCF5T35QI1dPUyF8TyFhI09PIWIjT09+T1V5WCFheVghYnlYIWR5WH5QI3xPbSNRT35PVSNTTyFhI1VPIWIjVU8hZCNST35PbSNXT1V6WCFhelghYnpYIWR6WH5PXSNYT35PIWIjWE8hZyNZT35PXiNaTyFiI1hPIWcjWU9+T1AhUlhRIVJYIVYhUlghYCFSWFMhUlghYSFSWCFiIVJYVSFSWG0hUlghZCFSWH5QJmFPUCFUWFEhVFghViFUWCFgIVRYUyFUWCFhIVRYIWIhVFhVIVRYbSFUWCFkIVRYflAmYU8hYiNeTyFnI15Pfk9eI19PIWIjXk8hZiNgTyFnI15Pfk9eI19PIVcjYU8hYiNeTyFnI15Pfk9QYWFRYWEhVmFhIWBhYX5QI3xPUCNjTyFWW09RIVhYIWAhWFh+T1AhWFhRIVhYIVYhWFghYCFYWH5QI3xPUF9PIVZbT1EhX1ghYCFfWH5QI3xPV1JPWFJPY1BPcVFPYmdYbWdYb2dYcGdYfk9XUk9YUk9jUE9xUU9iaVhtaVhvaVhwaVh+T2JrYW9rYX5QJU9PYm5Yb25YflAlT09tI2tPfk9iI2xPbyFvT35Pb3NhcHNhflAlT09vdFhwdFh+UCVPT20jcE9+T28heE9wI3FPfk9Td1AhYXdQIWJ3UH5QI3xPUyF8TyFhI3ZPIWIjdk9+T1V5YSFheWEhYnlhIWR5YX5QI3xPbSN4T35QJU9PbSN7T1V9UCFhfVAhYn1QIWR9UH5QI3xPVSNTTyFhJE9PIWIkT08hZCNST35PXSRRT35PIWIkUU8hZyRST35PIWIkU08hZyRTT35PXiRUTyFiJFNPIWckU09+T14kVE8hYiRTTyFmJFVPIWckU09+T1AhWGFRIVhhIVYhWGEhYCFYYX5QI3xPYm5hb25hflAlT09vdGFwdGF+UCVPT28heE9+T1V8WCFhfFghYnxYIWR8WH5QI3xPbSRaT35PbSRdT1V9WCFhfVghYn1YIWR9WH5PXSReT35PIWIkX08hZyRfT35PXiRgTyFiJF9PIWckX09+T1V8YSFhfGEhYnxhIWR8YX5QI3xPIWIkY08hZyRjT35PXCIsXG4gIGdvdG86IFwiLF0hbVBQUFBQUFBQUFBQUFBQUFBQIW5QUCF2I3YjfCRgI3wkYyRmJGokblAlVlBQUCF2JVklXiVhJXsmTyVhJlImVSZYJl8mYiVhUCZlJnsmZSdPJ1JQUCddJ2EnZydtJ3MneShYUFBQUFBQUFAoXyllKlgrYyxWVWFPYmNSI2UhYyF7Uk9QUVNUVVhZX2JjZGVoa25ydHZ6IU8hVSFXIV8hYiFjIWYhaCFrIWwhcyF1IXwjUSNSI1MjVyNjI2sjcCN4I3skWiRdUW1QUiFxbnFmUFFUaGtucnR2IWshbCFzIXUjUiNrI3BSIWdkUiFpZVRsUG5UalBuU2lQblNxUXZRe1RRIW1rUSF0clEhdnRSI3kjUlIhbmtUc1F2UiF3dCFSV09TVVhZX2JjeiFPIVUhVyFfIWIhYyF8I1EjUyNXI2MjeCN7JFokXVJ5U1IjdCF8UnxUUnxVUSFQVVIjfCNTUiN6I1JSI3ojU3laT1NVX2JjeiFPIV8hYiFjIXwjUSNTI1cjYyN4I3skWiRdUiFWWFIhWFlhXU9eYWJjIWEhYyFlVCFkYSFlUW5QUiFyblF2UVIhe3ZRIX15UiN1IX1RI1R8UiN9I1RXXk9iYyFjUyFeXiFhVCFhYSFlUSFlYVIjZiFlV2BPYmMhY1F4U1N9VSNTUSFgX1EjUHpRI1YhT1EjYiFfUSNkIWJRI3MhfFEjdyNRUSRQI1dRJFYjY1EkWSN4USRbI3tRJGEkWlIkYiRdeFpPU1VfYmN6IU8hXyFiIWMhfCNRI1MjVyNjI3gjeyRaJF1RIVZYUSFYWVEjWyFVUiNdIVchUVdPU1VYWV9iY3ohTyFVIVchXyFiIWMhfCNRI1MjVyNjI3gjeyRaJF1wZlBRVGhrbnJ0diFrIWwhcyF1I1IjayNwUSFnZFEhaWVRI2chZlIjaCFoU2dQbl5wUVRrcnR2I1JRIWpoUSNpIWtRI2ohbFEjbiFzUSNvIXVRJFcja1IkWCNwUXVRUiF6dlwiLFxuICBub2RlTmFtZXM6IFwi4pqgIERpcmVjdGl2ZUVuZCBEb2NFbmQgLSAtID8gPyA/IExpdGVyYWwgUXVvdGVkTGl0ZXJhbCBBbmNob3IgQWxpYXMgVGFnIEJsb2NrTGl0ZXJhbENvbnRlbnQgQ29tbWVudCBTdHJlYW0gQk9NIERvY3VtZW50IF0gWyBGbG93U2VxdWVuY2UgSXRlbSBUYWdnZWQgQW5jaG9yZWQgQW5jaG9yZWQgVGFnZ2VkIEZsb3dNYXBwaW5nIFBhaXIgS2V5IDogUGFpciAsIH0geyBGbG93TWFwcGluZyBQYWlyIFBhaXIgQmxvY2tTZXF1ZW5jZSBJdGVtIEl0ZW0gQmxvY2tNYXBwaW5nIFBhaXIgUGFpciBLZXkgUGFpciBQYWlyIEJsb2NrTGl0ZXJhbCBCbG9ja0xpdGVyYWxIZWFkZXIgVGFnZ2VkIEFuY2hvcmVkIEFuY2hvcmVkIFRhZ2dlZCBEaXJlY3RpdmUgRGlyZWN0aXZlTmFtZSBEaXJlY3RpdmVDb250ZW50IERvY3VtZW50XCIsXG4gIG1heFRlcm06IDc0LFxuICBjb250ZXh0OiBXSSxcbiAgbm9kZVByb3BzOiBbXG4gICAgW1wiaXNvbGF0ZVwiLCAtMywgOCwgOSwgMTQsIFwiXCJdLFxuICAgIFtcIm9wZW5lZEJ5XCIsIDE4LCBcIltcIiwgMzIsIFwie1wiXSxcbiAgICBbXCJjbG9zZWRCeVwiLCAxOSwgXCJdXCIsIDMzLCBcIn1cIl1cbiAgXSxcbiAgcHJvcFNvdXJjZXM6IFtZSV0sXG4gIHNraXBwZWROb2RlczogWzBdLFxuICByZXBlYXROb2RlQ291bnQ6IDYsXG4gIHRva2VuRGF0YTogXCItWX5Sbk9YI1BYWSRRWVokXVpdI1BdXiRdXnAjUHBxJFFxcyNQc3QkYnR1I1B1diR5dnwjUHx9JmV9IVsjUCFbIV0nTyFdIWAjUCFgIWEnaSFhIX0jUCF9I08qZyNPI1AjUCNQI1ErUSNRI28jUCNvI3ArayNwI3EnaSNxI3IsVSNyOydTI1A7J1M7PWAjejwlbD9IVCNQP0hUP0hVLG8/SFVPI1BRI1VVIVdRT1kjUFpwI1BwcSNocTsnUyNQOydTOz1gI3o8JWxPI1BRI2tUT1kjUFpzI1B0OydTI1A7J1M7PWAjejwlbE8jUFEjfVA7PWA8JWwjUH4kVlEhZn5YWSRRcHEkUX4kYk8hZ35+JGdTXn5PWSRiWjsnUyRiOydTOz1gJHM8JWxPJGJ+JHZQOz1gPCVsJGJSJU9YIVdRT1gla1hZI1BaXSVrXV4jUF5wJWtwcSNocTsnUyVrOydTOz1gJl88JWxPJWtSJXJYIVdRIVZQT1gla1hZI1BaXSVrXV4jUF5wJWtwcSNocTsnUyVrOydTOz1gJl88JWxPJWtSJmJQOz1gPCVsJWtSJmxVb1AhV1FPWSNQWnAjUHBxI2hxOydTI1A7J1M7PWAjejwlbE8jUFInVlVtUCFXUU9ZI1BacCNQcHEjaHE7J1MjUDsnUzs9YCN6PCVsTyNQUidwWyFQUCFXUU9ZI1BacCNQcHEjaHF7I1B7fChmfH0jUH0hTyhmIU8hUiNQIVIhWylwIVs7J1MjUDsnUzs9YCN6PCVsTyNQUihtVyFQUCFXUU9ZI1BacCNQcHEjaHEhUiNQIVIhWylWIVs7J1MjUDsnUzs9YCN6PCVsTyNQUileVSFQUCFXUU9ZI1BacCNQcHEjaHE7J1MjUDsnUzs9YCN6PCVsTyNQUil3WSFQUCFXUU9ZI1BacCNQcHEjaHF7I1B7fClWfH0jUH0hTylWIU87J1MjUDsnUzs9YCN6PCVsTyNQUipuVWNQIVdRT1kjUFpwI1BwcSNocTsnUyNQOydTOz1gI3o8JWxPI1BSK1hVYlAhV1FPWSNQWnAjUHBxI2hxOydTI1A7J1M7PWAjejwlbE8jUFIrclVxUCFXUU9ZI1BacCNQcHEjaHE7J1MjUDsnUzs9YCN6PCVsTyNQUixdVXBQIVdRT1kjUFpwI1BwcSNocTsnUyNQOydTOz1gI3o8JWxPI1BSLHZVYFAhV1FPWSNQWnAjUHBxI2hxOydTI1A7J1M7PWAjejwlbE8jUFwiLFxuICB0b2tlbml6ZXJzOiBbTUksIFhJLCBVSSwgcUksIDAsIDFdLFxuICB0b3BSdWxlczogeyBTdHJlYW06IFswLCAxNV0gfSxcbiAgdG9rZW5QcmVjOiAwXG59KSwgSEkgPSAvKiBAX19QVVJFX18gKi8gY3MuZGVmaW5lKHtcbiAgbmFtZTogXCJ5YW1sXCIsXG4gIHBhcnNlcjogLyogQF9fUFVSRV9fICovIHpJLmNvbmZpZ3VyZSh7XG4gICAgcHJvcHM6IFtcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBzYS5hZGQoe1xuICAgICAgICBTdHJlYW06ICh0KSA9PiB7XG4gICAgICAgICAgZm9yIChsZXQgZSA9IHQubm9kZS5yZXNvbHZlKHQucG9zLCAtMSk7IGUgJiYgZS50byA+PSB0LnBvczsgZSA9IGUucGFyZW50KSB7XG4gICAgICAgICAgICBpZiAoZS5uYW1lID09IFwiQmxvY2tMaXRlcmFsQ29udGVudFwiICYmIGUuZnJvbSA8IGUudG8pXG4gICAgICAgICAgICAgIHJldHVybiB0LmJhc2VJbmRlbnRGb3IoZSk7XG4gICAgICAgICAgICBpZiAoZS5uYW1lID09IFwiQmxvY2tMaXRlcmFsXCIpXG4gICAgICAgICAgICAgIHJldHVybiB0LmJhc2VJbmRlbnRGb3IoZSkgKyB0LnVuaXQ7XG4gICAgICAgICAgICBpZiAoZS5uYW1lID09IFwiQmxvY2tTZXF1ZW5jZVwiIHx8IGUubmFtZSA9PSBcIkJsb2NrTWFwcGluZ1wiKVxuICAgICAgICAgICAgICByZXR1cm4gdC5jb2x1bW4oZS5mcm9tLCAxKTtcbiAgICAgICAgICAgIGlmIChlLm5hbWUgPT0gXCJRdW90ZWRMaXRlcmFsXCIpXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgaWYgKGUubmFtZSA9PSBcIkxpdGVyYWxcIikge1xuICAgICAgICAgICAgICBsZXQgbiA9IHQuY29sdW1uKGUuZnJvbSwgMSk7XG4gICAgICAgICAgICAgIGlmIChuID09IHQubGluZUluZGVudChlLmZyb20sIDEpKVxuICAgICAgICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICAgICAgICBpZiAoZS50byA+IHQucG9zKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgRmxvd01hcHBpbmc6IC8qIEBfX1BVUkVfXyAqLyB4cCh7IGNsb3Npbmc6IFwifVwiIH0pLFxuICAgICAgICBGbG93U2VxdWVuY2U6IC8qIEBfX1BVUkVfXyAqLyB4cCh7IGNsb3Npbmc6IFwiXVwiIH0pXG4gICAgICB9KSxcbiAgICAgIC8qIEBfX1BVUkVfXyAqLyBLbC5hZGQoe1xuICAgICAgICBcIkZsb3dNYXBwaW5nIEZsb3dTZXF1ZW5jZVwiOiBIZCxcbiAgICAgICAgXCJCbG9ja1NlcXVlbmNlIEJsb2NrTWFwcGluZyBCbG9ja0xpdGVyYWxcIjogKHQsIGUpID0+ICh7IGZyb206IGUuZG9jLmxpbmVBdCh0LmZyb20pLnRvLCB0bzogdC50byB9KVxuICAgICAgfSlcbiAgICBdXG4gIH0pLFxuICBsYW5ndWFnZURhdGE6IHtcbiAgICBjb21tZW50VG9rZW5zOiB7IGxpbmU6IFwiI1wiIH0sXG4gICAgaW5kZW50T25JbnB1dDogL15cXHMqW1xcXVxcfV0kL1xuICB9XG59KTtcbmZ1bmN0aW9uIEZJKCkge1xuICByZXR1cm4gbmV3IEdsKEhJKTtcbn1cbnZhciBHSSA9ICh0KSA9PiB7XG4gIHZhciB7XG4gICAgdGhlbWU6IGUsXG4gICAgc2V0dGluZ3M6IG4gPSB7fSxcbiAgICBzdHlsZXM6IHIgPSBbXVxuICB9ID0gdCwgaSA9IHtcbiAgICBcIi5jbS1ndXR0ZXJzXCI6IHt9XG4gIH0sIHMgPSB7fTtcbiAgbi5iYWNrZ3JvdW5kICYmIChzLmJhY2tncm91bmRDb2xvciA9IG4uYmFja2dyb3VuZCksIG4uYmFja2dyb3VuZEltYWdlICYmIChzLmJhY2tncm91bmRJbWFnZSA9IG4uYmFja2dyb3VuZEltYWdlKSwgbi5mb3JlZ3JvdW5kICYmIChzLmNvbG9yID0gbi5mb3JlZ3JvdW5kKSwgKG4uYmFja2dyb3VuZCB8fCBuLmZvcmVncm91bmQpICYmIChpW1wiJlwiXSA9IHMpLCBuLmZvbnRGYW1pbHkgJiYgKGlbXCImLmNtLWVkaXRvciAuY20tc2Nyb2xsZXJcIl0gPSB7XG4gICAgZm9udEZhbWlseTogbi5mb250RmFtaWx5XG4gIH0pLCBuLmd1dHRlckJhY2tncm91bmQgJiYgKGlbXCIuY20tZ3V0dGVyc1wiXS5iYWNrZ3JvdW5kQ29sb3IgPSBuLmd1dHRlckJhY2tncm91bmQpLCBuLmd1dHRlckZvcmVncm91bmQgJiYgKGlbXCIuY20tZ3V0dGVyc1wiXS5jb2xvciA9IG4uZ3V0dGVyRm9yZWdyb3VuZCksIG4uZ3V0dGVyQm9yZGVyICYmIChpW1wiLmNtLWd1dHRlcnNcIl0uYm9yZGVyUmlnaHRDb2xvciA9IG4uZ3V0dGVyQm9yZGVyKSwgbi5jYXJldCAmJiAoaVtcIi5jbS1jb250ZW50XCJdID0ge1xuICAgIGNhcmV0Q29sb3I6IG4uY2FyZXRcbiAgfSwgaVtcIi5jbS1jdXJzb3IsIC5jbS1kcm9wQ3Vyc29yXCJdID0ge1xuICAgIGJvcmRlckxlZnRDb2xvcjogbi5jYXJldFxuICB9KTtcbiAgdmFyIG8gPSB7fTtcbiAgbi5ndXR0ZXJBY3RpdmVGb3JlZ3JvdW5kICYmIChvLmNvbG9yID0gbi5ndXR0ZXJBY3RpdmVGb3JlZ3JvdW5kKSwgbi5saW5lSGlnaGxpZ2h0ICYmIChpW1wiLmNtLWFjdGl2ZUxpbmVcIl0gPSB7XG4gICAgYmFja2dyb3VuZENvbG9yOiBuLmxpbmVIaWdobGlnaHRcbiAgfSwgby5iYWNrZ3JvdW5kQ29sb3IgPSBuLmxpbmVIaWdobGlnaHQpLCBpW1wiLmNtLWFjdGl2ZUxpbmVHdXR0ZXJcIl0gPSBvLCBuLnNlbGVjdGlvbiAmJiAoaVtcIiYuY20tZm9jdXNlZCAuY20tc2VsZWN0aW9uQmFja2dyb3VuZCwgJiAuY20tbGluZTo6c2VsZWN0aW9uLCAmIC5jbS1zZWxlY3Rpb25MYXllciAuY20tc2VsZWN0aW9uQmFja2dyb3VuZCwgLmNtLWNvbnRlbnQgOjpzZWxlY3Rpb25cIl0gPSB7XG4gICAgYmFja2dyb3VuZDogbi5zZWxlY3Rpb24gKyBcIiAhaW1wb3J0YW50XCJcbiAgfSksIG4uc2VsZWN0aW9uTWF0Y2ggJiYgKGlbXCImIC5jbS1zZWxlY3Rpb25NYXRjaFwiXSA9IHtcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IG4uc2VsZWN0aW9uTWF0Y2hcbiAgfSk7XG4gIHZhciBhID0gU2UudGhlbWUoaSwge1xuICAgIGRhcms6IGUgPT09IFwiZGFya1wiXG4gIH0pLCBsID0gSmwuZGVmaW5lKHIpLCBjID0gW2EsIGh4KGwpXTtcbiAgcmV0dXJuIGM7XG59O1xuY29uc3QgS0kgPSBHSSh7XG4gIHRoZW1lOiBcImxpZ2h0XCIsXG4gIHNldHRpbmdzOiB7XG4gICAgYmFja2dyb3VuZDogXCJ2YXIoLS1zY2FsYXItYmFja2dyb3VuZC0yKVwiLFxuICAgIGZvcmVncm91bmQ6IFwidmFyKC0tc2NhbGFyLWNvbG9yLTEpXCIsXG4gICAgY2FyZXQ6IFwidmFyKC0tc2NhbGFyLWNvbG9yLTEpXCIsXG4gICAgLy8gU2VsZWN0aW9uIGxpa2VseSBuZWVkcyBhIGhhcmRjb2RlZCBjb2xvciBkdWUgdG8gaXQgbm90IGFjY2VwdGluZyB2YXJpYWJsZXNcbiAgICBzZWxlY3Rpb246IFwicmdiYSgxNTEsIDE4MywgMjA1LCAwLjIpXCIsXG4gICAgc2VsZWN0aW9uTWF0Y2g6IFwiI2UzZGNjZVwiLFxuICAgIGd1dHRlckJhY2tncm91bmQ6IFwidmFyKC0tc2NhbGFyLWJhY2tncm91bmQtMilcIixcbiAgICBndXR0ZXJGb3JlZ3JvdW5kOiBcInZhcigtLXNjYWxhci1jb2xvci0zKVwiLFxuICAgIGd1dHRlckJvcmRlcjogXCJ0cmFuc3BhcmVudFwiLFxuICAgIGxpbmVIaWdobGlnaHQ6IFwidmFyKC0tc2NhbGFyLWJhY2tncm91bmQtMylcIixcbiAgICBmb250RmFtaWx5OiBcInZhcigtLXNjYWxhci1mb250LWNvZGUpXCJcbiAgfSxcbiAgc3R5bGVzOiBbXG4gICAge1xuICAgICAgdGFnOiBbUC5zdGFuZGFyZChQLnRhZ05hbWUpLCBQLnRhZ05hbWVdLFxuICAgICAgY29sb3I6IFwidmFyKC0tc2NhbGFyLWNvbG9yLXB1cnBsZSlcIlxuICAgIH0sXG4gICAge1xuICAgICAgdGFnOiBbUC5jb21tZW50XSxcbiAgICAgIGNvbG9yOiBcInZhcigtLXNjYWxhci1jb2xvci0zKVwiXG4gICAgfSxcbiAgICB7XG4gICAgICB0YWc6IFtQLmNsYXNzTmFtZV0sXG4gICAgICBjb2xvcjogXCJ2YXIoLS1zY2FsYXItY29sb3Itb3JhbmdlKVwiXG4gICAgfSxcbiAgICB7XG4gICAgICB0YWc6IFtQLnZhcmlhYmxlTmFtZSwgUC5wcm9wZXJ0eU5hbWUsIFAuYXR0cmlidXRlTmFtZV0sXG4gICAgICBjb2xvcjogXCJ2YXIoLS1zY2FsYXItY29sb3ItMSlcIlxuICAgIH0sXG4gICAge1xuICAgICAgdGFnOiBbUC5vcGVyYXRvcl0sXG4gICAgICBjb2xvcjogXCJ2YXIoLS1zY2FsYXItY29sb3ItMilcIlxuICAgIH0sXG4gICAge1xuICAgICAgdGFnOiBbUC5rZXl3b3JkLCBQLnR5cGVOYW1lLCBQLnR5cGVPcGVyYXRvcl0sXG4gICAgICBjb2xvcjogXCJ2YXIoLS1zY2FsYXItY29sb3ItZ3JlZW4pXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIHRhZzogW1Auc3RyaW5nXSxcbiAgICAgIGNvbG9yOiBcInZhcigtLXNjYWxhci1jb2xvci1ibHVlKVwiXG4gICAgfSxcbiAgICB7XG4gICAgICB0YWc6IFtQLmJyYWNrZXQsIFAucmVnZXhwLCBQLm1ldGFdLFxuICAgICAgY29sb3I6IFwidmFyKC0tc2NhbGFyLWNvbG9yLTMpXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIHRhZzogW1AubnVtYmVyXSxcbiAgICAgIGNvbG9yOiBcInZhcigtLXNjYWxhci1jb2xvci1ibHVlKVwiXG4gICAgfSxcbiAgICB7XG4gICAgICB0YWc6IFtQLm5hbWUsIFAucXVvdGVdLFxuICAgICAgY29sb3I6IFwidmFyKC0tc2NhbGFyLWNvbG9yLTMpXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIHRhZzogW1AuaGVhZGluZ10sXG4gICAgICBjb2xvcjogXCJ2YXIoLS1zY2FsYXItY29sb3ItMylcIixcbiAgICAgIGZvbnRXZWlnaHQ6IFwiYm9sZFwiXG4gICAgfSxcbiAgICB7XG4gICAgICB0YWc6IFtQLmVtcGhhc2lzXSxcbiAgICAgIGNvbG9yOiBcInZhcigtLXNjYWxhci1jb2xvci0zKVwiLFxuICAgICAgZm9udFN0eWxlOiBcIml0YWxpY1wiXG4gICAgfSxcbiAgICB7XG4gICAgICB0YWc6IFtQLmRlbGV0ZWRdLFxuICAgICAgY29sb3I6IFwidmFyKC0tc2NhbGFyLWNvbG9yLTMpXCIsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IFwidHJhbnNwYXJlbnRcIlxuICAgIH0sXG4gICAge1xuICAgICAgdGFnOiBbUC5hdG9tLCBQLmJvb2wsIFAuc3BlY2lhbChQLnZhcmlhYmxlTmFtZSldLFxuICAgICAgY29sb3I6IFwidmFyKC0tc2NhbGFyLWNvbG9yLTMpXCJcbiAgICB9LFxuICAgIHtcbiAgICAgIHRhZzogW1AudXJsLCBQLmVzY2FwZSwgUC5yZWdleHAsIFAubGlua10sXG4gICAgICBjb2xvcjogXCJ2YXIoLS1zY2FsYXItY29sb3ItMSlcIlxuICAgIH0sXG4gICAgeyB0YWc6IFAubGluaywgdGV4dERlY29yYXRpb246IFwidW5kZXJsaW5lXCIgfSxcbiAgICB7IHRhZzogUC5zdHJpa2V0aHJvdWdoLCB0ZXh0RGVjb3JhdGlvbjogXCJsaW5lLXRocm91Z2hcIiB9LFxuICAgIHtcbiAgICAgIHRhZzogUC5pbnZhbGlkLFxuICAgICAgY29sb3I6IFwidmFyKC0tc2NhbGFyLWNvbG9yLTMpXCJcbiAgICB9XG4gIF1cbn0pLCBDMCA9IG5ldyBVayh7XG4gIHJlZ2V4cDogLyhcXHtbXn1dK1xcfSkvZyxcbiAgZGVjb3JhdGlvbjogKCkgPT4gSmUubWFyayh7XG4gICAgYXR0cmlidXRlczoge1xuICAgICAgY2xhc3M6IFwiYXBpLWNsaWVudC11cmwtdmFyaWFibGVcIlxuICAgIH1cbiAgfSlcbn0pLCBKSSA9ICgpID0+IHJyLmZyb21DbGFzcyhcbiAgY2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKHQpIHtcbiAgICAgIF93KHRoaXMsIFwidmFyaWFibGVzXCIpLCB0aGlzLnZhcmlhYmxlcyA9IEMwLmNyZWF0ZURlY28odCk7XG4gICAgfVxuICAgIHVwZGF0ZSh0KSB7XG4gICAgICB0aGlzLnZhcmlhYmxlcyA9IEMwLnVwZGF0ZURlY28oXG4gICAgICAgIHQsXG4gICAgICAgIHRoaXMudmFyaWFibGVzXG4gICAgICApO1xuICAgIH1cbiAgfSxcbiAge1xuICAgIGRlY29yYXRpb25zOiAodCkgPT4gdC52YXJpYWJsZXMsXG4gICAgcHJvdmlkZTogKHQpID0+IFNlLmF0b21pY1Jhbmdlcy5vZihcbiAgICAgIChlKSA9PiB7XG4gICAgICAgIHZhciBuO1xuICAgICAgICByZXR1cm4gKChuID0gZS5wbHVnaW4odCkpID09IG51bGwgPyB2b2lkIDAgOiBuLnZhcmlhYmxlcykgfHwgSmUubm9uZTtcbiAgICAgIH1cbiAgICApXG4gIH1cbiksIGFvID0gKHQpID0+IFwicHJvdmlkZXJcIiBpbiB0ICYmICEhSnQodC5wcm92aWRlciksIGVXID0ge1xuICBrZXk6IFwiTW9kLWFcIixcbiAgcnVuOiAodCkgPT4gKHQuZGlzcGF0Y2goe1xuICAgIHNlbGVjdGlvbjogeyBhbmNob3I6IDAsIGhlYWQ6IHQuc3RhdGUuZG9jLmxlbmd0aCB9LFxuICAgIHNjcm9sbEludG9WaWV3OiAhMVxuICB9KSwgITApXG59LCB0VyA9ICh0KSA9PiB7XG4gIGNvbnN0IGUgPSBHKG51bGwpO1xuICBodChcbiAgICB0LmNvZGVNaXJyb3JSZWYsXG4gICAgKCkgPT4ge1xuICAgICAgdmFyIHM7XG4gICAgICAocyA9IGUudmFsdWUpID09IG51bGwgfHwgcy5kZXN0cm95KCksIG4oKTtcbiAgICB9LFxuICAgIHsgaW1tZWRpYXRlOiAhMCB9XG4gICksIElsKCgpID0+IHtcbiAgICB2YXIgcztcbiAgICByZXR1cm4gKHMgPSBlLnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogcy5kZXN0cm95KCk7XG4gIH0pO1xuICBmdW5jdGlvbiBuKCkge1xuICAgIGlmICh0LmNvZGVNaXJyb3JSZWYudmFsdWUpIHtcbiAgICAgIGNvbnN0IHMgPSBhbyh0KSA/IEp0KHQucHJvdmlkZXIpIDogbnVsbCwgbyA9IFIwKHtcbiAgICAgICAgLi4uci52YWx1ZSxcbiAgICAgICAgcHJvdmlkZXI6IHNcbiAgICAgIH0pO1xuICAgICAgZS52YWx1ZSA9IG5ldyBTZSh7XG4gICAgICAgIHBhcmVudDogdC5jb2RlTWlycm9yUmVmLnZhbHVlLFxuICAgICAgICBleHRlbnNpb25zOiBvXG4gICAgICB9KSwgYW8odCkgfHwgaShKdCh0LmNvbnRlbnQpKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgciA9IGooKCkgPT4gKHtcbiAgICBvbkNoYW5nZTogdC5vbkNoYW5nZSxcbiAgICBvbkJsdXI6IHQub25CbHVyLFxuICAgIG9uRm9jdXM6IHQub25Gb2N1cyxcbiAgICBsYW5ndWFnZTogSnQodC5sYW5ndWFnZSksXG4gICAgY2xhc3NlczogSnQodC5jbGFzc2VzKSxcbiAgICByZWFkT25seTogSnQodC5yZWFkT25seSksXG4gICAgbGluZU51bWJlcnM6IEp0KHQubGluZU51bWJlcnMpLFxuICAgIHdpdGhWYXJpYWJsZXM6IEp0KHQud2l0aFZhcmlhYmxlcyksXG4gICAgZGlzYWJsZUVudGVyOiBKdCh0LndpdGhWYXJpYWJsZXMpLFxuICAgIHdpdGhvdXRUaGVtZTogSnQodC53aXRob3V0VGhlbWUpLFxuICAgIGFkZGl0aW9uYWxFeHRlbnNpb25zOiBKdCh0LmV4dGVuc2lvbnMpXG4gIH0pKTtcbiAgaHQoXG4gICAgKCkgPT4gYW8odCkgPyBKdCh0LnByb3ZpZGVyKSA6IG51bGwsXG4gICAgKCkgPT4ge1xuICAgICAgdmFyIHM7XG4gICAgICBhbyh0KSAmJiAoKHMgPSBlLnZhbHVlKSA9PSBudWxsIHx8IHMuZGVzdHJveSgpLCBuKCkpO1xuICAgIH1cbiAgKSwgaHQoXG4gICAgcixcbiAgICAoKSA9PiB7XG4gICAgICBpZiAoZS52YWx1ZSkge1xuICAgICAgICBjb25zdCBzID0gYW8odCkgPyBKdCh0LnByb3ZpZGVyKSA6IG51bGwsIG8gPSBSMCh7XG4gICAgICAgICAgLi4uci52YWx1ZSxcbiAgICAgICAgICBwcm92aWRlcjogc1xuICAgICAgICB9KTtcbiAgICAgICAgZS52YWx1ZS5kaXNwYXRjaCh7XG4gICAgICAgICAgZWZmZWN0czogb3QucmVjb25maWd1cmUub2YobylcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG4gICAgeyBpbW1lZGlhdGU6ICEwIH1cbiAgKTtcbiAgY29uc3QgaSA9IChzID0gXCJcIikgPT4ge1xuICAgIGUudmFsdWUgJiYgZS52YWx1ZS5zdGF0ZS5kb2MudG9TdHJpbmcoKSAhPT0gcyAmJiBlLnZhbHVlLmRpc3BhdGNoKHtcbiAgICAgIGNoYW5nZXM6IHtcbiAgICAgICAgZnJvbTogMCxcbiAgICAgICAgdG86IGUudmFsdWUuc3RhdGUuZG9jLmxlbmd0aCxcbiAgICAgICAgaW5zZXJ0OiBzXG4gICAgICB9LFxuICAgICAgc2VsZWN0aW9uOiB7XG4gICAgICAgIGFuY2hvcjogTWF0aC5taW4oXG4gICAgICAgICAgZS52YWx1ZS5zdGF0ZS5zZWxlY3Rpb24ubWFpbi5hbmNob3IsXG4gICAgICAgICAgcy5sZW5ndGhcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICByZXR1cm4gaHQoXG4gICAgKCkgPT4gSnQodC5jb250ZW50KSxcbiAgICAoKSA9PiB7XG4gICAgICBhbyh0KSB8fCBpKEp0KHQuY29udGVudCkpO1xuICAgIH0sXG4gICAgeyBpbW1lZGlhdGU6ICEwIH1cbiAgKSwge1xuICAgIC8qKiBSZXBsYWNlcyB0aGUgY3VycmVudCBjb250ZW50IHdpdGggdGhlIGdpdmVuIHZhbHVlLiAqL1xuICAgIHNldENvZGVNaXJyb3JDb250ZW50OiBpLFxuICAgIC8qKiBDb2RlbWlycm9yIGluc3RhbmNlICovXG4gICAgY29kZU1pcnJvcjogZVxuICB9O1xufSwgQTAgPSB7XG4gIGh0bWw6IE9JLFxuICBqc29uOiB5SSxcbiAgeWFtbDogRkksXG4gIGNzczogSXhcbn07XG5mdW5jdGlvbiBSMCh7XG4gIG9uQ2hhbmdlOiB0LFxuICBvbkJsdXI6IGUsXG4gIG9uRm9jdXM6IG4sXG4gIHByb3ZpZGVyOiByLFxuICBsYW5ndWFnZTogaSxcbiAgY2xhc3NlczogcyA9IFtdLFxuICByZWFkT25seTogbyA9ICExLFxuICBsaW5lTnVtYmVyczogYSA9ICExLFxuICB3aXRoVmFyaWFibGVzOiBsID0gITEsXG4gIGRpc2FibGVFbnRlcjogYyA9ICExLFxuICB3aXRob3V0VGhlbWU6IHUgPSAhMSxcbiAgYWRkaXRpb25hbEV4dGVuc2lvbnM6IGQgPSBbXVxufSkge1xuICBjb25zdCBmID0gW1xuICAgIHREKCksXG4gICAgaHgodFosIHsgZmFsbGJhY2s6ICEwIH0pLFxuICAgIFNlLnRoZW1lKHtcbiAgICAgIFwiLmNtLWxpbmVcIjoge1xuICAgICAgICBsaW5lSGVpZ2h0OiBcIjIwcHhcIlxuICAgICAgfSxcbiAgICAgIFwiLmNtLWd1dHRlckVsZW1lbnRcIjoge1xuICAgICAgICBsaW5lSGVpZ2h0OiBcIjIwcHhcIlxuICAgICAgfVxuICAgIH0pLFxuICAgIC8vIExpc3RlbiB0byB1cGRhdGVzXG4gICAgU2UudXBkYXRlTGlzdGVuZXIub2YoKGgpID0+IHtcbiAgICAgIGguZG9jQ2hhbmdlZCAmJiAodCA9PSBudWxsIHx8IHQoaC5zdGF0ZS5kb2MudG9TdHJpbmcoKSkpO1xuICAgIH0pLFxuICAgIFNlLmRvbUV2ZW50SGFuZGxlcnMoe1xuICAgICAgYmx1cjogKGgsIHApID0+IHtcbiAgICAgICAgZSA9PSBudWxsIHx8IGUocC5zdGF0ZS5kb2MudG9TdHJpbmcoKSk7XG4gICAgICB9LFxuICAgICAgZm9jdXM6IChoLCBwKSA9PiB7XG4gICAgICAgIG4gPT0gbnVsbCB8fCBuKHAuc3RhdGUuZG9jLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH0pLFxuICAgIC8vIEFkZCBDbGFzc2VzXG4gICAgU2UuZWRpdG9yQXR0cmlidXRlcy5vZih7IGNsYXNzOiBzLmpvaW4oXCIgXCIpIH0pLFxuICAgIC4uLmRcbiAgXTtcbiAgcmV0dXJuIHIgJiYgZi5wdXNoKHIpLCB1IHx8IGYucHVzaChLSSksIG8gPyBmLnB1c2goU2UuZWRpdGFibGUub2YoITEpKSA6IGYucHVzaChcbiAgICBLRCgpLFxuICAgIGxaKCksXG4gICAgc1YoKSxcbiAgICB6WigpLFxuICAgIGJsLm9mKFtcbiAgICAgIC4uLkN4LFxuICAgICAgLi4uS1osXG4gICAgICBjVixcbiAgICAgIGVXXG4gICAgXSlcbiAgKSwgaSAmJiBBMFtpXSAmJiBmLnB1c2goQTBbaV0oKSksIGEgJiYgZi5wdXNoKG1EKCkpLCBsICYmIGYucHVzaChKSSgpKSwgYyAmJiBmLnB1c2goXG4gICAgYmwub2YoW1xuICAgICAge1xuICAgICAgICBrZXk6IFwiRW50ZXJcIixcbiAgICAgICAgcnVuOiAoKSA9PiAhMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAga2V5OiBcIkN0cmwtRW50ZXJcIixcbiAgICAgICAgbWFjOiBcIkNtZC1FbnRlclwiLFxuICAgICAgICBydW46ICgpID0+ICEwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXk6IFwiU2hpZnQtRW50ZXJcIixcbiAgICAgICAgcnVuOiAoKSA9PiAhMFxuICAgICAgfVxuICAgIF0pXG4gICksIGY7XG59XG5jb25zdCBuVyA9IC8qIEBfX1BVUkVfXyAqLyBsZSh7XG4gIF9fbmFtZTogXCJDb2RlTWlycm9yXCIsXG4gIHByb3BzOiB7XG4gICAgY29udGVudDoge30sXG4gICAgcmVhZE9ubHk6IHsgdHlwZTogQm9vbGVhbiB9LFxuICAgIGxhbmd1YWdlOiB7fSxcbiAgICB3aXRoVmFyaWFibGVzOiB7IHR5cGU6IEJvb2xlYW4gfSxcbiAgICBsaW5lTnVtYmVyczogeyB0eXBlOiBCb29sZWFuIH0sXG4gICAgd2l0aG91dFRoZW1lOiB7IHR5cGU6IEJvb2xlYW4gfSxcbiAgICBkaXNhYmxlRW50ZXI6IHsgdHlwZTogQm9vbGVhbiwgZGVmYXVsdDogITEgfVxuICB9LFxuICBlbWl0czogW1wiY2hhbmdlXCJdLFxuICBzZXR1cCh0LCB7IGVtaXQ6IGUgfSkge1xuICAgIGNvbnN0IG4gPSB0LCByID0gZSwgaSA9IEcobnVsbCk7XG4gICAgcmV0dXJuIHRXKHtcbiAgICAgIGNvbnRlbnQ6IEVpKCgpID0+IG4uY29udGVudCksXG4gICAgICByZWFkT25seTogRWkoKCkgPT4gbi5yZWFkT25seSksXG4gICAgICBsYW5ndWFnZTogRWkoKCkgPT4gbi5sYW5ndWFnZSksXG4gICAgICB3aXRoVmFyaWFibGVzOiBFaSgoKSA9PiBuLndpdGhWYXJpYWJsZXMpLFxuICAgICAgbGluZU51bWJlcnM6IEVpKCgpID0+IG4ubGluZU51bWJlcnMpLFxuICAgICAgd2l0aG91dFRoZW1lOiBFaSgoKSA9PiBuLndpdGhvdXRUaGVtZSksXG4gICAgICBkaXNhYmxlRW50ZXI6IEVpKCgpID0+IG4uZGlzYWJsZUVudGVyKSxcbiAgICAgIG9uQ2hhbmdlOiAocykgPT4gcihcImNoYW5nZVwiLCBzIHx8IFwiXCIpLFxuICAgICAgY29kZU1pcnJvclJlZjogaSxcbiAgICAgIGNsYXNzZXM6IFtcImNvZGVtaXJyb3JcIl1cbiAgICB9KSwgKHMsIG8pID0+IChaKCksIG5lKFwiZGl2XCIsIHtcbiAgICAgIHJlZl9rZXk6IFwiY29kZU1pcnJvclJlZlwiLFxuICAgICAgcmVmOiBpLFxuICAgICAgY2xhc3M6IFwiY29kZW1pcnJvci1jb250YWluZXJcIlxuICAgIH0sIG51bGwsIDUxMikpO1xuICB9XG59KSwgU1AgPSAvKiBAX19QVVJFX18gKi8gY3QoblcsIFtbXCJfX3Njb3BlSWRcIiwgXCJkYXRhLXYtMGFiYWYyZDlcIl1dKSwgclcgPSB7IGNsYXNzOiBcInNjYWxhci1tb2RhbC1sYXlvdXQgbW9kYWwtbGF5b3V0XCIgfSwgaVcgPSAvKiBAX19QVVJFX18gKi8gbGUoe1xuICBfX25hbWU6IFwiRmxvd01vZGFsXCIsXG4gIHByb3BzOiB7XG4gICAgc3RhdGU6IHt9LFxuICAgIHRpdGxlOiB7fSxcbiAgICBib2R5Q2xhc3M6IHt9LFxuICAgIG1heFdpZHRoOiB7fSxcbiAgICB2YXJpYW50OiB7IGRlZmF1bHQ6IFwibm9ybWFsXCIgfVxuICB9LFxuICBzZXR1cCh0KSB7XG4gICAgcmV0dXJuIChlLCBuKSA9PiAoWigpLCBrZShSKGZDKSwge1xuICAgICAgb3BlbjogZS5zdGF0ZS5vcGVuLFxuICAgICAgb25DbG9zZTogblswXSB8fCAoblswXSA9IChyKSA9PiBlLnN0YXRlLmhpZGUoKSlcbiAgICB9LCB7XG4gICAgICBkZWZhdWx0OiBjZSgoKSA9PiBbXG4gICAgICAgIEQoXCJkaXZcIiwgclcsIFtcbiAgICAgICAgICBKKFIoaEMpLCB7XG4gICAgICAgICAgICBjbGFzczogS2UoW1wibW9kYWxcIiwge1xuICAgICAgICAgICAgICBcIm1vZGFsLWNvbnRlbnQtbGFyZ2VcIjogZS52YXJpYW50ID09PSBcImxhcmdlXCIsXG4gICAgICAgICAgICAgIFwibW9kYWwtY29udGVudC1ub3JtYWxcIjogZS52YXJpYW50ID09PSBcIm5vcm1hbFwiLFxuICAgICAgICAgICAgICBcIm1vZGFsLWNvbnRlbnQtc21hbGxcIjogZS52YXJpYW50ID09PSBcInNtYWxsXCIsXG4gICAgICAgICAgICAgIFwibW9kYWwtY29udGVudC1zZWFyY2hcIjogZS52YXJpYW50ID09PSBcInNlYXJjaFwiLFxuICAgICAgICAgICAgICBcIm1vZGFsLWNvbnRlbnQtaGlzdG9yeVwiOiBlLnZhcmlhbnQgPT09IFwiaGlzdG9yeVwiXG4gICAgICAgICAgICB9XSksXG4gICAgICAgICAgICBzdHlsZTogQnIoeyBtYXhXaWR0aDogZS5tYXhXaWR0aCB9KVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IGNlKCgpID0+IFtcbiAgICAgICAgICAgICAgZS50aXRsZSA/IChaKCksIGtlKFIocEMpLCB7XG4gICAgICAgICAgICAgICAga2V5OiAwLFxuICAgICAgICAgICAgICAgIGNsYXNzOiBcIm1vZGFsLWhlYWRlclwiXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBjZSgoKSA9PiBbXG4gICAgICAgICAgICAgICAgICBIZShEZShlLnRpdGxlKSwgMSlcbiAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICBfOiAxXG4gICAgICAgICAgICAgIH0pKSA6IHN0KFwiXCIsICEwKSxcbiAgICAgICAgICAgICAgSihSKE9DKSwge1xuICAgICAgICAgICAgICAgIGNsYXNzOiBLZShbXCJtb2RhbC1ib2R5IGN1c3RvbS1zY3JvbGxcIiwgW2UuYm9keUNsYXNzXV0pXG4gICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBjZSgoKSA9PiBbXG4gICAgICAgICAgICAgICAgICBwdChlLiRzbG90cywgXCJkZWZhdWx0XCIsIHt9LCB2b2lkIDAsICEwKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF86IDNcbiAgICAgICAgICAgICAgfSwgOCwgW1wiY2xhc3NcIl0pXG4gICAgICAgICAgICBdKSxcbiAgICAgICAgICAgIF86IDNcbiAgICAgICAgICB9LCA4LCBbXCJjbGFzc1wiLCBcInN0eWxlXCJdKVxuICAgICAgICBdKVxuICAgICAgXSksXG4gICAgICBfOiAzXG4gICAgfSwgOCwgW1wib3BlblwiXSkpO1xuICB9XG59KSwgc1cgPSAvKiBAX19QVVJFX18gKi8gY3QoaVcsIFtbXCJfX3Njb3BlSWRcIiwgXCJkYXRhLXYtNGFhZmJmNjhcIl1dKSwgb1cgPSAoKSA9PiBYbih7XG4gIG9wZW46ICExLFxuICBzaG93KCkge1xuICAgIHRoaXMub3BlbiA9ICEwO1xuICB9LFxuICBoaWRlKCkge1xuICAgIHRoaXMub3BlbiA9ICExO1xuICB9XG59KTtcbmZ1bmN0aW9uIGFXKCkge1xuICByZXR1cm4gdHlwZW9mIG5hdmlnYXRvciA8IFwidVwiID8gL01hYy8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pIDogITE7XG59XG5jb25zdCBsVyA9ICh0LCBlKSA9PiB7XG4gIGlmICh0eXBlb2YgZSAhPSBcInN0cmluZ1wiIHx8ICFlLmxlbmd0aClcbiAgICByZXR1cm4gdDtcbiAgY29uc3QgbiA9IHQuZW5kc1dpdGgoXCIvXCIpID8gdCA6IGAke3R9L2AsIHIgPSBlLnN0YXJ0c1dpdGgoXCIvXCIpID8gZS5zbGljZSgxKSA6IGU7XG4gIHJldHVybiBbbiwgcl0uam9pbihcIlwiKTtcbn07XG5mdW5jdGlvbiBjVyh0KSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ID4gXCJ1XCIgPyBCdWZmZXIuZnJvbSh0KS50b1N0cmluZyhcImJhc2U2NFwiKSA6IGJ0b2EodCk7XG59XG5mdW5jdGlvbiB1Vyh0KSB7XG4gIHJldHVybiAhKCF0IHx8IEFycmF5LmlzQXJyYXkodCkgJiYgIXQubGVuZ3RoIHx8ICh0ID8/IFtdKS5zb21lKFxuICAgIChlKSA9PiAhT2JqZWN0LmtleXMoZSkubGVuZ3RoXG4gICkpO1xufVxuZnVuY3Rpb24gd1AodCwgZSkge1xuICB2YXIgbiwgcjtcbiAgY29uc3QgaSA9IFtdLCBzID0gW10sIG8gPSBbXTtcbiAgaWYgKCF0LmN1c3RvbVNlY3VyaXR5ICYmICghdC5wcmVmZXJyZWRTZWN1cml0eVNjaGVtZSB8fCAhdVcoZSkpKVxuICAgIHJldHVybiB7IGhlYWRlcnM6IGksIHF1ZXJ5U3RyaW5nOiBzLCBjb29raWVzOiBvIH07XG4gIGNvbnN0IGwgPSAoZSA9PSBudWxsID8gdm9pZCAwIDogZS5zb21lKFxuICAgICh1KSA9PiB0LnByZWZlcnJlZFNlY3VyaXR5U2NoZW1lICYmIE9iamVjdC5rZXlzKHUpLmluY2x1ZGVzKFxuICAgICAgdC5wcmVmZXJyZWRTZWN1cml0eVNjaGVtZVxuICAgIClcbiAgKSkgfHwgdC5jdXN0b21TZWN1cml0eSA/IHQucHJlZmVycmVkU2VjdXJpdHlTY2hlbWUgOiBPYmplY3Qua2V5cygoZSA9PSBudWxsID8gdm9pZCAwIDogZVswXSkgPz8ge30pLnBvcCgpLCBjID0gKG4gPSB0LnNlY3VyaXR5U2NoZW1lcykgPT0gbnVsbCA/IHZvaWQgMCA6IG5bbCA/PyBcIlwiXTtcbiAgaWYgKGMpIHtcbiAgICBpZiAoXCJ0eXBlXCIgaW4gYyAmJiBjLnR5cGUgPT09IFwiYXBpS2V5XCIpIHtcbiAgICAgIGlmIChcImluXCIgaW4gYyAmJiBjLmluID09PSBcImhlYWRlclwiKSB7XG4gICAgICAgIGNvbnN0IHUgPSAociA9IHQuYXBpS2V5LnRva2VuKSAhPSBudWxsICYmIHIubGVuZ3RoID8gdC5hcGlLZXkudG9rZW4gOiBcIllPVVJfVE9LRU5cIjtcbiAgICAgICAgaS5wdXNoKHtcbiAgICAgICAgICBuYW1lOiBcIm5hbWVcIiBpbiBjID8gYy5uYW1lIDogXCJcIixcbiAgICAgICAgICB2YWx1ZTogdVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoXCJpblwiIGluIGMgJiYgYy5pbiA9PT0gXCJjb29raWVcIikge1xuICAgICAgICBjb25zdCB1ID0gdC5hcGlLZXkudG9rZW4ubGVuZ3RoID8gdC5hcGlLZXkudG9rZW4gOiBcIllPVVJfVE9LRU5cIjtcbiAgICAgICAgby5wdXNoKHtcbiAgICAgICAgICBuYW1lOiBjLm5hbWUsXG4gICAgICAgICAgdmFsdWU6IHVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKFwiaW5cIiBpbiBjICYmIGMuaW4gPT09IFwicXVlcnlcIikge1xuICAgICAgICBjb25zdCB1ID0gdC5hcGlLZXkudG9rZW4ubGVuZ3RoID8gdC5hcGlLZXkudG9rZW4gOiBcIllPVVJfVE9LRU5cIjtcbiAgICAgICAgcy5wdXNoKHtcbiAgICAgICAgICBuYW1lOiBjLm5hbWUsXG4gICAgICAgICAgdmFsdWU6IHVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcInR5cGVcIiBpbiBjICYmIC8vIEB0cy1pZ25vcmVcbiAgICAoYy50eXBlID09PSBcImh0dHBcIiB8fCBjLnR5cGUgPT09IFwiYmFzaWNcIikpIHtcbiAgICAgIGlmIChcInR5cGVcIiBpbiBjICYmIC8vIEB0cy1pZ25vcmVcbiAgICAgIChjLnR5cGUgPT09IFwiYmFzaWNcIiB8fCBjLnR5cGUgPT09IFwiaHR0cFwiICYmIGMuc2NoZW1lID09PSBcImJhc2ljXCIpKSB7XG4gICAgICAgIGNvbnN0IHsgdXNlcm5hbWU6IHUsIHBhc3N3b3JkOiBkIH0gPSB0Lmh0dHAuYmFzaWMsIGYgPSBkVyh1LCBkKTtcbiAgICAgICAgaS5wdXNoKHtcbiAgICAgICAgICBuYW1lOiBcIkF1dGhvcml6YXRpb25cIixcbiAgICAgICAgICB2YWx1ZTogYEJhc2ljICR7Zn1gLnRyaW0oKVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAoXCJ0eXBlXCIgaW4gYyAmJiBjLnR5cGUgPT09IFwiaHR0cFwiICYmIGMuc2NoZW1lID09PSBcImJlYXJlclwiKSB7XG4gICAgICAgIGNvbnN0IHUgPSB0Lmh0dHAuYmVhcmVyLnRva2VuLmxlbmd0aCA/IHQuaHR0cC5iZWFyZXIudG9rZW4gOiBcIllPVVJfU0VDUkVUX1RPS0VOXCI7XG4gICAgICAgIGkucHVzaCh7XG4gICAgICAgICAgbmFtZTogXCJBdXRob3JpemF0aW9uXCIsXG4gICAgICAgICAgdmFsdWU6IGBCZWFyZXIgJHt1fWBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcInR5cGVcIiBpbiBjICYmIGMudHlwZS50b0xvd2VyQ2FzZSgpID09PSBcIm9hdXRoMlwiKSB7XG4gICAgICBjb25zdCB1ID0gdC5vQXV0aDIuYWNjZXNzVG9rZW4gfHwgXCJZT1VSX1NFQ1JFVF9UT0tFTlwiO1xuICAgICAgaS5wdXNoKHtcbiAgICAgICAgbmFtZTogXCJBdXRob3JpemF0aW9uXCIsXG4gICAgICAgIHZhbHVlOiBgQmVhcmVyICR7dX1gXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgaGVhZGVyczogaSwgcXVlcnlTdHJpbmc6IHMsIGNvb2tpZXM6IG8gfTtcbn1cbmZ1bmN0aW9uIGRXKHQsIGUpIHtcbiAgcmV0dXJuIHQgIT0gbnVsbCAmJiB0Lmxlbmd0aCB8fCBlICE9IG51bGwgJiYgZS5sZW5ndGggPyBjVyhgJHt0fToke2V9YCkgOiBcIlwiO1xufVxuZnVuY3Rpb24gZlcodCkge1xuICBjb25zdCBlID0gTWF0aC5mbG9vcigoKC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpKS5nZXRUaW1lKCkgLSB0KSAvIDFlMyk7XG4gIGlmIChlIDwgNDUpXG4gICAgcmV0dXJuIFwianVzdCBub3dcIjtcbiAgaWYgKGUgPCA2MClcbiAgICByZXR1cm4gYCR7ZX0gc2Vjb25kcyBhZ29gO1xuICBjb25zdCBuID0gTWF0aC5mbG9vcihlIC8gNjApO1xuICBpZiAobiA8IDYwKVxuICAgIHJldHVybiBgJHtufSBtaW51dGUke24gPT09IDEgPyBcIlwiIDogXCJzXCJ9IGFnb2A7XG4gIGNvbnN0IHIgPSBNYXRoLmZsb29yKG4gLyA2MCk7XG4gIGlmIChyIDwgMjQpXG4gICAgcmV0dXJuIGAke3J9IGhvdXIke3IgPT09IDEgPyBcIlwiIDogXCJzXCJ9IGFnb2A7XG4gIGNvbnN0IGkgPSBNYXRoLmZsb29yKHIgLyAyNCk7XG4gIGlmIChpIDwgMzApXG4gICAgcmV0dXJuIGAke2l9IGRheSR7aSA9PT0gMSA/IFwiXCIgOiBcInNcIn0gYWdvYDtcbiAgY29uc3QgcyA9IE1hdGguZmxvb3IoaSAvIDMwKTtcbiAgcmV0dXJuIHMgPCAxMiA/IGAke3N9IG1vbnRoJHtzID09PSAxID8gXCJcIiA6IFwic1wifSBhZ29gIDogXCJtb3JlIHRoYW4gYSB5ZWFyIGFnb1wiO1xufVxuZnVuY3Rpb24gTWModCwgZSwgbikge1xuICBjb25zdCByID0ge307XG4gIHJldHVybiB0LmZvckVhY2goKGkpID0+IHtcbiAgICByW2lbZV1dID0gaVtuXTtcbiAgfSksIHI7XG59XG5jb25zdCBoVyA9ICh0KSA9PiB7XG4gIGlmICh0eXBlb2YgdCAhPSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBcIlwiO1xuICBsZXQgZSA9IHQudHJpbSgpO1xuICByZXR1cm4gZS5sZW5ndGggPiAxICYmIGUuc3RhcnRzV2l0aChcIi9cIikgJiYgKGUgPSBlLnNsaWNlKDEpKSwgZTtcbn0sIFhjID0gXCJHRVRcIiwgcFcgPSAodCkgPT4ge1xuICBpZiAodHlwZW9mIHQgIT0gXCJzdHJpbmdcIilcbiAgICByZXR1cm4gY29uc29sZS53YXJuKFxuICAgICAgYFtzZW5kUmVxdWVzdF0gUmVxdWVzdCBtZXRob2QgaXMgbm90IGEgc3RyaW5nLiBVc2luZyAke1hjfSBhcyB0aGUgZGVmYXVsdC5gXG4gICAgKSwgWGM7XG4gIGNvbnN0IGUgPSB0LnRyaW0oKS50b1VwcGVyQ2FzZSgpO1xuICByZXR1cm4gamgoZSkgPyBlIDogKGNvbnNvbGUud2FybihcbiAgICBgW3NlbmRSZXF1ZXN0XSAke3R9IGlzIG5vdCBhIHZhbGlkIHJlcXVlc3QgbWV0aG9kLiBVc2luZyAke1hjfSBhcyB0aGUgZGVmYXVsdC5gXG4gICksIFhjKTtcbn0sIE9XID0gKHQpID0+IHtcbiAgaWYgKHR5cGVvZiB0ICE9IFwic3RyaW5nXCIpXG4gICAgcmV0dXJuIGNvbnNvbGUud2FybihcbiAgICAgIFwiW3NlbmRSZXF1ZXN0XSBVUkwgaXMgbm90IGEgc3RyaW5nLiBVc2luZyBhbiBlbXB0eSBzdHJpbmcgYXMgdGhlIGRlZmF1bHQuXCJcbiAgICApLCBcIlwiO1xuICBsZXQgZSA9IHQ7XG4gIGUuc3RhcnRzV2l0aChcImh0dHBcIikgfHwgKGNvbnNvbGUud2FybihcbiAgICBcIltzZW5kUmVxdWVzdF0gVVJMIGRvZXMgbm90IHN0YXJ0IHdpdGggaHR0cC4gQWRkaW5nIGh0dHA6Ly8gYXMgdGhlIGRlZmF1bHQgcHJlZml4LlwiXG4gICksIGUgPSBgaHR0cDovLyR7ZX1gKTtcbiAgY29uc3QgbiA9IG5ldyBVUkwoZSk7XG4gIHJldHVybiBuLmhvc3RuYW1lID0gbi5ob3N0bmFtZS50cmltKCkudG9Mb3dlckNhc2UoKSwgbi50b1N0cmluZygpO1xufTtcbmZ1bmN0aW9uIGpjKHQpIHtcbiAgcmV0dXJuICh0ID8/IFtdKS5tYXAoKGUpID0+ICh7IC4uLmUsIGVuYWJsZWQ6ICEwIH0pKTtcbn1cbmNvbnN0IGdXID0gKHQpID0+IHtcbiAgdmFyIGUsIG47XG4gIGNvbnN0IHsgcmVxdWVzdDogciB9ID0gdCwgeyBhdXRoZW50aWNhdGlvbjogaSB9ID0gWWwoKSwge1xuICAgIG9wZW5BcGk6IHsgb3BlcmF0aW9uOiBzLCBnbG9iYWxTZWN1cml0eTogbyB9XG4gIH0gPSBDdygpLCBhID0gd1AoXG4gICAgaSxcbiAgICAoKGUgPSBzID09IG51bGwgPyB2b2lkIDAgOiBzLmluZm9ybWF0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogZS5zZWN1cml0eSkgPz8gb1xuICApO1xuICByZXR1cm4gci5oZWFkZXJzID0gW1xuICAgIC4uLnIuaGVhZGVycyA/PyBbXSxcbiAgICAuLi5qYyhhLmhlYWRlcnMpXG4gIF0sIHIuY29va2llcyA9IFtcbiAgICAuLi5yLmNvb2tpZXMgPz8gW10sXG4gICAgLi4uamMoYS5jb29raWVzKVxuICBdLCByLnF1ZXJ5ID0gW1xuICAgIC4uLnIucXVlcnkgPz8gW10sXG4gICAgLi4uamMoYS5xdWVyeVN0cmluZylcbiAgXSwgci5ib2R5ICYmIFhoKHIuYm9keSkgJiYgKChuID0gci5oZWFkZXJzKSAhPSBudWxsICYmIG4uc29tZShcbiAgICAoYykgPT4gYy5uYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiY29udGVudC10eXBlXCJcbiAgKSB8fCAoci5oZWFkZXJzID0gW1xuICAgIC4uLnIuaGVhZGVycyA/PyBbXSxcbiAgICAuLi5qYyhbXG4gICAgICB7XG4gICAgICAgIG5hbWU6IFwiQ29udGVudC1UeXBlXCIsXG4gICAgICAgIHZhbHVlOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIlxuICAgICAgfVxuICAgIF0pXG4gIF0pLCByLmJvZHkgPSBKU09OLnBhcnNlKHIuYm9keSkpLCB7XG4gICAgLi4uclxuICB9O1xufSwgbVcgPSAodCwgZSkgPT4gT2JqZWN0LmVudHJpZXMoZSkucmVkdWNlKChuLCBbciwgaV0pID0+IG4ucmVwbGFjZShgeyR7cn19YCwgaS50b1N0cmluZygpKSwgdCk7XG5hc3luYyBmdW5jdGlvbiBiVyh0LCBlKSB7XG4gIHZhciBuO1xuICBjb25zdCByID0gcFcodC50eXBlKSwgaSA9IE1jKFxuICAgICh0LmhlYWRlcnMgPz8gW10pLmZpbHRlcigoYikgPT4gYi5lbmFibGVkKSxcbiAgICBcIm5hbWVcIixcbiAgICBcInZhbHVlXCJcbiAgKSwgcyA9IE9XKHQudXJsKSwgbyA9IGhXKHQucGF0aCksIFthLCAuLi5sXSA9IGxXKFxuICAgIHMsXG4gICAgb1xuICApLnNwbGl0KFwiP1wiKSwgYyA9IG1XKFxuICAgIGEsXG4gICAgTWMoXG4gICAgICAodC52YXJpYWJsZXMgPz8gW10pLmZpbHRlcigoYikgPT4gYi5lbmFibGVkKSxcbiAgICAgIFwibmFtZVwiLFxuICAgICAgXCJ2YWx1ZVwiXG4gICAgKVxuICApLCB1ID0gW107XG4gIGwuZm9yRWFjaCgoYikgPT4ge1xuICAgIG5ldyBVUkxTZWFyY2hQYXJhbXMoYiA/PyBcIlwiKS5mb3JFYWNoKChnLCB2KSA9PiB7XG4gICAgICB1LnB1c2goe1xuICAgICAgICBuYW1lOiB2LFxuICAgICAgICB2YWx1ZTogZyxcbiAgICAgICAgZW5hYmxlZDogITBcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbiAgY29uc3QgZCA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoXG4gICAgLy8gVE9ETzogTm8gdHlwZS1jYXN0aW5nXG4gICAgTWMoXG4gICAgICBbXG4gICAgICAgIC4uLih0LnF1ZXJ5ID8/IFtdKS5maWx0ZXIoKGIpID0+IGIuZW5hYmxlZCksXG4gICAgICAgIC4uLnVcbiAgICAgIF0sXG4gICAgICBcIm5hbWVcIixcbiAgICAgIFwidmFsdWVcIlxuICAgIClcbiAgKS50b1N0cmluZygpLCBmID0gYCR7Y30ke2QgPyBcIj9cIiArIGQgOiBcIlwifWAsIGggPSB7XG4gICAgdHlwZTogXCJub25lXCJcbiAgfSwgcCA9IERhdGUubm93KCk7XG4gIGlmICh0LmNvb2tpZXMgJiYgKChuID0gdC5jb29raWVzKSA9PSBudWxsID8gdm9pZCAwIDogbi5sZW5ndGgpID4gMCkge1xuICAgIGNvbnN0IGIgPSBNYyhcbiAgICAgICh0LmNvb2tpZXMgPz8gW10pLmZpbHRlcigoZykgPT4gZy5lbmFibGVkKSxcbiAgICAgIFwibmFtZVwiLFxuICAgICAgXCJ2YWx1ZVwiXG4gICAgKTtcbiAgICBpLkNvb2tpZSA9IE9iamVjdC5rZXlzKGIpLm1hcCgoZykgPT4gYCR7Z309JHtiW2ddfWApLmpvaW4oXCI7IFwiKTtcbiAgfVxuICBjb25zdCBPID0ge1xuICAgIG1ldGhvZDogcixcbiAgICB1cmw6IGYsXG4gICAgYXV0aDogaCxcbiAgICBoZWFkZXJzOiBpLFxuICAgIGRhdGE6IHQuYm9keVxuICB9LCBtID0gZSA/IHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIHVybDogZSxcbiAgICBkYXRhOiBPXG4gIH0gOiB7XG4gICAgbWV0aG9kOiBPLm1ldGhvZCxcbiAgICB1cmw6IE8udXJsLFxuICAgIGhlYWRlcnM6IE8uaGVhZGVycyxcbiAgICBkYXRhOiBPLmRhdGFcbiAgfTtcbiAgaS5jb29raWVzICYmIChtLndpdGhDcmVkZW50aWFscyA9ICEwKSwgY29uc29sZS5pbmZvKGUgPyBgJHtPLm1ldGhvZH0gJHtlfSDihpIgJHtPLnVybH1gIDogYCR7Ty5tZXRob2R9ICR7Ty51cmx9YCk7XG4gIGNvbnN0IHkgPSBhd2FpdCBBdChtKS50aGVuKChiKSA9PiBlID8ge1xuICAgIC4uLmIuZGF0YSxcbiAgICBlcnJvcjogITFcbiAgfSA6IHtcbiAgICAuLi5iLFxuICAgIHN0YXR1c0NvZGU6IGIuc3RhdHVzLFxuICAgIGRhdGE6IEpTT04uc3RyaW5naWZ5KGIuZGF0YSksXG4gICAgZXJyb3I6ICExXG4gIH0pLmNhdGNoKChiKSA9PiB7XG4gICAgY29uc3QgeyByZXNwb25zZTogZyB9ID0gYjtcbiAgICByZXR1cm4ge1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcImNvbnRlbnQtdHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIlxuICAgICAgfSxcbiAgICAgIC4uLmcsXG4gICAgICBzdGF0dXNDb2RlOiAoZyA9PSBudWxsID8gdm9pZCAwIDogZy5zdGF0dXMpID8/IDAsXG4gICAgICBkYXRhOiBKU09OLnN0cmluZ2lmeSgoZyA9PSBudWxsID8gdm9pZCAwIDogZy5kYXRhKSA/PyB7IGVycm9yOiBiLmNvZGUgfSlcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBzZW50VGltZTogRGF0ZS5ub3coKSxcbiAgICByZXF1ZXN0OiB7XG4gICAgICAuLi50LFxuICAgICAgdHlwZTogcixcbiAgICAgIHVybDogcyxcbiAgICAgIHBhdGg6IG9cbiAgICB9LFxuICAgIHJlc3BvbnNlOiB7XG4gICAgICAuLi55LFxuICAgICAgZHVyYXRpb246IERhdGUubm93KCkgLSBwXG4gICAgfSxcbiAgICByZXNwb25zZUlkOiB1MigpXG4gIH07XG59XG5jb25zdCB2VyA9IHsgY2xhc3M6IFwibmF2dGFibGUtaXRlbS00MCBuYXZ0YWJsZS1pdGVtLXJlcXVlc3RcIiB9LCB5VyA9IHsgY2xhc3M6IFwibmF2dGFibGUtaXRlbS00MCBuYXZ0YWJsZS1pdGVtLXJlc3BvbnNlXCIgfSwgU1cgPSB7IGNsYXNzOiBcIm5hdnRhYmxlLWl0ZW0tMjAgbmF2dGFibGUtaXRlbS10aW1lXCIgfSwgd1cgPSAvKiBAX19QVVJFX18gKi8gbGUoe1xuICBfX25hbWU6IFwiUmVxdWVzdEhpc3RvcnlJdGVtXCIsXG4gIHByb3BzOiB7XG4gICAgaGlzdG9yeToge31cbiAgfSxcbiAgc2V0dXAodCkge1xuICAgIGNvbnN0IHsgcmVxdWVzdEhpc3Rvcnk6IGUsIGFjdGl2ZVJlcXVlc3RJZDogbiwgc2V0QWN0aXZlUmVzcG9uc2U6IHIgfSA9IHNyKCksIGkgPSAocykgPT4ge1xuICAgICAgdmFyIG87XG4gICAgICByZXR1cm4gKG8gPSBzID09IG51bGwgPyB2b2lkIDAgOiBzLmhlYWRlcnMpICE9IG51bGwgJiYgb1tcIlgtQVBJLUNsaWVudC1Db250ZW50LUxlbmd0aFwiXSA/IEN1KFxuICAgICAgICBwYXJzZUZsb2F0KHMuaGVhZGVyc1tcIlgtQVBJLUNsaWVudC1Db250ZW50LUxlbmd0aFwiXSlcbiAgICAgICkgOiBDdSgwKTtcbiAgICB9O1xuICAgIHJldHVybiAocywgbykgPT4gKFooKSwgbmUoXCJkaXZcIiwge1xuICAgICAgY2xhc3M6IEtlKFtcIm5hdnRhYmxlLWl0ZW1cIiwgeyBcIm5hdnRhYmxlLWl0ZW1fX2FjdGl2ZVwiOiBSKG4pID09PSBzLmhpc3RvcnkgfV0pLFxuICAgICAgb25DbGljazogb1swXSB8fCAob1swXSA9IChhKSA9PiBSKHIpKHMuaGlzdG9yeSkpXG4gICAgfSwgW1xuICAgICAgRChcImRpdlwiLCB2VywgW1xuICAgICAgICBEKFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICBjbGFzczogS2UoW1wicmFkaW9cIiwgUihlKVtzLmhpc3RvcnldLnJlcXVlc3QudHlwZS50b0xvd2VyQ2FzZSgpXSksXG4gICAgICAgICAgdHlwZTogXCJidXR0b25cIlxuICAgICAgICB9LCBudWxsLCAyKSxcbiAgICAgICAgRChcInNwYW5cIiwgbnVsbCwgW1xuICAgICAgICAgIEQoXCJlbVwiLCBudWxsLCBEZShSKGUpW3MuaGlzdG9yeV0ucmVxdWVzdC50eXBlKSwgMSksXG4gICAgICAgICAgSGUoXCIgXCIgKyBEZShSKGUpW3MuaGlzdG9yeV0ucmVxdWVzdC51cmwpLCAxKVxuICAgICAgICBdKVxuICAgICAgXSksXG4gICAgICBEKFwiZGl2XCIsIHlXLCBbXG4gICAgICAgIEQoXCJzcGFuXCIsIG51bGwsIERlKFIoZHcpKFIoZSlbcy5oaXN0b3J5XS5yZXNwb25zZS5kdXJhdGlvbikpLCAxKSxcbiAgICAgICAgRChcInNwYW5cIiwge1xuICAgICAgICAgIGNsYXNzOiBLZShgc2NhbGFyLWFwaS1jbGllbnRfX3N0YXR1cy0tJHtTdHJpbmcoXG4gICAgICAgICAgICBSKGUpW3MuaGlzdG9yeV0ucmVzcG9uc2Uuc3RhdHVzQ29kZVxuICAgICAgICAgICkuY2hhckF0KDApfXh4YClcbiAgICAgICAgfSwgRGUoUihlKVtzLmhpc3RvcnldLnJlc3BvbnNlLnN0YXR1c0NvZGUpLCAzKSxcbiAgICAgICAgRChcInNwYW5cIiwgbnVsbCwgRGUoaShSKGUpW3MuaGlzdG9yeV0ucmVzcG9uc2UpKSwgMSlcbiAgICAgIF0pLFxuICAgICAgRChcImRpdlwiLCBTVywgW1xuICAgICAgICBEKFwic3BhblwiLCBudWxsLCBEZShSKGZXKShSKGUpW3MuaGlzdG9yeV0uc2VudFRpbWUpKSwgMSlcbiAgICAgIF0pXG4gICAgXSwgMikpO1xuICB9XG59KSwga1cgPSAvKiBAX19QVVJFX18gKi8gY3Qod1csIFtbXCJfX3Njb3BlSWRcIiwgXCJkYXRhLXYtMzUzYzZkODZcIl1dKSwgeFcgPSB7IGNsYXNzOiBcIm5hdmlnYXRpb24tY29udGVudC1pdGVtXCIgfSwgUFcgPSB7IGNsYXNzOiBcIm5hdnRhYmxlXCIgfSwgX1cgPSB7IGNsYXNzOiBcIm5hdnRhYmxlLXRhYmxlXCIgfSwgVFcgPSAvKiBAX19QVVJFX18gKi8gV2woJzxkaXYgY2xhc3M9XCJuYXZ0YWJsZS1pdGVtIG5hdnRhYmxlLWl0ZW1fX3RvcFwiPjxkaXYgY2xhc3M9XCJuYXZ0YWJsZS1pdGVtLTQwXCI+PGxhYmVsIGZvcj1cIlwiPlJlcXVlc3Q8L2xhYmVsPjwvZGl2PjxkaXYgY2xhc3M9XCJuYXZ0YWJsZS1pdGVtLTQwXCI+PGxhYmVsIGZvcj1cIlwiPlJlc3BvbnNlPC9sYWJlbD48L2Rpdj48ZGl2IGNsYXNzPVwibmF2dGFibGUtaXRlbS0yMFwiPjxsYWJlbCBmb3I9XCJcIj5USU1FPC9sYWJlbD48L2Rpdj48L2Rpdj4nLCAxKSwgRVcgPSB7IGNsYXNzOiBcIm5hdnRhYmxlLXJhZGlvc1wiIH0sICRXID0gLyogQF9fUFVSRV9fICovIFdsKCc8ZGl2IGNsYXNzPVwibmF2dGFibGUtbW9ja1wiPjxkaXYgY2xhc3M9XCJuYXZ0YWJsZS1pdGVtXCI+PGRpdiBjbGFzcz1cIm5hdnRhYmxlLWl0ZW0tNDBcIj48L2Rpdj48ZGl2IGNsYXNzPVwibmF2dGFibGUtaXRlbS00MFwiPjwvZGl2PjxkaXYgY2xhc3M9XCJuYXZ0YWJsZS1pdGVtLTIwXCI+PC9kaXY+PC9kaXY+PC9kaXY+JywgMSksIFFXID0gLyogQF9fUFVSRV9fICovIGxlKHtcbiAgX19uYW1lOiBcIlJlcXVlc3RIaXN0b3J5XCIsXG4gIGVtaXRzOiBbXCJ0b2dnbGVcIl0sXG4gIHNldHVwKHQpIHtcbiAgICBjb25zdCB7IHJlcXVlc3RIaXN0b3J5T3JkZXI6IGUgfSA9IHNyKCk7XG4gICAgcmV0dXJuIChuLCByKSA9PiAoWigpLCBuZShcImRpdlwiLCB4VywgW1xuICAgICAgRChcImRpdlwiLCBQVywgW1xuICAgICAgICBEKFwiZGl2XCIsIF9XLCBbXG4gICAgICAgICAgVFcsXG4gICAgICAgICAgRChcImRpdlwiLCBFVywgW1xuICAgICAgICAgICAgKFooITApLCBuZShQZSwgbnVsbCwgWHIoUihlKSwgKGkpID0+IChaKCksIGtlKGtXLCB7XG4gICAgICAgICAgICAgIGtleTogaSxcbiAgICAgICAgICAgICAgaGlzdG9yeTogaVxuICAgICAgICAgICAgfSwgbnVsbCwgOCwgW1wiaGlzdG9yeVwiXSkpKSwgMTI4KSlcbiAgICAgICAgICBdKSxcbiAgICAgICAgICAkV1xuICAgICAgICBdKVxuICAgICAgXSlcbiAgICBdKSk7XG4gIH1cbn0pLCBDVyA9IHsgY2xhc3M6IFwicmVxdWVzdC1tZXRob2Qtc2VsZWN0XCIgfSwgQVcgPSBbXCJkaXNhYmxlZFwiLCBcInZhbHVlXCJdLCBSVyA9IFtcInZhbHVlXCJdLCBOVyA9IC8qIEBfX1BVUkVfXyAqLyBsZSh7XG4gIF9fbmFtZTogXCJSZXF1ZXN0TWV0aG9kU2VsZWN0XCIsXG4gIHByb3BzOiB7XG4gICAgcmVxdWVzdE1ldGhvZDoge30sXG4gICAgcmVhZE9ubHk6IHsgdHlwZTogQm9vbGVhbiwgZGVmYXVsdDogITAgfVxuICB9LFxuICBlbWl0czogW1wiY2hhbmdlXCJdLFxuICBzZXR1cCh0KSB7XG4gICAgY29uc3QgZSA9IFtcbiAgICAgIFwiR0VUXCIsXG4gICAgICBcIlBPU1RcIixcbiAgICAgIFwiUFVUXCIsXG4gICAgICAvLyAnSEVBRCcsXG4gICAgICBcIkRFTEVURVwiLFxuICAgICAgXCJQQVRDSFwiXG4gICAgICAvLyAnT1BUSU9OUycsXG4gICAgICAvLyAnQ09OTkVDVCcsXG4gICAgICAvLyAnVFJBQ0UnLFxuICAgIF07XG4gICAgcmV0dXJuIChuLCByKSA9PiAoWigpLCBuZShcImRpdlwiLCBDVywgW1xuICAgICAgRChcInNwYW5cIiwge1xuICAgICAgICBjbGFzczogS2UoW1wicmVxdWVzdC1tZXRob2RcIiwgeyBcInJlcXVlc3QtbWV0aG9kLS1kaXNhYmxlZFwiOiBuLnJlYWRPbmx5IH1dKVxuICAgICAgfSwgW1xuICAgICAgICBEKFwic3BhblwiLCBudWxsLCBEZShuLnJlcXVlc3RNZXRob2QpLCAxKVxuICAgICAgXSwgMiksXG4gICAgICBEKFwic2VsZWN0XCIsIHtcbiAgICAgICAgZGlzYWJsZWQ6IG4ucmVhZE9ubHksXG4gICAgICAgIHZhbHVlOiBuLnJlcXVlc3RNZXRob2QudG9Mb3dlckNhc2UoKSxcbiAgICAgICAgb25JbnB1dDogclswXSB8fCAoclswXSA9IChpKSA9PiBuLiRlbWl0KFwiY2hhbmdlXCIsIGkudGFyZ2V0LnZhbHVlKSlcbiAgICAgIH0sIFtcbiAgICAgICAgKFooKSwgbmUoUGUsIG51bGwsIFhyKGUsIChpKSA9PiBEKFwib3B0aW9uXCIsIHtcbiAgICAgICAgICBrZXk6IGksXG4gICAgICAgICAgdmFsdWU6IGkudG9Mb2NhbGVMb3dlckNhc2UoKVxuICAgICAgICB9LCBEZShpKSwgOSwgUlcpKSwgNjQpKVxuICAgICAgXSwgNDAsIEFXKVxuICAgIF0pKTtcbiAgfVxufSksIERXID0gLyogQF9fUFVSRV9fICovIGN0KE5XLCBbW1wiX19zY29wZUlkXCIsIFwiZGF0YS12LTBmMWU1YmRjXCJdXSksIHRjID0gKHQpID0+IChLcyhcImRhdGEtdi0yOTY3ZTA3YVwiKSwgdCA9IHQoKSwgSnMoKSwgdCksIFpXID0ge1xuICBrZXk6IDAsXG4gIGNsYXNzOiBcImxvYWRlclwiXG59LCBWVyA9IHsgY2xhc3M6IFwidXJsLWZvcm1cIiB9LCBJVyA9IHsgY2xhc3M6IFwidXJsLWZvcm0tZmllbGRcIiB9LCBXVyA9IHsgY2xhc3M6IFwidXJsLWZvcm0taW5wdXQtd3JhcHBlciBjbS1zY3JvbGxlclwiIH0sIE1XID0gLyogQF9fUFVSRV9fICovIHRjKCgpID0+IC8qIEBfX1BVUkVfXyAqLyBEKFwiZGl2XCIsIHsgY2xhc3M6IFwidXJsLWZvcm0taW5wdXQtZmFkZV9fbGVmdFwiIH0sIG51bGwsIC0xKSksIFhXID0gLyogQF9fUFVSRV9fICovIHRjKCgpID0+IC8qIEBfX1BVUkVfXyAqLyBEKFwiZGl2XCIsIHsgY2xhc3M6IFwidXJsLWZvcm0taW5wdXQtZmFkZV9fcmlnaHRcIiB9LCBudWxsLCAtMSkpLCBqVyA9IHtcbiAga2V5OiAwLFxuICBjbGFzczogXCJoaXN0b3J5XCJcbn0sIEJXID0gLyogQF9fUFVSRV9fICovIHRjKCgpID0+IC8qIEBfX1BVUkVfXyAqLyBEKFwic3ZnXCIsIHtcbiAgZmlsbDogXCJub25lXCIsXG4gIGhlaWdodDogXCI0OFwiLFxuICB2aWV3Qm94OiBcIjAgMCAxNCAxNFwiLFxuICB3aWR0aDogXCI0OFwiLFxuICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG59LCBbXG4gIC8qIEBfX1BVUkVfXyAqLyBEKFwiZ1wiLCB7IGlkOiBcInJld2luZC1jbG9jay0tYmFjay1yZXR1cm4tY2xvY2stdGltZXItY291bnRkb3duXCIgfSwgW1xuICAgIC8qIEBfX1BVUkVfXyAqLyBEKFwicGF0aFwiLCB7XG4gICAgICBpZDogXCJWZWN0b3IgMTU2MSAoU3Ryb2tlKVwiLFxuICAgICAgXCJjbGlwLXJ1bGVcIjogXCJldmVub2RkXCIsXG4gICAgICBkOiBcIk02Ljk5OTk5IDIuNzVDNy40MTQyIDIuNzUgNy43NDk5OSAzLjA4NTc5IDcuNzQ5OTkgMy41VjcuNUM3Ljc0OTk5IDcuNzYzNDUgNy42MTE3NyA4LjAwNzU4IDcuMzg1ODYgOC4xNDMxMkw0Ljg4NTg2IDkuNjQzMTJDNC41MzA2OCA5Ljg1NjIzIDQuMDY5OTggOS43NDEwNiAzLjg1Njg3IDkuMzg1ODdDMy42NDM3NiA5LjAzMDY5IDMuNzU4OTMgOC41Njk5OSA0LjExNDEyIDguMzU2ODhMNi4yNDk5OSA3LjA3NTM2VjMuNUM2LjI0OTk5IDMuMDg1NzkgNi41ODU3OCAyLjc1IDYuOTk5OTkgMi43NVpcIixcbiAgICAgIGZpbGw6IFwiY3VycmVudENvbG9yXCIsXG4gICAgICBcImZpbGwtcnVsZVwiOiBcImV2ZW5vZGRcIlxuICAgIH0pLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBEKFwicGF0aFwiLCB7XG4gICAgICBpZDogXCJVbmlvblwiLFxuICAgICAgXCJjbGlwLXJ1bGVcIjogXCJldmVub2RkXCIsXG4gICAgICBkOiBcIk0xMi41IDdDMTIuNSAzLjk2MjQzIDEwLjAzNzYgMS41IDcgMS41QzUuMjQ5MTYgMS41IDMuNjg4NTMgMi4zMTc5NiAyLjY4MDY2IDMuNTk0NTZMMy42NDY0NSA0LjU2MDM0QzMuOTYxNDMgNC44NzUzMyAzLjczODM1IDUuNDEzOSAzLjI5Mjg5IDUuNDEzOUgwLjVDMC4yMjM4NTcgNS40MTM5IDAgNS4xOTAwNCAwIDQuOTEzOVYyLjEyMUMwIDEuNjc1NTUgMC41Mzg1NyAxLjQ1MjQ3IDAuODUzNTUzIDEuNzY3NDVMMS42MTQzOSAyLjUyODI5QzIuODk3ODEgMC45ODQzMDEgNC44MzM1NiAwIDcgMEMxMC44NjYgMCAxNCAzLjEzNDAxIDE0IDdDMTQgMTAuODY2IDEwLjg2NiAxNCA3IDE0QzMuNjg5MDIgMTQgMC45MTY1OTEgMTEuNzAyIDAuMTg3MzI5IDguNjE0NzNDMC4wOTIxMDU5IDguMjExNjEgMC4zNDE3MDQgNy44MDc2MiAwLjc0NDgyNCA3LjcxMjRDMS4xNDc5NCA3LjYxNzE3IDEuNTUxOTMgNy44NjY3NyAxLjY0NzE1IDguMjY5ODlDMi4yMjAxMyAxMC42OTU1IDQuNDAwMjUgMTIuNSA3IDEyLjVDMTAuMDM3NiAxMi41IDEyLjUgMTAuMDM3NiAxMi41IDdaXCIsXG4gICAgICBmaWxsOiBcImN1cnJlbnRDb2xvclwiLFxuICAgICAgXCJmaWxsLXJ1bGVcIjogXCJldmVub2RkXCJcbiAgICB9KVxuICBdKVxuXSwgLTEpKSwgTFcgPSBbXG4gIEJXXG5dLCBVVyA9IFtcImRpc2FibGVkXCJdLCBxVyA9IC8qIEBfX1BVUkVfXyAqLyB0YygoKSA9PiAvKiBAX19QVVJFX18gKi8gRChcInN2Z1wiLCB7XG4gIGZpbGw6IFwibm9uZVwiLFxuICBoZWlnaHQ6IFwiNDhcIixcbiAgdmlld0JveDogXCIwIDAgMTQgMTRcIixcbiAgd2lkdGg6IFwiNDhcIixcbiAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxufSwgW1xuICAvKiBAX19QVVJFX18gKi8gRChcImdcIiwgeyBpZDogXCJzZW5kLWVtYWlsLS1tYWlsLXNlbmQtZW1haWwtcGFwZXItYWlycGxhbmVcIiB9LCBbXG4gICAgLyogQF9fUFVSRV9fICovIEQoXCJwYXRoXCIsIHtcbiAgICAgIGlkOiBcIlN1YnRyYWN0XCIsXG4gICAgICBcImNsaXAtcnVsZVwiOiBcImV2ZW5vZGRcIixcbiAgICAgIGQ6IFwiTTExLjgyMTUgMC4wOTc3MzMxQzEyLjEwOTcgLTAuMDA3NTE3OCAxMi40MjIgLTAuMDI4NzEzNCAxMi43MjE5IDAuMDM2NzE3MkMxMy4wMjQ4IDAuMTAyODAzIDEzLjMwMjQgMC4yNTQ0ODEgMTMuNTIxNiAwLjQ3MzcxOUMxMy43NDA5IDAuNjkyOTU3IDEzLjg5MjYgMC45NzA1MzcgMTMuOTU4NiAxLjI3MzQ2QzE0LjAyNDEgMS41NzMzOCAxNC4wMDI5IDEuODg1NjYgMTMuODk3NiAyLjE3Mzg5TDEwLjMyMzYgMTIuODg1OUwxMC4zMjM0IDEyLjg4NjZDMTAuMjM2MyAxMy4xNSAxMC4wODMgMTMuMzg2NyA5Ljg3ODEzIDEzLjU3MzlDOS42NzM4MyAxMy43NjA2IDkuNDI1MTIgMTMuODkxNyA5LjE1NTc1IDEzLjk1NDlDOC44ODYzMyAxNC4wMjA2IDguNjA0NDQgMTQuMDE1IDguMzM3NzcgMTMuOTM4OEM4LjA3MTM0IDEzLjg2MjcgNy44MjkyOSAxMy43MTg3IDcuNjM1MzIgMTMuNTIwOUw1LjcxNzk4IDExLjYxMjNMMy43MDM5MiAxMi42NTM4QzMuNTQ2ODcgMTIuNzM1IDMuMzU4NiAxMi43MjcyIDMuMjA4NzcgMTIuNjMzM0MzLjA1ODk1IDEyLjUzOTUgMi45Njk4NCAxMi4zNzM0IDIuOTc0NDMgMTIuMTk2N0wzLjA1NyA5LjAxMjk0TDEwLjEwMiAzLjg5NTUzQzEwLjM4MTIgMy42OTI2NyAxMC40NDMyIDMuMzAxODIgMTAuMjQwMyAzLjAyMjU1QzEwLjAzNzUgMi43NDMyNyA5LjY0NjYyIDIuNjgxMzMgOS4zNjczNCAyLjg4NDE5TDIuMjAyODYgOC4wODg0TDAuNDczMTU2IDYuMzU4NjlMMC40NzMwOTggNi4zNTg2NEwwLjQ3Mjk3MSA2LjM1ODUxQzAuMjg1NjQ4IDYuMTcxMzIgMC4xNDc3NDYgNS45NDA1NCAwLjA3MTY0OTggNS42ODY4OEMtMC4wMDM5MDU2NSA1LjQzNTAzIC0wLjAxNjE4MSA1LjE2ODQ3IDAuMDM1ODY4NCA0LjkxMDc5QzAuMDg3OTg1IDQuNjI5MjggMC4yMTM4MjcgNC4zNjY1OCAwLjQwMDYwNyA0LjE0OTUxQzAuNTg4NjY4IDMuOTMwOTUgMC44MzE2ODEgMy43NjY1OCAxLjEwNDUzIDMuNjczMzlMMS4xMDc5IDMuNjcyMjRMMS4xMDc5IDMuNjcyMjVMMTEuODIxNSAwLjA5NzczMzFaXCIsXG4gICAgICBmaWxsOiBcImN1cnJlbnRDb2xvclwiLFxuICAgICAgXCJmaWxsLXJ1bGVcIjogXCJldmVub2RkXCJcbiAgICB9KVxuICBdKVxuXSwgLTEpKSwgWVcgPSAvKiBAX19QVVJFX18gKi8gdGMoKCkgPT4gLyogQF9fUFVSRV9fICovIEQoXCJzcGFuXCIsIG51bGwsIFwiU2VuZFwiLCAtMSkpLCB6VyA9IFtcbiAgcVcsXG4gIFlXXG5dLCBIVyA9IHsgY2xhc3M6IFwiYWRkcmVzcy1iYXItY29udGVudFwiIH0sIEZXID0gLyogQF9fUFVSRV9fICovIGxlKHtcbiAgX19uYW1lOiBcIkFkZHJlc3NCYXJcIixcbiAgcHJvcHM6IHtcbiAgICBwcm94eVVybDoge31cbiAgfSxcbiAgZW1pdHM6IFtcIm9uU2VuZFwiXSxcbiAgc2V0dXAodCwgeyBlbWl0OiBlIH0pIHtcbiAgICBjb25zdCBuID0gdCwgciA9IGUsIGkgPSBCUygpO1xuICAgIE5oKGFXKCkgPyBpLm1ldGFfZW50ZXIgOiBpLmN0cmxfZW50ZXIsIGIpO1xuICAgIGNvbnN0IHMgPSBHKCExKSwgbyA9IEcoITEpLCB7XG4gICAgICBhY3RpdmVSZXF1ZXN0OiBhLFxuICAgICAgYWRkUmVxdWVzdFRvSGlzdG9yeTogbCxcbiAgICAgIHJlcXVlc3RIaXN0b3J5OiBjLFxuICAgICAgcmVxdWVzdEhpc3RvcnlPcmRlcjogdSxcbiAgICAgIHJlYWRPbmx5OiBkLFxuICAgICAgc2V0QWN0aXZlUmVxdWVzdDogZlxuICAgIH0gPSBzcigpLCBoID0gb1coKSwgcCA9IGooKCkgPT4gYS51cmwpLCBPID0gaigoKSA9PiBhLnR5cGUpLCBtID0gaigoKSA9PiBhLnBhdGgpLCB5ID0gaigoKSA9PiBgJHtwLnZhbHVlfSR7bS52YWx1ZX1gKTtcbiAgICBhc3luYyBmdW5jdGlvbiBiKCkge1xuICAgICAgY29uc3QgUyA9IGdXKHtcbiAgICAgICAgcmVxdWVzdDogeyAuLi5hIH1cbiAgICAgIH0pO1xuICAgICAgby52YWx1ZSA9ICEwLCByKFwib25TZW5kXCIpO1xuICAgICAgY29uc3QgdyA9IGF3YWl0IGJXKFMsIG4ucHJveHlVcmwpO1xuICAgICAgdyAmJiBsKHcpLCBvLnZhbHVlID0gITE7XG4gICAgfVxuICAgIGNvbnN0IGcgPSAoUykgPT4ge1xuICAgICAgZC52YWx1ZSB8fCBhLnVybCArIGEucGF0aCAhPT0gUyAmJiBmKHsgLi4uYSwgdXJsOiBTLCBwYXRoOiBcIlwiIH0pO1xuICAgIH0sIHYgPSAoUykgPT4ge1xuICAgICAgUyAmJiBmKHtcbiAgICAgICAgLi4uYSxcbiAgICAgICAgdHlwZTogUy50b0xvY2FsZUxvd2VyQ2FzZSgpXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiAoUywgdykgPT4gKFooKSwgbmUoUGUsIG51bGwsIFtcbiAgICAgIG8udmFsdWUgPyAoWigpLCBuZShcImRpdlwiLCBaVykpIDogc3QoXCJcIiwgITApLFxuICAgICAgRChcImRpdlwiLCB7XG4gICAgICAgIGNsYXNzOiBLZShbXCJhZGRyZXNzLWJhclwiLCB7IFwiYWRkcmVzcy1iYXItLXdpdGgtaGlzdG9yeVwiOiBzLnZhbHVlIH1dKVxuICAgICAgfSwgW1xuICAgICAgICBEKFwiZGl2XCIsIFZXLCBbXG4gICAgICAgICAgRChcImRpdlwiLCBJVywgW1xuICAgICAgICAgICAgSihEVywge1xuICAgICAgICAgICAgICByZWFkT25seTogUihkKSxcbiAgICAgICAgICAgICAgcmVxdWVzdE1ldGhvZDogTy52YWx1ZSxcbiAgICAgICAgICAgICAgb25DaGFuZ2U6IHZcbiAgICAgICAgICAgIH0sIG51bGwsIDgsIFtcInJlYWRPbmx5XCIsIFwicmVxdWVzdE1ldGhvZFwiXSksXG4gICAgICAgICAgICBEKFwiZGl2XCIsIFdXLCBbXG4gICAgICAgICAgICAgIE1XLFxuICAgICAgICAgICAgICBKKFIoU1ApLCB7XG4gICAgICAgICAgICAgICAgY2xhc3M6IFwidXJsLWZvcm0taW5wdXRcIixcbiAgICAgICAgICAgICAgICBjb250ZW50OiB5LnZhbHVlLFxuICAgICAgICAgICAgICAgIGRpc2FibGVFbnRlcjogXCJcIixcbiAgICAgICAgICAgICAgICByZWFkT25seTogUihkKSxcbiAgICAgICAgICAgICAgICB3aXRob3V0VGhlbWU6IFwiXCIsXG4gICAgICAgICAgICAgICAgd2l0aFZhcmlhYmxlczogXCJcIixcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogZ1xuICAgICAgICAgICAgICB9LCBudWxsLCA4LCBbXCJjb250ZW50XCIsIFwicmVhZE9ubHlcIl0pLFxuICAgICAgICAgICAgICBYV1xuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBSKHUpLmxlbmd0aCA/IChaKCksIG5lKFwiZGl2XCIsIGpXLCBbXG4gICAgICAgICAgICAgIEQoXCJkaXZcIiwge1xuICAgICAgICAgICAgICAgIGNsYXNzOiBcImhpc3RvcnktdG9nZ2xlXCIsXG4gICAgICAgICAgICAgICAgb25DbGljazogd1swXSB8fCAod1swXSA9IChrKSA9PiBSKGgpLnNob3coKSlcbiAgICAgICAgICAgICAgfSwgTFcpXG4gICAgICAgICAgICBdKSkgOiBzdChcIlwiLCAhMCksXG4gICAgICAgICAgICBEKFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICAgICAgY2xhc3M6IFwic2VuZC1idXR0b25cIixcbiAgICAgICAgICAgICAgZGlzYWJsZWQ6ICF5LnZhbHVlLnRyaW0oKS5sZW5ndGgsXG4gICAgICAgICAgICAgIHR5cGU6IFwic3VibWl0XCIsXG4gICAgICAgICAgICAgIG9uQ2xpY2s6IGJcbiAgICAgICAgICAgIH0sIHpXLCA4LCBVVylcbiAgICAgICAgICBdKVxuICAgICAgICBdKSxcbiAgICAgICAgRChcImRpdlwiLCB7XG4gICAgICAgICAgY2xhc3M6IFwiYWRkcmVzcy1iYXItY2xvc2VcIixcbiAgICAgICAgICBvbkNsaWNrOiB3WzFdIHx8ICh3WzFdID0gKGspID0+IHMudmFsdWUgPSAhMSlcbiAgICAgICAgfSksXG4gICAgICAgIEQoXCJkaXZcIiwgSFcsIFtcbiAgICAgICAgICBKKFIoc1cpLCB7XG4gICAgICAgICAgICBzdGF0ZTogUihoKSxcbiAgICAgICAgICAgIHRpdGxlOiBcIlJlcXVlc3QgSGlzdG9yeVwiLFxuICAgICAgICAgICAgdmFyaWFudDogXCJoaXN0b3J5XCJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBkZWZhdWx0OiBjZSgoKSA9PiBbXG4gICAgICAgICAgICAgIEooUVcsIHtcbiAgICAgICAgICAgICAgICBzaG93SGlzdG9yeTogcy52YWx1ZSxcbiAgICAgICAgICAgICAgICBvblRvZ2dsZTogd1syXSB8fCAod1syXSA9IChrKSA9PiBzLnZhbHVlID0gIXMudmFsdWUpXG4gICAgICAgICAgICAgIH0sIG51bGwsIDgsIFtcInNob3dIaXN0b3J5XCJdKVxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBfOiAxXG4gICAgICAgICAgfSwgOCwgW1wic3RhdGVcIl0pXG4gICAgICAgIF0pXG4gICAgICBdLCAyKVxuICAgIF0sIDY0KSk7XG4gIH1cbn0pLCBHVyA9IC8qIEBfX1BVUkVfXyAqLyBjdChGVywgW1tcIl9fc2NvcGVJZFwiLCBcImRhdGEtdi0yOTY3ZTA3YVwiXV0pLCBrUCA9IFVDKFN5bWJvbCgpKSwgS1cgPSB7IGNsYXNzOiBcInNjYWxhci1hcGktY2xpZW50X190b2dnbGUtY29udGFpbmVyXCIgfSwgSlcgPSB7IGNsYXNzOiBcInNjYWxhci1hcGktY2xpZW50X19pdGVtX190aXRsZVwiIH0sIGVNID0ge1xuICBrZXk6IDAsXG4gIGNsYXNzOiBcInNjYWxhci1hcGktY2xpZW50X19pdGVtX19vcHRpb25zXCJcbn0sIHRNID0gLyogQF9fUFVSRV9fICovIEQoXCJzdmdcIiwge1xuICBjbGFzczogXCJzY2FsYXItYXBpLWNsaWVudF9fdG9nZ2xlX19pY29uXCIsXG4gIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gIGZpbGw6IFwibm9uZVwiLFxuICB2aWV3Qm94OiBcIjAgMCAxMiAxMlwiXG59LCBbXG4gIC8qIEBfX1BVUkVfXyAqLyBEKFwicGF0aFwiLCB7XG4gICAgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLFxuICAgIFwic3Ryb2tlLWxpbmVjYXBcIjogXCJyb3VuZFwiLFxuICAgIFwic3Ryb2tlLWxpbmVqb2luXCI6IFwicm91bmRcIixcbiAgICBkOiBcIk0yLjIgNC4xIDYgNy45bDMuOC0zLjhcIlxuICB9KVxuXSwgLTEpLCBuTSA9IHsgY2xhc3M6IFwic2NhbGFyLWFwaS1jbGllbnRfX2l0ZW1fX2NvbnRlbnRcIiB9LCBiaSA9IC8qIEBfX1BVUkVfXyAqLyBsZSh7XG4gIF9fbmFtZTogXCJDb2xsYXBzaWJsZVNlY3Rpb25cIixcbiAgcHJvcHM6IHtcbiAgICB0aXRsZToge30sXG4gICAgZGVmYXVsdE9wZW46IHsgdHlwZTogQm9vbGVhbiwgZGVmYXVsdDogITAgfVxuICB9LFxuICBzZXR1cCh0KSB7XG4gICAgY29uc3QgZSA9IHQsIG4gPSBHKG51bGwpLCByID0gRyhudWxsKSwgaSA9IEcoZS5kZWZhdWx0T3Blbik7XG4gICAgcmV0dXJuIGh0KFxuICAgICAgKCkgPT4gZS5kZWZhdWx0T3BlbixcbiAgICAgIChzLCBvKSA9PiB7XG4gICAgICAgIHZhciBhO1xuICAgICAgICBzICE9PSBvICYmIHMgIT09IGkudmFsdWUgJiYgKChhID0gbi52YWx1ZSkgPT0gbnVsbCB8fCBhLmVsLmNsaWNrKCkpO1xuICAgICAgfVxuICAgICksIChzLCBvKSA9PiAoWigpLCBrZShSKGJDKSwge1xuICAgICAgcmVmX2tleTogXCJkaXNjbG9zdXJlQnV0dG9uXCIsXG4gICAgICByZWY6IHIsXG4gICAgICBkZWZhdWx0T3Blbjogcy5kZWZhdWx0T3BlblxuICAgIH0sIHtcbiAgICAgIGRlZmF1bHQ6IGNlKCh7IG9wZW46IGEgfSkgPT4gW1xuICAgICAgICBEKFwiZGl2XCIsIHtcbiAgICAgICAgICBjbGFzczogS2UoW1wic2NhbGFyLWFwaS1jbGllbnRfX2l0ZW1cIiwgeyBcInNjYWxhci1hcGktY2xpZW50X19pdGVtLS1vcGVuXCI6IGEgfV0pXG4gICAgICAgIH0sIFtcbiAgICAgICAgICBKKFIodkMpLCB7XG4gICAgICAgICAgICByZWZfa2V5OiBcImNvbGxhcHNlQnV0dG9uXCIsXG4gICAgICAgICAgICByZWY6IG4sXG4gICAgICAgICAgICBjbGFzczogXCJzY2FsYXItYXBpLWNsaWVudF9fdG9nZ2xlXCIsXG4gICAgICAgICAgICBvbkNsaWNrOiBvWzBdIHx8IChvWzBdID0gKGwpID0+IGkudmFsdWUgPSAhaS52YWx1ZSlcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBkZWZhdWx0OiBjZSgoKSA9PiBbXG4gICAgICAgICAgICAgIEQoXCJkaXZcIiwgS1csIFtcbiAgICAgICAgICAgICAgICBEKFwic3BhblwiLCBKVywgRGUocy50aXRsZSksIDEpLFxuICAgICAgICAgICAgICAgIHMuJHNsb3RzLm9wdGlvbnMgJiYgYSA/IChaKCksIG5lKFwiZGl2XCIsIGVNLCBbXG4gICAgICAgICAgICAgICAgICBwdChzLiRzbG90cywgXCJvcHRpb25zXCIpXG4gICAgICAgICAgICAgICAgXSkpIDogc3QoXCJcIiwgITApXG4gICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICB0TVxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBfOiAyXG4gICAgICAgICAgfSwgMTUzNiksXG4gICAgICAgICAgSihSKHlDKSwgbnVsbCwge1xuICAgICAgICAgICAgZGVmYXVsdDogY2UoKCkgPT4gW1xuICAgICAgICAgICAgICBEKFwiZGl2XCIsIG5NLCBbXG4gICAgICAgICAgICAgICAgcHQocy4kc2xvdHMsIFwiZGVmYXVsdFwiKVxuICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBfOiAzXG4gICAgICAgICAgfSlcbiAgICAgICAgXSwgMilcbiAgICAgIF0pLFxuICAgICAgXzogM1xuICAgIH0sIDgsIFtcImRlZmF1bHRPcGVuXCJdKSk7XG4gIH1cbn0pLCByTSA9IHt9LCBpTSA9IHsgY2xhc3M6IFwiY2FyZC1mb3JtXCIgfTtcbmZ1bmN0aW9uIHNNKHQsIGUpIHtcbiAgcmV0dXJuIFooKSwgbmUoXCJmb3JtXCIsIGlNLCBbXG4gICAgcHQodC4kc2xvdHMsIFwiZGVmYXVsdFwiLCB7fSwgdm9pZCAwLCAhMClcbiAgXSk7XG59XG5jb25zdCBvTSA9IC8qIEBfX1BVUkVfXyAqLyBjdChyTSwgW1tcInJlbmRlclwiLCBzTV0sIFtcIl9fc2NvcGVJZFwiLCBcImRhdGEtdi1iYzhjZWE3MVwiXV0pLCBhTSA9IC8qIEBfX1BVUkVfXyAqLyBsZSh7XG4gIF9fbmFtZTogXCJDYXJkRm9ybUJ1dHRvblwiLFxuICBzZXR1cCh0LCB7IGV4cG9zZTogZSB9KSB7XG4gICAgY29uc3QgbiA9IEcoKTtcbiAgICByZXR1cm4gZSh7IGVsOiBuIH0pLCAociwgaSkgPT4gKFooKSwgbmUoXCJidXR0b25cIiwge1xuICAgICAgcmVmX2tleTogXCJlbFwiLFxuICAgICAgcmVmOiBuLFxuICAgICAgY2xhc3M6IFwiY2FyZC1mb3JtLWJ1dHRvblwiLFxuICAgICAgdHlwZTogXCJidXR0b25cIlxuICAgIH0sIFtcbiAgICAgIHB0KHIuJHNsb3RzLCBcImRlZmF1bHRcIiwge30sIHZvaWQgMCwgITApXG4gICAgXSwgNTEyKSk7XG4gIH1cbn0pLCB4UCA9IC8qIEBfX1BVUkVfXyAqLyBjdChhTSwgW1tcIl9fc2NvcGVJZFwiLCBcImRhdGEtdi02YWUwNTNlOVwiXV0pLCBsTSA9IHt9LCBjTSA9IHsgY2xhc3M6IFwiY2FyZC1mb3JtLWdyb3VwXCIgfTtcbmZ1bmN0aW9uIHVNKHQsIGUpIHtcbiAgcmV0dXJuIFooKSwgbmUoXCJkaXZcIiwgY00sIFtcbiAgICBwdCh0LiRzbG90cywgXCJkZWZhdWx0XCIsIHt9LCB2b2lkIDAsICEwKVxuICBdKTtcbn1cbmNvbnN0IE4wID0gLyogQF9fUFVSRV9fICovIGN0KGxNLCBbW1wicmVuZGVyXCIsIHVNXSwgW1wiX19zY29wZUlkXCIsIFwiZGF0YS12LTZiNWQyMTk0XCJdXSk7XG5mdW5jdGlvbiBQUCh0KSB7XG4gIHZhciBlLCBuLCByID0gXCJcIjtcbiAgaWYgKHR5cGVvZiB0ID09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHQgPT0gXCJudW1iZXJcIilcbiAgICByICs9IHQ7XG4gIGVsc2UgaWYgKHR5cGVvZiB0ID09IFwib2JqZWN0XCIpXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodCkpXG4gICAgICBmb3IgKGUgPSAwOyBlIDwgdC5sZW5ndGg7IGUrKylcbiAgICAgICAgdFtlXSAmJiAobiA9IFBQKHRbZV0pKSAmJiAociAmJiAociArPSBcIiBcIiksIHIgKz0gbik7XG4gICAgZWxzZVxuICAgICAgZm9yIChlIGluIHQpXG4gICAgICAgIHRbZV0gJiYgKHIgJiYgKHIgKz0gXCIgXCIpLCByICs9IGUpO1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIEpmKCkge1xuICBmb3IgKHZhciB0LCBlLCBuID0gMCwgciA9IFwiXCI7IG4gPCBhcmd1bWVudHMubGVuZ3RoOyApXG4gICAgKHQgPSBhcmd1bWVudHNbbisrXSkgJiYgKGUgPSBQUCh0KSkgJiYgKHIgJiYgKHIgKz0gXCIgXCIpLCByICs9IGUpO1xuICByZXR1cm4gcjtcbn1cbmNvbnN0IEQwID0gKHQpID0+IHR5cGVvZiB0ID09IFwiYm9vbGVhblwiID8gXCJcIi5jb25jYXQodCkgOiB0ID09PSAwID8gXCIwXCIgOiB0LCBkTSA9ICh0KSA9PiB7XG4gIGNvbnN0IGUgPSBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCwgcyA9IG5ldyBBcnJheShpKSwgbyA9IDA7IG8gPCBpOyBvKyspXG4gICAgICBzW29dID0gYXJndW1lbnRzW29dO1xuICAgIHZhciBhLCBsO1xuICAgIHJldHVybiB0eXBlb2YgKHQgPT0gbnVsbCB8fCAoYSA9IHQuaG9va3MpID09PSBudWxsIHx8IGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFbXCJjeDpkb25lXCJdKSA8IFwidVwiID8gdCA9PSBudWxsID8gdm9pZCAwIDogdC5ob29rc1tcImN4OmRvbmVcIl0oSmYocykpIDogdHlwZW9mICh0ID09IG51bGwgfHwgKGwgPSB0Lmhvb2tzKSA9PT0gbnVsbCB8fCBsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsLm9uQ29tcGxldGUpIDwgXCJ1XCIgPyB0ID09IG51bGwgPyB2b2lkIDAgOiB0Lmhvb2tzLm9uQ29tcGxldGUoSmYocykpIDogSmYocyk7XG4gIH07XG4gIHJldHVybiB7IGNvbXBvc2U6IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoLCBzID0gbmV3IEFycmF5KGkpLCBvID0gMDsgbyA8IGk7IG8rKylcbiAgICAgIHNbb10gPSBhcmd1bWVudHNbb107XG4gICAgcmV0dXJuIChhKSA9PiB7XG4gICAgICBjb25zdCBsID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGEgfHwge30pLmZpbHRlcigoYykgPT4ge1xuICAgICAgICBsZXQgW3VdID0gYztcbiAgICAgICAgcmV0dXJuICFbXCJjbGFzc1wiLCBcImNsYXNzTmFtZVwiXS5pbmNsdWRlcyh1KTtcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBlKHMubWFwKChjKSA9PiBjKGwpKSwgYSA9PSBudWxsID8gdm9pZCAwIDogYS5jbGFzcywgYSA9PSBudWxsID8gdm9pZCAwIDogYS5jbGFzc05hbWUpO1xuICAgIH07XG4gIH0sIGN2YTogKGkpID0+IChzKSA9PiB7XG4gICAgdmFyIG87XG4gICAgaWYgKChpID09IG51bGwgPyB2b2lkIDAgOiBpLnZhcmlhbnRzKSA9PSBudWxsKVxuICAgICAgcmV0dXJuIGUoaSA9PSBudWxsID8gdm9pZCAwIDogaS5iYXNlLCBzID09IG51bGwgPyB2b2lkIDAgOiBzLmNsYXNzLCBzID09IG51bGwgPyB2b2lkIDAgOiBzLmNsYXNzTmFtZSk7XG4gICAgY29uc3QgeyB2YXJpYW50czogYSwgZGVmYXVsdFZhcmlhbnRzOiBsIH0gPSBpLCBjID0gT2JqZWN0LmtleXMoYSkubWFwKChmKSA9PiB7XG4gICAgICBjb25zdCBoID0gcyA9PSBudWxsID8gdm9pZCAwIDogc1tmXSwgcCA9IGwgPT0gbnVsbCA/IHZvaWQgMCA6IGxbZl0sIE8gPSBEMChoKSB8fCBEMChwKTtcbiAgICAgIHJldHVybiBhW2ZdW09dO1xuICAgIH0pLCB1ID0geyAuLi5sLCAuLi5zICYmIE9iamVjdC5lbnRyaWVzKHMpLnJlZHVjZSgoZiwgaCkgPT4ge1xuICAgICAgbGV0IFtwLCBPXSA9IGg7XG4gICAgICByZXR1cm4gdHlwZW9mIE8gPiBcInVcIiA/IGYgOiB7IC4uLmYsIFtwXTogTyB9O1xuICAgIH0sIHt9KSB9LCBkID0gaSA9PSBudWxsIHx8IChvID0gaS5jb21wb3VuZFZhcmlhbnRzKSA9PT0gbnVsbCB8fCBvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvLnJlZHVjZSgoZiwgaCkgPT4ge1xuICAgICAgbGV0IHsgY2xhc3M6IHAsIGNsYXNzTmFtZTogTywgLi4ubSB9ID0gaDtcbiAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyhtKS5ldmVyeSgoeSkgPT4ge1xuICAgICAgICBsZXQgW2IsIGddID0geTtcbiAgICAgICAgY29uc3QgdiA9IHVbYl07XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KGcpID8gZy5pbmNsdWRlcyh2KSA6IHYgPT09IGc7XG4gICAgICB9KSA/IFsuLi5mLCBwLCBPXSA6IGY7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBlKGkgPT0gbnVsbCA/IHZvaWQgMCA6IGkuYmFzZSwgYywgZCwgcyA9PSBudWxsID8gdm9pZCAwIDogcy5jbGFzcywgcyA9PSBudWxsID8gdm9pZCAwIDogcy5jbGFzc05hbWUpO1xuICB9LCBjeDogZSB9O1xufSwgRWcgPSBcIi1cIjtcbmZ1bmN0aW9uIGZNKHQpIHtcbiAgY29uc3QgZSA9IHBNKHQpLCB7XG4gICAgY29uZmxpY3RpbmdDbGFzc0dyb3VwczogbixcbiAgICBjb25mbGljdGluZ0NsYXNzR3JvdXBNb2RpZmllcnM6IHJcbiAgfSA9IHQ7XG4gIGZ1bmN0aW9uIGkobykge1xuICAgIGNvbnN0IGEgPSBvLnNwbGl0KEVnKTtcbiAgICByZXR1cm4gYVswXSA9PT0gXCJcIiAmJiBhLmxlbmd0aCAhPT0gMSAmJiBhLnNoaWZ0KCksIF9QKGEsIGUpIHx8IGhNKG8pO1xuICB9XG4gIGZ1bmN0aW9uIHMobywgYSkge1xuICAgIGNvbnN0IGwgPSBuW29dIHx8IFtdO1xuICAgIHJldHVybiBhICYmIHJbb10gPyBbLi4ubCwgLi4ucltvXV0gOiBsO1xuICB9XG4gIHJldHVybiB7XG4gICAgZ2V0Q2xhc3NHcm91cElkOiBpLFxuICAgIGdldENvbmZsaWN0aW5nQ2xhc3NHcm91cElkczogc1xuICB9O1xufVxuZnVuY3Rpb24gX1AodCwgZSkge1xuICB2YXIgbjtcbiAgaWYgKHQubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBlLmNsYXNzR3JvdXBJZDtcbiAgY29uc3QgciA9IHRbMF0sIGkgPSBlLm5leHRQYXJ0LmdldChyKSwgcyA9IGkgPyBfUCh0LnNsaWNlKDEpLCBpKSA6IHZvaWQgMDtcbiAgaWYgKHMpXG4gICAgcmV0dXJuIHM7XG4gIGlmIChlLnZhbGlkYXRvcnMubGVuZ3RoID09PSAwKVxuICAgIHJldHVybjtcbiAgY29uc3QgbyA9IHQuam9pbihFZyk7XG4gIHJldHVybiAobiA9IGUudmFsaWRhdG9ycy5maW5kKCh7XG4gICAgdmFsaWRhdG9yOiBhXG4gIH0pID0+IGEobykpKSA9PSBudWxsID8gdm9pZCAwIDogbi5jbGFzc0dyb3VwSWQ7XG59XG5jb25zdCBaMCA9IC9eXFxbKC4rKVxcXSQvO1xuZnVuY3Rpb24gaE0odCkge1xuICBpZiAoWjAudGVzdCh0KSkge1xuICAgIGNvbnN0IGUgPSBaMC5leGVjKHQpWzFdLCBuID0gZSA9PSBudWxsID8gdm9pZCAwIDogZS5zdWJzdHJpbmcoMCwgZS5pbmRleE9mKFwiOlwiKSk7XG4gICAgaWYgKG4pXG4gICAgICByZXR1cm4gXCJhcmJpdHJhcnkuLlwiICsgbjtcbiAgfVxufVxuZnVuY3Rpb24gcE0odCkge1xuICBjb25zdCB7XG4gICAgdGhlbWU6IGUsXG4gICAgcHJlZml4OiBuXG4gIH0gPSB0LCByID0ge1xuICAgIG5leHRQYXJ0OiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgIHZhbGlkYXRvcnM6IFtdXG4gIH07XG4gIHJldHVybiBnTShPYmplY3QuZW50cmllcyh0LmNsYXNzR3JvdXBzKSwgbikuZm9yRWFjaCgoW3MsIG9dKSA9PiB7XG4gICAgSXAobywgciwgcywgZSk7XG4gIH0pLCByO1xufVxuZnVuY3Rpb24gSXAodCwgZSwgbiwgcikge1xuICB0LmZvckVhY2goKGkpID0+IHtcbiAgICBpZiAodHlwZW9mIGkgPT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3QgcyA9IGkgPT09IFwiXCIgPyBlIDogVjAoZSwgaSk7XG4gICAgICBzLmNsYXNzR3JvdXBJZCA9IG47XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGlmIChPTShpKSkge1xuICAgICAgICBJcChpKHIpLCBlLCBuLCByKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZS52YWxpZGF0b3JzLnB1c2goe1xuICAgICAgICB2YWxpZGF0b3I6IGksXG4gICAgICAgIGNsYXNzR3JvdXBJZDogblxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIE9iamVjdC5lbnRyaWVzKGkpLmZvckVhY2goKFtzLCBvXSkgPT4ge1xuICAgICAgSXAobywgVjAoZSwgcyksIG4sIHIpO1xuICAgIH0pO1xuICB9KTtcbn1cbmZ1bmN0aW9uIFYwKHQsIGUpIHtcbiAgbGV0IG4gPSB0O1xuICByZXR1cm4gZS5zcGxpdChFZykuZm9yRWFjaCgocikgPT4ge1xuICAgIG4ubmV4dFBhcnQuaGFzKHIpIHx8IG4ubmV4dFBhcnQuc2V0KHIsIHtcbiAgICAgIG5leHRQYXJ0OiAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLFxuICAgICAgdmFsaWRhdG9yczogW11cbiAgICB9KSwgbiA9IG4ubmV4dFBhcnQuZ2V0KHIpO1xuICB9KSwgbjtcbn1cbmZ1bmN0aW9uIE9NKHQpIHtcbiAgcmV0dXJuIHQuaXNUaGVtZUdldHRlcjtcbn1cbmZ1bmN0aW9uIGdNKHQsIGUpIHtcbiAgcmV0dXJuIGUgPyB0Lm1hcCgoW24sIHJdKSA9PiB7XG4gICAgY29uc3QgaSA9IHIubWFwKChzKSA9PiB0eXBlb2YgcyA9PSBcInN0cmluZ1wiID8gZSArIHMgOiB0eXBlb2YgcyA9PSBcIm9iamVjdFwiID8gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHMpLm1hcCgoW28sIGFdKSA9PiBbZSArIG8sIGFdKSkgOiBzKTtcbiAgICByZXR1cm4gW24sIGldO1xuICB9KSA6IHQ7XG59XG5mdW5jdGlvbiBtTSh0KSB7XG4gIGlmICh0IDwgMSlcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0OiAoKSA9PiB7XG4gICAgICB9LFxuICAgICAgc2V0OiAoKSA9PiB7XG4gICAgICB9XG4gICAgfTtcbiAgbGV0IGUgPSAwLCBuID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgciA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGZ1bmN0aW9uIGkocywgbykge1xuICAgIG4uc2V0KHMsIG8pLCBlKyssIGUgPiB0ICYmIChlID0gMCwgciA9IG4sIG4gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGdldChzKSB7XG4gICAgICBsZXQgbyA9IG4uZ2V0KHMpO1xuICAgICAgaWYgKG8gIT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuIG87XG4gICAgICBpZiAoKG8gPSByLmdldChzKSkgIT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuIGkocywgbyksIG87XG4gICAgfSxcbiAgICBzZXQocywgbykge1xuICAgICAgbi5oYXMocykgPyBuLnNldChzLCBvKSA6IGkocywgbyk7XG4gICAgfVxuICB9O1xufVxuY29uc3QgVFAgPSBcIiFcIjtcbmZ1bmN0aW9uIGJNKHQpIHtcbiAgY29uc3QgZSA9IHQuc2VwYXJhdG9yLCBuID0gZS5sZW5ndGggPT09IDEsIHIgPSBlWzBdLCBpID0gZS5sZW5ndGg7XG4gIHJldHVybiBmdW5jdGlvbihvKSB7XG4gICAgY29uc3QgYSA9IFtdO1xuICAgIGxldCBsID0gMCwgYyA9IDAsIHU7XG4gICAgZm9yIChsZXQgTyA9IDA7IE8gPCBvLmxlbmd0aDsgTysrKSB7XG4gICAgICBsZXQgbSA9IG9bT107XG4gICAgICBpZiAobCA9PT0gMCkge1xuICAgICAgICBpZiAobSA9PT0gciAmJiAobiB8fCBvLnNsaWNlKE8sIE8gKyBpKSA9PT0gZSkpIHtcbiAgICAgICAgICBhLnB1c2goby5zbGljZShjLCBPKSksIGMgPSBPICsgaTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobSA9PT0gXCIvXCIpIHtcbiAgICAgICAgICB1ID0gTztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbSA9PT0gXCJbXCIgPyBsKysgOiBtID09PSBcIl1cIiAmJiBsLS07XG4gICAgfVxuICAgIGNvbnN0IGQgPSBhLmxlbmd0aCA9PT0gMCA/IG8gOiBvLnN1YnN0cmluZyhjKSwgZiA9IGQuc3RhcnRzV2l0aChUUCksIGggPSBmID8gZC5zdWJzdHJpbmcoMSkgOiBkLCBwID0gdSAmJiB1ID4gYyA/IHUgLSBjIDogdm9pZCAwO1xuICAgIHJldHVybiB7XG4gICAgICBtb2RpZmllcnM6IGEsXG4gICAgICBoYXNJbXBvcnRhbnRNb2RpZmllcjogZixcbiAgICAgIGJhc2VDbGFzc05hbWU6IGgsXG4gICAgICBtYXliZVBvc3RmaXhNb2RpZmllclBvc2l0aW9uOiBwXG4gICAgfTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHZNKHQpIHtcbiAgaWYgKHQubGVuZ3RoIDw9IDEpXG4gICAgcmV0dXJuIHQ7XG4gIGNvbnN0IGUgPSBbXTtcbiAgbGV0IG4gPSBbXTtcbiAgcmV0dXJuIHQuZm9yRWFjaCgocikgPT4ge1xuICAgIHJbMF0gPT09IFwiW1wiID8gKGUucHVzaCguLi5uLnNvcnQoKSwgciksIG4gPSBbXSkgOiBuLnB1c2gocik7XG4gIH0pLCBlLnB1c2goLi4ubi5zb3J0KCkpLCBlO1xufVxuZnVuY3Rpb24geU0odCkge1xuICByZXR1cm4ge1xuICAgIGNhY2hlOiBtTSh0LmNhY2hlU2l6ZSksXG4gICAgc3BsaXRNb2RpZmllcnM6IGJNKHQpLFxuICAgIC4uLmZNKHQpXG4gIH07XG59XG5jb25zdCBTTSA9IC9cXHMrLztcbmZ1bmN0aW9uIHdNKHQsIGUpIHtcbiAgY29uc3Qge1xuICAgIHNwbGl0TW9kaWZpZXJzOiBuLFxuICAgIGdldENsYXNzR3JvdXBJZDogcixcbiAgICBnZXRDb25mbGljdGluZ0NsYXNzR3JvdXBJZHM6IGlcbiAgfSA9IGUsIHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICByZXR1cm4gdC50cmltKCkuc3BsaXQoU00pLm1hcCgobykgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIG1vZGlmaWVyczogYSxcbiAgICAgIGhhc0ltcG9ydGFudE1vZGlmaWVyOiBsLFxuICAgICAgYmFzZUNsYXNzTmFtZTogYyxcbiAgICAgIG1heWJlUG9zdGZpeE1vZGlmaWVyUG9zaXRpb246IHVcbiAgICB9ID0gbihvKTtcbiAgICBsZXQgZCA9IHIodSA/IGMuc3Vic3RyaW5nKDAsIHUpIDogYyksIGYgPSAhIXU7XG4gICAgaWYgKCFkKSB7XG4gICAgICBpZiAoIXUpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNUYWlsd2luZENsYXNzOiAhMSxcbiAgICAgICAgICBvcmlnaW5hbENsYXNzTmFtZTogb1xuICAgICAgICB9O1xuICAgICAgaWYgKGQgPSByKGMpLCAhZClcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RhaWx3aW5kQ2xhc3M6ICExLFxuICAgICAgICAgIG9yaWdpbmFsQ2xhc3NOYW1lOiBvXG4gICAgICAgIH07XG4gICAgICBmID0gITE7XG4gICAgfVxuICAgIGNvbnN0IGggPSB2TShhKS5qb2luKFwiOlwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgaXNUYWlsd2luZENsYXNzOiAhMCxcbiAgICAgIG1vZGlmaWVySWQ6IGwgPyBoICsgVFAgOiBoLFxuICAgICAgY2xhc3NHcm91cElkOiBkLFxuICAgICAgb3JpZ2luYWxDbGFzc05hbWU6IG8sXG4gICAgICBoYXNQb3N0Zml4TW9kaWZpZXI6IGZcbiAgICB9O1xuICB9KS5yZXZlcnNlKCkuZmlsdGVyKChvKSA9PiB7XG4gICAgaWYgKCFvLmlzVGFpbHdpbmRDbGFzcylcbiAgICAgIHJldHVybiAhMDtcbiAgICBjb25zdCB7XG4gICAgICBtb2RpZmllcklkOiBhLFxuICAgICAgY2xhc3NHcm91cElkOiBsLFxuICAgICAgaGFzUG9zdGZpeE1vZGlmaWVyOiBjXG4gICAgfSA9IG8sIHUgPSBhICsgbDtcbiAgICByZXR1cm4gcy5oYXModSkgPyAhMSA6IChzLmFkZCh1KSwgaShsLCBjKS5mb3JFYWNoKChkKSA9PiBzLmFkZChhICsgZCkpLCAhMCk7XG4gIH0pLnJldmVyc2UoKS5tYXAoKG8pID0+IG8ub3JpZ2luYWxDbGFzc05hbWUpLmpvaW4oXCIgXCIpO1xufVxuZnVuY3Rpb24ga00oKSB7XG4gIGxldCB0ID0gMCwgZSwgbiwgciA9IFwiXCI7XG4gIGZvciAoOyB0IDwgYXJndW1lbnRzLmxlbmd0aDsgKVxuICAgIChlID0gYXJndW1lbnRzW3QrK10pICYmIChuID0gRVAoZSkpICYmIChyICYmIChyICs9IFwiIFwiKSwgciArPSBuKTtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBFUCh0KSB7XG4gIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiB0O1xuICBsZXQgZSwgbiA9IFwiXCI7XG4gIGZvciAobGV0IHIgPSAwOyByIDwgdC5sZW5ndGg7IHIrKylcbiAgICB0W3JdICYmIChlID0gRVAodFtyXSkpICYmIChuICYmIChuICs9IFwiIFwiKSwgbiArPSBlKTtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBJMCh0LCAuLi5lKSB7XG4gIGxldCBuLCByLCBpLCBzID0gbztcbiAgZnVuY3Rpb24gbyhsKSB7XG4gICAgY29uc3QgYyA9IGUucmVkdWNlKCh1LCBkKSA9PiBkKHUpLCB0KCkpO1xuICAgIHJldHVybiBuID0geU0oYyksIHIgPSBuLmNhY2hlLmdldCwgaSA9IG4uY2FjaGUuc2V0LCBzID0gYSwgYShsKTtcbiAgfVxuICBmdW5jdGlvbiBhKGwpIHtcbiAgICBjb25zdCBjID0gcihsKTtcbiAgICBpZiAoYylcbiAgICAgIHJldHVybiBjO1xuICAgIGNvbnN0IHUgPSB3TShsLCBuKTtcbiAgICByZXR1cm4gaShsLCB1KSwgdTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHMoa00uYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gIH07XG59XG5mdW5jdGlvbiB1dCh0KSB7XG4gIGNvbnN0IGUgPSAobikgPT4gblt0XSB8fCBbXTtcbiAgcmV0dXJuIGUuaXNUaGVtZUdldHRlciA9ICEwLCBlO1xufVxuY29uc3QgJFAgPSAvXlxcWyg/OihbYS16LV0rKTopPyguKylcXF0kL2ksIHhNID0gL15cXGQrXFwvXFxkKyQvLCBQTSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcInB4XCIsIFwiZnVsbFwiLCBcInNjcmVlblwiXSksIF9NID0gL14oXFxkKyhcXC5cXGQrKT8pPyh4c3xzbXxtZHxsZ3x4bCkkLywgVE0gPSAvXFxkKyglfHB4fHI/ZW18W3NkbF0/dihbaHdpYl18bWlufG1heCl8cHR8cGN8aW58Y218bW18Y2FwfGNofGV4fHI/bGh8Y3Eod3xofGl8YnxtaW58bWF4KSl8XFxiKGNhbGN8bWlufG1heHxjbGFtcClcXCguK1xcKXxeMCQvLCBFTSA9IC9eKHJnYmE/fGhzbGE/fGh3Ynwob2spPyhsYWJ8bGNoKSlcXCguK1xcKSQvLCAkTSA9IC9eKGluc2V0Xyk/LT8oKFxcZCspP1xcLj8oXFxkKylbYS16XSt8MClfLT8oKFxcZCspP1xcLj8oXFxkKylbYS16XSt8MCkvLCBRTSA9IC9eKHVybHxpbWFnZXxpbWFnZS1zZXR8Y3Jvc3MtZmFkZXxlbGVtZW50fChyZXBlYXRpbmctKT8obGluZWFyfHJhZGlhbHxjb25pYyktZ3JhZGllbnQpXFwoLitcXCkkLztcbmZ1bmN0aW9uIHpyKHQpIHtcbiAgcmV0dXJuIEVzKHQpIHx8IFBNLmhhcyh0KSB8fCB4TS50ZXN0KHQpO1xufVxuZnVuY3Rpb24gUGkodCkge1xuICByZXR1cm4gYWEodCwgXCJsZW5ndGhcIiwgSU0pO1xufVxuZnVuY3Rpb24gRXModCkge1xuICByZXR1cm4gISF0ICYmICFOdW1iZXIuaXNOYU4oTnVtYmVyKHQpKTtcbn1cbmZ1bmN0aW9uIEJjKHQpIHtcbiAgcmV0dXJuIGFhKHQsIFwibnVtYmVyXCIsIEVzKTtcbn1cbmZ1bmN0aW9uIF9hKHQpIHtcbiAgcmV0dXJuICEhdCAmJiBOdW1iZXIuaXNJbnRlZ2VyKE51bWJlcih0KSk7XG59XG5mdW5jdGlvbiBDTSh0KSB7XG4gIHJldHVybiB0LmVuZHNXaXRoKFwiJVwiKSAmJiBFcyh0LnNsaWNlKDAsIC0xKSk7XG59XG5mdW5jdGlvbiBUZSh0KSB7XG4gIHJldHVybiAkUC50ZXN0KHQpO1xufVxuZnVuY3Rpb24gX2kodCkge1xuICByZXR1cm4gX00udGVzdCh0KTtcbn1cbmNvbnN0IEFNID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wibGVuZ3RoXCIsIFwic2l6ZVwiLCBcInBlcmNlbnRhZ2VcIl0pO1xuZnVuY3Rpb24gUk0odCkge1xuICByZXR1cm4gYWEodCwgQU0sIFFQKTtcbn1cbmZ1bmN0aW9uIE5NKHQpIHtcbiAgcmV0dXJuIGFhKHQsIFwicG9zaXRpb25cIiwgUVApO1xufVxuY29uc3QgRE0gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJpbWFnZVwiLCBcInVybFwiXSk7XG5mdW5jdGlvbiBaTSh0KSB7XG4gIHJldHVybiBhYSh0LCBETSwgTU0pO1xufVxuZnVuY3Rpb24gVk0odCkge1xuICByZXR1cm4gYWEodCwgXCJcIiwgV00pO1xufVxuZnVuY3Rpb24gVGEoKSB7XG4gIHJldHVybiAhMDtcbn1cbmZ1bmN0aW9uIGFhKHQsIGUsIG4pIHtcbiAgY29uc3QgciA9ICRQLmV4ZWModCk7XG4gIHJldHVybiByID8gclsxXSA/IHR5cGVvZiBlID09IFwic3RyaW5nXCIgPyByWzFdID09PSBlIDogZS5oYXMoclsxXSkgOiBuKHJbMl0pIDogITE7XG59XG5mdW5jdGlvbiBJTSh0KSB7XG4gIHJldHVybiBUTS50ZXN0KHQpICYmICFFTS50ZXN0KHQpO1xufVxuZnVuY3Rpb24gUVAoKSB7XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIFdNKHQpIHtcbiAgcmV0dXJuICRNLnRlc3QodCk7XG59XG5mdW5jdGlvbiBNTSh0KSB7XG4gIHJldHVybiBRTS50ZXN0KHQpO1xufVxuZnVuY3Rpb24gVzAoKSB7XG4gIGNvbnN0IHQgPSB1dChcImNvbG9yc1wiKSwgZSA9IHV0KFwic3BhY2luZ1wiKSwgbiA9IHV0KFwiYmx1clwiKSwgciA9IHV0KFwiYnJpZ2h0bmVzc1wiKSwgaSA9IHV0KFwiYm9yZGVyQ29sb3JcIiksIHMgPSB1dChcImJvcmRlclJhZGl1c1wiKSwgbyA9IHV0KFwiYm9yZGVyU3BhY2luZ1wiKSwgYSA9IHV0KFwiYm9yZGVyV2lkdGhcIiksIGwgPSB1dChcImNvbnRyYXN0XCIpLCBjID0gdXQoXCJncmF5c2NhbGVcIiksIHUgPSB1dChcImh1ZVJvdGF0ZVwiKSwgZCA9IHV0KFwiaW52ZXJ0XCIpLCBmID0gdXQoXCJnYXBcIiksIGggPSB1dChcImdyYWRpZW50Q29sb3JTdG9wc1wiKSwgcCA9IHV0KFwiZ3JhZGllbnRDb2xvclN0b3BQb3NpdGlvbnNcIiksIE8gPSB1dChcImluc2V0XCIpLCBtID0gdXQoXCJtYXJnaW5cIiksIHkgPSB1dChcIm9wYWNpdHlcIiksIGIgPSB1dChcInBhZGRpbmdcIiksIGcgPSB1dChcInNhdHVyYXRlXCIpLCB2ID0gdXQoXCJzY2FsZVwiKSwgUyA9IHV0KFwic2VwaWFcIiksIHcgPSB1dChcInNrZXdcIiksIGsgPSB1dChcInNwYWNlXCIpLCBfID0gdXQoXCJ0cmFuc2xhdGVcIiksIFQgPSAoKSA9PiBbXCJhdXRvXCIsIFwiY29udGFpblwiLCBcIm5vbmVcIl0sIEMgPSAoKSA9PiBbXCJhdXRvXCIsIFwiaGlkZGVuXCIsIFwiY2xpcFwiLCBcInZpc2libGVcIiwgXCJzY3JvbGxcIl0sIEEgPSAoKSA9PiBbXCJhdXRvXCIsIFRlLCBlXSwgUSA9ICgpID0+IFtUZSwgZV0sIFcgPSAoKSA9PiBbXCJcIiwgenIsIFBpXSwgTCA9ICgpID0+IFtcImF1dG9cIiwgRXMsIFRlXSwgcmUgPSAoKSA9PiBbXCJib3R0b21cIiwgXCJjZW50ZXJcIiwgXCJsZWZ0XCIsIFwibGVmdC1ib3R0b21cIiwgXCJsZWZ0LXRvcFwiLCBcInJpZ2h0XCIsIFwicmlnaHQtYm90dG9tXCIsIFwicmlnaHQtdG9wXCIsIFwidG9wXCJdLCBZID0gKCkgPT4gW1wic29saWRcIiwgXCJkYXNoZWRcIiwgXCJkb3R0ZWRcIiwgXCJkb3VibGVcIiwgXCJub25lXCJdLCBLID0gKCkgPT4gW1wibm9ybWFsXCIsIFwibXVsdGlwbHlcIiwgXCJzY3JlZW5cIiwgXCJvdmVybGF5XCIsIFwiZGFya2VuXCIsIFwibGlnaHRlblwiLCBcImNvbG9yLWRvZGdlXCIsIFwiY29sb3ItYnVyblwiLCBcImhhcmQtbGlnaHRcIiwgXCJzb2Z0LWxpZ2h0XCIsIFwiZGlmZmVyZW5jZVwiLCBcImV4Y2x1c2lvblwiLCBcImh1ZVwiLCBcInNhdHVyYXRpb25cIiwgXCJjb2xvclwiLCBcImx1bWlub3NpdHlcIl0sIEIgPSAoKSA9PiBbXCJzdGFydFwiLCBcImVuZFwiLCBcImNlbnRlclwiLCBcImJldHdlZW5cIiwgXCJhcm91bmRcIiwgXCJldmVubHlcIiwgXCJzdHJldGNoXCJdLCBfZSA9ICgpID0+IFtcIlwiLCBcIjBcIiwgVGVdLCBDZSA9ICgpID0+IFtcImF1dG9cIiwgXCJhdm9pZFwiLCBcImFsbFwiLCBcImF2b2lkLXBhZ2VcIiwgXCJwYWdlXCIsIFwibGVmdFwiLCBcInJpZ2h0XCIsIFwiY29sdW1uXCJdLCB1ZSA9ICgpID0+IFtFcywgQmNdLCBnZSA9ICgpID0+IFtFcywgVGVdO1xuICByZXR1cm4ge1xuICAgIGNhY2hlU2l6ZTogNTAwLFxuICAgIHNlcGFyYXRvcjogXCI6XCIsXG4gICAgdGhlbWU6IHtcbiAgICAgIGNvbG9yczogW1RhXSxcbiAgICAgIHNwYWNpbmc6IFt6ciwgUGldLFxuICAgICAgYmx1cjogW1wibm9uZVwiLCBcIlwiLCBfaSwgVGVdLFxuICAgICAgYnJpZ2h0bmVzczogdWUoKSxcbiAgICAgIGJvcmRlckNvbG9yOiBbdF0sXG4gICAgICBib3JkZXJSYWRpdXM6IFtcIm5vbmVcIiwgXCJcIiwgXCJmdWxsXCIsIF9pLCBUZV0sXG4gICAgICBib3JkZXJTcGFjaW5nOiBRKCksXG4gICAgICBib3JkZXJXaWR0aDogVygpLFxuICAgICAgY29udHJhc3Q6IHVlKCksXG4gICAgICBncmF5c2NhbGU6IF9lKCksXG4gICAgICBodWVSb3RhdGU6IGdlKCksXG4gICAgICBpbnZlcnQ6IF9lKCksXG4gICAgICBnYXA6IFEoKSxcbiAgICAgIGdyYWRpZW50Q29sb3JTdG9wczogW3RdLFxuICAgICAgZ3JhZGllbnRDb2xvclN0b3BQb3NpdGlvbnM6IFtDTSwgUGldLFxuICAgICAgaW5zZXQ6IEEoKSxcbiAgICAgIG1hcmdpbjogQSgpLFxuICAgICAgb3BhY2l0eTogdWUoKSxcbiAgICAgIHBhZGRpbmc6IFEoKSxcbiAgICAgIHNhdHVyYXRlOiB1ZSgpLFxuICAgICAgc2NhbGU6IHVlKCksXG4gICAgICBzZXBpYTogX2UoKSxcbiAgICAgIHNrZXc6IGdlKCksXG4gICAgICBzcGFjZTogUSgpLFxuICAgICAgdHJhbnNsYXRlOiBRKClcbiAgICB9LFxuICAgIGNsYXNzR3JvdXBzOiB7XG4gICAgICAvLyBMYXlvdXRcbiAgICAgIC8qKlxuICAgICAgICogQXNwZWN0IFJhdGlvXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYXNwZWN0LXJhdGlvXG4gICAgICAgKi9cbiAgICAgIGFzcGVjdDogW3tcbiAgICAgICAgYXNwZWN0OiBbXCJhdXRvXCIsIFwic3F1YXJlXCIsIFwidmlkZW9cIiwgVGVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQ29udGFpbmVyXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvY29udGFpbmVyXG4gICAgICAgKi9cbiAgICAgIGNvbnRhaW5lcjogW1wiY29udGFpbmVyXCJdLFxuICAgICAgLyoqXG4gICAgICAgKiBDb2x1bW5zXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvY29sdW1uc1xuICAgICAgICovXG4gICAgICBjb2x1bW5zOiBbe1xuICAgICAgICBjb2x1bW5zOiBbX2ldXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQnJlYWsgQWZ0ZXJcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9icmVhay1hZnRlclxuICAgICAgICovXG4gICAgICBcImJyZWFrLWFmdGVyXCI6IFt7XG4gICAgICAgIFwiYnJlYWstYWZ0ZXJcIjogQ2UoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJyZWFrIEJlZm9yZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JyZWFrLWJlZm9yZVxuICAgICAgICovXG4gICAgICBcImJyZWFrLWJlZm9yZVwiOiBbe1xuICAgICAgICBcImJyZWFrLWJlZm9yZVwiOiBDZSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQnJlYWsgSW5zaWRlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYnJlYWstaW5zaWRlXG4gICAgICAgKi9cbiAgICAgIFwiYnJlYWstaW5zaWRlXCI6IFt7XG4gICAgICAgIFwiYnJlYWstaW5zaWRlXCI6IFtcImF1dG9cIiwgXCJhdm9pZFwiLCBcImF2b2lkLXBhZ2VcIiwgXCJhdm9pZC1jb2x1bW5cIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3ggRGVjb3JhdGlvbiBCcmVha1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JveC1kZWNvcmF0aW9uLWJyZWFrXG4gICAgICAgKi9cbiAgICAgIFwiYm94LWRlY29yYXRpb25cIjogW3tcbiAgICAgICAgXCJib3gtZGVjb3JhdGlvblwiOiBbXCJzbGljZVwiLCBcImNsb25lXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm94IFNpemluZ1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JveC1zaXppbmdcbiAgICAgICAqL1xuICAgICAgYm94OiBbe1xuICAgICAgICBib3g6IFtcImJvcmRlclwiLCBcImNvbnRlbnRcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBEaXNwbGF5XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZGlzcGxheVxuICAgICAgICovXG4gICAgICBkaXNwbGF5OiBbXCJibG9ja1wiLCBcImlubGluZS1ibG9ja1wiLCBcImlubGluZVwiLCBcImZsZXhcIiwgXCJpbmxpbmUtZmxleFwiLCBcInRhYmxlXCIsIFwiaW5saW5lLXRhYmxlXCIsIFwidGFibGUtY2FwdGlvblwiLCBcInRhYmxlLWNlbGxcIiwgXCJ0YWJsZS1jb2x1bW5cIiwgXCJ0YWJsZS1jb2x1bW4tZ3JvdXBcIiwgXCJ0YWJsZS1mb290ZXItZ3JvdXBcIiwgXCJ0YWJsZS1oZWFkZXItZ3JvdXBcIiwgXCJ0YWJsZS1yb3ctZ3JvdXBcIiwgXCJ0YWJsZS1yb3dcIiwgXCJmbG93LXJvb3RcIiwgXCJncmlkXCIsIFwiaW5saW5lLWdyaWRcIiwgXCJjb250ZW50c1wiLCBcImxpc3QtaXRlbVwiLCBcImhpZGRlblwiXSxcbiAgICAgIC8qKlxuICAgICAgICogRmxvYXRzXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZmxvYXRcbiAgICAgICAqL1xuICAgICAgZmxvYXQ6IFt7XG4gICAgICAgIGZsb2F0OiBbXCJyaWdodFwiLCBcImxlZnRcIiwgXCJub25lXCIsIFwic3RhcnRcIiwgXCJlbmRcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBDbGVhclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2NsZWFyXG4gICAgICAgKi9cbiAgICAgIGNsZWFyOiBbe1xuICAgICAgICBjbGVhcjogW1wibGVmdFwiLCBcInJpZ2h0XCIsIFwiYm90aFwiLCBcIm5vbmVcIiwgXCJzdGFydFwiLCBcImVuZFwiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIElzb2xhdGlvblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2lzb2xhdGlvblxuICAgICAgICovXG4gICAgICBpc29sYXRpb246IFtcImlzb2xhdGVcIiwgXCJpc29sYXRpb24tYXV0b1wiXSxcbiAgICAgIC8qKlxuICAgICAgICogT2JqZWN0IEZpdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL29iamVjdC1maXRcbiAgICAgICAqL1xuICAgICAgXCJvYmplY3QtZml0XCI6IFt7XG4gICAgICAgIG9iamVjdDogW1wiY29udGFpblwiLCBcImNvdmVyXCIsIFwiZmlsbFwiLCBcIm5vbmVcIiwgXCJzY2FsZS1kb3duXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT2JqZWN0IFBvc2l0aW9uXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb2JqZWN0LXBvc2l0aW9uXG4gICAgICAgKi9cbiAgICAgIFwib2JqZWN0LXBvc2l0aW9uXCI6IFt7XG4gICAgICAgIG9iamVjdDogWy4uLnJlKCksIFRlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE92ZXJmbG93XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3ZlcmZsb3dcbiAgICAgICAqL1xuICAgICAgb3ZlcmZsb3c6IFt7XG4gICAgICAgIG92ZXJmbG93OiBDKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBPdmVyZmxvdyBYXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3ZlcmZsb3dcbiAgICAgICAqL1xuICAgICAgXCJvdmVyZmxvdy14XCI6IFt7XG4gICAgICAgIFwib3ZlcmZsb3cteFwiOiBDKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBPdmVyZmxvdyBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3ZlcmZsb3dcbiAgICAgICAqL1xuICAgICAgXCJvdmVyZmxvdy15XCI6IFt7XG4gICAgICAgIFwib3ZlcmZsb3cteVwiOiBDKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBPdmVyc2Nyb2xsIEJlaGF2aW9yXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3ZlcnNjcm9sbC1iZWhhdmlvclxuICAgICAgICovXG4gICAgICBvdmVyc2Nyb2xsOiBbe1xuICAgICAgICBvdmVyc2Nyb2xsOiBUKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBPdmVyc2Nyb2xsIEJlaGF2aW9yIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9vdmVyc2Nyb2xsLWJlaGF2aW9yXG4gICAgICAgKi9cbiAgICAgIFwib3ZlcnNjcm9sbC14XCI6IFt7XG4gICAgICAgIFwib3ZlcnNjcm9sbC14XCI6IFQoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE92ZXJzY3JvbGwgQmVoYXZpb3IgWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL292ZXJzY3JvbGwtYmVoYXZpb3JcbiAgICAgICAqL1xuICAgICAgXCJvdmVyc2Nyb2xsLXlcIjogW3tcbiAgICAgICAgXCJvdmVyc2Nyb2xsLXlcIjogVCgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUG9zaXRpb25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wb3NpdGlvblxuICAgICAgICovXG4gICAgICBwb3NpdGlvbjogW1wic3RhdGljXCIsIFwiZml4ZWRcIiwgXCJhYnNvbHV0ZVwiLCBcInJlbGF0aXZlXCIsIFwic3RpY2t5XCJdLFxuICAgICAgLyoqXG4gICAgICAgKiBUb3AgLyBSaWdodCAvIEJvdHRvbSAvIExlZnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90b3AtcmlnaHQtYm90dG9tLWxlZnRcbiAgICAgICAqL1xuICAgICAgaW5zZXQ6IFt7XG4gICAgICAgIGluc2V0OiBbT11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBSaWdodCAvIExlZnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90b3AtcmlnaHQtYm90dG9tLWxlZnRcbiAgICAgICAqL1xuICAgICAgXCJpbnNldC14XCI6IFt7XG4gICAgICAgIFwiaW5zZXQteFwiOiBbT11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUb3AgLyBCb3R0b21cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90b3AtcmlnaHQtYm90dG9tLWxlZnRcbiAgICAgICAqL1xuICAgICAgXCJpbnNldC15XCI6IFt7XG4gICAgICAgIFwiaW5zZXQteVwiOiBbT11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTdGFydFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvcC1yaWdodC1ib3R0b20tbGVmdFxuICAgICAgICovXG4gICAgICBzdGFydDogW3tcbiAgICAgICAgc3RhcnQ6IFtPXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEVuZFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvcC1yaWdodC1ib3R0b20tbGVmdFxuICAgICAgICovXG4gICAgICBlbmQ6IFt7XG4gICAgICAgIGVuZDogW09dXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVG9wXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdG9wLXJpZ2h0LWJvdHRvbS1sZWZ0XG4gICAgICAgKi9cbiAgICAgIHRvcDogW3tcbiAgICAgICAgdG9wOiBbT11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBSaWdodFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvcC1yaWdodC1ib3R0b20tbGVmdFxuICAgICAgICovXG4gICAgICByaWdodDogW3tcbiAgICAgICAgcmlnaHQ6IFtPXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvdHRvbVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvcC1yaWdodC1ib3R0b20tbGVmdFxuICAgICAgICovXG4gICAgICBib3R0b206IFt7XG4gICAgICAgIGJvdHRvbTogW09dXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTGVmdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvcC1yaWdodC1ib3R0b20tbGVmdFxuICAgICAgICovXG4gICAgICBsZWZ0OiBbe1xuICAgICAgICBsZWZ0OiBbT11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBWaXNpYmlsaXR5XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdmlzaWJpbGl0eVxuICAgICAgICovXG4gICAgICB2aXNpYmlsaXR5OiBbXCJ2aXNpYmxlXCIsIFwiaW52aXNpYmxlXCIsIFwiY29sbGFwc2VcIl0sXG4gICAgICAvKipcbiAgICAgICAqIFotSW5kZXhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy96LWluZGV4XG4gICAgICAgKi9cbiAgICAgIHo6IFt7XG4gICAgICAgIHo6IFtcImF1dG9cIiwgX2EsIFRlXVxuICAgICAgfV0sXG4gICAgICAvLyBGbGV4Ym94IGFuZCBHcmlkXG4gICAgICAvKipcbiAgICAgICAqIEZsZXggQmFzaXNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mbGV4LWJhc2lzXG4gICAgICAgKi9cbiAgICAgIGJhc2lzOiBbe1xuICAgICAgICBiYXNpczogQSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRmxleCBEaXJlY3Rpb25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mbGV4LWRpcmVjdGlvblxuICAgICAgICovXG4gICAgICBcImZsZXgtZGlyZWN0aW9uXCI6IFt7XG4gICAgICAgIGZsZXg6IFtcInJvd1wiLCBcInJvdy1yZXZlcnNlXCIsIFwiY29sXCIsIFwiY29sLXJldmVyc2VcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBGbGV4IFdyYXBcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mbGV4LXdyYXBcbiAgICAgICAqL1xuICAgICAgXCJmbGV4LXdyYXBcIjogW3tcbiAgICAgICAgZmxleDogW1wid3JhcFwiLCBcIndyYXAtcmV2ZXJzZVwiLCBcIm5vd3JhcFwiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEZsZXhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mbGV4XG4gICAgICAgKi9cbiAgICAgIGZsZXg6IFt7XG4gICAgICAgIGZsZXg6IFtcIjFcIiwgXCJhdXRvXCIsIFwiaW5pdGlhbFwiLCBcIm5vbmVcIiwgVGVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRmxleCBHcm93XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZmxleC1ncm93XG4gICAgICAgKi9cbiAgICAgIGdyb3c6IFt7XG4gICAgICAgIGdyb3c6IF9lKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBGbGV4IFNocmlua1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZsZXgtc2hyaW5rXG4gICAgICAgKi9cbiAgICAgIHNocmluazogW3tcbiAgICAgICAgc2hyaW5rOiBfZSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3JkZXJcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9vcmRlclxuICAgICAgICovXG4gICAgICBvcmRlcjogW3tcbiAgICAgICAgb3JkZXI6IFtcImZpcnN0XCIsIFwibGFzdFwiLCBcIm5vbmVcIiwgX2EsIFRlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyaWQgVGVtcGxhdGUgQ29sdW1uc1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyaWQtdGVtcGxhdGUtY29sdW1uc1xuICAgICAgICovXG4gICAgICBcImdyaWQtY29sc1wiOiBbe1xuICAgICAgICBcImdyaWQtY29sc1wiOiBbVGFdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JpZCBDb2x1bW4gU3RhcnQgLyBFbmRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmlkLWNvbHVtblxuICAgICAgICovXG4gICAgICBcImNvbC1zdGFydC1lbmRcIjogW3tcbiAgICAgICAgY29sOiBbXCJhdXRvXCIsIHtcbiAgICAgICAgICBzcGFuOiBbXCJmdWxsXCIsIF9hLCBUZV1cbiAgICAgICAgfSwgVGVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JpZCBDb2x1bW4gU3RhcnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmlkLWNvbHVtblxuICAgICAgICovXG4gICAgICBcImNvbC1zdGFydFwiOiBbe1xuICAgICAgICBcImNvbC1zdGFydFwiOiBMKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmlkIENvbHVtbiBFbmRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmlkLWNvbHVtblxuICAgICAgICovXG4gICAgICBcImNvbC1lbmRcIjogW3tcbiAgICAgICAgXCJjb2wtZW5kXCI6IEwoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyaWQgVGVtcGxhdGUgUm93c1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyaWQtdGVtcGxhdGUtcm93c1xuICAgICAgICovXG4gICAgICBcImdyaWQtcm93c1wiOiBbe1xuICAgICAgICBcImdyaWQtcm93c1wiOiBbVGFdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JpZCBSb3cgU3RhcnQgLyBFbmRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmlkLXJvd1xuICAgICAgICovXG4gICAgICBcInJvdy1zdGFydC1lbmRcIjogW3tcbiAgICAgICAgcm93OiBbXCJhdXRvXCIsIHtcbiAgICAgICAgICBzcGFuOiBbX2EsIFRlXVxuICAgICAgICB9LCBUZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmlkIFJvdyBTdGFydFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyaWQtcm93XG4gICAgICAgKi9cbiAgICAgIFwicm93LXN0YXJ0XCI6IFt7XG4gICAgICAgIFwicm93LXN0YXJ0XCI6IEwoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyaWQgUm93IEVuZFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyaWQtcm93XG4gICAgICAgKi9cbiAgICAgIFwicm93LWVuZFwiOiBbe1xuICAgICAgICBcInJvdy1lbmRcIjogTCgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JpZCBBdXRvIEZsb3dcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmlkLWF1dG8tZmxvd1xuICAgICAgICovXG4gICAgICBcImdyaWQtZmxvd1wiOiBbe1xuICAgICAgICBcImdyaWQtZmxvd1wiOiBbXCJyb3dcIiwgXCJjb2xcIiwgXCJkZW5zZVwiLCBcInJvdy1kZW5zZVwiLCBcImNvbC1kZW5zZVwiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyaWQgQXV0byBDb2x1bW5zXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JpZC1hdXRvLWNvbHVtbnNcbiAgICAgICAqL1xuICAgICAgXCJhdXRvLWNvbHNcIjogW3tcbiAgICAgICAgXCJhdXRvLWNvbHNcIjogW1wiYXV0b1wiLCBcIm1pblwiLCBcIm1heFwiLCBcImZyXCIsIFRlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyaWQgQXV0byBSb3dzXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JpZC1hdXRvLXJvd3NcbiAgICAgICAqL1xuICAgICAgXCJhdXRvLXJvd3NcIjogW3tcbiAgICAgICAgXCJhdXRvLXJvd3NcIjogW1wiYXV0b1wiLCBcIm1pblwiLCBcIm1heFwiLCBcImZyXCIsIFRlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdhcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dhcFxuICAgICAgICovXG4gICAgICBnYXA6IFt7XG4gICAgICAgIGdhcDogW2ZdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR2FwIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9nYXBcbiAgICAgICAqL1xuICAgICAgXCJnYXAteFwiOiBbe1xuICAgICAgICBcImdhcC14XCI6IFtmXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdhcCBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ2FwXG4gICAgICAgKi9cbiAgICAgIFwiZ2FwLXlcIjogW3tcbiAgICAgICAgXCJnYXAteVwiOiBbZl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBKdXN0aWZ5IENvbnRlbnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9qdXN0aWZ5LWNvbnRlbnRcbiAgICAgICAqL1xuICAgICAgXCJqdXN0aWZ5LWNvbnRlbnRcIjogW3tcbiAgICAgICAganVzdGlmeTogW1wibm9ybWFsXCIsIC4uLkIoKV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBKdXN0aWZ5IEl0ZW1zXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvanVzdGlmeS1pdGVtc1xuICAgICAgICovXG4gICAgICBcImp1c3RpZnktaXRlbXNcIjogW3tcbiAgICAgICAgXCJqdXN0aWZ5LWl0ZW1zXCI6IFtcInN0YXJ0XCIsIFwiZW5kXCIsIFwiY2VudGVyXCIsIFwic3RyZXRjaFwiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEp1c3RpZnkgU2VsZlxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2p1c3RpZnktc2VsZlxuICAgICAgICovXG4gICAgICBcImp1c3RpZnktc2VsZlwiOiBbe1xuICAgICAgICBcImp1c3RpZnktc2VsZlwiOiBbXCJhdXRvXCIsIFwic3RhcnRcIiwgXCJlbmRcIiwgXCJjZW50ZXJcIiwgXCJzdHJldGNoXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQWxpZ24gQ29udGVudFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2FsaWduLWNvbnRlbnRcbiAgICAgICAqL1xuICAgICAgXCJhbGlnbi1jb250ZW50XCI6IFt7XG4gICAgICAgIGNvbnRlbnQ6IFtcIm5vcm1hbFwiLCAuLi5CKCksIFwiYmFzZWxpbmVcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBBbGlnbiBJdGVtc1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2FsaWduLWl0ZW1zXG4gICAgICAgKi9cbiAgICAgIFwiYWxpZ24taXRlbXNcIjogW3tcbiAgICAgICAgaXRlbXM6IFtcInN0YXJ0XCIsIFwiZW5kXCIsIFwiY2VudGVyXCIsIFwiYmFzZWxpbmVcIiwgXCJzdHJldGNoXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQWxpZ24gU2VsZlxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2FsaWduLXNlbGZcbiAgICAgICAqL1xuICAgICAgXCJhbGlnbi1zZWxmXCI6IFt7XG4gICAgICAgIHNlbGY6IFtcImF1dG9cIiwgXCJzdGFydFwiLCBcImVuZFwiLCBcImNlbnRlclwiLCBcInN0cmV0Y2hcIiwgXCJiYXNlbGluZVwiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFBsYWNlIENvbnRlbnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wbGFjZS1jb250ZW50XG4gICAgICAgKi9cbiAgICAgIFwicGxhY2UtY29udGVudFwiOiBbe1xuICAgICAgICBcInBsYWNlLWNvbnRlbnRcIjogWy4uLkIoKSwgXCJiYXNlbGluZVwiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFBsYWNlIEl0ZW1zXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcGxhY2UtaXRlbXNcbiAgICAgICAqL1xuICAgICAgXCJwbGFjZS1pdGVtc1wiOiBbe1xuICAgICAgICBcInBsYWNlLWl0ZW1zXCI6IFtcInN0YXJ0XCIsIFwiZW5kXCIsIFwiY2VudGVyXCIsIFwiYmFzZWxpbmVcIiwgXCJzdHJldGNoXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUGxhY2UgU2VsZlxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BsYWNlLXNlbGZcbiAgICAgICAqL1xuICAgICAgXCJwbGFjZS1zZWxmXCI6IFt7XG4gICAgICAgIFwicGxhY2Utc2VsZlwiOiBbXCJhdXRvXCIsIFwic3RhcnRcIiwgXCJlbmRcIiwgXCJjZW50ZXJcIiwgXCJzdHJldGNoXCJdXG4gICAgICB9XSxcbiAgICAgIC8vIFNwYWNpbmdcbiAgICAgIC8qKlxuICAgICAgICogUGFkZGluZ1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BhZGRpbmdcbiAgICAgICAqL1xuICAgICAgcDogW3tcbiAgICAgICAgcDogW2JdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUGFkZGluZyBYXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcGFkZGluZ1xuICAgICAgICovXG4gICAgICBweDogW3tcbiAgICAgICAgcHg6IFtiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFBhZGRpbmcgWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BhZGRpbmdcbiAgICAgICAqL1xuICAgICAgcHk6IFt7XG4gICAgICAgIHB5OiBbYl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQYWRkaW5nIFN0YXJ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcGFkZGluZ1xuICAgICAgICovXG4gICAgICBwczogW3tcbiAgICAgICAgcHM6IFtiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFBhZGRpbmcgRW5kXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcGFkZGluZ1xuICAgICAgICovXG4gICAgICBwZTogW3tcbiAgICAgICAgcGU6IFtiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFBhZGRpbmcgVG9wXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcGFkZGluZ1xuICAgICAgICovXG4gICAgICBwdDogW3tcbiAgICAgICAgcHQ6IFtiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFBhZGRpbmcgUmlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgIHByOiBbe1xuICAgICAgICBwcjogW2JdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUGFkZGluZyBCb3R0b21cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgIHBiOiBbe1xuICAgICAgICBwYjogW2JdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUGFkZGluZyBMZWZ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcGFkZGluZ1xuICAgICAgICovXG4gICAgICBwbDogW3tcbiAgICAgICAgcGw6IFtiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1hcmdpblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hcmdpblxuICAgICAgICovXG4gICAgICBtOiBbe1xuICAgICAgICBtOiBbbV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNYXJnaW4gWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hcmdpblxuICAgICAgICovXG4gICAgICBteDogW3tcbiAgICAgICAgbXg6IFttXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1hcmdpbiBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWFyZ2luXG4gICAgICAgKi9cbiAgICAgIG15OiBbe1xuICAgICAgICBteTogW21dXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWFyZ2luIFN0YXJ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWFyZ2luXG4gICAgICAgKi9cbiAgICAgIG1zOiBbe1xuICAgICAgICBtczogW21dXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWFyZ2luIEVuZFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21hcmdpblxuICAgICAgICovXG4gICAgICBtZTogW3tcbiAgICAgICAgbWU6IFttXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE1hcmdpbiBUb3BcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXJnaW5cbiAgICAgICAqL1xuICAgICAgbXQ6IFt7XG4gICAgICAgIG10OiBbbV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNYXJnaW4gUmlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXJnaW5cbiAgICAgICAqL1xuICAgICAgbXI6IFt7XG4gICAgICAgIG1yOiBbbV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNYXJnaW4gQm90dG9tXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWFyZ2luXG4gICAgICAgKi9cbiAgICAgIG1iOiBbe1xuICAgICAgICBtYjogW21dXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWFyZ2luIExlZnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXJnaW5cbiAgICAgICAqL1xuICAgICAgbWw6IFt7XG4gICAgICAgIG1sOiBbbV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTcGFjZSBCZXR3ZWVuIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zcGFjZVxuICAgICAgICovXG4gICAgICBcInNwYWNlLXhcIjogW3tcbiAgICAgICAgXCJzcGFjZS14XCI6IFtrXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNwYWNlIEJldHdlZW4gWCBSZXZlcnNlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc3BhY2VcbiAgICAgICAqL1xuICAgICAgXCJzcGFjZS14LXJldmVyc2VcIjogW1wic3BhY2UteC1yZXZlcnNlXCJdLFxuICAgICAgLyoqXG4gICAgICAgKiBTcGFjZSBCZXR3ZWVuIFlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zcGFjZVxuICAgICAgICovXG4gICAgICBcInNwYWNlLXlcIjogW3tcbiAgICAgICAgXCJzcGFjZS15XCI6IFtrXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNwYWNlIEJldHdlZW4gWSBSZXZlcnNlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc3BhY2VcbiAgICAgICAqL1xuICAgICAgXCJzcGFjZS15LXJldmVyc2VcIjogW1wic3BhY2UteS1yZXZlcnNlXCJdLFxuICAgICAgLy8gU2l6aW5nXG4gICAgICAvKipcbiAgICAgICAqIFdpZHRoXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvd2lkdGhcbiAgICAgICAqL1xuICAgICAgdzogW3tcbiAgICAgICAgdzogW1wiYXV0b1wiLCBcIm1pblwiLCBcIm1heFwiLCBcImZpdFwiLCBcInN2d1wiLCBcImx2d1wiLCBcImR2d1wiLCBUZSwgZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNaW4tV2lkdGhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9taW4td2lkdGhcbiAgICAgICAqL1xuICAgICAgXCJtaW4td1wiOiBbe1xuICAgICAgICBcIm1pbi13XCI6IFtUZSwgZSwgXCJtaW5cIiwgXCJtYXhcIiwgXCJmaXRcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNYXgtV2lkdGhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9tYXgtd2lkdGhcbiAgICAgICAqL1xuICAgICAgXCJtYXgtd1wiOiBbe1xuICAgICAgICBcIm1heC13XCI6IFtUZSwgZSwgXCJub25lXCIsIFwiZnVsbFwiLCBcIm1pblwiLCBcIm1heFwiLCBcImZpdFwiLCBcInByb3NlXCIsIHtcbiAgICAgICAgICBzY3JlZW46IFtfaV1cbiAgICAgICAgfSwgX2ldXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogSGVpZ2h0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvaGVpZ2h0XG4gICAgICAgKi9cbiAgICAgIGg6IFt7XG4gICAgICAgIGg6IFtUZSwgZSwgXCJhdXRvXCIsIFwibWluXCIsIFwibWF4XCIsIFwiZml0XCIsIFwic3ZoXCIsIFwibHZoXCIsIFwiZHZoXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTWluLUhlaWdodFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21pbi1oZWlnaHRcbiAgICAgICAqL1xuICAgICAgXCJtaW4taFwiOiBbe1xuICAgICAgICBcIm1pbi1oXCI6IFtUZSwgZSwgXCJtaW5cIiwgXCJtYXhcIiwgXCJmaXRcIiwgXCJzdmhcIiwgXCJsdmhcIiwgXCJkdmhcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNYXgtSGVpZ2h0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbWF4LWhlaWdodFxuICAgICAgICovXG4gICAgICBcIm1heC1oXCI6IFt7XG4gICAgICAgIFwibWF4LWhcIjogW1RlLCBlLCBcIm1pblwiLCBcIm1heFwiLCBcImZpdFwiLCBcInN2aFwiLCBcImx2aFwiLCBcImR2aFwiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNpemVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zaXplXG4gICAgICAgKi9cbiAgICAgIHNpemU6IFt7XG4gICAgICAgIHNpemU6IFtUZSwgZSwgXCJhdXRvXCIsIFwibWluXCIsIFwibWF4XCIsIFwiZml0XCJdXG4gICAgICB9XSxcbiAgICAgIC8vIFR5cG9ncmFwaHlcbiAgICAgIC8qKlxuICAgICAgICogRm9udCBTaXplXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZm9udC1zaXplXG4gICAgICAgKi9cbiAgICAgIFwiZm9udC1zaXplXCI6IFt7XG4gICAgICAgIHRleHQ6IFtcImJhc2VcIiwgX2ksIFBpXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEZvbnQgU21vb3RoaW5nXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZm9udC1zbW9vdGhpbmdcbiAgICAgICAqL1xuICAgICAgXCJmb250LXNtb290aGluZ1wiOiBbXCJhbnRpYWxpYXNlZFwiLCBcInN1YnBpeGVsLWFudGlhbGlhc2VkXCJdLFxuICAgICAgLyoqXG4gICAgICAgKiBGb250IFN0eWxlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZm9udC1zdHlsZVxuICAgICAgICovXG4gICAgICBcImZvbnQtc3R5bGVcIjogW1wiaXRhbGljXCIsIFwibm90LWl0YWxpY1wiXSxcbiAgICAgIC8qKlxuICAgICAgICogRm9udCBXZWlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LXdlaWdodFxuICAgICAgICovXG4gICAgICBcImZvbnQtd2VpZ2h0XCI6IFt7XG4gICAgICAgIGZvbnQ6IFtcInRoaW5cIiwgXCJleHRyYWxpZ2h0XCIsIFwibGlnaHRcIiwgXCJub3JtYWxcIiwgXCJtZWRpdW1cIiwgXCJzZW1pYm9sZFwiLCBcImJvbGRcIiwgXCJleHRyYWJvbGRcIiwgXCJibGFja1wiLCBCY11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBGb250IEZhbWlseVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZvbnQtZmFtaWx5XG4gICAgICAgKi9cbiAgICAgIFwiZm9udC1mYW1pbHlcIjogW3tcbiAgICAgICAgZm9udDogW1RhXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEZvbnQgVmFyaWFudCBOdW1lcmljXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZm9udC12YXJpYW50LW51bWVyaWNcbiAgICAgICAqL1xuICAgICAgXCJmdm4tbm9ybWFsXCI6IFtcIm5vcm1hbC1udW1zXCJdLFxuICAgICAgLyoqXG4gICAgICAgKiBGb250IFZhcmlhbnQgTnVtZXJpY1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZvbnQtdmFyaWFudC1udW1lcmljXG4gICAgICAgKi9cbiAgICAgIFwiZnZuLW9yZGluYWxcIjogW1wib3JkaW5hbFwiXSxcbiAgICAgIC8qKlxuICAgICAgICogRm9udCBWYXJpYW50IE51bWVyaWNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LXZhcmlhbnQtbnVtZXJpY1xuICAgICAgICovXG4gICAgICBcImZ2bi1zbGFzaGVkLXplcm9cIjogW1wic2xhc2hlZC16ZXJvXCJdLFxuICAgICAgLyoqXG4gICAgICAgKiBGb250IFZhcmlhbnQgTnVtZXJpY1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZvbnQtdmFyaWFudC1udW1lcmljXG4gICAgICAgKi9cbiAgICAgIFwiZnZuLWZpZ3VyZVwiOiBbXCJsaW5pbmctbnVtc1wiLCBcIm9sZHN0eWxlLW51bXNcIl0sXG4gICAgICAvKipcbiAgICAgICAqIEZvbnQgVmFyaWFudCBOdW1lcmljXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZm9udC12YXJpYW50LW51bWVyaWNcbiAgICAgICAqL1xuICAgICAgXCJmdm4tc3BhY2luZ1wiOiBbXCJwcm9wb3J0aW9uYWwtbnVtc1wiLCBcInRhYnVsYXItbnVtc1wiXSxcbiAgICAgIC8qKlxuICAgICAgICogRm9udCBWYXJpYW50IE51bWVyaWNcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb250LXZhcmlhbnQtbnVtZXJpY1xuICAgICAgICovXG4gICAgICBcImZ2bi1mcmFjdGlvblwiOiBbXCJkaWFnb25hbC1mcmFjdGlvbnNcIiwgXCJzdGFja2VkLWZyYWN0b25zXCJdLFxuICAgICAgLyoqXG4gICAgICAgKiBMZXR0ZXIgU3BhY2luZ1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2xldHRlci1zcGFjaW5nXG4gICAgICAgKi9cbiAgICAgIHRyYWNraW5nOiBbe1xuICAgICAgICB0cmFja2luZzogW1widGlnaHRlclwiLCBcInRpZ2h0XCIsIFwibm9ybWFsXCIsIFwid2lkZVwiLCBcIndpZGVyXCIsIFwid2lkZXN0XCIsIFRlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIExpbmUgQ2xhbXBcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9saW5lLWNsYW1wXG4gICAgICAgKi9cbiAgICAgIFwibGluZS1jbGFtcFwiOiBbe1xuICAgICAgICBcImxpbmUtY2xhbXBcIjogW1wibm9uZVwiLCBFcywgQmNdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTGluZSBIZWlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9saW5lLWhlaWdodFxuICAgICAgICovXG4gICAgICBsZWFkaW5nOiBbe1xuICAgICAgICBsZWFkaW5nOiBbXCJub25lXCIsIFwidGlnaHRcIiwgXCJzbnVnXCIsIFwibm9ybWFsXCIsIFwicmVsYXhlZFwiLCBcImxvb3NlXCIsIHpyLCBUZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBMaXN0IFN0eWxlIEltYWdlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbGlzdC1zdHlsZS1pbWFnZVxuICAgICAgICovXG4gICAgICBcImxpc3QtaW1hZ2VcIjogW3tcbiAgICAgICAgXCJsaXN0LWltYWdlXCI6IFtcIm5vbmVcIiwgVGVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogTGlzdCBTdHlsZSBUeXBlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbGlzdC1zdHlsZS10eXBlXG4gICAgICAgKi9cbiAgICAgIFwibGlzdC1zdHlsZS10eXBlXCI6IFt7XG4gICAgICAgIGxpc3Q6IFtcIm5vbmVcIiwgXCJkaXNjXCIsIFwiZGVjaW1hbFwiLCBUZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBMaXN0IFN0eWxlIFBvc2l0aW9uXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvbGlzdC1zdHlsZS1wb3NpdGlvblxuICAgICAgICovXG4gICAgICBcImxpc3Qtc3R5bGUtcG9zaXRpb25cIjogW3tcbiAgICAgICAgbGlzdDogW1wiaW5zaWRlXCIsIFwib3V0c2lkZVwiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFBsYWNlaG9sZGVyIENvbG9yXG4gICAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSBUYWlsd2luZCBDU1MgdjMuMC4wXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcGxhY2Vob2xkZXItY29sb3JcbiAgICAgICAqL1xuICAgICAgXCJwbGFjZWhvbGRlci1jb2xvclwiOiBbe1xuICAgICAgICBwbGFjZWhvbGRlcjogW3RdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUGxhY2Vob2xkZXIgT3BhY2l0eVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BsYWNlaG9sZGVyLW9wYWNpdHlcbiAgICAgICAqL1xuICAgICAgXCJwbGFjZWhvbGRlci1vcGFjaXR5XCI6IFt7XG4gICAgICAgIFwicGxhY2Vob2xkZXItb3BhY2l0eVwiOiBbeV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUZXh0IEFsaWdubWVudFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RleHQtYWxpZ25cbiAgICAgICAqL1xuICAgICAgXCJ0ZXh0LWFsaWdubWVudFwiOiBbe1xuICAgICAgICB0ZXh0OiBbXCJsZWZ0XCIsIFwiY2VudGVyXCIsIFwicmlnaHRcIiwgXCJqdXN0aWZ5XCIsIFwic3RhcnRcIiwgXCJlbmRcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUZXh0IENvbG9yXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdGV4dC1jb2xvclxuICAgICAgICovXG4gICAgICBcInRleHQtY29sb3JcIjogW3tcbiAgICAgICAgdGV4dDogW3RdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVGV4dCBPcGFjaXR5XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdGV4dC1vcGFjaXR5XG4gICAgICAgKi9cbiAgICAgIFwidGV4dC1vcGFjaXR5XCI6IFt7XG4gICAgICAgIFwidGV4dC1vcGFjaXR5XCI6IFt5XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRleHQgRGVjb3JhdGlvblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RleHQtZGVjb3JhdGlvblxuICAgICAgICovXG4gICAgICBcInRleHQtZGVjb3JhdGlvblwiOiBbXCJ1bmRlcmxpbmVcIiwgXCJvdmVybGluZVwiLCBcImxpbmUtdGhyb3VnaFwiLCBcIm5vLXVuZGVybGluZVwiXSxcbiAgICAgIC8qKlxuICAgICAgICogVGV4dCBEZWNvcmF0aW9uIFN0eWxlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdGV4dC1kZWNvcmF0aW9uLXN0eWxlXG4gICAgICAgKi9cbiAgICAgIFwidGV4dC1kZWNvcmF0aW9uLXN0eWxlXCI6IFt7XG4gICAgICAgIGRlY29yYXRpb246IFsuLi5ZKCksIFwid2F2eVwiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRleHQgRGVjb3JhdGlvbiBUaGlja25lc3NcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LWRlY29yYXRpb24tdGhpY2tuZXNzXG4gICAgICAgKi9cbiAgICAgIFwidGV4dC1kZWNvcmF0aW9uLXRoaWNrbmVzc1wiOiBbe1xuICAgICAgICBkZWNvcmF0aW9uOiBbXCJhdXRvXCIsIFwiZnJvbS1mb250XCIsIHpyLCBQaV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUZXh0IFVuZGVybGluZSBPZmZzZXRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LXVuZGVybGluZS1vZmZzZXRcbiAgICAgICAqL1xuICAgICAgXCJ1bmRlcmxpbmUtb2Zmc2V0XCI6IFt7XG4gICAgICAgIFwidW5kZXJsaW5lLW9mZnNldFwiOiBbXCJhdXRvXCIsIHpyLCBUZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUZXh0IERlY29yYXRpb24gQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LWRlY29yYXRpb24tY29sb3JcbiAgICAgICAqL1xuICAgICAgXCJ0ZXh0LWRlY29yYXRpb24tY29sb3JcIjogW3tcbiAgICAgICAgZGVjb3JhdGlvbjogW3RdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVGV4dCBUcmFuc2Zvcm1cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LXRyYW5zZm9ybVxuICAgICAgICovXG4gICAgICBcInRleHQtdHJhbnNmb3JtXCI6IFtcInVwcGVyY2FzZVwiLCBcImxvd2VyY2FzZVwiLCBcImNhcGl0YWxpemVcIiwgXCJub3JtYWwtY2FzZVwiXSxcbiAgICAgIC8qKlxuICAgICAgICogVGV4dCBPdmVyZmxvd1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RleHQtb3ZlcmZsb3dcbiAgICAgICAqL1xuICAgICAgXCJ0ZXh0LW92ZXJmbG93XCI6IFtcInRydW5jYXRlXCIsIFwidGV4dC1lbGxpcHNpc1wiLCBcInRleHQtY2xpcFwiXSxcbiAgICAgIC8qKlxuICAgICAgICogVGV4dCBXcmFwXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdGV4dC13cmFwXG4gICAgICAgKi9cbiAgICAgIFwidGV4dC13cmFwXCI6IFt7XG4gICAgICAgIHRleHQ6IFtcIndyYXBcIiwgXCJub3dyYXBcIiwgXCJiYWxhbmNlXCIsIFwicHJldHR5XCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVGV4dCBJbmRlbnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90ZXh0LWluZGVudFxuICAgICAgICovXG4gICAgICBpbmRlbnQ6IFt7XG4gICAgICAgIGluZGVudDogUSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVmVydGljYWwgQWxpZ25tZW50XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdmVydGljYWwtYWxpZ25cbiAgICAgICAqL1xuICAgICAgXCJ2ZXJ0aWNhbC1hbGlnblwiOiBbe1xuICAgICAgICBhbGlnbjogW1wiYmFzZWxpbmVcIiwgXCJ0b3BcIiwgXCJtaWRkbGVcIiwgXCJib3R0b21cIiwgXCJ0ZXh0LXRvcFwiLCBcInRleHQtYm90dG9tXCIsIFwic3ViXCIsIFwic3VwZXJcIiwgVGVdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogV2hpdGVzcGFjZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3doaXRlc3BhY2VcbiAgICAgICAqL1xuICAgICAgd2hpdGVzcGFjZTogW3tcbiAgICAgICAgd2hpdGVzcGFjZTogW1wibm9ybWFsXCIsIFwibm93cmFwXCIsIFwicHJlXCIsIFwicHJlLWxpbmVcIiwgXCJwcmUtd3JhcFwiLCBcImJyZWFrLXNwYWNlc1wiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFdvcmQgQnJlYWtcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy93b3JkLWJyZWFrXG4gICAgICAgKi9cbiAgICAgIGJyZWFrOiBbe1xuICAgICAgICBicmVhazogW1wibm9ybWFsXCIsIFwid29yZHNcIiwgXCJhbGxcIiwgXCJrZWVwXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogSHlwaGVuc1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2h5cGhlbnNcbiAgICAgICAqL1xuICAgICAgaHlwaGVuczogW3tcbiAgICAgICAgaHlwaGVuczogW1wibm9uZVwiLCBcIm1hbnVhbFwiLCBcImF1dG9cIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBDb250ZW50XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvY29udGVudFxuICAgICAgICovXG4gICAgICBjb250ZW50OiBbe1xuICAgICAgICBjb250ZW50OiBbXCJub25lXCIsIFRlXVxuICAgICAgfV0sXG4gICAgICAvLyBCYWNrZ3JvdW5kc1xuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZ3JvdW5kIEF0dGFjaG1lbnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZ3JvdW5kLWF0dGFjaG1lbnRcbiAgICAgICAqL1xuICAgICAgXCJiZy1hdHRhY2htZW50XCI6IFt7XG4gICAgICAgIGJnOiBbXCJmaXhlZFwiLCBcImxvY2FsXCIsIFwic2Nyb2xsXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2dyb3VuZCBDbGlwXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2dyb3VuZC1jbGlwXG4gICAgICAgKi9cbiAgICAgIFwiYmctY2xpcFwiOiBbe1xuICAgICAgICBcImJnLWNsaXBcIjogW1wiYm9yZGVyXCIsIFwicGFkZGluZ1wiLCBcImNvbnRlbnRcIiwgXCJ0ZXh0XCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2dyb3VuZCBPcGFjaXR5XG4gICAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSBUYWlsd2luZCBDU1MgdjMuMC4wXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2dyb3VuZC1vcGFjaXR5XG4gICAgICAgKi9cbiAgICAgIFwiYmctb3BhY2l0eVwiOiBbe1xuICAgICAgICBcImJnLW9wYWNpdHlcIjogW3ldXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2dyb3VuZCBPcmlnaW5cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZ3JvdW5kLW9yaWdpblxuICAgICAgICovXG4gICAgICBcImJnLW9yaWdpblwiOiBbe1xuICAgICAgICBcImJnLW9yaWdpblwiOiBbXCJib3JkZXJcIiwgXCJwYWRkaW5nXCIsIFwiY29udGVudFwiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tncm91bmQgUG9zaXRpb25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZ3JvdW5kLXBvc2l0aW9uXG4gICAgICAgKi9cbiAgICAgIFwiYmctcG9zaXRpb25cIjogW3tcbiAgICAgICAgYmc6IFsuLi5yZSgpLCBOTV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZ3JvdW5kIFJlcGVhdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tncm91bmQtcmVwZWF0XG4gICAgICAgKi9cbiAgICAgIFwiYmctcmVwZWF0XCI6IFt7XG4gICAgICAgIGJnOiBbXCJuby1yZXBlYXRcIiwge1xuICAgICAgICAgIHJlcGVhdDogW1wiXCIsIFwieFwiLCBcInlcIiwgXCJyb3VuZFwiLCBcInNwYWNlXCJdXG4gICAgICAgIH1dXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2dyb3VuZCBTaXplXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2dyb3VuZC1zaXplXG4gICAgICAgKi9cbiAgICAgIFwiYmctc2l6ZVwiOiBbe1xuICAgICAgICBiZzogW1wiYXV0b1wiLCBcImNvdmVyXCIsIFwiY29udGFpblwiLCBSTV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZ3JvdW5kIEltYWdlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2dyb3VuZC1pbWFnZVxuICAgICAgICovXG4gICAgICBcImJnLWltYWdlXCI6IFt7XG4gICAgICAgIGJnOiBbXCJub25lXCIsIHtcbiAgICAgICAgICBcImdyYWRpZW50LXRvXCI6IFtcInRcIiwgXCJ0clwiLCBcInJcIiwgXCJiclwiLCBcImJcIiwgXCJibFwiLCBcImxcIiwgXCJ0bFwiXVxuICAgICAgICB9LCBaTV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZ3JvdW5kIENvbG9yXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2dyb3VuZC1jb2xvclxuICAgICAgICovXG4gICAgICBcImJnLWNvbG9yXCI6IFt7XG4gICAgICAgIGJnOiBbdF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmFkaWVudCBDb2xvciBTdG9wcyBGcm9tIFBvc2l0aW9uXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JhZGllbnQtY29sb3Itc3RvcHNcbiAgICAgICAqL1xuICAgICAgXCJncmFkaWVudC1mcm9tLXBvc1wiOiBbe1xuICAgICAgICBmcm9tOiBbcF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmFkaWVudCBDb2xvciBTdG9wcyBWaWEgUG9zaXRpb25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmFkaWVudC1jb2xvci1zdG9wc1xuICAgICAgICovXG4gICAgICBcImdyYWRpZW50LXZpYS1wb3NcIjogW3tcbiAgICAgICAgdmlhOiBbcF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmFkaWVudCBDb2xvciBTdG9wcyBUbyBQb3NpdGlvblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyYWRpZW50LWNvbG9yLXN0b3BzXG4gICAgICAgKi9cbiAgICAgIFwiZ3JhZGllbnQtdG8tcG9zXCI6IFt7XG4gICAgICAgIHRvOiBbcF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmFkaWVudCBDb2xvciBTdG9wcyBGcm9tXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZ3JhZGllbnQtY29sb3Itc3RvcHNcbiAgICAgICAqL1xuICAgICAgXCJncmFkaWVudC1mcm9tXCI6IFt7XG4gICAgICAgIGZyb206IFtoXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEdyYWRpZW50IENvbG9yIFN0b3BzIFZpYVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2dyYWRpZW50LWNvbG9yLXN0b3BzXG4gICAgICAgKi9cbiAgICAgIFwiZ3JhZGllbnQtdmlhXCI6IFt7XG4gICAgICAgIHZpYTogW2hdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogR3JhZGllbnQgQ29sb3IgU3RvcHMgVG9cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmFkaWVudC1jb2xvci1zdG9wc1xuICAgICAgICovXG4gICAgICBcImdyYWRpZW50LXRvXCI6IFt7XG4gICAgICAgIHRvOiBbaF1cbiAgICAgIH1dLFxuICAgICAgLy8gQm9yZGVyc1xuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICByb3VuZGVkOiBbe1xuICAgICAgICByb3VuZGVkOiBbc11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIFN0YXJ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICBcInJvdW5kZWQtc1wiOiBbe1xuICAgICAgICBcInJvdW5kZWQtc1wiOiBbc11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIEVuZFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAqL1xuICAgICAgXCJyb3VuZGVkLWVcIjogW3tcbiAgICAgICAgXCJyb3VuZGVkLWVcIjogW3NdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1cyBUb3BcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgKi9cbiAgICAgIFwicm91bmRlZC10XCI6IFt7XG4gICAgICAgIFwicm91bmRlZC10XCI6IFtzXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBSYWRpdXMgUmlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgKi9cbiAgICAgIFwicm91bmRlZC1yXCI6IFt7XG4gICAgICAgIFwicm91bmRlZC1yXCI6IFtzXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBSYWRpdXMgQm90dG9tXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICBcInJvdW5kZWQtYlwiOiBbe1xuICAgICAgICBcInJvdW5kZWQtYlwiOiBbc11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgUmFkaXVzIExlZnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgKi9cbiAgICAgIFwicm91bmRlZC1sXCI6IFt7XG4gICAgICAgIFwicm91bmRlZC1sXCI6IFtzXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBSYWRpdXMgU3RhcnQgU3RhcnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgKi9cbiAgICAgIFwicm91bmRlZC1zc1wiOiBbe1xuICAgICAgICBcInJvdW5kZWQtc3NcIjogW3NdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1cyBTdGFydCBFbmRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgKi9cbiAgICAgIFwicm91bmRlZC1zZVwiOiBbe1xuICAgICAgICBcInJvdW5kZWQtc2VcIjogW3NdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1cyBFbmQgRW5kXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICBcInJvdW5kZWQtZWVcIjogW3tcbiAgICAgICAgXCJyb3VuZGVkLWVlXCI6IFtzXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBSYWRpdXMgRW5kIFN0YXJ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXJhZGl1c1xuICAgICAgICovXG4gICAgICBcInJvdW5kZWQtZXNcIjogW3tcbiAgICAgICAgXCJyb3VuZGVkLWVzXCI6IFtzXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBSYWRpdXMgVG9wIExlZnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgKi9cbiAgICAgIFwicm91bmRlZC10bFwiOiBbe1xuICAgICAgICBcInJvdW5kZWQtdGxcIjogW3NdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1cyBUb3AgUmlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgKi9cbiAgICAgIFwicm91bmRlZC10clwiOiBbe1xuICAgICAgICBcInJvdW5kZWQtdHJcIjogW3NdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1cyBCb3R0b20gUmlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItcmFkaXVzXG4gICAgICAgKi9cbiAgICAgIFwicm91bmRlZC1iclwiOiBbe1xuICAgICAgICBcInJvdW5kZWQtYnJcIjogW3NdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFJhZGl1cyBCb3R0b20gTGVmdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1yYWRpdXNcbiAgICAgICAqL1xuICAgICAgXCJyb3VuZGVkLWJsXCI6IFt7XG4gICAgICAgIFwicm91bmRlZC1ibFwiOiBbc11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgV2lkdGhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItd2lkdGhcbiAgICAgICAqL1xuICAgICAgXCJib3JkZXItd1wiOiBbe1xuICAgICAgICBib3JkZXI6IFthXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBXaWR0aCBYXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXdpZHRoXG4gICAgICAgKi9cbiAgICAgIFwiYm9yZGVyLXcteFwiOiBbe1xuICAgICAgICBcImJvcmRlci14XCI6IFthXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBXaWR0aCBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXdpZHRoXG4gICAgICAgKi9cbiAgICAgIFwiYm9yZGVyLXcteVwiOiBbe1xuICAgICAgICBcImJvcmRlci15XCI6IFthXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBXaWR0aCBTdGFydFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci13aWR0aFxuICAgICAgICovXG4gICAgICBcImJvcmRlci13LXNcIjogW3tcbiAgICAgICAgXCJib3JkZXItc1wiOiBbYV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgV2lkdGggRW5kXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXdpZHRoXG4gICAgICAgKi9cbiAgICAgIFwiYm9yZGVyLXctZVwiOiBbe1xuICAgICAgICBcImJvcmRlci1lXCI6IFthXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBXaWR0aCBUb3BcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItd2lkdGhcbiAgICAgICAqL1xuICAgICAgXCJib3JkZXItdy10XCI6IFt7XG4gICAgICAgIFwiYm9yZGVyLXRcIjogW2FdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFdpZHRoIFJpZ2h0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXdpZHRoXG4gICAgICAgKi9cbiAgICAgIFwiYm9yZGVyLXctclwiOiBbe1xuICAgICAgICBcImJvcmRlci1yXCI6IFthXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBXaWR0aCBCb3R0b21cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItd2lkdGhcbiAgICAgICAqL1xuICAgICAgXCJib3JkZXItdy1iXCI6IFt7XG4gICAgICAgIFwiYm9yZGVyLWJcIjogW2FdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFdpZHRoIExlZnRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItd2lkdGhcbiAgICAgICAqL1xuICAgICAgXCJib3JkZXItdy1sXCI6IFt7XG4gICAgICAgIFwiYm9yZGVyLWxcIjogW2FdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIE9wYWNpdHlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItb3BhY2l0eVxuICAgICAgICovXG4gICAgICBcImJvcmRlci1vcGFjaXR5XCI6IFt7XG4gICAgICAgIFwiYm9yZGVyLW9wYWNpdHlcIjogW3ldXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIFN0eWxlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXN0eWxlXG4gICAgICAgKi9cbiAgICAgIFwiYm9yZGVyLXN0eWxlXCI6IFt7XG4gICAgICAgIGJvcmRlcjogWy4uLlkoKSwgXCJoaWRkZW5cIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBEaXZpZGUgV2lkdGggWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2RpdmlkZS13aWR0aFxuICAgICAgICovXG4gICAgICBcImRpdmlkZS14XCI6IFt7XG4gICAgICAgIFwiZGl2aWRlLXhcIjogW2FdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRGl2aWRlIFdpZHRoIFggUmV2ZXJzZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2RpdmlkZS13aWR0aFxuICAgICAgICovXG4gICAgICBcImRpdmlkZS14LXJldmVyc2VcIjogW1wiZGl2aWRlLXgtcmV2ZXJzZVwiXSxcbiAgICAgIC8qKlxuICAgICAgICogRGl2aWRlIFdpZHRoIFlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9kaXZpZGUtd2lkdGhcbiAgICAgICAqL1xuICAgICAgXCJkaXZpZGUteVwiOiBbe1xuICAgICAgICBcImRpdmlkZS15XCI6IFthXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIERpdmlkZSBXaWR0aCBZIFJldmVyc2VcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9kaXZpZGUtd2lkdGhcbiAgICAgICAqL1xuICAgICAgXCJkaXZpZGUteS1yZXZlcnNlXCI6IFtcImRpdmlkZS15LXJldmVyc2VcIl0sXG4gICAgICAvKipcbiAgICAgICAqIERpdmlkZSBPcGFjaXR5XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZGl2aWRlLW9wYWNpdHlcbiAgICAgICAqL1xuICAgICAgXCJkaXZpZGUtb3BhY2l0eVwiOiBbe1xuICAgICAgICBcImRpdmlkZS1vcGFjaXR5XCI6IFt5XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIERpdmlkZSBTdHlsZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2RpdmlkZS1zdHlsZVxuICAgICAgICovXG4gICAgICBcImRpdmlkZS1zdHlsZVwiOiBbe1xuICAgICAgICBkaXZpZGU6IFkoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBDb2xvclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1jb2xvclxuICAgICAgICovXG4gICAgICBcImJvcmRlci1jb2xvclwiOiBbe1xuICAgICAgICBib3JkZXI6IFtpXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBDb2xvciBYXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLWNvbG9yXG4gICAgICAgKi9cbiAgICAgIFwiYm9yZGVyLWNvbG9yLXhcIjogW3tcbiAgICAgICAgXCJib3JkZXIteFwiOiBbaV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgQ29sb3IgWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1jb2xvclxuICAgICAgICovXG4gICAgICBcImJvcmRlci1jb2xvci15XCI6IFt7XG4gICAgICAgIFwiYm9yZGVyLXlcIjogW2ldXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIENvbG9yIFRvcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1jb2xvclxuICAgICAgICovXG4gICAgICBcImJvcmRlci1jb2xvci10XCI6IFt7XG4gICAgICAgIFwiYm9yZGVyLXRcIjogW2ldXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIENvbG9yIFJpZ2h0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLWNvbG9yXG4gICAgICAgKi9cbiAgICAgIFwiYm9yZGVyLWNvbG9yLXJcIjogW3tcbiAgICAgICAgXCJib3JkZXItclwiOiBbaV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgQ29sb3IgQm90dG9tXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLWNvbG9yXG4gICAgICAgKi9cbiAgICAgIFwiYm9yZGVyLWNvbG9yLWJcIjogW3tcbiAgICAgICAgXCJib3JkZXItYlwiOiBbaV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3JkZXIgQ29sb3IgTGVmdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JvcmRlci1jb2xvclxuICAgICAgICovXG4gICAgICBcImJvcmRlci1jb2xvci1sXCI6IFt7XG4gICAgICAgIFwiYm9yZGVyLWxcIjogW2ldXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogRGl2aWRlIENvbG9yXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZGl2aWRlLWNvbG9yXG4gICAgICAgKi9cbiAgICAgIFwiZGl2aWRlLWNvbG9yXCI6IFt7XG4gICAgICAgIGRpdmlkZTogW2ldXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3V0bGluZSBTdHlsZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL291dGxpbmUtc3R5bGVcbiAgICAgICAqL1xuICAgICAgXCJvdXRsaW5lLXN0eWxlXCI6IFt7XG4gICAgICAgIG91dGxpbmU6IFtcIlwiLCAuLi5ZKCldXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogT3V0bGluZSBPZmZzZXRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9vdXRsaW5lLW9mZnNldFxuICAgICAgICovXG4gICAgICBcIm91dGxpbmUtb2Zmc2V0XCI6IFt7XG4gICAgICAgIFwib3V0bGluZS1vZmZzZXRcIjogW3pyLCBUZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBPdXRsaW5lIFdpZHRoXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3V0bGluZS13aWR0aFxuICAgICAgICovXG4gICAgICBcIm91dGxpbmUtd1wiOiBbe1xuICAgICAgICBvdXRsaW5lOiBbenIsIFBpXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIE91dGxpbmUgQ29sb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9vdXRsaW5lLWNvbG9yXG4gICAgICAgKi9cbiAgICAgIFwib3V0bGluZS1jb2xvclwiOiBbe1xuICAgICAgICBvdXRsaW5lOiBbdF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBSaW5nIFdpZHRoXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcmluZy13aWR0aFxuICAgICAgICovXG4gICAgICBcInJpbmctd1wiOiBbe1xuICAgICAgICByaW5nOiBXKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBSaW5nIFdpZHRoIEluc2V0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcmluZy13aWR0aFxuICAgICAgICovXG4gICAgICBcInJpbmctdy1pbnNldFwiOiBbXCJyaW5nLWluc2V0XCJdLFxuICAgICAgLyoqXG4gICAgICAgKiBSaW5nIENvbG9yXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcmluZy1jb2xvclxuICAgICAgICovXG4gICAgICBcInJpbmctY29sb3JcIjogW3tcbiAgICAgICAgcmluZzogW3RdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUmluZyBPcGFjaXR5XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcmluZy1vcGFjaXR5XG4gICAgICAgKi9cbiAgICAgIFwicmluZy1vcGFjaXR5XCI6IFt7XG4gICAgICAgIFwicmluZy1vcGFjaXR5XCI6IFt5XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFJpbmcgT2Zmc2V0IFdpZHRoXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvcmluZy1vZmZzZXQtd2lkdGhcbiAgICAgICAqL1xuICAgICAgXCJyaW5nLW9mZnNldC13XCI6IFt7XG4gICAgICAgIFwicmluZy1vZmZzZXRcIjogW3pyLCBQaV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBSaW5nIE9mZnNldCBDb2xvclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Jpbmctb2Zmc2V0LWNvbG9yXG4gICAgICAgKi9cbiAgICAgIFwicmluZy1vZmZzZXQtY29sb3JcIjogW3tcbiAgICAgICAgXCJyaW5nLW9mZnNldFwiOiBbdF1cbiAgICAgIH1dLFxuICAgICAgLy8gRWZmZWN0c1xuICAgICAgLyoqXG4gICAgICAgKiBCb3ggU2hhZG93XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm94LXNoYWRvd1xuICAgICAgICovXG4gICAgICBzaGFkb3c6IFt7XG4gICAgICAgIHNoYWRvdzogW1wiXCIsIFwiaW5uZXJcIiwgXCJub25lXCIsIF9pLCBWTV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCb3ggU2hhZG93IENvbG9yXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm94LXNoYWRvdy1jb2xvclxuICAgICAgICovXG4gICAgICBcInNoYWRvdy1jb2xvclwiOiBbe1xuICAgICAgICBzaGFkb3c6IFtUYV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBPcGFjaXR5XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvb3BhY2l0eVxuICAgICAgICovXG4gICAgICBvcGFjaXR5OiBbe1xuICAgICAgICBvcGFjaXR5OiBbeV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBNaXggQmxlbmQgTW9kZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL21peC1ibGVuZC1tb2RlXG4gICAgICAgKi9cbiAgICAgIFwibWl4LWJsZW5kXCI6IFt7XG4gICAgICAgIFwibWl4LWJsZW5kXCI6IFsuLi5LKCksIFwicGx1cy1saWdodGVyXCIsIFwicGx1cy1kYXJrZXJcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZ3JvdW5kIEJsZW5kIE1vZGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9iYWNrZ3JvdW5kLWJsZW5kLW1vZGVcbiAgICAgICAqL1xuICAgICAgXCJiZy1ibGVuZFwiOiBbe1xuICAgICAgICBcImJnLWJsZW5kXCI6IEsoKVxuICAgICAgfV0sXG4gICAgICAvLyBGaWx0ZXJzXG4gICAgICAvKipcbiAgICAgICAqIEZpbHRlclxuICAgICAgICogQGRlcHJlY2F0ZWQgc2luY2UgVGFpbHdpbmQgQ1NTIHYzLjAuMFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2ZpbHRlclxuICAgICAgICovXG4gICAgICBmaWx0ZXI6IFt7XG4gICAgICAgIGZpbHRlcjogW1wiXCIsIFwibm9uZVwiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJsdXJcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ibHVyXG4gICAgICAgKi9cbiAgICAgIGJsdXI6IFt7XG4gICAgICAgIGJsdXI6IFtuXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJyaWdodG5lc3NcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9icmlnaHRuZXNzXG4gICAgICAgKi9cbiAgICAgIGJyaWdodG5lc3M6IFt7XG4gICAgICAgIGJyaWdodG5lc3M6IFtyXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIENvbnRyYXN0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvY29udHJhc3RcbiAgICAgICAqL1xuICAgICAgY29udHJhc3Q6IFt7XG4gICAgICAgIGNvbnRyYXN0OiBbbF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBEcm9wIFNoYWRvd1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2Ryb3Atc2hhZG93XG4gICAgICAgKi9cbiAgICAgIFwiZHJvcC1zaGFkb3dcIjogW3tcbiAgICAgICAgXCJkcm9wLXNoYWRvd1wiOiBbXCJcIiwgXCJub25lXCIsIF9pLCBUZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBHcmF5c2NhbGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ncmF5c2NhbGVcbiAgICAgICAqL1xuICAgICAgZ3JheXNjYWxlOiBbe1xuICAgICAgICBncmF5c2NhbGU6IFtjXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEh1ZSBSb3RhdGVcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9odWUtcm90YXRlXG4gICAgICAgKi9cbiAgICAgIFwiaHVlLXJvdGF0ZVwiOiBbe1xuICAgICAgICBcImh1ZS1yb3RhdGVcIjogW3VdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogSW52ZXJ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvaW52ZXJ0XG4gICAgICAgKi9cbiAgICAgIGludmVydDogW3tcbiAgICAgICAgaW52ZXJ0OiBbZF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTYXR1cmF0ZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3NhdHVyYXRlXG4gICAgICAgKi9cbiAgICAgIHNhdHVyYXRlOiBbe1xuICAgICAgICBzYXR1cmF0ZTogW2ddXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2VwaWFcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zZXBpYVxuICAgICAgICovXG4gICAgICBzZXBpYTogW3tcbiAgICAgICAgc2VwaWE6IFtTXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tkcm9wIEZpbHRlclxuICAgICAgICogQGRlcHJlY2F0ZWQgc2luY2UgVGFpbHdpbmQgQ1NTIHYzLjAuMFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tkcm9wLWZpbHRlclxuICAgICAgICovXG4gICAgICBcImJhY2tkcm9wLWZpbHRlclwiOiBbe1xuICAgICAgICBcImJhY2tkcm9wLWZpbHRlclwiOiBbXCJcIiwgXCJub25lXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQmFja2Ryb3AgQmx1clxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tkcm9wLWJsdXJcbiAgICAgICAqL1xuICAgICAgXCJiYWNrZHJvcC1ibHVyXCI6IFt7XG4gICAgICAgIFwiYmFja2Ryb3AtYmx1clwiOiBbbl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZHJvcCBCcmlnaHRuZXNzXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2Ryb3AtYnJpZ2h0bmVzc1xuICAgICAgICovXG4gICAgICBcImJhY2tkcm9wLWJyaWdodG5lc3NcIjogW3tcbiAgICAgICAgXCJiYWNrZHJvcC1icmlnaHRuZXNzXCI6IFtyXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tkcm9wIENvbnRyYXN0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2Ryb3AtY29udHJhc3RcbiAgICAgICAqL1xuICAgICAgXCJiYWNrZHJvcC1jb250cmFzdFwiOiBbe1xuICAgICAgICBcImJhY2tkcm9wLWNvbnRyYXN0XCI6IFtsXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tkcm9wIEdyYXlzY2FsZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tkcm9wLWdyYXlzY2FsZVxuICAgICAgICovXG4gICAgICBcImJhY2tkcm9wLWdyYXlzY2FsZVwiOiBbe1xuICAgICAgICBcImJhY2tkcm9wLWdyYXlzY2FsZVwiOiBbY11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZHJvcCBIdWUgUm90YXRlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2Ryb3AtaHVlLXJvdGF0ZVxuICAgICAgICovXG4gICAgICBcImJhY2tkcm9wLWh1ZS1yb3RhdGVcIjogW3tcbiAgICAgICAgXCJiYWNrZHJvcC1odWUtcm90YXRlXCI6IFt1XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tkcm9wIEludmVydFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2JhY2tkcm9wLWludmVydFxuICAgICAgICovXG4gICAgICBcImJhY2tkcm9wLWludmVydFwiOiBbe1xuICAgICAgICBcImJhY2tkcm9wLWludmVydFwiOiBbZF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBCYWNrZHJvcCBPcGFjaXR5XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2Ryb3Atb3BhY2l0eVxuICAgICAgICovXG4gICAgICBcImJhY2tkcm9wLW9wYWNpdHlcIjogW3tcbiAgICAgICAgXCJiYWNrZHJvcC1vcGFjaXR5XCI6IFt5XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tkcm9wIFNhdHVyYXRlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2Ryb3Atc2F0dXJhdGVcbiAgICAgICAqL1xuICAgICAgXCJiYWNrZHJvcC1zYXR1cmF0ZVwiOiBbe1xuICAgICAgICBcImJhY2tkcm9wLXNhdHVyYXRlXCI6IFtnXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJhY2tkcm9wIFNlcGlhXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYmFja2Ryb3Atc2VwaWFcbiAgICAgICAqL1xuICAgICAgXCJiYWNrZHJvcC1zZXBpYVwiOiBbe1xuICAgICAgICBcImJhY2tkcm9wLXNlcGlhXCI6IFtTXVxuICAgICAgfV0sXG4gICAgICAvLyBUYWJsZXNcbiAgICAgIC8qKlxuICAgICAgICogQm9yZGVyIENvbGxhcHNlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLWNvbGxhcHNlXG4gICAgICAgKi9cbiAgICAgIFwiYm9yZGVyLWNvbGxhcHNlXCI6IFt7XG4gICAgICAgIGJvcmRlcjogW1wiY29sbGFwc2VcIiwgXCJzZXBhcmF0ZVwiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBTcGFjaW5nXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYm9yZGVyLXNwYWNpbmdcbiAgICAgICAqL1xuICAgICAgXCJib3JkZXItc3BhY2luZ1wiOiBbe1xuICAgICAgICBcImJvcmRlci1zcGFjaW5nXCI6IFtvXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBTcGFjaW5nIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItc3BhY2luZ1xuICAgICAgICovXG4gICAgICBcImJvcmRlci1zcGFjaW5nLXhcIjogW3tcbiAgICAgICAgXCJib3JkZXItc3BhY2luZy14XCI6IFtvXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEJvcmRlciBTcGFjaW5nIFlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9ib3JkZXItc3BhY2luZ1xuICAgICAgICovXG4gICAgICBcImJvcmRlci1zcGFjaW5nLXlcIjogW3tcbiAgICAgICAgXCJib3JkZXItc3BhY2luZy15XCI6IFtvXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRhYmxlIExheW91dFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RhYmxlLWxheW91dFxuICAgICAgICovXG4gICAgICBcInRhYmxlLWxheW91dFwiOiBbe1xuICAgICAgICB0YWJsZTogW1wiYXV0b1wiLCBcImZpeGVkXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQ2FwdGlvbiBTaWRlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvY2FwdGlvbi1zaWRlXG4gICAgICAgKi9cbiAgICAgIGNhcHRpb246IFt7XG4gICAgICAgIGNhcHRpb246IFtcInRvcFwiLCBcImJvdHRvbVwiXVxuICAgICAgfV0sXG4gICAgICAvLyBUcmFuc2l0aW9ucyBhbmQgQW5pbWF0aW9uXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5pc2l0aW9uIFByb3BlcnR5XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdHJhbnNpdGlvbi1wcm9wZXJ0eVxuICAgICAgICovXG4gICAgICB0cmFuc2l0aW9uOiBbe1xuICAgICAgICB0cmFuc2l0aW9uOiBbXCJub25lXCIsIFwiYWxsXCIsIFwiXCIsIFwiY29sb3JzXCIsIFwib3BhY2l0eVwiLCBcInNoYWRvd1wiLCBcInRyYW5zZm9ybVwiLCBUZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2l0aW9uIER1cmF0aW9uXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdHJhbnNpdGlvbi1kdXJhdGlvblxuICAgICAgICovXG4gICAgICBkdXJhdGlvbjogW3tcbiAgICAgICAgZHVyYXRpb246IGdlKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2l0aW9uIFRpbWluZyBGdW5jdGlvblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uXG4gICAgICAgKi9cbiAgICAgIGVhc2U6IFt7XG4gICAgICAgIGVhc2U6IFtcImxpbmVhclwiLCBcImluXCIsIFwib3V0XCIsIFwiaW4tb3V0XCIsIFRlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zaXRpb24gRGVsYXlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90cmFuc2l0aW9uLWRlbGF5XG4gICAgICAgKi9cbiAgICAgIGRlbGF5OiBbe1xuICAgICAgICBkZWxheTogZ2UoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIEFuaW1hdGlvblxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2FuaW1hdGlvblxuICAgICAgICovXG4gICAgICBhbmltYXRlOiBbe1xuICAgICAgICBhbmltYXRlOiBbXCJub25lXCIsIFwic3BpblwiLCBcInBpbmdcIiwgXCJwdWxzZVwiLCBcImJvdW5jZVwiLCBUZV1cbiAgICAgIH1dLFxuICAgICAgLy8gVHJhbnNmb3Jtc1xuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2Zvcm1cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90cmFuc2Zvcm1cbiAgICAgICAqL1xuICAgICAgdHJhbnNmb3JtOiBbe1xuICAgICAgICB0cmFuc2Zvcm06IFtcIlwiLCBcImdwdVwiLCBcIm5vbmVcIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY2FsZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3NjYWxlXG4gICAgICAgKi9cbiAgICAgIHNjYWxlOiBbe1xuICAgICAgICBzY2FsZTogW3ZdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2NhbGUgWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3NjYWxlXG4gICAgICAgKi9cbiAgICAgIFwic2NhbGUteFwiOiBbe1xuICAgICAgICBcInNjYWxlLXhcIjogW3ZdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2NhbGUgWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3NjYWxlXG4gICAgICAgKi9cbiAgICAgIFwic2NhbGUteVwiOiBbe1xuICAgICAgICBcInNjYWxlLXlcIjogW3ZdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogUm90YXRlXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvcm90YXRlXG4gICAgICAgKi9cbiAgICAgIHJvdGF0ZTogW3tcbiAgICAgICAgcm90YXRlOiBbX2EsIFRlXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zbGF0ZSBYXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdHJhbnNsYXRlXG4gICAgICAgKi9cbiAgICAgIFwidHJhbnNsYXRlLXhcIjogW3tcbiAgICAgICAgXCJ0cmFuc2xhdGUteFwiOiBbX11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUcmFuc2xhdGUgWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RyYW5zbGF0ZVxuICAgICAgICovXG4gICAgICBcInRyYW5zbGF0ZS15XCI6IFt7XG4gICAgICAgIFwidHJhbnNsYXRlLXlcIjogW19dXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2tldyBYXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2tld1xuICAgICAgICovXG4gICAgICBcInNrZXcteFwiOiBbe1xuICAgICAgICBcInNrZXcteFwiOiBbd11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTa2V3IFlcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9za2V3XG4gICAgICAgKi9cbiAgICAgIFwic2tldy15XCI6IFt7XG4gICAgICAgIFwic2tldy15XCI6IFt3XVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRyYW5zZm9ybSBPcmlnaW5cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90cmFuc2Zvcm0tb3JpZ2luXG4gICAgICAgKi9cbiAgICAgIFwidHJhbnNmb3JtLW9yaWdpblwiOiBbe1xuICAgICAgICBvcmlnaW46IFtcImNlbnRlclwiLCBcInRvcFwiLCBcInRvcC1yaWdodFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tLXJpZ2h0XCIsIFwiYm90dG9tXCIsIFwiYm90dG9tLWxlZnRcIiwgXCJsZWZ0XCIsIFwidG9wLWxlZnRcIiwgVGVdXG4gICAgICB9XSxcbiAgICAgIC8vIEludGVyYWN0aXZpdHlcbiAgICAgIC8qKlxuICAgICAgICogQWNjZW50IENvbG9yXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvYWNjZW50LWNvbG9yXG4gICAgICAgKi9cbiAgICAgIGFjY2VudDogW3tcbiAgICAgICAgYWNjZW50OiBbXCJhdXRvXCIsIHRdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogQXBwZWFyYW5jZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2FwcGVhcmFuY2VcbiAgICAgICAqL1xuICAgICAgYXBwZWFyYW5jZTogW3tcbiAgICAgICAgYXBwZWFyYW5jZTogW1wibm9uZVwiLCBcImF1dG9cIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBDdXJzb3JcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9jdXJzb3JcbiAgICAgICAqL1xuICAgICAgY3Vyc29yOiBbe1xuICAgICAgICBjdXJzb3I6IFtcImF1dG9cIiwgXCJkZWZhdWx0XCIsIFwicG9pbnRlclwiLCBcIndhaXRcIiwgXCJ0ZXh0XCIsIFwibW92ZVwiLCBcImhlbHBcIiwgXCJub3QtYWxsb3dlZFwiLCBcIm5vbmVcIiwgXCJjb250ZXh0LW1lbnVcIiwgXCJwcm9ncmVzc1wiLCBcImNlbGxcIiwgXCJjcm9zc2hhaXJcIiwgXCJ2ZXJ0aWNhbC10ZXh0XCIsIFwiYWxpYXNcIiwgXCJjb3B5XCIsIFwibm8tZHJvcFwiLCBcImdyYWJcIiwgXCJncmFiYmluZ1wiLCBcImFsbC1zY3JvbGxcIiwgXCJjb2wtcmVzaXplXCIsIFwicm93LXJlc2l6ZVwiLCBcIm4tcmVzaXplXCIsIFwiZS1yZXNpemVcIiwgXCJzLXJlc2l6ZVwiLCBcInctcmVzaXplXCIsIFwibmUtcmVzaXplXCIsIFwibnctcmVzaXplXCIsIFwic2UtcmVzaXplXCIsIFwic3ctcmVzaXplXCIsIFwiZXctcmVzaXplXCIsIFwibnMtcmVzaXplXCIsIFwibmVzdy1yZXNpemVcIiwgXCJud3NlLXJlc2l6ZVwiLCBcInpvb20taW5cIiwgXCJ6b29tLW91dFwiLCBUZV1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBDYXJldCBDb2xvclxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL2p1c3QtaW4tdGltZS1tb2RlI2NhcmV0LWNvbG9yLXV0aWxpdGllc1xuICAgICAgICovXG4gICAgICBcImNhcmV0LWNvbG9yXCI6IFt7XG4gICAgICAgIGNhcmV0OiBbdF1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBQb2ludGVyIEV2ZW50c1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3BvaW50ZXItZXZlbnRzXG4gICAgICAgKi9cbiAgICAgIFwicG9pbnRlci1ldmVudHNcIjogW3tcbiAgICAgICAgXCJwb2ludGVyLWV2ZW50c1wiOiBbXCJub25lXCIsIFwiYXV0b1wiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFJlc2l6ZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Jlc2l6ZVxuICAgICAgICovXG4gICAgICByZXNpemU6IFt7XG4gICAgICAgIHJlc2l6ZTogW1wibm9uZVwiLCBcInlcIiwgXCJ4XCIsIFwiXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIEJlaGF2aW9yXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLWJlaGF2aW9yXG4gICAgICAgKi9cbiAgICAgIFwic2Nyb2xsLWJlaGF2aW9yXCI6IFt7XG4gICAgICAgIHNjcm9sbDogW1wiYXV0b1wiLCBcInNtb290aFwiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBNYXJnaW5cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtbWFyZ2luXG4gICAgICAgKi9cbiAgICAgIFwic2Nyb2xsLW1cIjogW3tcbiAgICAgICAgXCJzY3JvbGwtbVwiOiBRKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgTWFyZ2luIFhcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtbWFyZ2luXG4gICAgICAgKi9cbiAgICAgIFwic2Nyb2xsLW14XCI6IFt7XG4gICAgICAgIFwic2Nyb2xsLW14XCI6IFEoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBNYXJnaW4gWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1tYXJnaW5cbiAgICAgICAqL1xuICAgICAgXCJzY3JvbGwtbXlcIjogW3tcbiAgICAgICAgXCJzY3JvbGwtbXlcIjogUSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIE1hcmdpbiBTdGFydFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1tYXJnaW5cbiAgICAgICAqL1xuICAgICAgXCJzY3JvbGwtbXNcIjogW3tcbiAgICAgICAgXCJzY3JvbGwtbXNcIjogUSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIE1hcmdpbiBFbmRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtbWFyZ2luXG4gICAgICAgKi9cbiAgICAgIFwic2Nyb2xsLW1lXCI6IFt7XG4gICAgICAgIFwic2Nyb2xsLW1lXCI6IFEoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBNYXJnaW4gVG9wXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLW1hcmdpblxuICAgICAgICovXG4gICAgICBcInNjcm9sbC1tdFwiOiBbe1xuICAgICAgICBcInNjcm9sbC1tdFwiOiBRKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgTWFyZ2luIFJpZ2h0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLW1hcmdpblxuICAgICAgICovXG4gICAgICBcInNjcm9sbC1tclwiOiBbe1xuICAgICAgICBcInNjcm9sbC1tclwiOiBRKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgTWFyZ2luIEJvdHRvbVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1tYXJnaW5cbiAgICAgICAqL1xuICAgICAgXCJzY3JvbGwtbWJcIjogW3tcbiAgICAgICAgXCJzY3JvbGwtbWJcIjogUSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIE1hcmdpbiBMZWZ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLW1hcmdpblxuICAgICAgICovXG4gICAgICBcInNjcm9sbC1tbFwiOiBbe1xuICAgICAgICBcInNjcm9sbC1tbFwiOiBRKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgUGFkZGluZ1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgIFwic2Nyb2xsLXBcIjogW3tcbiAgICAgICAgXCJzY3JvbGwtcFwiOiBRKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgUGFkZGluZyBYXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXBhZGRpbmdcbiAgICAgICAqL1xuICAgICAgXCJzY3JvbGwtcHhcIjogW3tcbiAgICAgICAgXCJzY3JvbGwtcHhcIjogUSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIFBhZGRpbmcgWVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1wYWRkaW5nXG4gICAgICAgKi9cbiAgICAgIFwic2Nyb2xsLXB5XCI6IFt7XG4gICAgICAgIFwic2Nyb2xsLXB5XCI6IFEoKVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBQYWRkaW5nIFN0YXJ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXBhZGRpbmdcbiAgICAgICAqL1xuICAgICAgXCJzY3JvbGwtcHNcIjogW3tcbiAgICAgICAgXCJzY3JvbGwtcHNcIjogUSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIFBhZGRpbmcgRW5kXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXBhZGRpbmdcbiAgICAgICAqL1xuICAgICAgXCJzY3JvbGwtcGVcIjogW3tcbiAgICAgICAgXCJzY3JvbGwtcGVcIjogUSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIFBhZGRpbmcgVG9wXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXBhZGRpbmdcbiAgICAgICAqL1xuICAgICAgXCJzY3JvbGwtcHRcIjogW3tcbiAgICAgICAgXCJzY3JvbGwtcHRcIjogUSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIFBhZGRpbmcgUmlnaHRcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtcGFkZGluZ1xuICAgICAgICovXG4gICAgICBcInNjcm9sbC1wclwiOiBbe1xuICAgICAgICBcInNjcm9sbC1wclwiOiBRKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgUGFkZGluZyBCb3R0b21cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtcGFkZGluZ1xuICAgICAgICovXG4gICAgICBcInNjcm9sbC1wYlwiOiBbe1xuICAgICAgICBcInNjcm9sbC1wYlwiOiBRKClcbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTY3JvbGwgUGFkZGluZyBMZWZ0XG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc2Nyb2xsLXBhZGRpbmdcbiAgICAgICAqL1xuICAgICAgXCJzY3JvbGwtcGxcIjogW3tcbiAgICAgICAgXCJzY3JvbGwtcGxcIjogUSgpXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIFNuYXAgQWxpZ25cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zY3JvbGwtc25hcC1hbGlnblxuICAgICAgICovXG4gICAgICBcInNuYXAtYWxpZ25cIjogW3tcbiAgICAgICAgc25hcDogW1wic3RhcnRcIiwgXCJlbmRcIiwgXCJjZW50ZXJcIiwgXCJhbGlnbi1ub25lXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIFNuYXAgU3RvcFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1zbmFwLXN0b3BcbiAgICAgICAqL1xuICAgICAgXCJzbmFwLXN0b3BcIjogW3tcbiAgICAgICAgc25hcDogW1wibm9ybWFsXCIsIFwiYWx3YXlzXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU2Nyb2xsIFNuYXAgVHlwZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1zbmFwLXR5cGVcbiAgICAgICAqL1xuICAgICAgXCJzbmFwLXR5cGVcIjogW3tcbiAgICAgICAgc25hcDogW1wibm9uZVwiLCBcInhcIiwgXCJ5XCIsIFwiYm90aFwiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFNjcm9sbCBTbmFwIFR5cGUgU3RyaWN0bmVzc1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3Njcm9sbC1zbmFwLXR5cGVcbiAgICAgICAqL1xuICAgICAgXCJzbmFwLXN0cmljdG5lc3NcIjogW3tcbiAgICAgICAgc25hcDogW1wibWFuZGF0b3J5XCIsIFwicHJveGltaXR5XCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVG91Y2ggQWN0aW9uXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdG91Y2gtYWN0aW9uXG4gICAgICAgKi9cbiAgICAgIHRvdWNoOiBbe1xuICAgICAgICB0b3VjaDogW1wiYXV0b1wiLCBcIm5vbmVcIiwgXCJtYW5pcHVsYXRpb25cIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBUb3VjaCBBY3Rpb24gWFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3RvdWNoLWFjdGlvblxuICAgICAgICovXG4gICAgICBcInRvdWNoLXhcIjogW3tcbiAgICAgICAgXCJ0b3VjaC1wYW5cIjogW1wieFwiLCBcImxlZnRcIiwgXCJyaWdodFwiXVxuICAgICAgfV0sXG4gICAgICAvKipcbiAgICAgICAqIFRvdWNoIEFjdGlvbiBZXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvdG91Y2gtYWN0aW9uXG4gICAgICAgKi9cbiAgICAgIFwidG91Y2gteVwiOiBbe1xuICAgICAgICBcInRvdWNoLXBhblwiOiBbXCJ5XCIsIFwidXBcIiwgXCJkb3duXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogVG91Y2ggQWN0aW9uIFBpbmNoIFpvb21cbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy90b3VjaC1hY3Rpb25cbiAgICAgICAqL1xuICAgICAgXCJ0b3VjaC1welwiOiBbXCJ0b3VjaC1waW5jaC16b29tXCJdLFxuICAgICAgLyoqXG4gICAgICAgKiBVc2VyIFNlbGVjdFxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3VzZXItc2VsZWN0XG4gICAgICAgKi9cbiAgICAgIHNlbGVjdDogW3tcbiAgICAgICAgc2VsZWN0OiBbXCJub25lXCIsIFwidGV4dFwiLCBcImFsbFwiLCBcImF1dG9cIl1cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBXaWxsIENoYW5nZVxuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3dpbGwtY2hhbmdlXG4gICAgICAgKi9cbiAgICAgIFwid2lsbC1jaGFuZ2VcIjogW3tcbiAgICAgICAgXCJ3aWxsLWNoYW5nZVwiOiBbXCJhdXRvXCIsIFwic2Nyb2xsXCIsIFwiY29udGVudHNcIiwgXCJ0cmFuc2Zvcm1cIiwgVGVdXG4gICAgICB9XSxcbiAgICAgIC8vIFNWR1xuICAgICAgLyoqXG4gICAgICAgKiBGaWxsXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3MvZmlsbFxuICAgICAgICovXG4gICAgICBmaWxsOiBbe1xuICAgICAgICBmaWxsOiBbdCwgXCJub25lXCJdXG4gICAgICB9XSxcbiAgICAgIC8qKlxuICAgICAgICogU3Ryb2tlIFdpZHRoXG4gICAgICAgKiBAc2VlIGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tL2RvY3Mvc3Ryb2tlLXdpZHRoXG4gICAgICAgKi9cbiAgICAgIFwic3Ryb2tlLXdcIjogW3tcbiAgICAgICAgc3Ryb2tlOiBbenIsIFBpLCBCY11cbiAgICAgIH1dLFxuICAgICAgLyoqXG4gICAgICAgKiBTdHJva2VcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9zdHJva2VcbiAgICAgICAqL1xuICAgICAgc3Ryb2tlOiBbe1xuICAgICAgICBzdHJva2U6IFt0LCBcIm5vbmVcIl1cbiAgICAgIH1dLFxuICAgICAgLy8gQWNjZXNzaWJpbGl0eVxuICAgICAgLyoqXG4gICAgICAgKiBTY3JlZW4gUmVhZGVyc1xuICAgICAgICogQHNlZSBodHRwczovL3RhaWx3aW5kY3NzLmNvbS9kb2NzL3NjcmVlbi1yZWFkZXJzXG4gICAgICAgKi9cbiAgICAgIHNyOiBbXCJzci1vbmx5XCIsIFwibm90LXNyLW9ubHlcIl0sXG4gICAgICAvKipcbiAgICAgICAqIEZvcmNlZCBDb2xvciBBZGp1c3RcbiAgICAgICAqIEBzZWUgaHR0cHM6Ly90YWlsd2luZGNzcy5jb20vZG9jcy9mb3JjZWQtY29sb3ItYWRqdXN0XG4gICAgICAgKi9cbiAgICAgIFwiZm9yY2VkLWNvbG9yLWFkanVzdFwiOiBbe1xuICAgICAgICBcImZvcmNlZC1jb2xvci1hZGp1c3RcIjogW1wiYXV0b1wiLCBcIm5vbmVcIl1cbiAgICAgIH1dXG4gICAgfSxcbiAgICBjb25mbGljdGluZ0NsYXNzR3JvdXBzOiB7XG4gICAgICBvdmVyZmxvdzogW1wib3ZlcmZsb3cteFwiLCBcIm92ZXJmbG93LXlcIl0sXG4gICAgICBvdmVyc2Nyb2xsOiBbXCJvdmVyc2Nyb2xsLXhcIiwgXCJvdmVyc2Nyb2xsLXlcIl0sXG4gICAgICBpbnNldDogW1wiaW5zZXQteFwiLCBcImluc2V0LXlcIiwgXCJzdGFydFwiLCBcImVuZFwiLCBcInRvcFwiLCBcInJpZ2h0XCIsIFwiYm90dG9tXCIsIFwibGVmdFwiXSxcbiAgICAgIFwiaW5zZXQteFwiOiBbXCJyaWdodFwiLCBcImxlZnRcIl0sXG4gICAgICBcImluc2V0LXlcIjogW1widG9wXCIsIFwiYm90dG9tXCJdLFxuICAgICAgZmxleDogW1wiYmFzaXNcIiwgXCJncm93XCIsIFwic2hyaW5rXCJdLFxuICAgICAgZ2FwOiBbXCJnYXAteFwiLCBcImdhcC15XCJdLFxuICAgICAgcDogW1wicHhcIiwgXCJweVwiLCBcInBzXCIsIFwicGVcIiwgXCJwdFwiLCBcInByXCIsIFwicGJcIiwgXCJwbFwiXSxcbiAgICAgIHB4OiBbXCJwclwiLCBcInBsXCJdLFxuICAgICAgcHk6IFtcInB0XCIsIFwicGJcIl0sXG4gICAgICBtOiBbXCJteFwiLCBcIm15XCIsIFwibXNcIiwgXCJtZVwiLCBcIm10XCIsIFwibXJcIiwgXCJtYlwiLCBcIm1sXCJdLFxuICAgICAgbXg6IFtcIm1yXCIsIFwibWxcIl0sXG4gICAgICBteTogW1wibXRcIiwgXCJtYlwiXSxcbiAgICAgIHNpemU6IFtcIndcIiwgXCJoXCJdLFxuICAgICAgXCJmb250LXNpemVcIjogW1wibGVhZGluZ1wiXSxcbiAgICAgIFwiZnZuLW5vcm1hbFwiOiBbXCJmdm4tb3JkaW5hbFwiLCBcImZ2bi1zbGFzaGVkLXplcm9cIiwgXCJmdm4tZmlndXJlXCIsIFwiZnZuLXNwYWNpbmdcIiwgXCJmdm4tZnJhY3Rpb25cIl0sXG4gICAgICBcImZ2bi1vcmRpbmFsXCI6IFtcImZ2bi1ub3JtYWxcIl0sXG4gICAgICBcImZ2bi1zbGFzaGVkLXplcm9cIjogW1wiZnZuLW5vcm1hbFwiXSxcbiAgICAgIFwiZnZuLWZpZ3VyZVwiOiBbXCJmdm4tbm9ybWFsXCJdLFxuICAgICAgXCJmdm4tc3BhY2luZ1wiOiBbXCJmdm4tbm9ybWFsXCJdLFxuICAgICAgXCJmdm4tZnJhY3Rpb25cIjogW1wiZnZuLW5vcm1hbFwiXSxcbiAgICAgIFwibGluZS1jbGFtcFwiOiBbXCJkaXNwbGF5XCIsIFwib3ZlcmZsb3dcIl0sXG4gICAgICByb3VuZGVkOiBbXCJyb3VuZGVkLXNcIiwgXCJyb3VuZGVkLWVcIiwgXCJyb3VuZGVkLXRcIiwgXCJyb3VuZGVkLXJcIiwgXCJyb3VuZGVkLWJcIiwgXCJyb3VuZGVkLWxcIiwgXCJyb3VuZGVkLXNzXCIsIFwicm91bmRlZC1zZVwiLCBcInJvdW5kZWQtZWVcIiwgXCJyb3VuZGVkLWVzXCIsIFwicm91bmRlZC10bFwiLCBcInJvdW5kZWQtdHJcIiwgXCJyb3VuZGVkLWJyXCIsIFwicm91bmRlZC1ibFwiXSxcbiAgICAgIFwicm91bmRlZC1zXCI6IFtcInJvdW5kZWQtc3NcIiwgXCJyb3VuZGVkLWVzXCJdLFxuICAgICAgXCJyb3VuZGVkLWVcIjogW1wicm91bmRlZC1zZVwiLCBcInJvdW5kZWQtZWVcIl0sXG4gICAgICBcInJvdW5kZWQtdFwiOiBbXCJyb3VuZGVkLXRsXCIsIFwicm91bmRlZC10clwiXSxcbiAgICAgIFwicm91bmRlZC1yXCI6IFtcInJvdW5kZWQtdHJcIiwgXCJyb3VuZGVkLWJyXCJdLFxuICAgICAgXCJyb3VuZGVkLWJcIjogW1wicm91bmRlZC1iclwiLCBcInJvdW5kZWQtYmxcIl0sXG4gICAgICBcInJvdW5kZWQtbFwiOiBbXCJyb3VuZGVkLXRsXCIsIFwicm91bmRlZC1ibFwiXSxcbiAgICAgIFwiYm9yZGVyLXNwYWNpbmdcIjogW1wiYm9yZGVyLXNwYWNpbmcteFwiLCBcImJvcmRlci1zcGFjaW5nLXlcIl0sXG4gICAgICBcImJvcmRlci13XCI6IFtcImJvcmRlci13LXNcIiwgXCJib3JkZXItdy1lXCIsIFwiYm9yZGVyLXctdFwiLCBcImJvcmRlci13LXJcIiwgXCJib3JkZXItdy1iXCIsIFwiYm9yZGVyLXctbFwiXSxcbiAgICAgIFwiYm9yZGVyLXcteFwiOiBbXCJib3JkZXItdy1yXCIsIFwiYm9yZGVyLXctbFwiXSxcbiAgICAgIFwiYm9yZGVyLXcteVwiOiBbXCJib3JkZXItdy10XCIsIFwiYm9yZGVyLXctYlwiXSxcbiAgICAgIFwiYm9yZGVyLWNvbG9yXCI6IFtcImJvcmRlci1jb2xvci10XCIsIFwiYm9yZGVyLWNvbG9yLXJcIiwgXCJib3JkZXItY29sb3ItYlwiLCBcImJvcmRlci1jb2xvci1sXCJdLFxuICAgICAgXCJib3JkZXItY29sb3IteFwiOiBbXCJib3JkZXItY29sb3ItclwiLCBcImJvcmRlci1jb2xvci1sXCJdLFxuICAgICAgXCJib3JkZXItY29sb3IteVwiOiBbXCJib3JkZXItY29sb3ItdFwiLCBcImJvcmRlci1jb2xvci1iXCJdLFxuICAgICAgXCJzY3JvbGwtbVwiOiBbXCJzY3JvbGwtbXhcIiwgXCJzY3JvbGwtbXlcIiwgXCJzY3JvbGwtbXNcIiwgXCJzY3JvbGwtbWVcIiwgXCJzY3JvbGwtbXRcIiwgXCJzY3JvbGwtbXJcIiwgXCJzY3JvbGwtbWJcIiwgXCJzY3JvbGwtbWxcIl0sXG4gICAgICBcInNjcm9sbC1teFwiOiBbXCJzY3JvbGwtbXJcIiwgXCJzY3JvbGwtbWxcIl0sXG4gICAgICBcInNjcm9sbC1teVwiOiBbXCJzY3JvbGwtbXRcIiwgXCJzY3JvbGwtbWJcIl0sXG4gICAgICBcInNjcm9sbC1wXCI6IFtcInNjcm9sbC1weFwiLCBcInNjcm9sbC1weVwiLCBcInNjcm9sbC1wc1wiLCBcInNjcm9sbC1wZVwiLCBcInNjcm9sbC1wdFwiLCBcInNjcm9sbC1wclwiLCBcInNjcm9sbC1wYlwiLCBcInNjcm9sbC1wbFwiXSxcbiAgICAgIFwic2Nyb2xsLXB4XCI6IFtcInNjcm9sbC1wclwiLCBcInNjcm9sbC1wbFwiXSxcbiAgICAgIFwic2Nyb2xsLXB5XCI6IFtcInNjcm9sbC1wdFwiLCBcInNjcm9sbC1wYlwiXSxcbiAgICAgIHRvdWNoOiBbXCJ0b3VjaC14XCIsIFwidG91Y2gteVwiLCBcInRvdWNoLXB6XCJdLFxuICAgICAgXCJ0b3VjaC14XCI6IFtcInRvdWNoXCJdLFxuICAgICAgXCJ0b3VjaC15XCI6IFtcInRvdWNoXCJdLFxuICAgICAgXCJ0b3VjaC1welwiOiBbXCJ0b3VjaFwiXVxuICAgIH0sXG4gICAgY29uZmxpY3RpbmdDbGFzc0dyb3VwTW9kaWZpZXJzOiB7XG4gICAgICBcImZvbnQtc2l6ZVwiOiBbXCJsZWFkaW5nXCJdXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gWE0odCwge1xuICBjYWNoZVNpemU6IGUsXG4gIHByZWZpeDogbixcbiAgc2VwYXJhdG9yOiByLFxuICBleHRlbmQ6IGkgPSB7fSxcbiAgb3ZlcnJpZGU6IHMgPSB7fVxufSkge1xuICBmdSh0LCBcImNhY2hlU2l6ZVwiLCBlKSwgZnUodCwgXCJwcmVmaXhcIiwgbiksIGZ1KHQsIFwic2VwYXJhdG9yXCIsIHIpO1xuICBmb3IgKGNvbnN0IG8gaW4gcylcbiAgICBqTSh0W29dLCBzW29dKTtcbiAgZm9yIChjb25zdCBvIGluIGkpXG4gICAgQk0odFtvXSwgaVtvXSk7XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gZnUodCwgZSwgbikge1xuICBuICE9PSB2b2lkIDAgJiYgKHRbZV0gPSBuKTtcbn1cbmZ1bmN0aW9uIGpNKHQsIGUpIHtcbiAgaWYgKGUpXG4gICAgZm9yIChjb25zdCBuIGluIGUpXG4gICAgICBmdSh0LCBuLCBlW25dKTtcbn1cbmZ1bmN0aW9uIEJNKHQsIGUpIHtcbiAgaWYgKGUpXG4gICAgZm9yIChjb25zdCBuIGluIGUpIHtcbiAgICAgIGNvbnN0IHIgPSBlW25dO1xuICAgICAgciAhPT0gdm9pZCAwICYmICh0W25dID0gKHRbbl0gfHwgW10pLmNvbmNhdChyKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gTE0odCwgLi4uZSkge1xuICByZXR1cm4gdHlwZW9mIHQgPT0gXCJmdW5jdGlvblwiID8gSTAoVzAsIHQsIC4uLmUpIDogSTAoKCkgPT4gWE0oVzAoKSwgdCksIC4uLmUpO1xufVxudmFyIE0wID0gdHlwZW9mIGdsb2JhbFRoaXMgPCBcInVcIiA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsIDwgXCJ1XCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiA8IFwidVwiID8gc2VsZiA6IHt9O1xuZnVuY3Rpb24gVU0odCkge1xuICByZXR1cm4gdCAmJiB0Ll9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsIFwiZGVmYXVsdFwiKSA/IHQuZGVmYXVsdCA6IHQ7XG59XG52YXIgQ1AgPSB7IGV4cG9ydHM6IHt9IH07XG4oZnVuY3Rpb24odCkge1xuICB2YXIgZSA9IHR5cGVvZiB3aW5kb3cgPCBcInVcIiA/IHdpbmRvdyA6IHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSA8IFwidVwiICYmIHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZSA/IHNlbGYgOiB7fTtcbiAgLyoqXG4gICAqIFByaXNtOiBMaWdodHdlaWdodCwgcm9idXN0LCBlbGVnYW50IHN5bnRheCBoaWdobGlnaHRpbmdcbiAgICpcbiAgICogQGxpY2Vuc2UgTUlUIDxodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVD5cbiAgICogQGF1dGhvciBMZWEgVmVyb3UgPGh0dHBzOi8vbGVhLnZlcm91Lm1lPlxuICAgKiBAbmFtZXNwYWNlXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHZhciBuID0gZnVuY3Rpb24ocikge1xuICAgIHZhciBpID0gLyg/Ol58XFxzKWxhbmcoPzp1YWdlKT8tKFtcXHctXSspKD89XFxzfCQpL2ksIHMgPSAwLCBvID0ge30sIGEgPSB7XG4gICAgICAvKipcbiAgICAgICAqIEJ5IGRlZmF1bHQsIFByaXNtIHdpbGwgYXR0ZW1wdCB0byBoaWdobGlnaHQgYWxsIGNvZGUgZWxlbWVudHMgKGJ5IGNhbGxpbmcge0BsaW5rIFByaXNtLmhpZ2hsaWdodEFsbH0pIG9uIHRoZVxuICAgICAgICogY3VycmVudCBwYWdlIGFmdGVyIHRoZSBwYWdlIGZpbmlzaGVkIGxvYWRpbmcuIFRoaXMgbWlnaHQgYmUgYSBwcm9ibGVtIGlmIGUuZy4geW91IHdhbnRlZCB0byBhc3luY2hyb25vdXNseSBsb2FkXG4gICAgICAgKiBhZGRpdGlvbmFsIGxhbmd1YWdlcyBvciBwbHVnaW5zIHlvdXJzZWxmLlxuICAgICAgICpcbiAgICAgICAqIEJ5IHNldHRpbmcgdGhpcyB2YWx1ZSB0byBgdHJ1ZWAsIFByaXNtIHdpbGwgbm90IGF1dG9tYXRpY2FsbHkgaGlnaGxpZ2h0IGFsbCBjb2RlIGVsZW1lbnRzIG9uIHRoZSBwYWdlLlxuICAgICAgICpcbiAgICAgICAqIFlvdSBvYnZpb3VzbHkgaGF2ZSB0byBjaGFuZ2UgdGhpcyB2YWx1ZSBiZWZvcmUgdGhlIGF1dG9tYXRpYyBoaWdobGlnaHRpbmcgc3RhcnRlZC4gVG8gZG8gdGhpcywgeW91IGNhbiBhZGQgYW5cbiAgICAgICAqIGVtcHR5IFByaXNtIG9iamVjdCBpbnRvIHRoZSBnbG9iYWwgc2NvcGUgYmVmb3JlIGxvYWRpbmcgdGhlIFByaXNtIHNjcmlwdCBsaWtlIHRoaXM6XG4gICAgICAgKlxuICAgICAgICogYGBganNcbiAgICAgICAqIHdpbmRvdy5QcmlzbSA9IHdpbmRvdy5QcmlzbSB8fCB7fTtcbiAgICAgICAqIFByaXNtLm1hbnVhbCA9IHRydWU7XG4gICAgICAgKiAvLyBhZGQgYSBuZXcgPHNjcmlwdD4gdG8gbG9hZCBQcmlzbSdzIHNjcmlwdFxuICAgICAgICogYGBgXG4gICAgICAgKlxuICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICogQG1lbWJlcm9mIFByaXNtXG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKi9cbiAgICAgIG1hbnVhbDogci5QcmlzbSAmJiByLlByaXNtLm1hbnVhbCxcbiAgICAgIC8qKlxuICAgICAgICogQnkgZGVmYXVsdCwgaWYgUHJpc20gaXMgaW4gYSB3ZWIgd29ya2VyLCBpdCBhc3N1bWVzIHRoYXQgaXQgaXMgaW4gYSB3b3JrZXIgaXQgY3JlYXRlZCBpdHNlbGYsIHNvIGl0IHVzZXNcbiAgICAgICAqIGBhZGRFdmVudExpc3RlbmVyYCB0byBjb21tdW5pY2F0ZSB3aXRoIGl0cyBwYXJlbnQgaW5zdGFuY2UuIEhvd2V2ZXIsIGlmIHlvdSdyZSB1c2luZyBQcmlzbSBtYW51YWxseSBpbiB5b3VyXG4gICAgICAgKiBvd24gd29ya2VyLCB5b3UgZG9uJ3Qgd2FudCBpdCB0byBkbyB0aGlzLlxuICAgICAgICpcbiAgICAgICAqIEJ5IHNldHRpbmcgdGhpcyB2YWx1ZSB0byBgdHJ1ZWAsIFByaXNtIHdpbGwgbm90IGFkZCBpdHMgb3duIGxpc3RlbmVycyB0byB0aGUgd29ya2VyLlxuICAgICAgICpcbiAgICAgICAqIFlvdSBvYnZpb3VzbHkgaGF2ZSB0byBjaGFuZ2UgdGhpcyB2YWx1ZSBiZWZvcmUgUHJpc20gZXhlY3V0ZXMuIFRvIGRvIHRoaXMsIHlvdSBjYW4gYWRkIGFuXG4gICAgICAgKiBlbXB0eSBQcmlzbSBvYmplY3QgaW50byB0aGUgZ2xvYmFsIHNjb3BlIGJlZm9yZSBsb2FkaW5nIHRoZSBQcmlzbSBzY3JpcHQgbGlrZSB0aGlzOlxuICAgICAgICpcbiAgICAgICAqIGBgYGpzXG4gICAgICAgKiB3aW5kb3cuUHJpc20gPSB3aW5kb3cuUHJpc20gfHwge307XG4gICAgICAgKiBQcmlzbS5kaXNhYmxlV29ya2VyTWVzc2FnZUhhbmRsZXIgPSB0cnVlO1xuICAgICAgICogLy8gTG9hZCBQcmlzbSdzIHNjcmlwdFxuICAgICAgICogYGBgXG4gICAgICAgKlxuICAgICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAgICogQG1lbWJlcm9mIFByaXNtXG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKi9cbiAgICAgIGRpc2FibGVXb3JrZXJNZXNzYWdlSGFuZGxlcjogci5QcmlzbSAmJiByLlByaXNtLmRpc2FibGVXb3JrZXJNZXNzYWdlSGFuZGxlcixcbiAgICAgIC8qKlxuICAgICAgICogQSBuYW1lc3BhY2UgZm9yIHV0aWxpdHkgbWV0aG9kcy5cbiAgICAgICAqXG4gICAgICAgKiBBbGwgZnVuY3Rpb24gaW4gdGhpcyBuYW1lc3BhY2UgdGhhdCBhcmUgbm90IGV4cGxpY2l0bHkgbWFya2VkIGFzIF9wdWJsaWNfIGFyZSBmb3IgX19pbnRlcm5hbCB1c2Ugb25seV9fIGFuZCBtYXlcbiAgICAgICAqIGNoYW5nZSBvciBkaXNhcHBlYXIgYXQgYW55IHRpbWUuXG4gICAgICAgKlxuICAgICAgICogQG5hbWVzcGFjZVxuICAgICAgICogQG1lbWJlcm9mIFByaXNtXG4gICAgICAgKi9cbiAgICAgIHV0aWw6IHtcbiAgICAgICAgZW5jb2RlOiBmdW5jdGlvbiBiKGcpIHtcbiAgICAgICAgICByZXR1cm4gZyBpbnN0YW5jZW9mIGwgPyBuZXcgbChnLnR5cGUsIGIoZy5jb250ZW50KSwgZy5hbGlhcykgOiBBcnJheS5pc0FycmF5KGcpID8gZy5tYXAoYikgOiBnLnJlcGxhY2UoLyYvZywgXCImYW1wO1wiKS5yZXBsYWNlKC88L2csIFwiJmx0O1wiKS5yZXBsYWNlKC9cXHUwMGEwL2csIFwiIFwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIHR5cGUgb2YgdGhlIGdpdmVuIHZhbHVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge2FueX0gb1xuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiB0eXBlKG51bGwpICAgICAgPT09ICdOdWxsJ1xuICAgICAgICAgKiB0eXBlKHVuZGVmaW5lZCkgPT09ICdVbmRlZmluZWQnXG4gICAgICAgICAqIHR5cGUoMTIzKSAgICAgICA9PT0gJ051bWJlcidcbiAgICAgICAgICogdHlwZSgnZm9vJykgICAgID09PSAnU3RyaW5nJ1xuICAgICAgICAgKiB0eXBlKHRydWUpICAgICAgPT09ICdCb29sZWFuJ1xuICAgICAgICAgKiB0eXBlKFsxLCAyXSkgICAgPT09ICdBcnJheSdcbiAgICAgICAgICogdHlwZSh7fSkgICAgICAgID09PSAnT2JqZWN0J1xuICAgICAgICAgKiB0eXBlKFN0cmluZykgICAgPT09ICdGdW5jdGlvbidcbiAgICAgICAgICogdHlwZSgvYWJjKy8pICAgID09PSAnUmVnRXhwJ1xuICAgICAgICAgKi9cbiAgICAgICAgdHlwZTogZnVuY3Rpb24oYikge1xuICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYikuc2xpY2UoOCwgLTEpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIHVuaXF1ZSBudW1iZXIgZm9yIHRoZSBnaXZlbiBvYmplY3QuIExhdGVyIGNhbGxzIHdpbGwgc3RpbGwgcmV0dXJuIHRoZSBzYW1lIG51bWJlci5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9ialxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgb2JqSWQ6IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgICByZXR1cm4gYi5fX2lkIHx8IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLCBcIl9faWRcIiwgeyB2YWx1ZTogKytzIH0pLCBiLl9faWQ7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIGEgZGVlcCBjbG9uZSBvZiB0aGUgZ2l2ZW4gb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgbWFpbiBpbnRlbmRlZCB1c2Ugb2YgdGhpcyBmdW5jdGlvbiBpcyB0byBjbG9uZSBsYW5ndWFnZSBkZWZpbml0aW9ucy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtUfSBvXG4gICAgICAgICAqIEBwYXJhbSB7UmVjb3JkPG51bWJlciwgYW55Pn0gW3Zpc2l0ZWRdXG4gICAgICAgICAqIEByZXR1cm5zIHtUfVxuICAgICAgICAgKiBAdGVtcGxhdGUgVFxuICAgICAgICAgKi9cbiAgICAgICAgY2xvbmU6IGZ1bmN0aW9uIGIoZywgdikge1xuICAgICAgICAgIHYgPSB2IHx8IHt9O1xuICAgICAgICAgIHZhciBTLCB3O1xuICAgICAgICAgIHN3aXRjaCAoYS51dGlsLnR5cGUoZykpIHtcbiAgICAgICAgICAgIGNhc2UgXCJPYmplY3RcIjpcbiAgICAgICAgICAgICAgaWYgKHcgPSBhLnV0aWwub2JqSWQoZyksIHZbd10pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZbd107XG4gICAgICAgICAgICAgIFMgPSAvKiogQHR5cGUge1JlY29yZDxzdHJpbmcsIGFueT59ICovXG4gICAgICAgICAgICAgIHt9LCB2W3ddID0gUztcbiAgICAgICAgICAgICAgZm9yICh2YXIgayBpbiBnKVxuICAgICAgICAgICAgICAgIGcuaGFzT3duUHJvcGVydHkoaykgJiYgKFNba10gPSBiKGdba10sIHYpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAvKiogQHR5cGUge2FueX0gKi9cbiAgICAgICAgICAgICAgICBTXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjYXNlIFwiQXJyYXlcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIHcgPSBhLnV0aWwub2JqSWQoZyksIHZbd10gPyB2W3ddIDogKFMgPSBbXSwgdlt3XSA9IFMsIGcuZm9yRWFjaChmdW5jdGlvbihfLCBUKSB7XG4gICAgICAgICAgICAgICAgU1tUXSA9IGIoXywgdik7XG4gICAgICAgICAgICAgIH0pLCAvKiogQHR5cGUge2FueX0gKi9cbiAgICAgICAgICAgICAgUyk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICByZXR1cm4gZztcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBQcmlzbSBsYW5ndWFnZSBvZiB0aGUgZ2l2ZW4gZWxlbWVudCBzZXQgYnkgYSBgbGFuZ3VhZ2UteHh4eGAgb3IgYGxhbmcteHh4eGAgY2xhc3MuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIG5vIGxhbmd1YWdlIGlzIHNldCBmb3IgdGhlIGVsZW1lbnQgb3IgdGhlIGVsZW1lbnQgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLCBgbm9uZWAgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICAgICAqL1xuICAgICAgICBnZXRMYW5ndWFnZTogZnVuY3Rpb24oYikge1xuICAgICAgICAgIGZvciAoOyBiOyApIHtcbiAgICAgICAgICAgIHZhciBnID0gaS5leGVjKGIuY2xhc3NOYW1lKTtcbiAgICAgICAgICAgIGlmIChnKVxuICAgICAgICAgICAgICByZXR1cm4gZ1sxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgYiA9IGIucGFyZW50RWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFwibm9uZVwiO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgUHJpc20gYGxhbmd1YWdlLXh4eHhgIGNsYXNzIG9mIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0TGFuZ3VhZ2U6IGZ1bmN0aW9uKGIsIGcpIHtcbiAgICAgICAgICBiLmNsYXNzTmFtZSA9IGIuY2xhc3NOYW1lLnJlcGxhY2UoUmVnRXhwKGksIFwiZ2lcIiksIFwiXCIpLCBiLmNsYXNzTGlzdC5hZGQoXCJsYW5ndWFnZS1cIiArIGcpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyB0aGUgc2NyaXB0IGVsZW1lbnQgdGhhdCBpcyBjdXJyZW50bHkgZXhlY3V0aW5nLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGRvZXMgX19ub3RfXyB3b3JrIGZvciBsaW5lIHNjcmlwdCBlbGVtZW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7SFRNTFNjcmlwdEVsZW1lbnQgfCBudWxsfVxuICAgICAgICAgKi9cbiAgICAgICAgY3VycmVudFNjcmlwdDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCA+IFwidVwiKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgaWYgKFwiY3VycmVudFNjcmlwdFwiIGluIGRvY3VtZW50KVxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgLyoqIEB0eXBlIHthbnl9ICovXG4gICAgICAgICAgICAgIGRvY3VtZW50LmN1cnJlbnRTY3JpcHRcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKFMpIHtcbiAgICAgICAgICAgIHZhciBiID0gKC9hdCBbXihcXHJcXG5dKlxcKCguKik6W146XSs6W146XStcXCkkL2kuZXhlYyhTLnN0YWNrKSB8fCBbXSlbMV07XG4gICAgICAgICAgICBpZiAoYikge1xuICAgICAgICAgICAgICB2YXIgZyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgICBmb3IgKHZhciB2IGluIGcpXG4gICAgICAgICAgICAgICAgaWYgKGdbdl0uc3JjID09IGIpXG4gICAgICAgICAgICAgICAgICByZXR1cm4gZ1t2XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgd2hldGhlciBhIGdpdmVuIGNsYXNzIGlzIGFjdGl2ZSBmb3IgYGVsZW1lbnRgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgY2xhc3MgY2FuIGJlIGFjdGl2YXRlZCBpZiBgZWxlbWVudGAgb3Igb25lIG9mIGl0cyBhbmNlc3RvcnMgaGFzIHRoZSBnaXZlbiBjbGFzcyBhbmQgaXQgY2FuIGJlIGRlYWN0aXZhdGVkXG4gICAgICAgICAqIGlmIGBlbGVtZW50YCBvciBvbmUgb2YgaXRzIGFuY2VzdG9ycyBoYXMgdGhlIG5lZ2F0ZWQgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gY2xhc3MuIFRoZSBfbmVnYXRlZCB2ZXJzaW9uXyBvZiB0aGVcbiAgICAgICAgICogZ2l2ZW4gY2xhc3MgaXMganVzdCB0aGUgZ2l2ZW4gY2xhc3Mgd2l0aCBhIGBuby1gIHByZWZpeC5cbiAgICAgICAgICpcbiAgICAgICAgICogV2hldGhlciB0aGUgY2xhc3MgaXMgYWN0aXZlIGlzIGRldGVybWluZWQgYnkgdGhlIGNsb3Nlc3QgYW5jZXN0b3Igb2YgYGVsZW1lbnRgICh3aGVyZSBgZWxlbWVudGAgaXRzZWxmIGlzXG4gICAgICAgICAqIGNsb3Nlc3QgYW5jZXN0b3IpIHRoYXQgaGFzIHRoZSBnaXZlbiBjbGFzcyBvciB0aGUgbmVnYXRlZCB2ZXJzaW9uIG9mIGl0LiBJZiBuZWl0aGVyIGBlbGVtZW50YCBub3IgYW55IG9mIGl0c1xuICAgICAgICAgKiBhbmNlc3RvcnMgaGF2ZSB0aGUgZ2l2ZW4gY2xhc3Mgb3IgdGhlIG5lZ2F0ZWQgdmVyc2lvbiBvZiBpdCwgdGhlbiB0aGUgZGVmYXVsdCBhY3RpdmF0aW9uIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEluIHRoZSBwYXJhZG94aWNhbCBzaXR1YXRpb24gd2hlcmUgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgY29udGFpbnMgX19ib3RoX18gdGhlIGdpdmVuIGNsYXNzIGFuZCB0aGUgbmVnYXRlZFxuICAgICAgICAgKiB2ZXJzaW9uIG9mIGl0LCB0aGUgY2xhc3MgaXMgY29uc2lkZXJlZCBhY3RpdmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RlZmF1bHRBY3RpdmF0aW9uPWZhbHNlXVxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAgICovXG4gICAgICAgIGlzQWN0aXZlOiBmdW5jdGlvbihiLCBnLCB2KSB7XG4gICAgICAgICAgZm9yICh2YXIgUyA9IFwibm8tXCIgKyBnOyBiOyApIHtcbiAgICAgICAgICAgIHZhciB3ID0gYi5jbGFzc0xpc3Q7XG4gICAgICAgICAgICBpZiAody5jb250YWlucyhnKSlcbiAgICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICAgICAgaWYgKHcuY29udGFpbnMoUykpXG4gICAgICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgICAgIGIgPSBiLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAhIXY7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgbmFtZXNwYWNlIGNvbnRhaW5zIGFsbCBjdXJyZW50bHkgbG9hZGVkIGxhbmd1YWdlcyBhbmQgdGhlIHNvbWUgaGVscGVyIGZ1bmN0aW9ucyB0byBjcmVhdGUgYW5kIG1vZGlmeSBsYW5ndWFnZXMuXG4gICAgICAgKlxuICAgICAgICogQG5hbWVzcGFjZVxuICAgICAgICogQG1lbWJlcm9mIFByaXNtXG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKi9cbiAgICAgIGxhbmd1YWdlczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGdyYW1tYXIgZm9yIHBsYWluLCB1bmZvcm1hdHRlZCB0ZXh0LlxuICAgICAgICAgKi9cbiAgICAgICAgcGxhaW46IG8sXG4gICAgICAgIHBsYWludGV4dDogbyxcbiAgICAgICAgdGV4dDogbyxcbiAgICAgICAgdHh0OiBvLFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIGRlZXAgY29weSBvZiB0aGUgbGFuZ3VhZ2Ugd2l0aCB0aGUgZ2l2ZW4gaWQgYW5kIGFwcGVuZHMgdGhlIGdpdmVuIHRva2Vucy5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYSB0b2tlbiBpbiBgcmVkZWZgIGFsc28gYXBwZWFycyBpbiB0aGUgY29waWVkIGxhbmd1YWdlLCB0aGVuIHRoZSBleGlzdGluZyB0b2tlbiBpbiB0aGUgY29waWVkIGxhbmd1YWdlXG4gICAgICAgICAqIHdpbGwgYmUgb3ZlcndyaXR0ZW4gYXQgaXRzIG9yaWdpbmFsIHBvc2l0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiAjIyBCZXN0IHByYWN0aWNlc1xuICAgICAgICAgKlxuICAgICAgICAgKiBTaW5jZSB0aGUgcG9zaXRpb24gb2Ygb3ZlcndyaXRpbmcgdG9rZW5zICh0b2tlbiBpbiBgcmVkZWZgIHRoYXQgb3ZlcndyaXRlIHRva2VucyBpbiB0aGUgY29waWVkIGxhbmd1YWdlKVxuICAgICAgICAgKiBkb2Vzbid0IG1hdHRlciwgdGhleSBjYW4gdGVjaG5pY2FsbHkgYmUgaW4gYW55IG9yZGVyLiBIb3dldmVyLCB0aGlzIGNhbiBiZSBjb25mdXNpbmcgdG8gb3RoZXJzIHRoYXQgdHJ5aW5nIHRvXG4gICAgICAgICAqIHVuZGVyc3RhbmQgdGhlIGxhbmd1YWdlIGRlZmluaXRpb24gYmVjYXVzZSwgbm9ybWFsbHksIHRoZSBvcmRlciBvZiB0b2tlbnMgbWF0dGVycyBpbiBQcmlzbSBncmFtbWFycy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlcmVmb3JlLCBpdCBpcyBlbmNvdXJhZ2VkIHRvIG9yZGVyIG92ZXJ3cml0aW5nIHRva2VucyBhY2NvcmRpbmcgdG8gdGhlIHBvc2l0aW9ucyBvZiB0aGUgb3ZlcndyaXR0ZW4gdG9rZW5zLlxuICAgICAgICAgKiBGdXJ0aGVybW9yZSwgYWxsIG5vbi1vdmVyd3JpdGluZyB0b2tlbnMgc2hvdWxkIGJlIHBsYWNlZCBhZnRlciB0aGUgb3ZlcndyaXRpbmcgb25lcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBpZCBvZiB0aGUgbGFuZ3VhZ2UgdG8gZXh0ZW5kLiBUaGlzIGhhcyB0byBiZSBhIGtleSBpbiBgUHJpc20ubGFuZ3VhZ2VzYC5cbiAgICAgICAgICogQHBhcmFtIHtHcmFtbWFyfSByZWRlZiBUaGUgbmV3IHRva2VucyB0byBhcHBlbmQuXG4gICAgICAgICAqIEByZXR1cm5zIHtHcmFtbWFyfSBUaGUgbmV3IGxhbmd1YWdlIGNyZWF0ZWQuXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogUHJpc20ubGFuZ3VhZ2VzWydjc3Mtd2l0aC1jb2xvcnMnXSA9IFByaXNtLmxhbmd1YWdlcy5leHRlbmQoJ2NzcycsIHtcbiAgICAgICAgICogICAgIC8vIFByaXNtLmxhbmd1YWdlcy5jc3MgYWxyZWFkeSBoYXMgYSAnY29tbWVudCcgdG9rZW4sIHNvIHRoaXMgdG9rZW4gd2lsbCBvdmVyd3JpdGUgQ1NTJyAnY29tbWVudCcgdG9rZW5cbiAgICAgICAgICogICAgIC8vIGF0IGl0cyBvcmlnaW5hbCBwb3NpdGlvblxuICAgICAgICAgKiAgICAgJ2NvbW1lbnQnOiB7IC4uLiB9LFxuICAgICAgICAgKiAgICAgLy8gQ1NTIGRvZXNuJ3QgaGF2ZSBhICdjb2xvcicgdG9rZW4sIHNvIHRoaXMgdG9rZW4gd2lsbCBiZSBhcHBlbmRlZFxuICAgICAgICAgKiAgICAgJ2NvbG9yJzogL1xcYig/OnJlZHxncmVlbnxibHVlKVxcYi9cbiAgICAgICAgICogfSk7XG4gICAgICAgICAqL1xuICAgICAgICBleHRlbmQ6IGZ1bmN0aW9uKGIsIGcpIHtcbiAgICAgICAgICB2YXIgdiA9IGEudXRpbC5jbG9uZShhLmxhbmd1YWdlc1tiXSk7XG4gICAgICAgICAgZm9yICh2YXIgUyBpbiBnKVxuICAgICAgICAgICAgdltTXSA9IGdbU107XG4gICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbnNlcnRzIHRva2VucyBfYmVmb3JlXyBhbm90aGVyIHRva2VuIGluIGEgbGFuZ3VhZ2UgZGVmaW5pdGlvbiBvciBhbnkgb3RoZXIgZ3JhbW1hci5cbiAgICAgICAgICpcbiAgICAgICAgICogIyMgVXNhZ2VcbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBoZWxwZXIgbWV0aG9kIG1ha2VzIGl0IGVhc3kgdG8gbW9kaWZ5IGV4aXN0aW5nIGxhbmd1YWdlcy4gRm9yIGV4YW1wbGUsIHRoZSBDU1MgbGFuZ3VhZ2UgZGVmaW5pdGlvblxuICAgICAgICAgKiBub3Qgb25seSBkZWZpbmVzIENTUyBoaWdobGlnaHRpbmcgZm9yIENTUyBkb2N1bWVudHMsIGJ1dCBhbHNvIG5lZWRzIHRvIGRlZmluZSBoaWdobGlnaHRpbmcgZm9yIENTUyBlbWJlZGRlZFxuICAgICAgICAgKiBpbiBIVE1MIHRocm91Z2ggYDxzdHlsZT5gIGVsZW1lbnRzLiBUbyBkbyB0aGlzLCBpdCBuZWVkcyB0byBtb2RpZnkgYFByaXNtLmxhbmd1YWdlcy5tYXJrdXBgIGFuZCBhZGQgdGhlXG4gICAgICAgICAqIGFwcHJvcHJpYXRlIHRva2Vucy4gSG93ZXZlciwgYFByaXNtLmxhbmd1YWdlcy5tYXJrdXBgIGlzIGEgcmVndWxhciBKYXZhU2NyaXB0IG9iamVjdCBsaXRlcmFsLCBzbyBpZiB5b3UgZG9cbiAgICAgICAgICogdGhpczpcbiAgICAgICAgICpcbiAgICAgICAgICogYGBganNcbiAgICAgICAgICogUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cC5zdHlsZSA9IHtcbiAgICAgICAgICogICAgIC8vIHRva2VuXG4gICAgICAgICAqIH07XG4gICAgICAgICAqIGBgYFxuICAgICAgICAgKlxuICAgICAgICAgKiB0aGVuIHRoZSBgc3R5bGVgIHRva2VuIHdpbGwgYmUgYWRkZWQgKGFuZCBwcm9jZXNzZWQpIGF0IHRoZSBlbmQuIGBpbnNlcnRCZWZvcmVgIGFsbG93cyB5b3UgdG8gaW5zZXJ0IHRva2Vuc1xuICAgICAgICAgKiBiZWZvcmUgZXhpc3RpbmcgdG9rZW5zLiBGb3IgdGhlIENTUyBleGFtcGxlIGFib3ZlLCB5b3Ugd291bGQgdXNlIGl0IGxpa2UgdGhpczpcbiAgICAgICAgICpcbiAgICAgICAgICogYGBganNcbiAgICAgICAgICogUHJpc20ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZSgnbWFya3VwJywgJ2NkYXRhJywge1xuICAgICAgICAgKiAgICAgJ3N0eWxlJzoge1xuICAgICAgICAgKiAgICAgICAgIC8vIHRva2VuXG4gICAgICAgICAqICAgICB9XG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICpcbiAgICAgICAgICogIyMgU3BlY2lhbCBjYXNlc1xuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGUgZ3JhbW1hcnMgb2YgYGluc2lkZWAgYW5kIGBpbnNlcnRgIGhhdmUgdG9rZW5zIHdpdGggdGhlIHNhbWUgbmFtZSwgdGhlIHRva2VucyBpbiBgaW5zaWRlYCdzIGdyYW1tYXJcbiAgICAgICAgICogd2lsbCBiZSBpZ25vcmVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGJlaGF2aW9yIGNhbiBiZSB1c2VkIHRvIGluc2VydCB0b2tlbnMgYWZ0ZXIgYGJlZm9yZWA6XG4gICAgICAgICAqXG4gICAgICAgICAqIGBgYGpzXG4gICAgICAgICAqIFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ21hcmt1cCcsICdjb21tZW50Jywge1xuICAgICAgICAgKiAgICAgJ2NvbW1lbnQnOiBQcmlzbS5sYW5ndWFnZXMubWFya3VwLmNvbW1lbnQsXG4gICAgICAgICAqICAgICAvLyB0b2tlbnMgYWZ0ZXIgJ2NvbW1lbnQnXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICpcbiAgICAgICAgICogIyMgTGltaXRhdGlvbnNcbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIG1haW4gcHJvYmxlbSBgaW5zZXJ0QmVmb3JlYCBoYXMgdG8gc29sdmUgaXMgaXRlcmF0aW9uIG9yZGVyLiBTaW5jZSBFUzIwMTUsIHRoZSBpdGVyYXRpb24gb3JkZXIgZm9yIG9iamVjdFxuICAgICAgICAgKiBwcm9wZXJ0aWVzIGlzIGd1YXJhbnRlZWQgdG8gYmUgdGhlIGluc2VydGlvbiBvcmRlciAoZXhjZXB0IGZvciBpbnRlZ2VyIGtleXMpIGJ1dCBzb21lIGJyb3dzZXJzIGJlaGF2ZVxuICAgICAgICAgKiBkaWZmZXJlbnRseSB3aGVuIGtleXMgYXJlIGRlbGV0ZWQgYW5kIHJlLWluc2VydGVkLiBTbyBgaW5zZXJ0QmVmb3JlYCBjYW4ndCBiZSBpbXBsZW1lbnRlZCBieSB0ZW1wb3JhcmlseVxuICAgICAgICAgKiBkZWxldGluZyBwcm9wZXJ0aWVzIHdoaWNoIGlzIG5lY2Vzc2FyeSB0byBpbnNlcnQgYXQgYXJiaXRyYXJ5IHBvc2l0aW9ucy5cbiAgICAgICAgICpcbiAgICAgICAgICogVG8gc29sdmUgdGhpcyBwcm9ibGVtLCBgaW5zZXJ0QmVmb3JlYCBkb2Vzbid0IGFjdHVhbGx5IGluc2VydCB0aGUgZ2l2ZW4gdG9rZW5zIGludG8gdGhlIHRhcmdldCBvYmplY3QuXG4gICAgICAgICAqIEluc3RlYWQsIGl0IHdpbGwgY3JlYXRlIGEgbmV3IG9iamVjdCBhbmQgcmVwbGFjZSBhbGwgcmVmZXJlbmNlcyB0byB0aGUgdGFyZ2V0IG9iamVjdCB3aXRoIHRoZSBuZXcgb25lLiBUaGlzXG4gICAgICAgICAqIGNhbiBiZSBkb25lIHdpdGhvdXQgdGVtcG9yYXJpbHkgZGVsZXRpbmcgcHJvcGVydGllcywgc28gdGhlIGl0ZXJhdGlvbiBvcmRlciBpcyB3ZWxsLWRlZmluZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEhvd2V2ZXIsIG9ubHkgcmVmZXJlbmNlcyB0aGF0IGNhbiBiZSByZWFjaGVkIGZyb20gYFByaXNtLmxhbmd1YWdlc2Agb3IgYGluc2VydGAgd2lsbCBiZSByZXBsYWNlZC4gSS5lLiBpZlxuICAgICAgICAgKiB5b3UgaG9sZCB0aGUgdGFyZ2V0IG9iamVjdCBpbiBhIHZhcmlhYmxlLCB0aGVuIHRoZSB2YWx1ZSBvZiB0aGUgdmFyaWFibGUgd2lsbCBub3QgY2hhbmdlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBgYGBqc1xuICAgICAgICAgKiB2YXIgb2xkTWFya3VwID0gUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cDtcbiAgICAgICAgICogdmFyIG5ld01hcmt1cCA9IFByaXNtLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoJ21hcmt1cCcsICdjb21tZW50JywgeyAuLi4gfSk7XG4gICAgICAgICAqXG4gICAgICAgICAqIGFzc2VydChvbGRNYXJrdXAgIT09IFByaXNtLmxhbmd1YWdlcy5tYXJrdXApO1xuICAgICAgICAgKiBhc3NlcnQobmV3TWFya3VwID09PSBQcmlzbS5sYW5ndWFnZXMubWFya3VwKTtcbiAgICAgICAgICogYGBgXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnNpZGUgVGhlIHByb3BlcnR5IG9mIGByb290YCAoZS5nLiBhIGxhbmd1YWdlIGlkIGluIGBQcmlzbS5sYW5ndWFnZXNgKSB0aGF0IGNvbnRhaW5zIHRoZVxuICAgICAgICAgKiBvYmplY3QgdG8gYmUgbW9kaWZpZWQuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiZWZvcmUgVGhlIGtleSB0byBpbnNlcnQgYmVmb3JlLlxuICAgICAgICAgKiBAcGFyYW0ge0dyYW1tYXJ9IGluc2VydCBBbiBvYmplY3QgY29udGFpbmluZyB0aGUga2V5LXZhbHVlIHBhaXJzIHRvIGJlIGluc2VydGVkLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IFtyb290XSBUaGUgb2JqZWN0IGNvbnRhaW5pbmcgYGluc2lkZWAsIGkuZS4gdGhlIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZVxuICAgICAgICAgKiBvYmplY3QgdG8gYmUgbW9kaWZpZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIERlZmF1bHRzIHRvIGBQcmlzbS5sYW5ndWFnZXNgLlxuICAgICAgICAgKiBAcmV0dXJucyB7R3JhbW1hcn0gVGhlIG5ldyBncmFtbWFyIG9iamVjdC5cbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKi9cbiAgICAgICAgaW5zZXJ0QmVmb3JlOiBmdW5jdGlvbihiLCBnLCB2LCBTKSB7XG4gICAgICAgICAgUyA9IFMgfHwgLyoqIEB0eXBlIHthbnl9ICovXG4gICAgICAgICAgYS5sYW5ndWFnZXM7XG4gICAgICAgICAgdmFyIHcgPSBTW2JdLCBrID0ge307XG4gICAgICAgICAgZm9yICh2YXIgXyBpbiB3KVxuICAgICAgICAgICAgaWYgKHcuaGFzT3duUHJvcGVydHkoXykpIHtcbiAgICAgICAgICAgICAgaWYgKF8gPT0gZylcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBUIGluIHYpXG4gICAgICAgICAgICAgICAgICB2Lmhhc093blByb3BlcnR5KFQpICYmIChrW1RdID0gdltUXSk7XG4gICAgICAgICAgICAgIHYuaGFzT3duUHJvcGVydHkoXykgfHwgKGtbX10gPSB3W19dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgQyA9IFNbYl07XG4gICAgICAgICAgcmV0dXJuIFNbYl0gPSBrLCBhLmxhbmd1YWdlcy5ERlMoYS5sYW5ndWFnZXMsIGZ1bmN0aW9uKEEsIFEpIHtcbiAgICAgICAgICAgIFEgPT09IEMgJiYgQSAhPSBiICYmICh0aGlzW0FdID0gayk7XG4gICAgICAgICAgfSksIGs7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFRyYXZlcnNlIGEgbGFuZ3VhZ2UgZGVmaW5pdGlvbiB3aXRoIERlcHRoIEZpcnN0IFNlYXJjaFxuICAgICAgICBERlM6IGZ1bmN0aW9uIGIoZywgdiwgUywgdykge1xuICAgICAgICAgIHcgPSB3IHx8IHt9O1xuICAgICAgICAgIHZhciBrID0gYS51dGlsLm9iaklkO1xuICAgICAgICAgIGZvciAodmFyIF8gaW4gZylcbiAgICAgICAgICAgIGlmIChnLmhhc093blByb3BlcnR5KF8pKSB7XG4gICAgICAgICAgICAgIHYuY2FsbChnLCBfLCBnW19dLCBTIHx8IF8pO1xuICAgICAgICAgICAgICB2YXIgVCA9IGdbX10sIEMgPSBhLnV0aWwudHlwZShUKTtcbiAgICAgICAgICAgICAgQyA9PT0gXCJPYmplY3RcIiAmJiAhd1trKFQpXSA/ICh3W2soVCldID0gITAsIGIoVCwgdiwgbnVsbCwgdykpIDogQyA9PT0gXCJBcnJheVwiICYmICF3W2soVCldICYmICh3W2soVCldID0gITAsIGIoVCwgdiwgXywgdykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcGx1Z2luczoge30sXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgaXMgdGhlIG1vc3QgaGlnaC1sZXZlbCBmdW5jdGlvbiBpbiBQcmlzbeKAmXMgQVBJLlxuICAgICAgICogSXQgZmV0Y2hlcyBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgaGF2ZSBhIGAubGFuZ3VhZ2UteHh4eGAgY2xhc3MgYW5kIHRoZW4gY2FsbHMge0BsaW5rIFByaXNtLmhpZ2hsaWdodEVsZW1lbnR9IG9uXG4gICAgICAgKiBlYWNoIG9uZSBvZiB0aGVtLlxuICAgICAgICpcbiAgICAgICAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byBgUHJpc20uaGlnaGxpZ2h0QWxsVW5kZXIoZG9jdW1lbnQsIGFzeW5jLCBjYWxsYmFjaylgLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FzeW5jPWZhbHNlXSBTYW1lIGFzIGluIHtAbGluayBQcmlzbS5oaWdobGlnaHRBbGxVbmRlcn0uXG4gICAgICAgKiBAcGFyYW0ge0hpZ2hsaWdodENhbGxiYWNrfSBbY2FsbGJhY2tdIFNhbWUgYXMgaW4ge0BsaW5rIFByaXNtLmhpZ2hsaWdodEFsbFVuZGVyfS5cbiAgICAgICAqIEBtZW1iZXJvZiBQcmlzbVxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG4gICAgICBoaWdobGlnaHRBbGw6IGZ1bmN0aW9uKGIsIGcpIHtcbiAgICAgICAgYS5oaWdobGlnaHRBbGxVbmRlcihkb2N1bWVudCwgYiwgZyk7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAgKiBGZXRjaGVzIGFsbCB0aGUgZGVzY2VuZGFudHMgb2YgYGNvbnRhaW5lcmAgdGhhdCBoYXZlIGEgYC5sYW5ndWFnZS14eHh4YCBjbGFzcyBhbmQgdGhlbiBjYWxsc1xuICAgICAgICoge0BsaW5rIFByaXNtLmhpZ2hsaWdodEVsZW1lbnR9IG9uIGVhY2ggb25lIG9mIHRoZW0uXG4gICAgICAgKlxuICAgICAgICogVGhlIGZvbGxvd2luZyBob29rcyB3aWxsIGJlIHJ1bjpcbiAgICAgICAqIDEuIGBiZWZvcmUtaGlnaGxpZ2h0YWxsYFxuICAgICAgICogMi4gYGJlZm9yZS1hbGwtZWxlbWVudHMtaGlnaGxpZ2h0YFxuICAgICAgICogMy4gQWxsIGhvb2tzIG9mIHtAbGluayBQcmlzbS5oaWdobGlnaHRFbGVtZW50fSBmb3IgZWFjaCBlbGVtZW50LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7UGFyZW50Tm9kZX0gY29udGFpbmVyIFRoZSByb290IGVsZW1lbnQsIHdob3NlIGRlc2NlbmRhbnRzIHRoYXQgaGF2ZSBhIGAubGFuZ3VhZ2UteHh4eGAgY2xhc3Mgd2lsbCBiZSBoaWdobGlnaHRlZC5cbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FzeW5jPWZhbHNlXSBXaGV0aGVyIGVhY2ggZWxlbWVudCBpcyB0byBiZSBoaWdobGlnaHRlZCBhc3luY2hyb25vdXNseSB1c2luZyBXZWIgV29ya2Vycy5cbiAgICAgICAqIEBwYXJhbSB7SGlnaGxpZ2h0Q2FsbGJhY2t9IFtjYWxsYmFja10gQW4gb3B0aW9uYWwgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCBvbiBlYWNoIGVsZW1lbnQgYWZ0ZXIgaXRzIGhpZ2hsaWdodGluZyBpcyBkb25lLlxuICAgICAgICogQG1lbWJlcm9mIFByaXNtXG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKi9cbiAgICAgIGhpZ2hsaWdodEFsbFVuZGVyOiBmdW5jdGlvbihiLCBnLCB2KSB7XG4gICAgICAgIHZhciBTID0ge1xuICAgICAgICAgIGNhbGxiYWNrOiB2LFxuICAgICAgICAgIGNvbnRhaW5lcjogYixcbiAgICAgICAgICBzZWxlY3RvcjogJ2NvZGVbY2xhc3MqPVwibGFuZ3VhZ2UtXCJdLCBbY2xhc3MqPVwibGFuZ3VhZ2UtXCJdIGNvZGUsIGNvZGVbY2xhc3MqPVwibGFuZy1cIl0sIFtjbGFzcyo9XCJsYW5nLVwiXSBjb2RlJ1xuICAgICAgICB9O1xuICAgICAgICBhLmhvb2tzLnJ1bihcImJlZm9yZS1oaWdobGlnaHRhbGxcIiwgUyksIFMuZWxlbWVudHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoUy5jb250YWluZXIucXVlcnlTZWxlY3RvckFsbChTLnNlbGVjdG9yKSksIGEuaG9va3MucnVuKFwiYmVmb3JlLWFsbC1lbGVtZW50cy1oaWdobGlnaHRcIiwgUyk7XG4gICAgICAgIGZvciAodmFyIHcgPSAwLCBrOyBrID0gUy5lbGVtZW50c1t3KytdOyApXG4gICAgICAgICAgYS5oaWdobGlnaHRFbGVtZW50KGssIGcgPT09ICEwLCBTLmNhbGxiYWNrKTtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIEhpZ2hsaWdodHMgdGhlIGNvZGUgaW5zaWRlIGEgc2luZ2xlIGVsZW1lbnQuXG4gICAgICAgKlxuICAgICAgICogVGhlIGZvbGxvd2luZyBob29rcyB3aWxsIGJlIHJ1bjpcbiAgICAgICAqIDEuIGBiZWZvcmUtc2FuaXR5LWNoZWNrYFxuICAgICAgICogMi4gYGJlZm9yZS1oaWdobGlnaHRgXG4gICAgICAgKiAzLiBBbGwgaG9va3Mgb2Yge0BsaW5rIFByaXNtLmhpZ2hsaWdodH0uIFRoZXNlIGhvb2tzIHdpbGwgYmUgcnVuIGJ5IGFuIGFzeW5jaHJvbm91cyB3b3JrZXIgaWYgYGFzeW5jYCBpcyBgdHJ1ZWAuXG4gICAgICAgKiA0LiBgYmVmb3JlLWluc2VydGBcbiAgICAgICAqIDUuIGBhZnRlci1oaWdobGlnaHRgXG4gICAgICAgKiA2LiBgY29tcGxldGVgXG4gICAgICAgKlxuICAgICAgICogU29tZSB0aGUgYWJvdmUgaG9va3Mgd2lsbCBiZSBza2lwcGVkIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgY29udGFpbiBhbnkgdGV4dCBvciB0aGVyZSBpcyBubyBncmFtbWFyIGxvYWRlZCBmb3JcbiAgICAgICAqIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIGNvZGUuXG4gICAgICAgKiBJdCBtdXN0IGhhdmUgYSBjbGFzcyBvZiBgbGFuZ3VhZ2UteHh4eGAgdG8gYmUgcHJvY2Vzc2VkLCB3aGVyZSBgeHh4eGAgaXMgYSB2YWxpZCBsYW5ndWFnZSBpZGVudGlmaWVyLlxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBbYXN5bmM9ZmFsc2VdIFdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgdG8gYmUgaGlnaGxpZ2h0ZWQgYXN5bmNocm9ub3VzbHkgdXNpbmcgV2ViIFdvcmtlcnNcbiAgICAgICAqIHRvIGltcHJvdmUgcGVyZm9ybWFuY2UgYW5kIGF2b2lkIGJsb2NraW5nIHRoZSBVSSB3aGVuIGhpZ2hsaWdodGluZyB2ZXJ5IGxhcmdlIGNodW5rcyBvZiBjb2RlLiBUaGlzIG9wdGlvbiBpc1xuICAgICAgICogW2Rpc2FibGVkIGJ5IGRlZmF1bHRdKGh0dHBzOi8vcHJpc21qcy5jb20vZmFxLmh0bWwjd2h5LWlzLWFzeW5jaHJvbm91cy1oaWdobGlnaHRpbmctZGlzYWJsZWQtYnktZGVmYXVsdCkuXG4gICAgICAgKlxuICAgICAgICogTm90ZTogQWxsIGxhbmd1YWdlIGRlZmluaXRpb25zIHJlcXVpcmVkIHRvIGhpZ2hsaWdodCB0aGUgY29kZSBtdXN0IGJlIGluY2x1ZGVkIGluIHRoZSBtYWluIGBwcmlzbS5qc2AgZmlsZSBmb3JcbiAgICAgICAqIGFzeW5jaHJvbm91cyBoaWdobGlnaHRpbmcgdG8gd29yay4gWW91IGNhbiBidWlsZCB5b3VyIG93biBidW5kbGUgb24gdGhlXG4gICAgICAgKiBbRG93bmxvYWQgcGFnZV0oaHR0cHM6Ly9wcmlzbWpzLmNvbS9kb3dubG9hZC5odG1sKS5cbiAgICAgICAqIEBwYXJhbSB7SGlnaGxpZ2h0Q2FsbGJhY2t9IFtjYWxsYmFja10gQW4gb3B0aW9uYWwgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCBhZnRlciB0aGUgaGlnaGxpZ2h0aW5nIGlzIGRvbmUuXG4gICAgICAgKiBNb3N0bHkgdXNlZnVsIHdoZW4gYGFzeW5jYCBpcyBgdHJ1ZWAsIHNpbmNlIGluIHRoYXQgY2FzZSwgdGhlIGhpZ2hsaWdodGluZyBpcyBkb25lIGFzeW5jaHJvbm91c2x5LlxuICAgICAgICogQG1lbWJlcm9mIFByaXNtXG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKi9cbiAgICAgIGhpZ2hsaWdodEVsZW1lbnQ6IGZ1bmN0aW9uKGIsIGcsIHYpIHtcbiAgICAgICAgdmFyIFMgPSBhLnV0aWwuZ2V0TGFuZ3VhZ2UoYiksIHcgPSBhLmxhbmd1YWdlc1tTXTtcbiAgICAgICAgYS51dGlsLnNldExhbmd1YWdlKGIsIFMpO1xuICAgICAgICB2YXIgayA9IGIucGFyZW50RWxlbWVudDtcbiAgICAgICAgayAmJiBrLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwicHJlXCIgJiYgYS51dGlsLnNldExhbmd1YWdlKGssIFMpO1xuICAgICAgICB2YXIgXyA9IGIudGV4dENvbnRlbnQsIFQgPSB7XG4gICAgICAgICAgZWxlbWVudDogYixcbiAgICAgICAgICBsYW5ndWFnZTogUyxcbiAgICAgICAgICBncmFtbWFyOiB3LFxuICAgICAgICAgIGNvZGU6IF9cbiAgICAgICAgfTtcbiAgICAgICAgZnVuY3Rpb24gQyhRKSB7XG4gICAgICAgICAgVC5oaWdobGlnaHRlZENvZGUgPSBRLCBhLmhvb2tzLnJ1bihcImJlZm9yZS1pbnNlcnRcIiwgVCksIFQuZWxlbWVudC5pbm5lckhUTUwgPSBULmhpZ2hsaWdodGVkQ29kZSwgYS5ob29rcy5ydW4oXCJhZnRlci1oaWdobGlnaHRcIiwgVCksIGEuaG9va3MucnVuKFwiY29tcGxldGVcIiwgVCksIHYgJiYgdi5jYWxsKFQuZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEuaG9va3MucnVuKFwiYmVmb3JlLXNhbml0eS1jaGVja1wiLCBUKSwgayA9IFQuZWxlbWVudC5wYXJlbnRFbGVtZW50LCBrICYmIGsubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJwcmVcIiAmJiAhay5oYXNBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiKSAmJiBrLnNldEF0dHJpYnV0ZShcInRhYmluZGV4XCIsIFwiMFwiKSwgIVQuY29kZSkge1xuICAgICAgICAgIGEuaG9va3MucnVuKFwiY29tcGxldGVcIiwgVCksIHYgJiYgdi5jYWxsKFQuZWxlbWVudCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhLmhvb2tzLnJ1bihcImJlZm9yZS1oaWdobGlnaHRcIiwgVCksICFULmdyYW1tYXIpIHtcbiAgICAgICAgICBDKGEudXRpbC5lbmNvZGUoVC5jb2RlKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnICYmIHIuV29ya2VyKSB7XG4gICAgICAgICAgdmFyIEEgPSBuZXcgV29ya2VyKGEuZmlsZW5hbWUpO1xuICAgICAgICAgIEEub25tZXNzYWdlID0gZnVuY3Rpb24oUSkge1xuICAgICAgICAgICAgQyhRLmRhdGEpO1xuICAgICAgICAgIH0sIEEucG9zdE1lc3NhZ2UoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgbGFuZ3VhZ2U6IFQubGFuZ3VhZ2UsXG4gICAgICAgICAgICBjb2RlOiBULmNvZGUsXG4gICAgICAgICAgICBpbW1lZGlhdGVDbG9zZTogITBcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIEMoYS5oaWdobGlnaHQoVC5jb2RlLCBULmdyYW1tYXIsIFQubGFuZ3VhZ2UpKTtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIExvdy1sZXZlbCBmdW5jdGlvbiwgb25seSB1c2UgaWYgeW91IGtub3cgd2hhdCB5b3XigJlyZSBkb2luZy4gSXQgYWNjZXB0cyBhIHN0cmluZyBvZiB0ZXh0IGFzIGlucHV0XG4gICAgICAgKiBhbmQgdGhlIGxhbmd1YWdlIGRlZmluaXRpb25zIHRvIHVzZSwgYW5kIHJldHVybnMgYSBzdHJpbmcgd2l0aCB0aGUgSFRNTCBwcm9kdWNlZC5cbiAgICAgICAqXG4gICAgICAgKiBUaGUgZm9sbG93aW5nIGhvb2tzIHdpbGwgYmUgcnVuOlxuICAgICAgICogMS4gYGJlZm9yZS10b2tlbml6ZWBcbiAgICAgICAqIDIuIGBhZnRlci10b2tlbml6ZWBcbiAgICAgICAqIDMuIGB3cmFwYDogT24gZWFjaCB7QGxpbmsgVG9rZW59LlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IEEgc3RyaW5nIHdpdGggdGhlIGNvZGUgdG8gYmUgaGlnaGxpZ2h0ZWQuXG4gICAgICAgKiBAcGFyYW0ge0dyYW1tYXJ9IGdyYW1tYXIgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHRva2VucyB0byB1c2UuXG4gICAgICAgKlxuICAgICAgICogVXN1YWxseSBhIGxhbmd1YWdlIGRlZmluaXRpb24gbGlrZSBgUHJpc20ubGFuZ3VhZ2VzLm1hcmt1cGAuXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2UgVGhlIG5hbWUgb2YgdGhlIGxhbmd1YWdlIGRlZmluaXRpb24gcGFzc2VkIHRvIGBncmFtbWFyYC5cbiAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBoaWdobGlnaHRlZCBIVE1MLlxuICAgICAgICogQG1lbWJlcm9mIFByaXNtXG4gICAgICAgKiBAcHVibGljXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogUHJpc20uaGlnaGxpZ2h0KCd2YXIgZm9vID0gdHJ1ZTsnLCBQcmlzbS5sYW5ndWFnZXMuamF2YXNjcmlwdCwgJ2phdmFzY3JpcHQnKTtcbiAgICAgICAqL1xuICAgICAgaGlnaGxpZ2h0OiBmdW5jdGlvbihiLCBnLCB2KSB7XG4gICAgICAgIHZhciBTID0ge1xuICAgICAgICAgIGNvZGU6IGIsXG4gICAgICAgICAgZ3JhbW1hcjogZyxcbiAgICAgICAgICBsYW5ndWFnZTogdlxuICAgICAgICB9O1xuICAgICAgICBpZiAoYS5ob29rcy5ydW4oXCJiZWZvcmUtdG9rZW5pemVcIiwgUyksICFTLmdyYW1tYXIpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgbGFuZ3VhZ2UgXCInICsgUy5sYW5ndWFnZSArICdcIiBoYXMgbm8gZ3JhbW1hci4nKTtcbiAgICAgICAgcmV0dXJuIFMudG9rZW5zID0gYS50b2tlbml6ZShTLmNvZGUsIFMuZ3JhbW1hciksIGEuaG9va3MucnVuKFwiYWZ0ZXItdG9rZW5pemVcIiwgUyksIGwuc3RyaW5naWZ5KGEudXRpbC5lbmNvZGUoUy50b2tlbnMpLCBTLmxhbmd1YWdlKTtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIFRoaXMgaXMgdGhlIGhlYXJ0IG9mIFByaXNtLCBhbmQgdGhlIG1vc3QgbG93LWxldmVsIGZ1bmN0aW9uIHlvdSBjYW4gdXNlLiBJdCBhY2NlcHRzIGEgc3RyaW5nIG9mIHRleHQgYXMgaW5wdXRcbiAgICAgICAqIGFuZCB0aGUgbGFuZ3VhZ2UgZGVmaW5pdGlvbnMgdG8gdXNlLCBhbmQgcmV0dXJucyBhbiBhcnJheSB3aXRoIHRoZSB0b2tlbml6ZWQgY29kZS5cbiAgICAgICAqXG4gICAgICAgKiBXaGVuIHRoZSBsYW5ndWFnZSBkZWZpbml0aW9uIGluY2x1ZGVzIG5lc3RlZCB0b2tlbnMsIHRoZSBmdW5jdGlvbiBpcyBjYWxsZWQgcmVjdXJzaXZlbHkgb24gZWFjaCBvZiB0aGVzZSB0b2tlbnMuXG4gICAgICAgKlxuICAgICAgICogVGhpcyBtZXRob2QgY291bGQgYmUgdXNlZnVsIGluIG90aGVyIGNvbnRleHRzIGFzIHdlbGwsIGFzIGEgdmVyeSBjcnVkZSBwYXJzZXIuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgQSBzdHJpbmcgd2l0aCB0aGUgY29kZSB0byBiZSBoaWdobGlnaHRlZC5cbiAgICAgICAqIEBwYXJhbSB7R3JhbW1hcn0gZ3JhbW1hciBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgdG9rZW5zIHRvIHVzZS5cbiAgICAgICAqXG4gICAgICAgKiBVc3VhbGx5IGEgbGFuZ3VhZ2UgZGVmaW5pdGlvbiBsaWtlIGBQcmlzbS5sYW5ndWFnZXMubWFya3VwYC5cbiAgICAgICAqIEByZXR1cm5zIHtUb2tlblN0cmVhbX0gQW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQgdG9rZW5zLCBhIHRva2VuIHN0cmVhbS5cbiAgICAgICAqIEBtZW1iZXJvZiBQcmlzbVxuICAgICAgICogQHB1YmxpY1xuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqIGxldCBjb2RlID0gYHZhciBmb28gPSAwO2A7XG4gICAgICAgKiBsZXQgdG9rZW5zID0gUHJpc20udG9rZW5pemUoY29kZSwgUHJpc20ubGFuZ3VhZ2VzLmphdmFzY3JpcHQpO1xuICAgICAgICogdG9rZW5zLmZvckVhY2godG9rZW4gPT4ge1xuICAgICAgICogICAgIGlmICh0b2tlbiBpbnN0YW5jZW9mIFByaXNtLlRva2VuICYmIHRva2VuLnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgKiAgICAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCBudW1lcmljIGxpdGVyYWw6ICR7dG9rZW4uY29udGVudH1gKTtcbiAgICAgICAqICAgICB9XG4gICAgICAgKiB9KTtcbiAgICAgICAqL1xuICAgICAgdG9rZW5pemU6IGZ1bmN0aW9uKGIsIGcpIHtcbiAgICAgICAgdmFyIHYgPSBnLnJlc3Q7XG4gICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgZm9yICh2YXIgUyBpbiB2KVxuICAgICAgICAgICAgZ1tTXSA9IHZbU107XG4gICAgICAgICAgZGVsZXRlIGcucmVzdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdyA9IG5ldyBkKCk7XG4gICAgICAgIHJldHVybiBmKHcsIHcuaGVhZCwgYiksIHUoYiwgdywgZywgdy5oZWFkLCAwKSwgcCh3KTtcbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAqIEBuYW1lc3BhY2VcbiAgICAgICAqIEBtZW1iZXJvZiBQcmlzbVxuICAgICAgICogQHB1YmxpY1xuICAgICAgICovXG4gICAgICBob29rczoge1xuICAgICAgICBhbGw6IHt9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyB0aGUgZ2l2ZW4gY2FsbGJhY2sgdG8gdGhlIGxpc3Qgb2YgY2FsbGJhY2tzIGZvciB0aGUgZ2l2ZW4gaG9vay5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGNhbGxiYWNrIHdpbGwgYmUgaW52b2tlZCB3aGVuIHRoZSBob29rIGl0IGlzIHJlZ2lzdGVyZWQgZm9yIGlzIHJ1bi5cbiAgICAgICAgICogSG9va3MgYXJlIHVzdWFsbHkgZGlyZWN0bHkgcnVuIGJ5IGEgaGlnaGxpZ2h0IGZ1bmN0aW9uIGJ1dCB5b3UgY2FuIGFsc28gcnVuIGhvb2tzIHlvdXJzZWxmLlxuICAgICAgICAgKlxuICAgICAgICAgKiBPbmUgY2FsbGJhY2sgZnVuY3Rpb24gY2FuIGJlIHJlZ2lzdGVyZWQgdG8gbXVsdGlwbGUgaG9va3MgYW5kIHRoZSBzYW1lIGhvb2sgbXVsdGlwbGUgdGltZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBob29rLlxuICAgICAgICAgKiBAcGFyYW0ge0hvb2tDYWxsYmFja30gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdoaWNoIGlzIGdpdmVuIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAgICAgICAgICogQHB1YmxpY1xuICAgICAgICAgKi9cbiAgICAgICAgYWRkOiBmdW5jdGlvbihiLCBnKSB7XG4gICAgICAgICAgdmFyIHYgPSBhLmhvb2tzLmFsbDtcbiAgICAgICAgICB2W2JdID0gdltiXSB8fCBbXSwgdltiXS5wdXNoKGcpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUnVucyBhIGhvb2sgaW52b2tpbmcgYWxsIHJlZ2lzdGVyZWQgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQ2FsbGJhY2tzIHdpbGwgYmUgaW52b2tlZCBzeW5jaHJvbm91c2x5IGFuZCBpbiB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSB3ZXJlIHJlZ2lzdGVyZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBob29rLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IGVudiBUaGUgZW52aXJvbm1lbnQgdmFyaWFibGVzIG9mIHRoZSBob29rIHBhc3NlZCB0byBhbGwgY2FsbGJhY2tzIHJlZ2lzdGVyZWQuXG4gICAgICAgICAqIEBwdWJsaWNcbiAgICAgICAgICovXG4gICAgICAgIHJ1bjogZnVuY3Rpb24oYiwgZykge1xuICAgICAgICAgIHZhciB2ID0gYS5ob29rcy5hbGxbYl07XG4gICAgICAgICAgaWYgKCEoIXYgfHwgIXYubGVuZ3RoKSlcbiAgICAgICAgICAgIGZvciAodmFyIFMgPSAwLCB3OyB3ID0gdltTKytdOyApXG4gICAgICAgICAgICAgIHcoZyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBUb2tlbjogbFxuICAgIH07XG4gICAgci5QcmlzbSA9IGE7XG4gICAgZnVuY3Rpb24gbChiLCBnLCB2LCBTKSB7XG4gICAgICB0aGlzLnR5cGUgPSBiLCB0aGlzLmNvbnRlbnQgPSBnLCB0aGlzLmFsaWFzID0gdiwgdGhpcy5sZW5ndGggPSAoUyB8fCBcIlwiKS5sZW5ndGggfCAwO1xuICAgIH1cbiAgICBsLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIGIoZywgdikge1xuICAgICAgaWYgKHR5cGVvZiBnID09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBnO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZykpIHtcbiAgICAgICAgdmFyIFMgPSBcIlwiO1xuICAgICAgICByZXR1cm4gZy5mb3JFYWNoKGZ1bmN0aW9uKEMpIHtcbiAgICAgICAgICBTICs9IGIoQywgdik7XG4gICAgICAgIH0pLCBTO1xuICAgICAgfVxuICAgICAgdmFyIHcgPSB7XG4gICAgICAgIHR5cGU6IGcudHlwZSxcbiAgICAgICAgY29udGVudDogYihnLmNvbnRlbnQsIHYpLFxuICAgICAgICB0YWc6IFwic3BhblwiLFxuICAgICAgICBjbGFzc2VzOiBbXCJ0b2tlblwiLCBnLnR5cGVdLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICAgICAgbGFuZ3VhZ2U6IHZcbiAgICAgIH0sIGsgPSBnLmFsaWFzO1xuICAgICAgayAmJiAoQXJyYXkuaXNBcnJheShrKSA/IEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KHcuY2xhc3NlcywgaykgOiB3LmNsYXNzZXMucHVzaChrKSksIGEuaG9va3MucnVuKFwid3JhcFwiLCB3KTtcbiAgICAgIHZhciBfID0gXCJcIjtcbiAgICAgIGZvciAodmFyIFQgaW4gdy5hdHRyaWJ1dGVzKVxuICAgICAgICBfICs9IFwiIFwiICsgVCArICc9XCInICsgKHcuYXR0cmlidXRlc1tUXSB8fCBcIlwiKS5yZXBsYWNlKC9cIi9nLCBcIiZxdW90O1wiKSArICdcIic7XG4gICAgICByZXR1cm4gXCI8XCIgKyB3LnRhZyArICcgY2xhc3M9XCInICsgdy5jbGFzc2VzLmpvaW4oXCIgXCIpICsgJ1wiJyArIF8gKyBcIj5cIiArIHcuY29udGVudCArIFwiPC9cIiArIHcudGFnICsgXCI+XCI7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBjKGIsIGcsIHYsIFMpIHtcbiAgICAgIGIubGFzdEluZGV4ID0gZztcbiAgICAgIHZhciB3ID0gYi5leGVjKHYpO1xuICAgICAgaWYgKHcgJiYgUyAmJiB3WzFdKSB7XG4gICAgICAgIHZhciBrID0gd1sxXS5sZW5ndGg7XG4gICAgICAgIHcuaW5kZXggKz0gaywgd1swXSA9IHdbMF0uc2xpY2Uoayk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdztcbiAgICB9XG4gICAgZnVuY3Rpb24gdShiLCBnLCB2LCBTLCB3LCBrKSB7XG4gICAgICBmb3IgKHZhciBfIGluIHYpXG4gICAgICAgIGlmICghKCF2Lmhhc093blByb3BlcnR5KF8pIHx8ICF2W19dKSkge1xuICAgICAgICAgIHZhciBUID0gdltfXTtcbiAgICAgICAgICBUID0gQXJyYXkuaXNBcnJheShUKSA/IFQgOiBbVF07XG4gICAgICAgICAgZm9yICh2YXIgQyA9IDA7IEMgPCBULmxlbmd0aDsgKytDKSB7XG4gICAgICAgICAgICBpZiAoayAmJiBrLmNhdXNlID09IF8gKyBcIixcIiArIEMpXG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBBID0gVFtDXSwgUSA9IEEuaW5zaWRlLCBXID0gISFBLmxvb2tiZWhpbmQsIEwgPSAhIUEuZ3JlZWR5LCByZSA9IEEuYWxpYXM7XG4gICAgICAgICAgICBpZiAoTCAmJiAhQS5wYXR0ZXJuLmdsb2JhbCkge1xuICAgICAgICAgICAgICB2YXIgWSA9IEEucGF0dGVybi50b1N0cmluZygpLm1hdGNoKC9baW1zdXldKiQvKVswXTtcbiAgICAgICAgICAgICAgQS5wYXR0ZXJuID0gUmVnRXhwKEEucGF0dGVybi5zb3VyY2UsIFkgKyBcImdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBLID0gQS5wYXR0ZXJuIHx8IEEsIEIgPSBTLm5leHQsIF9lID0gdzsgQiAhPT0gZy50YWlsICYmICEoayAmJiBfZSA+PSBrLnJlYWNoKTsgX2UgKz0gQi52YWx1ZS5sZW5ndGgsIEIgPSBCLm5leHQpIHtcbiAgICAgICAgICAgICAgdmFyIENlID0gQi52YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGcubGVuZ3RoID4gYi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICBpZiAoIShDZSBpbnN0YW5jZW9mIGwpKSB7XG4gICAgICAgICAgICAgICAgdmFyIHVlID0gMSwgZ2U7XG4gICAgICAgICAgICAgICAgaWYgKEwpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChnZSA9IGMoSywgX2UsIGIsIFcpLCAhZ2UgfHwgZ2UuaW5kZXggPj0gYi5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgdmFyIFZ0ID0gZ2UuaW5kZXgsIEJlID0gZ2UuaW5kZXggKyBnZVswXS5sZW5ndGgsIExlID0gX2U7XG4gICAgICAgICAgICAgICAgICBmb3IgKExlICs9IEIudmFsdWUubGVuZ3RoOyBWdCA+PSBMZTsgKVxuICAgICAgICAgICAgICAgICAgICBCID0gQi5uZXh0LCBMZSArPSBCLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIGlmIChMZSAtPSBCLnZhbHVlLmxlbmd0aCwgX2UgPSBMZSwgQi52YWx1ZSBpbnN0YW5jZW9mIGwpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgWnQgPSBCOyBadCAhPT0gZy50YWlsICYmIChMZSA8IEJlIHx8IHR5cGVvZiBadC52YWx1ZSA9PSBcInN0cmluZ1wiKTsgWnQgPSBadC5uZXh0KVxuICAgICAgICAgICAgICAgICAgICB1ZSsrLCBMZSArPSBadC52YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICB1ZS0tLCBDZSA9IGIuc2xpY2UoX2UsIExlKSwgZ2UuaW5kZXggLT0gX2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChnZSA9IGMoSywgMCwgQ2UsIFcpLCAhZ2UpXG4gICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB2YXIgVnQgPSBnZS5pbmRleCwgSXQgPSBnZVswXSwgVG4gPSBDZS5zbGljZSgwLCBWdCksIFNyID0gQ2Uuc2xpY2UoVnQgKyBJdC5sZW5ndGgpLCBvciA9IF9lICsgQ2UubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGsgJiYgb3IgPiBrLnJlYWNoICYmIChrLnJlYWNoID0gb3IpO1xuICAgICAgICAgICAgICAgIHZhciBFbiA9IEIucHJldjtcbiAgICAgICAgICAgICAgICBUbiAmJiAoRW4gPSBmKGcsIEVuLCBUbiksIF9lICs9IFRuLmxlbmd0aCksIGgoZywgRW4sIHVlKTtcbiAgICAgICAgICAgICAgICB2YXIgdmkgPSBuZXcgbChfLCBRID8gYS50b2tlbml6ZShJdCwgUSkgOiBJdCwgcmUsIEl0KTtcbiAgICAgICAgICAgICAgICBpZiAoQiA9IGYoZywgRW4sIHZpKSwgU3IgJiYgZihnLCBCLCBTciksIHVlID4gMSkge1xuICAgICAgICAgICAgICAgICAgdmFyIFVyID0ge1xuICAgICAgICAgICAgICAgICAgICBjYXVzZTogXyArIFwiLFwiICsgQyxcbiAgICAgICAgICAgICAgICAgICAgcmVhY2g6IG9yXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgdShiLCBnLCB2LCBCLnByZXYsIF9lLCBVciksIGsgJiYgVXIucmVhY2ggPiBrLnJlYWNoICYmIChrLnJlYWNoID0gVXIucmVhY2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkKCkge1xuICAgICAgdmFyIGIgPSB7IHZhbHVlOiBudWxsLCBwcmV2OiBudWxsLCBuZXh0OiBudWxsIH0sIGcgPSB7IHZhbHVlOiBudWxsLCBwcmV2OiBiLCBuZXh0OiBudWxsIH07XG4gICAgICBiLm5leHQgPSBnLCB0aGlzLmhlYWQgPSBiLCB0aGlzLnRhaWwgPSBnLCB0aGlzLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGYoYiwgZywgdikge1xuICAgICAgdmFyIFMgPSBnLm5leHQsIHcgPSB7IHZhbHVlOiB2LCBwcmV2OiBnLCBuZXh0OiBTIH07XG4gICAgICByZXR1cm4gZy5uZXh0ID0gdywgUy5wcmV2ID0gdywgYi5sZW5ndGgrKywgdztcbiAgICB9XG4gICAgZnVuY3Rpb24gaChiLCBnLCB2KSB7XG4gICAgICBmb3IgKHZhciBTID0gZy5uZXh0LCB3ID0gMDsgdyA8IHYgJiYgUyAhPT0gYi50YWlsOyB3KyspXG4gICAgICAgIFMgPSBTLm5leHQ7XG4gICAgICBnLm5leHQgPSBTLCBTLnByZXYgPSBnLCBiLmxlbmd0aCAtPSB3O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwKGIpIHtcbiAgICAgIGZvciAodmFyIGcgPSBbXSwgdiA9IGIuaGVhZC5uZXh0OyB2ICE9PSBiLnRhaWw7IClcbiAgICAgICAgZy5wdXNoKHYudmFsdWUpLCB2ID0gdi5uZXh0O1xuICAgICAgcmV0dXJuIGc7XG4gICAgfVxuICAgIGlmICghci5kb2N1bWVudClcbiAgICAgIHJldHVybiByLmFkZEV2ZW50TGlzdGVuZXIgJiYgKGEuZGlzYWJsZVdvcmtlck1lc3NhZ2VIYW5kbGVyIHx8IHIuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZnVuY3Rpb24oYikge1xuICAgICAgICB2YXIgZyA9IEpTT04ucGFyc2UoYi5kYXRhKSwgdiA9IGcubGFuZ3VhZ2UsIFMgPSBnLmNvZGUsIHcgPSBnLmltbWVkaWF0ZUNsb3NlO1xuICAgICAgICByLnBvc3RNZXNzYWdlKGEuaGlnaGxpZ2h0KFMsIGEubGFuZ3VhZ2VzW3ZdLCB2KSksIHcgJiYgci5jbG9zZSgpO1xuICAgICAgfSwgITEpKSwgYTtcbiAgICB2YXIgTyA9IGEudXRpbC5jdXJyZW50U2NyaXB0KCk7XG4gICAgTyAmJiAoYS5maWxlbmFtZSA9IE8uc3JjLCBPLmhhc0F0dHJpYnV0ZShcImRhdGEtbWFudWFsXCIpICYmIChhLm1hbnVhbCA9ICEwKSk7XG4gICAgZnVuY3Rpb24gbSgpIHtcbiAgICAgIGEubWFudWFsIHx8IGEuaGlnaGxpZ2h0QWxsKCk7XG4gICAgfVxuICAgIGlmICghYS5tYW51YWwpIHtcbiAgICAgIHZhciB5ID0gZG9jdW1lbnQucmVhZHlTdGF0ZTtcbiAgICAgIHkgPT09IFwibG9hZGluZ1wiIHx8IHkgPT09IFwiaW50ZXJhY3RpdmVcIiAmJiBPICYmIE8uZGVmZXIgPyBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCBtKSA6IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKG0pIDogd2luZG93LnNldFRpbWVvdXQobSwgMTYpO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfShlKTtcbiAgdC5leHBvcnRzICYmICh0LmV4cG9ydHMgPSBuKSwgdHlwZW9mIE0wIDwgXCJ1XCIgJiYgKE0wLlByaXNtID0gbiksIG4ubGFuZ3VhZ2VzLm1hcmt1cCA9IHtcbiAgICBjb21tZW50OiB7XG4gICAgICBwYXR0ZXJuOiAvPCEtLSg/Oig/ITwhLS0pW1xcc1xcU10pKj8tLT4vLFxuICAgICAgZ3JlZWR5OiAhMFxuICAgIH0sXG4gICAgcHJvbG9nOiB7XG4gICAgICBwYXR0ZXJuOiAvPFxcP1tcXHNcXFNdKz9cXD8+LyxcbiAgICAgIGdyZWVkeTogITBcbiAgICB9LFxuICAgIGRvY3R5cGU6IHtcbiAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi94bWwvI05ULWRvY3R5cGVkZWNsXG4gICAgICBwYXR0ZXJuOiAvPCFET0NUWVBFKD86W14+XCInW1xcXV18XCJbXlwiXSpcInwnW14nXSonKSsoPzpcXFsoPzpbXjxcIidcXF1dfFwiW15cIl0qXCJ8J1teJ10qJ3w8KD8hIS0tKXw8IS0tKD86W14tXXwtKD8hLT4pKSotLT4pKlxcXVxccyopPz4vaSxcbiAgICAgIGdyZWVkeTogITAsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgXCJpbnRlcm5hbC1zdWJzZXRcIjoge1xuICAgICAgICAgIHBhdHRlcm46IC8oXlteXFxbXSpcXFspW1xcc1xcU10rKD89XFxdPiQpLyxcbiAgICAgICAgICBsb29rYmVoaW5kOiAhMCxcbiAgICAgICAgICBncmVlZHk6ICEwLFxuICAgICAgICAgIGluc2lkZTogbnVsbFxuICAgICAgICAgIC8vIHNlZSBiZWxvd1xuICAgICAgICB9LFxuICAgICAgICBzdHJpbmc6IHtcbiAgICAgICAgICBwYXR0ZXJuOiAvXCJbXlwiXSpcInwnW14nXSonLyxcbiAgICAgICAgICBncmVlZHk6ICEwXG4gICAgICAgIH0sXG4gICAgICAgIHB1bmN0dWF0aW9uOiAvXjwhfD4kfFtbXFxdXS8sXG4gICAgICAgIFwiZG9jdHlwZS10YWdcIjogL15ET0NUWVBFL2ksXG4gICAgICAgIG5hbWU6IC9bXlxcczw+J1wiXSsvXG4gICAgICB9XG4gICAgfSxcbiAgICBjZGF0YToge1xuICAgICAgcGF0dGVybjogLzwhXFxbQ0RBVEFcXFtbXFxzXFxTXSo/XFxdXFxdPi9pLFxuICAgICAgZ3JlZWR5OiAhMFxuICAgIH0sXG4gICAgdGFnOiB7XG4gICAgICBwYXR0ZXJuOiAvPFxcLz8oPyFcXGQpW15cXHM+XFwvPSQ8JV0rKD86XFxzKD86XFxzKlteXFxzPlxcLz1dKyg/Olxccyo9XFxzKig/OlwiW15cIl0qXCJ8J1teJ10qJ3xbXlxccydcIj49XSsoPz1bXFxzPl0pKXwoPz1bXFxzLz5dKSkpKyk/XFxzKlxcLz8+LyxcbiAgICAgIGdyZWVkeTogITAsXG4gICAgICBpbnNpZGU6IHtcbiAgICAgICAgdGFnOiB7XG4gICAgICAgICAgcGF0dGVybjogL148XFwvP1teXFxzPlxcL10rLyxcbiAgICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICAgIHB1bmN0dWF0aW9uOiAvXjxcXC8/LyxcbiAgICAgICAgICAgIG5hbWVzcGFjZTogL15bXlxccz5cXC86XSs6L1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJzcGVjaWFsLWF0dHJcIjogW10sXG4gICAgICAgIFwiYXR0ci12YWx1ZVwiOiB7XG4gICAgICAgICAgcGF0dGVybjogLz1cXHMqKD86XCJbXlwiXSpcInwnW14nXSonfFteXFxzJ1wiPj1dKykvLFxuICAgICAgICAgIGluc2lkZToge1xuICAgICAgICAgICAgcHVuY3R1YXRpb246IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHBhdHRlcm46IC9ePS8sXG4gICAgICAgICAgICAgICAgYWxpYXM6IFwiYXR0ci1lcXVhbHNcIlxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcGF0dGVybjogL14oXFxzKilbXCInXXxbXCInXSQvLFxuICAgICAgICAgICAgICAgIGxvb2tiZWhpbmQ6ICEwXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHB1bmN0dWF0aW9uOiAvXFwvPz4vLFxuICAgICAgICBcImF0dHItbmFtZVwiOiB7XG4gICAgICAgICAgcGF0dGVybjogL1teXFxzPlxcL10rLyxcbiAgICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICAgIG5hbWVzcGFjZTogL15bXlxccz5cXC86XSs6L1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZW50aXR5OiBbXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC8mW1xcZGEtel17MSw4fTsvaSxcbiAgICAgICAgYWxpYXM6IFwibmFtZWQtZW50aXR5XCJcbiAgICAgIH0sXG4gICAgICAvJiN4P1tcXGRhLWZdezEsOH07L2lcbiAgICBdXG4gIH0sIG4ubGFuZ3VhZ2VzLm1hcmt1cC50YWcuaW5zaWRlW1wiYXR0ci12YWx1ZVwiXS5pbnNpZGUuZW50aXR5ID0gbi5sYW5ndWFnZXMubWFya3VwLmVudGl0eSwgbi5sYW5ndWFnZXMubWFya3VwLmRvY3R5cGUuaW5zaWRlW1wiaW50ZXJuYWwtc3Vic2V0XCJdLmluc2lkZSA9IG4ubGFuZ3VhZ2VzLm1hcmt1cCwgbi5ob29rcy5hZGQoXCJ3cmFwXCIsIGZ1bmN0aW9uKHIpIHtcbiAgICByLnR5cGUgPT09IFwiZW50aXR5XCIgJiYgKHIuYXR0cmlidXRlcy50aXRsZSA9IHIuY29udGVudC5yZXBsYWNlKC8mYW1wOy8sIFwiJlwiKSk7XG4gIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkobi5sYW5ndWFnZXMubWFya3VwLnRhZywgXCJhZGRJbmxpbmVkXCIsIHtcbiAgICAvKipcbiAgICAgKiBBZGRzIGFuIGlubGluZWQgbGFuZ3VhZ2UgdG8gbWFya3VwLlxuICAgICAqXG4gICAgICogQW4gZXhhbXBsZSBvZiBhbiBpbmxpbmVkIGxhbmd1YWdlIGlzIENTUyB3aXRoIGA8c3R5bGU+YCB0YWdzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZ05hbWUgVGhlIG5hbWUgb2YgdGhlIHRhZyB0aGF0IGNvbnRhaW5zIHRoZSBpbmxpbmVkIGxhbmd1YWdlLiBUaGlzIG5hbWUgd2lsbCBiZSB0cmVhdGVkIGFzXG4gICAgICogY2FzZSBpbnNlbnNpdGl2ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGFuZyBUaGUgbGFuZ3VhZ2Uga2V5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYWRkSW5saW5lZCgnc3R5bGUnLCAnY3NzJyk7XG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uKGksIHMpIHtcbiAgICAgIHZhciBvID0ge307XG4gICAgICBvW1wibGFuZ3VhZ2UtXCIgKyBzXSA9IHtcbiAgICAgICAgcGF0dGVybjogLyhePCFcXFtDREFUQVxcWylbXFxzXFxTXSs/KD89XFxdXFxdPiQpL2ksXG4gICAgICAgIGxvb2tiZWhpbmQ6ICEwLFxuICAgICAgICBpbnNpZGU6IG4ubGFuZ3VhZ2VzW3NdXG4gICAgICB9LCBvLmNkYXRhID0gL148IVxcW0NEQVRBXFxbfFxcXVxcXT4kL2k7XG4gICAgICB2YXIgYSA9IHtcbiAgICAgICAgXCJpbmNsdWRlZC1jZGF0YVwiOiB7XG4gICAgICAgICAgcGF0dGVybjogLzwhXFxbQ0RBVEFcXFtbXFxzXFxTXSo/XFxdXFxdPi9pLFxuICAgICAgICAgIGluc2lkZTogb1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgYVtcImxhbmd1YWdlLVwiICsgc10gPSB7XG4gICAgICAgIHBhdHRlcm46IC9bXFxzXFxTXSsvLFxuICAgICAgICBpbnNpZGU6IG4ubGFuZ3VhZ2VzW3NdXG4gICAgICB9O1xuICAgICAgdmFyIGwgPSB7fTtcbiAgICAgIGxbaV0gPSB7XG4gICAgICAgIHBhdHRlcm46IFJlZ0V4cCgvKDxfX1tePl0qPikoPzo8IVxcW0NEQVRBXFxbKD86W15cXF1dfFxcXSg/IVxcXT4pKSpcXF1cXF0+fCg/ITwhXFxbQ0RBVEFcXFspW1xcc1xcU10pKj8oPz08XFwvX18+KS8uc291cmNlLnJlcGxhY2UoL19fL2csIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9KSwgXCJpXCIpLFxuICAgICAgICBsb29rYmVoaW5kOiAhMCxcbiAgICAgICAgZ3JlZWR5OiAhMCxcbiAgICAgICAgaW5zaWRlOiBhXG4gICAgICB9LCBuLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoXCJtYXJrdXBcIiwgXCJjZGF0YVwiLCBsKTtcbiAgICB9XG4gIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkobi5sYW5ndWFnZXMubWFya3VwLnRhZywgXCJhZGRBdHRyaWJ1dGVcIiwge1xuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gcGF0dGVybiB0byBoaWdobGlnaHQgbGFuZ3VhZ2VzIGVtYmVkZGVkIGluIEhUTUwgYXR0cmlidXRlcy5cbiAgICAgKlxuICAgICAqIEFuIGV4YW1wbGUgb2YgYW4gaW5saW5lZCBsYW5ndWFnZSBpcyBDU1Mgd2l0aCBgc3R5bGVgIGF0dHJpYnV0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0ck5hbWUgVGhlIG5hbWUgb2YgdGhlIHRhZyB0aGF0IGNvbnRhaW5zIHRoZSBpbmxpbmVkIGxhbmd1YWdlLiBUaGlzIG5hbWUgd2lsbCBiZSB0cmVhdGVkIGFzXG4gICAgICogY2FzZSBpbnNlbnNpdGl2ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGFuZyBUaGUgbGFuZ3VhZ2Uga2V5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYWRkQXR0cmlidXRlKCdzdHlsZScsICdjc3MnKTtcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24ociwgaSkge1xuICAgICAgbi5sYW5ndWFnZXMubWFya3VwLnRhZy5pbnNpZGVbXCJzcGVjaWFsLWF0dHJcIl0ucHVzaCh7XG4gICAgICAgIHBhdHRlcm46IFJlZ0V4cChcbiAgICAgICAgICAvKF58W1wiJ1xcc10pLy5zb3VyY2UgKyBcIig/OlwiICsgciArIFwiKVwiICsgL1xccyo9XFxzKig/OlwiW15cIl0qXCJ8J1teJ10qJ3xbXlxccydcIj49XSsoPz1bXFxzPl0pKS8uc291cmNlLFxuICAgICAgICAgIFwiaVwiXG4gICAgICAgICksXG4gICAgICAgIGxvb2tiZWhpbmQ6ICEwLFxuICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICBcImF0dHItbmFtZVwiOiAvXlteXFxzPV0rLyxcbiAgICAgICAgICBcImF0dHItdmFsdWVcIjoge1xuICAgICAgICAgICAgcGF0dGVybjogLz1bXFxzXFxTXSsvLFxuICAgICAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgcGF0dGVybjogLyhePVxccyooW1wiJ118KD8hW1wiJ10pKSlcXFNbXFxzXFxTXSooPz1cXDIkKS8sXG4gICAgICAgICAgICAgICAgbG9va2JlaGluZDogITAsXG4gICAgICAgICAgICAgICAgYWxpYXM6IFtpLCBcImxhbmd1YWdlLVwiICsgaV0sXG4gICAgICAgICAgICAgICAgaW5zaWRlOiBuLmxhbmd1YWdlc1tpXVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBwdW5jdHVhdGlvbjogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHBhdHRlcm46IC9ePS8sXG4gICAgICAgICAgICAgICAgICBhbGlhczogXCJhdHRyLWVxdWFsc1wiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvXCJ8Jy9cbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KSwgbi5sYW5ndWFnZXMuaHRtbCA9IG4ubGFuZ3VhZ2VzLm1hcmt1cCwgbi5sYW5ndWFnZXMubWF0aG1sID0gbi5sYW5ndWFnZXMubWFya3VwLCBuLmxhbmd1YWdlcy5zdmcgPSBuLmxhbmd1YWdlcy5tYXJrdXAsIG4ubGFuZ3VhZ2VzLnhtbCA9IG4ubGFuZ3VhZ2VzLmV4dGVuZChcIm1hcmt1cFwiLCB7fSksIG4ubGFuZ3VhZ2VzLnNzbWwgPSBuLmxhbmd1YWdlcy54bWwsIG4ubGFuZ3VhZ2VzLmF0b20gPSBuLmxhbmd1YWdlcy54bWwsIG4ubGFuZ3VhZ2VzLnJzcyA9IG4ubGFuZ3VhZ2VzLnhtbCwgZnVuY3Rpb24ocikge1xuICAgIHZhciBpID0gLyg/OlwiKD86XFxcXCg/OlxcclxcbnxbXFxzXFxTXSl8W15cIlxcXFxcXHJcXG5dKSpcInwnKD86XFxcXCg/OlxcclxcbnxbXFxzXFxTXSl8W14nXFxcXFxcclxcbl0pKicpLztcbiAgICByLmxhbmd1YWdlcy5jc3MgPSB7XG4gICAgICBjb21tZW50OiAvXFwvXFwqW1xcc1xcU10qP1xcKlxcLy8sXG4gICAgICBhdHJ1bGU6IHtcbiAgICAgICAgcGF0dGVybjogUmVnRXhwKFwiQFtcXFxcdy1dKD86XCIgKyAvW147e1xcc1wiJ118XFxzKyg/IVxccykvLnNvdXJjZSArIFwifFwiICsgaS5zb3VyY2UgKyBcIikqP1wiICsgLyg/Ojt8KD89XFxzKlxceykpLy5zb3VyY2UpLFxuICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICBydWxlOiAvXkBbXFx3LV0rLyxcbiAgICAgICAgICBcInNlbGVjdG9yLWZ1bmN0aW9uLWFyZ3VtZW50XCI6IHtcbiAgICAgICAgICAgIHBhdHRlcm46IC8oXFxic2VsZWN0b3JcXHMqXFwoXFxzKig/IVtcXHMpXSkpKD86W14oKVxcc118XFxzKyg/IVtcXHMpXSl8XFwoKD86W14oKV18XFwoW14oKV0qXFwpKSpcXCkpKyg/PVxccypcXCkpLyxcbiAgICAgICAgICAgIGxvb2tiZWhpbmQ6ICEwLFxuICAgICAgICAgICAgYWxpYXM6IFwic2VsZWN0b3JcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAga2V5d29yZDoge1xuICAgICAgICAgICAgcGF0dGVybjogLyhefFteXFx3LV0pKD86YW5kfG5vdHxvbmx5fG9yKSg/IVtcXHctXSkvLFxuICAgICAgICAgICAgbG9va2JlaGluZDogITBcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gU2VlIHJlc3QgYmVsb3dcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHVybDoge1xuICAgICAgICAvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLXZhbHVlcy0zLyN1cmxzXG4gICAgICAgIHBhdHRlcm46IFJlZ0V4cChcIlxcXFxidXJsXFxcXCgoPzpcIiArIGkuc291cmNlICsgXCJ8XCIgKyAvKD86W15cXFxcXFxyXFxuKClcIiddfFxcXFxbXFxzXFxTXSkqLy5zb3VyY2UgKyBcIilcXFxcKVwiLCBcImlcIiksXG4gICAgICAgIGdyZWVkeTogITAsXG4gICAgICAgIGluc2lkZToge1xuICAgICAgICAgIGZ1bmN0aW9uOiAvXnVybC9pLFxuICAgICAgICAgIHB1bmN0dWF0aW9uOiAvXlxcKHxcXCkkLyxcbiAgICAgICAgICBzdHJpbmc6IHtcbiAgICAgICAgICAgIHBhdHRlcm46IFJlZ0V4cChcIl5cIiArIGkuc291cmNlICsgXCIkXCIpLFxuICAgICAgICAgICAgYWxpYXM6IFwidXJsXCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBzZWxlY3Rvcjoge1xuICAgICAgICBwYXR0ZXJuOiBSZWdFeHAoYChefFt7fVxcXFxzXSlbXnt9XFxcXHNdKD86W157fTtcIidcXFxcc118XFxcXHMrKD8hW1xcXFxze10pfGAgKyBpLnNvdXJjZSArIFwiKSooPz1cXFxccypcXFxceylcIiksXG4gICAgICAgIGxvb2tiZWhpbmQ6ICEwXG4gICAgICB9LFxuICAgICAgc3RyaW5nOiB7XG4gICAgICAgIHBhdHRlcm46IGksXG4gICAgICAgIGdyZWVkeTogITBcbiAgICAgIH0sXG4gICAgICBwcm9wZXJ0eToge1xuICAgICAgICBwYXR0ZXJuOiAvKF58W14tXFx3XFx4QTAtXFx1RkZGRl0pKD8hXFxzKVstX2EtelxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVstXFx3XFx4QTAtXFx1RkZGRl0pKig/PVxccyo6KS9pLFxuICAgICAgICBsb29rYmVoaW5kOiAhMFxuICAgICAgfSxcbiAgICAgIGltcG9ydGFudDogLyFpbXBvcnRhbnRcXGIvaSxcbiAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgIHBhdHRlcm46IC8oXnxbXi1hLXowLTldKVstYS16MC05XSsoPz1cXCgpL2ksXG4gICAgICAgIGxvb2tiZWhpbmQ6ICEwXG4gICAgICB9LFxuICAgICAgcHVuY3R1YXRpb246IC9bKCl7fTs6LF0vXG4gICAgfSwgci5sYW5ndWFnZXMuY3NzLmF0cnVsZS5pbnNpZGUucmVzdCA9IHIubGFuZ3VhZ2VzLmNzcztcbiAgICB2YXIgcyA9IHIubGFuZ3VhZ2VzLm1hcmt1cDtcbiAgICBzICYmIChzLnRhZy5hZGRJbmxpbmVkKFwic3R5bGVcIiwgXCJjc3NcIiksIHMudGFnLmFkZEF0dHJpYnV0ZShcInN0eWxlXCIsIFwiY3NzXCIpKTtcbiAgfShuKSwgbi5sYW5ndWFnZXMuY2xpa2UgPSB7XG4gICAgY29tbWVudDogW1xuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvKF58W15cXFxcXSlcXC9cXCpbXFxzXFxTXSo/KD86XFwqXFwvfCQpLyxcbiAgICAgICAgbG9va2JlaGluZDogITAsXG4gICAgICAgIGdyZWVkeTogITBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC8oXnxbXlxcXFw6XSlcXC9cXC8uKi8sXG4gICAgICAgIGxvb2tiZWhpbmQ6ICEwLFxuICAgICAgICBncmVlZHk6ICEwXG4gICAgICB9XG4gICAgXSxcbiAgICBzdHJpbmc6IHtcbiAgICAgIHBhdHRlcm46IC8oW1wiJ10pKD86XFxcXCg/OlxcclxcbnxbXFxzXFxTXSl8KD8hXFwxKVteXFxcXFxcclxcbl0pKlxcMS8sXG4gICAgICBncmVlZHk6ICEwXG4gICAgfSxcbiAgICBcImNsYXNzLW5hbWVcIjoge1xuICAgICAgcGF0dGVybjogLyhcXGIoPzpjbGFzc3xleHRlbmRzfGltcGxlbWVudHN8aW5zdGFuY2VvZnxpbnRlcmZhY2V8bmV3fHRyYWl0KVxccyt8XFxiY2F0Y2hcXHMrXFwoKVtcXHcuXFxcXF0rL2ksXG4gICAgICBsb29rYmVoaW5kOiAhMCxcbiAgICAgIGluc2lkZToge1xuICAgICAgICBwdW5jdHVhdGlvbjogL1suXFxcXF0vXG4gICAgICB9XG4gICAgfSxcbiAgICBrZXl3b3JkOiAvXFxiKD86YnJlYWt8Y2F0Y2h8Y29udGludWV8ZG98ZWxzZXxmaW5hbGx5fGZvcnxmdW5jdGlvbnxpZnxpbnxpbnN0YW5jZW9mfG5ld3xudWxsfHJldHVybnx0aHJvd3x0cnl8d2hpbGUpXFxiLyxcbiAgICBib29sZWFuOiAvXFxiKD86ZmFsc2V8dHJ1ZSlcXGIvLFxuICAgIGZ1bmN0aW9uOiAvXFxiXFx3Kyg/PVxcKCkvLFxuICAgIG51bWJlcjogL1xcYjB4W1xcZGEtZl0rXFxifCg/OlxcYlxcZCsoPzpcXC5cXGQqKT98XFxCXFwuXFxkKykoPzplWystXT9cXGQrKT8vaSxcbiAgICBvcGVyYXRvcjogL1s8Pl09P3xbIT1dPT89P3wtLT98XFwrXFwrP3wmJj98XFx8XFx8P3xbPyovfl4lXS8sXG4gICAgcHVuY3R1YXRpb246IC9be31bXFxdOygpLC46XS9cbiAgfSwgbi5sYW5ndWFnZXMuamF2YXNjcmlwdCA9IG4ubGFuZ3VhZ2VzLmV4dGVuZChcImNsaWtlXCIsIHtcbiAgICBcImNsYXNzLW5hbWVcIjogW1xuICAgICAgbi5sYW5ndWFnZXMuY2xpa2VbXCJjbGFzcy1uYW1lXCJdLFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvKF58W14kXFx3XFx4QTAtXFx1RkZGRl0pKD8hXFxzKVtfJEEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKig/PVxcLig/OmNvbnN0cnVjdG9yfHByb3RvdHlwZSkpLyxcbiAgICAgICAgbG9va2JlaGluZDogITBcbiAgICAgIH1cbiAgICBdLFxuICAgIGtleXdvcmQ6IFtcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogLygoPzpefFxcfSlcXHMqKWNhdGNoXFxiLyxcbiAgICAgICAgbG9va2JlaGluZDogITBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC8oXnxbXi5dfFxcLlxcLlxcLlxccyopXFxiKD86YXN8YXNzZXJ0KD89XFxzKlxceyl8YXN5bmMoPz1cXHMqKD86ZnVuY3Rpb25cXGJ8XFwofFskXFx3XFx4QTAtXFx1RkZGRl18JCkpfGF3YWl0fGJyZWFrfGNhc2V8Y2xhc3N8Y29uc3R8Y29udGludWV8ZGVidWdnZXJ8ZGVmYXVsdHxkZWxldGV8ZG98ZWxzZXxlbnVtfGV4cG9ydHxleHRlbmRzfGZpbmFsbHkoPz1cXHMqKD86XFx7fCQpKXxmb3J8ZnJvbSg/PVxccyooPzpbJ1wiXXwkKSl8ZnVuY3Rpb258KD86Z2V0fHNldCkoPz1cXHMqKD86WyNcXFskXFx3XFx4QTAtXFx1RkZGRl18JCkpfGlmfGltcGxlbWVudHN8aW1wb3J0fGlufGluc3RhbmNlb2Z8aW50ZXJmYWNlfGxldHxuZXd8bnVsbHxvZnxwYWNrYWdlfHByaXZhdGV8cHJvdGVjdGVkfHB1YmxpY3xyZXR1cm58c3RhdGljfHN1cGVyfHN3aXRjaHx0aGlzfHRocm93fHRyeXx0eXBlb2Z8dW5kZWZpbmVkfHZhcnx2b2lkfHdoaWxlfHdpdGh8eWllbGQpXFxiLyxcbiAgICAgICAgbG9va2JlaGluZDogITBcbiAgICAgIH1cbiAgICBdLFxuICAgIC8vIEFsbG93IGZvciBhbGwgbm9uLUFTQ0lJIGNoYXJhY3RlcnMgKFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMDA4NDQ0KVxuICAgIGZ1bmN0aW9uOiAvIz8oPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqKD89XFxzKig/OlxcLlxccyooPzphcHBseXxiaW5kfGNhbGwpXFxzKik/XFwoKS8sXG4gICAgbnVtYmVyOiB7XG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoXG4gICAgICAgIC8oXnxbXlxcdyRdKS8uc291cmNlICsgXCIoPzpcIiArIC8vIGNvbnN0YW50XG4gICAgICAgICgvTmFOfEluZmluaXR5Ly5zb3VyY2UgKyBcInxcIiArIC8vIGJpbmFyeSBpbnRlZ2VyXG4gICAgICAgIC8wW2JCXVswMV0rKD86X1swMV0rKSpuPy8uc291cmNlICsgXCJ8XCIgKyAvLyBvY3RhbCBpbnRlZ2VyXG4gICAgICAgIC8wW29PXVswLTddKyg/Ol9bMC03XSspKm4/Ly5zb3VyY2UgKyBcInxcIiArIC8vIGhleGFkZWNpbWFsIGludGVnZXJcbiAgICAgICAgLzBbeFhdW1xcZEEtRmEtZl0rKD86X1tcXGRBLUZhLWZdKykqbj8vLnNvdXJjZSArIFwifFwiICsgLy8gZGVjaW1hbCBiaWdpbnRcbiAgICAgICAgL1xcZCsoPzpfXFxkKykqbi8uc291cmNlICsgXCJ8XCIgKyAvLyBkZWNpbWFsIG51bWJlciAoaW50ZWdlciBvciBmbG9hdCkgYnV0IG5vIGJpZ2ludFxuICAgICAgICAvKD86XFxkKyg/Ol9cXGQrKSooPzpcXC4oPzpcXGQrKD86X1xcZCspKik/KT98XFwuXFxkKyg/Ol9cXGQrKSopKD86W0VlXVsrLV0/XFxkKyg/Ol9cXGQrKSopPy8uc291cmNlKSArIFwiKVwiICsgLyg/IVtcXHckXSkvLnNvdXJjZVxuICAgICAgKSxcbiAgICAgIGxvb2tiZWhpbmQ6ICEwXG4gICAgfSxcbiAgICBvcGVyYXRvcjogLy0tfFxcK1xcK3xcXCpcXCo9P3w9PnwmJj0/fFxcfFxcfD0/fFshPV09PXw8PD0/fD4+Pj89P3xbLSsqLyUmfF4hPTw+XT0/fFxcLnszfXxcXD9cXD89P3xcXD9cXC4/fFt+Ol0vXG4gIH0pLCBuLmxhbmd1YWdlcy5qYXZhc2NyaXB0W1wiY2xhc3MtbmFtZVwiXVswXS5wYXR0ZXJuID0gLyhcXGIoPzpjbGFzc3xleHRlbmRzfGltcGxlbWVudHN8aW5zdGFuY2VvZnxpbnRlcmZhY2V8bmV3KVxccyspW1xcdy5cXFxcXSsvLCBuLmxhbmd1YWdlcy5pbnNlcnRCZWZvcmUoXCJqYXZhc2NyaXB0XCIsIFwia2V5d29yZFwiLCB7XG4gICAgcmVnZXg6IHtcbiAgICAgIHBhdHRlcm46IFJlZ0V4cChcbiAgICAgICAgLy8gbG9va2JlaGluZFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVnZXhwL25vLWR1cGUtY2hhcmFjdGVycy1jaGFyYWN0ZXItY2xhc3NcbiAgICAgICAgLygoPzpefFteJFxcd1xceEEwLVxcdUZGRkYuXCInXFxdKVxcc118XFxiKD86cmV0dXJufHlpZWxkKSlcXHMqKS8uc291cmNlICsgLy8gUmVnZXggcGF0dGVybjpcbiAgICAgICAgLy8gVGhlcmUgYXJlIDIgcmVnZXggcGF0dGVybnMgaGVyZS4gVGhlIFJlZ0V4cCBzZXQgbm90YXRpb24gcHJvcG9zYWwgYWRkZWQgc3VwcG9ydCBmb3IgbmVzdGVkIGNoYXJhY3RlclxuICAgICAgICAvLyBjbGFzc2VzIGlmIHRoZSBgdmAgZmxhZyBpcyBwcmVzZW50LiBVbmZvcnR1bmF0ZWx5LCBuZXN0ZWQgQ0NzIGFyZSBib3RoIGNvbnRleHQtZnJlZSBhbmQgaW5jb21wYXRpYmxlXG4gICAgICAgIC8vIHdpdGggdGhlIG9ubHkgc3ludGF4LCBzbyB3ZSBoYXZlIHRvIGRlZmluZSAyIGRpZmZlcmVudCByZWdleCBwYXR0ZXJucy5cbiAgICAgICAgL1xcLy8uc291cmNlICsgXCIoPzpcIiArIC8oPzpcXFsoPzpbXlxcXVxcXFxcXHJcXG5dfFxcXFwuKSpcXF18XFxcXC58W14vXFxcXFxcW1xcclxcbl0pK1xcL1tkZ2lteXVzXXswLDd9Ly5zb3VyY2UgKyBcInxcIiArIC8vIGB2YCBmbGFnIHN5bnRheC4gVGhpcyBzdXBwb3J0cyAzIGxldmVscyBvZiBuZXN0ZWQgY2hhcmFjdGVyIGNsYXNzZXMuXG4gICAgICAgIC8oPzpcXFsoPzpbXltcXF1cXFxcXFxyXFxuXXxcXFxcLnxcXFsoPzpbXltcXF1cXFxcXFxyXFxuXXxcXFxcLnxcXFsoPzpbXltcXF1cXFxcXFxyXFxuXXxcXFxcLikqXFxdKSpcXF0pKlxcXXxcXFxcLnxbXi9cXFxcXFxbXFxyXFxuXSkrXFwvW2RnaW15dXNdezAsN312W2RnaW15dXNdezAsN30vLnNvdXJjZSArIFwiKVwiICsgLy8gbG9va2FoZWFkXG4gICAgICAgIC8oPz0oPzpcXHN8XFwvXFwqKD86W14qXXxcXCooPyFcXC8pKSpcXCpcXC8pKig/OiR8W1xcclxcbiwuOzp9KVxcXV18XFwvXFwvKSkvLnNvdXJjZVxuICAgICAgKSxcbiAgICAgIGxvb2tiZWhpbmQ6ICEwLFxuICAgICAgZ3JlZWR5OiAhMCxcbiAgICAgIGluc2lkZToge1xuICAgICAgICBcInJlZ2V4LXNvdXJjZVwiOiB7XG4gICAgICAgICAgcGF0dGVybjogL14oXFwvKVtcXHNcXFNdKyg/PVxcL1thLXpdKiQpLyxcbiAgICAgICAgICBsb29rYmVoaW5kOiAhMCxcbiAgICAgICAgICBhbGlhczogXCJsYW5ndWFnZS1yZWdleFwiLFxuICAgICAgICAgIGluc2lkZTogbi5sYW5ndWFnZXMucmVnZXhcbiAgICAgICAgfSxcbiAgICAgICAgXCJyZWdleC1kZWxpbWl0ZXJcIjogL15cXC98XFwvJC8sXG4gICAgICAgIFwicmVnZXgtZmxhZ3NcIjogL15bYS16XSskL1xuICAgICAgfVxuICAgIH0sXG4gICAgLy8gVGhpcyBtdXN0IGJlIGRlY2xhcmVkIGJlZm9yZSBrZXl3b3JkIGJlY2F1c2Ugd2UgdXNlIFwiZnVuY3Rpb25cIiBpbnNpZGUgdGhlIGxvb2stZm9yd2FyZFxuICAgIFwiZnVuY3Rpb24tdmFyaWFibGVcIjoge1xuICAgICAgcGF0dGVybjogLyM/KD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKig/PVxccypbPTpdXFxzKig/OmFzeW5jXFxzKik/KD86XFxiZnVuY3Rpb25cXGJ8KD86XFwoKD86W14oKV18XFwoW14oKV0qXFwpKSpcXCl8KD8hXFxzKVtfJGEtekEtWlxceEEwLVxcdUZGRkZdKD86KD8hXFxzKVskXFx3XFx4QTAtXFx1RkZGRl0pKilcXHMqPT4pKS8sXG4gICAgICBhbGlhczogXCJmdW5jdGlvblwiXG4gICAgfSxcbiAgICBwYXJhbWV0ZXI6IFtcbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogLyhmdW5jdGlvbig/OlxccysoPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqKT9cXHMqXFwoXFxzKikoPyFcXHMpKD86W14oKVxcc118XFxzKyg/IVtcXHMpXSl8XFwoW14oKV0qXFwpKSsoPz1cXHMqXFwpKS8sXG4gICAgICAgIGxvb2tiZWhpbmQ6ICEwLFxuICAgICAgICBpbnNpZGU6IG4ubGFuZ3VhZ2VzLmphdmFzY3JpcHRcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC8oXnxbXiRcXHdcXHhBMC1cXHVGRkZGXSkoPyFcXHMpW18kYS16XFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqKD89XFxzKj0+KS9pLFxuICAgICAgICBsb29rYmVoaW5kOiAhMCxcbiAgICAgICAgaW5zaWRlOiBuLmxhbmd1YWdlcy5qYXZhc2NyaXB0XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvKFxcKFxccyopKD8hXFxzKSg/OlteKClcXHNdfFxccysoPyFbXFxzKV0pfFxcKFteKCldKlxcKSkrKD89XFxzKlxcKVxccyo9PikvLFxuICAgICAgICBsb29rYmVoaW5kOiAhMCxcbiAgICAgICAgaW5zaWRlOiBuLmxhbmd1YWdlcy5qYXZhc2NyaXB0XG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvKCg/OlxcYnxcXHN8XikoPyEoPzphc3xhc3luY3xhd2FpdHxicmVha3xjYXNlfGNhdGNofGNsYXNzfGNvbnN0fGNvbnRpbnVlfGRlYnVnZ2VyfGRlZmF1bHR8ZGVsZXRlfGRvfGVsc2V8ZW51bXxleHBvcnR8ZXh0ZW5kc3xmaW5hbGx5fGZvcnxmcm9tfGZ1bmN0aW9ufGdldHxpZnxpbXBsZW1lbnRzfGltcG9ydHxpbnxpbnN0YW5jZW9mfGludGVyZmFjZXxsZXR8bmV3fG51bGx8b2Z8cGFja2FnZXxwcml2YXRlfHByb3RlY3RlZHxwdWJsaWN8cmV0dXJufHNldHxzdGF0aWN8c3VwZXJ8c3dpdGNofHRoaXN8dGhyb3d8dHJ5fHR5cGVvZnx1bmRlZmluZWR8dmFyfHZvaWR8d2hpbGV8d2l0aHx5aWVsZCkoPyFbJFxcd1xceEEwLVxcdUZGRkZdKSkoPzooPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqXFxzKilcXChcXHMqfFxcXVxccypcXChcXHMqKSg/IVxccykoPzpbXigpXFxzXXxcXHMrKD8hW1xccyldKXxcXChbXigpXSpcXCkpKyg/PVxccypcXClcXHMqXFx7KS8sXG4gICAgICAgIGxvb2tiZWhpbmQ6ICEwLFxuICAgICAgICBpbnNpZGU6IG4ubGFuZ3VhZ2VzLmphdmFzY3JpcHRcbiAgICAgIH1cbiAgICBdLFxuICAgIGNvbnN0YW50OiAvXFxiW0EtWl0oPzpbQS1aX118XFxkeD8pKlxcYi9cbiAgfSksIG4ubGFuZ3VhZ2VzLmluc2VydEJlZm9yZShcImphdmFzY3JpcHRcIiwgXCJzdHJpbmdcIiwge1xuICAgIGhhc2hiYW5nOiB7XG4gICAgICBwYXR0ZXJuOiAvXiMhLiovLFxuICAgICAgZ3JlZWR5OiAhMCxcbiAgICAgIGFsaWFzOiBcImNvbW1lbnRcIlxuICAgIH0sXG4gICAgXCJ0ZW1wbGF0ZS1zdHJpbmdcIjoge1xuICAgICAgcGF0dGVybjogL2AoPzpcXFxcW1xcc1xcU118XFwkXFx7KD86W157fV18XFx7KD86W157fV18XFx7W159XSpcXH0pKlxcfSkrXFx9fCg/IVxcJFxceylbXlxcXFxgXSkqYC8sXG4gICAgICBncmVlZHk6ICEwLFxuICAgICAgaW5zaWRlOiB7XG4gICAgICAgIFwidGVtcGxhdGUtcHVuY3R1YXRpb25cIjoge1xuICAgICAgICAgIHBhdHRlcm46IC9eYHxgJC8sXG4gICAgICAgICAgYWxpYXM6IFwic3RyaW5nXCJcbiAgICAgICAgfSxcbiAgICAgICAgaW50ZXJwb2xhdGlvbjoge1xuICAgICAgICAgIHBhdHRlcm46IC8oKD86XnxbXlxcXFxdKSg/OlxcXFx7Mn0pKilcXCRcXHsoPzpbXnt9XXxcXHsoPzpbXnt9XXxcXHtbXn1dKlxcfSkqXFx9KStcXH0vLFxuICAgICAgICAgIGxvb2tiZWhpbmQ6ICEwLFxuICAgICAgICAgIGluc2lkZToge1xuICAgICAgICAgICAgXCJpbnRlcnBvbGF0aW9uLXB1bmN0dWF0aW9uXCI6IHtcbiAgICAgICAgICAgICAgcGF0dGVybjogL15cXCRcXHt8XFx9JC8sXG4gICAgICAgICAgICAgIGFsaWFzOiBcInB1bmN0dWF0aW9uXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXN0OiBuLmxhbmd1YWdlcy5qYXZhc2NyaXB0XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzdHJpbmc6IC9bXFxzXFxTXSsvXG4gICAgICB9XG4gICAgfSxcbiAgICBcInN0cmluZy1wcm9wZXJ0eVwiOiB7XG4gICAgICBwYXR0ZXJuOiAvKCg/Ol58Wyx7XSlbIFxcdF0qKShbXCInXSkoPzpcXFxcKD86XFxyXFxufFtcXHNcXFNdKXwoPyFcXDIpW15cXFxcXFxyXFxuXSkqXFwyKD89XFxzKjopL20sXG4gICAgICBsb29rYmVoaW5kOiAhMCxcbiAgICAgIGdyZWVkeTogITAsXG4gICAgICBhbGlhczogXCJwcm9wZXJ0eVwiXG4gICAgfVxuICB9KSwgbi5sYW5ndWFnZXMuaW5zZXJ0QmVmb3JlKFwiamF2YXNjcmlwdFwiLCBcIm9wZXJhdG9yXCIsIHtcbiAgICBcImxpdGVyYWwtcHJvcGVydHlcIjoge1xuICAgICAgcGF0dGVybjogLygoPzpefFsse10pWyBcXHRdKikoPyFcXHMpW18kYS16QS1aXFx4QTAtXFx1RkZGRl0oPzooPyFcXHMpWyRcXHdcXHhBMC1cXHVGRkZGXSkqKD89XFxzKjopL20sXG4gICAgICBsb29rYmVoaW5kOiAhMCxcbiAgICAgIGFsaWFzOiBcInByb3BlcnR5XCJcbiAgICB9XG4gIH0pLCBuLmxhbmd1YWdlcy5tYXJrdXAgJiYgKG4ubGFuZ3VhZ2VzLm1hcmt1cC50YWcuYWRkSW5saW5lZChcInNjcmlwdFwiLCBcImphdmFzY3JpcHRcIiksIG4ubGFuZ3VhZ2VzLm1hcmt1cC50YWcuYWRkQXR0cmlidXRlKFxuICAgIC9vbig/OmFib3J0fGJsdXJ8Y2hhbmdlfGNsaWNrfGNvbXBvc2l0aW9uKD86ZW5kfHN0YXJ0fHVwZGF0ZSl8ZGJsY2xpY2t8ZXJyb3J8Zm9jdXMoPzppbnxvdXQpP3xrZXkoPzpkb3dufHVwKXxsb2FkfG1vdXNlKD86ZG93bnxlbnRlcnxsZWF2ZXxtb3ZlfG91dHxvdmVyfHVwKXxyZXNldHxyZXNpemV8c2Nyb2xsfHNlbGVjdHxzbG90Y2hhbmdlfHN1Ym1pdHx1bmxvYWR8d2hlZWwpLy5zb3VyY2UsXG4gICAgXCJqYXZhc2NyaXB0XCJcbiAgKSksIG4ubGFuZ3VhZ2VzLmpzID0gbi5sYW5ndWFnZXMuamF2YXNjcmlwdCwgZnVuY3Rpb24oKSB7XG4gICAgaWYgKHR5cGVvZiBuID4gXCJ1XCIgfHwgdHlwZW9mIGRvY3VtZW50ID4gXCJ1XCIpXG4gICAgICByZXR1cm47XG4gICAgRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyB8fCAoRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyA9IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3Rvcik7XG4gICAgdmFyIHIgPSBcIkxvYWRpbmfigKZcIiwgaSA9IGZ1bmN0aW9uKE8sIG0pIHtcbiAgICAgIHJldHVybiBcIuKcliBFcnJvciBcIiArIE8gKyBcIiB3aGlsZSBmZXRjaGluZyBmaWxlOiBcIiArIG07XG4gICAgfSwgcyA9IFwi4pyWIEVycm9yOiBGaWxlIGRvZXMgbm90IGV4aXN0IG9yIGlzIGVtcHR5XCIsIG8gPSB7XG4gICAgICBqczogXCJqYXZhc2NyaXB0XCIsXG4gICAgICBweTogXCJweXRob25cIixcbiAgICAgIHJiOiBcInJ1YnlcIixcbiAgICAgIHBzMTogXCJwb3dlcnNoZWxsXCIsXG4gICAgICBwc20xOiBcInBvd2Vyc2hlbGxcIixcbiAgICAgIHNoOiBcImJhc2hcIixcbiAgICAgIGJhdDogXCJiYXRjaFwiLFxuICAgICAgaDogXCJjXCIsXG4gICAgICB0ZXg6IFwibGF0ZXhcIlxuICAgIH0sIGEgPSBcImRhdGEtc3JjLXN0YXR1c1wiLCBsID0gXCJsb2FkaW5nXCIsIGMgPSBcImxvYWRlZFwiLCB1ID0gXCJmYWlsZWRcIiwgZCA9IFwicHJlW2RhdGEtc3JjXTpub3QoW1wiICsgYSArICc9XCInICsgYyArICdcIl0pOm5vdChbJyArIGEgKyAnPVwiJyArIGwgKyAnXCJdKSc7XG4gICAgZnVuY3Rpb24gZihPLCBtLCB5KSB7XG4gICAgICB2YXIgYiA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgYi5vcGVuKFwiR0VUXCIsIE8sICEwKSwgYi5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgYi5yZWFkeVN0YXRlID09IDQgJiYgKGIuc3RhdHVzIDwgNDAwICYmIGIucmVzcG9uc2VUZXh0ID8gbShiLnJlc3BvbnNlVGV4dCkgOiBiLnN0YXR1cyA+PSA0MDAgPyB5KGkoYi5zdGF0dXMsIGIuc3RhdHVzVGV4dCkpIDogeShzKSk7XG4gICAgICB9LCBiLnNlbmQobnVsbCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGgoTykge1xuICAgICAgdmFyIG0gPSAvXlxccyooXFxkKylcXHMqKD86KCwpXFxzKig/OihcXGQrKVxccyopPyk/JC8uZXhlYyhPIHx8IFwiXCIpO1xuICAgICAgaWYgKG0pIHtcbiAgICAgICAgdmFyIHkgPSBOdW1iZXIobVsxXSksIGIgPSBtWzJdLCBnID0gbVszXTtcbiAgICAgICAgcmV0dXJuIGIgPyBnID8gW3ksIE51bWJlcihnKV0gOiBbeSwgdm9pZCAwXSA6IFt5LCB5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgbi5ob29rcy5hZGQoXCJiZWZvcmUtaGlnaGxpZ2h0YWxsXCIsIGZ1bmN0aW9uKE8pIHtcbiAgICAgIE8uc2VsZWN0b3IgKz0gXCIsIFwiICsgZDtcbiAgICB9KSwgbi5ob29rcy5hZGQoXCJiZWZvcmUtc2FuaXR5LWNoZWNrXCIsIGZ1bmN0aW9uKE8pIHtcbiAgICAgIHZhciBtID0gKFxuICAgICAgICAvKiogQHR5cGUge0hUTUxQcmVFbGVtZW50fSAqL1xuICAgICAgICBPLmVsZW1lbnRcbiAgICAgICk7XG4gICAgICBpZiAobS5tYXRjaGVzKGQpKSB7XG4gICAgICAgIE8uY29kZSA9IFwiXCIsIG0uc2V0QXR0cmlidXRlKGEsIGwpO1xuICAgICAgICB2YXIgeSA9IG0uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIkNPREVcIikpO1xuICAgICAgICB5LnRleHRDb250ZW50ID0gcjtcbiAgICAgICAgdmFyIGIgPSBtLmdldEF0dHJpYnV0ZShcImRhdGEtc3JjXCIpLCBnID0gTy5sYW5ndWFnZTtcbiAgICAgICAgaWYgKGcgPT09IFwibm9uZVwiKSB7XG4gICAgICAgICAgdmFyIHYgPSAoL1xcLihcXHcrKSQvLmV4ZWMoYikgfHwgWywgXCJub25lXCJdKVsxXTtcbiAgICAgICAgICBnID0gb1t2XSB8fCB2O1xuICAgICAgICB9XG4gICAgICAgIG4udXRpbC5zZXRMYW5ndWFnZSh5LCBnKSwgbi51dGlsLnNldExhbmd1YWdlKG0sIGcpO1xuICAgICAgICB2YXIgUyA9IG4ucGx1Z2lucy5hdXRvbG9hZGVyO1xuICAgICAgICBTICYmIFMubG9hZExhbmd1YWdlcyhnKSwgZihcbiAgICAgICAgICBiLFxuICAgICAgICAgIGZ1bmN0aW9uKHcpIHtcbiAgICAgICAgICAgIG0uc2V0QXR0cmlidXRlKGEsIGMpO1xuICAgICAgICAgICAgdmFyIGsgPSBoKG0uZ2V0QXR0cmlidXRlKFwiZGF0YS1yYW5nZVwiKSk7XG4gICAgICAgICAgICBpZiAoaykge1xuICAgICAgICAgICAgICB2YXIgXyA9IHcuc3BsaXQoL1xcclxcbj98XFxuL2cpLCBUID0ga1swXSwgQyA9IGtbMV0gPT0gbnVsbCA/IF8ubGVuZ3RoIDoga1sxXTtcbiAgICAgICAgICAgICAgVCA8IDAgJiYgKFQgKz0gXy5sZW5ndGgpLCBUID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oVCAtIDEsIF8ubGVuZ3RoKSksIEMgPCAwICYmIChDICs9IF8ubGVuZ3RoKSwgQyA9IE1hdGgubWF4KDAsIE1hdGgubWluKEMsIF8ubGVuZ3RoKSksIHcgPSBfLnNsaWNlKFQsIEMpLmpvaW4oYFxuYCksIG0uaGFzQXR0cmlidXRlKFwiZGF0YS1zdGFydFwiKSB8fCBtLnNldEF0dHJpYnV0ZShcImRhdGEtc3RhcnRcIiwgU3RyaW5nKFQgKyAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5LnRleHRDb250ZW50ID0gdywgbi5oaWdobGlnaHRFbGVtZW50KHkpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24odykge1xuICAgICAgICAgICAgbS5zZXRBdHRyaWJ1dGUoYSwgdSksIHkudGV4dENvbnRlbnQgPSB3O1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9KSwgbi5wbHVnaW5zLmZpbGVIaWdobGlnaHQgPSB7XG4gICAgICAvKipcbiAgICAgICAqIEV4ZWN1dGVzIHRoZSBGaWxlIEhpZ2hsaWdodCBwbHVnaW4gZm9yIGFsbCBtYXRjaGluZyBgcHJlYCBlbGVtZW50cyB1bmRlciB0aGUgZ2l2ZW4gY29udGFpbmVyLlxuICAgICAgICpcbiAgICAgICAqIE5vdGU6IEVsZW1lbnRzIHdoaWNoIGFyZSBhbHJlYWR5IGxvYWRlZCBvciBjdXJyZW50bHkgbG9hZGluZyB3aWxsIG5vdCBiZSB0b3VjaGVkIGJ5IHRoaXMgbWV0aG9kLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7UGFyZW50Tm9kZX0gW2NvbnRhaW5lcj1kb2N1bWVudF1cbiAgICAgICAqL1xuICAgICAgaGlnaGxpZ2h0OiBmdW5jdGlvbihtKSB7XG4gICAgICAgIGZvciAodmFyIHkgPSAobSB8fCBkb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbChkKSwgYiA9IDAsIGc7IGcgPSB5W2IrK107IClcbiAgICAgICAgICBuLmhpZ2hsaWdodEVsZW1lbnQoZyk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcCA9ICExO1xuICAgIG4uZmlsZUhpZ2hsaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcCB8fCAoY29uc29sZS53YXJuKFwiUHJpc20uZmlsZUhpZ2hsaWdodCBpcyBkZXByZWNhdGVkLiBVc2UgYFByaXNtLnBsdWdpbnMuZmlsZUhpZ2hsaWdodC5oaWdobGlnaHRgIGluc3RlYWQuXCIpLCBwID0gITApLCBuLnBsdWdpbnMuZmlsZUhpZ2hsaWdodC5oaWdobGlnaHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9KCk7XG59KShDUCk7XG52YXIgcU0gPSBDUC5leHBvcnRzO1xuY29uc3QgRWEgPSAvKiBAX19QVVJFX18gKi8gVU0ocU0pLCBXcCA9IFwic2NhbGFyLWNvbXBvbmVudFwiLCBZTSA9IExNKHtcbiAgZXh0ZW5kOiB7XG4gICAgY2xhc3NHcm91cHM6IHtcbiAgICAgIFwiZm9udC1zaXplXCI6IFtcInRleHQteHhzXCJdLFxuICAgICAgLy8gQWRkIHRoZSBzY2FsYXIgY2xhc3MgcHJlZml4IGFzIGEgY3VzdG9tIGNsYXNzIHRvIGJlIGRlZHVwZWQgYnkgdGFpbHdpbmQtbWVyZ2VcbiAgICAgIFtXcF06IFtXcF1cbiAgICB9XG4gIH1cbn0pLCB7IGN2YTogJGcsIGN4OiBHZCwgY29tcG9zZTogVmogfSA9IGRNKHtcbiAgaG9va3M6IHtcbiAgICBvbkNvbXBsZXRlOiAodCkgPT4gYCR7WU0odCwgV3ApfWBcbiAgfVxufSksIHpNID0gLyogQF9fUFVSRV9fICovIFdsKCc8cGF0aCBjbGFzcz1cInN2Zy1wYXRoIHN2Zy1jaGVjay1tYXJrXCIgZD1cIm0gMCA2MCBsIDMwIDMwIGwgNzAgLTgwXCIgZGF0YS12LTQ3ZmFjZWRhPjwvcGF0aD48cGF0aCBjbGFzcz1cInN2Zy1wYXRoIHN2Zy14LW1hcmtcIiBkPVwibSA1MCA1MCBsIDQwIC00MFwiIGRhdGEtdi00N2ZhY2VkYT48L3BhdGg+PHBhdGggY2xhc3M9XCJzdmctcGF0aCBzdmcteC1tYXJrXCIgZD1cIm0gNTAgNTAgbCA0MCA0MFwiIGRhdGEtdi00N2ZhY2VkYT48L3BhdGg+PHBhdGggY2xhc3M9XCJzdmctcGF0aCBzdmcteC1tYXJrXCIgZD1cIm0gNTAgNTAgbCAtNDAgLTQwXCIgZGF0YS12LTQ3ZmFjZWRhPjwvcGF0aD48cGF0aCBjbGFzcz1cInN2Zy1wYXRoIHN2Zy14LW1hcmtcIiBkPVwibSA1MCA1MCBsIC00MCA0MFwiIGRhdGEtdi00N2ZhY2VkYT48L3BhdGg+JywgNSksIEhNID0ge1xuICBrZXk6IDAsXG4gIGNsYXNzOiBcImNpcmN1bGFyLWxvYWRlclwiXG59LCBGTSA9IC8qIEBfX1BVUkVfXyAqLyBsZSh7XG4gIF9fbmFtZTogXCJTY2FsYXJMb2FkaW5nXCIsXG4gIHByb3BzOiB7XG4gICAgbG9hZGluZ1N0YXRlOiB7fSxcbiAgICBzaXplOiB7IGRlZmF1bHQ6IFwiMjRweFwiIH1cbiAgfSxcbiAgc2V0dXAodCkge1xuICAgIHJldHVybiBHMSgoZSkgPT4gKHtcbiAgICAgIGQ2Y2FlNzU4OiBlLnNpemVcbiAgICB9KSksIChlLCBuKSA9PiBlLmxvYWRpbmdTdGF0ZSA/IChaKCksIG5lKFwiZGl2XCIsIHtcbiAgICAgIGtleTogMCxcbiAgICAgIGNsYXNzOiBLZShSKEdkKShcImxvYWRlci13cmFwcGVyXCIpKVxuICAgIH0sIFtcbiAgICAgIChaKCksIG5lKFwic3ZnXCIsIHtcbiAgICAgICAgY2xhc3M6IEtlKFtcInN2Zy1sb2FkZXJcIiwge1xuICAgICAgICAgIFwiaWNvbi1pcy12YWxpZFwiOiBlLmxvYWRpbmdTdGF0ZS5pc1ZhbGlkLFxuICAgICAgICAgIFwiaWNvbi1pcy1pbnZhbGlkXCI6IGUubG9hZGluZ1N0YXRlLmlzSW52YWxpZFxuICAgICAgICB9XSksXG4gICAgICAgIHZpZXdCb3g6IFwiMCAwIDEwMCAxMDBcIixcbiAgICAgICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICAgICAgXCJ4bWxuczp4bGlua1wiOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIlxuICAgICAgfSwgW1xuICAgICAgICB6TSxcbiAgICAgICAgZS5sb2FkaW5nU3RhdGUuaXNMb2FkaW5nID8gKFooKSwgbmUoXCJnXCIsIEhNLCBbXG4gICAgICAgICAgRChcImNpcmNsZVwiLCB7XG4gICAgICAgICAgICBjbGFzczogS2UoW1wibG9hZGVyLXBhdGhcIiwge1xuICAgICAgICAgICAgICBcImxvYWRlci1wYXRoLW9mZlwiOiBlLmxvYWRpbmdTdGF0ZS5pc1ZhbGlkIHx8IGUubG9hZGluZ1N0YXRlLmlzSW52YWxpZFxuICAgICAgICAgICAgfV0pLFxuICAgICAgICAgICAgY3g6IFwiNTBcIixcbiAgICAgICAgICAgIGN5OiBcIjUwXCIsXG4gICAgICAgICAgICBmaWxsOiBcIm5vbmVcIixcbiAgICAgICAgICAgIHI6IFwiMjBcIixcbiAgICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IFwiMlwiXG4gICAgICAgICAgfSwgbnVsbCwgMilcbiAgICAgICAgXSkpIDogc3QoXCJcIiwgITApXG4gICAgICBdLCAyKSlcbiAgICBdLCAyKSkgOiBzdChcIlwiLCAhMCk7XG4gIH1cbn0pLCBHTSA9ICh0LCBlKSA9PiB7XG4gIGNvbnN0IG4gPSB0Ll9fdmNjT3B0cyB8fCB0O1xuICBmb3IgKGNvbnN0IFtyLCBpXSBvZiBlKVxuICAgIG5bcl0gPSBpO1xuICByZXR1cm4gbjtcbn0sIEtNID0gLyogQF9fUFVSRV9fICovIEdNKEZNLCBbW1wiX19zY29wZUlkXCIsIFwiZGF0YS12LTQ3ZmFjZWRhXCJdXSksIEFQID0ge1xuICBzb2xpZDogW1xuICAgIFwic2NhbGFyLWJ1dHRvbi1zb2xpZFwiLFxuICAgIFwiYmctYmFjay1idG4tMSB0ZXh0LWZvcmUtYnRuLTEgc2hhZG93LXNtIGFjdGl2ZTpiZy1iYWNrLWJ0bi0xIGFjdGl2ZTpzaGFkb3ctbm9uZSBob2N1czpiZy1ob3Zlci1idG4tMVwiXG4gIF0sXG4gIG91dGxpbmVkOiBbXG4gICAgXCJzY2FsYXItYnV0dG9uLW91dGxpbmVkXCIsXG4gICAgXCJhY3RpdmU6YmctYnRuLTEgYm9yZGVyIGJvcmRlci1zb2xpZCBib3JkZXItYm9yZGVyIGJnLXRyYW5zcGFyZW50IHRleHQtZm9yZS0xIGhvY3VzOmJnLWJvcmRlclwiXG4gIF0sXG4gIGdob3N0OiBbXG4gICAgXCJzY2FsYXItYnV0dG9uLWdob3N0XCIsXG4gICAgXCJiZy10cmFuc3BhcmVudCB0ZXh0LWZvcmUtMyBhY3RpdmU6dGV4dC1mb3JlLTIgaG9jdXM6dGV4dC1mb3JlLTJcIlxuICBdLFxuICBkYW5nZXI6IFtcbiAgICBcInNjYWxhci1idXR0b24tZGFuZ2VyXCIsXG4gICAgXCJiZy1lcnJvciB0ZXh0LXdoaXRlIGFjdGl2ZTpicmlnaHRuZXNzLTkwIGhvY3VzOmJyaWdodG5lc3MtOTBcIlxuICBdXG59LCBKTSA9ICRnKHtcbiAgYmFzZTogXCJzY2FsYXItYnV0dG9uIHJvdyBjdXJzb3ItcG9pbnRlciBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgcm91bmRlZCBmb250LW1lZGl1bVwiLFxuICB2YXJpYW50czoge1xuICAgIGRpc2FibGVkOiB7XG4gICAgICB0cnVlOiBcImJnLWJhY2tncm91bmQtMiB0ZXh0LWNvbG9yLTMgY3Vyc29yLW5vdC1hbGxvd2VkIHNoYWRvdy1ub25lXCJcbiAgICB9LFxuICAgIGZ1bGxXaWR0aDogeyB0cnVlOiBcInctZnVsbFwiIH0sXG4gICAgc2l6ZTogeyBzbTogXCJweC0yIHB5LTEgdGV4dC14c1wiLCBtZDogXCJoLTEwIHB4LTYgdGV4dC1zbVwiIH0sXG4gICAgdmFyaWFudDogQVBcbiAgfSxcbiAgY29tcG91bmRWYXJpYW50czogW1xuICAgIHtcbiAgICAgIGRpc2FibGVkOiAhMCxcbiAgICAgIHZhcmlhbnQ6IFwiZ2hvc3RcIixcbiAgICAgIGNsYXNzOiBcImJnLXRyYW5zcGFyZW50IHRleHQtZ2hvc3RcIlxuICAgIH1cbiAgXVxufSksIGVYID0gW1wiYXJpYURpc2FibGVkXCJdLCB0WCA9IHtcbiAga2V5OiAwLFxuICBjbGFzczogXCJtci0yIGgtNCB3LTRcIlxufSwgblggPSB7XG4gIGtleTogMSxcbiAgY2xhc3M6IFwibWwtMlwiXG59LCByWCA9IC8qIEBfX1BVUkVfXyAqLyBsZSh7XG4gIGluaGVyaXRBdHRyczogITEsXG4gIF9fbmFtZTogXCJTY2FsYXJCdXR0b25cIixcbiAgcHJvcHM6IHtcbiAgICBkaXNhYmxlZDogeyB0eXBlOiBCb29sZWFuIH0sXG4gICAgZnVsbFdpZHRoOiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6ICExIH0sXG4gICAgbG9hZGluZzoge30sXG4gICAgc2l6ZTogeyBkZWZhdWx0OiBcIm1kXCIgfSxcbiAgICB2YXJpYW50OiB7IGRlZmF1bHQ6IFwic29saWRcIiB9XG4gIH0sXG4gIHNldHVwKHQpIHtcbiAgICBjb25zdCBlID0gaigoKSA9PiB7XG4gICAgICBjb25zdCB7IGNsYXNzOiBuLCAuLi5yIH0gPSB4TygpO1xuICAgICAgcmV0dXJuIHsgY2xhc3M6IG4gfHwgXCJcIiwgcmVzdDogciB9O1xuICAgIH0pO1xuICAgIHJldHVybiAobiwgcikgPT4gKFooKSwgbmUoXCJidXR0b25cIiwgTWwoZS52YWx1ZS5yZXN0LCB7XG4gICAgICBhcmlhRGlzYWJsZWQ6IG4uZGlzYWJsZWQgfHwgdm9pZCAwLFxuICAgICAgY2xhc3M6IFIoR2QpKFxuICAgICAgICBSKEpNKSh7IGZ1bGxXaWR0aDogbi5mdWxsV2lkdGgsIGRpc2FibGVkOiBuLmRpc2FibGVkLCBzaXplOiBuLnNpemUsIHZhcmlhbnQ6IG4udmFyaWFudCB9KSxcbiAgICAgICAgeyBcInBsLTkgcHItM1wiOiBuLmxvYWRpbmcgfSxcbiAgICAgICAgYCR7ZS52YWx1ZS5jbGFzc31gXG4gICAgICApLFxuICAgICAgdHlwZTogXCJidXR0b25cIlxuICAgIH0pLCBbXG4gICAgICBuLiRzbG90cy5pY29uID8gKFooKSwgbmUoXCJkaXZcIiwgdFgsIFtcbiAgICAgICAgcHQobi4kc2xvdHMsIFwiaWNvblwiKVxuICAgICAgXSkpIDogc3QoXCJcIiwgITApLFxuICAgICAgcHQobi4kc2xvdHMsIFwiZGVmYXVsdFwiKSxcbiAgICAgIG4ubG9hZGluZyA/IChaKCksIG5lKFwiZGl2XCIsIG5YLCBbXG4gICAgICAgIEooUihLTSksIHtcbiAgICAgICAgICBsb2FkaW5nU3RhdGU6IG4ubG9hZGluZyxcbiAgICAgICAgICBzaXplOiBcIjIwcHhcIlxuICAgICAgICB9LCBudWxsLCA4LCBbXCJsb2FkaW5nU3RhdGVcIl0pXG4gICAgICBdKSkgOiBzdChcIlwiLCAhMClcbiAgICBdLCAxNiwgZVgpKTtcbiAgfVxufSk7XG4oZnVuY3Rpb24odCkge1xuICB2YXIgZSA9IFwiXFxcXGIoPzpCQVNIfEJBU0hPUFRTfEJBU0hfQUxJQVNFU3xCQVNIX0FSR0N8QkFTSF9BUkdWfEJBU0hfQ01EU3xCQVNIX0NPTVBMRVRJT05fQ09NUEFUX0RJUnxCQVNIX0xJTkVOT3xCQVNIX1JFTUFUQ0h8QkFTSF9TT1VSQ0V8QkFTSF9WRVJTSU5GT3xCQVNIX1ZFUlNJT058Q09MT1JURVJNfENPTFVNTlN8Q09NUF9XT1JEQlJFQUtTfERCVVNfU0VTU0lPTl9CVVNfQUREUkVTU3xERUZBVUxUU19QQVRIfERFU0tUT1BfU0VTU0lPTnxESVJTVEFDS3xESVNQTEFZfEVVSUR8R0RNU0VTU0lPTnxHRE1fTEFOR3xHTk9NRV9LRVlSSU5HX0NPTlRST0x8R05PTUVfS0VZUklOR19QSUR8R1BHX0FHRU5UX0lORk98R1JPVVBTfEhJU1RDT05UUk9MfEhJU1RGSUxFfEhJU1RGSUxFU0laRXxISVNUU0laRXxIT01FfEhPU1ROQU1FfEhPU1RUWVBFfElGU3xJTlNUQU5DRXxKT0J8TEFOR3xMQU5HVUFHRXxMQ19BRERSRVNTfExDX0FMTHxMQ19JREVOVElGSUNBVElPTnxMQ19NRUFTVVJFTUVOVHxMQ19NT05FVEFSWXxMQ19OQU1FfExDX05VTUVSSUN8TENfUEFQRVJ8TENfVEVMRVBIT05FfExDX1RJTUV8TEVTU0NMT1NFfExFU1NPUEVOfExJTkVTfExPR05BTUV8TFNfQ09MT1JTfE1BQ0hUWVBFfE1BSUxDSEVDS3xNQU5EQVRPUllfUEFUSHxOT19BVF9CUklER0V8T0xEUFdEfE9QVEVSUnxPUFRJTkR8T1JCSVRfU09DS0VURElSfE9TVFlQRXxQQVBFUlNJWkV8UEFUSHxQSVBFU1RBVFVTfFBQSUR8UFMxfFBTMnxQUzN8UFM0fFBXRHxSQU5ET018UkVQTFl8U0VDT05EU3xTRUxJTlVYX0lOSVR8U0VTU0lPTnxTRVNTSU9OVFlQRXxTRVNTSU9OX01BTkFHRVJ8U0hFTEx8U0hFTExPUFRTfFNITFZMfFNTSF9BVVRIX1NPQ0t8VEVSTXxVSUR8VVBTVEFSVF9FVkVOVFN8VVBTVEFSVF9JTlNUQU5DRXxVUFNUQVJUX0pPQnxVUFNUQVJUX1NFU1NJT058VVNFUnxXSU5ET1dJRHxYQVVUSE9SSVRZfFhER19DT05GSUdfRElSU3xYREdfQ1VSUkVOVF9ERVNLVE9QfFhER19EQVRBX0RJUlN8WERHX0dSRUVURVJfREFUQV9ESVJ8WERHX01FTlVfUFJFRklYfFhER19SVU5USU1FX0RJUnxYREdfU0VBVHxYREdfU0VBVF9QQVRIfFhER19TRVNTSU9OX0RFU0tUT1B8WERHX1NFU1NJT05fSUR8WERHX1NFU1NJT05fUEFUSHxYREdfU0VTU0lPTl9UWVBFfFhER19WVE5SfFhNT0RJRklFUlMpXFxcXGJcIiwgbiA9IHtcbiAgICBwYXR0ZXJuOiAvKF4oW1wiJ10/KVxcdytcXDIpWyBcXHRdK1xcUy4qLyxcbiAgICBsb29rYmVoaW5kOiAhMCxcbiAgICBhbGlhczogXCJwdW5jdHVhdGlvblwiLFxuICAgIC8vIHRoaXMgbG9va3MgcmVhc29uYWJseSB3ZWxsIGluIGFsbCB0aGVtZXNcbiAgICBpbnNpZGU6IG51bGxcbiAgICAvLyBzZWUgYmVsb3dcbiAgfSwgciA9IHtcbiAgICBiYXNoOiBuLFxuICAgIGVudmlyb25tZW50OiB7XG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoXCJcXFxcJFwiICsgZSksXG4gICAgICBhbGlhczogXCJjb25zdGFudFwiXG4gICAgfSxcbiAgICB2YXJpYWJsZTogW1xuICAgICAgLy8gWzBdOiBBcml0aG1ldGljIEVudmlyb25tZW50XG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC9cXCQ/XFwoXFwoW1xcc1xcU10rP1xcKVxcKS8sXG4gICAgICAgIGdyZWVkeTogITAsXG4gICAgICAgIGluc2lkZToge1xuICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgJCBzaWduIGF0IHRoZSBiZWdpbm5pbmcgaGlnaGxpZ2h0ICQoKCBhbmQgKSkgYXMgdmFyaWFibGVcbiAgICAgICAgICB2YXJpYWJsZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBwYXR0ZXJuOiAvKF5cXCRcXChcXChbXFxzXFxTXSspXFwpXFwpLyxcbiAgICAgICAgICAgICAgbG9va2JlaGluZDogITBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvXlxcJFxcKFxcKC9cbiAgICAgICAgICBdLFxuICAgICAgICAgIG51bWJlcjogL1xcYjB4W1xcZEEtRmEtZl0rXFxifCg/OlxcYlxcZCsoPzpcXC5cXGQqKT98XFxCXFwuXFxkKykoPzpbRWVdLT9cXGQrKT8vLFxuICAgICAgICAgIC8vIE9wZXJhdG9ycyBhY2NvcmRpbmcgdG8gaHR0cHM6Ly93d3cuZ251Lm9yZy9zb2Z0d2FyZS9iYXNoL21hbnVhbC9iYXNocmVmLmh0bWwjU2hlbGwtQXJpdGhtZXRpY1xuICAgICAgICAgIG9wZXJhdG9yOiAvLS18XFwrXFwrfFxcKlxcKj0/fDw8PT98Pj49P3wmJnxcXHxcXHx8Wz0hK1xcLSovJTw+XiZ8XT0/fFs/fjpdLyxcbiAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyAkIHNpZ24gYXQgdGhlIGJlZ2lubmluZyBoaWdobGlnaHQgKCggYW5kICkpIGFzIHB1bmN0dWF0aW9uXG4gICAgICAgICAgcHVuY3R1YXRpb246IC9cXChcXCg/fFxcKVxcKT98LHw7L1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gWzFdOiBDb21tYW5kIFN1YnN0aXR1dGlvblxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvXFwkXFwoKD86XFwoW14pXStcXCl8W14oKV0pK1xcKXxgW15gXStgLyxcbiAgICAgICAgZ3JlZWR5OiAhMCxcbiAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgdmFyaWFibGU6IC9eXFwkXFwofF5gfFxcKSR8YCQvXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBbMl06IEJyYWNlIGV4cGFuc2lvblxuICAgICAge1xuICAgICAgICBwYXR0ZXJuOiAvXFwkXFx7W159XStcXH0vLFxuICAgICAgICBncmVlZHk6ICEwLFxuICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICBvcGVyYXRvcjogLzpbLT0/K10/fFshXFwvXXwjIz98JSU/fFxcXlxcXj98LCw/LyxcbiAgICAgICAgICBwdW5jdHVhdGlvbjogL1tcXFtcXF1dLyxcbiAgICAgICAgICBlbnZpcm9ubWVudDoge1xuICAgICAgICAgICAgcGF0dGVybjogUmVnRXhwKFwiKFxcXFx7KVwiICsgZSksXG4gICAgICAgICAgICBsb29rYmVoaW5kOiAhMCxcbiAgICAgICAgICAgIGFsaWFzOiBcImNvbnN0YW50XCJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvXFwkKD86XFx3K3xbIz8qIUAkXSkvXG4gICAgXSxcbiAgICAvLyBFc2NhcGUgc2VxdWVuY2VzIGZyb20gZWNobyBhbmQgcHJpbnRmJ3MgbWFudWFscywgYW5kIGVzY2FwZWQgcXVvdGVzLlxuICAgIGVudGl0eTogL1xcXFwoPzpbYWJjZUVmbnJ0dlxcXFxcIl18Tz9bMC03XXsxLDN9fFVbMC05YS1mQS1GXXs4fXx1WzAtOWEtZkEtRl17NH18eFswLTlhLWZBLUZdezEsMn0pL1xuICB9O1xuICB0Lmxhbmd1YWdlcy5iYXNoID0ge1xuICAgIHNoZWJhbmc6IHtcbiAgICAgIHBhdHRlcm46IC9eIyFcXHMqXFwvLiovLFxuICAgICAgYWxpYXM6IFwiaW1wb3J0YW50XCJcbiAgICB9LFxuICAgIGNvbW1lbnQ6IHtcbiAgICAgIHBhdHRlcm46IC8oXnxbXlwie1xcXFwkXSkjLiovLFxuICAgICAgbG9va2JlaGluZDogITBcbiAgICB9LFxuICAgIFwiZnVuY3Rpb24tbmFtZVwiOiBbXG4gICAgICAvLyBhKSBmdW5jdGlvbiBmb28ge1xuICAgICAgLy8gYikgZm9vKCkge1xuICAgICAgLy8gYykgZnVuY3Rpb24gZm9vKCkge1xuICAgICAgLy8gYnV0IG5vdCDigJxmb28ge+KAnVxuICAgICAge1xuICAgICAgICAvLyBhKSBhbmQgYylcbiAgICAgICAgcGF0dGVybjogLyhcXGJmdW5jdGlvblxccyspW1xcdy1dKyg/PSg/OlxccypcXCg/OlxccypcXCkpP1xccypcXHspLyxcbiAgICAgICAgbG9va2JlaGluZDogITAsXG4gICAgICAgIGFsaWFzOiBcImZ1bmN0aW9uXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC8vIGIpXG4gICAgICAgIHBhdHRlcm46IC9cXGJbXFx3LV0rKD89XFxzKlxcKFxccypcXClcXHMqXFx7KS8sXG4gICAgICAgIGFsaWFzOiBcImZ1bmN0aW9uXCJcbiAgICAgIH1cbiAgICBdLFxuICAgIC8vIEhpZ2hsaWdodCB2YXJpYWJsZSBuYW1lcyBhcyB2YXJpYWJsZXMgaW4gZm9yIGFuZCBzZWxlY3QgYmVnaW5uaW5ncy5cbiAgICBcImZvci1vci1zZWxlY3RcIjoge1xuICAgICAgcGF0dGVybjogLyhcXGIoPzpmb3J8c2VsZWN0KVxccyspXFx3Kyg/PVxccytpblxccykvLFxuICAgICAgYWxpYXM6IFwidmFyaWFibGVcIixcbiAgICAgIGxvb2tiZWhpbmQ6ICEwXG4gICAgfSxcbiAgICAvLyBIaWdobGlnaHQgdmFyaWFibGUgbmFtZXMgYXMgdmFyaWFibGVzIGluIHRoZSBsZWZ0LWhhbmQgcGFydFxuICAgIC8vIG9mIGFzc2lnbm1lbnRzICjigJw94oCdIGFuZCDigJwrPeKAnSkuXG4gICAgXCJhc3NpZ24tbGVmdFwiOiB7XG4gICAgICBwYXR0ZXJuOiAvKF58W1xcczt8Jl18Wzw+XVxcKClcXHcrKD86XFwuXFx3KykqKD89XFwrPz0pLyxcbiAgICAgIGluc2lkZToge1xuICAgICAgICBlbnZpcm9ubWVudDoge1xuICAgICAgICAgIHBhdHRlcm46IFJlZ0V4cChcIihefFtcXFxcczt8Jl18Wzw+XVxcXFwoKVwiICsgZSksXG4gICAgICAgICAgbG9va2JlaGluZDogITAsXG4gICAgICAgICAgYWxpYXM6IFwiY29uc3RhbnRcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYWxpYXM6IFwidmFyaWFibGVcIixcbiAgICAgIGxvb2tiZWhpbmQ6ICEwXG4gICAgfSxcbiAgICAvLyBIaWdobGlnaHQgcGFyYW1ldGVyIG5hbWVzIGFzIHZhcmlhYmxlc1xuICAgIHBhcmFtZXRlcjoge1xuICAgICAgcGF0dGVybjogLyhefFxccyktezEsMn0oPzpcXHcrOlsrLV0/KT9cXHcrKD86XFwuXFx3KykqKD89Wz1cXHNdfCQpLyxcbiAgICAgIGFsaWFzOiBcInZhcmlhYmxlXCIsXG4gICAgICBsb29rYmVoaW5kOiAhMFxuICAgIH0sXG4gICAgc3RyaW5nOiBbXG4gICAgICAvLyBTdXBwb3J0IGZvciBIZXJlLWRvY3VtZW50cyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IZXJlX2RvY3VtZW50XG4gICAgICB7XG4gICAgICAgIHBhdHRlcm46IC8oKD86XnxbXjxdKTw8LT9cXHMqKShcXHcrKVxcc1tcXHNcXFNdKj8oPzpcXHI/XFxufFxccilcXDIvLFxuICAgICAgICBsb29rYmVoaW5kOiAhMCxcbiAgICAgICAgZ3JlZWR5OiAhMCxcbiAgICAgICAgaW5zaWRlOiByXG4gICAgICB9LFxuICAgICAgLy8gSGVyZS1kb2N1bWVudCB3aXRoIHF1b3RlcyBhcm91bmQgdGhlIHRhZ1xuICAgICAgLy8g4oaSIE5vIGV4cGFuc2lvbiAoc28gbm8g4oCcaW5zaWRl4oCdKS5cbiAgICAgIHtcbiAgICAgICAgcGF0dGVybjogLygoPzpefFtePF0pPDwtP1xccyopKFtcIiddKShcXHcrKVxcMlxcc1tcXHNcXFNdKj8oPzpcXHI/XFxufFxccilcXDMvLFxuICAgICAgICBsb29rYmVoaW5kOiAhMCxcbiAgICAgICAgZ3JlZWR5OiAhMCxcbiAgICAgICAgaW5zaWRlOiB7XG4gICAgICAgICAgYmFzaDogblxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8g4oCcTm9ybWFs4oCdIHN0cmluZ1xuICAgICAge1xuICAgICAgICAvLyBodHRwczovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2Jhc2gvbWFudWFsL2h0bWxfbm9kZS9Eb3VibGUtUXVvdGVzLmh0bWxcbiAgICAgICAgcGF0dGVybjogLyhefFteXFxcXF0oPzpcXFxcXFxcXCkqKVwiKD86XFxcXFtcXHNcXFNdfFxcJFxcKFteKV0rXFwpfFxcJCg/IVxcKCl8YFteYF0rYHxbXlwiXFxcXGAkXSkqXCIvLFxuICAgICAgICBsb29rYmVoaW5kOiAhMCxcbiAgICAgICAgZ3JlZWR5OiAhMCxcbiAgICAgICAgaW5zaWRlOiByXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAvLyBodHRwczovL3d3dy5nbnUub3JnL3NvZnR3YXJlL2Jhc2gvbWFudWFsL2h0bWxfbm9kZS9TaW5nbGUtUXVvdGVzLmh0bWxcbiAgICAgICAgcGF0dGVybjogLyhefFteJFxcXFxdKSdbXiddKicvLFxuICAgICAgICBsb29rYmVoaW5kOiAhMCxcbiAgICAgICAgZ3JlZWR5OiAhMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgLy8gaHR0cHM6Ly93d3cuZ251Lm9yZy9zb2Z0d2FyZS9iYXNoL21hbnVhbC9odG1sX25vZGUvQU5TSV8wMDJkQy1RdW90aW5nLmh0bWxcbiAgICAgICAgcGF0dGVybjogL1xcJCcoPzpbXidcXFxcXXxcXFxcW1xcc1xcU10pKicvLFxuICAgICAgICBncmVlZHk6ICEwLFxuICAgICAgICBpbnNpZGU6IHtcbiAgICAgICAgICBlbnRpdHk6IHIuZW50aXR5XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdLFxuICAgIGVudmlyb25tZW50OiB7XG4gICAgICBwYXR0ZXJuOiBSZWdFeHAoXCJcXFxcJD9cIiArIGUpLFxuICAgICAgYWxpYXM6IFwiY29uc3RhbnRcIlxuICAgIH0sXG4gICAgdmFyaWFibGU6IHIudmFyaWFibGUsXG4gICAgZnVuY3Rpb246IHtcbiAgICAgIHBhdHRlcm46IC8oXnxbXFxzO3wmXXxbPD5dXFwoKSg/OmFkZHxhcHJvcG9zfGFwdHxhcHQtY2FjaGV8YXB0LWdldHxhcHRpdHVkZXxhc3BlbGx8YXV0b215c3FsYmFja3VwfGF3a3xiYXNlbmFtZXxiYXNofGJjfGJjb25zb2xlfGJnfGJ6aXAyfGNhbHxjYXJnb3xjYXR8Y2ZkaXNrfGNoZ3JwfGNoa2NvbmZpZ3xjaG1vZHxjaG93bnxjaHJvb3R8Y2tzdW18Y2xlYXJ8Y21wfGNvbHVtbnxjb21tfGNvbXBvc2VyfGNwfGNyb258Y3JvbnRhYnxjc3BsaXR8Y3VybHxjdXR8ZGF0ZXxkY3xkZHxkZHJlc2N1ZXxkZWJvb3RzdHJhcHxkZnxkaWZmfGRpZmYzfGRpZ3xkaXJ8ZGlyY29sb3JzfGRpcm5hbWV8ZGlyc3xkbWVzZ3xkb2NrZXJ8ZG9ja2VyLWNvbXBvc2V8ZHV8ZWdyZXB8ZWplY3R8ZW52fGV0aHRvb2x8ZXhwYW5kfGV4cGVjdHxleHByfGZkZm9ybWF0fGZkaXNrfGZnfGZncmVwfGZpbGV8ZmluZHxmbXR8Zm9sZHxmb3JtYXR8ZnJlZXxmc2NrfGZ0cHxmdXNlcnxnYXdrfGdpdHxncGFydGVkfGdyZXB8Z3JvdXBhZGR8Z3JvdXBkZWx8Z3JvdXBtb2R8Z3JvdXBzfGdydWItbWtjb25maWd8Z3ppcHxoYWx0fGhlYWR8aGd8aGlzdG9yeXxob3N0fGhvc3RuYW1lfGh0b3B8aWNvbnZ8aWR8aWZjb25maWd8aWZkb3dufGlmdXB8aW1wb3J0fGluc3RhbGx8aXB8amF2YXxqb2JzfGpvaW58a2lsbHxraWxsYWxsfGxlc3N8bGlua3xsbnxsb2NhdGV8bG9nbmFtZXxsb2dyb3RhdGV8bG9va3xscGN8bHByfGxwcmludHxscHJpbnRkfGxwcmludHF8bHBybXxsc3xsc29mfGx5bnh8bWFrZXxtYW58bWN8bWRhZG18bWtjb25maWd8bWtkaXJ8bWtlMmZzfG1rZmlmb3xta2ZzfG1raXNvZnN8bWtub2R8bWtzd2FwfG1tdnxtb3JlfG1vc3R8bW91bnR8bXRvb2xzfG10cnxtdXR0fG12fG5hbm98bmN8bmV0c3RhdHxuaWNlfG5sfG5vZGV8bm9odXB8bm90aWZ5LXNlbmR8bnBtfG5zbG9va3VwfG9wfG9wZW58cGFydGVkfHBhc3N3ZHxwYXN0ZXxwYXRoY2hrfHBpbmd8cGtpbGx8cG5wbXxwb2RtYW58cG9kbWFuLWNvbXBvc2V8cG9wZHxwcnxwcmludGNhcHxwcmludGVudnxwc3xwdXNoZHxwdnxxdW90YXxxdW90YWNoZWNrfHF1b3RhY3RsfHJhbXxyYXJ8cmNwfHJlYm9vdHxyZW1zeW5jfHJlbmFtZXxyZW5pY2V8cmV2fHJtfHJtZGlyfHJwbXxyc3luY3xzY3B8c2NyZWVufHNkaWZmfHNlZHxzZW5kbWFpbHxzZXF8c2VydmljZXxzZnRwfHNofHNoZWxsY2hlY2t8c2h1ZnxzaHV0ZG93bnxzbGVlcHxzbG9jYXRlfHNvcnR8c3BsaXR8c3NofHN0YXR8c3RyYWNlfHN1fHN1ZG98c3VtfHN1c3BlbmR8c3dhcG9ufHN5bmN8c3lzY3RsfHRhY3x0YWlsfHRhcnx0ZWV8dGltZXx0aW1lb3V0fHRvcHx0b3VjaHx0cnx0cmFjZXJvdXRlfHRzb3J0fHR0eXx1bW91bnR8dW5hbWV8dW5leHBhbmR8dW5pcXx1bml0c3x1bnJhcnx1bnNoYXJ8dW56aXB8dXBkYXRlLWdydWJ8dXB0aW1lfHVzZXJhZGR8dXNlcmRlbHx1c2VybW9kfHVzZXJzfHV1ZGVjb2RlfHV1ZW5jb2RlfHZ8dmNwa2d8dmRpcnx2aXx2aW18dmlyc2h8dm1zdGF0fHdhaXR8d2F0Y2h8d2N8d2dldHx3aGVyZWlzfHdoaWNofHdob3x3aG9hbWl8d3JpdGV8eGFyZ3N8eGRnLW9wZW58eWFybnx5ZXN8emVuaXR5fHppcHx6c2h8enlwcGVyKSg/PSR8WylcXHM7fCZdKS8sXG4gICAgICBsb29rYmVoaW5kOiAhMFxuICAgIH0sXG4gICAga2V5d29yZDoge1xuICAgICAgcGF0dGVybjogLyhefFtcXHM7fCZdfFs8Pl1cXCgpKD86Y2FzZXxkb3xkb25lfGVsaWZ8ZWxzZXxlc2FjfGZpfGZvcnxmdW5jdGlvbnxpZnxpbnxzZWxlY3R8dGhlbnx1bnRpbHx3aGlsZSkoPz0kfFspXFxzO3wmXSkvLFxuICAgICAgbG9va2JlaGluZDogITBcbiAgICB9LFxuICAgIC8vIGh0dHBzOi8vd3d3LmdudS5vcmcvc29mdHdhcmUvYmFzaC9tYW51YWwvaHRtbF9ub2RlL1NoZWxsLUJ1aWx0aW4tQ29tbWFuZHMuaHRtbFxuICAgIGJ1aWx0aW46IHtcbiAgICAgIHBhdHRlcm46IC8oXnxbXFxzO3wmXXxbPD5dXFwoKSg/OlxcLnw6fGFsaWFzfGJpbmR8YnJlYWt8YnVpbHRpbnxjYWxsZXJ8Y2R8Y29tbWFuZHxjb250aW51ZXxkZWNsYXJlfGVjaG98ZW5hYmxlfGV2YWx8ZXhlY3xleGl0fGV4cG9ydHxnZXRvcHRzfGhhc2h8aGVscHxsZXR8bG9jYWx8bG9nb3V0fG1hcGZpbGV8cHJpbnRmfHB3ZHxyZWFkfHJlYWRhcnJheXxyZWFkb25seXxyZXR1cm58c2V0fHNoaWZ0fHNob3B0fHNvdXJjZXx0ZXN0fHRpbWVzfHRyYXB8dHlwZXx0eXBlc2V0fHVsaW1pdHx1bWFza3x1bmFsaWFzfHVuc2V0KSg/PSR8WylcXHM7fCZdKS8sXG4gICAgICBsb29rYmVoaW5kOiAhMCxcbiAgICAgIC8vIEFsaWFzIGFkZGVkIHRvIG1ha2UgdGhvc2UgZWFzaWVyIHRvIGRpc3Rpbmd1aXNoIGZyb20gc3RyaW5ncy5cbiAgICAgIGFsaWFzOiBcImNsYXNzLW5hbWVcIlxuICAgIH0sXG4gICAgYm9vbGVhbjoge1xuICAgICAgcGF0dGVybjogLyhefFtcXHM7fCZdfFs8Pl1cXCgpKD86ZmFsc2V8dHJ1ZSkoPz0kfFspXFxzO3wmXSkvLFxuICAgICAgbG9va2JlaGluZDogITBcbiAgICB9LFxuICAgIFwiZmlsZS1kZXNjcmlwdG9yXCI6IHtcbiAgICAgIHBhdHRlcm46IC9cXEImXFxkXFxiLyxcbiAgICAgIGFsaWFzOiBcImltcG9ydGFudFwiXG4gICAgfSxcbiAgICBvcGVyYXRvcjoge1xuICAgICAgLy8gTG90cyBvZiByZWRpcmVjdGlvbnMgaGVyZSwgYnV0IG5vdCBqdXN0IHRoYXQuXG4gICAgICBwYXR0ZXJuOiAvXFxkPzw+fD5cXHx8XFwrPXw9Wz1+XT98IT0/fDw8WzwtXT98WyZcXGRdPz4+fFxcZFs8Pl0mP3xbPD5dWyY9XT98Jls+Jl0/fFxcfFsmfF0/LyxcbiAgICAgIGluc2lkZToge1xuICAgICAgICBcImZpbGUtZGVzY3JpcHRvclwiOiB7XG4gICAgICAgICAgcGF0dGVybjogL15cXGQvLFxuICAgICAgICAgIGFsaWFzOiBcImltcG9ydGFudFwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHB1bmN0dWF0aW9uOiAvXFwkP1xcKFxcKD98XFwpXFwpP3xcXC5cXC58W3t9W1xcXTtcXFxcXS8sXG4gICAgbnVtYmVyOiB7XG4gICAgICBwYXR0ZXJuOiAvKF58XFxzKSg/OlsxLTldXFxkKnwwKSg/OlsuLF1cXGQrKT9cXGIvLFxuICAgICAgbG9va2JlaGluZDogITBcbiAgICB9XG4gIH0sIG4uaW5zaWRlID0gdC5sYW5ndWFnZXMuYmFzaDtcbiAgZm9yICh2YXIgaSA9IFtcbiAgICBcImNvbW1lbnRcIixcbiAgICBcImZ1bmN0aW9uLW5hbWVcIixcbiAgICBcImZvci1vci1zZWxlY3RcIixcbiAgICBcImFzc2lnbi1sZWZ0XCIsXG4gICAgXCJwYXJhbWV0ZXJcIixcbiAgICBcInN0cmluZ1wiLFxuICAgIFwiZW52aXJvbm1lbnRcIixcbiAgICBcImZ1bmN0aW9uXCIsXG4gICAgXCJrZXl3b3JkXCIsXG4gICAgXCJidWlsdGluXCIsXG4gICAgXCJib29sZWFuXCIsXG4gICAgXCJmaWxlLWRlc2NyaXB0b3JcIixcbiAgICBcIm9wZXJhdG9yXCIsXG4gICAgXCJwdW5jdHVhdGlvblwiLFxuICAgIFwibnVtYmVyXCJcbiAgXSwgcyA9IHIudmFyaWFibGVbMV0uaW5zaWRlLCBvID0gMDsgbyA8IGkubGVuZ3RoOyBvKyspXG4gICAgc1tpW29dXSA9IHQubGFuZ3VhZ2VzLmJhc2hbaVtvXV07XG4gIHQubGFuZ3VhZ2VzLnNoID0gdC5sYW5ndWFnZXMuYmFzaCwgdC5sYW5ndWFnZXMuc2hlbGwgPSB0Lmxhbmd1YWdlcy5iYXNoO1xufSkoUHJpc20pO1xuUHJpc20ubGFuZ3VhZ2VzLmpzb24gPSB7XG4gIHByb3BlcnR5OiB7XG4gICAgcGF0dGVybjogLyhefFteXFxcXF0pXCIoPzpcXFxcLnxbXlxcXFxcIlxcclxcbl0pKlwiKD89XFxzKjopLyxcbiAgICBsb29rYmVoaW5kOiAhMCxcbiAgICBncmVlZHk6ICEwXG4gIH0sXG4gIHN0cmluZzoge1xuICAgIHBhdHRlcm46IC8oXnxbXlxcXFxdKVwiKD86XFxcXC58W15cXFxcXCJcXHJcXG5dKSpcIig/IVxccyo6KS8sXG4gICAgbG9va2JlaGluZDogITAsXG4gICAgZ3JlZWR5OiAhMFxuICB9LFxuICBjb21tZW50OiB7XG4gICAgcGF0dGVybjogL1xcL1xcLy4qfFxcL1xcKltcXHNcXFNdKj8oPzpcXCpcXC98JCkvLFxuICAgIGdyZWVkeTogITBcbiAgfSxcbiAgbnVtYmVyOiAvLT9cXGJcXGQrKD86XFwuXFxkKyk/KD86ZVsrLV0/XFxkKyk/XFxiL2ksXG4gIHB1bmN0dWF0aW9uOiAvW3t9W1xcXSxdLyxcbiAgb3BlcmF0b3I6IC86LyxcbiAgYm9vbGVhbjogL1xcYig/OmZhbHNlfHRydWUpXFxiLyxcbiAgbnVsbDoge1xuICAgIHBhdHRlcm46IC9cXGJudWxsXFxiLyxcbiAgICBhbGlhczogXCJrZXl3b3JkXCJcbiAgfVxufTtcblByaXNtLmxhbmd1YWdlcy53ZWJtYW5pZmVzdCA9IFByaXNtLmxhbmd1YWdlcy5qc29uO1xuKGZ1bmN0aW9uKCkge1xuICBpZiAodHlwZW9mIFByaXNtID4gXCJ1XCIgfHwgdHlwZW9mIGRvY3VtZW50ID4gXCJ1XCIpXG4gICAgcmV0dXJuO1xuICB2YXIgdCA9IFwibGluZS1udW1iZXJzXCIsIGUgPSAvXFxuKD8hJCkvZywgbiA9IFByaXNtLnBsdWdpbnMubGluZU51bWJlcnMgPSB7XG4gICAgLyoqXG4gICAgICogR2V0IG5vZGUgZm9yIHByb3ZpZGVkIGxpbmUgbnVtYmVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgcHJlIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbnVtYmVyIGxpbmUgbnVtYmVyXG4gICAgICogQHJldHVybnMge0VsZW1lbnR8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGdldExpbmU6IGZ1bmN0aW9uKG8sIGEpIHtcbiAgICAgIGlmICghKG8udGFnTmFtZSAhPT0gXCJQUkVcIiB8fCAhby5jbGFzc0xpc3QuY29udGFpbnModCkpKSB7XG4gICAgICAgIHZhciBsID0gby5xdWVyeVNlbGVjdG9yKFwiLmxpbmUtbnVtYmVycy1yb3dzXCIpO1xuICAgICAgICBpZiAobCkge1xuICAgICAgICAgIHZhciBjID0gcGFyc2VJbnQoby5nZXRBdHRyaWJ1dGUoXCJkYXRhLXN0YXJ0XCIpLCAxMCkgfHwgMSwgdSA9IGMgKyAobC5jaGlsZHJlbi5sZW5ndGggLSAxKTtcbiAgICAgICAgICBhIDwgYyAmJiAoYSA9IGMpLCBhID4gdSAmJiAoYSA9IHUpO1xuICAgICAgICAgIHZhciBkID0gYSAtIGM7XG4gICAgICAgICAgcmV0dXJuIGwuY2hpbGRyZW5bZF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFJlc2l6ZXMgdGhlIGxpbmUgbnVtYmVycyBvZiB0aGUgZ2l2ZW4gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBub3QgYWRkIGxpbmUgbnVtYmVycy4gSXQgd2lsbCBvbmx5IHJlc2l6ZSBleGlzdGluZyBvbmVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBBIGA8cHJlPmAgZWxlbWVudCB3aXRoIGxpbmUgbnVtYmVycy5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICByZXNpemU6IGZ1bmN0aW9uKG8pIHtcbiAgICAgIHIoW29dKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIHBsdWdpbiBjYW4gYXNzdW1lIHRoYXQgdGhlIHVuaXRzIGZvbnQgc2l6ZXMgYW5kIG1hcmdpbnMgYXJlIG5vdCBkZXBlbmRlZCBvbiB0aGUgc2l6ZSBvZlxuICAgICAqIHRoZSBjdXJyZW50IHZpZXdwb3J0LlxuICAgICAqXG4gICAgICogU2V0dGluZyB0aGlzIHRvIGB0cnVlYCB3aWxsIGFsbG93IHRoZSBwbHVnaW4gdG8gZG8gY2VydGFpbiBvcHRpbWl6YXRpb25zIGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuXG4gICAgICpcbiAgICAgKiBTZXQgdGhpcyB0byBgZmFsc2VgIGlmIHlvdSB1c2UgYW55IG9mIHRoZSBmb2xsb3dpbmcgQ1NTIHVuaXRzOiBgdmhgLCBgdndgLCBgdm1pbmAsIGB2bWF4YC5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIGFzc3VtZVZpZXdwb3J0SW5kZXBlbmRlbmNlOiAhMFxuICB9O1xuICBmdW5jdGlvbiByKG8pIHtcbiAgICBpZiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uKGwpIHtcbiAgICAgIHZhciBjID0gaShsKSwgdSA9IGNbXCJ3aGl0ZS1zcGFjZVwiXTtcbiAgICAgIHJldHVybiB1ID09PSBcInByZS13cmFwXCIgfHwgdSA9PT0gXCJwcmUtbGluZVwiO1xuICAgIH0pLCBvLmxlbmd0aCAhPSAwKSB7XG4gICAgICB2YXIgYSA9IG8ubWFwKGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgdmFyIGMgPSBsLnF1ZXJ5U2VsZWN0b3IoXCJjb2RlXCIpLCB1ID0gbC5xdWVyeVNlbGVjdG9yKFwiLmxpbmUtbnVtYmVycy1yb3dzXCIpO1xuICAgICAgICBpZiAoISghYyB8fCAhdSkpIHtcbiAgICAgICAgICB2YXIgZCA9IGwucXVlcnlTZWxlY3RvcihcIi5saW5lLW51bWJlcnMtc2l6ZXJcIiksIGYgPSBjLnRleHRDb250ZW50LnNwbGl0KGUpO1xuICAgICAgICAgIGQgfHwgKGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKSwgZC5jbGFzc05hbWUgPSBcImxpbmUtbnVtYmVycy1zaXplclwiLCBjLmFwcGVuZENoaWxkKGQpKSwgZC5pbm5lckhUTUwgPSBcIjBcIiwgZC5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICAgIHZhciBoID0gZC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgICAgICAgcmV0dXJuIGQuaW5uZXJIVE1MID0gXCJcIiwge1xuICAgICAgICAgICAgZWxlbWVudDogbCxcbiAgICAgICAgICAgIGxpbmVzOiBmLFxuICAgICAgICAgICAgbGluZUhlaWdodHM6IFtdLFxuICAgICAgICAgICAgb25lTGluZXJIZWlnaHQ6IGgsXG4gICAgICAgICAgICBzaXplcjogZFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pLmZpbHRlcihCb29sZWFuKTtcbiAgICAgIGEuZm9yRWFjaChmdW5jdGlvbihsKSB7XG4gICAgICAgIHZhciBjID0gbC5zaXplciwgdSA9IGwubGluZXMsIGQgPSBsLmxpbmVIZWlnaHRzLCBmID0gbC5vbmVMaW5lckhlaWdodDtcbiAgICAgICAgZFt1Lmxlbmd0aCAtIDFdID0gdm9pZCAwLCB1LmZvckVhY2goZnVuY3Rpb24oaCwgcCkge1xuICAgICAgICAgIGlmIChoICYmIGgubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdmFyIE8gPSBjLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpKTtcbiAgICAgICAgICAgIE8uc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIiwgTy50ZXh0Q29udGVudCA9IGg7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBkW3BdID0gZjtcbiAgICAgICAgfSk7XG4gICAgICB9KSwgYS5mb3JFYWNoKGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgZm9yICh2YXIgYyA9IGwuc2l6ZXIsIHUgPSBsLmxpbmVIZWlnaHRzLCBkID0gMCwgZiA9IDA7IGYgPCB1Lmxlbmd0aDsgZisrKVxuICAgICAgICAgIHVbZl0gPT09IHZvaWQgMCAmJiAodVtmXSA9IGMuY2hpbGRyZW5bZCsrXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQpO1xuICAgICAgfSksIGEuZm9yRWFjaChmdW5jdGlvbihsKSB7XG4gICAgICAgIHZhciBjID0gbC5zaXplciwgdSA9IGwuZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiLmxpbmUtbnVtYmVycy1yb3dzXCIpO1xuICAgICAgICBjLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIiwgYy5pbm5lckhUTUwgPSBcIlwiLCBsLmxpbmVIZWlnaHRzLmZvckVhY2goZnVuY3Rpb24oZCwgZikge1xuICAgICAgICAgIHUuY2hpbGRyZW5bZl0uc3R5bGUuaGVpZ2h0ID0gZCArIFwicHhcIjtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaShvKSB7XG4gICAgcmV0dXJuIG8gPyB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSA/IGdldENvbXB1dGVkU3R5bGUobykgOiBvLmN1cnJlbnRTdHlsZSB8fCBudWxsIDogbnVsbDtcbiAgfVxuICB2YXIgcyA9IHZvaWQgMDtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgZnVuY3Rpb24oKSB7XG4gICAgbi5hc3N1bWVWaWV3cG9ydEluZGVwZW5kZW5jZSAmJiBzID09PSB3aW5kb3cuaW5uZXJXaWR0aCB8fCAocyA9IHdpbmRvdy5pbm5lcldpZHRoLCByKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJwcmUuXCIgKyB0KSkpKTtcbiAgfSksIFByaXNtLmhvb2tzLmFkZChcImNvbXBsZXRlXCIsIGZ1bmN0aW9uKG8pIHtcbiAgICBpZiAoby5jb2RlKSB7XG4gICAgICB2YXIgYSA9IChcbiAgICAgICAgLyoqIEB0eXBlIHtFbGVtZW50fSAqL1xuICAgICAgICBvLmVsZW1lbnRcbiAgICAgICksIGwgPSAoXG4gICAgICAgIC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovXG4gICAgICAgIGEucGFyZW50Tm9kZVxuICAgICAgKTtcbiAgICAgIGlmICghKCFsIHx8ICEvcHJlL2kudGVzdChsLm5vZGVOYW1lKSkgJiYgIWEucXVlcnlTZWxlY3RvcihcIi5saW5lLW51bWJlcnMtcm93c1wiKSAmJiBQcmlzbS51dGlsLmlzQWN0aXZlKGEsIHQpKSB7XG4gICAgICAgIGEuY2xhc3NMaXN0LnJlbW92ZSh0KSwgbC5jbGFzc0xpc3QuYWRkKHQpO1xuICAgICAgICB2YXIgYyA9IG8uY29kZS5tYXRjaChlKSwgdSA9IGMgPyBjLmxlbmd0aCArIDEgOiAxLCBkLCBmID0gbmV3IEFycmF5KHUgKyAxKS5qb2luKFwiPHNwYW4+PC9zcGFuPlwiKTtcbiAgICAgICAgZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpLCBkLnNldEF0dHJpYnV0ZShcImFyaWEtaGlkZGVuXCIsIFwidHJ1ZVwiKSwgZC5jbGFzc05hbWUgPSBcImxpbmUtbnVtYmVycy1yb3dzXCIsIGQuaW5uZXJIVE1MID0gZiwgbC5oYXNBdHRyaWJ1dGUoXCJkYXRhLXN0YXJ0XCIpICYmIChsLnN0eWxlLmNvdW50ZXJSZXNldCA9IFwibGluZW51bWJlciBcIiArIChwYXJzZUludChsLmdldEF0dHJpYnV0ZShcImRhdGEtc3RhcnRcIiksIDEwKSAtIDEpKSwgby5lbGVtZW50LmFwcGVuZENoaWxkKGQpLCByKFtsXSksIFByaXNtLmhvb2tzLnJ1bihcImxpbmUtbnVtYmVyc1wiLCBvKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pLCBQcmlzbS5ob29rcy5hZGQoXCJsaW5lLW51bWJlcnNcIiwgZnVuY3Rpb24obykge1xuICAgIG8ucGx1Z2lucyA9IG8ucGx1Z2lucyB8fCB7fSwgby5wbHVnaW5zLmxpbmVOdW1iZXJzID0gITA7XG4gIH0pO1xufSkoKTtcbmZ1bmN0aW9uIGlYKHQpIHtcbiAgY29uc3QgZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShcbiAgICB0LFxuICAgIChuLCByKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHIgPT0gXCJvYmplY3RcIiAmJiByICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChlLmhhcyhyKSlcbiAgICAgICAgICByZXR1cm4gXCJbQ2lyY3VsYXJdXCI7XG4gICAgICAgIGUuYWRkKHIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHI7XG4gICAgfSxcbiAgICAyXG4gICk7XG59XG5mdW5jdGlvbiBMYyh0KSB7XG4gIGlmICh0eXBlb2YgdCA9PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiB0O1xuICBpZiAodHlwZW9mIHQgPT0gXCJvYmplY3RcIilcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHQsIG51bGwsIDIpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIGlYKHQpO1xuICAgIH1cbiAgcmV0dXJuIHQ7XG59XG5jb25zdCBzWCA9IFtcImlubmVySFRNTFwiXSwgb1ggPSAvKiBAX19QVVJFX18gKi8gbGUoe1xuICBfX25hbWU6IFwiU2NhbGFyQ29kZUJsb2NrXCIsXG4gIHByb3BzOiB7XG4gICAgY29udGVudDoge30sXG4gICAgbGFuZzogeyBkZWZhdWx0OiBcImpzXCIgfSxcbiAgICBsaW5lTnVtYmVyczogeyB0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiAhMSB9LFxuICAgIGhpZGVDcmVkZW50aWFsczoge31cbiAgfSxcbiAgc2V0dXAodCkge1xuICAgIGNvbnN0IGUgPSB0LCBuID0gQVIoTGMoZS5jb250ZW50KSksIHIgPSBgY29tcG9uZW50cy1zY2FsYXItY29kZS1ibG9jayR7bn1gLCB7IHBsdWdpbnM6IGksIGhpZ2hsaWdodEVsZW1lbnQ6IHMgfSA9IEVhO1xuICAgIGUuaGlkZUNyZWRlbnRpYWxzICYmIEVhLmhvb2tzLmFkZChcIndyYXBcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgaWYgKCFlLmhpZGVDcmVkZW50aWFscylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbGV0IGYgPSAhMTtcbiAgICAgIHR5cGVvZiBlLmhpZGVDcmVkZW50aWFscyA9PSBcInN0cmluZ1wiID8gZC5jb250ZW50LmluY2x1ZGVzKGUuaGlkZUNyZWRlbnRpYWxzKSAmJiAoZiA9ICEwKSA6IEFycmF5LmlzQXJyYXkoZS5oaWRlQ3JlZGVudGlhbHMpICYmIChmID0gZS5oaWRlQ3JlZGVudGlhbHMuc29tZShcbiAgICAgICAgKGgpID0+IGQuY29udGVudC5pbmNsdWRlcyhoKVxuICAgICAgKSksIGYgJiYgKGQuY29udGVudCA9IGQuY29udGVudC5yZXBsYWNlKFxuICAgICAgICAvPHNwYW4gY2xhc3M9XCJjcmVkZW50aWFsc1wiPi4qPzxcXC9zcGFuPi9nLFxuICAgICAgICAoaCkgPT4gaC5yZXBsYWNlKC88c3BhbiBjbGFzcz1cImNyZWRlbnRpYWxzXCI+fDxcXC9zcGFuPi9nLCBcIlwiKVxuICAgICAgKSwgZC5jb250ZW50ID0gZC5jb250ZW50LnJlcGxhY2UoXG4gICAgICAgIG5ldyBSZWdFeHAoXG4gICAgICAgICAgdHlwZW9mIGUuaGlkZUNyZWRlbnRpYWxzID09IFwic3RyaW5nXCIgPyBlLmhpZGVDcmVkZW50aWFscyA6IGUuaGlkZUNyZWRlbnRpYWxzLmpvaW4oXCJ8XCIpLFxuICAgICAgICAgIFwiZ1wiXG4gICAgICAgICksXG4gICAgICAgIChoKSA9PiBgPHNwYW4gY2xhc3M9XCJjcmVkZW50aWFsc1wiPiR7aH08L3NwYW4+YFxuICAgICAgKSk7XG4gICAgfSk7XG4gICAgY29uc3QgbyA9IEcobnVsbCksIGEgPSBHKCR3W3JdID8/IFwiXCIpLCBsID0gaigoKSA9PiBlLmxhbmcgPT09IFwibm9kZVwiID8gXCJqc1wiIDogZS5sYW5nKSwgYyA9IGUubGFuZztcbiAgICBodChcbiAgICAgIFsoKSA9PiBlLmxhbmcsICgpID0+IGUuY29udGVudCwgb10sXG4gICAgICAoKSA9PiB7XG4gICAgICAgIG8udmFsdWUgJiYgZS5jb250ZW50ICYmICghYS52YWx1ZSB8fCBlLmxhbmcgIT09IGMpICYmIChhLnZhbHVlID0gXCJcIiwgUG4oKCkgPT4gcyhvLnZhbHVlKSkpO1xuICAgICAgfSxcbiAgICAgIHsgaW1tZWRpYXRlOiAhMCB9XG4gICAgKTtcbiAgICBjb25zdCB1ID0gL1xcbig/ISQpL2c7XG4gICAgcmV0dXJuIHhkKGFzeW5jICgpID0+IHtcbiAgICAgIGxldCBkID0gXCJcIjtcbiAgICAgIGUubGluZU51bWJlcnMgJiYgRWEuaG9va3MuYWRkKFwiYWZ0ZXItdG9rZW5pemVcIiwgKGgpID0+IHtcbiAgICAgICAgY29uc3QgcCA9IGguY29kZS5tYXRjaCh1KSwgTyA9IHAgPyBwLmxlbmd0aCArIDEgOiAxO1xuICAgICAgICBkID0gYDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGNsYXNzPVwibGluZS1udW1iZXJzLXJvd3NcIj4ke25ldyBBcnJheShPICsgMSkuam9pbihcIjxzcGFuPjwvc3Bhbj5cIil9PC9zcGFuPmA7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGYgPSBFYS5oaWdobGlnaHQoXG4gICAgICAgIExjKGUuY29udGVudCksXG4gICAgICAgIEVhLmxhbmd1YWdlc1tsLnZhbHVlXSxcbiAgICAgICAgbC52YWx1ZVxuICAgICAgKTtcbiAgICAgIGlmIChhLnZhbHVlID0gZiArIGQsIG4gIT09IDApIHtcbiAgICAgICAgY29uc3QgaCA9IHlPKCk7XG4gICAgICAgIGgucGF5bG9hZC5kYXRhW3JdID0gZiArIGQ7XG4gICAgICB9XG4gICAgfSksIGV0KGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IGltcG9ydChcIi4vcHJpc20tYXV0b2xvYWRlci1EbGg4Vnpsdy1CUi1aazMxaS1DMm5KbnlEeS5qc1wiKSwgaS5hdXRvbG9hZGVyLmxhbmd1YWdlc19wYXRoID0gXCJodHRwczovL2NkbmpzLmNsb3VkZmxhcmUuY29tL2FqYXgvbGlicy9wcmlzbS8xLjI5LjAvY29tcG9uZW50cy9cIjtcbiAgICB9KSwgKGQsIGYpID0+IChaKCksIG5lKFwicHJlXCIsIHtcbiAgICAgIGNsYXNzOiBLZShbXG4gICAgICAgIGBzY2FsYXItY29tcG9uZW50IHNjYWxhci1jb2RlYmxvY2stcHJlIGxhbmd1YWdlLSR7bC52YWx1ZX1gLFxuICAgICAgICB7XG4gICAgICAgICAgXCJsaW5lLW51bWJlcnNcIjogZC5saW5lTnVtYmVyc1xuICAgICAgICB9XG4gICAgICBdKVxuICAgIH0sIFtcbiAgICAgIGEudmFsdWUgPyAoWigpLCBuZShcImNvZGVcIiwge1xuICAgICAgICBrZXk6IDAsXG4gICAgICAgIGNsYXNzOiBLZShgc2NhbGFyLWNvZGVibG9jay1jb2RlIGxhbmd1YWdlLSR7bC52YWx1ZX1gKSxcbiAgICAgICAgaW5uZXJIVE1MOiBSKExjKShhLnZhbHVlKVxuICAgICAgfSwgbnVsbCwgMTAsIHNYKSkgOiAoWigpLCBuZShcImNvZGVcIiwge1xuICAgICAgICBrZXk6IDEsXG4gICAgICAgIHJlZl9rZXk6IFwiZWxcIixcbiAgICAgICAgcmVmOiBvLFxuICAgICAgICBjbGFzczogS2UoYHNjYWxhci1jb2RlYmxvY2stY29kZSBsYW5ndWFnZS0ke2wudmFsdWV9YClcbiAgICAgIH0sIERlKFIoTGMpKGQuY29udGVudCkpLCAzKSlcbiAgICBdLCAyKSk7XG4gIH1cbn0pLCBYMCA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuYXNzaWduKHsgXCIuL0FkZC5zdmdcIjogKCkgPT4gaW1wb3J0KFwiLi9BZGQtbmd5WmdZWHgtRHp5UXdKdlMtRGc2bTR1QmUuanNcIiksIFwiLi9BcnJvd0xlZnQuc3ZnXCI6ICgpID0+IGltcG9ydChcIi4vQXJyb3dMZWZ0LWFZMTdXMmFTLURGU0F0T01oLXN0WS0yUk9zLmpzXCIpLCBcIi4vQXJyb3dSaWdodC5zdmdcIjogKCkgPT4gaW1wb3J0KFwiLi9BcnJvd1JpZ2h0LURFTXRkb0U3LUQzVnoxUzVxLUJRZGZaVDhkLmpzXCIpLCBcIi4vQmFja2dyb3VuZC5zdmdcIjogKCkgPT4gaW1wb3J0KFwiLi9CYWNrZ3JvdW5kLURjUmhTSGdmLURNVUxYZWxILUJhZHhnWDBXLmpzXCIpLCBcIi4vQnJhY2tldHMuc3ZnXCI6ICgpID0+IGltcG9ydChcIi4vQnJhY2tldHMtNEk4T0tvbWYtQmRJWGxyVHMtQ1d2RWJxYkQuanNcIiksIFwiLi9CcmFuY2guc3ZnXCI6ICgpID0+IGltcG9ydChcIi4vQnJhbmNoLUNYd2o4WXVHLUl4S3FSV2t4LUNYUUJBZjUxLmpzXCIpLCBcIi4vQ2FsbFRvQWN0aW9uLnN2Z1wiOiAoKSA9PiBpbXBvcnQoXCIuL0NhbGxUb0FjdGlvbi1FeVFLa3ZiZy1ENVVzUTRZSC1oYVhBaU9QVC5qc1wiKSwgXCIuL0NoZWNrbWFyay5zdmdcIjogKCkgPT4gaW1wb3J0KFwiLi9DaGVja21hcmstRGU3bnE2Y0ctQ2VuVk9hdjctRDlCdTVmeGQuanNcIiksIFwiLi9DaGV2cm9uRG93bi5zdmdcIjogKCkgPT4gaW1wb3J0KFwiLi9DaGV2cm9uRG93bi1DbzdFQUtBdi1ESE53WFViUy1DUWxRdzRXWS5qc1wiKSwgXCIuL0NoZXZyb25MZWZ0LnN2Z1wiOiAoKSA9PiBpbXBvcnQoXCIuL0NoZXZyb25MZWZ0LURZdDBpZEF1LURBekN0bXdzLXREQS14ZHZaLmpzXCIpLCBcIi4vQ2hldnJvblJpZ2h0LnN2Z1wiOiAoKSA9PiBpbXBvcnQoXCIuL0NoZXZyb25SaWdodC15bHhUb1ZXbC1DREZEdUJFMS1CMG1ZWGY1ZC5qc1wiKSwgXCIuL0NoZXZyb25VcC5zdmdcIjogKCkgPT4gaW1wb3J0KFwiLi9DaGV2cm9uVXAteEFudWtJZmotQ3VLRkxWRDMtRFdWU1IzRXouanNcIiksIFwiLi9DbGlwYm9hcmQuc3ZnXCI6ICgpID0+IGltcG9ydChcIi4vQ2xpcGJvYXJkLUNVX0t4R0V2LURXclF0V1ZpLUJaRG01dmZpLmpzXCIpLCBcIi4vQ2xvc2Uuc3ZnXCI6ICgpID0+IGltcG9ydChcIi4vQ2xvc2UtQ1czejQycVotQ2VYNnMzRkEtQkpaWnAxMWouanNcIiksIFwiLi9Db2RlRm9sZGVyLnN2Z1wiOiAoKSA9PiBpbXBvcnQoXCIuL0NvZGVGb2xkZXItQ3ZfaWd6SkUtQ29XZmFZMFotQm9XZTBMSFAuanNcIiksIFwiLi9Db29raWUuc3ZnXCI6ICgpID0+IGltcG9ydChcIi4vQ29va2llLUNFSHZYcHFCLUQ5NjBJbUJ5LURWSEYtN3JmLmpzXCIpLCBcIi4vRGFya01vZGUuc3ZnXCI6ICgpID0+IGltcG9ydChcIi4vRGFya01vZGUtQ0JzVjhRX0ktREhQZnVjcG0tRHl6ZlN5WVIuanNcIiksIFwiLi9EZWxldGUuc3ZnXCI6ICgpID0+IGltcG9ydChcIi4vRGVsZXRlLUJDWm14ckRELUJIb0NmX3U0LUNaZXNaYWpPLmpzXCIpLCBcIi4vRGlzY29yZC5zdmdcIjogKCkgPT4gaW1wb3J0KFwiLi9EaXNjb3JkLUJIWU9GQkIyLU5ZQkdZeS1fLUJnVVltYkVLLmpzXCIpLCBcIi4vRG9jc1BhZ2Uuc3ZnXCI6ICgpID0+IGltcG9ydChcIi4vRG9jc1BhZ2UtcmgyeHd4S04tQlAxVmFnZm0tRHBqM2twc0kuanNcIiksIFwiLi9EdXBsaWNhdGUuc3ZnXCI6ICgpID0+IGltcG9ydChcIi4vRHVwbGljYXRlLUJQbHpOcGNmLURibUZLMFhDLUJwMUFiWllSLmpzXCIpLCBcIi4vRWRpdC5zdmdcIjogKCkgPT4gaW1wb3J0KFwiLi9FZGl0LUJyMDRSTlliLUJoQ3lhYzR0LURYbHpxQm5RLmpzXCIpLCBcIi4vRWxsaXBzZXMuc3ZnXCI6ICgpID0+IGltcG9ydChcIi4vRWxsaXBzZXMtQm9fWDM2SHgtQ3NKbUt2bEUtb1NDa05tT2YuanNcIiksIFwiLi9FcnJvci5zdmdcIjogKCkgPT4gaW1wb3J0KFwiLi9FcnJvci1CX1JHdFdKSS1EOUtWLUV2Ry1hdDFCMHNfTS5qc1wiKSwgXCIuL0V4dGVybmFsTGluay5zdmdcIjogKCkgPT4gaW1wb3J0KFwiLi9FeHRlcm5hbExpbmstREs4TC1FSDctQU5KRXpvSE8tQ1kwdlBmb2YuanNcIiksIFwiLi9GaWx0ZXJMaXN0LnN2Z1wiOiAoKSA9PiBpbXBvcnQoXCIuL0ZpbHRlckxpc3QtQ3NBY0U5ZW0tYXliVGhZMVYtQkszLURIc2UuanNcIiksIFwiLi9Gb2xkZXIuc3ZnXCI6ICgpID0+IGltcG9ydChcIi4vRm9sZGVyLUNkY2o0ZXZoLUItZzdUdHpLLVlqV2tVa2dFLmpzXCIpLCBcIi4vR2l0SHViLnN2Z1wiOiAoKSA9PiBpbXBvcnQoXCIuL0dpdEh1Yi1OZEU2WnM5ay1CQUd6Z1hIXy1EVEV5V0N3OC5qc1wiKSwgXCIuL0hpZGUuc3ZnXCI6ICgpID0+IGltcG9ydChcIi4vSGlkZS1RM0dQa0lLSC00MGFJc0x0Ti1Ebk12SEJheC5qc1wiKSwgXCIuL0hpc3Rvcnkuc3ZnXCI6ICgpID0+IGltcG9ydChcIi4vSGlzdG9yeS1EOW5taE5Jbi1CVTltUjU1YS1DYlk2ODk5QS5qc1wiKSwgXCIuL0pzb25PYmplY3Quc3ZnXCI6ICgpID0+IGltcG9ydChcIi4vSnNvbk9iamVjdC1oR2RIVVE0TS1DbTFoWGdBbi1lTmFjbzJFci5qc1wiKSwgXCIuL0tleS5zdmdcIjogKCkgPT4gaW1wb3J0KFwiLi9LZXktQ1dYSnFYMjgtRGROVWhCMTEtRDQzaEZZQlkuanNcIiksIFwiLi9MZWF2ZS5zdmdcIjogKCkgPT4gaW1wb3J0KFwiLi9MZWF2ZS1LMUozdXdvRy1XZ1RtbHdncy1CMUc3QVV4Ny5qc1wiKSwgXCIuL0xpZ2h0RGFya01vZGVUb2dnbGUuc3ZnXCI6ICgpID0+IGltcG9ydChcIi4vTGlnaHREYXJrTW9kZVRvZ2dsZS1Ca3ZNaW1EYS1EazY0Wi1VRS1EaWQxY3B6SC5qc1wiKSwgXCIuL0xpZ2h0TW9kZS5zdmdcIjogKCkgPT4gaW1wb3J0KFwiLi9MaWdodE1vZGUtQnR6NnZ5VF8tSnBLTFB6ZFQtQ1lCU0dvNVcuanNcIiksIFwiLi9MaW5rLnN2Z1wiOiAoKSA9PiBpbXBvcnQoXCIuL0xpbmstQnp1Y19fTmMtQnZ0eDBIWkctQnN4b1RSTEYuanNcIiksIFwiLi9Mb2NrLnN2Z1wiOiAoKSA9PiBpbXBvcnQoXCIuL0xvY2steGhpSDFtS3otUnJscjNmR3YtQ0hIV0p4bTguanNcIiksIFwiLi9Mb2dvLnN2Z1wiOiAoKSA9PiBpbXBvcnQoXCIuL0xvZ28tbXR6ZUtEOE0tTFFjb3I5Uk0tRFVIOTEwNnEuanNcIiksIFwiLi9Mb2dvQVBJLnN2Z1wiOiAoKSA9PiBpbXBvcnQoXCIuL0xvZ29BUEktQ2FVNUU2RkstQnpiNUViblotQkNPM2U1QlIuanNcIiksIFwiLi9Mb2dvQ2xpZW50LnN2Z1wiOiAoKSA9PiBpbXBvcnQoXCIuL0xvZ29DbGllbnQtRGRDLXRfN1AtQl9yWjkxUEMtZWFaNldtT2YuanNcIiksIFwiLi9Mb2dvTWFya2V0LnN2Z1wiOiAoKSA9PiBpbXBvcnQoXCIuL0xvZ29NYXJrZXQtRHdsQXBjYWItX0lOUkRTTHMtQ3U5MkVrMVYuanNcIiksIFwiLi9Mb2dvU3dhZ2dlci5zdmdcIjogKCkgPT4gaW1wb3J0KFwiLi9Mb2dvU3dhZ2dlci1DSDYwSDVxVy1ERkVwRlhJVS1DUkxJV2szay5qc1wiKSwgXCIuL01hZ2ljLnN2Z1wiOiAoKSA9PiBpbXBvcnQoXCIuL01hZ2ljLURzaTlfYkVjLUJZTjQyX2VILURKN2p2cWxwLmpzXCIpLCBcIi4vTWVudS5zdmdcIjogKCkgPT4gaW1wb3J0KFwiLi9NZW51LUNGSzVjT3NtLUNxRTlUc2dyLURNdC1MNk9OLmpzXCIpLCBcIi4vUGFnZS5zdmdcIjogKCkgPT4gaW1wb3J0KFwiLi9QYWdlLUI3clZ1aHBsLUJVSW9nVWlqLUJCNjcxS20xLmpzXCIpLCBcIi4vUGFwZXJBaXJwbGFuZS5zdmdcIjogKCkgPT4gaW1wb3J0KFwiLi9QYXBlckFpcnBsYW5lLUJDLTRtR0VCLUJyVjVmWDhzLWdGREc0TGNGLmpzXCIpLCBcIi4vUGF5bWVudC5zdmdcIjogKCkgPT4gaW1wb3J0KFwiLi9QYXltZW50LWh6Y1hQMVhiLUIyRzFwNC1pLURxeU54U0tGLmpzXCIpLCBcIi4vUGxheS5zdmdcIjogKCkgPT4gaW1wb3J0KFwiLi9QbGF5LUJyVmFnUlFBLURCcmFqY1hiLUJkay01VTNpLmpzXCIpLCBcIi4vUmVmcmVzaC5zdmdcIjogKCkgPT4gaW1wb3J0KFwiLi9SZWZyZXNoLUJlNnZIRUVpLUM2bFJxRmlNLUM3M0hjczFlLmpzXCIpLCBcIi4vUmVzcG9uc2Uuc3ZnXCI6ICgpID0+IGltcG9ydChcIi4vUmVzcG9uc2UtRHE5cE0tWlUtRGNZYjh1ODQtRDlWR0xaY3ouanNcIiksIFwiLi9TZWFyY2guc3ZnXCI6ICgpID0+IGltcG9ydChcIi4vU2VhcmNoLURxdGxzd1JHLUQtaHByRWswLUNJNEdvSzloLmpzXCIpLCBcIi4vU2hvdy5zdmdcIjogKCkgPT4gaW1wb3J0KFwiLi9TaG93LUQ4NmhLejV5LUNGOVB2N0ZTLUNkeWQ0OF9nLmpzXCIpLCBcIi4vU2lkZUJhckNsb3NlZC5zdmdcIjogKCkgPT4gaW1wb3J0KFwiLi9TaWRlQmFyQ2xvc2VkLUNZVU5TMlhNLUN5QW42TXAyLUNxZjR2YWlzLmpzXCIpLCBcIi4vU2lkZUJhck9wZW4uc3ZnXCI6ICgpID0+IGltcG9ydChcIi4vU2lkZUJhck9wZW4tQk94VzQ5X1UtRDVJS3RrZlAtQ1p6UGlQOHIuanNcIiksIFwiLi9Tb3J0LnN2Z1wiOiAoKSA9PiBpbXBvcnQoXCIuL1NvcnQtb1RqQmhKRlEteVdfWk5Vbk4td3ozY3lLZ1QuanNcIiksIFwiLi9UZXJtaW5hbC5zdmdcIjogKCkgPT4gaW1wb3J0KFwiLi9UZXJtaW5hbC1DS3AtLXN1NS12V2FHVTRfei1EQU1CZXNYdi5qc1wiKSwgXCIuL1RodW1ic0Rvd24uc3ZnXCI6ICgpID0+IGltcG9ydChcIi4vVGh1bWJzRG93bi1CTWduc0FTTC1CMllGeEI4aS1EQU1OWGJZZS5qc1wiKSwgXCIuL1RodW1ic1VwLnN2Z1wiOiAoKSA9PiBpbXBvcnQoXCIuL1RodW1ic1VwLUMxajZ6WTJqLURLcWgzejFELUIyVTh6UlZ5LmpzXCIpLCBcIi4vVHJhc2guc3ZnXCI6ICgpID0+IGltcG9ydChcIi4vVHJhc2gtQnBBM3pXUEQtQkFqdVFkeXMtNTJDVnNzMHguanNcIiksIFwiLi9VbmxvY2suc3ZnXCI6ICgpID0+IGltcG9ydChcIi4vVW5sb2NrLUNZOFVxSm9FLUNyd0luaks5LUNZOFRMbkF1LmpzXCIpLCBcIi4vVXBsb2FkLnN2Z1wiOiAoKSA9PiBpbXBvcnQoXCIuL1VwbG9hZC1SRUlkTDdSSS1Dc2ZXUG1iVi1mMDJaZGRNWC5qc1wiKSwgXCIuL1VzZXIuc3ZnXCI6ICgpID0+IGltcG9ydChcIi4vVXNlci1EZjVzdk1RMy1CRDdJV1BRUS1Ca05FMEQydi5qc1wiKSwgXCIuL3Byb2dyYW1taW5nLWZyYW1ld29yay1hbmd1bGFyLnN2Z1wiOiAoKSA9PiBpbXBvcnQoXCIuL3Byb2dyYW1taW5nLWZyYW1ld29yay1hbmd1bGFyLURENFZqZ2JrLUJ6YzlEOWFtLUJmdWNLM3ZTLmpzXCIpLCBcIi4vcHJvZ3JhbW1pbmctZnJhbWV3b3JrLWFzdHJvLnN2Z1wiOiAoKSA9PiBpbXBvcnQoXCIuL3Byb2dyYW1taW5nLWZyYW1ld29yay1hc3Ryby1DTGZyUnQxOS1DZlBseXk2VC1CVTBiVzNOVi5qc1wiKSwgXCIuL3Byb2dyYW1taW5nLWZyYW1ld29yay1sYXJhdmVsLnN2Z1wiOiAoKSA9PiBpbXBvcnQoXCIuL3Byb2dyYW1taW5nLWZyYW1ld29yay1sYXJhdmVsLWtBeTJ3Vkx5LUN0eV80b1hxLTZYMG5td1ZTLmpzXCIpLCBcIi4vcHJvZ3JhbW1pbmctZnJhbWV3b3JrLW5leHRkb3Rqcy5zdmdcIjogKCkgPT4gaW1wb3J0KFwiLi9wcm9ncmFtbWluZy1mcmFtZXdvcmstbmV4dGRvdGpzLUJLZGRfRFlfLURVVHYtdDFRLUNBeV9KTEVXLmpzXCIpLCBcIi4vcHJvZ3JhbW1pbmctZnJhbWV3b3JrLXJlYWN0LnN2Z1wiOiAoKSA9PiBpbXBvcnQoXCIuL3Byb2dyYW1taW5nLWZyYW1ld29yay1yZWFjdC1QRGdtdFp1Ti1EZFVvZ0w4NS1CeVhnckpTRy5qc1wiKSwgXCIuL3Byb2dyYW1taW5nLWZyYW1ld29yay12dWVkb3Rqcy5zdmdcIjogKCkgPT4gaW1wb3J0KFwiLi9wcm9ncmFtbWluZy1mcmFtZXdvcmstdnVlZG90anMtQ3Y0NlcyYUItRHRfSTlwY2otRDZHZnZfcEsuanNcIiksIFwiLi9wcm9ncmFtbWluZy1sYW5ndWFnZS1jLnN2Z1wiOiAoKSA9PiBpbXBvcnQoXCIuL3Byb2dyYW1taW5nLWxhbmd1YWdlLWMtaFBHdTJadmctUUcxcFNkSkctRFRmSzFCTmIuanNcIiksIFwiLi9wcm9ncmFtbWluZy1sYW5ndWFnZS1jbG9qdXJlLnN2Z1wiOiAoKSA9PiBpbXBvcnQoXCIuL3Byb2dyYW1taW5nLWxhbmd1YWdlLWNsb2p1cmUtQ3Ztemt5OHgtRDZHcy02T2wtdXR2cTRXVnEuanNcIiksIFwiLi9wcm9ncmFtbWluZy1sYW5ndWFnZS1jc2hhcnAuc3ZnXCI6ICgpID0+IGltcG9ydChcIi4vcHJvZ3JhbW1pbmctbGFuZ3VhZ2UtY3NoYXJwLWxxWDFvV2diLUIxXzhmWUc5LVBCcFhFWHpKLmpzXCIpLCBcIi4vcHJvZ3JhbW1pbmctbGFuZ3VhZ2UtY3NzMy5zdmdcIjogKCkgPT4gaW1wb3J0KFwiLi9wcm9ncmFtbWluZy1sYW5ndWFnZS1jc3MzLURwcDRDcjZiLUJmNVhGNy1wLURWbFBCUXplLmpzXCIpLCBcIi4vcHJvZ3JhbW1pbmctbGFuZ3VhZ2UtZ28uc3ZnXCI6ICgpID0+IGltcG9ydChcIi4vcHJvZ3JhbW1pbmctbGFuZ3VhZ2UtZ28tRG9KeFd3VDYtQlVnZlNsZzEtQ1JJbEJ4T2QuanNcIiksIFwiLi9wcm9ncmFtbWluZy1sYW5ndWFnZS1odG1sNS5zdmdcIjogKCkgPT4gaW1wb3J0KFwiLi9wcm9ncmFtbWluZy1sYW5ndWFnZS1odG1sNS1EbHFKSzRFTC1CbDlkVEEtRC1CbTJTMU14dS5qc1wiKSwgXCIuL3Byb2dyYW1taW5nLWxhbmd1YWdlLWh0dHAuc3ZnXCI6ICgpID0+IGltcG9ydChcIi4vcHJvZ3JhbW1pbmctbGFuZ3VhZ2UtaHR0cC13TVl3RlMxSS1CV1FYSTQ0TS1pSGpkalFYZy5qc1wiKSwgXCIuL3Byb2dyYW1taW5nLWxhbmd1YWdlLWphdmEuc3ZnXCI6ICgpID0+IGltcG9ydChcIi4vcHJvZ3JhbW1pbmctbGFuZ3VhZ2UtamF2YS1CQ3hHMlRfdy1DV3FCSFZ6Xy1DSkVLV3JDVS5qc1wiKSwgXCIuL3Byb2dyYW1taW5nLWxhbmd1YWdlLWphdmFzY3JpcHQuc3ZnXCI6ICgpID0+IGltcG9ydChcIi4vcHJvZ3JhbW1pbmctbGFuZ3VhZ2UtamF2YXNjcmlwdC1WeEx2aTFRRy1ERmpZRl9NUC1DMXdNeTN6RS5qc1wiKSwgXCIuL3Byb2dyYW1taW5nLWxhbmd1YWdlLWpzb24uc3ZnXCI6ICgpID0+IGltcG9ydChcIi4vcHJvZ3JhbW1pbmctbGFuZ3VhZ2UtanNvbi12RVhfZzdaaS1CTVpyU1IxdC1jYjNmUDRzTS5qc1wiKSwgXCIuL3Byb2dyYW1taW5nLWxhbmd1YWdlLWtvdGxpbi5zdmdcIjogKCkgPT4gaW1wb3J0KFwiLi9wcm9ncmFtbWluZy1sYW5ndWFnZS1rb3RsaW4tREtWOHZQOWgtQzFaaTg5TlotQllIbkk2dHUuanNcIiksIFwiLi9wcm9ncmFtbWluZy1sYW5ndWFnZS1ub2RlLnN2Z1wiOiAoKSA9PiBpbXBvcnQoXCIuL3Byb2dyYW1taW5nLWxhbmd1YWdlLW5vZGUtWHNneDM4bG0tRFpoYU9QSUotRGpzNnZSa0suanNcIiksIFwiLi9wcm9ncmFtbWluZy1sYW5ndWFnZS1vYmpjLnN2Z1wiOiAoKSA9PiBpbXBvcnQoXCIuL3Byb2dyYW1taW5nLWxhbmd1YWdlLW9iamMtQlFYU09Cc1gtQlItQjkxQnktQllIc09nWnUuanNcIiksIFwiLi9wcm9ncmFtbWluZy1sYW5ndWFnZS1vY2FtbC5zdmdcIjogKCkgPT4gaW1wb3J0KFwiLi9wcm9ncmFtbWluZy1sYW5ndWFnZS1vY2FtbC1CRXo3Z0d2Ny1pcDNfWnVoYi1EaVBSdjhtcS5qc1wiKSwgXCIuL3Byb2dyYW1taW5nLWxhbmd1YWdlLXBocC5zdmdcIjogKCkgPT4gaW1wb3J0KFwiLi9wcm9ncmFtbWluZy1sYW5ndWFnZS1waHAtR1kzOGY4cjQtRFFfOEVNRkgtRFR3REVXYzIuanNcIiksIFwiLi9wcm9ncmFtbWluZy1sYW5ndWFnZS1wb3dlcnNoZWxsLnN2Z1wiOiAoKSA9PiBpbXBvcnQoXCIuL3Byb2dyYW1taW5nLWxhbmd1YWdlLXBvd2Vyc2hlbGwtQzlEa1NwMzYtUzN4aXhfZHctQ2MtTU1RNUMuanNcIiksIFwiLi9wcm9ncmFtbWluZy1sYW5ndWFnZS1weXRob24uc3ZnXCI6ICgpID0+IGltcG9ydChcIi4vcHJvZ3JhbW1pbmctbGFuZ3VhZ2UtcHl0aG9uLUN0LV9rTmpvLUJDcmx5ZnYwLUJOeXJDaVZWLmpzXCIpLCBcIi4vcHJvZ3JhbW1pbmctbGFuZ3VhZ2Utci5zdmdcIjogKCkgPT4gaW1wb3J0KFwiLi9wcm9ncmFtbWluZy1sYW5ndWFnZS1yLUJHb0t3dWE5LUJXR09LRDlNLUNVTEtVUERuLmpzXCIpLCBcIi4vcHJvZ3JhbW1pbmctbGFuZ3VhZ2UtcnVieS5zdmdcIjogKCkgPT4gaW1wb3J0KFwiLi9wcm9ncmFtbWluZy1sYW5ndWFnZS1ydWJ5LURoZE00ZDdnLURkM0xhNktuLURaOS1lR2FkLmpzXCIpLCBcIi4vcHJvZ3JhbW1pbmctbGFuZ3VhZ2Utc2NhbGEuc3ZnXCI6ICgpID0+IGltcG9ydChcIi4vcHJvZ3JhbW1pbmctbGFuZ3VhZ2Utc2NhbGEtQlZnMGRUb0otQnpfbi1DTnctREdxWG5UX1ouanNcIiksIFwiLi9wcm9ncmFtbWluZy1sYW5ndWFnZS1zaGVsbC5zdmdcIjogKCkgPT4gaW1wb3J0KFwiLi9wcm9ncmFtbWluZy1sYW5ndWFnZS1zaGVsbC1Cc1RhMXhJNy1YSmJZamg3Ty1EYlRKUHdSbC5qc1wiKSwgXCIuL3Byb2dyYW1taW5nLWxhbmd1YWdlLXN3aWZ0LnN2Z1wiOiAoKSA9PiBpbXBvcnQoXCIuL3Byb2dyYW1taW5nLWxhbmd1YWdlLXN3aWZ0LURuNzJ4UGpnLUJVdnU1X1NWLUJiLW5HZGRhLmpzXCIpLCBcIi4vcHJvZ3JhbW1pbmctbGFuZ3VhZ2UtdHlwZXNjcmlwdC5zdmdcIjogKCkgPT4gaW1wb3J0KFwiLi9wcm9ncmFtbWluZy1sYW5ndWFnZS10eXBlc2NyaXB0LUNkRi1IdVJpLUNhRE8wMk1XLUJCdU8wS2xHLmpzXCIpLCBcIi4vcHJvZ3JhbW1pbmctc2NyaXB0LWNvZGUuc3ZnXCI6ICgpID0+IGltcG9ydChcIi4vcHJvZ3JhbW1pbmctc2NyaXB0LWNvZGUtRFFOMXZlYjItQlBGQUxYVmstQnFPLTBkX1YuanNcIiksIFwiLi9wcm9ncmFtbWluZy10b29sLWdpdC5zdmdcIjogKCkgPT4gaW1wb3J0KFwiLi9wcm9ncmFtbWluZy10b29sLWdpdC1ERG5RMXpHRC1DejZZajB3ai1EcW92RnFPcS5qc1wiKSwgXCIuL3Byb2dyYW1taW5nLXRvb2wtdGFpbHdpbmRjc3Muc3ZnXCI6ICgpID0+IGltcG9ydChcIi4vcHJvZ3JhbW1pbmctdG9vbC10YWlsd2luZGNzcy14alhpMEU2Zy1reTJ3YnNJSS1EWmZTekJuaC5qc1wiKSB9KSwgajAgPSAodCkgPT4ge1xuICBjb25zdCBlID0gYC4vJHt0fS5zdmdgO1xuICByZXR1cm4gWDBbZV0gPyAvKiBAX19QVVJFX18gKi8gYTEoWDBbZV0pIDogKGNvbnNvbGUud2FybihgQ291bGQgbm90IGZpbmQgaWNvbjogJHt0fWApLCBudWxsKTtcbn0sIGFYID0gW1wic3JjXCJdLCBfbCA9IC8qIEBfX1BVUkVfXyAqLyBsZSh7XG4gIF9fbmFtZTogXCJTY2FsYXJJY29uXCIsXG4gIHByb3BzOiB7XG4gICAgaWNvbjoge30sXG4gICAgc2l6ZToge31cbiAgfSxcbiAgc2V0dXAodCkge1xuICAgIGNvbnN0IGUgPSB0LCBuID0gJGcoe1xuICAgICAgdmFyaWFudHM6IHtcbiAgICAgICAgc2l6ZToge1xuICAgICAgICAgIHhzOiBcInNpemUtMyBzdHJva2UtWzEuNF1cIixcbiAgICAgICAgICBzbTogXCJzaXplLTMuNSBzdHJva2UtWzEuMl1cIixcbiAgICAgICAgICBtZDogXCJzaXplLTQgc3Ryb2tlLVsxLjFdXCIsXG4gICAgICAgICAgbGc6IFwic2l6ZS01XCIsXG4gICAgICAgICAgeGw6IFwic2l6ZS02IHN0cm9rZS1bMC45Nl1cIixcbiAgICAgICAgICBcIjJ4bFwiOiBcInNpemUtOCBzdHJva2UtWzAuOTJdXCIsXG4gICAgICAgICAgXCIzeGxcIjogXCJzaXplLTEwIHN0cm9rZS1bMC45XVwiLFxuICAgICAgICAgIGZ1bGw6IFwic2l6ZS1mdWxsXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRlZmF1bHRWYXJpYW50czoge1xuICAgICAgICBzaXplOiBcImZ1bGxcIlxuICAgICAgfVxuICAgIH0pLCByID0gajAoZS5pY29uKTtcbiAgICByZXR1cm4gKGksIHMpID0+IFIocikgPyAoWigpLCBrZShabChSKGowKShpLmljb24pKSwge1xuICAgICAga2V5OiAwLFxuICAgICAgY2xhc3M6IEtlKFIoR2QpKFwic2NhbGFyLWljb25cIiwgUihuKSh7IHNpemU6IGkuc2l6ZSB9KSkpXG4gICAgfSwgbnVsbCwgOCwgW1wiY2xhc3NcIl0pKSA6IChaKCksIG5lKFwiaW1nXCIsIHtcbiAgICAgIGtleTogMSxcbiAgICAgIHNyYzogaS5pY29uXG4gICAgfSwgbnVsbCwgOCwgYVgpKTtcbiAgfVxufSksIGxYID0gW1wiYXJpYURpc2FibGVkXCJdLCBjWCA9IHsgY2xhc3M6IFwic3Itb25seVwiIH0sIHVYID0gLyogQF9fUFVSRV9fICovIGxlKHtcbiAgX19uYW1lOiBcIlNjYWxhckljb25CdXR0b25cIixcbiAgcHJvcHM6IHtcbiAgICBsYWJlbDoge30sXG4gICAgaWNvbjoge30sXG4gICAgZGlzYWJsZWQ6IHsgdHlwZTogQm9vbGVhbiB9LFxuICAgIHZhcmlhbnQ6IHsgZGVmYXVsdDogXCJnaG9zdFwiIH0sXG4gICAgc2l6ZTogeyBkZWZhdWx0OiBcIm1kXCIgfVxuICB9LFxuICBzZXR1cCh0KSB7XG4gICAgY29uc3QgZSA9ICRnKHtcbiAgICAgIGJhc2U6IFwic2NhbGFyLWljb24tYnV0dG9uIGdyaWQgYXNwZWN0LXNxdWFyZSBjdXJzb3ItcG9pbnRlciByb3VuZGVkXCIsXG4gICAgICB2YXJpYW50czoge1xuICAgICAgICBzaXplOiB7XG4gICAgICAgICAgeHM6IFwic2l6ZS0zLjUgcC0wLjVcIixcbiAgICAgICAgICBzbTogXCJzaXplLTYgcC0xXCIsXG4gICAgICAgICAgbWQ6IFwic2l6ZS0xMCBwLTNcIixcbiAgICAgICAgICBmdWxsOiBcImgtZnVsbCB3LWZ1bGxcIlxuICAgICAgICB9LFxuICAgICAgICBkaXNhYmxlZDoge1xuICAgICAgICAgIHRydWU6IFwiY3Vyc29yLW5vdC1hbGxvd2VkIHNoYWRvdy1ub25lXCJcbiAgICAgICAgfSxcbiAgICAgICAgdmFyaWFudDogQVBcbiAgICAgIH1cbiAgICB9KSwgbiA9IGooKCkgPT4ge1xuICAgICAgY29uc3QgeyBjbGFzczogciwgLi4uaSB9ID0geE8oKTtcbiAgICAgIHJldHVybiB7IGNsYXNzOiByIHx8IFwiXCIsIHJlc3Q6IGkgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gKHIsIGkpID0+IChaKCksIG5lKFwiYnV0dG9uXCIsIE1sKG4udmFsdWUucmVzdCwge1xuICAgICAgYXJpYURpc2FibGVkOiByLmRpc2FibGVkIHx8IHZvaWQgMCxcbiAgICAgIGNsYXNzOiBSKEdkKShSKGUpKHsgc2l6ZTogci5zaXplLCB2YXJpYW50OiByLnZhcmlhbnQsIGRpc2FibGVkOiByLmRpc2FibGVkIH0pLCBuLnZhbHVlLmNsYXNzKSxcbiAgICAgIHR5cGU6IFwiYnV0dG9uXCJcbiAgICB9KSwgW1xuICAgICAgSihSKF9sKSwgeyBpY29uOiByLmljb24gfSwgbnVsbCwgOCwgW1wiaWNvblwiXSksXG4gICAgICBEKFwic3BhblwiLCBjWCwgRGUoci5sYWJlbCksIDEpXG4gICAgXSwgMTYsIGxYKSk7XG4gIH1cbn0pLCBkWCA9IHsgY2xhc3M6IFwiY2FyZC1mb3JtLWlucHV0XCIgfSwgZlggPSBbXCJmb3JcIl0sIGhYID0gW1wiaWRcIiwgXCJ0eXBlXCJdLCBwWCA9IC8qIEBfX1BVUkVfXyAqLyBsZSh7XG4gIGluaGVyaXRBdHRyczogITEsXG4gIF9fbmFtZTogXCJDYXJkRm9ybVRleHRJbnB1dFwiLFxuICBwcm9wczoge1xuICAgIGlkOiB7fSxcbiAgICB0eXBlOiB7fVxuICB9LFxuICBzZXR1cCh0KSB7XG4gICAgY29uc3QgZSA9IHQsIG4gPSBHKCEwKSwgciA9IGooXG4gICAgICAoKSA9PiBlLnR5cGUgPT09IFwicGFzc3dvcmRcIiA/IG4udmFsdWUgPyBcInBhc3N3b3JkXCIgOiBcInRleHRcIiA6IGUudHlwZSA/PyBcInRleHRcIlxuICAgICk7XG4gICAgcmV0dXJuIChpLCBzKSA9PiAoWigpLCBuZShcImRpdlwiLCBkWCwgW1xuICAgICAgRChcImxhYmVsXCIsIHsgZm9yOiBpLmlkIH0sIFtcbiAgICAgICAgcHQoaS4kc2xvdHMsIFwiZGVmYXVsdFwiLCB7fSwgdm9pZCAwLCAhMClcbiAgICAgIF0sIDgsIGZYKSxcbiAgICAgIEQoXCJpbnB1dFwiLCBNbChpLiRhdHRycywge1xuICAgICAgICBpZDogaS5pZCxcbiAgICAgICAgYXV0b2NvbXBsZXRlOiBcIm9mZlwiLFxuICAgICAgICBcImRhdGEtMXAtaWdub3JlXCI6IFwiXCIsXG4gICAgICAgIHNwZWxsY2hlY2s6IFwiZmFsc2VcIixcbiAgICAgICAgdHlwZTogci52YWx1ZVxuICAgICAgfSksIG51bGwsIDE2LCBoWCksXG4gICAgICBpLnR5cGUgPT09IFwicGFzc3dvcmRcIiA/IChaKCksIGtlKFIodVgpLCB7XG4gICAgICAgIGtleTogMCxcbiAgICAgICAgY2xhc3M6IFwicGFzc3dvcmQtbWFza1wiLFxuICAgICAgICBpY29uOiBuLnZhbHVlID8gXCJTaG93XCIgOiBcIkhpZGVcIixcbiAgICAgICAgbGFiZWw6IG4udmFsdWUgPyBcIlNob3cgUGFzc3dvcmRcIiA6IFwiSGlkZSBQYXNzd29yZFwiLFxuICAgICAgICBvbkNsaWNrOiBzWzBdIHx8IChzWzBdID0gKG8pID0+IG4udmFsdWUgPSAhbi52YWx1ZSlcbiAgICAgIH0sIG51bGwsIDgsIFtcImljb25cIiwgXCJsYWJlbFwiXSkpIDogc3QoXCJcIiwgITApXG4gICAgXSkpO1xuICB9XG59KSwgbG8gPSAvKiBAX19QVVJFX18gKi8gY3QocFgsIFtbXCJfX3Njb3BlSWRcIiwgXCJkYXRhLXYtYjM2YzJkY2FcIl1dKSwgT1ggPSAodCkgPT4gKEtzKFwiZGF0YS12LTJjMDE4MmYxXCIpLCB0ID0gdCgpLCBKcygpLCB0KSwgZ1ggPSB7IGNsYXNzOiBcInNjb3Blcy1sYWJlbFwiIH0sIG1YID0gLyogQF9fUFVSRV9fICovIE9YKCgpID0+IC8qIEBfX1BVUkVfXyAqLyBEKFwiZW1cIiwgbnVsbCwgXCIvXCIsIC0xKSksIGJYID0gW1wiY2hlY2tlZFwiXSwgdlggPSB7IGNsYXNzOiBcImRyb3Bkb3duLWl0ZW0tdGl0bGVcIiB9LCB5WCA9IHsgY2xhc3M6IFwiZHJvcGRvd24taXRlbS1kZXNjcmlwdGlvblwiIH0sIFNYID0gLyogQF9fUFVSRV9fICovIGxlKHtcbiAgX19uYW1lOiBcIlNlY3VyaXR5U2NoZW1lU2NvcGVzXCIsXG4gIHByb3BzOiB7XG4gICAgc2NvcGVzOiB7fSxcbiAgICBzZWxlY3RlZDoge31cbiAgfSxcbiAgZW1pdHM6IFtcInVwZGF0ZTpzZWxlY3RlZFwiXSxcbiAgc2V0dXAodCwgeyBlbWl0OiBlIH0pIHtcbiAgICBjb25zdCBuID0gdCwgciA9IGUsIGkgPSBHKCksIHMgPSBHKCksIHsgZmxvYXRpbmdTdHlsZXM6IG8gfSA9IGVSKGksIHMsIHtcbiAgICAgIHBsYWNlbWVudDogXCJib3R0b20tZW5kXCIsXG4gICAgICB3aGlsZUVsZW1lbnRzTW91bnRlZDogSDIsXG4gICAgICBtaWRkbGV3YXJlOiBbJDIoNSksIEcyKCksIEYyKCldXG4gICAgfSksIGEgPSBqKHtcbiAgICAgIGdldDogKCkgPT4gbi5zZWxlY3RlZCxcbiAgICAgIHNldDogKGwpID0+IHIoXCJ1cGRhdGU6c2VsZWN0ZWRcIiwgbClcbiAgICB9KTtcbiAgICByZXR1cm4gKGwsIGMpID0+IChaKCksIGtlKFIoRUMpLCB7XG4gICAgICBtb2RlbFZhbHVlOiBhLnZhbHVlLFxuICAgICAgXCJvblVwZGF0ZTptb2RlbFZhbHVlXCI6IGNbMF0gfHwgKGNbMF0gPSAodSkgPT4gYS52YWx1ZSA9IHUpLFxuICAgICAgbXVsdGlwbGU6IFwiXCJcbiAgICB9LCB7XG4gICAgICBkZWZhdWx0OiBjZSgoeyBvcGVuOiB1IH0pID0+IFtcbiAgICAgICAgRChcImRpdlwiLCB7XG4gICAgICAgICAgcmVmX2tleTogXCJ0cmlnZ2VyXCIsXG4gICAgICAgICAgcmVmOiBpLFxuICAgICAgICAgIGNsYXNzOiBLZShbXCJ3cmFwcGVyXCIsIHsgXCJ3cmFwcGVyLW9wZW5cIjogdSB9XSlcbiAgICAgICAgfSwgW1xuICAgICAgICAgIEooUigkQyksIHsgYXM6IHhQIH0sIHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IGNlKCgpID0+IFtcbiAgICAgICAgICAgICAgRChcImRpdlwiLCBnWCwgW1xuICAgICAgICAgICAgICAgIEhlKFwiIFNjb3BlcyBcIiArIERlKGEudmFsdWUubGVuZ3RoKSwgMSksXG4gICAgICAgICAgICAgICAgbVgsXG4gICAgICAgICAgICAgICAgSGUoRGUoT2JqZWN0LmVudHJpZXMobC5zY29wZXMpLmxlbmd0aCkgKyBcIiBcIiwgMSksXG4gICAgICAgICAgICAgICAgSihSKF9sKSwge1xuICAgICAgICAgICAgICAgICAgaWNvbjogdSA/IFwiQ2hldnJvblVwXCIgOiBcIkNoZXZyb25Eb3duXCIsXG4gICAgICAgICAgICAgICAgICBzaXplOiBcInNtXCJcbiAgICAgICAgICAgICAgICB9LCBudWxsLCA4LCBbXCJpY29uXCJdKVxuICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBfOiAyXG4gICAgICAgICAgfSwgMTAyNClcbiAgICAgICAgXSwgMiksXG4gICAgICAgIChaKCksIGtlKFRPLCB7IHRvOiBcImJvZHlcIiB9LCBbXG4gICAgICAgICAgSihSKEVSKSwgbnVsbCwge1xuICAgICAgICAgICAgZGVmYXVsdDogY2UoKHsgc3R5bGVzOiBkIH0pID0+IFtcbiAgICAgICAgICAgICAgRChcImRpdlwiLCB7XG4gICAgICAgICAgICAgICAgcmVmX2tleTogXCJkcm9wZG93blwiLFxuICAgICAgICAgICAgICAgIHJlZjogcyxcbiAgICAgICAgICAgICAgICBjbGFzczogS2UoW1wiZmxvYXRpbmdcIiwgZF0pLFxuICAgICAgICAgICAgICAgIHN0eWxlOiBCcihSKG8pKVxuICAgICAgICAgICAgICB9LCBbXG4gICAgICAgICAgICAgICAgSihSKFFDKSwge1xuICAgICAgICAgICAgICAgICAgYXM6IFwiZGxcIixcbiAgICAgICAgICAgICAgICAgIGNsYXNzOiBcImRyb3Bkb3duXCJcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OiBjZSgoKSA9PiBbXG4gICAgICAgICAgICAgICAgICAgIChaKCEwKSwgbmUoUGUsIG51bGwsIFhyKE9iamVjdC5lbnRyaWVzKGwuc2NvcGVzKSwgKFtmLCBoXSkgPT4gKFooKSwga2UoUihDQyksIHtcbiAgICAgICAgICAgICAgICAgICAgICBrZXk6IGYsXG4gICAgICAgICAgICAgICAgICAgICAgYXM6IFwiZGl2XCIsXG4gICAgICAgICAgICAgICAgICAgICAgY2xhc3M6IFwiZHJvcGRvd24taXRlbVwiLFxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBmXG4gICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBjZSgoeyBzZWxlY3RlZDogcCB9KSA9PiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBEKFwiaW5wdXRcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjaGVja2VkOiBwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogXCJkcm9wZG93bi1pdGVtLWNoZWNrXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRhYmluZGV4OiBcIi0xXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY2hlY2tib3hcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgbnVsbCwgOCwgYlgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgRChcImR0XCIsIHZYLCBEZShmKSwgMSksXG4gICAgICAgICAgICAgICAgICAgICAgICBEKFwiZGRcIiwgeVgsIERlKGgpLCAxKVxuICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgIF86IDJcbiAgICAgICAgICAgICAgICAgICAgfSwgMTAzMiwgW1widmFsdWVcIl0pKSksIDEyOCkpXG4gICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgIF86IDFcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICBdLCA2KVxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBfOiAxXG4gICAgICAgICAgfSlcbiAgICAgICAgXSkpXG4gICAgICBdKSxcbiAgICAgIF86IDFcbiAgICB9LCA4LCBbXCJtb2RlbFZhbHVlXCJdKSk7XG4gIH1cbn0pLCB3WCA9IC8qIEBfX1BVUkVfXyAqLyBjdChTWCwgW1tcIl9fc2NvcGVJZFwiLCBcImRhdGEtdi0yYzAxODJmMVwiXV0pLCBrWCA9IC8qIEBfX1BVUkVfXyAqLyBsZSh7XG4gIF9fbmFtZTogXCJTZWN1cml0eVNjaGVtZVwiLFxuICBwcm9wczoge1xuICAgIHZhbHVlOiB7fVxuICB9LFxuICBzZXR1cCh0KSB7XG4gICAgY29uc3QgeyBhdXRoZW50aWNhdGlvbjogZSwgc2V0QXV0aGVudGljYXRpb246IG4gfSA9IFlsKCksIHIgPSAoZCkgPT4ge1xuICAgICAgbih7XG4gICAgICAgIGFwaUtleToge1xuICAgICAgICAgIC4uLmUuYXBpS2V5LFxuICAgICAgICAgIHRva2VuOiBkLnRhcmdldC52YWx1ZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCBpID0gKGQpID0+IHtcbiAgICAgIG4oe1xuICAgICAgICBodHRwOiB7XG4gICAgICAgICAgLi4uZS5odHRwLFxuICAgICAgICAgIGJhc2ljOiB7XG4gICAgICAgICAgICAuLi5lLmh0dHAuYmFzaWMsXG4gICAgICAgICAgICB1c2VybmFtZTogZC50YXJnZXQudmFsdWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIHMgPSAoZCkgPT4ge1xuICAgICAgbih7XG4gICAgICAgIGh0dHA6IHtcbiAgICAgICAgICAuLi5lLmh0dHAsXG4gICAgICAgICAgYmFzaWM6IHtcbiAgICAgICAgICAgIC4uLmUuaHR0cC5iYXNpYyxcbiAgICAgICAgICAgIHBhc3N3b3JkOiBkLnRhcmdldC52YWx1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSwgbyA9IChkKSA9PiB7XG4gICAgICBuKHtcbiAgICAgICAgaHR0cDoge1xuICAgICAgICAgIC4uLmUuaHR0cCxcbiAgICAgICAgICBiZWFyZXI6IHtcbiAgICAgICAgICAgIC4uLmUuaHR0cC5iZWFyZXIsXG4gICAgICAgICAgICB0b2tlbjogZC50YXJnZXQudmFsdWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIGEgPSAoZCkgPT4ge1xuICAgICAgbih7XG4gICAgICAgIG9BdXRoMjoge1xuICAgICAgICAgIC4uLmUub0F1dGgyLFxuICAgICAgICAgIGNsaWVudElkOiBkLnRhcmdldC52YWx1ZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCBsID0gKGQpID0+IHtcbiAgICAgIGNvbnN0IGYgPSBlLm9BdXRoMi5zY29wZXMuam9pbihcIiBcIiksIGggPSAoTWF0aC5yYW5kb20oKSArIDEpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNyksIHAgPSBuZXcgVVJMKGQuYXV0aG9yaXphdGlvblVybCk7XG4gICAgICByZXR1cm4gbih7XG4gICAgICAgIG9BdXRoMjogeyAuLi5lLm9BdXRoMiwgc3RhdGU6IGggfVxuICAgICAgfSksIHAuc2VhcmNoUGFyYW1zLnNldChcInJlc3BvbnNlX3R5cGVcIiwgXCJ0b2tlblwiKSwgcC5zZWFyY2hQYXJhbXMuc2V0KFwiY2xpZW50X2lkXCIsIGUub0F1dGgyLmNsaWVudElkKSwgcC5zZWFyY2hQYXJhbXMuc2V0KFwicmVkaXJlY3RfdXJpXCIsIHdpbmRvdy5sb2NhdGlvbi5ocmVmKSwgcC5zZWFyY2hQYXJhbXMuc2V0KFwic2NvcGVcIiwgZiksIHAuc2VhcmNoUGFyYW1zLnNldChcInN0YXRlXCIsIGgpLCBwLnRvU3RyaW5nKCk7XG4gICAgfSwgYyA9IGooe1xuICAgICAgZ2V0OiAoKSA9PiBlLm9BdXRoMi5zY29wZXMsXG4gICAgICBzZXQ6IChkKSA9PiBuKHsgb0F1dGgyOiB7IC4uLmUub0F1dGgyLCBzY29wZXM6IGQgfSB9KVxuICAgIH0pLCB1ID0gKGQpID0+IHtcbiAgICAgIGNvbnN0IGggPSB3aW5kb3cub3BlbihkLCBcIm9wZW5BdXRoMldpbmRvd1wiLCBcImxlZnQ9MTAwLHRvcD0xMDAsd2lkdGg9ODAwLGhlaWdodD02MDBcIik7XG4gICAgICBpZiAoaCkge1xuICAgICAgICBjb25zdCBwID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdmFyIE87XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKGgubG9jYXRpb24uaHJlZikuZ2V0KFwiYWNjZXNzX3Rva2VuXCIpO1xuICAgICAgICAgICAgaWYgKGguY2xvc2VkIHx8IHkpIHtcbiAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChwKTtcbiAgICAgICAgICAgICAgY29uc3QgYiA9IChPID0gaC5sb2NhdGlvbi5ocmVmLm1hdGNoKC9zdGF0ZT0oW14mXSopLykpID09IG51bGwgPyB2b2lkIDAgOiBPWzFdO1xuICAgICAgICAgICAgICB5ICYmIGUub0F1dGgyLnN0YXRlID09PSBiICYmIG4oe1xuICAgICAgICAgICAgICAgIG9BdXRoMjogeyAuLi5lLm9BdXRoMiwgYWNjZXNzVG9rZW46IHkgfVxuICAgICAgICAgICAgICB9KSwgaC5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMjAwKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiAoZCwgZikgPT4ge1xuICAgICAgdmFyIGg7XG4gICAgICByZXR1cm4gZC52YWx1ZSAmJiAoKGggPSBkLnZhbHVlKSAhPSBudWxsICYmIGgudHlwZSkgPyAoWigpLCBrZShvTSwgeyBrZXk6IDAgfSwge1xuICAgICAgICBkZWZhdWx0OiBjZSgoKSA9PiBbXG4gICAgICAgICAgZC52YWx1ZS50eXBlID09PSBcImFwaUtleVwiID8gKFooKSwga2UobG8sIHtcbiAgICAgICAgICAgIGtleTogMCxcbiAgICAgICAgICAgIGlkOiBgc2VjdXJpdHktc2NoZW1lLSR7ZC52YWx1ZS5uYW1lfWAsXG4gICAgICAgICAgICBwbGFjZWhvbGRlcjogXCJUb2tlblwiLFxuICAgICAgICAgICAgdHlwZTogXCJwYXNzd29yZFwiLFxuICAgICAgICAgICAgdmFsdWU6IFIoZSkuYXBpS2V5LnRva2VuLFxuICAgICAgICAgICAgb25JbnB1dDogclxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IGNlKCgpID0+IFtcbiAgICAgICAgICAgICAgSGUoRGUoZC52YWx1ZS5pbi5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGQudmFsdWUuaW4uc2xpY2UoMSkpICsgXCIgQVBJIFwiLCAxKVxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBfOiAxXG4gICAgICAgICAgfSwgOCwgW1wiaWRcIiwgXCJ2YWx1ZVwiXSkpIDogZC52YWx1ZS50eXBlID09PSBcImh0dHBcIiB8fCBkLnZhbHVlLnR5cGUgPT09IFwiYmFzaWNcIiA/IChaKCksIG5lKFBlLCB7IGtleTogMSB9LCBbXG4gICAgICAgICAgICBkLnZhbHVlLnR5cGUgPT09IFwiYmFzaWNcIiB8fCBkLnZhbHVlLnNjaGVtZSA9PT0gXCJiYXNpY1wiID8gKFooKSwga2UoTjAsIHsga2V5OiAwIH0sIHtcbiAgICAgICAgICAgICAgZGVmYXVsdDogY2UoKCkgPT4gW1xuICAgICAgICAgICAgICAgIEoobG8sIHtcbiAgICAgICAgICAgICAgICAgIGlkOiBcImh0dHAuYmFzaWMudXNlcm5hbWVcIixcbiAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBcIlVzZXJuYW1lXCIsXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogUihlKS5odHRwLmJhc2ljLnVzZXJuYW1lLFxuICAgICAgICAgICAgICAgICAgb25JbnB1dDogaVxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGNlKCgpID0+IFtcbiAgICAgICAgICAgICAgICAgICAgSGUoXCIgVXNlcm5hbWUgXCIpXG4gICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgIF86IDFcbiAgICAgICAgICAgICAgICB9LCA4LCBbXCJ2YWx1ZVwiXSksXG4gICAgICAgICAgICAgICAgSihsbywge1xuICAgICAgICAgICAgICAgICAgaWQ6IFwiaHR0cC5iYXNpYy5wYXNzd29yZFwiLFxuICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IFwiUGFzc3dvcmRcIixcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwicGFzc3dvcmRcIixcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBSKGUpLmh0dHAuYmFzaWMucGFzc3dvcmQsXG4gICAgICAgICAgICAgICAgICBvbklucHV0OiBzXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDogY2UoKCkgPT4gW1xuICAgICAgICAgICAgICAgICAgICBIZShcIiBQYXNzd29yZCBcIilcbiAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgXzogMVxuICAgICAgICAgICAgICAgIH0sIDgsIFtcInZhbHVlXCJdKVxuICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgXzogMVxuICAgICAgICAgICAgfSkpIDogZC52YWx1ZS50eXBlID09PSBcImh0dHBcIiAmJiBkLnZhbHVlLnNjaGVtZSA9PT0gXCJiZWFyZXJcIiA/IChaKCksIGtlKGxvLCB7XG4gICAgICAgICAgICAgIGtleTogMSxcbiAgICAgICAgICAgICAgaWQ6IFwiaHR0cC5iZWFyZXIudG9rZW5cIixcbiAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6IFwiVG9rZW5cIixcbiAgICAgICAgICAgICAgdHlwZTogXCJwYXNzd29yZFwiLFxuICAgICAgICAgICAgICB2YWx1ZTogUihlKS5odHRwLmJlYXJlci50b2tlbixcbiAgICAgICAgICAgICAgb25JbnB1dDogb1xuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBkZWZhdWx0OiBjZSgoKSA9PiBbXG4gICAgICAgICAgICAgICAgSGUoXCIgQmVhcmVyIFRva2VuIFwiKVxuICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgXzogMVxuICAgICAgICAgICAgfSwgOCwgW1widmFsdWVcIl0pKSA6IHN0KFwiXCIsICEwKVxuICAgICAgICAgIF0sIDY0KSkgOiBkLnZhbHVlLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gXCJvYXV0aDJcIiAmJiBkLnZhbHVlLmZsb3dzICYmIGQudmFsdWUuZmxvd3MuaW1wbGljaXQgPyAoWigpLCBrZShOMCwgeyBrZXk6IDIgfSwge1xuICAgICAgICAgICAgZGVmYXVsdDogY2UoKCkgPT4gW1xuICAgICAgICAgICAgICBSKGUpLm9BdXRoMi5hY2Nlc3NUb2tlbiA/IChaKCksIG5lKFBlLCB7IGtleTogMCB9LCBbXG4gICAgICAgICAgICAgICAgSihsbywge1xuICAgICAgICAgICAgICAgICAgaWQ6IFwib0F1dGgyLmFjY2Vzc1Rva2VuXCIsXG4gICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogXCJ4eHh4eFwiLFxuICAgICAgICAgICAgICAgICAgdHlwZTogXCJwYXNzd29yZFwiLFxuICAgICAgICAgICAgICAgICAgdmFsdWU6IFIoZSkub0F1dGgyLmFjY2Vzc1Rva2VuXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDogY2UoKCkgPT4gW1xuICAgICAgICAgICAgICAgICAgICBIZShcIiBBY2Nlc3MgVG9rZW4gXCIpXG4gICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgIF86IDFcbiAgICAgICAgICAgICAgICB9LCA4LCBbXCJ2YWx1ZVwiXSksXG4gICAgICAgICAgICAgICAgSih4UCwge1xuICAgICAgICAgICAgICAgICAgb25DbGljazogZlswXSB8fCAoZlswXSA9ICgpID0+IFIobikoe1xuICAgICAgICAgICAgICAgICAgICBvQXV0aDI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAuLi5SKGUpLm9BdXRoMixcbiAgICAgICAgICAgICAgICAgICAgICBhY2Nlc3NUb2tlbjogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogXCJcIlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OiBjZSgoKSA9PiBbXG4gICAgICAgICAgICAgICAgICAgIEhlKFwiIFJlc2V0IFwiKVxuICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICBfOiAxXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgXSwgNjQpKSA6IChaKCksIG5lKFBlLCB7IGtleTogMSB9LCBbXG4gICAgICAgICAgICAgICAgSihsbywge1xuICAgICAgICAgICAgICAgICAgaWQ6IFwib0F1dGgyLmNsaWVudElkXCIsXG4gICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogXCIxMjM0NVwiLFxuICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogUihlKS5vQXV0aDIuY2xpZW50SWQsXG4gICAgICAgICAgICAgICAgICBvbklucHV0OiBhXG4gICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgZGVmYXVsdDogY2UoKCkgPT4gW1xuICAgICAgICAgICAgICAgICAgICBIZShcIiBDbGllbnQgSUQgXCIpXG4gICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgIF86IDFcbiAgICAgICAgICAgICAgICB9LCA4LCBbXCJ2YWx1ZVwiXSksXG4gICAgICAgICAgICAgICAgZC52YWx1ZSAhPT0gdm9pZCAwID8gKFooKSwga2Uod1gsIHtcbiAgICAgICAgICAgICAgICAgIGtleTogMCxcbiAgICAgICAgICAgICAgICAgIHNlbGVjdGVkOiBjLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgXCJvblVwZGF0ZTpzZWxlY3RlZFwiOiBmWzFdIHx8IChmWzFdID0gKHApID0+IGMudmFsdWUgPSBwKSxcbiAgICAgICAgICAgICAgICAgIHNjb3BlczogZC52YWx1ZS5mbG93cy5pbXBsaWNpdC5zY29wZXNcbiAgICAgICAgICAgICAgICB9LCBudWxsLCA4LCBbXCJzZWxlY3RlZFwiLCBcInNjb3Blc1wiXSkpIDogc3QoXCJcIiwgITApLFxuICAgICAgICAgICAgICAgIEQoXCJidXR0b25cIiwge1xuICAgICAgICAgICAgICAgICAgY2xhc3M6IFwiY2FyZGZvcm0tYXV0aC1idXR0b25cIixcbiAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6IGZbMl0gfHwgKGZbMl0gPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdShcbiAgICAgICAgICAgICAgICAgICAgICBsKFxuICAgICAgICAgICAgICAgICAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAocCA9IGQudmFsdWUpID09IG51bGwgPyB2b2lkIDAgOiBwLmZsb3dzLmltcGxpY2l0XG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9LCBcIiBBdXRob3JpemUgXCIpXG4gICAgICAgICAgICAgIF0sIDY0KSlcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgXzogMVxuICAgICAgICAgIH0pKSA6IHN0KFwiXCIsICEwKVxuICAgICAgICBdKSxcbiAgICAgICAgXzogMVxuICAgICAgfSkpIDogc3QoXCJcIiwgITApO1xuICAgIH07XG4gIH1cbn0pLCB4WCA9IC8qIEBfX1BVUkVfXyAqLyBjdChrWCwgW1tcIl9fc2NvcGVJZFwiLCBcImRhdGEtdi0zZWI5M2FjOVwiXV0pLCBQWCA9ICh0KSA9PiAoS3MoXCJkYXRhLXYtZDRkMGM5NzlcIiksIHQgPSB0KCksIEpzKCksIHQpLCBfWCA9IHtcbiAga2V5OiAwLFxuICBjbGFzczogXCJzZWN1cml0eS1zY2hlbWUtbGFiZWxcIlxufSwgVFggPSB7XG4gIGtleTogMSxcbiAgY2xhc3M6IFwic2VjdXJpdHktc2NoZW1lLXNlbGVjdG9yXCJcbn0sIEVYID0geyBjbGFzczogXCJzZWN1cml0eS1zY2hlbWUtbGFiZWxcIiB9LCAkWCA9IFtcInZhbHVlXCJdLCBRWCA9IC8qIEBfX1BVUkVfXyAqLyBQWCgoKSA9PiAvKiBAX19QVVJFX18gKi8gRChcIm9wdGlvblwiLCB7IHZhbHVlOiBcIlwiIH0sIFwiTm9uZVwiLCAtMSkpLCBDWCA9IFtcInZhbHVlXCJdLCBBWCA9IC8qIEBfX1BVUkVfXyAqLyBsZSh7XG4gIF9fbmFtZTogXCJTZWN1cml0eVNjaGVtZVNlbGVjdG9yXCIsXG4gIHByb3BzOiB7XG4gICAgdmFsdWU6IHt9XG4gIH0sXG4gIGVtaXRzOiBbXCJpbnB1dFwiXSxcbiAgc2V0dXAodCwgeyBlbWl0OiBlIH0pIHtcbiAgICBjb25zdCBuID0gdCwgciA9IGUsIHsgYXV0aGVudGljYXRpb246IGksIHNldEF1dGhlbnRpY2F0aW9uOiBzIH0gPSBZbCgpLCBvID0gKG0pID0+IHtcbiAgICAgIGEobS50YXJnZXQudmFsdWUpO1xuICAgIH07XG4gICAgZXQoKCkgPT4ge1xuICAgICAgaS5wcmVmZXJyZWRTZWN1cml0eVNjaGVtZSB8fCBhKE9iamVjdC5rZXlzKG4udmFsdWUgPz8ge30pWzBdID8/IG51bGwpO1xuICAgIH0pO1xuICAgIGNvbnN0IGEgPSAobSkgPT4ge1xuICAgICAgcyh7XG4gICAgICAgIHByZWZlcnJlZFNlY3VyaXR5U2NoZW1lOiBtXG4gICAgICB9KSwgcihcImlucHV0XCIsIG0pO1xuICAgIH07XG4gICAgeGQoXG4gICAgICAoKSA9PiBhKE9iamVjdC5rZXlzKG4udmFsdWUgPz8ge30pWzBdID8/IG51bGwpXG4gICAgKTtcbiAgICBjb25zdCBsID0gKG0pID0+ICEobSAhPSBudWxsICYmIG0udHlwZSksIGMgPSAobSkgPT4gbS50eXBlLnRvTG93ZXJDYXNlKCkgPT09IFwiYXBpa2V5XCIsIHUgPSAobSkgPT4gbS50eXBlID09PSBcImh0dHBcIiAmJiBtLnNjaGVtZS50b0xvd2VyQ2FzZSgpID09PSBcImJhc2ljXCIgfHwgbS50eXBlLnRvTG93ZXJDYXNlKCkgPT09IFwiYmFzaWNcIiwgZCA9IChtKSA9PiBtLnR5cGUgPT09IFwiaHR0cFwiICYmIG0uc2NoZW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiYmVhcmVyXCIsIGYgPSAobSkgPT4gbS50eXBlLnRvTG93ZXJDYXNlKCkgPT09IFwib2F1dGgyXCIsIGggPSAobSwgeSkgPT4gYCR7cChtKX0gKCR7eX0pYCwgcCA9IChtKSA9PiBsKG0pID8gXCJObyBBdXRoZW50aWNhdGlvblwiIDogYyhtKSA/IFwiQVBJIEtleVwiIDogdShtKSA/IFwiQmFzaWMgQXV0aGVudGljYXRpb25cIiA6IGQobSkgPyBcIkJlYXJlciBBdXRoZW50aWNhdGlvblwiIDogZihtKSA/IFwiT0F1dGggMi4wXCIgOiBgJHttLnR5cGV9IChub3QgeWV0IHN1cHBvcnRlZClgLCBPID0gaigoKSA9PiBPYmplY3Qua2V5cyhuLnZhbHVlID8/IHt9KSk7XG4gICAgcmV0dXJuIChtLCB5KSA9PiB7XG4gICAgICB2YXIgYiwgZztcbiAgICAgIHJldHVybiBPLnZhbHVlLmxlbmd0aCA9PT0gMSA/IChaKCksIG5lKFwiZGl2XCIsIF9YLCBEZShoKChiID0gbS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IGJbTy52YWx1ZVswXV0sIE8udmFsdWVbMF0pKSwgMSkpIDogTy52YWx1ZS5sZW5ndGggPiAxID8gKFooKSwgbmUoXCJkaXZcIiwgVFgsIFtcbiAgICAgICAgRChcInNwYW5cIiwgRVgsIERlKFIoaSkucHJlZmVycmVkU2VjdXJpdHlTY2hlbWUgPyBoKFxuICAgICAgICAgIChnID0gbS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IGdbUihpKS5wcmVmZXJyZWRTZWN1cml0eVNjaGVtZV0sXG4gICAgICAgICAgUihpKS5wcmVmZXJyZWRTZWN1cml0eVNjaGVtZVxuICAgICAgICApIDogXCJOb25lXCIpLCAxKSxcbiAgICAgICAgSihSKF9sKSwgeyBpY29uOiBcIkNoZXZyb25Eb3duXCIgfSksXG4gICAgICAgIEQoXCJzZWxlY3RcIiwge1xuICAgICAgICAgIHZhbHVlOiBSKGkpLnByZWZlcnJlZFNlY3VyaXR5U2NoZW1lLFxuICAgICAgICAgIG9uQ2xpY2s6IHlbMF0gfHwgKHlbMF0gPSBhUygoKSA9PiB7XG4gICAgICAgICAgfSwgW1wicHJldmVudFwiXSkpLFxuICAgICAgICAgIG9uSW5wdXQ6IG9cbiAgICAgICAgfSwgW1xuICAgICAgICAgIFFYLFxuICAgICAgICAgIChaKCEwKSwgbmUoUGUsIG51bGwsIFhyKE8udmFsdWUsICh2KSA9PiB7XG4gICAgICAgICAgICB2YXIgUztcbiAgICAgICAgICAgIHJldHVybiBaKCksIG5lKFwib3B0aW9uXCIsIHtcbiAgICAgICAgICAgICAga2V5OiB2LFxuICAgICAgICAgICAgICB2YWx1ZTogdiA/PyBudWxsXG4gICAgICAgICAgICB9LCBEZShoKChTID0gbS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IFNbdl0sIHYpKSwgOSwgQ1gpO1xuICAgICAgICAgIH0pLCAxMjgpKVxuICAgICAgICBdLCA0MCwgJFgpXG4gICAgICBdKSkgOiBzdChcIlwiLCAhMCk7XG4gICAgfTtcbiAgfVxufSksIFJYID0gLyogQF9fUFVSRV9fICovIGN0KEFYLCBbW1wiX19zY29wZUlkXCIsIFwiZGF0YS12LWQ0ZDBjOTc5XCJdXSksIE5YID0ge1xuICBrZXk6IDAsXG4gIGNsYXNzOiBcInByZWZlcnJlZC1zZWN1cml0eS1zY2hlbWVcIlxufSwgRFggPSB7XG4gIGtleTogMSxcbiAgY2xhc3M6IFwic2VjdXJpdHktc2NoZW1lLWVtcHR5LXN0YXRlXCJcbn0sIFpYID0gLyogQF9fUFVSRV9fICovIGxlKHtcbiAgX19uYW1lOiBcIlJlcXVlc3RBdXRoZW50aWNhdGlvblwiLFxuICBzZXR1cCh0KSB7XG4gICAgY29uc3QgZSA9IEcobnVsbCk7XG4gICAga1Aub24oKCkgPT4ge1xuICAgICAgaWYgKCFlLnZhbHVlKVxuICAgICAgICByZXR1cm47XG4gICAgICBlLnZhbHVlLnNjcm9sbEludG9WaWV3KHtcbiAgICAgICAgYmVoYXZpb3I6IFwic21vb3RoXCIsXG4gICAgICAgIGJsb2NrOiBcImNlbnRlclwiXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBjb25zdCB7IGF1dGhlbnRpY2F0aW9uOiBuLCBzZXRBdXRoZW50aWNhdGlvbjogciB9ID0gWWwoKSwgaSA9IChzKSA9PiB7XG4gICAgICByKHtcbiAgICAgICAgY3VzdG9tU2VjdXJpdHk6ICEwLFxuICAgICAgICBwcmVmZXJyZWRTZWN1cml0eVNjaGVtZTogcyxcbiAgICAgICAgc2VjdXJpdHlTY2hlbWVzOiB7XG4gICAgICAgICAgYXBpS2V5OiB7IHR5cGU6IFwiYXBpS2V5XCIsIG5hbWU6IFwiYXBpS2V5XCIsIGluOiBcImhlYWRlclwiIH0sXG4gICAgICAgICAgaHR0cEJhc2ljOiB7IHR5cGU6IFwiaHR0cFwiLCBzY2hlbWU6IFwiYmFzaWNcIiB9LFxuICAgICAgICAgIGh0dHBCZWFyZXI6IHsgdHlwZTogXCJodHRwXCIsIHNjaGVtZTogXCJiZWFyZXJcIiB9XG4gICAgICAgICAgLy8gVE9ETyBvYXV0aDJcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gKHMsIG8pID0+IChaKCksIG5lKFwiZGl2XCIsIHtcbiAgICAgIHJlZl9rZXk6IFwicmVxdWVzdEF1dGhlbnRpY2F0aW9uUmVmXCIsXG4gICAgICByZWY6IGVcbiAgICB9LCBbXG4gICAgICBKKFIoYmkpLCB7IHRpdGxlOiBcIkF1dGhlbnRpY2F0aW9uXCIgfSwge1xuICAgICAgICBvcHRpb25zOiBjZSgoKSA9PiBbXG4gICAgICAgICAgSihSWCwge1xuICAgICAgICAgICAgdmFsdWU6IFIobikuc2VjdXJpdHlTY2hlbWVzXG4gICAgICAgICAgfSwgbnVsbCwgOCwgW1widmFsdWVcIl0pXG4gICAgICAgIF0pLFxuICAgICAgICBkZWZhdWx0OiBjZSgoKSA9PiB7XG4gICAgICAgICAgdmFyIGE7XG4gICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIFIobikucHJlZmVycmVkU2VjdXJpdHlTY2hlbWUgPyAoWigpLCBuZShcImRpdlwiLCBOWCwgW1xuICAgICAgICAgICAgICBKKHhYLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IChhID0gUihuKS5zZWN1cml0eVNjaGVtZXMpID09IG51bGwgPyB2b2lkIDAgOiBhW1IobikucHJlZmVycmVkU2VjdXJpdHlTY2hlbWVdXG4gICAgICAgICAgICAgIH0sIG51bGwsIDgsIFtcInZhbHVlXCJdKVxuICAgICAgICAgICAgXSkpIDogc3QoXCJcIiwgITApLFxuICAgICAgICAgICAgUihuKS5zZWN1cml0eVNjaGVtZXMgPyBzdChcIlwiLCAhMCkgOiAoWigpLCBuZShcImRpdlwiLCBEWCwgW1xuICAgICAgICAgICAgICBEKFwiZGl2XCIsIHtcbiAgICAgICAgICAgICAgICBjbGFzczogXCJzY2FsYXItYXBpLWNsaWVudC1hZGRcIixcbiAgICAgICAgICAgICAgICB2YXJpYW50OiBcIm91dGxpbmVkXCIsXG4gICAgICAgICAgICAgICAgb25DbGljazogb1swXSB8fCAob1swXSA9IChsKSA9PiBpKFwiYXBpS2V5XCIpKVxuICAgICAgICAgICAgICB9LCBcIiBBcGlLZXkgXCIpLFxuICAgICAgICAgICAgICBEKFwiZGl2XCIsIHtcbiAgICAgICAgICAgICAgICBjbGFzczogXCJzY2FsYXItYXBpLWNsaWVudC1hZGRcIixcbiAgICAgICAgICAgICAgICB2YXJpYW50OiBcIm91dGxpbmVkXCIsXG4gICAgICAgICAgICAgICAgb25DbGljazogb1sxXSB8fCAob1sxXSA9IChsKSA9PiBpKFwiaHR0cEJhc2ljXCIpKVxuICAgICAgICAgICAgICB9LCBcIiBCYXNpYyBcIiksXG4gICAgICAgICAgICAgIEQoXCJkaXZcIiwge1xuICAgICAgICAgICAgICAgIGNsYXNzOiBcInNjYWxhci1hcGktY2xpZW50LWFkZFwiLFxuICAgICAgICAgICAgICAgIHZhcmlhbnQ6IFwib3V0bGluZWRcIixcbiAgICAgICAgICAgICAgICBvbkNsaWNrOiBvWzJdIHx8IChvWzJdID0gKGwpID0+IGkoXCJodHRwQmVhcmVyXCIpKVxuICAgICAgICAgICAgICB9LCBcIiBCZWFyZXIgXCIpXG4gICAgICAgICAgICBdKSlcbiAgICAgICAgICBdO1xuICAgICAgICB9KSxcbiAgICAgICAgXzogMVxuICAgICAgfSlcbiAgICBdLCA1MTIpKTtcbiAgfVxufSksIFZYID0gLyogQF9fUFVSRV9fICovIGN0KFpYLCBbW1wiX19zY29wZUlkXCIsIFwiZGF0YS12LWQzNGM3ZjBjXCJdXSksIElYID0geyBjbGFzczogXCJ0YWJsZS1yb3dcIiB9LCBXWCA9IHsgY2xhc3M6IFwidGFibGUtcm93LWl0ZW1cIiB9LCBNWCA9IHsgY2xhc3M6IFwidGFibGUtcm93LWl0ZW1cIiB9LCBYWCA9IHtcbiAga2V5OiAwLFxuICBjbGFzczogXCJ0YWJsZS1yb3ctaXRlbVwiXG59LCBqWCA9IHsgY2xhc3M6IFwidGFibGUtcm93LW1ldGFcIiB9LCBCWCA9IC8qIEBfX1BVUkVfXyAqLyBsZSh7XG4gIF9fbmFtZTogXCJHcmlkUm93XCIsXG4gIHByb3BzOiB7XG4gICAgc2hvd0Rlc2NyaXB0aW9uOiB7IHR5cGU6IEJvb2xlYW4gfVxuICB9LFxuICBzZXR1cCh0KSB7XG4gICAgcmV0dXJuIChlLCBuKSA9PiAoWigpLCBuZShcImRpdlwiLCBJWCwgW1xuICAgICAgRChcImRpdlwiLCBXWCwgW1xuICAgICAgICBwdChlLiRzbG90cywgXCJrZXlcIiwge30sIHZvaWQgMCwgITApXG4gICAgICBdKSxcbiAgICAgIEQoXCJkaXZcIiwgTVgsIFtcbiAgICAgICAgcHQoZS4kc2xvdHMsIFwidmFsdWVcIiwge30sIHZvaWQgMCwgITApXG4gICAgICBdKSxcbiAgICAgIGUuc2hvd0Rlc2NyaXB0aW9uID8gKFooKSwgbmUoXCJkaXZcIiwgWFgsIFtcbiAgICAgICAgcHQoZS4kc2xvdHMsIFwiZGVzY3JpcHRpb25cIiwge30sIHZvaWQgMCwgITApXG4gICAgICBdKSkgOiBzdChcIlwiLCAhMCksXG4gICAgICBEKFwiZGl2XCIsIGpYLCBbXG4gICAgICAgIHB0KGUuJHNsb3RzLCBcIm1ldGFcIiwge30sIHZvaWQgMCwgITApXG4gICAgICBdKVxuICAgIF0pKTtcbiAgfVxufSksIFFnID0gLyogQF9fUFVSRV9fICovIGN0KEJYLCBbW1wiX19zY29wZUlkXCIsIFwiZGF0YS12LWQwZjI4ZjZlXCJdXSksIEtkID0gKHQpID0+IChLcyhcImRhdGEtdi0xZmQ3OTIwMlwiKSwgdCA9IHQoKSwgSnMoKSwgdCksIExYID0gLyogQF9fUFVSRV9fICovIEtkKCgpID0+IC8qIEBfX1BVUkVfXyAqLyBEKFwibGFiZWxcIiwgeyBjbGFzczogXCJ0YWJsZS1jb2x1bW4taGVhZGVyXCIgfSwgXCJLZXlcIiwgLTEpKSwgVVggPSAvKiBAX19QVVJFX18gKi8gS2QoKCkgPT4gLyogQF9fUFVSRV9fICovIEQoXCJsYWJlbFwiLCB7IGNsYXNzOiBcInRhYmxlLWNvbHVtbi1oZWFkZXJcIiB9LCBcIlZhbHVlXCIsIC0xKSksIHFYID0gLyogQF9fUFVSRV9fICovIEtkKCgpID0+IC8qIEBfX1BVUkVfXyAqLyBEKFwibGFiZWxcIiwgeyBjbGFzczogXCJ0YWJsZS1jb2x1bW4taGVhZGVyXCIgfSwgXCJEZXNjcmlwdGlvblwiLCAtMSkpLCBZWCA9IC8qIEBfX1BVUkVfXyAqLyBLZCgoKSA9PiAvKiBAX19QVVJFX18gKi8gRChcInN2Z1wiLCB7XG4gIGZpbGw6IFwiY3VycmVudENvbG9yXCIsXG4gIGhlaWdodDogXCIxMlwiLFxuICB2aWV3Qm94OiBcIjAgMCAxOCAxMlwiLFxuICB3aWR0aDogXCIxOFwiLFxuICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG59LCBbXG4gIC8qIEBfX1BVUkVfXyAqLyBEKFwicGF0aFwiLCB7XG4gICAgZDogXCJNMCAxMmgxMnYtMkgwdjJ6TTAgMHYyaDE4VjBIMHptMCA3aDE4VjVIMHYyelwiLFxuICAgIFwiZmlsbC1ydWxlXCI6IFwibm9uemVyb1wiXG4gIH0pXG5dLCAtMSkpLCB6WCA9IC8qIEBfX1BVUkVfXyAqLyBsZSh7XG4gIF9fbmFtZTogXCJHcmlkSGVhZGVyXCIsXG4gIHByb3BzOiB7XG4gICAgc2hvd0Rlc2NyaXB0aW9uOiB7IHR5cGU6IEJvb2xlYW4gfVxuICB9LFxuICBlbWl0czogW1widXBkYXRlOnNob3dEZXNjcmlwdGlvblwiXSxcbiAgc2V0dXAodCkge1xuICAgIHJldHVybiAoZSwgbikgPT4gKFooKSwga2UoUWcsIHsgc2hvd0Rlc2NyaXB0aW9uOiBlLnNob3dEZXNjcmlwdGlvbiB9LCB7XG4gICAgICBrZXk6IGNlKCgpID0+IFtcbiAgICAgICAgTFhcbiAgICAgIF0pLFxuICAgICAgdmFsdWU6IGNlKCgpID0+IFtcbiAgICAgICAgVVhcbiAgICAgIF0pLFxuICAgICAgZGVzY3JpcHRpb246IGNlKCgpID0+IFtcbiAgICAgICAgcVhcbiAgICAgIF0pLFxuICAgICAgbWV0YTogY2UoKCkgPT4gW1xuICAgICAgICBKKFIoclgpLCB7XG4gICAgICAgICAgY2xhc3M6IFwidGFibGUtZGVzY3JpcHRpb24tdG9nZ2xlXCIsXG4gICAgICAgICAgdmFyaWFudDogXCJ0ZXh0XCIsXG4gICAgICAgICAgb25DbGljazogblswXSB8fCAoblswXSA9IChyKSA9PiBlLiRlbWl0KFwidXBkYXRlOnNob3dEZXNjcmlwdGlvblwiLCAhZS5zaG93RGVzY3JpcHRpb24pKVxuICAgICAgICB9LCB7XG4gICAgICAgICAgZGVmYXVsdDogY2UoKCkgPT4gW1xuICAgICAgICAgICAgWVhcbiAgICAgICAgICBdKSxcbiAgICAgICAgICBfOiAxXG4gICAgICAgIH0pXG4gICAgICBdKSxcbiAgICAgIF86IDFcbiAgICB9LCA4LCBbXCJzaG93RGVzY3JpcHRpb25cIl0pKTtcbiAgfVxufSksIEhYID0gLyogQF9fUFVSRV9fICovIGN0KHpYLCBbW1wiX19zY29wZUlkXCIsIFwiZGF0YS12LTFmZDc5MjAyXCJdXSksIFJQID0gKHQpID0+IChLcyhcImRhdGEtdi1jMDQyYjgzOVwiKSwgdCA9IHQoKSwgSnMoKSwgdCksIEZYID0geyBjbGFzczogXCJtZXRhLWNoZWNrXCIgfSwgR1ggPSAvKiBAX19QVVJFX18gKi8gUlAoKCkgPT4gLyogQF9fUFVSRV9fICovIEQoXCJzcGFuXCIsIHsgY2xhc3M6IFwibWV0YS1jaGVja21hcmtcIiB9LCBudWxsLCAtMSkpLCBLWCA9IC8qIEBfX1BVUkVfXyAqLyBSUCgoKSA9PiAvKiBAX19QVVJFX18gKi8gRChcInN2Z1wiLCB7XG4gIGZpbGw6IFwibm9uZVwiLFxuICBoZWlnaHQ6IFwiMTBcIixcbiAgdmlld0JveDogXCItMC41IC0wLjUgMTAgMTBcIixcbiAgd2lkdGg6IFwiMTBcIixcbiAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxufSwgW1xuICAvKiBAX19QVVJFX18gKi8gRChcInBhdGhcIiwge1xuICAgIGQ6IFwibTguNTUgMC40NSAtOC4xIDguMVwiLFxuICAgIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIixcbiAgICBcInN0cm9rZS1saW5lY2FwXCI6IFwicm91bmRcIixcbiAgICBcInN0cm9rZS1saW5lam9pblwiOiBcInJvdW5kXCIsXG4gICAgXCJzdHJva2Utd2lkdGhcIjogXCIxLjVcIlxuICB9KSxcbiAgLyogQF9fUFVSRV9fICovIEQoXCJwYXRoXCIsIHtcbiAgICBkOiBcIm0wLjQ1IDAuNDUgOC4xIDguMVwiLFxuICAgIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIixcbiAgICBcInN0cm9rZS1saW5lY2FwXCI6IFwicm91bmRcIixcbiAgICBcInN0cm9rZS1saW5lam9pblwiOiBcInJvdW5kXCIsXG4gICAgXCJzdHJva2Utd2lkdGhcIjogXCIxLjVcIlxuICB9KVxuXSwgLTEpKSwgSlggPSBbXG4gIEtYXG5dLCBlOCA9IC8qIEBfX1BVUkVfXyAqLyBsZSh7XG4gIF9fbmFtZTogXCJHcmlkUm93RWRpdGFibGVcIixcbiAgcHJvcHM6IHtcbiAgICBuYW1lOiB7fSxcbiAgICBkZXNjcmlwdGlvbjoge30sXG4gICAgdmFsdWU6IHt9LFxuICAgIHJlcXVpcmVkOiB7IHR5cGU6IEJvb2xlYW4gfSxcbiAgICBlbmFibGVkOiB7IHR5cGU6IEJvb2xlYW4gfVxuICB9LFxuICBlbWl0czogW1widXBkYXRlOm5hbWVcIiwgXCJ1cGRhdGU6dmFsdWVcIiwgXCJ1cGRhdGU6ZGVzY3JpcHRpb25cIiwgXCJ1cGRhdGU6ZW5hYmxlZFwiLCBcImRlbGV0ZVwiXSxcbiAgc2V0dXAodCwgeyBlbWl0OiBlIH0pIHtcbiAgICBjb25zdCBuID0gdCwgciA9IGUsIGkgPSBqKHtcbiAgICAgIGdldDogKCkgPT4gbi5uYW1lLFxuICAgICAgc2V0OiAobCkgPT4ge1xuICAgICAgICByKFwidXBkYXRlOmVuYWJsZWRcIiwgITApLCByKFwidXBkYXRlOm5hbWVcIiwgbCk7XG4gICAgICB9XG4gICAgfSksIHMgPSBqKHtcbiAgICAgIGdldDogKCkgPT4gYCR7bi52YWx1ZX1gLFxuICAgICAgc2V0OiAobCkgPT4ge1xuICAgICAgICByKFwidXBkYXRlOmVuYWJsZWRcIiwgITApLCByKFwidXBkYXRlOnZhbHVlXCIsIGwpO1xuICAgICAgfVxuICAgIH0pLCBvID0gaih7XG4gICAgICBnZXQ6ICgpID0+IG4uZGVzY3JpcHRpb24gPz8gXCJcIixcbiAgICAgIHNldDogKGwpID0+IHIoXCJ1cGRhdGU6ZGVzY3JpcHRpb25cIiwgbClcbiAgICB9KSwgYSA9IGooe1xuICAgICAgZ2V0OiAoKSA9PiBuLmVuYWJsZWQsXG4gICAgICBzZXQ6IChsKSA9PiByKFwidXBkYXRlOmVuYWJsZWRcIiwgbClcbiAgICB9KTtcbiAgICByZXR1cm4gKGwsIGMpID0+IChaKCksIGtlKFFnLCB7XG4gICAgICBjbGFzczogS2UoW1widGFibGUtcm93LWVkaXRhYmxlXCIsIHsgXCJyZXF1aXJlZC1wYXJhbWV0ZXJcIjogbC5yZXF1aXJlZCB9XSlcbiAgICB9LCB7XG4gICAgICBrZXk6IGNlKCgpID0+IFtcbiAgICAgICAgWGkoRChcImlucHV0XCIsIHtcbiAgICAgICAgICBcIm9uVXBkYXRlOm1vZGVsVmFsdWVcIjogY1swXSB8fCAoY1swXSA9ICh1KSA9PiBpLnZhbHVlID0gdSksXG4gICAgICAgICAgcGxhY2Vob2xkZXI6IFwiS2V5XCJcbiAgICAgICAgfSwgbnVsbCwgNTEyKSwgW1xuICAgICAgICAgIFtHaSwgaS52YWx1ZV1cbiAgICAgICAgXSlcbiAgICAgIF0pLFxuICAgICAgdmFsdWU6IGNlKCgpID0+IFtcbiAgICAgICAgWGkoRChcImlucHV0XCIsIHtcbiAgICAgICAgICBcIm9uVXBkYXRlOm1vZGVsVmFsdWVcIjogY1sxXSB8fCAoY1sxXSA9ICh1KSA9PiBzLnZhbHVlID0gdSksXG4gICAgICAgICAgcGxhY2Vob2xkZXI6IFwiVmFsdWVcIlxuICAgICAgICB9LCBudWxsLCA1MTIpLCBbXG4gICAgICAgICAgW0dpLCBzLnZhbHVlXVxuICAgICAgICBdKVxuICAgICAgXSksXG4gICAgICBkZXNjcmlwdGlvbjogY2UoKCkgPT4gW1xuICAgICAgICBYaShEKFwiaW5wdXRcIiwge1xuICAgICAgICAgIFwib25VcGRhdGU6bW9kZWxWYWx1ZVwiOiBjWzJdIHx8IChjWzJdID0gKHUpID0+IG8udmFsdWUgPSB1KSxcbiAgICAgICAgICBwbGFjZWhvbGRlcjogXCJEZXNjcmlwdGlvblwiXG4gICAgICAgIH0sIG51bGwsIDUxMiksIFtcbiAgICAgICAgICBbR2ksIG8udmFsdWVdXG4gICAgICAgIF0pXG4gICAgICBdKSxcbiAgICAgIG1ldGE6IGNlKCgpID0+IFtcbiAgICAgICAgRChcImxhYmVsXCIsIEZYLCBbXG4gICAgICAgICAgWGkoRChcImlucHV0XCIsIHtcbiAgICAgICAgICAgIFwib25VcGRhdGU6bW9kZWxWYWx1ZVwiOiBjWzNdIHx8IChjWzNdID0gKHUpID0+IGEudmFsdWUgPSB1KSxcbiAgICAgICAgICAgIHR5cGU6IFwiY2hlY2tib3hcIlxuICAgICAgICAgIH0sIG51bGwsIDUxMiksIFtcbiAgICAgICAgICAgIFskZCwgYS52YWx1ZV1cbiAgICAgICAgICBdKSxcbiAgICAgICAgICBHWFxuICAgICAgICBdKSxcbiAgICAgICAgbC5yZXF1aXJlZCA/IHN0KFwiXCIsICEwKSA6IChaKCksIG5lKFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICBrZXk6IDAsXG4gICAgICAgICAgY2xhc3M6IFwibWV0YS1kZWxldGVcIixcbiAgICAgICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgICAgIG9uQ2xpY2s6IGNbNF0gfHwgKGNbNF0gPSAodSkgPT4gbC4kZW1pdChcImRlbGV0ZVwiKSlcbiAgICAgICAgfSwgSlgpKVxuICAgICAgXSksXG4gICAgICBfOiAxXG4gICAgfSwgOCwgW1wiY2xhc3NcIl0pKTtcbiAgfVxufSksIHQ4ID0gLyogQF9fUFVSRV9fICovIGN0KGU4LCBbW1wiX19zY29wZUlkXCIsIFwiZGF0YS12LWMwNDJiODM5XCJdXSksIG44ID0gKHQpID0+IChLcyhcImRhdGEtdi03OGJjZDkzZFwiKSwgdCA9IHQoKSwgSnMoKSwgdCksIHI4ID0gW1widmFsdWVcIl0sIGk4ID0gW1widmFsdWVcIl0sIHM4ID0gLyogQF9fUFVSRV9fICovIG44KCgpID0+IC8qIEBfX1BVUkVfXyAqLyBEKFwiaW5wdXRcIiwge1xuICBkaXNhYmxlZDogXCJcIixcbiAgdmFsdWU6IFwiUmVhZC1vbmx5XCJcbn0sIG51bGwsIC0xKSksIG84ID0gLyogQF9fUFVSRV9fICovIGxlKHtcbiAgX19uYW1lOiBcIkdyaWRSb3dHZW5lcmF0ZWRcIixcbiAgcHJvcHM6IHtcbiAgICBpdGVtOiB7fVxuICB9LFxuICBzZXR1cCh0KSB7XG4gICAgcmV0dXJuIChlLCBuKSA9PiAoWigpLCBrZShRZywgeyBjbGFzczogXCJ0YWJsZS1yb3ctZ2VuZXJhdGVkXCIgfSwge1xuICAgICAga2V5OiBjZSgoKSA9PiBbXG4gICAgICAgIEQoXCJpbnB1dFwiLCB7XG4gICAgICAgICAgZGlzYWJsZWQ6IFwiXCIsXG4gICAgICAgICAgcGxhY2Vob2xkZXI6IFwia2V5XCIsXG4gICAgICAgICAgdmFsdWU6IGUuaXRlbS5uYW1lXG4gICAgICAgIH0sIG51bGwsIDgsIHI4KVxuICAgICAgXSksXG4gICAgICB2YWx1ZTogY2UoKCkgPT4gW1xuICAgICAgICBEKFwiaW5wdXRcIiwge1xuICAgICAgICAgIGRpc2FibGVkOiBcIlwiLFxuICAgICAgICAgIHBsYWNlaG9sZGVyOiBcInZhbHVlXCIsXG4gICAgICAgICAgdHlwZTogXCJwYXNzd29yZFwiLFxuICAgICAgICAgIHZhbHVlOiBlLml0ZW0udmFsdWVcbiAgICAgICAgfSwgbnVsbCwgOCwgaTgpXG4gICAgICBdKSxcbiAgICAgIGRlc2NyaXB0aW9uOiBjZSgoKSA9PiBbXG4gICAgICAgIHM4XG4gICAgICBdKSxcbiAgICAgIF86IDFcbiAgICB9KSk7XG4gIH1cbn0pLCBhOCA9IC8qIEBfX1BVUkVfXyAqLyBjdChvOCwgW1tcIl9fc2NvcGVJZFwiLCBcImRhdGEtdi03OGJjZDkzZFwiXV0pLCBsOCA9IHsgY2xhc3M6IFwidGFibGVcIiB9LCBjOCA9IHsgY2xhc3M6IFwibWV0YS1hY3Rpb25zXCIgfSwgdTggPSB7IGNsYXNzOiBcIm1ldGEtYWN0aW9ucy1pdGVtLWljb25cIiB9LCBkOCA9IHsgY2xhc3M6IFwibWV0YS1hY3Rpb25zLWl0ZW0taWNvblwiIH0sIGY4ID0gLyogQF9fUFVSRV9fICovIGxlKHtcbiAgX19uYW1lOiBcIkdyaWRcIixcbiAgcHJvcHM6IHtcbiAgICBpdGVtczoge30sXG4gICAgZ2VuZXJhdGVkSXRlbXM6IHt9LFxuICAgIGFkZExhYmVsOiB7fSxcbiAgICBzaG93TW9yZUZpbHRlcjogeyB0eXBlOiBCb29sZWFuIH1cbiAgfSxcbiAgZW1pdHM6IFtcImRlbGV0ZUluZGV4XCIsIFwiYWRkQW5vdGhlclwiXSxcbiAgc2V0dXAodCwgeyBlbWl0OiBlIH0pIHtcbiAgICBjb25zdCBuID0gZSwgciA9IEcoITEpLCBpID0gRyghMSk7XG4gICAgZnVuY3Rpb24gcygpIHtcbiAgICAgIG4oXCJhZGRBbm90aGVyXCIpLCBpLnZhbHVlID0gITA7XG4gICAgfVxuICAgIHJldHVybiAobywgYSkgPT4gKFooKSwgbmUoXCJkaXZcIiwgbDgsIFtcbiAgICAgIEooSFgsIHtcbiAgICAgICAgc2hvd0Rlc2NyaXB0aW9uOiByLnZhbHVlLFxuICAgICAgICBcIm9uVXBkYXRlOnNob3dEZXNjcmlwdGlvblwiOiBhWzBdIHx8IChhWzBdID0gKGwpID0+IHIudmFsdWUgPSBsKVxuICAgICAgfSwgbnVsbCwgOCwgW1wic2hvd0Rlc2NyaXB0aW9uXCJdKSxcbiAgICAgIChaKCEwKSwgbmUoUGUsIG51bGwsIFhyKG8uZ2VuZXJhdGVkSXRlbXMsIChsKSA9PiAoWigpLCBrZShhOCwge1xuICAgICAgICBrZXk6IGwubmFtZSxcbiAgICAgICAgaXRlbTogbCxcbiAgICAgICAgc2hvd0Rlc2NyaXB0aW9uOiByLnZhbHVlLFxuICAgICAgICBvbkNsaWNrOiBhWzFdIHx8IChhWzFdID0gKGMpID0+IFIoa1ApLmVtaXQoKSlcbiAgICAgIH0sIG51bGwsIDgsIFtcIml0ZW1cIiwgXCJzaG93RGVzY3JpcHRpb25cIl0pKSksIDEyOCkpLFxuICAgICAgKFooITApLCBuZShQZSwgbnVsbCwgWHIoby5pdGVtcywgKGwsIGMpID0+IFhpKChaKCksIGtlKHQ4LCB7XG4gICAgICAgIGtleTogYyxcbiAgICAgICAgZGVzY3JpcHRpb246IGwuZGVzY3JpcHRpb24sXG4gICAgICAgIFwib25VcGRhdGU6ZGVzY3JpcHRpb25cIjogKHUpID0+IGwuZGVzY3JpcHRpb24gPSB1LFxuICAgICAgICBlbmFibGVkOiBsLmVuYWJsZWQsXG4gICAgICAgIFwib25VcGRhdGU6ZW5hYmxlZFwiOiAodSkgPT4gbC5lbmFibGVkID0gdSxcbiAgICAgICAgbmFtZTogbC5uYW1lLFxuICAgICAgICBcIm9uVXBkYXRlOm5hbWVcIjogKHUpID0+IGwubmFtZSA9IHUsXG4gICAgICAgIHZhbHVlOiBsLnZhbHVlLFxuICAgICAgICBcIm9uVXBkYXRlOnZhbHVlXCI6ICh1KSA9PiBsLnZhbHVlID0gdSxcbiAgICAgICAgcmVxdWlyZWQ6IGwucmVxdWlyZWQsXG4gICAgICAgIHNob3dEZXNjcmlwdGlvbjogci52YWx1ZSxcbiAgICAgICAgb25EZWxldGU6ICh1KSA9PiBvLiRlbWl0KFwiZGVsZXRlSW5kZXhcIiwgYylcbiAgICAgIH0sIG51bGwsIDgsIFtcImRlc2NyaXB0aW9uXCIsIFwib25VcGRhdGU6ZGVzY3JpcHRpb25cIiwgXCJlbmFibGVkXCIsIFwib25VcGRhdGU6ZW5hYmxlZFwiLCBcIm5hbWVcIiwgXCJvblVwZGF0ZTpuYW1lXCIsIFwidmFsdWVcIiwgXCJvblVwZGF0ZTp2YWx1ZVwiLCBcInJlcXVpcmVkXCIsIFwic2hvd0Rlc2NyaXB0aW9uXCIsIFwib25EZWxldGVcIl0pKSwgW1xuICAgICAgICBbamwsICFvLnNob3dNb3JlRmlsdGVyIHx8IG8uc2hvd01vcmVGaWx0ZXIgJiYgYyA8IDUgfHwgaS52YWx1ZV1cbiAgICAgIF0pKSwgMTI4KSksXG4gICAgICBEKFwiZGl2XCIsIGM4LCBbXG4gICAgICAgIG8uYWRkTGFiZWwgPyAoWigpLCBuZShcImJ1dHRvblwiLCB7XG4gICAgICAgICAga2V5OiAwLFxuICAgICAgICAgIGNsYXNzOiBcIm1ldGEtYWN0aW9ucy1pdGVtXCIsXG4gICAgICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgICAgICBvbkNsaWNrOiBzXG4gICAgICAgIH0sIFtcbiAgICAgICAgICBEKFwiaVwiLCB1OCwgW1xuICAgICAgICAgICAgSihSKF9sKSwgeyBpY29uOiBcIkFkZFwiIH0pXG4gICAgICAgICAgXSksXG4gICAgICAgICAgSGUoXCIgXCIgKyBEZShvLmFkZExhYmVsKSwgMSlcbiAgICAgICAgXSkpIDogc3QoXCJcIiwgITApLFxuICAgICAgICBvLnNob3dNb3JlRmlsdGVyICYmIG8uaXRlbXMgJiYgby5pdGVtcy5sZW5ndGggPiA1ICYmICFpLnZhbHVlID8gKFooKSwgbmUoXCJidXR0b25cIiwge1xuICAgICAgICAgIGtleTogMSxcbiAgICAgICAgICBjbGFzczogXCJtZXRhLWFjdGlvbnMtaXRlbVwiLFxuICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgICAgb25DbGljazogYVsyXSB8fCAoYVsyXSA9IChsKSA9PiBpLnZhbHVlID0gITApXG4gICAgICAgIH0sIFtcbiAgICAgICAgICBIZShcIiBTaG93IE1vcmUgXCIpLFxuICAgICAgICAgIEQoXCJpXCIsIGQ4LCBbXG4gICAgICAgICAgICBKKFIoX2wpLCB7IGljb246IFwiQ2hldnJvbkRvd25cIiB9KVxuICAgICAgICAgIF0pXG4gICAgICAgIF0pKSA6IHN0KFwiXCIsICEwKVxuICAgICAgXSlcbiAgICBdKSk7XG4gIH1cbn0pLCBuYyA9IC8qIEBfX1BVUkVfXyAqLyBjdChmOCwgW1tcIl9fc2NvcGVJZFwiLCBcImRhdGEtdi1hZjExMzhjOFwiXV0pLCBoOCA9IHsgY2xhc3M6IFwibmF2dGFibGUgc2ltcGxldGFibGVcIiB9LCBwOCA9IHsgY2xhc3M6IFwibmF2dGFibGUtdGFibGVcIiB9LCBPOCA9IC8qIEBfX1BVUkVfXyAqLyBXbCgnPGRpdiBjbGFzcz1cIm5hdnRhYmxlLWl0ZW0gbmF2dGFibGUtaXRlbV9fdG9wXCIgZGF0YS12LTViYTQwZTUyPjxkaXYgY2xhc3M9XCJuYXZ0YWJsZS1pdGVtLTMzXCIgZGF0YS12LTViYTQwZTUyPjxsYWJlbCBmb3I9XCJcIiBkYXRhLXYtNWJhNDBlNTI+TmFtZTwvbGFiZWw+PC9kaXY+PGRpdiBjbGFzcz1cIm5hdnRhYmxlLWl0ZW0tNjZcIiBkYXRhLXYtNWJhNDBlNTI+PGxhYmVsIGZvcj1cIlwiIGRhdGEtdi01YmE0MGU1Mj5WYWx1ZTwvbGFiZWw+PC9kaXY+PC9kaXY+JywgMSksIGc4ID0geyBjbGFzczogXCJuYXZ0YWJsZS1pdGVtLTMzXCIgfSwgbTggPSB7IGNsYXNzOiBcIm5hdnRhYmxlLWl0ZW0tNjZcIiB9LCBiOCA9IC8qIEBfX1BVUkVfXyAqLyBsZSh7XG4gIF9fbmFtZTogXCJTaW1wbGVHcmlkXCIsXG4gIHByb3BzOiB7XG4gICAgaXRlbXM6IHt9XG4gIH0sXG4gIHNldHVwKHQpIHtcbiAgICByZXR1cm4gKGUsIG4pID0+IChaKCksIG5lKFwiZGl2XCIsIGg4LCBbXG4gICAgICBEKFwiZGl2XCIsIHA4LCBbXG4gICAgICAgIE84LFxuICAgICAgICAoWighMCksIG5lKFBlLCBudWxsLCBYcihlLml0ZW1zLCAocikgPT4gKFooKSwgbmUoXCJkaXZcIiwge1xuICAgICAgICAgIGtleTogci5pZCxcbiAgICAgICAgICBjbGFzczogXCJuYXZ0YWJsZS1pdGVtXCJcbiAgICAgICAgfSwgW1xuICAgICAgICAgIEQoXCJkaXZcIiwgZzgsIFtcbiAgICAgICAgICAgIEQoXCJwXCIsIG51bGwsIERlKHIubmFtZSksIDEpXG4gICAgICAgICAgXSksXG4gICAgICAgICAgRChcImRpdlwiLCBtOCwgW1xuICAgICAgICAgICAgRChcInBcIiwgbnVsbCwgRGUoci52YWx1ZSksIDEpXG4gICAgICAgICAgXSlcbiAgICAgICAgXSkpKSwgMTI4KSlcbiAgICAgIF0pXG4gICAgXSkpO1xuICB9XG59KSwgdjggPSAvKiBAX19QVVJFX18gKi8gY3QoYjgsIFtbXCJfX3Njb3BlSWRcIiwgXCJkYXRhLXYtNWJhNDBlNTJcIl1dKSwgeTggPSB7IGtleTogMCB9LCBTOCA9IC8qIEBfX1BVUkVfXyAqLyBsZSh7XG4gIF9fbmFtZTogXCJSZXF1ZXN0Qm9keVwiLFxuICBwcm9wczoge1xuICAgIGJvZHk6IHt9LFxuICAgIGZvcm1EYXRhOiB7fVxuICB9LFxuICBzZXR1cCh0KSB7XG4gICAgY29uc3QgeyBhY3RpdmVSZXF1ZXN0OiBlLCBzZXRBY3RpdmVSZXF1ZXN0OiBuIH0gPSBzcigpLCByID0gKGkpID0+IHtcbiAgICAgIGUuYm9keSAhPT0gaSAmJiBuKHtcbiAgICAgICAgLi4uZSxcbiAgICAgICAgYm9keTogaVxuICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gKGksIHMpID0+IChaKCksIGtlKFIoYmkpLCB7IHRpdGxlOiBcIkJvZHlcIiB9LCB7XG4gICAgICBkZWZhdWx0OiBjZSgoKSA9PiBbXG4gICAgICAgIGkuYm9keSAmJiBpLmJvZHkubGVuZ3RoID09PSAwICYmIGkuZm9ybURhdGEgJiYgaS5mb3JtRGF0YS5sZW5ndGggPT09IDAgPyAoWigpLCBuZShcInNwYW5cIiwgeTgsIFwiTm8gQm9keVwiKSkgOiBpLmZvcm1EYXRhICYmIGkuZm9ybURhdGEubGVuZ3RoID4gMCA/IChaKCksIGtlKFIobmMpLCB7XG4gICAgICAgICAga2V5OiAxLFxuICAgICAgICAgIGl0ZW1zOiBpLmZvcm1EYXRhXG4gICAgICAgIH0sIG51bGwsIDgsIFtcIml0ZW1zXCJdKSkgOiAoWigpLCBrZShSKFNQKSwge1xuICAgICAgICAgIGtleTogMixcbiAgICAgICAgICBjb250ZW50OiBSKGUpLmJvZHksXG4gICAgICAgICAgbGFuZ3VhZ2U6IFwianNvblwiLFxuICAgICAgICAgIGxpbmVOdW1iZXJzOiBcIlwiLFxuICAgICAgICAgIG9uQ2hhbmdlOiByXG4gICAgICAgIH0sIG51bGwsIDgsIFtcImNvbnRlbnRcIl0pKVxuICAgICAgXSksXG4gICAgICBfOiAxXG4gICAgfSkpO1xuICB9XG59KSwgdzggPSB7XG4gIGtleTogMCxcbiAgY2xhc3M6IFwic2NhbGFyLWFwaS1jbGllbnRfX2VtcHR5LXN0YXRlXCJcbn0sIGs4ID0gLyogQF9fUFVSRV9fICovIEQoXCJzdmdcIiwge1xuICBjbGFzczogXCJmbG93LWljb25cIixcbiAgXCJkYXRhLXYtYWE0ZmJkMmRcIjogXCJcIixcbiAgaGVpZ2h0OiBcIjEwMCVcIixcbiAgdmlld0JveDogXCIwIDAgNDggNDhcIixcbiAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxufSwgW1xuICAvKiBAX19QVVJFX18gKi8gRChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTI0IDEuNzE0djQ0LjU3Mk0xLjcxNCAyNGg0NC41NzJcIixcbiAgICBmaWxsOiBcIm5vbmVcIixcbiAgICBzdHJva2U6IFwiY3VycmVudENvbG9yXCIsXG4gICAgXCJzdHJva2UtbGluZWNhcFwiOiBcInJvdW5kXCIsXG4gICAgXCJzdHJva2UtbGluZWpvaW5cIjogXCJyb3VuZFwiLFxuICAgIFwic3Ryb2tlLXdpZHRoXCI6IFwiMy40MjlcIixcbiAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gIH0pXG5dLCAtMSksIHg4ID0gLyogQF9fUFVSRV9fICovIGxlKHtcbiAgX19uYW1lOiBcIlJlcXVlc3RDb29raWVzXCIsXG4gIHByb3BzOiB7XG4gICAgY29va2llczoge30sXG4gICAgZ2VuZXJhdGVkQ29va2llczoge31cbiAgfSxcbiAgc2V0dXAodCkge1xuICAgIGNvbnN0IGUgPSB0LCB7IGFjdGl2ZVJlcXVlc3Q6IG4gfSA9IHNyKCk7XG4gICAgZnVuY3Rpb24gcihvKSB7XG4gICAgICB2YXIgYTtcbiAgICAgIChhID0gbi5jb29raWVzKSA9PSBudWxsIHx8IGEuc3BsaWNlKG8sIDEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpKCkge1xuICAgICAgdmFyIG87XG4gICAgICBuLmNvb2tpZXMgPT09IHZvaWQgMCAmJiAobi5jb29raWVzID0gW10pLCAobyA9IG4uY29va2llcykgPT0gbnVsbCB8fCBvLnB1c2goeyBuYW1lOiBcIlwiLCB2YWx1ZTogXCJcIiwgZW5hYmxlZDogITAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHMgPSBqKCgpID0+IHtcbiAgICAgIHZhciBvLCBhO1xuICAgICAgcmV0dXJuICEhKChvID0gZS5jb29raWVzKSAhPSBudWxsICYmIG8ubGVuZ3RoIHx8IChhID0gZS5nZW5lcmF0ZWRDb29raWVzKSAhPSBudWxsICYmIGEubGVuZ3RoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gKG8sIGEpID0+IChaKCksIGtlKFIoYmkpLCB7XG4gICAgICBkZWZhdWx0T3Blbjogcy52YWx1ZSxcbiAgICAgIHRpdGxlOiBcIkNvb2tpZXNcIlxuICAgIH0sIHtcbiAgICAgIGRlZmF1bHQ6IGNlKCgpID0+IFtcbiAgICAgICAgcy52YWx1ZSA/IChaKCksIGtlKFIobmMpLCB7XG4gICAgICAgICAga2V5OiAxLFxuICAgICAgICAgIGFkZExhYmVsOiBcIkNvb2tpZVwiLFxuICAgICAgICAgIGdlbmVyYXRlZEl0ZW1zOiBvLmdlbmVyYXRlZENvb2tpZXMsXG4gICAgICAgICAgaXRlbXM6IG8uY29va2llcyxcbiAgICAgICAgICBvbkFkZEFub3RoZXI6IGksXG4gICAgICAgICAgb25EZWxldGVJbmRleDogclxuICAgICAgICB9LCBudWxsLCA4LCBbXCJnZW5lcmF0ZWRJdGVtc1wiLCBcIml0ZW1zXCJdKSkgOiAoWigpLCBuZShcImRpdlwiLCB3OCwgW1xuICAgICAgICAgIEQoXCJidXR0b25cIiwge1xuICAgICAgICAgICAgY2xhc3M6IFwic2NhbGFyLWFwaS1jbGllbnQtYWRkXCIsXG4gICAgICAgICAgICB0eXBlOiBcImJ1dHRvblwiLFxuICAgICAgICAgICAgb25DbGljazogaVxuICAgICAgICAgIH0sIFtcbiAgICAgICAgICAgIGs4LFxuICAgICAgICAgICAgSGUoXCIgQ29va2llcyBcIilcbiAgICAgICAgICBdKVxuICAgICAgICBdKSlcbiAgICAgIF0pLFxuICAgICAgXzogMVxuICAgIH0sIDgsIFtcImRlZmF1bHRPcGVuXCJdKSk7XG4gIH1cbn0pLCBQOCA9IHtcbiAga2V5OiAwLFxuICBjbGFzczogXCJzY2FsYXItYXBpLWNsaWVudF9fZW1wdHktc3RhdGVcIlxufSwgXzggPSAvKiBAX19QVVJFX18gKi8gRChcInN2Z1wiLCB7XG4gIGNsYXNzOiBcImZsb3ctaWNvblwiLFxuICBcImRhdGEtdi1hYTRmYmQyZFwiOiBcIlwiLFxuICBoZWlnaHQ6IFwiMTAwJVwiLFxuICB2aWV3Qm94OiBcIjAgMCA0OCA0OFwiLFxuICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG59LCBbXG4gIC8qIEBfX1BVUkVfXyAqLyBEKFwicGF0aFwiLCB7XG4gICAgZDogXCJNMjQgMS43MTR2NDQuNTcyTTEuNzE0IDI0aDQ0LjU3MlwiLFxuICAgIGZpbGw6IFwibm9uZVwiLFxuICAgIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIixcbiAgICBcInN0cm9rZS1saW5lY2FwXCI6IFwicm91bmRcIixcbiAgICBcInN0cm9rZS1saW5lam9pblwiOiBcInJvdW5kXCIsXG4gICAgXCJzdHJva2Utd2lkdGhcIjogXCIzLjQyOVwiLFxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgfSlcbl0sIC0xKSwgVDggPSAvKiBAX19QVVJFX18gKi8gbGUoe1xuICBfX25hbWU6IFwiUmVxdWVzdEhlYWRlcnNcIixcbiAgcHJvcHM6IHtcbiAgICBoZWFkZXJzOiB7fSxcbiAgICBnZW5lcmF0ZWRIZWFkZXJzOiB7fVxuICB9LFxuICBzZXR1cCh0KSB7XG4gICAgY29uc3QgZSA9IHQsIHsgYWN0aXZlUmVxdWVzdDogbiB9ID0gc3IoKTtcbiAgICBmdW5jdGlvbiByKG8pIHtcbiAgICAgIHZhciBhO1xuICAgICAgKGEgPSBuLmhlYWRlcnMpID09IG51bGwgfHwgYS5zcGxpY2UobywgMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGkoKSB7XG4gICAgICB2YXIgbztcbiAgICAgIG4uaGVhZGVycyA9PT0gdm9pZCAwICYmIChuLmhlYWRlcnMgPSBbXSksIChvID0gbi5oZWFkZXJzKSA9PSBudWxsIHx8IG8ucHVzaCh7IG5hbWU6IFwiXCIsIHZhbHVlOiBcIlwiLCBlbmFibGVkOiAhMCB9KTtcbiAgICB9XG4gICAgY29uc3QgcyA9IGooKCkgPT4ge1xuICAgICAgdmFyIG8sIGE7XG4gICAgICByZXR1cm4gISEoKG8gPSBlLmhlYWRlcnMpICE9IG51bGwgJiYgby5sZW5ndGggfHwgKGEgPSBlLmdlbmVyYXRlZEhlYWRlcnMpICE9IG51bGwgJiYgYS5sZW5ndGgpO1xuICAgIH0pO1xuICAgIHJldHVybiAobywgYSkgPT4gKFooKSwga2UoUihiaSksIHtcbiAgICAgIGRlZmF1bHRPcGVuOiBzLnZhbHVlLFxuICAgICAgdGl0bGU6IFwiSGVhZGVyc1wiXG4gICAgfSwge1xuICAgICAgZGVmYXVsdDogY2UoKCkgPT4gW1xuICAgICAgICBzLnZhbHVlID8gKFooKSwga2UoUihuYyksIHtcbiAgICAgICAgICBrZXk6IDEsXG4gICAgICAgICAgYWRkTGFiZWw6IFwiSGVhZGVyXCIsXG4gICAgICAgICAgZ2VuZXJhdGVkSXRlbXM6IG8uZ2VuZXJhdGVkSGVhZGVycyxcbiAgICAgICAgICBpdGVtczogby5oZWFkZXJzLFxuICAgICAgICAgIG9uQWRkQW5vdGhlcjogaSxcbiAgICAgICAgICBvbkRlbGV0ZUluZGV4OiByXG4gICAgICAgIH0sIG51bGwsIDgsIFtcImdlbmVyYXRlZEl0ZW1zXCIsIFwiaXRlbXNcIl0pKSA6IChaKCksIG5lKFwiZGl2XCIsIFA4LCBbXG4gICAgICAgICAgRChcImJ1dHRvblwiLCB7XG4gICAgICAgICAgICBjbGFzczogXCJzY2FsYXItYXBpLWNsaWVudC1hZGRcIixcbiAgICAgICAgICAgIHR5cGU6IFwiYnV0dG9uXCIsXG4gICAgICAgICAgICBvbkNsaWNrOiBpXG4gICAgICAgICAgfSwgW1xuICAgICAgICAgICAgXzgsXG4gICAgICAgICAgICBIZShcIiBIZWFkZXJzIFwiKVxuICAgICAgICAgIF0pXG4gICAgICAgIF0pKVxuICAgICAgXSksXG4gICAgICBfOiAxXG4gICAgfSwgOCwgW1wiZGVmYXVsdE9wZW5cIl0pKTtcbiAgfVxufSksIEU4ID0ge1xuICBrZXk6IDAsXG4gIGNsYXNzOiBcInNjYWxhci1hcGktY2xpZW50X19lbXB0eS1zdGF0ZVwiXG59LCAkOCA9IC8qIEBfX1BVUkVfXyAqLyBEKFwic3ZnXCIsIHtcbiAgY2xhc3M6IFwiZmxvdy1pY29uXCIsXG4gIFwiZGF0YS12LWFhNGZiZDJkXCI6IFwiXCIsXG4gIGhlaWdodDogXCIxMDAlXCIsXG4gIHZpZXdCb3g6IFwiMCAwIDQ4IDQ4XCIsXG4gIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbn0sIFtcbiAgLyogQF9fUFVSRV9fICovIEQoXCJwYXRoXCIsIHtcbiAgICBkOiBcIk0yNCAxLjcxNHY0NC41NzJNMS43MTQgMjRoNDQuNTcyXCIsXG4gICAgZmlsbDogXCJub25lXCIsXG4gICAgc3Ryb2tlOiBcImN1cnJlbnRDb2xvclwiLFxuICAgIFwic3Ryb2tlLWxpbmVjYXBcIjogXCJyb3VuZFwiLFxuICAgIFwic3Ryb2tlLWxpbmVqb2luXCI6IFwicm91bmRcIixcbiAgICBcInN0cm9rZS13aWR0aFwiOiBcIjMuNDI5XCIsXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICB9KVxuXSwgLTEpLCBROCA9IC8qIEBfX1BVUkVfXyAqLyBsZSh7XG4gIF9fbmFtZTogXCJSZXF1ZXN0UXVlcnlcIixcbiAgcHJvcHM6IHtcbiAgICBxdWVyaWVzOiB7fSxcbiAgICBnZW5lcmF0ZWRRdWVyaWVzOiB7fVxuICB9LFxuICBzZXR1cCh0KSB7XG4gICAgY29uc3QgZSA9IHQsIHsgYWN0aXZlUmVxdWVzdDogbiB9ID0gc3IoKTtcbiAgICBmdW5jdGlvbiByKG8pIHtcbiAgICAgIHZhciBhO1xuICAgICAgKGEgPSBuLnF1ZXJ5KSA9PSBudWxsIHx8IGEuc3BsaWNlKG8sIDEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpKCkge1xuICAgICAgdmFyIG87XG4gICAgICBuLnF1ZXJ5ID09PSB2b2lkIDAgJiYgKG4ucXVlcnkgPSBbXSksIChvID0gbi5xdWVyeSkgPT0gbnVsbCB8fCBvLnB1c2goeyBuYW1lOiBcIlwiLCB2YWx1ZTogXCJcIiwgZW5hYmxlZDogITAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHMgPSBqKCgpID0+IHtcbiAgICAgIHZhciBvLCBhO1xuICAgICAgcmV0dXJuICEhKChvID0gZS5xdWVyaWVzKSAhPSBudWxsICYmIG8ubGVuZ3RoIHx8IChhID0gZS5nZW5lcmF0ZWRRdWVyaWVzKSAhPSBudWxsICYmIGEubGVuZ3RoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gKG8sIGEpID0+IChaKCksIGtlKFIoYmkpLCB7XG4gICAgICBkZWZhdWx0T3Blbjogcy52YWx1ZSxcbiAgICAgIHRpdGxlOiBcIlF1ZXJ5IFBhcmFtZXRlcnNcIlxuICAgIH0sIHtcbiAgICAgIGRlZmF1bHQ6IGNlKCgpID0+IFtcbiAgICAgICAgcy52YWx1ZSA/IChaKCksIGtlKFIobmMpLCB7XG4gICAgICAgICAga2V5OiAxLFxuICAgICAgICAgIGFkZExhYmVsOiBcIlF1ZXJ5IFBhcmFtZXRlclwiLFxuICAgICAgICAgIGdlbmVyYXRlZEl0ZW1zOiBvLmdlbmVyYXRlZFF1ZXJpZXMsXG4gICAgICAgICAgaXRlbXM6IG8ucXVlcmllcyxcbiAgICAgICAgICBzaG93TW9yZUZpbHRlcjogITAsXG4gICAgICAgICAgb25BZGRBbm90aGVyOiBpLFxuICAgICAgICAgIG9uRGVsZXRlSW5kZXg6IHJcbiAgICAgICAgfSwgbnVsbCwgOCwgW1wiZ2VuZXJhdGVkSXRlbXNcIiwgXCJpdGVtc1wiXSkpIDogKFooKSwgbmUoXCJkaXZcIiwgRTgsIFtcbiAgICAgICAgICBEKFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICAgIGNsYXNzOiBcInNjYWxhci1hcGktY2xpZW50LWFkZFwiLFxuICAgICAgICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgICAgICAgIG9uQ2xpY2s6IGlcbiAgICAgICAgICB9LCBbXG4gICAgICAgICAgICAkOCxcbiAgICAgICAgICAgIEhlKFwiIFF1ZXJ5IFBhcmFtZXRlciBcIilcbiAgICAgICAgICBdKVxuICAgICAgICBdKSlcbiAgICAgIF0pLFxuICAgICAgXzogMVxuICAgIH0sIDgsIFtcImRlZmF1bHRPcGVuXCJdKSk7XG4gIH1cbn0pLCBDOCA9IHtcbiAga2V5OiAwLFxuICBjbGFzczogXCJzY2FsYXItYXBpLWNsaWVudF9fZW1wdHktc3RhdGVcIlxufSwgQTggPSAvKiBAX19QVVJFX18gKi8gRChcInN2Z1wiLCB7XG4gIGNsYXNzOiBcImZsb3ctaWNvblwiLFxuICBcImRhdGEtdi1hYTRmYmQyZFwiOiBcIlwiLFxuICBoZWlnaHQ6IFwiMTAwJVwiLFxuICB2aWV3Qm94OiBcIjAgMCA0OCA0OFwiLFxuICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG59LCBbXG4gIC8qIEBfX1BVUkVfXyAqLyBEKFwicGF0aFwiLCB7XG4gICAgZDogXCJNMjQgMS43MTR2NDQuNTcyTTEuNzE0IDI0aDQ0LjU3MlwiLFxuICAgIGZpbGw6IFwibm9uZVwiLFxuICAgIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIixcbiAgICBcInN0cm9rZS1saW5lY2FwXCI6IFwicm91bmRcIixcbiAgICBcInN0cm9rZS1saW5lam9pblwiOiBcInJvdW5kXCIsXG4gICAgXCJzdHJva2Utd2lkdGhcIjogXCIzLjQyOVwiLFxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgfSlcbl0sIC0xKSwgUjggPSAvKiBAX19QVVJFX18gKi8gbGUoe1xuICBfX25hbWU6IFwiUmVxdWVzdFZhcmlhYmxlc1wiLFxuICBwcm9wczoge1xuICAgIHZhcmlhYmxlczoge31cbiAgfSxcbiAgc2V0dXAodCkge1xuICAgIGNvbnN0IHsgYWN0aXZlUmVxdWVzdDogZSB9ID0gc3IoKTtcbiAgICBmdW5jdGlvbiBuKGkpIHtcbiAgICAgIHZhciBzO1xuICAgICAgKHMgPSBlLnZhcmlhYmxlcykgPT0gbnVsbCB8fCBzLnNwbGljZShpLCAxKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcigpIHtcbiAgICAgIHZhciBpO1xuICAgICAgZS52YXJpYWJsZXMgPT09IHZvaWQgMCAmJiAoZS52YXJpYWJsZXMgPSBbXSksIChpID0gZS52YXJpYWJsZXMpID09IG51bGwgfHwgaS5wdXNoKHsgbmFtZTogXCJcIiwgdmFsdWU6IFwiXCIsIGVuYWJsZWQ6ICEwIH0pO1xuICAgIH1cbiAgICByZXR1cm4gKGksIHMpID0+IChaKCksIGtlKFIoYmkpLCB7XG4gICAgICBkZWZhdWx0T3BlbjogUihlKS52YXJpYWJsZXMgJiYgUihlKS52YXJpYWJsZXMubGVuZ3RoID4gMCxcbiAgICAgIHRpdGxlOiBcIlZhcmlhYmxlc1wiXG4gICAgfSwge1xuICAgICAgZGVmYXVsdDogY2UoKCkgPT4gW1xuICAgICAgICAhaS52YXJpYWJsZXMgfHwgaS52YXJpYWJsZXMubGVuZ3RoID09PSAwID8gKFooKSwgbmUoXCJkaXZcIiwgQzgsIFtcbiAgICAgICAgICBEKFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICAgIGNsYXNzOiBcInNjYWxhci1hcGktY2xpZW50LWFkZFwiLFxuICAgICAgICAgICAgdHlwZTogXCJidXR0b25cIixcbiAgICAgICAgICAgIG9uQ2xpY2s6IHJcbiAgICAgICAgICB9LCBbXG4gICAgICAgICAgICBBOCxcbiAgICAgICAgICAgIEhlKFwiIFZhcmlhYmxlIFwiKVxuICAgICAgICAgIF0pXG4gICAgICAgIF0pKSA6IChaKCksIGtlKFIobmMpLCB7XG4gICAgICAgICAga2V5OiAxLFxuICAgICAgICAgIGFkZExhYmVsOiBcIlZhcmlhYmxlXCIsXG4gICAgICAgICAgaXRlbXM6IGkudmFyaWFibGVzLFxuICAgICAgICAgIHNob3dNb3JlRmlsdGVyOiAhMCxcbiAgICAgICAgICBvbkFkZEFub3RoZXI6IHIsXG4gICAgICAgICAgb25EZWxldGVJbmRleDogblxuICAgICAgICB9LCBudWxsLCA4LCBbXCJpdGVtc1wiXSkpXG4gICAgICBdKSxcbiAgICAgIF86IDFcbiAgICB9LCA4LCBbXCJkZWZhdWx0T3BlblwiXSkpO1xuICB9XG59KSwgTjggPSB7IGNsYXNzOiBcInNjYWxhci1hcGktY2xpZW50X19tYWluX19sZWZ0IGN1c3RvbS1zY3JvbGxcIiB9LCBEOCA9IHsgY2xhc3M6IFwic2NhbGFyLWFwaS1jbGllbnRfX21haW5fX2NvbnRlbnRcIiB9LCBaOCA9IHsgY2xhc3M6IFwic2NhbGFyLWFwaS1jbGllbnRfX21haW5fX2NvbnRlbnRfX2hlYWRlclwiIH0sIFY4ID0gLyogQF9fUFVSRV9fICovIEQoXCJsYWJlbFwiLCBudWxsLCBcIlJlcXVlc3RcIiwgLTEpLCBJOCA9IHsgY2xhc3M6IFwibWV0YVwiIH0sIFc4ID0geyBjbGFzczogXCJtZXRhLWl0ZW0gbWV0YS1pdGVtX19pbnB1dFwiIH0sIE04ID0geyBjbGFzczogXCJzY2FsYXItYXBpLWNsaWVudF9fbWFpbl9fY29udGVudF9fYm9keVwiIH0sIFg4ID0gLyogQF9fUFVSRV9fICovIEQoXCJkaXZcIiwgeyBjbGFzczogXCJzY2FsYXItYXBpLWNsaWVudF9fbWFpbl9fc2Nyb2xsLWNvbnRhaW5lclwiIH0sIG51bGwsIC0xKSwgajggPSAhMCwgQjAgPSAvKiBAX19QVVJFX18gKi8gbGUoe1xuICBfX25hbWU6IFwiUmVxdWVzdFwiLFxuICBzZXR1cCh0KSB7XG4gICAgY29uc3QgeyBhY3RpdmVSZXF1ZXN0OiBlIH0gPSBzcigpLCB7IGF1dGhlbnRpY2F0aW9uOiBuIH0gPSBZbCgpLCB7XG4gICAgICBvcGVuQXBpOiB7IG9wZXJhdGlvbjogciwgZ2xvYmFsU2VjdXJpdHk6IGkgfVxuICAgIH0gPSBDdygpLCBzID0gaihcbiAgICAgICgpID0+IHtcbiAgICAgICAgdmFyIGE7XG4gICAgICAgIHJldHVybiB3UChcbiAgICAgICAgICBuLFxuICAgICAgICAgICgoYSA9IHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIuaW5mb3JtYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBhLnNlY3VyaXR5KSA/PyBpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgKSwgbyA9IGooKCkgPT4ge1xuICAgICAgY29uc3QgYSA9IGUudHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgcmV0dXJuIGEgPT09IFwicHV0XCIgfHwgYSA9PT0gXCJwb3N0XCIgfHwgYSA9PT0gXCJwYXRjaFwiO1xuICAgIH0pO1xuICAgIHJldHVybiAoYSwgbCkgPT4gKFooKSwgbmUoXCJkaXZcIiwgTjgsIFtcbiAgICAgIEQoXCJkaXZcIiwgRDgsIFtcbiAgICAgICAgRChcImRpdlwiLCBaOCwgW1xuICAgICAgICAgIFY4LFxuICAgICAgICAgIEQoXCJkaXZcIiwgSTgsIFtcbiAgICAgICAgICAgIEQoXCJkaXZcIiwgVzgsIFtcbiAgICAgICAgICAgICAgWGkoRChcImlucHV0XCIsIHtcbiAgICAgICAgICAgICAgICBcIm9uVXBkYXRlOm1vZGVsVmFsdWVcIjogbFswXSB8fCAobFswXSA9IChjKSA9PiBSKGUpLm5hbWUgPSBjKSxcbiAgICAgICAgICAgICAgICBjbGFzczogXCJzY2FsYXItYXBpLWNsaWVudF9fcmVxdWVzdC1uYW1lXCIsXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ6IGo4LFxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiBcIlJlcXVlc3QgTmFtZVwiLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiXG4gICAgICAgICAgICAgIH0sIG51bGwsIDUxMiksIFtcbiAgICAgICAgICAgICAgICBbR2ksIFIoZSkubmFtZV1cbiAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgXSlcbiAgICAgICAgXSksXG4gICAgICAgIEQoXCJkaXZcIiwgTTgsIFtcbiAgICAgICAgICBKKFI4LCB7XG4gICAgICAgICAgICB2YXJpYWJsZXM6IFIoZSkudmFyaWFibGVzXG4gICAgICAgICAgfSwgbnVsbCwgOCwgW1widmFyaWFibGVzXCJdKSxcbiAgICAgICAgICBKKFIoVlgpKSxcbiAgICAgICAgICBKKHg4LCB7XG4gICAgICAgICAgICBjb29raWVzOiBSKGUpLmNvb2tpZXMsXG4gICAgICAgICAgICBnZW5lcmF0ZWRDb29raWVzOiBzLnZhbHVlLmNvb2tpZXNcbiAgICAgICAgICB9LCBudWxsLCA4LCBbXCJjb29raWVzXCIsIFwiZ2VuZXJhdGVkQ29va2llc1wiXSksXG4gICAgICAgICAgSihUOCwge1xuICAgICAgICAgICAgZ2VuZXJhdGVkSGVhZGVyczogcy52YWx1ZS5oZWFkZXJzLFxuICAgICAgICAgICAgaGVhZGVyczogUihlKS5oZWFkZXJzXG4gICAgICAgICAgfSwgbnVsbCwgOCwgW1wiZ2VuZXJhdGVkSGVhZGVyc1wiLCBcImhlYWRlcnNcIl0pLFxuICAgICAgICAgIEooUTgsIHtcbiAgICAgICAgICAgIGdlbmVyYXRlZFF1ZXJpZXM6IHMudmFsdWUucXVlcnlTdHJpbmcsXG4gICAgICAgICAgICBxdWVyaWVzOiBSKGUpLnF1ZXJ5XG4gICAgICAgICAgfSwgbnVsbCwgOCwgW1wiZ2VuZXJhdGVkUXVlcmllc1wiLCBcInF1ZXJpZXNcIl0pLFxuICAgICAgICAgIG8udmFsdWUgPyAoWigpLCBrZShTOCwge1xuICAgICAgICAgICAga2V5OiAwLFxuICAgICAgICAgICAgYm9keTogUihlKS5ib2R5LFxuICAgICAgICAgICAgZm9ybURhdGE6IFIoZSkuZm9ybURhdGEsXG4gICAgICAgICAgICByZXF1ZXN0Qm9keTogUihlKS5ib2R5XG4gICAgICAgICAgfSwgbnVsbCwgOCwgW1wiYm9keVwiLCBcImZvcm1EYXRhXCIsIFwicmVxdWVzdEJvZHlcIl0pKSA6IHN0KFwiXCIsICEwKSxcbiAgICAgICAgICBYOFxuICAgICAgICBdKVxuICAgICAgXSlcbiAgICBdKSk7XG4gIH1cbn0pLCBCOCA9IGAgICAgICAgICAgICAgICAgICAgICAgICAgLiwsdW9kOEI4Ym91LCwuXG4gICAgICAgICAgICAgICAgLi4sdW9kOEJCQkJCQkJCQkJCQkJCQkJSUEZUP2whaTouXG4gICAgICAgICAgIHx8fHx8fHx8fHx8fHx8IT9URlBSQkJCQkJCQkJCQkJCQkJCOG09LFxuICAgICAgICAgICB8fHx8ICAgJ1wiXCJeXiEhfHx8fHx8fHx8fFRGUFJCQkJWVCE6Li4uIVxuICAgICAgICAgICB8fHx8ICAgICAgICAgICAgJ1wiXCJeXiEhfHx8fHw/ITouLi4uLi4uIVxuICAgICAgICAgICB8fHx8ICAgICAgICAgICAgICAgICAgICAgfHx8fC4uLi4uLi4uLiFcbiAgICAgICAgICAgfHx8fCAgICAgICAgICAgICAgICAgICAgIHx8fHwuLi4uLi4uLi4hXG4gICAgICAgICAgIHx8fHwgICAgICAgICAgICAgICAgICAgICB8fHx8Li4uLi4uLi4uIVxuICAgICAgICAgICB8fHx8ICAgICAgICAgICAgICAgICAgICAgfHx8fC4uLi4uLi4uLiFcbiAgICAgICAgICAgfHx8fCAgICAgICAgICAgICAgICAgICAgIHx8fHwuLi4uLi4uLi4hXG4gICAgICAgICAgIHx8fHwgICAgICAgICAgICAgICAgICAgICB8fHx8Li4uLi4uLi4uIVxuICAgICAgICAgICB8fHx8LCAgICAgICAgICAgICAgICAgICAgfHx8fC4uLi4uLi4uLlxcYFxuICAgICAgICAgICB8fHx8fCEhLS5fICAgICAgICAgICAgICAgfHx8fC4uLi4uLi47LlxuICAgICAgICAgICAnOiF8fHx8fHx8fHwhIS0uXyAgICAgICAgfHx8fC4uLi4uYkJCQkJXZG91LC5cbiAgICAgICAgIGJCQkJCQjg2Zm9pIXx8fHx8fHwhIS0uLjp8fHwhLi5iQkJCQkJCQkJCQkJCQkJZIVxuICAgICAgICAgOjohP1RGUFJCQkJCQkI4NmZvaSF8fHx8fHx8fCEhYkJCQkJCQkJCQkJCQkJCWS4uIVxuICAgICAgICAgOjo6Ojo6Ojo6IT9URlBSQkJCQkJCODZmdGlhYWJCQkJCQkJCQkJCQkJCQlkuLi4uIVxuICAgICAgICAgOjo6O1xcYFwiXiE6Ozo6Ojo6OiE/VEZQUkJCQkJCQkJCQkJCQkJCQkJCQkJZLi4uLi4uIVxuICAgICAgICAgOzo6Ojo6Oi4uLicnXjo6Ojo6Ojo6OjohP1RGUFJCQkJCQkJCQkJCWS4uLi4uLi4uIVxuICAgICAub2I4NmZvaTs6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6OjohP1RGUFJCWS4uLi4uLi4uLi5cXGBcbiAgICAuYjg4ODg4ODg4ODg4NmZvaTs6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Ojo6Oi4uLi4uLi4uLi5cXGBcbiAuYjg4ODg4ODg4ODg4ODg4ODg4ODg4NmZvaTs6Ojo6Ojo6Ojo6Ojo6Ojo6Li4uLi4uLi4uLlxuLmI4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODZmb2k7Ojo6Ojo6Ojo6Li4uLi4uXFxgXG4hVGY5OTg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODZmb2k7Ojo6Li4uLlxcYFxuICAnXCJeIXxUZjk5ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODghOjouLlxcYFxuICAgICAgICdcIl4hfFRmOTk4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg5ISEgJ1xcYFxuICAgICAgICAgICAgICdcIl4hfFRmOTk4ODg4ODg4ODg4ODg4ODg4OCEhXFxgICAgICAgICAgICAgaUJCYm8uXG4gICAgICAgICAgICAgICAgICAnXCJeIXxUZjk5ODg4ODg4ODg4OSFcXGAgICAgICAgICAgICAgV0JCQkJiby5cbiAgICAgICAgICAgICAgICAgICAgICAgICdcIl4hfFRmOTk4OSFcXGAgICAgICAgICAgICAgIFlCQkJQXidcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcIl4hXFxgICAgICAgICAgICAgICAgXFxgXG5gLCBMOCA9IHsgY2xhc3M6IFwiYXNjaWktYXJ0XCIgfSwgVTggPSB7IGNsYXNzOiBcImFzY2lpLWFydC1saW5lXCIgfSwgcTggPSAvKiBAX19QVVJFX18gKi8gbGUoe1xuICBfX25hbWU6IFwiU2NhbGFyQXNjaWlBcnRcIixcbiAgcHJvcHM6IHtcbiAgICBhcnQ6IHt9XG4gIH0sXG4gIHNldHVwKHQpIHtcbiAgICBjb25zdCBlID0gdCwgbiA9IGooKCkgPT4gZS5hcnQuc3BsaXQoYFxuYCkpO1xuICAgIHJldHVybiAociwgaSkgPT4gKFooKSwgbmUoXCJkaXZcIiwgTDgsIFtcbiAgICAgIChaKCEwKSwgbmUoUGUsIG51bGwsIFhyKG4udmFsdWUsIChzLCBvKSA9PiAoWigpLCBuZShcInNwYW5cIiwge1xuICAgICAgICBrZXk6IG8sXG4gICAgICAgIGNsYXNzOiBcImFzY2lpLWFydC1saW5lLXdyYXBwZXJcIixcbiAgICAgICAgc3R5bGU6IEJyKHsgd2lkdGg6IGBjYWxjKCR7cy5sZW5ndGggKyAxfWNoKWAgfSlcbiAgICAgIH0sIFtcbiAgICAgICAgRChcInNwYW5cIiwgVTgsIERlKHMpLCAxKVxuICAgICAgXSwgNCkpKSwgMTI4KSlcbiAgICBdKSk7XG4gIH1cbn0pLCBZOCA9IC8qIEBfX1BVUkVfXyAqLyBjdChxOCwgW1tcIl9fc2NvcGVJZFwiLCBcImRhdGEtdi1jNzA2MzQ4ZFwiXV0pLCB6OCA9IHtcbiAga2V5OiAxLFxuICBjbGFzczogXCJzY2FsYXItYXBpLWNsaWVudF9fZW1wdHktc3RhdGVcIlxufSwgSDggPSB7XG4gIGtleTogMSxcbiAgY2xhc3M6IFwic2NhbGFyLWFwaS1jbGllbnRfX2VtcHR5LXN0YXRlXCJcbn0sIEY4ID0gLyogQF9fUFVSRV9fICovIGxlKHtcbiAgX19uYW1lOiBcIlJlc3BvbnNlQm9keVwiLFxuICBwcm9wczoge1xuICAgIGFjdGl2ZTogeyB0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiAhMSB9LFxuICAgIGRhdGE6IHsgZGVmYXVsdDogbnVsbCB9LFxuICAgIGhlYWRlcnM6IHt9XG4gIH0sXG4gIHNldHVwKHQpIHtcbiAgICBjb25zdCBlID0gdCwgbiA9IGooKCkgPT4ge1xuICAgICAgY29uc3QgaSA9IGUuaGVhZGVycy5maW5kKFxuICAgICAgICAocykgPT4gcy5uYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiY29udGVudC10eXBlXCJcbiAgICAgICk7XG4gICAgICBpZiAoIWkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpPLnBhcnNlKGkudmFsdWUpLnR5cGU7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSksIHIgPSBqKCgpID0+IG4udmFsdWUgPT09IFwiYXBwbGljYXRpb24vanNvblwiIHx8IG4udmFsdWUgPT09IFwiYXBwbGljYXRpb24vcHJvYmxlbStqc29uXCIgfHwgbi52YWx1ZSA9PT0gXCJhcHBsaWNhdGlvbi92bmQuYXBpK2pzb25cIiA/IFwianNvblwiIDogbi52YWx1ZSA9PT0gXCJ0ZXh0L2h0bWxcIiB8fCBuLnZhbHVlID09PSBcInRleHQvcGxhaW5cIiA/IFwiaHRtbFwiIDogbnVsbCk7XG4gICAgcmV0dXJuIChpLCBzKSA9PiAoWigpLCBrZShSKGJpKSwgeyB0aXRsZTogXCJCb2R5XCIgfSwge1xuICAgICAgZGVmYXVsdDogY2UoKCkgPT4gW1xuICAgICAgICBpLmFjdGl2ZSA/IChaKCksIG5lKFBlLCB7IGtleTogMCB9LCBbXG4gICAgICAgICAgci52YWx1ZSA/IChaKCksIGtlKFIob1gpLCB7XG4gICAgICAgICAgICBrZXk6IDAsXG4gICAgICAgICAgICBjbGFzczogXCJjdXN0b20tc2Nyb2xsXCIsXG4gICAgICAgICAgICBjb250ZW50OiBpLmRhdGEsXG4gICAgICAgICAgICBsYW5nOiByLnZhbHVlXG4gICAgICAgICAgfSwgbnVsbCwgOCwgW1wiY29udGVudFwiLCBcImxhbmdcIl0pKSA6IChaKCksIG5lKFwiZGl2XCIsIHo4LCBbXG4gICAgICAgICAgICBuLnZhbHVlID8gKFooKSwgbmUoUGUsIHsga2V5OiAwIH0sIFtcbiAgICAgICAgICAgICAgSGUoXCIgTm8gUHJldmlldyBBdmFpbGFibGUgKFwiICsgRGUobi52YWx1ZSkgKyBcIikgXCIsIDEpXG4gICAgICAgICAgICBdLCA2NCkpIDogKFooKSwgbmUoUGUsIHsga2V5OiAxIH0sIFtcbiAgICAgICAgICAgICAgSGUoXCIgQ2Fu4oCZdCByZW5kZXIgYSBwcmV2aWV3LiBUaGUgQ29udGVudC1UeXBlIGhlYWRlciBpcyBtaXNzaW5nIG9yIHVua25vd24uIFwiKVxuICAgICAgICAgICAgXSwgNjQpKVxuICAgICAgICAgIF0pKVxuICAgICAgICBdLCA2NCkpIDogKFooKSwgbmUoXCJkaXZcIiwgSDgsIFwiIE5vIFJlc3BvbnNlIFwiKSlcbiAgICAgIF0pLFxuICAgICAgXzogMVxuICAgIH0pKTtcbiAgfVxufSksIEc4ID0gW1wiaHJlZlwiXSwgSzggPSAvKiBAX19QVVJFX18gKi8gbGUoe1xuICBfX25hbWU6IFwiSGVscGZ1bExpbmtcIixcbiAgcHJvcHM6IHtcbiAgICBocmVmOiB7fVxuICB9LFxuICBzZXR1cCh0KSB7XG4gICAgcmV0dXJuIChlLCBuKSA9PiAoWigpLCBuZShcImFcIiwge1xuICAgICAgaHJlZjogZS5ocmVmLFxuICAgICAgcmVsOiBcIm5vb3BlbmVyIG5vcmVmZXJyZXJcIixcbiAgICAgIHRhcmdldDogXCJfYmxhbmtcIlxuICAgIH0sIFtcbiAgICAgIHB0KGUuJHNsb3RzLCBcImRlZmF1bHRcIiwge30sIHZvaWQgMCwgITApXG4gICAgXSwgOCwgRzgpKTtcbiAgfVxufSksIE5QID0gLyogQF9fUFVSRV9fICovIGN0KEs4LCBbW1wiX19zY29wZUlkXCIsIFwiZGF0YS12LTg4Nzg4YzQ0XCJdXSksIEo4ID0gLyogQF9fUFVSRV9fICovIGxlKHtcbiAgX19uYW1lOiBcIlNpbXBsZUNlbGxcIixcbiAgcHJvcHM6IHtcbiAgICB3cmFwOiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6ICEwIH0sXG4gICAgc3Ryb25nOiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6ICExIH0sXG4gICAgaHJlZjogeyBkZWZhdWx0OiBudWxsIH1cbiAgfSxcbiAgc2V0dXAodCkge1xuICAgIHJldHVybiAoZSwgbikgPT4gKFooKSwgbmUoXCJ0ZFwiLCB7XG4gICAgICBjbGFzczogS2UoW1wic2ltcGxlLWNlbGxcIiwgeyB3cmFwOiBlLndyYXAsIHN0cm9uZzogZS5zdHJvbmcgfV0pXG4gICAgfSwgW1xuICAgICAgZS5ocmVmID8gKFooKSwga2UoTlAsIHtcbiAgICAgICAga2V5OiAwLFxuICAgICAgICBocmVmOiBlLmhyZWZcbiAgICAgIH0sIHtcbiAgICAgICAgZGVmYXVsdDogY2UoKCkgPT4gW1xuICAgICAgICAgIHB0KGUuJHNsb3RzLCBcImRlZmF1bHRcIiwge30sIHZvaWQgMCwgITApXG4gICAgICAgIF0pLFxuICAgICAgICBfOiAzXG4gICAgICB9LCA4LCBbXCJocmVmXCJdKSkgOiBwdChlLiRzbG90cywgXCJkZWZhdWx0XCIsIHsga2V5OiAxIH0sIHZvaWQgMCwgITApXG4gICAgXSwgMikpO1xuICB9XG59KSwgTXAgPSAvKiBAX19QVVJFX18gKi8gY3QoSjgsIFtbXCJfX3Njb3BlSWRcIiwgXCJkYXRhLXYtN2U2NGE4YmZcIl1dKSwgZTQgPSAvKiBAX19QVVJFX18gKi8gbGUoe1xuICBfX25hbWU6IFwiU2ltcGxlSGVhZGVyXCIsXG4gIHNldHVwKHQpIHtcbiAgICByZXR1cm4gKGUsIG4pID0+IChaKCksIGtlKE1wLCB7XG4gICAgICBhczogXCJ0aFwiLFxuICAgICAgY2xhc3M6IFwic2ltcGxlLWhlYWRlclwiXG4gICAgfSwge1xuICAgICAgZGVmYXVsdDogY2UoKCkgPT4gW1xuICAgICAgICBwdChlLiRzbG90cywgXCJkZWZhdWx0XCIsIHt9LCB2b2lkIDAsICEwKVxuICAgICAgXSksXG4gICAgICBfOiAzXG4gICAgfSkpO1xuICB9XG59KSwgTDAgPSAvKiBAX19QVVJFX18gKi8gY3QoZTQsIFtbXCJfX3Njb3BlSWRcIiwgXCJkYXRhLXYtYWZhOGQ2YmFcIl1dKSwgdDQgPSB7fSwgbjQgPSB7IGNsYXNzOiBcInNpbXBsZS1yb3dcIiB9O1xuZnVuY3Rpb24gcjQodCwgZSkge1xuICByZXR1cm4gWigpLCBuZShcInRyXCIsIG40LCBbXG4gICAgcHQodC4kc2xvdHMsIFwiZGVmYXVsdFwiLCB7fSwgdm9pZCAwLCAhMClcbiAgXSk7XG59XG5jb25zdCBVMCA9IC8qIEBfX1BVUkVfXyAqLyBjdCh0NCwgW1tcInJlbmRlclwiLCByNF0sIFtcIl9fc2NvcGVJZFwiLCBcImRhdGEtdi01ZDc0MjYxMVwiXV0pLCBpNCA9IHt9LCBzNCA9IHsgY2xhc3M6IFwic2ltcGxlLXRhYmxlLWNvbnRhaW5lclwiIH0sIG80ID0geyBjbGFzczogXCJzaW1wbGUtdGFibGVcIiB9O1xuZnVuY3Rpb24gYTQodCwgZSkge1xuICByZXR1cm4gWigpLCBuZShcImRpdlwiLCBzNCwgW1xuICAgIEQoXCJ0YWJsZVwiLCBvNCwgW1xuICAgICAgcHQodC4kc2xvdHMsIFwiZGVmYXVsdFwiLCB7fSwgdm9pZCAwLCAhMClcbiAgICBdKVxuICBdKTtcbn1cbmNvbnN0IGw0ID0gLyogQF9fUFVSRV9fICovIGN0KGk0LCBbW1wicmVuZGVyXCIsIGE0XSwgW1wiX19zY29wZUlkXCIsIFwiZGF0YS12LTE2NzQ5Y2UyXCJdXSksIGM0ID0ge1xuICBrZXk6IDEsXG4gIGNsYXNzOiBcInNjYWxhci1hcGktY2xpZW50X19lbXB0eS1zdGF0ZVwiXG59LCB1NCA9IC8qIEBfX1BVUkVfXyAqLyBsZSh7XG4gIF9fbmFtZTogXCJSZXNwb25zZUhlYWRlcnNcIixcbiAgcHJvcHM6IHtcbiAgICBoZWFkZXJzOiB7fVxuICB9LFxuICBzZXR1cCh0KSB7XG4gICAgY29uc3QgZSA9IChyKSA9PiB7XG4gICAgICB2YXIgaTtcbiAgICAgIHJldHVybiAoaSA9IHFSLmZpbmQoKHMpID0+IHMubmFtZS50b0xvd2VyQ2FzZSgpID09PSByLnRvTG93ZXJDYXNlKCkpKSA9PSBudWxsID8gdm9pZCAwIDogaS51cmw7XG4gICAgfSwgbiA9IChyKSA9PiByLnNwbGl0KFwiLVwiKS5tYXAoKGkpID0+IGkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBpLnNsaWNlKDEpKS5qb2luKFwiLVwiKTtcbiAgICByZXR1cm4gKHIsIGkpID0+IChaKCksIGtlKFIoYmkpLCB7IHRpdGxlOiBcIkhlYWRlcnNcIiB9LCB7XG4gICAgICBkZWZhdWx0OiBjZSgoKSA9PiBbXG4gICAgICAgIHIuaGVhZGVycy5sZW5ndGggPiAwID8gKFooKSwga2UoUihsNCksIHsga2V5OiAwIH0sIHtcbiAgICAgICAgICBkZWZhdWx0OiBjZSgoKSA9PiBbXG4gICAgICAgICAgICBKKFIoVTApLCBudWxsLCB7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6IGNlKCgpID0+IFtcbiAgICAgICAgICAgICAgICBKKFIoTDApLCBudWxsLCB7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OiBjZSgoKSA9PiBbXG4gICAgICAgICAgICAgICAgICAgIEhlKFwiS2V5XCIpXG4gICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgIF86IDFcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBKKFIoTDApLCBudWxsLCB7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OiBjZSgoKSA9PiBbXG4gICAgICAgICAgICAgICAgICAgIEhlKFwiVmFsdWVcIilcbiAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgXzogMVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICBfOiAxXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIChaKCEwKSwgbmUoUGUsIG51bGwsIFhyKHIuaGVhZGVycywgKHMpID0+IChaKCksIGtlKFIoVTApLCB7XG4gICAgICAgICAgICAgIGtleTogcy5uYW1lXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6IGNlKCgpID0+IFtcbiAgICAgICAgICAgICAgICBKKFIoTXApLCB7XG4gICAgICAgICAgICAgICAgICBocmVmOiBlKHMubmFtZSksXG4gICAgICAgICAgICAgICAgICBzdHJvbmc6ICEwLFxuICAgICAgICAgICAgICAgICAgd3JhcDogITFcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OiBjZSgoKSA9PiBbXG4gICAgICAgICAgICAgICAgICAgIEhlKERlKG4ocy5uYW1lKSksIDEpXG4gICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgIF86IDJcbiAgICAgICAgICAgICAgICB9LCAxMDMyLCBbXCJocmVmXCJdKSxcbiAgICAgICAgICAgICAgICBKKFIoTXApLCBudWxsLCB7XG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OiBjZSgoKSA9PiBbXG4gICAgICAgICAgICAgICAgICAgIEhlKERlKHMudmFsdWUpLCAxKVxuICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICBfOiAyXG4gICAgICAgICAgICAgICAgfSwgMTAyNClcbiAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgIF86IDJcbiAgICAgICAgICAgIH0sIDEwMjQpKSksIDEyOCkpXG4gICAgICAgICAgXSksXG4gICAgICAgICAgXzogMVxuICAgICAgICB9KSkgOiAoWigpLCBuZShcImRpdlwiLCBjNCwgXCJObyBIZWFkZXJzXCIpKVxuICAgICAgXSksXG4gICAgICBfOiAxXG4gICAgfSkpO1xuICB9XG59KSwgZDQgPSB7IGNsYXNzOiBcIm1ldGEtaXRlbVwiIH0sIGY0ID0geyBjbGFzczogXCJtZXRhLWl0ZW1cIiB9LCBoNCA9IHsgY2xhc3M6IFwibWV0YS1pdGVtXCIgfSwgcDQgPSAvKiBAX19QVVJFX18gKi8gbGUoe1xuICBfX25hbWU6IFwiUmVzcG9uc2VNZXRhSW5mb3JtYXRpb25cIixcbiAgcHJvcHM6IHtcbiAgICByZXNwb25zZToge31cbiAgfSxcbiAgc2V0dXAodCkge1xuICAgIGNvbnN0IGUgPSB0LCBuID0gKGkpID0+IHtcbiAgICAgIHZhciBzO1xuICAgICAgcmV0dXJuIChzID0gaSA9PSBudWxsID8gdm9pZCAwIDogaS5oZWFkZXJzKSAhPSBudWxsICYmIHNbXCJYLUFQSS1DbGllbnQtQ29udGVudC1MZW5ndGhcIl0gPyBDdShcbiAgICAgICAgcGFyc2VGbG9hdChpLmhlYWRlcnNbXCJYLUFQSS1DbGllbnQtQ29udGVudC1MZW5ndGhcIl0pXG4gICAgICApIDogQ3UoMCk7XG4gICAgfSwgciA9IGooKCkgPT4ge1xuICAgICAgY29uc3QgaSA9IGUucmVzcG9uc2Uuc3RhdHVzQ29kZTtcbiAgICAgIGlmIChpKVxuICAgICAgICByZXR1cm4gUlJbaV0gPz8gdm9pZCAwO1xuICAgIH0pO1xuICAgIHJldHVybiAoaSwgcykgPT4ge1xuICAgICAgdmFyIG8sIGE7XG4gICAgICByZXR1cm4gWigpLCBuZShQZSwgbnVsbCwgW1xuICAgICAgICBEKFwiZGl2XCIsIGQ0LCBbXG4gICAgICAgICAgRChcInNwYW5cIiwgbnVsbCwgRGUoUihkdykoaS5yZXNwb25zZS5kdXJhdGlvbikpLCAxKVxuICAgICAgICBdKSxcbiAgICAgICAgRChcImRpdlwiLCBmNCwgW1xuICAgICAgICAgIEQoXCJzcGFuXCIsIG51bGwsIERlKG4oaS5yZXNwb25zZSkpLCAxKVxuICAgICAgICBdKSxcbiAgICAgICAgRChcImRpdlwiLCBoNCwgW1xuICAgICAgICAgIEQoXCJzcGFuXCIsIHtcbiAgICAgICAgICAgIGNsYXNzOiBLZShgc2NhbGFyLWFwaS1jbGllbnRfX3N0YXR1cyBzY2FsYXItYXBpLWNsaWVudF9fc3RhdHVzLS0ke1N0cmluZyhcbiAgICAgICAgICAgICAgaS5yZXNwb25zZS5zdGF0dXNDb2RlXG4gICAgICAgICAgICApLmNoYXJBdCgwKX14eGApXG4gICAgICAgICAgfSwgW1xuICAgICAgICAgICAgKG8gPSByLnZhbHVlKSAhPSBudWxsICYmIG8udXJsID8gKFooKSwga2UoTlAsIHtcbiAgICAgICAgICAgICAga2V5OiAwLFxuICAgICAgICAgICAgICBocmVmOiByLnZhbHVlLnVybFxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICBkZWZhdWx0OiBjZSgoKSA9PiBbXG4gICAgICAgICAgICAgICAgSGUoRGUoaS5yZXNwb25zZS5zdGF0dXNDb2RlKSArIFwiIFwiICsgRGUoci52YWx1ZS5uYW1lKSwgMSlcbiAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgIF86IDFcbiAgICAgICAgICAgIH0sIDgsIFtcImhyZWZcIl0pKSA6IChaKCksIG5lKFBlLCB7IGtleTogMSB9LCBbXG4gICAgICAgICAgICAgIEhlKERlKGkucmVzcG9uc2Uuc3RhdHVzQ29kZSkgKyBcIiBcIiArIERlKChhID0gci52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IGEubmFtZSksIDEpXG4gICAgICAgICAgICBdLCA2NCkpXG4gICAgICAgICAgXSwgMilcbiAgICAgICAgXSlcbiAgICAgIF0sIDY0KTtcbiAgICB9O1xuICB9XG59KSwgTzQgPSB7IGNsYXNzOiBcInNjYWxhci1hcGktY2xpZW50X19tYWluX19yaWdodCBjdXN0b20tc2Nyb2xsXCIgfSwgZzQgPSB7IGNsYXNzOiBcInNjYWxhci1hcGktY2xpZW50X19tYWluX19jb250ZW50XCIgfSwgbTQgPSB7IGNsYXNzOiBcInNjYWxhci1hcGktY2xpZW50X19tYWluX19jb250ZW50X19oZWFkZXJcIiB9LCBiNCA9IC8qIEBfX1BVUkVfXyAqLyBEKFwibGFiZWxcIiwgbnVsbCwgXCJSZXNwb25zZVwiLCAtMSksIHY0ID0ge1xuICBrZXk6IDAsXG4gIGNsYXNzOiBcIm1ldGFcIlxufSwgeTQgPSB7XG4gIGtleTogMCxcbiAgY2xhc3M6IFwic2NhbGFyLWFwaS1jbGllbnRfX21haW5fX2NvbnRlbnRfX2JvZHlcIlxufSwgUzQgPSB7XG4gIGtleTogMCxcbiAgY2xhc3M6IFwic2NhbGFyLWFwaS1jbGllbnRfX2VtcHR5LXN0YXRlXCJcbn0sIHc0ID0gLyogQF9fUFVSRV9fICovIEQoXCJkaXZcIiwgeyBjbGFzczogXCJzY2FsYXItYXBpLWNsaWVudF9fbWFpbl9fc2Nyb2xsLWNvbnRhaW5lclwiIH0sIG51bGwsIC0xKSwgazQgPSB7XG4gIGtleTogMSxcbiAgY2xhc3M6IFwic2NhbGFyLWFwaS1jbGllbnRfX21haW5fX2NvbnRlbnQgZW1wdHktc3RhdGVcIlxufSwgeDQgPSAvKiBAX19QVVJFX18gKi8gRChcInBcIiwgbnVsbCwgXCJGaWxsIHRoZSB2b2lkIGFuZCBzZW5kIHlvdXIgcmVxdWVzdFwiLCAtMSksIHEwID0gLyogQF9fUFVSRV9fICovIGxlKHtcbiAgX19uYW1lOiBcIlJlc3BvbnNlXCIsXG4gIHNldHVwKHQpIHtcbiAgICBjb25zdCB7IGFjdGl2ZVJlc3BvbnNlOiBlLCBhY3RpdmVSZXF1ZXN0SWQ6IG4gfSA9IHNyKCksIHIgPSBqKCgpID0+IHtcbiAgICAgIHZhciBvO1xuICAgICAgY29uc3QgYSA9IChvID0gZS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IG8uaGVhZGVycztcbiAgICAgIHJldHVybiBhID8gT2JqZWN0LmtleXMoYSkubWFwKChsKSA9PiAoeyBuYW1lOiBsLCB2YWx1ZTogYVtsXSB9KSkuZmlsdGVyKFxuICAgICAgICAobCkgPT4gIVtcbiAgICAgICAgICBcInJlc3QtYXBpLWNsaWVudC1jb250ZW50LWxlbmd0aFwiLFxuICAgICAgICAgIFwiWC1BUEktQ2xpZW50LUNvbnRlbnQtTGVuZ3RoXCJcbiAgICAgICAgXS5pbmNsdWRlcyhsLm5hbWUpXG4gICAgICApIDogW107XG4gICAgfSksIGkgPSBqKCgpID0+IHtcbiAgICAgIHZhciBvO1xuICAgICAgY29uc3QgYSA9IChvID0gZS52YWx1ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IG8uY29va2llcztcbiAgICAgIHJldHVybiBhID8gT2JqZWN0LmtleXMoYSkubWFwKChsKSA9PiAoeyBuYW1lOiBsLCB2YWx1ZTogYVtsXSB9KSkgOiBbXTtcbiAgICB9KSwgcyA9IGooKCkgPT4ge1xuICAgICAgdmFyIG87XG4gICAgICBjb25zdCBhID0gKG8gPSBlLnZhbHVlKSA9PSBudWxsID8gdm9pZCAwIDogby5kYXRhO1xuICAgICAgcmV0dXJuIGEgJiYgWGgoYSkgPyBKU09OLnN0cmluZ2lmeShKU09OLnBhcnNlKGEpLCBudWxsLCAyKSA6IGEgJiYgdHlwZW9mIE9lKGEpID09IFwib2JqZWN0XCIgfHwgYSAmJiAhWGgoYSkgPyBKU09OLnN0cmluZ2lmeShhLCBudWxsLCAyKSA6IGE7XG4gICAgfSk7XG4gICAgcmV0dXJuIChvLCBhKSA9PiAoWigpLCBuZShcImRpdlwiLCBPNCwgW1xuICAgICAgRChcImRpdlwiLCBnNCwgW1xuICAgICAgICBEKFwiZGl2XCIsIG00LCBbXG4gICAgICAgICAgYjQsXG4gICAgICAgICAgUihuKSAmJiBSKGUpID8gKFooKSwgbmUoXCJkaXZcIiwgdjQsIFtcbiAgICAgICAgICAgIEoocDQsIHsgcmVzcG9uc2U6IFIoZSkgfSwgbnVsbCwgOCwgW1wicmVzcG9uc2VcIl0pXG4gICAgICAgICAgXSkpIDogc3QoXCJcIiwgITApXG4gICAgICAgIF0pLFxuICAgICAgICBSKG4pICYmIFIoZSkgPyAoWigpLCBuZShcImRpdlwiLCB5NCwgW1xuICAgICAgICAgIEooRjgsIHtcbiAgICAgICAgICAgIGFjdGl2ZTogISFSKGUpLFxuICAgICAgICAgICAgZGF0YTogcy52YWx1ZSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHIudmFsdWVcbiAgICAgICAgICB9LCBudWxsLCA4LCBbXCJhY3RpdmVcIiwgXCJkYXRhXCIsIFwiaGVhZGVyc1wiXSksXG4gICAgICAgICAgSih1NCwgeyBoZWFkZXJzOiByLnZhbHVlIH0sIG51bGwsIDgsIFtcImhlYWRlcnNcIl0pLFxuICAgICAgICAgIEooUihiaSksIHsgdGl0bGU6IFwiQ29va2llc1wiIH0sIHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IGNlKCgpID0+IFtcbiAgICAgICAgICAgICAgWGkoSihSKHY4KSwgeyBpdGVtczogaS52YWx1ZSB9LCBudWxsLCA4LCBbXCJpdGVtc1wiXSksIFtcbiAgICAgICAgICAgICAgICBbamwsIGkudmFsdWUubGVuZ3RoID4gMF1cbiAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgIGkudmFsdWUubGVuZ3RoID09PSAwID8gKFooKSwgbmUoXCJkaXZcIiwgUzQsIFwiTm8gQ29va2llc1wiKSkgOiBzdChcIlwiLCAhMClcbiAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgXzogMVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHc0XG4gICAgICAgIF0pKSA6IChaKCksIG5lKFwiZGl2XCIsIGs0LCBbXG4gICAgICAgICAgSihZOCwgeyBhcnQ6IFIoQjgpIH0sIG51bGwsIDgsIFtcImFydFwiXSksXG4gICAgICAgICAgeDRcbiAgICAgICAgXSkpXG4gICAgICBdKVxuICAgIF0pKTtcbiAgfVxufSksIFA0ID0geyBjbGFzczogXCJzY2FsYXItYXBpLWNsaWVudF9fbWFpblwiIH0sIF80ID0gLyogQF9fUFVSRV9fICovIGxlKHtcbiAgX19uYW1lOiBcIkFwaUNsaWVudFwiLFxuICBwcm9wczoge1xuICAgIHByb3h5VXJsOiB7fSxcbiAgICByZWFkT25seTogeyB0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiAhMSB9LFxuICAgIHRoZW1lOiB7fSxcbiAgICB3aXRoRGVmYXVsdEZvbnRzOiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6ICEwIH0sXG4gICAgc2hvd1NpZGVCYXI6IHsgdHlwZTogQm9vbGVhbiwgZGVmYXVsdDogITEgfVxuICB9LFxuICBlbWl0czogW1wiZXNjYXBlS2V5UHJlc3NcIiwgXCJ0b2dnbGVTaWRlYmFyXCJdLFxuICBzZXR1cCh0LCB7IGVtaXQ6IGUgfSkge1xuICAgIGNvbnN0IG4gPSB0LCByID0gZSwgaSA9IEJTKCk7XG4gICAgTmgoaS5lc2NhcGUsICgpID0+IHIoXCJlc2NhcGVLZXlQcmVzc1wiKSksIE5oKGkubWV0YV9iLCAoKSA9PiByKFwidG9nZ2xlU2lkZWJhclwiKSk7XG4gICAgY29uc3QgeyBhY3RpdmVSZXF1ZXN0OiBzLCByZWFkT25seTogbyB9ID0gc3IoKSwgYSA9IExDKFwiKG1heC13aWR0aDogODIwcHgpXCIpLCBsID0gRygwKSwgYyA9IHtcbiAgICAgIFJlcXVlc3Q6IDAsXG4gICAgICBSZXNwb25zZTogMVxuICAgIH07XG4gICAgZnVuY3Rpb24gdShkKSB7XG4gICAgICBsLnZhbHVlID0gZDtcbiAgICB9XG4gICAgcmV0dXJuIGh0KFxuICAgICAgKCkgPT4gbi5yZWFkT25seSxcbiAgICAgICgpID0+IHtcbiAgICAgICAgby52YWx1ZSA9IG4ucmVhZE9ubHk7XG4gICAgICB9LFxuICAgICAgeyBpbW1lZGlhdGU6ICEwIH1cbiAgICApLCAoZCwgZikgPT4gKFooKSwgbmUoUGUsIG51bGwsIFtcbiAgICAgIEooUih3UiksIHtcbiAgICAgICAgaWQ6IGQudGhlbWUsXG4gICAgICAgIHdpdGhEZWZhdWx0Rm9udHM6IGQud2l0aERlZmF1bHRGb250c1xuICAgICAgfSwgbnVsbCwgOCwgW1wiaWRcIiwgXCJ3aXRoRGVmYXVsdEZvbnRzXCJdKSxcbiAgICAgIEooRlIsIHtcbiAgICAgICAgY2xhc3M6IFwic2NhbGFyLWFwaS1jbGllbnRcIixcbiAgICAgICAgbWV0aG9kOiBSKHMpLnR5cGUgPz8gXCJnZXRcIixcbiAgICAgICAgcHJvcGVydHk6IFwiLS1zY2FsYXItYXBpLWNsaWVudC1jb2xvclwiLFxuICAgICAgICBvbktleWRvd246IGZbMV0gfHwgKGZbMV0gPSBsUygoaCkgPT4gcihcImVzY2FwZUtleVByZXNzXCIpLCBbXCJlc2NcIl0pKVxuICAgICAgfSwge1xuICAgICAgICBkZWZhdWx0OiBjZSgoKSA9PiBbXG4gICAgICAgICAgRChcImRpdlwiLCBudWxsLCBbXG4gICAgICAgICAgICBwdChkLiRzbG90cywgXCJhZGRyZXNzLWJhci1jb250cm9sc1wiKSxcbiAgICAgICAgICAgIEooR1csIHtcbiAgICAgICAgICAgICAgcHJveHlVcmw6IGQucHJveHlVcmwsXG4gICAgICAgICAgICAgIG9uT25TZW5kOiBmWzBdIHx8IChmWzBdID0gKGgpID0+IHUoYy5SZXNwb25zZSkpXG4gICAgICAgICAgICB9LCBudWxsLCA4LCBbXCJwcm94eVVybFwiXSlcbiAgICAgICAgICBdKSxcbiAgICAgICAgICBEKFwiZGl2XCIsIFA0LCBbXG4gICAgICAgICAgICBkLnNob3dTaWRlQmFyID8gcHQoZC4kc2xvdHMsIFwic2lkZWJhclwiLCB7IGtleTogMCB9KSA6IHN0KFwiXCIsICEwKSxcbiAgICAgICAgICAgIFIoYSkgPyAoWigpLCBrZShSKERDKSwge1xuICAgICAgICAgICAgICBrZXk6IDIsXG4gICAgICAgICAgICAgIHNlbGVjdGVkSW5kZXg6IGwudmFsdWUsXG4gICAgICAgICAgICAgIG9uQ2hhbmdlOiB1XG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6IGNlKCgpID0+IFtcbiAgICAgICAgICAgICAgICBKKFIoWkMpLCB7IGNsYXNzOiBcInNjYWxhci1hcGktY2xpZW50X19tb2JpbGUtbmF2aWdhdGlvblwiIH0sIHtcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGNlKCgpID0+IFtcbiAgICAgICAgICAgICAgICAgICAgSihSKGNiKSwgeyBjbGFzczogXCJzY2FsYXItYXBpLWNsaWVudF9fbW9iaWxlLW5hdmlnYXRpb25fX3RvZ2dsZVwiIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBjZSgoeyBzZWxlY3RlZDogaCB9KSA9PiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBEKFwic3BhblwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiBLZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJzY2FsYXItYXBpLWNsaWVudF9fbW9iaWxlLW5hdmlnYXRpb24tLWFjdGl2ZVwiOiBoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBcIiBSZXF1ZXN0IFwiLCAyKVxuICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgIF86IDFcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIEooUihjYiksIHsgY2xhc3M6IFwic2NhbGFyLWFwaS1jbGllbnRfX21vYmlsZS1uYXZpZ2F0aW9uX190b2dnbGVcIiB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogY2UoKHsgc2VsZWN0ZWQ6IGggfSkgPT4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgRChcInNwYW5cIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogS2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic2NhbGFyLWFwaS1jbGllbnRfX21vYmlsZS1uYXZpZ2F0aW9uLS1hY3RpdmVcIjogaFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgXCIgUmVzcG9uc2UgXCIsIDIpXG4gICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgXzogMVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICBfOiAxXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgSihSKFZDKSwgeyBhczogXCJ0ZW1wbGF0ZVwiIH0sIHtcbiAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGNlKCgpID0+IFtcbiAgICAgICAgICAgICAgICAgICAgSihSKHViKSwgeyBhczogXCJ0ZW1wbGF0ZVwiIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiBjZSgoKSA9PiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBKKFIoQjApKVxuICAgICAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgICAgIF86IDFcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIEooUih1YiksIHsgYXM6IFwidGVtcGxhdGVcIiB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDogY2UoKCkgPT4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgSihSKHEwKSlcbiAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICBfOiAxXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgIF86IDFcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgXzogMVxuICAgICAgICAgICAgfSwgOCwgW1wic2VsZWN0ZWRJbmRleFwiXSkpIDogKFooKSwgbmUoUGUsIHsga2V5OiAxIH0sIFtcbiAgICAgICAgICAgICAgSihSKEIwKSksXG4gICAgICAgICAgICAgIEooUihxMCkpXG4gICAgICAgICAgICBdLCA2NCkpXG4gICAgICAgICAgXSlcbiAgICAgICAgXSksXG4gICAgICAgIF86IDNcbiAgICAgIH0sIDgsIFtcIm1ldGhvZFwiXSlcbiAgICBdLCA2NCkpO1xuICB9XG59KTtcbi8qKlxuKiBAdnVlL2NvbXBpbGVyLWNvcmUgdjMuNC4yMVxuKiAoYykgMjAxOC1wcmVzZW50IFl1eGkgKEV2YW4pIFlvdSBhbmQgVnVlIGNvbnRyaWJ1dG9yc1xuKiBAbGljZW5zZSBNSVRcbioqL1xuY29uc3QgVGwgPSBTeW1ib2wocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJGcmFnbWVudFwiIDogXCJcIiksIEdhID0gU3ltYm9sKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiVGVsZXBvcnRcIiA6IFwiXCIpLCBDZyA9IFN5bWJvbChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIlN1c3BlbnNlXCIgOiBcIlwiKSwgdGQgPSBTeW1ib2wocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJLZWVwQWxpdmVcIiA6IFwiXCIpLCBEUCA9IFN5bWJvbChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIkJhc2VUcmFuc2l0aW9uXCIgOiBcIlwiKSwgRnMgPSBTeW1ib2wocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJvcGVuQmxvY2tcIiA6IFwiXCIpLCBaUCA9IFN5bWJvbChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcImNyZWF0ZUJsb2NrXCIgOiBcIlwiKSwgVlAgPSBTeW1ib2wocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJjcmVhdGVFbGVtZW50QmxvY2tcIiA6IFwiXCIpLCBBZyA9IFN5bWJvbChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcImNyZWF0ZVZOb2RlXCIgOiBcIlwiKSwgUmcgPSBTeW1ib2wocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJjcmVhdGVFbGVtZW50Vk5vZGVcIiA6IFwiXCIpLCByYyA9IFN5bWJvbChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcImNyZWF0ZUNvbW1lbnRWTm9kZVwiIDogXCJcIiksIE5nID0gU3ltYm9sKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiY3JlYXRlVGV4dFZOb2RlXCIgOiBcIlwiKSwgSVAgPSBTeW1ib2wocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJjcmVhdGVTdGF0aWNWTm9kZVwiIDogXCJcIiksIERnID0gU3ltYm9sKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwicmVzb2x2ZUNvbXBvbmVudFwiIDogXCJcIiksIFpnID0gU3ltYm9sKFxuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcInJlc29sdmVEeW5hbWljQ29tcG9uZW50XCIgOiBcIlwiXG4pLCBWZyA9IFN5bWJvbChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcInJlc29sdmVEaXJlY3RpdmVcIiA6IFwiXCIpLCBJZyA9IFN5bWJvbChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcInJlc29sdmVGaWx0ZXJcIiA6IFwiXCIpLCBXZyA9IFN5bWJvbChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIndpdGhEaXJlY3RpdmVzXCIgOiBcIlwiKSwgTWcgPSBTeW1ib2wocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJyZW5kZXJMaXN0XCIgOiBcIlwiKSwgV1AgPSBTeW1ib2wocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJyZW5kZXJTbG90XCIgOiBcIlwiKSwgTVAgPSBTeW1ib2wocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJjcmVhdGVTbG90c1wiIDogXCJcIiksIEpkID0gU3ltYm9sKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwidG9EaXNwbGF5U3RyaW5nXCIgOiBcIlwiKSwgbmQgPSBTeW1ib2wocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJtZXJnZVByb3BzXCIgOiBcIlwiKSwgWGcgPSBTeW1ib2wocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJub3JtYWxpemVDbGFzc1wiIDogXCJcIiksIGpnID0gU3ltYm9sKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwibm9ybWFsaXplU3R5bGVcIiA6IFwiXCIpLCBFbCA9IFN5bWJvbChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIm5vcm1hbGl6ZVByb3BzXCIgOiBcIlwiKSwgaWMgPSBTeW1ib2wocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJndWFyZFJlYWN0aXZlUHJvcHNcIiA6IFwiXCIpLCBCZyA9IFN5bWJvbChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcInRvSGFuZGxlcnNcIiA6IFwiXCIpLCBYcCA9IFN5bWJvbChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcImNhbWVsaXplXCIgOiBcIlwiKSwgVDQgPSBTeW1ib2wocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJjYXBpdGFsaXplXCIgOiBcIlwiKSwganAgPSBTeW1ib2wocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJ0b0hhbmRsZXJLZXlcIiA6IFwiXCIpLCByZCA9IFN5bWJvbChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcInNldEJsb2NrVHJhY2tpbmdcIiA6IFwiXCIpLCBFNCA9IFN5bWJvbChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcInB1c2hTY29wZUlkXCIgOiBcIlwiKSwgJDQgPSBTeW1ib2wocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJwb3BTY29wZUlkXCIgOiBcIlwiKSwgTGcgPSBTeW1ib2wocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJ3aXRoQ3R4XCIgOiBcIlwiKSwgUTQgPSBTeW1ib2wocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJ1bnJlZlwiIDogXCJcIiksIEM0ID0gU3ltYm9sKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiaXNSZWZcIiA6IFwiXCIpLCBVZyA9IFN5bWJvbChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIndpdGhNZW1vXCIgOiBcIlwiKSwgWFAgPSBTeW1ib2wocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJpc01lbW9TYW1lXCIgOiBcIlwiKSwgSG8gPSB7XG4gIFtUbF06IFwiRnJhZ21lbnRcIixcbiAgW0dhXTogXCJUZWxlcG9ydFwiLFxuICBbQ2ddOiBcIlN1c3BlbnNlXCIsXG4gIFt0ZF06IFwiS2VlcEFsaXZlXCIsXG4gIFtEUF06IFwiQmFzZVRyYW5zaXRpb25cIixcbiAgW0ZzXTogXCJvcGVuQmxvY2tcIixcbiAgW1pQXTogXCJjcmVhdGVCbG9ja1wiLFxuICBbVlBdOiBcImNyZWF0ZUVsZW1lbnRCbG9ja1wiLFxuICBbQWddOiBcImNyZWF0ZVZOb2RlXCIsXG4gIFtSZ106IFwiY3JlYXRlRWxlbWVudFZOb2RlXCIsXG4gIFtyY106IFwiY3JlYXRlQ29tbWVudFZOb2RlXCIsXG4gIFtOZ106IFwiY3JlYXRlVGV4dFZOb2RlXCIsXG4gIFtJUF06IFwiY3JlYXRlU3RhdGljVk5vZGVcIixcbiAgW0RnXTogXCJyZXNvbHZlQ29tcG9uZW50XCIsXG4gIFtaZ106IFwicmVzb2x2ZUR5bmFtaWNDb21wb25lbnRcIixcbiAgW1ZnXTogXCJyZXNvbHZlRGlyZWN0aXZlXCIsXG4gIFtJZ106IFwicmVzb2x2ZUZpbHRlclwiLFxuICBbV2ddOiBcIndpdGhEaXJlY3RpdmVzXCIsXG4gIFtNZ106IFwicmVuZGVyTGlzdFwiLFxuICBbV1BdOiBcInJlbmRlclNsb3RcIixcbiAgW01QXTogXCJjcmVhdGVTbG90c1wiLFxuICBbSmRdOiBcInRvRGlzcGxheVN0cmluZ1wiLFxuICBbbmRdOiBcIm1lcmdlUHJvcHNcIixcbiAgW1hnXTogXCJub3JtYWxpemVDbGFzc1wiLFxuICBbamddOiBcIm5vcm1hbGl6ZVN0eWxlXCIsXG4gIFtFbF06IFwibm9ybWFsaXplUHJvcHNcIixcbiAgW2ljXTogXCJndWFyZFJlYWN0aXZlUHJvcHNcIixcbiAgW0JnXTogXCJ0b0hhbmRsZXJzXCIsXG4gIFtYcF06IFwiY2FtZWxpemVcIixcbiAgW1Q0XTogXCJjYXBpdGFsaXplXCIsXG4gIFtqcF06IFwidG9IYW5kbGVyS2V5XCIsXG4gIFtyZF06IFwic2V0QmxvY2tUcmFja2luZ1wiLFxuICBbRTRdOiBcInB1c2hTY29wZUlkXCIsXG4gIFskNF06IFwicG9wU2NvcGVJZFwiLFxuICBbTGddOiBcIndpdGhDdHhcIixcbiAgW1E0XTogXCJ1bnJlZlwiLFxuICBbQzRdOiBcImlzUmVmXCIsXG4gIFtVZ106IFwid2l0aE1lbW9cIixcbiAgW1hQXTogXCJpc01lbW9TYW1lXCJcbn07XG5mdW5jdGlvbiBBNCh0KSB7XG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModCkuZm9yRWFjaCgoZSkgPT4ge1xuICAgIEhvW2VdID0gdFtlXTtcbiAgfSk7XG59XG5jb25zdCBMbiA9IHtcbiAgc3RhcnQ6IHsgbGluZTogMSwgY29sdW1uOiAxLCBvZmZzZXQ6IDAgfSxcbiAgZW5kOiB7IGxpbmU6IDEsIGNvbHVtbjogMSwgb2Zmc2V0OiAwIH0sXG4gIHNvdXJjZTogXCJcIlxufTtcbmZ1bmN0aW9uIFI0KHQsIGUgPSBcIlwiKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogMCxcbiAgICBzb3VyY2U6IGUsXG4gICAgY2hpbGRyZW46IHQsXG4gICAgaGVscGVyczogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSxcbiAgICBjb21wb25lbnRzOiBbXSxcbiAgICBkaXJlY3RpdmVzOiBbXSxcbiAgICBob2lzdHM6IFtdLFxuICAgIGltcG9ydHM6IFtdLFxuICAgIGNhY2hlZDogMCxcbiAgICB0ZW1wczogMCxcbiAgICBjb2RlZ2VuTm9kZTogdm9pZCAwLFxuICAgIGxvYzogTG5cbiAgfTtcbn1cbmZ1bmN0aW9uICRsKHQsIGUsIG4sIHIsIGksIHMsIG8sIGEgPSAhMSwgbCA9ICExLCBjID0gITEsIHUgPSBMbikge1xuICByZXR1cm4gdCAmJiAoYSA/ICh0LmhlbHBlcihGcyksIHQuaGVscGVyKEtvKHQuaW5TU1IsIGMpKSkgOiB0LmhlbHBlcihHbyh0LmluU1NSLCBjKSksIG8gJiYgdC5oZWxwZXIoV2cpKSwge1xuICAgIHR5cGU6IDEzLFxuICAgIHRhZzogZSxcbiAgICBwcm9wczogbixcbiAgICBjaGlsZHJlbjogcixcbiAgICBwYXRjaEZsYWc6IGksXG4gICAgZHluYW1pY1Byb3BzOiBzLFxuICAgIGRpcmVjdGl2ZXM6IG8sXG4gICAgaXNCbG9jazogYSxcbiAgICBkaXNhYmxlVHJhY2tpbmc6IGwsXG4gICAgaXNDb21wb25lbnQ6IGMsXG4gICAgbG9jOiB1XG4gIH07XG59XG5mdW5jdGlvbiBzYyh0LCBlID0gTG4pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAxNyxcbiAgICBsb2M6IGUsXG4gICAgZWxlbWVudHM6IHRcbiAgfTtcbn1cbmZ1bmN0aW9uIEduKHQsIGUgPSBMbikge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IDE1LFxuICAgIGxvYzogZSxcbiAgICBwcm9wZXJ0aWVzOiB0XG4gIH07XG59XG5mdW5jdGlvbiB5dCh0LCBlKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogMTYsXG4gICAgbG9jOiBMbixcbiAgICBrZXk6IHdlKHQpID8gRWUodCwgITApIDogdCxcbiAgICB2YWx1ZTogZVxuICB9O1xufVxuZnVuY3Rpb24gRWUodCwgZSA9ICExLCBuID0gTG4sIHIgPSAwKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogNCxcbiAgICBsb2M6IG4sXG4gICAgY29udGVudDogdCxcbiAgICBpc1N0YXRpYzogZSxcbiAgICBjb25zdFR5cGU6IGUgPyAzIDogclxuICB9O1xufVxuZnVuY3Rpb24gcHIodCwgZSA9IExuKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogOCxcbiAgICBsb2M6IGUsXG4gICAgY2hpbGRyZW46IHRcbiAgfTtcbn1cbmZ1bmN0aW9uIER0KHQsIGUgPSBbXSwgbiA9IExuKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogMTQsXG4gICAgbG9jOiBuLFxuICAgIGNhbGxlZTogdCxcbiAgICBhcmd1bWVudHM6IGVcbiAgfTtcbn1cbmZ1bmN0aW9uIEZvKHQsIGUgPSB2b2lkIDAsIG4gPSAhMSwgciA9ICExLCBpID0gTG4pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAxOCxcbiAgICBwYXJhbXM6IHQsXG4gICAgcmV0dXJuczogZSxcbiAgICBuZXdsaW5lOiBuLFxuICAgIGlzU2xvdDogcixcbiAgICBsb2M6IGlcbiAgfTtcbn1cbmZ1bmN0aW9uIEJwKHQsIGUsIG4sIHIgPSAhMCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IDE5LFxuICAgIHRlc3Q6IHQsXG4gICAgY29uc2VxdWVudDogZSxcbiAgICBhbHRlcm5hdGU6IG4sXG4gICAgbmV3bGluZTogcixcbiAgICBsb2M6IExuXG4gIH07XG59XG5mdW5jdGlvbiBONCh0LCBlLCBuID0gITEpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAyMCxcbiAgICBpbmRleDogdCxcbiAgICB2YWx1ZTogZSxcbiAgICBpc1ZOb2RlOiBuLFxuICAgIGxvYzogTG5cbiAgfTtcbn1cbmZ1bmN0aW9uIEQ0KHQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAyMSxcbiAgICBib2R5OiB0LFxuICAgIGxvYzogTG5cbiAgfTtcbn1cbmZ1bmN0aW9uIEdvKHQsIGUpIHtcbiAgcmV0dXJuIHQgfHwgZSA/IEFnIDogUmc7XG59XG5mdW5jdGlvbiBLbyh0LCBlKSB7XG4gIHJldHVybiB0IHx8IGUgPyBaUCA6IFZQO1xufVxuZnVuY3Rpb24gcWcodCwgeyBoZWxwZXI6IGUsIHJlbW92ZUhlbHBlcjogbiwgaW5TU1I6IHIgfSkge1xuICB0LmlzQmxvY2sgfHwgKHQuaXNCbG9jayA9ICEwLCBuKEdvKHIsIHQuaXNDb21wb25lbnQpKSwgZShGcyksIGUoS28ociwgdC5pc0NvbXBvbmVudCkpKTtcbn1cbmNvbnN0IFkwID0gbmV3IFVpbnQ4QXJyYXkoWzEyMywgMTIzXSksIHowID0gbmV3IFVpbnQ4QXJyYXkoWzEyNSwgMTI1XSk7XG5mdW5jdGlvbiBIMCh0KSB7XG4gIHJldHVybiB0ID49IDk3ICYmIHQgPD0gMTIyIHx8IHQgPj0gNjUgJiYgdCA8PSA5MDtcbn1cbmZ1bmN0aW9uIE5uKHQpIHtcbiAgcmV0dXJuIHQgPT09IDMyIHx8IHQgPT09IDEwIHx8IHQgPT09IDkgfHwgdCA9PT0gMTIgfHwgdCA9PT0gMTM7XG59XG5mdW5jdGlvbiBUaSh0KSB7XG4gIHJldHVybiB0ID09PSA0NyB8fCB0ID09PSA2MiB8fCBObih0KTtcbn1cbmZ1bmN0aW9uIGlkKHQpIHtcbiAgY29uc3QgZSA9IG5ldyBVaW50OEFycmF5KHQubGVuZ3RoKTtcbiAgZm9yIChsZXQgbiA9IDA7IG4gPCB0Lmxlbmd0aDsgbisrKVxuICAgIGVbbl0gPSB0LmNoYXJDb2RlQXQobik7XG4gIHJldHVybiBlO1xufVxuY29uc3QgVXQgPSB7XG4gIENkYXRhOiBuZXcgVWludDhBcnJheShbNjcsIDY4LCA2NSwgODQsIDY1LCA5MV0pLFxuICAvLyBDREFUQVtcbiAgQ2RhdGFFbmQ6IG5ldyBVaW50OEFycmF5KFs5MywgOTMsIDYyXSksXG4gIC8vIF1dPlxuICBDb21tZW50RW5kOiBuZXcgVWludDhBcnJheShbNDUsIDQ1LCA2Ml0pLFxuICAvLyBgLS0+YFxuICBTY3JpcHRFbmQ6IG5ldyBVaW50OEFycmF5KFs2MCwgNDcsIDExNSwgOTksIDExNCwgMTA1LCAxMTIsIDExNl0pLFxuICAvLyBgPFxcL3NjcmlwdGBcbiAgU3R5bGVFbmQ6IG5ldyBVaW50OEFycmF5KFs2MCwgNDcsIDExNSwgMTE2LCAxMjEsIDEwOCwgMTAxXSksXG4gIC8vIGA8L3N0eWxlYFxuICBUaXRsZUVuZDogbmV3IFVpbnQ4QXJyYXkoWzYwLCA0NywgMTE2LCAxMDUsIDExNiwgMTA4LCAxMDFdKSxcbiAgLy8gYDwvdGl0bGVgXG4gIFRleHRhcmVhRW5kOiBuZXcgVWludDhBcnJheShbXG4gICAgNjAsXG4gICAgNDcsXG4gICAgMTE2LFxuICAgIDEwMSxcbiAgICAxMjAsXG4gICAgMTE2LFxuICAgIDk3LFxuICAgIDExNCxcbiAgICAxMDEsXG4gICAgOTdcbiAgXSlcbiAgLy8gYDwvdGV4dGFyZWFcbn07XG5jbGFzcyBaNCB7XG4gIGNvbnN0cnVjdG9yKGUsIG4pIHtcbiAgICB0aGlzLnN0YWNrID0gZSwgdGhpcy5jYnMgPSBuLCB0aGlzLnN0YXRlID0gMSwgdGhpcy5idWZmZXIgPSBcIlwiLCB0aGlzLnNlY3Rpb25TdGFydCA9IDAsIHRoaXMuaW5kZXggPSAwLCB0aGlzLmVudGl0eVN0YXJ0ID0gMCwgdGhpcy5iYXNlU3RhdGUgPSAxLCB0aGlzLmluUkNEQVRBID0gITEsIHRoaXMuaW5YTUwgPSAhMSwgdGhpcy5pblZQcmUgPSAhMSwgdGhpcy5uZXdsaW5lcyA9IFtdLCB0aGlzLm1vZGUgPSAwLCB0aGlzLmRlbGltaXRlck9wZW4gPSBZMCwgdGhpcy5kZWxpbWl0ZXJDbG9zZSA9IHowLCB0aGlzLmRlbGltaXRlckluZGV4ID0gLTEsIHRoaXMuY3VycmVudFNlcXVlbmNlID0gdm9pZCAwLCB0aGlzLnNlcXVlbmNlSW5kZXggPSAwO1xuICB9XG4gIGdldCBpblNGQ1Jvb3QoKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kZSA9PT0gMiAmJiB0aGlzLnN0YWNrLmxlbmd0aCA9PT0gMDtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLnN0YXRlID0gMSwgdGhpcy5tb2RlID0gMCwgdGhpcy5idWZmZXIgPSBcIlwiLCB0aGlzLnNlY3Rpb25TdGFydCA9IDAsIHRoaXMuaW5kZXggPSAwLCB0aGlzLmJhc2VTdGF0ZSA9IDEsIHRoaXMuaW5SQ0RBVEEgPSAhMSwgdGhpcy5jdXJyZW50U2VxdWVuY2UgPSB2b2lkIDAsIHRoaXMubmV3bGluZXMubGVuZ3RoID0gMCwgdGhpcy5kZWxpbWl0ZXJPcGVuID0gWTAsIHRoaXMuZGVsaW1pdGVyQ2xvc2UgPSB6MDtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGUgUG9zaXRpb24gb2JqZWN0IHdpdGggbGluZSAvIGNvbHVtbiBpbmZvcm1hdGlvbiB1c2luZyByZWNvcmRlZFxuICAgKiBuZXdsaW5lIHBvc2l0aW9ucy4gV2Uga25vdyB0aGUgaW5kZXggaXMgYWx3YXlzIGdvaW5nIHRvIGJlIGFuIGFscmVhZHlcbiAgICogcHJvY2Vzc2VkIGluZGV4LCBzbyBhbGwgdGhlIG5ld2xpbmVzIHVwIHRvIHRoaXMgaW5kZXggc2hvdWxkIGhhdmUgYmVlblxuICAgKiByZWNvcmRlZC5cbiAgICovXG4gIGdldFBvcyhlKSB7XG4gICAgbGV0IG4gPSAxLCByID0gZSArIDE7XG4gICAgZm9yIChsZXQgaSA9IHRoaXMubmV3bGluZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGNvbnN0IHMgPSB0aGlzLm5ld2xpbmVzW2ldO1xuICAgICAgaWYgKGUgPiBzKSB7XG4gICAgICAgIG4gPSBpICsgMiwgciA9IGUgLSBzO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbHVtbjogcixcbiAgICAgIGxpbmU6IG4sXG4gICAgICBvZmZzZXQ6IGVcbiAgICB9O1xuICB9XG4gIHBlZWsoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyLmNoYXJDb2RlQXQodGhpcy5pbmRleCArIDEpO1xuICB9XG4gIHN0YXRlVGV4dChlKSB7XG4gICAgZSA9PT0gNjAgPyAodGhpcy5pbmRleCA+IHRoaXMuc2VjdGlvblN0YXJ0ICYmIHRoaXMuY2JzLm9udGV4dCh0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCksIHRoaXMuc3RhdGUgPSA1LCB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXgpIDogIXRoaXMuaW5WUHJlICYmIGUgPT09IHRoaXMuZGVsaW1pdGVyT3BlblswXSAmJiAodGhpcy5zdGF0ZSA9IDIsIHRoaXMuZGVsaW1pdGVySW5kZXggPSAwLCB0aGlzLnN0YXRlSW50ZXJwb2xhdGlvbk9wZW4oZSkpO1xuICB9XG4gIHN0YXRlSW50ZXJwb2xhdGlvbk9wZW4oZSkge1xuICAgIGlmIChlID09PSB0aGlzLmRlbGltaXRlck9wZW5bdGhpcy5kZWxpbWl0ZXJJbmRleF0pXG4gICAgICBpZiAodGhpcy5kZWxpbWl0ZXJJbmRleCA9PT0gdGhpcy5kZWxpbWl0ZXJPcGVuLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuaW5kZXggKyAxIC0gdGhpcy5kZWxpbWl0ZXJPcGVuLmxlbmd0aDtcbiAgICAgICAgbiA+IHRoaXMuc2VjdGlvblN0YXJ0ICYmIHRoaXMuY2JzLm9udGV4dCh0aGlzLnNlY3Rpb25TdGFydCwgbiksIHRoaXMuc3RhdGUgPSAzLCB0aGlzLnNlY3Rpb25TdGFydCA9IG47XG4gICAgICB9IGVsc2VcbiAgICAgICAgdGhpcy5kZWxpbWl0ZXJJbmRleCsrO1xuICAgIGVsc2VcbiAgICAgIHRoaXMuaW5SQ0RBVEEgPyAodGhpcy5zdGF0ZSA9IDMyLCB0aGlzLnN0YXRlSW5SQ0RBVEEoZSkpIDogKHRoaXMuc3RhdGUgPSAxLCB0aGlzLnN0YXRlVGV4dChlKSk7XG4gIH1cbiAgc3RhdGVJbnRlcnBvbGF0aW9uKGUpIHtcbiAgICBlID09PSB0aGlzLmRlbGltaXRlckNsb3NlWzBdICYmICh0aGlzLnN0YXRlID0gNCwgdGhpcy5kZWxpbWl0ZXJJbmRleCA9IDAsIHRoaXMuc3RhdGVJbnRlcnBvbGF0aW9uQ2xvc2UoZSkpO1xuICB9XG4gIHN0YXRlSW50ZXJwb2xhdGlvbkNsb3NlKGUpIHtcbiAgICBlID09PSB0aGlzLmRlbGltaXRlckNsb3NlW3RoaXMuZGVsaW1pdGVySW5kZXhdID8gdGhpcy5kZWxpbWl0ZXJJbmRleCA9PT0gdGhpcy5kZWxpbWl0ZXJDbG9zZS5sZW5ndGggLSAxID8gKHRoaXMuY2JzLm9uaW50ZXJwb2xhdGlvbih0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCArIDEpLCB0aGlzLmluUkNEQVRBID8gdGhpcy5zdGF0ZSA9IDMyIDogdGhpcy5zdGF0ZSA9IDEsIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDEpIDogdGhpcy5kZWxpbWl0ZXJJbmRleCsrIDogKHRoaXMuc3RhdGUgPSAzLCB0aGlzLnN0YXRlSW50ZXJwb2xhdGlvbihlKSk7XG4gIH1cbiAgc3RhdGVTcGVjaWFsU3RhcnRTZXF1ZW5jZShlKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuc2VxdWVuY2VJbmRleCA9PT0gdGhpcy5jdXJyZW50U2VxdWVuY2UubGVuZ3RoO1xuICAgIGlmICghKG4gPyAoXG4gICAgICAvLyBJZiB3ZSBhcmUgYXQgdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2UsIG1ha2Ugc3VyZSB0aGUgdGFnIG5hbWUgaGFzIGVuZGVkXG4gICAgICBUaShlKVxuICAgICkgOiAoXG4gICAgICAvLyBPdGhlcndpc2UsIGRvIGEgY2FzZS1pbnNlbnNpdGl2ZSBjb21wYXJpc29uXG4gICAgICAoZSB8IDMyKSA9PT0gdGhpcy5jdXJyZW50U2VxdWVuY2VbdGhpcy5zZXF1ZW5jZUluZGV4XVxuICAgICkpKVxuICAgICAgdGhpcy5pblJDREFUQSA9ICExO1xuICAgIGVsc2UgaWYgKCFuKSB7XG4gICAgICB0aGlzLnNlcXVlbmNlSW5kZXgrKztcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZXF1ZW5jZUluZGV4ID0gMCwgdGhpcy5zdGF0ZSA9IDYsIHRoaXMuc3RhdGVJblRhZ05hbWUoZSk7XG4gIH1cbiAgLyoqIExvb2sgZm9yIGFuIGVuZCB0YWcuIEZvciA8dGl0bGU+IGFuZCA8dGV4dGFyZWE+LCBhbHNvIGRlY29kZSBlbnRpdGllcy4gKi9cbiAgc3RhdGVJblJDREFUQShlKSB7XG4gICAgaWYgKHRoaXMuc2VxdWVuY2VJbmRleCA9PT0gdGhpcy5jdXJyZW50U2VxdWVuY2UubGVuZ3RoKSB7XG4gICAgICBpZiAoZSA9PT0gNjIgfHwgTm4oZSkpIHtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuaW5kZXggLSB0aGlzLmN1cnJlbnRTZXF1ZW5jZS5sZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLnNlY3Rpb25TdGFydCA8IG4pIHtcbiAgICAgICAgICBjb25zdCByID0gdGhpcy5pbmRleDtcbiAgICAgICAgICB0aGlzLmluZGV4ID0gbiwgdGhpcy5jYnMub250ZXh0KHRoaXMuc2VjdGlvblN0YXJ0LCBuKSwgdGhpcy5pbmRleCA9IHI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWN0aW9uU3RhcnQgPSBuICsgMiwgdGhpcy5zdGF0ZUluQ2xvc2luZ1RhZ05hbWUoZSksIHRoaXMuaW5SQ0RBVEEgPSAhMTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXF1ZW5jZUluZGV4ID0gMDtcbiAgICB9XG4gICAgKGUgfCAzMikgPT09IHRoaXMuY3VycmVudFNlcXVlbmNlW3RoaXMuc2VxdWVuY2VJbmRleF0gPyB0aGlzLnNlcXVlbmNlSW5kZXggKz0gMSA6IHRoaXMuc2VxdWVuY2VJbmRleCA9PT0gMCA/IHRoaXMuY3VycmVudFNlcXVlbmNlID09PSBVdC5UaXRsZUVuZCB8fCB0aGlzLmN1cnJlbnRTZXF1ZW5jZSA9PT0gVXQuVGV4dGFyZWFFbmQgJiYgIXRoaXMuaW5TRkNSb290ID8gZSA9PT0gdGhpcy5kZWxpbWl0ZXJPcGVuWzBdICYmICh0aGlzLnN0YXRlID0gMiwgdGhpcy5kZWxpbWl0ZXJJbmRleCA9IDAsIHRoaXMuc3RhdGVJbnRlcnBvbGF0aW9uT3BlbihlKSkgOiB0aGlzLmZhc3RGb3J3YXJkVG8oNjApICYmICh0aGlzLnNlcXVlbmNlSW5kZXggPSAxKSA6IHRoaXMuc2VxdWVuY2VJbmRleCA9ICsoZSA9PT0gNjApO1xuICB9XG4gIHN0YXRlQ0RBVEFTZXF1ZW5jZShlKSB7XG4gICAgZSA9PT0gVXQuQ2RhdGFbdGhpcy5zZXF1ZW5jZUluZGV4XSA/ICsrdGhpcy5zZXF1ZW5jZUluZGV4ID09PSBVdC5DZGF0YS5sZW5ndGggJiYgKHRoaXMuc3RhdGUgPSAyOCwgdGhpcy5jdXJyZW50U2VxdWVuY2UgPSBVdC5DZGF0YUVuZCwgdGhpcy5zZXF1ZW5jZUluZGV4ID0gMCwgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4ICsgMSkgOiAodGhpcy5zZXF1ZW5jZUluZGV4ID0gMCwgdGhpcy5zdGF0ZSA9IDIzLCB0aGlzLnN0YXRlSW5EZWNsYXJhdGlvbihlKSk7XG4gIH1cbiAgLyoqXG4gICAqIFdoZW4gd2Ugd2FpdCBmb3Igb25lIHNwZWNpZmljIGNoYXJhY3Rlciwgd2UgY2FuIHNwZWVkIHRoaW5ncyB1cFxuICAgKiBieSBza2lwcGluZyB0aHJvdWdoIHRoZSBidWZmZXIgdW50aWwgd2UgZmluZCBpdC5cbiAgICpcbiAgICogQHJldHVybnMgV2hldGhlciB0aGUgY2hhcmFjdGVyIHdhcyBmb3VuZC5cbiAgICovXG4gIGZhc3RGb3J3YXJkVG8oZSkge1xuICAgIGZvciAoOyArK3RoaXMuaW5kZXggPCB0aGlzLmJ1ZmZlci5sZW5ndGg7ICkge1xuICAgICAgY29uc3QgbiA9IHRoaXMuYnVmZmVyLmNoYXJDb2RlQXQodGhpcy5pbmRleCk7XG4gICAgICBpZiAobiA9PT0gMTAgJiYgdGhpcy5uZXdsaW5lcy5wdXNoKHRoaXMuaW5kZXgpLCBuID09PSBlKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmluZGV4ID0gdGhpcy5idWZmZXIubGVuZ3RoIC0gMSwgITE7XG4gIH1cbiAgLyoqXG4gICAqIENvbW1lbnRzIGFuZCBDREFUQSBlbmQgd2l0aCBgLS0+YCBhbmQgYF1dPmAuXG4gICAqXG4gICAqIFRoZWlyIGNvbW1vbiBxdWFsaXRpZXMgYXJlOlxuICAgKiAtIFRoZWlyIGVuZCBzZXF1ZW5jZXMgaGF2ZSBhIGRpc3RpbmN0IGNoYXJhY3RlciB0aGV5IHN0YXJ0IHdpdGguXG4gICAqIC0gVGhhdCBjaGFyYWN0ZXIgaXMgdGhlbiByZXBlYXRlZCwgc28gd2UgaGF2ZSB0byBjaGVjayBtdWx0aXBsZSByZXBlYXRzLlxuICAgKiAtIEFsbCBjaGFyYWN0ZXJzIGJ1dCB0aGUgc3RhcnQgY2hhcmFjdGVyIG9mIHRoZSBzZXF1ZW5jZSBjYW4gYmUgc2tpcHBlZC5cbiAgICovXG4gIHN0YXRlSW5Db21tZW50TGlrZShlKSB7XG4gICAgZSA9PT0gdGhpcy5jdXJyZW50U2VxdWVuY2VbdGhpcy5zZXF1ZW5jZUluZGV4XSA/ICsrdGhpcy5zZXF1ZW5jZUluZGV4ID09PSB0aGlzLmN1cnJlbnRTZXF1ZW5jZS5sZW5ndGggJiYgKHRoaXMuY3VycmVudFNlcXVlbmNlID09PSBVdC5DZGF0YUVuZCA/IHRoaXMuY2JzLm9uY2RhdGEodGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuaW5kZXggLSAyKSA6IHRoaXMuY2JzLm9uY29tbWVudCh0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCAtIDIpLCB0aGlzLnNlcXVlbmNlSW5kZXggPSAwLCB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXggKyAxLCB0aGlzLnN0YXRlID0gMSkgOiB0aGlzLnNlcXVlbmNlSW5kZXggPT09IDAgPyB0aGlzLmZhc3RGb3J3YXJkVG8odGhpcy5jdXJyZW50U2VxdWVuY2VbMF0pICYmICh0aGlzLnNlcXVlbmNlSW5kZXggPSAxKSA6IGUgIT09IHRoaXMuY3VycmVudFNlcXVlbmNlW3RoaXMuc2VxdWVuY2VJbmRleCAtIDFdICYmICh0aGlzLnNlcXVlbmNlSW5kZXggPSAwKTtcbiAgfVxuICBzdGFydFNwZWNpYWwoZSwgbikge1xuICAgIHRoaXMuZW50ZXJSQ0RBVEEoZSwgbiksIHRoaXMuc3RhdGUgPSAzMTtcbiAgfVxuICBlbnRlclJDREFUQShlLCBuKSB7XG4gICAgdGhpcy5pblJDREFUQSA9ICEwLCB0aGlzLmN1cnJlbnRTZXF1ZW5jZSA9IGUsIHRoaXMuc2VxdWVuY2VJbmRleCA9IG47XG4gIH1cbiAgc3RhdGVCZWZvcmVUYWdOYW1lKGUpIHtcbiAgICBlID09PSAzMyA/ICh0aGlzLnN0YXRlID0gMjIsIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDEpIDogZSA9PT0gNjMgPyAodGhpcy5zdGF0ZSA9IDI0LCB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXggKyAxKSA6IEgwKGUpID8gKHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCwgdGhpcy5tb2RlID09PSAwID8gdGhpcy5zdGF0ZSA9IDYgOiB0aGlzLmluU0ZDUm9vdCA/IHRoaXMuc3RhdGUgPSAzNCA6IHRoaXMuaW5YTUwgPyB0aGlzLnN0YXRlID0gNiA6IGUgPT09IDExNiA/IHRoaXMuc3RhdGUgPSAzMCA6IHRoaXMuc3RhdGUgPSBlID09PSAxMTUgPyAyOSA6IDYpIDogZSA9PT0gNDcgPyB0aGlzLnN0YXRlID0gOCA6ICh0aGlzLnN0YXRlID0gMSwgdGhpcy5zdGF0ZVRleHQoZSkpO1xuICB9XG4gIHN0YXRlSW5UYWdOYW1lKGUpIHtcbiAgICBUaShlKSAmJiB0aGlzLmhhbmRsZVRhZ05hbWUoZSk7XG4gIH1cbiAgc3RhdGVJblNGQ1Jvb3RUYWdOYW1lKGUpIHtcbiAgICBpZiAoVGkoZSkpIHtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLmJ1ZmZlci5zbGljZSh0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCk7XG4gICAgICBuICE9PSBcInRlbXBsYXRlXCIgJiYgdGhpcy5lbnRlclJDREFUQShpZChcIjwvXCIgKyBuKSwgMCksIHRoaXMuaGFuZGxlVGFnTmFtZShlKTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlVGFnTmFtZShlKSB7XG4gICAgdGhpcy5jYnMub25vcGVudGFnbmFtZSh0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCksIHRoaXMuc2VjdGlvblN0YXJ0ID0gLTEsIHRoaXMuc3RhdGUgPSAxMSwgdGhpcy5zdGF0ZUJlZm9yZUF0dHJOYW1lKGUpO1xuICB9XG4gIHN0YXRlQmVmb3JlQ2xvc2luZ1RhZ05hbWUoZSkge1xuICAgIE5uKGUpIHx8IChlID09PSA2MiA/IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgdGhpcy5jYnMub25lcnIoMTQsIHRoaXMuaW5kZXgpLCB0aGlzLnN0YXRlID0gMSwgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4ICsgMSkgOiAodGhpcy5zdGF0ZSA9IEgwKGUpID8gOSA6IDI3LCB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXgpKTtcbiAgfVxuICBzdGF0ZUluQ2xvc2luZ1RhZ05hbWUoZSkge1xuICAgIChlID09PSA2MiB8fCBObihlKSkgJiYgKHRoaXMuY2JzLm9uY2xvc2V0YWcodGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuaW5kZXgpLCB0aGlzLnNlY3Rpb25TdGFydCA9IC0xLCB0aGlzLnN0YXRlID0gMTAsIHRoaXMuc3RhdGVBZnRlckNsb3NpbmdUYWdOYW1lKGUpKTtcbiAgfVxuICBzdGF0ZUFmdGVyQ2xvc2luZ1RhZ05hbWUoZSkge1xuICAgIGUgPT09IDYyICYmICh0aGlzLnN0YXRlID0gMSwgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4ICsgMSk7XG4gIH1cbiAgc3RhdGVCZWZvcmVBdHRyTmFtZShlKSB7XG4gICAgZSA9PT0gNjIgPyAodGhpcy5jYnMub25vcGVudGFnZW5kKHRoaXMuaW5kZXgpLCB0aGlzLmluUkNEQVRBID8gdGhpcy5zdGF0ZSA9IDMyIDogdGhpcy5zdGF0ZSA9IDEsIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDEpIDogZSA9PT0gNDcgPyAodGhpcy5zdGF0ZSA9IDcsIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB0aGlzLnBlZWsoKSAhPT0gNjIgJiYgdGhpcy5jYnMub25lcnIoMjIsIHRoaXMuaW5kZXgpKSA6IGUgPT09IDYwICYmIHRoaXMucGVlaygpID09PSA0NyA/ICh0aGlzLmNicy5vbm9wZW50YWdlbmQodGhpcy5pbmRleCksIHRoaXMuc3RhdGUgPSA1LCB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXgpIDogTm4oZSkgfHwgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBlID09PSA2MSAmJiB0aGlzLmNicy5vbmVycihcbiAgICAgIDE5LFxuICAgICAgdGhpcy5pbmRleFxuICAgICksIHRoaXMuaGFuZGxlQXR0clN0YXJ0KGUpKTtcbiAgfVxuICBoYW5kbGVBdHRyU3RhcnQoZSkge1xuICAgIGUgPT09IDExOCAmJiB0aGlzLnBlZWsoKSA9PT0gNDUgPyAodGhpcy5zdGF0ZSA9IDEzLCB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXgpIDogZSA9PT0gNDYgfHwgZSA9PT0gNTggfHwgZSA9PT0gNjQgfHwgZSA9PT0gMzUgPyAodGhpcy5jYnMub25kaXJuYW1lKHRoaXMuaW5kZXgsIHRoaXMuaW5kZXggKyAxKSwgdGhpcy5zdGF0ZSA9IDE0LCB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXggKyAxKSA6ICh0aGlzLnN0YXRlID0gMTIsIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCk7XG4gIH1cbiAgc3RhdGVJblNlbGZDbG9zaW5nVGFnKGUpIHtcbiAgICBlID09PSA2MiA/ICh0aGlzLmNicy5vbnNlbGZjbG9zaW5ndGFnKHRoaXMuaW5kZXgpLCB0aGlzLnN0YXRlID0gMSwgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4ICsgMSwgdGhpcy5pblJDREFUQSA9ICExKSA6IE5uKGUpIHx8ICh0aGlzLnN0YXRlID0gMTEsIHRoaXMuc3RhdGVCZWZvcmVBdHRyTmFtZShlKSk7XG4gIH1cbiAgc3RhdGVJbkF0dHJOYW1lKGUpIHtcbiAgICBlID09PSA2MSB8fCBUaShlKSA/ICh0aGlzLmNicy5vbmF0dHJpYm5hbWUodGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuaW5kZXgpLCB0aGlzLmhhbmRsZUF0dHJOYW1lRW5kKGUpKSA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiAoZSA9PT0gMzQgfHwgZSA9PT0gMzkgfHwgZSA9PT0gNjApICYmIHRoaXMuY2JzLm9uZXJyKFxuICAgICAgMTcsXG4gICAgICB0aGlzLmluZGV4XG4gICAgKTtcbiAgfVxuICBzdGF0ZUluRGlyTmFtZShlKSB7XG4gICAgZSA9PT0gNjEgfHwgVGkoZSkgPyAodGhpcy5jYnMub25kaXJuYW1lKHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmluZGV4KSwgdGhpcy5oYW5kbGVBdHRyTmFtZUVuZChlKSkgOiBlID09PSA1OCA/ICh0aGlzLmNicy5vbmRpcm5hbWUodGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuaW5kZXgpLCB0aGlzLnN0YXRlID0gMTQsIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDEpIDogZSA9PT0gNDYgJiYgKHRoaXMuY2JzLm9uZGlybmFtZSh0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCksIHRoaXMuc3RhdGUgPSAxNiwgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4ICsgMSk7XG4gIH1cbiAgc3RhdGVJbkRpckFyZyhlKSB7XG4gICAgZSA9PT0gNjEgfHwgVGkoZSkgPyAodGhpcy5jYnMub25kaXJhcmcodGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuaW5kZXgpLCB0aGlzLmhhbmRsZUF0dHJOYW1lRW5kKGUpKSA6IGUgPT09IDkxID8gdGhpcy5zdGF0ZSA9IDE1IDogZSA9PT0gNDYgJiYgKHRoaXMuY2JzLm9uZGlyYXJnKHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmluZGV4KSwgdGhpcy5zdGF0ZSA9IDE2LCB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXggKyAxKTtcbiAgfVxuICBzdGF0ZUluRHluYW1pY0RpckFyZyhlKSB7XG4gICAgZSA9PT0gOTMgPyB0aGlzLnN0YXRlID0gMTQgOiAoZSA9PT0gNjEgfHwgVGkoZSkpICYmICh0aGlzLmNicy5vbmRpcmFyZyh0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCArIDEpLCB0aGlzLmhhbmRsZUF0dHJOYW1lRW5kKGUpLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgdGhpcy5jYnMub25lcnIoXG4gICAgICAyNyxcbiAgICAgIHRoaXMuaW5kZXhcbiAgICApKTtcbiAgfVxuICBzdGF0ZUluRGlyTW9kaWZpZXIoZSkge1xuICAgIGUgPT09IDYxIHx8IFRpKGUpID8gKHRoaXMuY2JzLm9uZGlybW9kaWZpZXIodGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuaW5kZXgpLCB0aGlzLmhhbmRsZUF0dHJOYW1lRW5kKGUpKSA6IGUgPT09IDQ2ICYmICh0aGlzLmNicy5vbmRpcm1vZGlmaWVyKHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmluZGV4KSwgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4ICsgMSk7XG4gIH1cbiAgaGFuZGxlQXR0ck5hbWVFbmQoZSkge1xuICAgIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCwgdGhpcy5zdGF0ZSA9IDE3LCB0aGlzLmNicy5vbmF0dHJpYm5hbWVlbmQodGhpcy5pbmRleCksIHRoaXMuc3RhdGVBZnRlckF0dHJOYW1lKGUpO1xuICB9XG4gIHN0YXRlQWZ0ZXJBdHRyTmFtZShlKSB7XG4gICAgZSA9PT0gNjEgPyB0aGlzLnN0YXRlID0gMTggOiBlID09PSA0NyB8fCBlID09PSA2MiA/ICh0aGlzLmNicy5vbmF0dHJpYmVuZCgwLCB0aGlzLnNlY3Rpb25TdGFydCksIHRoaXMuc2VjdGlvblN0YXJ0ID0gLTEsIHRoaXMuc3RhdGUgPSAxMSwgdGhpcy5zdGF0ZUJlZm9yZUF0dHJOYW1lKGUpKSA6IE5uKGUpIHx8ICh0aGlzLmNicy5vbmF0dHJpYmVuZCgwLCB0aGlzLnNlY3Rpb25TdGFydCksIHRoaXMuaGFuZGxlQXR0clN0YXJ0KGUpKTtcbiAgfVxuICBzdGF0ZUJlZm9yZUF0dHJWYWx1ZShlKSB7XG4gICAgZSA9PT0gMzQgPyAodGhpcy5zdGF0ZSA9IDE5LCB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXggKyAxKSA6IGUgPT09IDM5ID8gKHRoaXMuc3RhdGUgPSAyMCwgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4ICsgMSkgOiBObihlKSB8fCAodGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4LCB0aGlzLnN0YXRlID0gMjEsIHRoaXMuc3RhdGVJbkF0dHJWYWx1ZU5vUXVvdGVzKGUpKTtcbiAgfVxuICBoYW5kbGVJbkF0dHJWYWx1ZShlLCBuKSB7XG4gICAgKGUgPT09IG4gfHwgdGhpcy5mYXN0Rm9yd2FyZFRvKG4pKSAmJiAodGhpcy5jYnMub25hdHRyaWJkYXRhKHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmluZGV4KSwgdGhpcy5zZWN0aW9uU3RhcnQgPSAtMSwgdGhpcy5jYnMub25hdHRyaWJlbmQoXG4gICAgICBuID09PSAzNCA/IDMgOiAyLFxuICAgICAgdGhpcy5pbmRleCArIDFcbiAgICApLCB0aGlzLnN0YXRlID0gMTEpO1xuICB9XG4gIHN0YXRlSW5BdHRyVmFsdWVEb3VibGVRdW90ZXMoZSkge1xuICAgIHRoaXMuaGFuZGxlSW5BdHRyVmFsdWUoZSwgMzQpO1xuICB9XG4gIHN0YXRlSW5BdHRyVmFsdWVTaW5nbGVRdW90ZXMoZSkge1xuICAgIHRoaXMuaGFuZGxlSW5BdHRyVmFsdWUoZSwgMzkpO1xuICB9XG4gIHN0YXRlSW5BdHRyVmFsdWVOb1F1b3RlcyhlKSB7XG4gICAgTm4oZSkgfHwgZSA9PT0gNjIgPyAodGhpcy5jYnMub25hdHRyaWJkYXRhKHRoaXMuc2VjdGlvblN0YXJ0LCB0aGlzLmluZGV4KSwgdGhpcy5zZWN0aW9uU3RhcnQgPSAtMSwgdGhpcy5jYnMub25hdHRyaWJlbmQoMSwgdGhpcy5pbmRleCksIHRoaXMuc3RhdGUgPSAxMSwgdGhpcy5zdGF0ZUJlZm9yZUF0dHJOYW1lKGUpKSA6IChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZSA9PT0gMzQgfHwgZSA9PT0gMzkgfHwgZSA9PT0gNjAgfHwgZSA9PT0gNjEgfHwgZSA9PT0gOTYpICYmIHRoaXMuY2JzLm9uZXJyKFxuICAgICAgMTgsXG4gICAgICB0aGlzLmluZGV4XG4gICAgKTtcbiAgfVxuICBzdGF0ZUJlZm9yZURlY2xhcmF0aW9uKGUpIHtcbiAgICBlID09PSA5MSA/ICh0aGlzLnN0YXRlID0gMjYsIHRoaXMuc2VxdWVuY2VJbmRleCA9IDApIDogdGhpcy5zdGF0ZSA9IGUgPT09IDQ1ID8gMjUgOiAyMztcbiAgfVxuICBzdGF0ZUluRGVjbGFyYXRpb24oZSkge1xuICAgIChlID09PSA2MiB8fCB0aGlzLmZhc3RGb3J3YXJkVG8oNjIpKSAmJiAodGhpcy5zdGF0ZSA9IDEsIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCArIDEpO1xuICB9XG4gIHN0YXRlSW5Qcm9jZXNzaW5nSW5zdHJ1Y3Rpb24oZSkge1xuICAgIChlID09PSA2MiB8fCB0aGlzLmZhc3RGb3J3YXJkVG8oNjIpKSAmJiAodGhpcy5jYnMub25wcm9jZXNzaW5naW5zdHJ1Y3Rpb24odGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuaW5kZXgpLCB0aGlzLnN0YXRlID0gMSwgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4ICsgMSk7XG4gIH1cbiAgc3RhdGVCZWZvcmVDb21tZW50KGUpIHtcbiAgICBlID09PSA0NSA/ICh0aGlzLnN0YXRlID0gMjgsIHRoaXMuY3VycmVudFNlcXVlbmNlID0gVXQuQ29tbWVudEVuZCwgdGhpcy5zZXF1ZW5jZUluZGV4ID0gMiwgdGhpcy5zZWN0aW9uU3RhcnQgPSB0aGlzLmluZGV4ICsgMSkgOiB0aGlzLnN0YXRlID0gMjM7XG4gIH1cbiAgc3RhdGVJblNwZWNpYWxDb21tZW50KGUpIHtcbiAgICAoZSA9PT0gNjIgfHwgdGhpcy5mYXN0Rm9yd2FyZFRvKDYyKSkgJiYgKHRoaXMuY2JzLm9uY29tbWVudCh0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCksIHRoaXMuc3RhdGUgPSAxLCB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXggKyAxKTtcbiAgfVxuICBzdGF0ZUJlZm9yZVNwZWNpYWxTKGUpIHtcbiAgICBlID09PSBVdC5TY3JpcHRFbmRbM10gPyB0aGlzLnN0YXJ0U3BlY2lhbChVdC5TY3JpcHRFbmQsIDQpIDogZSA9PT0gVXQuU3R5bGVFbmRbM10gPyB0aGlzLnN0YXJ0U3BlY2lhbChVdC5TdHlsZUVuZCwgNCkgOiAodGhpcy5zdGF0ZSA9IDYsIHRoaXMuc3RhdGVJblRhZ05hbWUoZSkpO1xuICB9XG4gIHN0YXRlQmVmb3JlU3BlY2lhbFQoZSkge1xuICAgIGUgPT09IFV0LlRpdGxlRW5kWzNdID8gdGhpcy5zdGFydFNwZWNpYWwoVXQuVGl0bGVFbmQsIDQpIDogZSA9PT0gVXQuVGV4dGFyZWFFbmRbM10gPyB0aGlzLnN0YXJ0U3BlY2lhbChVdC5UZXh0YXJlYUVuZCwgNCkgOiAodGhpcy5zdGF0ZSA9IDYsIHRoaXMuc3RhdGVJblRhZ05hbWUoZSkpO1xuICB9XG4gIHN0YXJ0RW50aXR5KCkge1xuICB9XG4gIHN0YXRlSW5FbnRpdHkoKSB7XG4gIH1cbiAgLyoqXG4gICAqIEl0ZXJhdGVzIHRocm91Z2ggdGhlIGJ1ZmZlciwgY2FsbGluZyB0aGUgZnVuY3Rpb24gY29ycmVzcG9uZGluZyB0byB0aGUgY3VycmVudCBzdGF0ZS5cbiAgICpcbiAgICogU3RhdGVzIHRoYXQgYXJlIG1vcmUgbGlrZWx5IHRvIGJlIGhpdCBhcmUgaGlnaGVyIHVwLCBhcyBhIHBlcmZvcm1hbmNlIGltcHJvdmVtZW50LlxuICAgKi9cbiAgcGFyc2UoZSkge1xuICAgIGZvciAodGhpcy5idWZmZXIgPSBlOyB0aGlzLmluZGV4IDwgdGhpcy5idWZmZXIubGVuZ3RoOyApIHtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLmJ1ZmZlci5jaGFyQ29kZUF0KHRoaXMuaW5kZXgpO1xuICAgICAgc3dpdGNoIChuID09PSAxMCAmJiB0aGlzLm5ld2xpbmVzLnB1c2godGhpcy5pbmRleCksIHRoaXMuc3RhdGUpIHtcbiAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgdGhpcy5zdGF0ZVRleHQobik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAyOiB7XG4gICAgICAgICAgdGhpcy5zdGF0ZUludGVycG9sYXRpb25PcGVuKG4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMzoge1xuICAgICAgICAgIHRoaXMuc3RhdGVJbnRlcnBvbGF0aW9uKG4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgNDoge1xuICAgICAgICAgIHRoaXMuc3RhdGVJbnRlcnBvbGF0aW9uQ2xvc2Uobik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAzMToge1xuICAgICAgICAgIHRoaXMuc3RhdGVTcGVjaWFsU3RhcnRTZXF1ZW5jZShuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDMyOiB7XG4gICAgICAgICAgdGhpcy5zdGF0ZUluUkNEQVRBKG4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMjY6IHtcbiAgICAgICAgICB0aGlzLnN0YXRlQ0RBVEFTZXF1ZW5jZShuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDE5OiB7XG4gICAgICAgICAgdGhpcy5zdGF0ZUluQXR0clZhbHVlRG91YmxlUXVvdGVzKG4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMTI6IHtcbiAgICAgICAgICB0aGlzLnN0YXRlSW5BdHRyTmFtZShuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDEzOiB7XG4gICAgICAgICAgdGhpcy5zdGF0ZUluRGlyTmFtZShuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDE0OiB7XG4gICAgICAgICAgdGhpcy5zdGF0ZUluRGlyQXJnKG4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMTU6IHtcbiAgICAgICAgICB0aGlzLnN0YXRlSW5EeW5hbWljRGlyQXJnKG4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMTY6IHtcbiAgICAgICAgICB0aGlzLnN0YXRlSW5EaXJNb2RpZmllcihuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDI4OiB7XG4gICAgICAgICAgdGhpcy5zdGF0ZUluQ29tbWVudExpa2Uobik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAyNzoge1xuICAgICAgICAgIHRoaXMuc3RhdGVJblNwZWNpYWxDb21tZW50KG4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMTE6IHtcbiAgICAgICAgICB0aGlzLnN0YXRlQmVmb3JlQXR0ck5hbWUobik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSA2OiB7XG4gICAgICAgICAgdGhpcy5zdGF0ZUluVGFnTmFtZShuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDM0OiB7XG4gICAgICAgICAgdGhpcy5zdGF0ZUluU0ZDUm9vdFRhZ05hbWUobik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSA5OiB7XG4gICAgICAgICAgdGhpcy5zdGF0ZUluQ2xvc2luZ1RhZ05hbWUobik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSA1OiB7XG4gICAgICAgICAgdGhpcy5zdGF0ZUJlZm9yZVRhZ05hbWUobik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAxNzoge1xuICAgICAgICAgIHRoaXMuc3RhdGVBZnRlckF0dHJOYW1lKG4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMjA6IHtcbiAgICAgICAgICB0aGlzLnN0YXRlSW5BdHRyVmFsdWVTaW5nbGVRdW90ZXMobik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAxODoge1xuICAgICAgICAgIHRoaXMuc3RhdGVCZWZvcmVBdHRyVmFsdWUobik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSA4OiB7XG4gICAgICAgICAgdGhpcy5zdGF0ZUJlZm9yZUNsb3NpbmdUYWdOYW1lKG4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMTA6IHtcbiAgICAgICAgICB0aGlzLnN0YXRlQWZ0ZXJDbG9zaW5nVGFnTmFtZShuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDI5OiB7XG4gICAgICAgICAgdGhpcy5zdGF0ZUJlZm9yZVNwZWNpYWxTKG4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMzA6IHtcbiAgICAgICAgICB0aGlzLnN0YXRlQmVmb3JlU3BlY2lhbFQobik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAyMToge1xuICAgICAgICAgIHRoaXMuc3RhdGVJbkF0dHJWYWx1ZU5vUXVvdGVzKG4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgNzoge1xuICAgICAgICAgIHRoaXMuc3RhdGVJblNlbGZDbG9zaW5nVGFnKG4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMjM6IHtcbiAgICAgICAgICB0aGlzLnN0YXRlSW5EZWNsYXJhdGlvbihuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDIyOiB7XG4gICAgICAgICAgdGhpcy5zdGF0ZUJlZm9yZURlY2xhcmF0aW9uKG4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMjU6IHtcbiAgICAgICAgICB0aGlzLnN0YXRlQmVmb3JlQ29tbWVudChuKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDI0OiB7XG4gICAgICAgICAgdGhpcy5zdGF0ZUluUHJvY2Vzc2luZ0luc3RydWN0aW9uKG4pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMzM6IHtcbiAgICAgICAgICB0aGlzLnN0YXRlSW5FbnRpdHkoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5pbmRleCsrO1xuICAgIH1cbiAgICB0aGlzLmNsZWFudXAoKSwgdGhpcy5maW5pc2goKTtcbiAgfVxuICAvKipcbiAgICogUmVtb3ZlIGRhdGEgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIGNvbnN1bWVkIGZyb20gdGhlIGJ1ZmZlci5cbiAgICovXG4gIGNsZWFudXAoKSB7XG4gICAgdGhpcy5zZWN0aW9uU3RhcnQgIT09IHRoaXMuaW5kZXggJiYgKHRoaXMuc3RhdGUgPT09IDEgfHwgdGhpcy5zdGF0ZSA9PT0gMzIgJiYgdGhpcy5zZXF1ZW5jZUluZGV4ID09PSAwID8gKHRoaXMuY2JzLm9udGV4dCh0aGlzLnNlY3Rpb25TdGFydCwgdGhpcy5pbmRleCksIHRoaXMuc2VjdGlvblN0YXJ0ID0gdGhpcy5pbmRleCkgOiAodGhpcy5zdGF0ZSA9PT0gMTkgfHwgdGhpcy5zdGF0ZSA9PT0gMjAgfHwgdGhpcy5zdGF0ZSA9PT0gMjEpICYmICh0aGlzLmNicy5vbmF0dHJpYmRhdGEodGhpcy5zZWN0aW9uU3RhcnQsIHRoaXMuaW5kZXgpLCB0aGlzLnNlY3Rpb25TdGFydCA9IHRoaXMuaW5kZXgpKTtcbiAgfVxuICBmaW5pc2goKSB7XG4gICAgdGhpcy5oYW5kbGVUcmFpbGluZ0RhdGEoKSwgdGhpcy5jYnMub25lbmQoKTtcbiAgfVxuICAvKiogSGFuZGxlIGFueSB0cmFpbGluZyBkYXRhLiAqL1xuICBoYW5kbGVUcmFpbGluZ0RhdGEoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuYnVmZmVyLmxlbmd0aDtcbiAgICB0aGlzLnNlY3Rpb25TdGFydCA+PSBlIHx8ICh0aGlzLnN0YXRlID09PSAyOCA/IHRoaXMuY3VycmVudFNlcXVlbmNlID09PSBVdC5DZGF0YUVuZCA/IHRoaXMuY2JzLm9uY2RhdGEodGhpcy5zZWN0aW9uU3RhcnQsIGUpIDogdGhpcy5jYnMub25jb21tZW50KHRoaXMuc2VjdGlvblN0YXJ0LCBlKSA6IHRoaXMuc3RhdGUgPT09IDYgfHwgdGhpcy5zdGF0ZSA9PT0gMTEgfHwgdGhpcy5zdGF0ZSA9PT0gMTggfHwgdGhpcy5zdGF0ZSA9PT0gMTcgfHwgdGhpcy5zdGF0ZSA9PT0gMTIgfHwgdGhpcy5zdGF0ZSA9PT0gMTMgfHwgdGhpcy5zdGF0ZSA9PT0gMTQgfHwgdGhpcy5zdGF0ZSA9PT0gMTUgfHwgdGhpcy5zdGF0ZSA9PT0gMTYgfHwgdGhpcy5zdGF0ZSA9PT0gMjAgfHwgdGhpcy5zdGF0ZSA9PT0gMTkgfHwgdGhpcy5zdGF0ZSA9PT0gMjEgfHwgdGhpcy5zdGF0ZSA9PT0gOSB8fCB0aGlzLmNicy5vbnRleHQodGhpcy5zZWN0aW9uU3RhcnQsIGUpKTtcbiAgfVxuICBlbWl0Q29kZVBvaW50KGUsIG4pIHtcbiAgfVxufVxuY29uc3QgVjQgPSB7XG4gIENPTVBJTEVSX0lTX09OX0VMRU1FTlQ6IHtcbiAgICBtZXNzYWdlOiAnUGxhdGZvcm0tbmF0aXZlIGVsZW1lbnRzIHdpdGggXCJpc1wiIHByb3Agd2lsbCBubyBsb25nZXIgYmUgdHJlYXRlZCBhcyBjb21wb25lbnRzIGluIFZ1ZSAzIHVubGVzcyB0aGUgXCJpc1wiIHZhbHVlIGlzIGV4cGxpY2l0bHkgcHJlZml4ZWQgd2l0aCBcInZ1ZTpcIi4nLFxuICAgIGxpbms6IFwiaHR0cHM6Ly92My1taWdyYXRpb24udnVlanMub3JnL2JyZWFraW5nLWNoYW5nZXMvY3VzdG9tLWVsZW1lbnRzLWludGVyb3AuaHRtbFwiXG4gIH0sXG4gIENPTVBJTEVSX1ZfQklORF9TWU5DOiB7XG4gICAgbWVzc2FnZTogKHQpID0+IGAuc3luYyBtb2RpZmllciBmb3Igdi1iaW5kIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2LW1vZGVsIHdpdGggYXJndW1lbnQgaW5zdGVhZC4gXFxgdi1iaW5kOiR7dH0uc3luY1xcYCBzaG91bGQgYmUgY2hhbmdlZCB0byBcXGB2LW1vZGVsOiR7dH1cXGAuYCxcbiAgICBsaW5rOiBcImh0dHBzOi8vdjMtbWlncmF0aW9uLnZ1ZWpzLm9yZy9icmVha2luZy1jaGFuZ2VzL3YtbW9kZWwuaHRtbFwiXG4gIH0sXG4gIENPTVBJTEVSX1ZfQklORF9PQkpFQ1RfT1JERVI6IHtcbiAgICBtZXNzYWdlOiAndi1iaW5kPVwib2JqXCIgdXNhZ2UgaXMgbm93IG9yZGVyIHNlbnNpdGl2ZSBhbmQgYmVoYXZlcyBsaWtlIEphdmFTY3JpcHQgb2JqZWN0IHNwcmVhZDogaXQgd2lsbCBub3cgb3ZlcndyaXRlIGFuIGV4aXN0aW5nIG5vbi1tZXJnZWFibGUgYXR0cmlidXRlIHRoYXQgYXBwZWFycyBiZWZvcmUgdi1iaW5kIGluIHRoZSBjYXNlIG9mIGNvbmZsaWN0LiBUbyByZXRhaW4gMi54IGJlaGF2aW9yLCBtb3ZlIHYtYmluZCB0byBtYWtlIGl0IHRoZSBmaXJzdCBhdHRyaWJ1dGUuIFlvdSBjYW4gYWxzbyBzdXBwcmVzcyB0aGlzIHdhcm5pbmcgaWYgdGhlIHVzYWdlIGlzIGludGVuZGVkLicsXG4gICAgbGluazogXCJodHRwczovL3YzLW1pZ3JhdGlvbi52dWVqcy5vcmcvYnJlYWtpbmctY2hhbmdlcy92LWJpbmQuaHRtbFwiXG4gIH0sXG4gIENPTVBJTEVSX1ZfT05fTkFUSVZFOiB7XG4gICAgbWVzc2FnZTogXCIubmF0aXZlIG1vZGlmaWVyIGZvciB2LW9uIGhhcyBiZWVuIHJlbW92ZWQgYXMgaXMgbm8gbG9uZ2VyIG5lY2Vzc2FyeS5cIixcbiAgICBsaW5rOiBcImh0dHBzOi8vdjMtbWlncmF0aW9uLnZ1ZWpzLm9yZy9icmVha2luZy1jaGFuZ2VzL3Ytb24tbmF0aXZlLW1vZGlmaWVyLXJlbW92ZWQuaHRtbFwiXG4gIH0sXG4gIENPTVBJTEVSX1ZfSUZfVl9GT1JfUFJFQ0VERU5DRToge1xuICAgIG1lc3NhZ2U6IFwidi1pZiAvIHYtZm9yIHByZWNlZGVuY2Ugd2hlbiB1c2VkIG9uIHRoZSBzYW1lIGVsZW1lbnQgaGFzIGNoYW5nZWQgaW4gVnVlIDM6IHYtaWYgbm93IHRha2VzIGhpZ2hlciBwcmVjZWRlbmNlIGFuZCB3aWxsIG5vIGxvbmdlciBoYXZlIGFjY2VzcyB0byB2LWZvciBzY29wZSB2YXJpYWJsZXMuIEl0IGlzIGJlc3QgdG8gYXZvaWQgdGhlIGFtYmlndWl0eSB3aXRoIDx0ZW1wbGF0ZT4gdGFncyBvciB1c2UgYSBjb21wdXRlZCBwcm9wZXJ0eSB0aGF0IGZpbHRlcnMgdi1mb3IgZGF0YSBzb3VyY2UuXCIsXG4gICAgbGluazogXCJodHRwczovL3YzLW1pZ3JhdGlvbi52dWVqcy5vcmcvYnJlYWtpbmctY2hhbmdlcy92LWlmLXYtZm9yLmh0bWxcIlxuICB9LFxuICBDT01QSUxFUl9OQVRJVkVfVEVNUExBVEU6IHtcbiAgICBtZXNzYWdlOiBcIjx0ZW1wbGF0ZT4gd2l0aCBubyBzcGVjaWFsIGRpcmVjdGl2ZXMgd2lsbCByZW5kZXIgYXMgYSBuYXRpdmUgdGVtcGxhdGUgZWxlbWVudCBpbnN0ZWFkIG9mIGl0cyBpbm5lciBjb250ZW50IGluIFZ1ZSAzLlwiXG4gIH0sXG4gIENPTVBJTEVSX0lOTElORV9URU1QTEFURToge1xuICAgIG1lc3NhZ2U6ICdcImlubGluZS10ZW1wbGF0ZVwiIGhhcyBiZWVuIHJlbW92ZWQgaW4gVnVlIDMuJyxcbiAgICBsaW5rOiBcImh0dHBzOi8vdjMtbWlncmF0aW9uLnZ1ZWpzLm9yZy9icmVha2luZy1jaGFuZ2VzL2lubGluZS10ZW1wbGF0ZS1hdHRyaWJ1dGUuaHRtbFwiXG4gIH0sXG4gIENPTVBJTEVSX0ZJTFRFUlM6IHtcbiAgICBtZXNzYWdlOiAnZmlsdGVycyBoYXZlIGJlZW4gcmVtb3ZlZCBpbiBWdWUgMy4gVGhlIFwifFwiIHN5bWJvbCB3aWxsIGJlIHRyZWF0ZWQgYXMgbmF0aXZlIEphdmFTY3JpcHQgYml0d2lzZSBPUiBvcGVyYXRvci4gVXNlIG1ldGhvZCBjYWxscyBvciBjb21wdXRlZCBwcm9wZXJ0aWVzIGluc3RlYWQuJyxcbiAgICBsaW5rOiBcImh0dHBzOi8vdjMtbWlncmF0aW9uLnZ1ZWpzLm9yZy9icmVha2luZy1jaGFuZ2VzL2ZpbHRlcnMuaHRtbFwiXG4gIH1cbn07XG5mdW5jdGlvbiBMcCh0LCB7IGNvbXBhdENvbmZpZzogZSB9KSB7XG4gIGNvbnN0IG4gPSBlICYmIGVbdF07XG4gIHJldHVybiB0ID09PSBcIk1PREVcIiA/IG4gfHwgMyA6IG47XG59XG5mdW5jdGlvbiBlcyh0LCBlKSB7XG4gIGNvbnN0IG4gPSBMcChcIk1PREVcIiwgZSksIHIgPSBMcCh0LCBlKTtcbiAgcmV0dXJuIG4gPT09IDMgPyByID09PSAhMCA6IHIgIT09ICExO1xufVxuZnVuY3Rpb24gSm8odCwgZSwgbiwgLi4ucikge1xuICBjb25zdCBpID0gZXModCwgZSk7XG4gIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgaSAmJiBzZCh0LCBlLCBuLCAuLi5yKSwgaTtcbn1cbmZ1bmN0aW9uIHNkKHQsIGUsIG4sIC4uLnIpIHtcbiAgaWYgKExwKHQsIGUpID09PSBcInN1cHByZXNzLXdhcm5pbmdcIilcbiAgICByZXR1cm47XG4gIGNvbnN0IHsgbWVzc2FnZTogcywgbGluazogbyB9ID0gVjRbdF0sIGEgPSBgKGRlcHJlY2F0aW9uICR7dH0pICR7dHlwZW9mIHMgPT0gXCJmdW5jdGlvblwiID8gcyguLi5yKSA6IHN9JHtvID8gYFxuICBEZXRhaWxzOiAke299YCA6IFwiXCJ9YCwgbCA9IG5ldyBTeW50YXhFcnJvcihhKTtcbiAgbC5jb2RlID0gdCwgbiAmJiAobC5sb2MgPSBuKSwgZS5vbldhcm4obCk7XG59XG5mdW5jdGlvbiBZZyh0KSB7XG4gIHRocm93IHQ7XG59XG5mdW5jdGlvbiBqUCh0KSB7XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBjb25zb2xlLndhcm4oYFtWdWUgd2Fybl0gJHt0Lm1lc3NhZ2V9YCk7XG59XG5mdW5jdGlvbiBHZSh0LCBlLCBuLCByKSB7XG4gIGNvbnN0IGkgPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyAobiB8fCBJNClbdF0gKyAociB8fCBcIlwiKSA6IGBodHRwczovL3Z1ZWpzLm9yZy9lcnJvci1yZWZlcmVuY2UvI2NvbXBpbGVyLSR7dH1gLCBzID0gbmV3IFN5bnRheEVycm9yKFN0cmluZyhpKSk7XG4gIHJldHVybiBzLmNvZGUgPSB0LCBzLmxvYyA9IGUsIHM7XG59XG5jb25zdCBJNCA9IHtcbiAgLy8gcGFyc2UgZXJyb3JzXG4gIDA6IFwiSWxsZWdhbCBjb21tZW50LlwiLFxuICAxOiBcIkNEQVRBIHNlY3Rpb24gaXMgYWxsb3dlZCBvbmx5IGluIFhNTCBjb250ZXh0LlwiLFxuICAyOiBcIkR1cGxpY2F0ZSBhdHRyaWJ1dGUuXCIsXG4gIDM6IFwiRW5kIHRhZyBjYW5ub3QgaGF2ZSBhdHRyaWJ1dGVzLlwiLFxuICA0OiBcIklsbGVnYWwgJy8nIGluIHRhZ3MuXCIsXG4gIDU6IFwiVW5leHBlY3RlZCBFT0YgaW4gdGFnLlwiLFxuICA2OiBcIlVuZXhwZWN0ZWQgRU9GIGluIENEQVRBIHNlY3Rpb24uXCIsXG4gIDc6IFwiVW5leHBlY3RlZCBFT0YgaW4gY29tbWVudC5cIixcbiAgODogXCJVbmV4cGVjdGVkIEVPRiBpbiBzY3JpcHQuXCIsXG4gIDk6IFwiVW5leHBlY3RlZCBFT0YgaW4gdGFnLlwiLFxuICAxMDogXCJJbmNvcnJlY3RseSBjbG9zZWQgY29tbWVudC5cIixcbiAgMTE6IFwiSW5jb3JyZWN0bHkgb3BlbmVkIGNvbW1lbnQuXCIsXG4gIDEyOiBcIklsbGVnYWwgdGFnIG5hbWUuIFVzZSAnJmx0OycgdG8gcHJpbnQgJzwnLlwiLFxuICAxMzogXCJBdHRyaWJ1dGUgdmFsdWUgd2FzIGV4cGVjdGVkLlwiLFxuICAxNDogXCJFbmQgdGFnIG5hbWUgd2FzIGV4cGVjdGVkLlwiLFxuICAxNTogXCJXaGl0ZXNwYWNlIHdhcyBleHBlY3RlZC5cIixcbiAgMTY6IFwiVW5leHBlY3RlZCAnPCEtLScgaW4gY29tbWVudC5cIixcbiAgMTc6IGBBdHRyaWJ1dGUgbmFtZSBjYW5ub3QgY29udGFpbiBVKzAwMjIgKFwiKSwgVSswMDI3ICgnKSwgYW5kIFUrMDAzQyAoPCkuYCxcbiAgMTg6IFwiVW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlIGNhbm5vdCBjb250YWluIFUrMDAyMiAoXFxcIiksIFUrMDAyNyAoJyksIFUrMDAzQyAoPCksIFUrMDAzRCAoPSksIGFuZCBVKzAwNjAgKGApLlwiLFxuICAxOTogXCJBdHRyaWJ1dGUgbmFtZSBjYW5ub3Qgc3RhcnQgd2l0aCAnPScuXCIsXG4gIDIxOiBcIic8PycgaXMgYWxsb3dlZCBvbmx5IGluIFhNTCBjb250ZXh0LlwiLFxuICAyMDogXCJVbmV4cGVjdGVkIG51bGwgY2hhcmFjdGVyLlwiLFxuICAyMjogXCJJbGxlZ2FsICcvJyBpbiB0YWdzLlwiLFxuICAvLyBWdWUtc3BlY2lmaWMgcGFyc2UgZXJyb3JzXG4gIDIzOiBcIkludmFsaWQgZW5kIHRhZy5cIixcbiAgMjQ6IFwiRWxlbWVudCBpcyBtaXNzaW5nIGVuZCB0YWcuXCIsXG4gIDI1OiBcIkludGVycG9sYXRpb24gZW5kIHNpZ24gd2FzIG5vdCBmb3VuZC5cIixcbiAgMjc6IFwiRW5kIGJyYWNrZXQgZm9yIGR5bmFtaWMgZGlyZWN0aXZlIGFyZ3VtZW50IHdhcyBub3QgZm91bmQuIE5vdGUgdGhhdCBkeW5hbWljIGRpcmVjdGl2ZSBhcmd1bWVudCBjYW5ub3QgY29udGFpbiBzcGFjZXMuXCIsXG4gIDI2OiBcIkxlZ2FsIGRpcmVjdGl2ZSBuYW1lIHdhcyBleHBlY3RlZC5cIixcbiAgLy8gdHJhbnNmb3JtIGVycm9yc1xuICAyODogXCJ2LWlmL3YtZWxzZS1pZiBpcyBtaXNzaW5nIGV4cHJlc3Npb24uXCIsXG4gIDI5OiBcInYtaWYvZWxzZSBicmFuY2hlcyBtdXN0IHVzZSB1bmlxdWUga2V5cy5cIixcbiAgMzA6IFwidi1lbHNlL3YtZWxzZS1pZiBoYXMgbm8gYWRqYWNlbnQgdi1pZiBvciB2LWVsc2UtaWYuXCIsXG4gIDMxOiBcInYtZm9yIGlzIG1pc3NpbmcgZXhwcmVzc2lvbi5cIixcbiAgMzI6IFwidi1mb3IgaGFzIGludmFsaWQgZXhwcmVzc2lvbi5cIixcbiAgMzM6IFwiPHRlbXBsYXRlIHYtZm9yPiBrZXkgc2hvdWxkIGJlIHBsYWNlZCBvbiB0aGUgPHRlbXBsYXRlPiB0YWcuXCIsXG4gIDM0OiBcInYtYmluZCBpcyBtaXNzaW5nIGV4cHJlc3Npb24uXCIsXG4gIDUyOiBcInYtYmluZCB3aXRoIHNhbWUtbmFtZSBzaG9ydGhhbmQgb25seSBhbGxvd3Mgc3RhdGljIGFyZ3VtZW50LlwiLFxuICAzNTogXCJ2LW9uIGlzIG1pc3NpbmcgZXhwcmVzc2lvbi5cIixcbiAgMzY6IFwiVW5leHBlY3RlZCBjdXN0b20gZGlyZWN0aXZlIG9uIDxzbG90PiBvdXRsZXQuXCIsXG4gIDM3OiBcIk1peGVkIHYtc2xvdCB1c2FnZSBvbiBib3RoIHRoZSBjb21wb25lbnQgYW5kIG5lc3RlZCA8dGVtcGxhdGU+LiBXaGVuIHRoZXJlIGFyZSBtdWx0aXBsZSBuYW1lZCBzbG90cywgYWxsIHNsb3RzIHNob3VsZCB1c2UgPHRlbXBsYXRlPiBzeW50YXggdG8gYXZvaWQgc2NvcGUgYW1iaWd1aXR5LlwiLFxuICAzODogXCJEdXBsaWNhdGUgc2xvdCBuYW1lcyBmb3VuZC4gXCIsXG4gIDM5OiBcIkV4dHJhbmVvdXMgY2hpbGRyZW4gZm91bmQgd2hlbiBjb21wb25lbnQgYWxyZWFkeSBoYXMgZXhwbGljaXRseSBuYW1lZCBkZWZhdWx0IHNsb3QuIFRoZXNlIGNoaWxkcmVuIHdpbGwgYmUgaWdub3JlZC5cIixcbiAgNDA6IFwidi1zbG90IGNhbiBvbmx5IGJlIHVzZWQgb24gY29tcG9uZW50cyBvciA8dGVtcGxhdGU+IHRhZ3MuXCIsXG4gIDQxOiBcInYtbW9kZWwgaXMgbWlzc2luZyBleHByZXNzaW9uLlwiLFxuICA0MjogXCJ2LW1vZGVsIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBKYXZhU2NyaXB0IG1lbWJlciBleHByZXNzaW9uLlwiLFxuICA0MzogXCJ2LW1vZGVsIGNhbm5vdCBiZSB1c2VkIG9uIHYtZm9yIG9yIHYtc2xvdCBzY29wZSB2YXJpYWJsZXMgYmVjYXVzZSB0aGV5IGFyZSBub3Qgd3JpdGFibGUuXCIsXG4gIDQ0OiBgdi1tb2RlbCBjYW5ub3QgYmUgdXNlZCBvbiBhIHByb3AsIGJlY2F1c2UgbG9jYWwgcHJvcCBiaW5kaW5ncyBhcmUgbm90IHdyaXRhYmxlLlxuVXNlIGEgdi1iaW5kIGJpbmRpbmcgY29tYmluZWQgd2l0aCBhIHYtb24gbGlzdGVuZXIgdGhhdCBlbWl0cyB1cGRhdGU6eCBldmVudCBpbnN0ZWFkLmAsXG4gIDQ1OiBcIkVycm9yIHBhcnNpbmcgSmF2YVNjcmlwdCBleHByZXNzaW9uOiBcIixcbiAgNDY6IFwiPEtlZXBBbGl2ZT4gZXhwZWN0cyBleGFjdGx5IG9uZSBjaGlsZCBjb21wb25lbnQuXCIsXG4gIDUxOiBcIkB2bm9kZS0qIGhvb2tzIGluIHRlbXBsYXRlcyBhcmUgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gVXNlIHRoZSB2dWU6IHByZWZpeCBpbnN0ZWFkLiBGb3IgZXhhbXBsZSwgQHZub2RlLW1vdW50ZWQgc2hvdWxkIGJlIGNoYW5nZWQgdG8gQHZ1ZTptb3VudGVkLiBAdm5vZGUtKiBob29rcyBzdXBwb3J0IGhhcyBiZWVuIHJlbW92ZWQgaW4gMy40LlwiLFxuICAvLyBnZW5lcmljIGVycm9yc1xuICA0NzogJ1wicHJlZml4SWRlbnRpZmllcnNcIiBvcHRpb24gaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJ1aWxkIG9mIGNvbXBpbGVyLicsXG4gIDQ4OiBcIkVTIG1vZHVsZSBtb2RlIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBidWlsZCBvZiBjb21waWxlci5cIixcbiAgNDk6ICdcImNhY2hlSGFuZGxlcnNcIiBvcHRpb24gaXMgb25seSBzdXBwb3J0ZWQgd2hlbiB0aGUgXCJwcmVmaXhJZGVudGlmaWVyc1wiIG9wdGlvbiBpcyBlbmFibGVkLicsXG4gIDUwOiAnXCJzY29wZUlkXCIgb3B0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIGluIG1vZHVsZSBtb2RlLicsXG4gIC8vIGp1c3QgdG8gZnVsZmlsbCB0eXBlc1xuICA1MzogXCJcIlxufSwgeG4gPSAodCkgPT4gdC50eXBlID09PSA0ICYmIHQuaXNTdGF0aWM7XG5mdW5jdGlvbiBCUCh0KSB7XG4gIHN3aXRjaCAodCkge1xuICAgIGNhc2UgXCJUZWxlcG9ydFwiOlxuICAgIGNhc2UgXCJ0ZWxlcG9ydFwiOlxuICAgICAgcmV0dXJuIEdhO1xuICAgIGNhc2UgXCJTdXNwZW5zZVwiOlxuICAgIGNhc2UgXCJzdXNwZW5zZVwiOlxuICAgICAgcmV0dXJuIENnO1xuICAgIGNhc2UgXCJLZWVwQWxpdmVcIjpcbiAgICBjYXNlIFwia2VlcC1hbGl2ZVwiOlxuICAgICAgcmV0dXJuIHRkO1xuICAgIGNhc2UgXCJCYXNlVHJhbnNpdGlvblwiOlxuICAgIGNhc2UgXCJiYXNlLXRyYW5zaXRpb25cIjpcbiAgICAgIHJldHVybiBEUDtcbiAgfVxufVxuY29uc3QgVzQgPSAvXlxcZHxbXlxcJFxcd10vLCB6ZyA9ICh0KSA9PiAhVzQudGVzdCh0KSwgTTQgPSAvW0EtWmEtel8kXFx4QTAtXFx1RkZGRl0vLCBYNCA9IC9bXFwuXFw/XFx3JFxceEEwLVxcdUZGRkZdLywgajQgPSAvXFxzK1suW11cXHMqfFxccypbLltdXFxzKy9nLCBCNCA9ICh0KSA9PiB7XG4gIHQgPSB0LnRyaW0oKS5yZXBsYWNlKGo0LCAobykgPT4gby50cmltKCkpO1xuICBsZXQgZSA9IDAsIG4gPSBbXSwgciA9IDAsIGkgPSAwLCBzID0gbnVsbDtcbiAgZm9yIChsZXQgbyA9IDA7IG8gPCB0Lmxlbmd0aDsgbysrKSB7XG4gICAgY29uc3QgYSA9IHQuY2hhckF0KG8pO1xuICAgIHN3aXRjaCAoZSkge1xuICAgICAgY2FzZSAwOlxuICAgICAgICBpZiAoYSA9PT0gXCJbXCIpXG4gICAgICAgICAgbi5wdXNoKGUpLCBlID0gMSwgcisrO1xuICAgICAgICBlbHNlIGlmIChhID09PSBcIihcIilcbiAgICAgICAgICBuLnB1c2goZSksIGUgPSAyLCBpKys7XG4gICAgICAgIGVsc2UgaWYgKCEobyA9PT0gMCA/IE00IDogWDQpLnRlc3QoYSkpXG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgYSA9PT0gXCInXCIgfHwgYSA9PT0gJ1wiJyB8fCBhID09PSBcImBcIiA/IChuLnB1c2goZSksIGUgPSAzLCBzID0gYSkgOiBhID09PSBcIltcIiA/IHIrKyA6IGEgPT09IFwiXVwiICYmICgtLXIgfHwgKGUgPSBuLnBvcCgpKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBpZiAoYSA9PT0gXCInXCIgfHwgYSA9PT0gJ1wiJyB8fCBhID09PSBcImBcIilcbiAgICAgICAgICBuLnB1c2goZSksIGUgPSAzLCBzID0gYTtcbiAgICAgICAgZWxzZSBpZiAoYSA9PT0gXCIoXCIpXG4gICAgICAgICAgaSsrO1xuICAgICAgICBlbHNlIGlmIChhID09PSBcIilcIikge1xuICAgICAgICAgIGlmIChvID09PSB0Lmxlbmd0aCAtIDEpXG4gICAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgICAgLS1pIHx8IChlID0gbi5wb3AoKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGEgPT09IHMgJiYgKGUgPSBuLnBvcCgpLCBzID0gbnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gIXIgJiYgIWk7XG59LCBMUCA9IEI0O1xuZnVuY3Rpb24gRjAodCwgZSkge1xuICBpZiAoIXQpXG4gICAgdGhyb3cgbmV3IEVycm9yKGUgfHwgXCJ1bmV4cGVjdGVkIGNvbXBpbGVyIGNvbmRpdGlvblwiKTtcbn1cbmZ1bmN0aW9uIHpuKHQsIGUsIG4gPSAhMSkge1xuICBmb3IgKGxldCByID0gMDsgciA8IHQucHJvcHMubGVuZ3RoOyByKyspIHtcbiAgICBjb25zdCBpID0gdC5wcm9wc1tyXTtcbiAgICBpZiAoaS50eXBlID09PSA3ICYmIChuIHx8IGkuZXhwKSAmJiAod2UoZSkgPyBpLm5hbWUgPT09IGUgOiBlLnRlc3QoaS5uYW1lKSkpXG4gICAgICByZXR1cm4gaTtcbiAgfVxufVxuZnVuY3Rpb24gUWwodCwgZSwgbiA9ICExLCByID0gITEpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0LnByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgcyA9IHQucHJvcHNbaV07XG4gICAgaWYgKHMudHlwZSA9PT0gNikge1xuICAgICAgaWYgKG4pXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKHMubmFtZSA9PT0gZSAmJiAocy52YWx1ZSB8fCByKSlcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfSBlbHNlIGlmIChzLm5hbWUgPT09IFwiYmluZFwiICYmIChzLmV4cCB8fCByKSAmJiBMaShzLmFyZywgZSkpXG4gICAgICByZXR1cm4gcztcbiAgfVxufVxuZnVuY3Rpb24gTGkodCwgZSkge1xuICByZXR1cm4gISEodCAmJiB4bih0KSAmJiB0LmNvbnRlbnQgPT09IGUpO1xufVxuZnVuY3Rpb24gTDQodCkge1xuICByZXR1cm4gdC5wcm9wcy5zb21lKFxuICAgIChlKSA9PiBlLnR5cGUgPT09IDcgJiYgZS5uYW1lID09PSBcImJpbmRcIiAmJiAoIWUuYXJnIHx8IC8vIHYtYmluZD1cIm9ialwiXG4gICAgZS5hcmcudHlwZSAhPT0gNCB8fCAvLyB2LWJpbmQ6W19jdHguZm9vXVxuICAgICFlLmFyZy5pc1N0YXRpYylcbiAgICAvLyB2LWJpbmQ6W2Zvb11cbiAgKTtcbn1cbmZ1bmN0aW9uIGVoKHQpIHtcbiAgcmV0dXJuIHQudHlwZSA9PT0gNSB8fCB0LnR5cGUgPT09IDI7XG59XG5mdW5jdGlvbiBVNCh0KSB7XG4gIHJldHVybiB0LnR5cGUgPT09IDcgJiYgdC5uYW1lID09PSBcInNsb3RcIjtcbn1cbmZ1bmN0aW9uIG9kKHQpIHtcbiAgcmV0dXJuIHQudHlwZSA9PT0gMSAmJiB0LnRhZ1R5cGUgPT09IDM7XG59XG5mdW5jdGlvbiBhZCh0KSB7XG4gIHJldHVybiB0LnR5cGUgPT09IDEgJiYgdC50YWdUeXBlID09PSAyO1xufVxuY29uc3QgcTQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbRWwsIGljXSk7XG5mdW5jdGlvbiBVUCh0LCBlID0gW10pIHtcbiAgaWYgKHQgJiYgIXdlKHQpICYmIHQudHlwZSA9PT0gMTQpIHtcbiAgICBjb25zdCBuID0gdC5jYWxsZWU7XG4gICAgaWYgKCF3ZShuKSAmJiBxNC5oYXMobikpXG4gICAgICByZXR1cm4gVVAoXG4gICAgICAgIHQuYXJndW1lbnRzWzBdLFxuICAgICAgICBlLmNvbmNhdCh0KVxuICAgICAgKTtcbiAgfVxuICByZXR1cm4gW3QsIGVdO1xufVxuZnVuY3Rpb24gbGQodCwgZSwgbikge1xuICBsZXQgciwgaSA9IHQudHlwZSA9PT0gMTMgPyB0LnByb3BzIDogdC5hcmd1bWVudHNbMl0sIHMgPSBbXSwgbztcbiAgaWYgKGkgJiYgIXdlKGkpICYmIGkudHlwZSA9PT0gMTQpIHtcbiAgICBjb25zdCBhID0gVVAoaSk7XG4gICAgaSA9IGFbMF0sIHMgPSBhWzFdLCBvID0gc1tzLmxlbmd0aCAtIDFdO1xuICB9XG4gIGlmIChpID09IG51bGwgfHwgd2UoaSkpXG4gICAgciA9IEduKFtlXSk7XG4gIGVsc2UgaWYgKGkudHlwZSA9PT0gMTQpIHtcbiAgICBjb25zdCBhID0gaS5hcmd1bWVudHNbMF07XG4gICAgIXdlKGEpICYmIGEudHlwZSA9PT0gMTUgPyBHMChlLCBhKSB8fCBhLnByb3BlcnRpZXMudW5zaGlmdChlKSA6IGkuY2FsbGVlID09PSBCZyA/IHIgPSBEdChuLmhlbHBlcihuZCksIFtcbiAgICAgIEduKFtlXSksXG4gICAgICBpXG4gICAgXSkgOiBpLmFyZ3VtZW50cy51bnNoaWZ0KEduKFtlXSkpLCAhciAmJiAociA9IGkpO1xuICB9IGVsc2VcbiAgICBpLnR5cGUgPT09IDE1ID8gKEcwKGUsIGkpIHx8IGkucHJvcGVydGllcy51bnNoaWZ0KGUpLCByID0gaSkgOiAociA9IER0KG4uaGVscGVyKG5kKSwgW1xuICAgICAgR24oW2VdKSxcbiAgICAgIGlcbiAgICBdKSwgbyAmJiBvLmNhbGxlZSA9PT0gaWMgJiYgKG8gPSBzW3MubGVuZ3RoIC0gMl0pKTtcbiAgdC50eXBlID09PSAxMyA/IG8gPyBvLmFyZ3VtZW50c1swXSA9IHIgOiB0LnByb3BzID0gciA6IG8gPyBvLmFyZ3VtZW50c1swXSA9IHIgOiB0LmFyZ3VtZW50c1syXSA9IHI7XG59XG5mdW5jdGlvbiBHMCh0LCBlKSB7XG4gIGxldCBuID0gITE7XG4gIGlmICh0LmtleS50eXBlID09PSA0KSB7XG4gICAgY29uc3QgciA9IHQua2V5LmNvbnRlbnQ7XG4gICAgbiA9IGUucHJvcGVydGllcy5zb21lKFxuICAgICAgKGkpID0+IGkua2V5LnR5cGUgPT09IDQgJiYgaS5rZXkuY29udGVudCA9PT0gclxuICAgICk7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBDbCh0LCBlKSB7XG4gIHJldHVybiBgXyR7ZX1fJHt0LnJlcGxhY2UoL1teXFx3XS9nLCAobiwgcikgPT4gbiA9PT0gXCItXCIgPyBcIl9cIiA6IHQuY2hhckNvZGVBdChyKS50b1N0cmluZygpKX1gO1xufVxuZnVuY3Rpb24gWTQodCkge1xuICByZXR1cm4gdC50eXBlID09PSAxNCAmJiB0LmNhbGxlZSA9PT0gVWcgPyB0LmFyZ3VtZW50c1sxXS5yZXR1cm5zIDogdDtcbn1cbmNvbnN0IHo0ID0gLyhbXFxzXFxTXSo/KVxccysoPzppbnxvZilcXHMrKFtcXHNcXFNdKikvLCBxUCA9IHtcbiAgcGFyc2VNb2RlOiBcImJhc2VcIixcbiAgbnM6IDAsXG4gIGRlbGltaXRlcnM6IFtcInt7XCIsIFwifX1cIl0sXG4gIGdldE5hbWVzcGFjZTogKCkgPT4gMCxcbiAgaXNWb2lkVGFnOiB6YyxcbiAgaXNQcmVUYWc6IHpjLFxuICBpc0N1c3RvbUVsZW1lbnQ6IHpjLFxuICBvbkVycm9yOiBZZyxcbiAgb25XYXJuOiBqUCxcbiAgY29tbWVudHM6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIixcbiAgcHJlZml4SWRlbnRpZmllcnM6ICExXG59O1xubGV0IEllID0gcVAsIEFsID0gbnVsbCwgV3MgPSBcIlwiLCBlbiA9IG51bGwsIE1lID0gbnVsbCwgYm4gPSBcIlwiLCBKciA9IC0xLCBicyA9IC0xLCBjZCA9IDAsIFZpID0gITEsIFVwID0gbnVsbDtcbmNvbnN0IHZ0ID0gW10sIGF0ID0gbmV3IFo0KHZ0LCB7XG4gIG9uZXJyOiBtbixcbiAgb250ZXh0KHQsIGUpIHtcbiAgICBVYyhxdCh0LCBlKSwgdCwgZSk7XG4gIH0sXG4gIG9udGV4dGVudGl0eSh0LCBlLCBuKSB7XG4gICAgVWModCwgZSwgbik7XG4gIH0sXG4gIG9uaW50ZXJwb2xhdGlvbih0LCBlKSB7XG4gICAgaWYgKFZpKVxuICAgICAgcmV0dXJuIFVjKHF0KHQsIGUpLCB0LCBlKTtcbiAgICBsZXQgbiA9IHQgKyBhdC5kZWxpbWl0ZXJPcGVuLmxlbmd0aCwgciA9IGUgLSBhdC5kZWxpbWl0ZXJDbG9zZS5sZW5ndGg7XG4gICAgZm9yICg7IE5uKFdzLmNoYXJDb2RlQXQobikpOyApXG4gICAgICBuKys7XG4gICAgZm9yICg7IE5uKFdzLmNoYXJDb2RlQXQociAtIDEpKTsgKVxuICAgICAgci0tO1xuICAgIGxldCBpID0gcXQobiwgcik7XG4gICAgaS5pbmNsdWRlcyhcIiZcIikgJiYgKGkgPSBJZS5kZWNvZGVFbnRpdGllcyhpLCAhMSkpLCBxcCh7XG4gICAgICB0eXBlOiA1LFxuICAgICAgY29udGVudDogcHUoaSwgITEsIFJ0KG4sIHIpKSxcbiAgICAgIGxvYzogUnQodCwgZSlcbiAgICB9KTtcbiAgfSxcbiAgb25vcGVudGFnbmFtZSh0LCBlKSB7XG4gICAgY29uc3QgbiA9IHF0KHQsIGUpO1xuICAgIGVuID0ge1xuICAgICAgdHlwZTogMSxcbiAgICAgIHRhZzogbixcbiAgICAgIG5zOiBJZS5nZXROYW1lc3BhY2UobiwgdnRbMF0sIEllLm5zKSxcbiAgICAgIHRhZ1R5cGU6IDAsXG4gICAgICAvLyB3aWxsIGJlIHJlZmluZWQgb24gdGFnIGNsb3NlXG4gICAgICBwcm9wczogW10sXG4gICAgICBjaGlsZHJlbjogW10sXG4gICAgICBsb2M6IFJ0KHQgLSAxLCBlKSxcbiAgICAgIGNvZGVnZW5Ob2RlOiB2b2lkIDBcbiAgICB9O1xuICB9LFxuICBvbm9wZW50YWdlbmQodCkge1xuICAgIEowKHQpO1xuICB9LFxuICBvbmNsb3NldGFnKHQsIGUpIHtcbiAgICBjb25zdCBuID0gcXQodCwgZSk7XG4gICAgaWYgKCFJZS5pc1ZvaWRUYWcobikpIHtcbiAgICAgIGxldCByID0gITE7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZ0Lmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAodnRbaV0udGFnLnRvTG93ZXJDYXNlKCkgPT09IG4udG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgIHIgPSAhMCwgaSA+IDAgJiYgbW4oMjQsIHZ0WzBdLmxvYy5zdGFydC5vZmZzZXQpO1xuICAgICAgICAgIGZvciAobGV0IG8gPSAwOyBvIDw9IGk7IG8rKykge1xuICAgICAgICAgICAgY29uc3QgYSA9IHZ0LnNoaWZ0KCk7XG4gICAgICAgICAgICBodShhLCBlLCBvIDwgaSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICByIHx8IG1uKDIzLCBZUCh0LCA2MCkpO1xuICAgIH1cbiAgfSxcbiAgb25zZWxmY2xvc2luZ3RhZyh0KSB7XG4gICAgdmFyIGU7XG4gICAgY29uc3QgbiA9IGVuLnRhZztcbiAgICBlbi5pc1NlbGZDbG9zaW5nID0gITAsIEowKHQpLCAoKGUgPSB2dFswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IGUudGFnKSA9PT0gbiAmJiBodSh2dC5zaGlmdCgpLCB0KTtcbiAgfSxcbiAgb25hdHRyaWJuYW1lKHQsIGUpIHtcbiAgICBNZSA9IHtcbiAgICAgIHR5cGU6IDYsXG4gICAgICBuYW1lOiBxdCh0LCBlKSxcbiAgICAgIG5hbWVMb2M6IFJ0KHQsIGUpLFxuICAgICAgdmFsdWU6IHZvaWQgMCxcbiAgICAgIGxvYzogUnQodClcbiAgICB9O1xuICB9LFxuICBvbmRpcm5hbWUodCwgZSkge1xuICAgIGNvbnN0IG4gPSBxdCh0LCBlKSwgciA9IG4gPT09IFwiLlwiIHx8IG4gPT09IFwiOlwiID8gXCJiaW5kXCIgOiBuID09PSBcIkBcIiA/IFwib25cIiA6IG4gPT09IFwiI1wiID8gXCJzbG90XCIgOiBuLnNsaWNlKDIpO1xuICAgIGlmICghVmkgJiYgciA9PT0gXCJcIiAmJiBtbigyNiwgdCksIFZpIHx8IHIgPT09IFwiXCIpXG4gICAgICBNZSA9IHtcbiAgICAgICAgdHlwZTogNixcbiAgICAgICAgbmFtZTogbixcbiAgICAgICAgbmFtZUxvYzogUnQodCwgZSksXG4gICAgICAgIHZhbHVlOiB2b2lkIDAsXG4gICAgICAgIGxvYzogUnQodClcbiAgICAgIH07XG4gICAgZWxzZSBpZiAoTWUgPSB7XG4gICAgICB0eXBlOiA3LFxuICAgICAgbmFtZTogcixcbiAgICAgIHJhd05hbWU6IG4sXG4gICAgICBleHA6IHZvaWQgMCxcbiAgICAgIGFyZzogdm9pZCAwLFxuICAgICAgbW9kaWZpZXJzOiBuID09PSBcIi5cIiA/IFtcInByb3BcIl0gOiBbXSxcbiAgICAgIGxvYzogUnQodClcbiAgICB9LCByID09PSBcInByZVwiKSB7XG4gICAgICBWaSA9IGF0LmluVlByZSA9ICEwLCBVcCA9IGVuO1xuICAgICAgY29uc3QgaSA9IGVuLnByb3BzO1xuICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCBpLmxlbmd0aDsgcysrKVxuICAgICAgICBpW3NdLnR5cGUgPT09IDcgJiYgKGlbc10gPSByNyhpW3NdKSk7XG4gICAgfVxuICB9LFxuICBvbmRpcmFyZyh0LCBlKSB7XG4gICAgaWYgKHQgPT09IGUpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbiA9IHF0KHQsIGUpO1xuICAgIGlmIChWaSlcbiAgICAgIE1lLm5hbWUgKz0gbiwgJHMoTWUubmFtZUxvYywgZSk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCByID0gblswXSAhPT0gXCJbXCI7XG4gICAgICBNZS5hcmcgPSBwdShcbiAgICAgICAgciA/IG4gOiBuLnNsaWNlKDEsIC0xKSxcbiAgICAgICAgcixcbiAgICAgICAgUnQodCwgZSksXG4gICAgICAgIHIgPyAzIDogMFxuICAgICAgKTtcbiAgICB9XG4gIH0sXG4gIG9uZGlybW9kaWZpZXIodCwgZSkge1xuICAgIGNvbnN0IG4gPSBxdCh0LCBlKTtcbiAgICBpZiAoVmkpXG4gICAgICBNZS5uYW1lICs9IFwiLlwiICsgbiwgJHMoTWUubmFtZUxvYywgZSk7XG4gICAgZWxzZSBpZiAoTWUubmFtZSA9PT0gXCJzbG90XCIpIHtcbiAgICAgIGNvbnN0IHIgPSBNZS5hcmc7XG4gICAgICByICYmIChyLmNvbnRlbnQgKz0gXCIuXCIgKyBuLCAkcyhyLmxvYywgZSkpO1xuICAgIH0gZWxzZVxuICAgICAgTWUubW9kaWZpZXJzLnB1c2gobik7XG4gIH0sXG4gIG9uYXR0cmliZGF0YSh0LCBlKSB7XG4gICAgYm4gKz0gcXQodCwgZSksIEpyIDwgMCAmJiAoSnIgPSB0KSwgYnMgPSBlO1xuICB9LFxuICBvbmF0dHJpYmVudGl0eSh0LCBlLCBuKSB7XG4gICAgYm4gKz0gdCwgSnIgPCAwICYmIChKciA9IGUpLCBicyA9IG47XG4gIH0sXG4gIG9uYXR0cmlibmFtZWVuZCh0KSB7XG4gICAgY29uc3QgZSA9IE1lLmxvYy5zdGFydC5vZmZzZXQsIG4gPSBxdChlLCB0KTtcbiAgICBNZS50eXBlID09PSA3ICYmIChNZS5yYXdOYW1lID0gbiksIGVuLnByb3BzLnNvbWUoXG4gICAgICAocikgPT4gKHIudHlwZSA9PT0gNyA/IHIucmF3TmFtZSA6IHIubmFtZSkgPT09IG5cbiAgICApICYmIG1uKDIsIGUpO1xuICB9LFxuICBvbmF0dHJpYmVuZCh0LCBlKSB7XG4gICAgaWYgKGVuICYmIE1lKSB7XG4gICAgICBpZiAoJHMoTWUubG9jLCBlKSwgdCAhPT0gMClcbiAgICAgICAgaWYgKGJuLmluY2x1ZGVzKFwiJlwiKSAmJiAoYm4gPSBJZS5kZWNvZGVFbnRpdGllcyhcbiAgICAgICAgICBibixcbiAgICAgICAgICAhMFxuICAgICAgICApKSwgTWUudHlwZSA9PT0gNilcbiAgICAgICAgICBNZS5uYW1lID09PSBcImNsYXNzXCIgJiYgKGJuID0gSFAoYm4pLnRyaW0oKSksIHQgPT09IDEgJiYgIWJuICYmIG1uKDEzLCBlKSwgTWUudmFsdWUgPSB7XG4gICAgICAgICAgICB0eXBlOiAyLFxuICAgICAgICAgICAgY29udGVudDogYm4sXG4gICAgICAgICAgICBsb2M6IHQgPT09IDEgPyBSdChKciwgYnMpIDogUnQoSnIgLSAxLCBicyArIDEpXG4gICAgICAgICAgfSwgYXQuaW5TRkNSb290ICYmIGVuLnRhZyA9PT0gXCJ0ZW1wbGF0ZVwiICYmIE1lLm5hbWUgPT09IFwibGFuZ1wiICYmIGJuICYmIGJuICE9PSBcImh0bWxcIiAmJiBhdC5lbnRlclJDREFUQShpZChcIjwvdGVtcGxhdGVcIiksIDApO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBsZXQgbiA9IDA7XG4gICAgICAgICAgTWUuZXhwID0gcHUoXG4gICAgICAgICAgICBibixcbiAgICAgICAgICAgICExLFxuICAgICAgICAgICAgUnQoSnIsIGJzKSxcbiAgICAgICAgICAgIDAsXG4gICAgICAgICAgICBuXG4gICAgICAgICAgKSwgTWUubmFtZSA9PT0gXCJmb3JcIiAmJiAoTWUuZm9yUGFyc2VSZXN1bHQgPSBGNChNZS5leHApKTtcbiAgICAgICAgICBsZXQgciA9IC0xO1xuICAgICAgICAgIE1lLm5hbWUgPT09IFwiYmluZFwiICYmIChyID0gTWUubW9kaWZpZXJzLmluZGV4T2YoXCJzeW5jXCIpKSA+IC0xICYmIEpvKFxuICAgICAgICAgICAgXCJDT01QSUxFUl9WX0JJTkRfU1lOQ1wiLFxuICAgICAgICAgICAgSWUsXG4gICAgICAgICAgICBNZS5sb2MsXG4gICAgICAgICAgICBNZS5yYXdOYW1lXG4gICAgICAgICAgKSAmJiAoTWUubmFtZSA9IFwibW9kZWxcIiwgTWUubW9kaWZpZXJzLnNwbGljZShyLCAxKSk7XG4gICAgICAgIH1cbiAgICAgIChNZS50eXBlICE9PSA3IHx8IE1lLm5hbWUgIT09IFwicHJlXCIpICYmIGVuLnByb3BzLnB1c2goTWUpO1xuICAgIH1cbiAgICBibiA9IFwiXCIsIEpyID0gYnMgPSAtMTtcbiAgfSxcbiAgb25jb21tZW50KHQsIGUpIHtcbiAgICBJZS5jb21tZW50cyAmJiBxcCh7XG4gICAgICB0eXBlOiAzLFxuICAgICAgY29udGVudDogcXQodCwgZSksXG4gICAgICBsb2M6IFJ0KHQgLSA0LCBlICsgMylcbiAgICB9KTtcbiAgfSxcbiAgb25lbmQoKSB7XG4gICAgY29uc3QgdCA9IFdzLmxlbmd0aDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGF0LnN0YXRlICE9PSAxKVxuICAgICAgc3dpdGNoIChhdC5zdGF0ZSkge1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgIGNhc2UgODpcbiAgICAgICAgICBtbig1LCB0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgbW4oXG4gICAgICAgICAgICAyNSxcbiAgICAgICAgICAgIGF0LnNlY3Rpb25TdGFydFxuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjg6XG4gICAgICAgICAgYXQuY3VycmVudFNlcXVlbmNlID09PSBVdC5DZGF0YUVuZCA/IG1uKDYsIHQpIDogbW4oNywgdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICBjYXNlIDk6XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgIGNhc2UgMTI6XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgIGNhc2UgMTQ6XG4gICAgICAgIGNhc2UgMTU6XG4gICAgICAgIGNhc2UgMTY6XG4gICAgICAgIGNhc2UgMTc6XG4gICAgICAgIGNhc2UgMTg6XG4gICAgICAgIGNhc2UgMTk6XG4gICAgICAgIGNhc2UgMjA6XG4gICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgbW4oOSwgdCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgZm9yIChsZXQgZSA9IDA7IGUgPCB2dC5sZW5ndGg7IGUrKylcbiAgICAgIGh1KHZ0W2VdLCB0IC0gMSksIG1uKDI0LCB2dFtlXS5sb2Muc3RhcnQub2Zmc2V0KTtcbiAgfSxcbiAgb25jZGF0YSh0LCBlKSB7XG4gICAgdnRbMF0ubnMgIT09IDAgPyBVYyhxdCh0LCBlKSwgdCwgZSkgOiBtbigxLCB0IC0gOSk7XG4gIH0sXG4gIG9ucHJvY2Vzc2luZ2luc3RydWN0aW9uKHQpIHtcbiAgICAodnRbMF0gPyB2dFswXS5ucyA6IEllLm5zKSA9PT0gMCAmJiBtbihcbiAgICAgIDIxLFxuICAgICAgdCAtIDFcbiAgICApO1xuICB9XG59KSwgSzAgPSAvLChbXixcXH1cXF1dKikoPzosKFteLFxcfVxcXV0qKSk/JC8sIEg0ID0gL15cXCh8XFwpJC9nO1xuZnVuY3Rpb24gRjQodCkge1xuICBjb25zdCBlID0gdC5sb2MsIG4gPSB0LmNvbnRlbnQsIHIgPSBuLm1hdGNoKHo0KTtcbiAgaWYgKCFyKVxuICAgIHJldHVybjtcbiAgY29uc3QgWywgaSwgc10gPSByLCBvID0gKGQsIGYsIGggPSAhMSkgPT4ge1xuICAgIGNvbnN0IHAgPSBlLnN0YXJ0Lm9mZnNldCArIGYsIE8gPSBwICsgZC5sZW5ndGg7XG4gICAgcmV0dXJuIHB1KFxuICAgICAgZCxcbiAgICAgICExLFxuICAgICAgUnQocCwgTyksXG4gICAgICAwLFxuICAgICAgaCA/IDEgOiAwXG4gICAgICAvKiBOb3JtYWwgKi9cbiAgICApO1xuICB9LCBhID0ge1xuICAgIHNvdXJjZTogbyhzLnRyaW0oKSwgbi5pbmRleE9mKHMsIGkubGVuZ3RoKSksXG4gICAgdmFsdWU6IHZvaWQgMCxcbiAgICBrZXk6IHZvaWQgMCxcbiAgICBpbmRleDogdm9pZCAwLFxuICAgIGZpbmFsaXplZDogITFcbiAgfTtcbiAgbGV0IGwgPSBpLnRyaW0oKS5yZXBsYWNlKEg0LCBcIlwiKS50cmltKCk7XG4gIGNvbnN0IGMgPSBpLmluZGV4T2YobCksIHUgPSBsLm1hdGNoKEswKTtcbiAgaWYgKHUpIHtcbiAgICBsID0gbC5yZXBsYWNlKEswLCBcIlwiKS50cmltKCk7XG4gICAgY29uc3QgZCA9IHVbMV0udHJpbSgpO1xuICAgIGxldCBmO1xuICAgIGlmIChkICYmIChmID0gbi5pbmRleE9mKGQsIGMgKyBsLmxlbmd0aCksIGEua2V5ID0gbyhkLCBmLCAhMCkpLCB1WzJdKSB7XG4gICAgICBjb25zdCBoID0gdVsyXS50cmltKCk7XG4gICAgICBoICYmIChhLmluZGV4ID0gbyhcbiAgICAgICAgaCxcbiAgICAgICAgbi5pbmRleE9mKFxuICAgICAgICAgIGgsXG4gICAgICAgICAgYS5rZXkgPyBmICsgZC5sZW5ndGggOiBjICsgbC5sZW5ndGhcbiAgICAgICAgKSxcbiAgICAgICAgITBcbiAgICAgICkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbCAmJiAoYS52YWx1ZSA9IG8obCwgYywgITApKSwgYTtcbn1cbmZ1bmN0aW9uIHF0KHQsIGUpIHtcbiAgcmV0dXJuIFdzLnNsaWNlKHQsIGUpO1xufVxuZnVuY3Rpb24gSjAodCkge1xuICBhdC5pblNGQ1Jvb3QgJiYgKGVuLmlubmVyTG9jID0gUnQodCArIDEsIHQgKyAxKSksIHFwKGVuKTtcbiAgY29uc3QgeyB0YWc6IGUsIG5zOiBuIH0gPSBlbjtcbiAgbiA9PT0gMCAmJiBJZS5pc1ByZVRhZyhlKSAmJiBjZCsrLCBJZS5pc1ZvaWRUYWcoZSkgPyBodShlbiwgdCkgOiAodnQudW5zaGlmdChlbiksIChuID09PSAxIHx8IG4gPT09IDIpICYmIChhdC5pblhNTCA9ICEwKSksIGVuID0gbnVsbDtcbn1cbmZ1bmN0aW9uIFVjKHQsIGUsIG4pIHtcbiAgdmFyIHI7XG4gIHtcbiAgICBjb25zdCBvID0gKHIgPSB2dFswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IHIudGFnO1xuICAgIG8gIT09IFwic2NyaXB0XCIgJiYgbyAhPT0gXCJzdHlsZVwiICYmIHQuaW5jbHVkZXMoXCImXCIpICYmICh0ID0gSWUuZGVjb2RlRW50aXRpZXModCwgITEpKTtcbiAgfVxuICBjb25zdCBpID0gdnRbMF0gfHwgQWwsIHMgPSBpLmNoaWxkcmVuW2kuY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gIChzID09IG51bGwgPyB2b2lkIDAgOiBzLnR5cGUpID09PSAyID8gKHMuY29udGVudCArPSB0LCAkcyhzLmxvYywgbikpIDogaS5jaGlsZHJlbi5wdXNoKHtcbiAgICB0eXBlOiAyLFxuICAgIGNvbnRlbnQ6IHQsXG4gICAgbG9jOiBSdChlLCBuKVxuICB9KTtcbn1cbmZ1bmN0aW9uIGh1KHQsIGUsIG4gPSAhMSkge1xuICBuID8gJHModC5sb2MsIFlQKGUsIDYwKSkgOiAkcyh0LmxvYywgZSArIDEpLCBhdC5pblNGQ1Jvb3QgJiYgKHQuY2hpbGRyZW4ubGVuZ3RoID8gdC5pbm5lckxvYy5lbmQgPSAkZSh7fSwgdC5jaGlsZHJlblt0LmNoaWxkcmVuLmxlbmd0aCAtIDFdLmxvYy5lbmQpIDogdC5pbm5lckxvYy5lbmQgPSAkZSh7fSwgdC5pbm5lckxvYy5zdGFydCksIHQuaW5uZXJMb2Muc291cmNlID0gcXQoXG4gICAgdC5pbm5lckxvYy5zdGFydC5vZmZzZXQsXG4gICAgdC5pbm5lckxvYy5lbmQub2Zmc2V0XG4gICkpO1xuICBjb25zdCB7IHRhZzogciwgbnM6IGkgfSA9IHQ7XG4gIFZpIHx8IChyID09PSBcInNsb3RcIiA/IHQudGFnVHlwZSA9IDIgOiBleSh0KSA/IHQudGFnVHlwZSA9IDMgOiBLNCh0KSAmJiAodC50YWdUeXBlID0gMSkpLCBhdC5pblJDREFUQSB8fCAodC5jaGlsZHJlbiA9IHpQKHQuY2hpbGRyZW4sIHQudGFnKSksIGkgPT09IDAgJiYgSWUuaXNQcmVUYWcocikgJiYgY2QtLSwgVXAgPT09IHQgJiYgKFZpID0gYXQuaW5WUHJlID0gITEsIFVwID0gbnVsbCksIGF0LmluWE1MICYmICh2dFswXSA/IHZ0WzBdLm5zIDogSWUubnMpID09PSAwICYmIChhdC5pblhNTCA9ICExKTtcbiAge1xuICAgIGNvbnN0IHMgPSB0LnByb3BzO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZXMoXG4gICAgICBcIkNPTVBJTEVSX1ZfSUZfVl9GT1JfUFJFQ0VERU5DRVwiLFxuICAgICAgSWVcbiAgICApKSB7XG4gICAgICBsZXQgYSA9ICExLCBsID0gITE7XG4gICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHMubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgY29uc3QgdSA9IHNbY107XG4gICAgICAgIGlmICh1LnR5cGUgPT09IDcgJiYgKHUubmFtZSA9PT0gXCJpZlwiID8gYSA9ICEwIDogdS5uYW1lID09PSBcImZvclwiICYmIChsID0gITApKSwgYSAmJiBsKSB7XG4gICAgICAgICAgc2QoXG4gICAgICAgICAgICBcIkNPTVBJTEVSX1ZfSUZfVl9GT1JfUFJFQ0VERU5DRVwiLFxuICAgICAgICAgICAgSWUsXG4gICAgICAgICAgICB0LmxvY1xuICAgICAgICAgICk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFhdC5pblNGQ1Jvb3QgJiYgZXMoXG4gICAgICBcIkNPTVBJTEVSX05BVElWRV9URU1QTEFURVwiLFxuICAgICAgSWVcbiAgICApICYmIHQudGFnID09PSBcInRlbXBsYXRlXCIgJiYgIWV5KHQpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgc2QoXG4gICAgICAgIFwiQ09NUElMRVJfTkFUSVZFX1RFTVBMQVRFXCIsXG4gICAgICAgIEllLFxuICAgICAgICB0LmxvY1xuICAgICAgKTtcbiAgICAgIGNvbnN0IGEgPSB2dFswXSB8fCBBbCwgbCA9IGEuY2hpbGRyZW4uaW5kZXhPZih0KTtcbiAgICAgIGEuY2hpbGRyZW4uc3BsaWNlKGwsIDEsIC4uLnQuY2hpbGRyZW4pO1xuICAgIH1cbiAgICBjb25zdCBvID0gcy5maW5kKFxuICAgICAgKGEpID0+IGEudHlwZSA9PT0gNiAmJiBhLm5hbWUgPT09IFwiaW5saW5lLXRlbXBsYXRlXCJcbiAgICApO1xuICAgIG8gJiYgSm8oXG4gICAgICBcIkNPTVBJTEVSX0lOTElORV9URU1QTEFURVwiLFxuICAgICAgSWUsXG4gICAgICBvLmxvY1xuICAgICkgJiYgdC5jaGlsZHJlbi5sZW5ndGggJiYgKG8udmFsdWUgPSB7XG4gICAgICB0eXBlOiAyLFxuICAgICAgY29udGVudDogcXQoXG4gICAgICAgIHQuY2hpbGRyZW5bMF0ubG9jLnN0YXJ0Lm9mZnNldCxcbiAgICAgICAgdC5jaGlsZHJlblt0LmNoaWxkcmVuLmxlbmd0aCAtIDFdLmxvYy5lbmQub2Zmc2V0XG4gICAgICApLFxuICAgICAgbG9jOiBvLmxvY1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBZUCh0LCBlKSB7XG4gIGxldCBuID0gdDtcbiAgZm9yICg7IFdzLmNoYXJDb2RlQXQobikgIT09IGUgJiYgbiA+PSAwOyApXG4gICAgbi0tO1xuICByZXR1cm4gbjtcbn1cbmNvbnN0IEc0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiaWZcIiwgXCJlbHNlXCIsIFwiZWxzZS1pZlwiLCBcImZvclwiLCBcInNsb3RcIl0pO1xuZnVuY3Rpb24gZXkoeyB0YWc6IHQsIHByb3BzOiBlIH0pIHtcbiAgaWYgKHQgPT09IFwidGVtcGxhdGVcIikge1xuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgZS5sZW5ndGg7IG4rKylcbiAgICAgIGlmIChlW25dLnR5cGUgPT09IDcgJiYgRzQuaGFzKGVbbl0ubmFtZSkpXG4gICAgICAgIHJldHVybiAhMDtcbiAgfVxuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiBLNCh7IHRhZzogdCwgcHJvcHM6IGUgfSkge1xuICB2YXIgbjtcbiAgaWYgKEllLmlzQ3VzdG9tRWxlbWVudCh0KSlcbiAgICByZXR1cm4gITE7XG4gIGlmICh0ID09PSBcImNvbXBvbmVudFwiIHx8IEo0KHQuY2hhckNvZGVBdCgwKSkgfHwgQlAodCkgfHwgKG4gPSBJZS5pc0J1aWx0SW5Db21wb25lbnQpICE9IG51bGwgJiYgbi5jYWxsKEllLCB0KSB8fCBJZS5pc05hdGl2ZVRhZyAmJiAhSWUuaXNOYXRpdmVUYWcodCkpXG4gICAgcmV0dXJuICEwO1xuICBmb3IgKGxldCByID0gMDsgciA8IGUubGVuZ3RoOyByKyspIHtcbiAgICBjb25zdCBpID0gZVtyXTtcbiAgICBpZiAoaS50eXBlID09PSA2KSB7XG4gICAgICBpZiAoaS5uYW1lID09PSBcImlzXCIgJiYgaS52YWx1ZSkge1xuICAgICAgICBpZiAoaS52YWx1ZS5jb250ZW50LnN0YXJ0c1dpdGgoXCJ2dWU6XCIpKVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgaWYgKEpvKFxuICAgICAgICAgIFwiQ09NUElMRVJfSVNfT05fRUxFTUVOVFwiLFxuICAgICAgICAgIEllLFxuICAgICAgICAgIGkubG9jXG4gICAgICAgICkpXG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICAvLyA6aXMgb24gcGxhaW4gZWxlbWVudCAtIG9ubHkgdHJlYXQgYXMgY29tcG9uZW50IGluIGNvbXBhdCBtb2RlXG4gICAgICBpLm5hbWUgPT09IFwiYmluZFwiICYmIExpKGkuYXJnLCBcImlzXCIpICYmIEpvKFxuICAgICAgICBcIkNPTVBJTEVSX0lTX09OX0VMRU1FTlRcIixcbiAgICAgICAgSWUsXG4gICAgICAgIGkubG9jXG4gICAgICApXG4gICAgKVxuICAgICAgcmV0dXJuICEwO1xuICB9XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIEo0KHQpIHtcbiAgcmV0dXJuIHQgPiA2NCAmJiB0IDwgOTE7XG59XG5jb25zdCBlNyA9IC9cXHJcXG4vZztcbmZ1bmN0aW9uIHpQKHQsIGUpIHtcbiAgdmFyIG4sIHI7XG4gIGNvbnN0IGkgPSBJZS53aGl0ZXNwYWNlICE9PSBcInByZXNlcnZlXCI7XG4gIGxldCBzID0gITE7XG4gIGZvciAobGV0IG8gPSAwOyBvIDwgdC5sZW5ndGg7IG8rKykge1xuICAgIGNvbnN0IGEgPSB0W29dO1xuICAgIGlmIChhLnR5cGUgPT09IDIpXG4gICAgICBpZiAoY2QpXG4gICAgICAgIGEuY29udGVudCA9IGEuY29udGVudC5yZXBsYWNlKGU3LCBgXG5gKTtcbiAgICAgIGVsc2UgaWYgKHQ3KGEuY29udGVudCkpIHtcbiAgICAgICAgY29uc3QgbCA9IChuID0gdFtvIC0gMV0pID09IG51bGwgPyB2b2lkIDAgOiBuLnR5cGUsIGMgPSAociA9IHRbbyArIDFdKSA9PSBudWxsID8gdm9pZCAwIDogci50eXBlO1xuICAgICAgICAhbCB8fCAhYyB8fCBpICYmIChsID09PSAzICYmIChjID09PSAzIHx8IGMgPT09IDEpIHx8IGwgPT09IDEgJiYgKGMgPT09IDMgfHwgYyA9PT0gMSAmJiBuNyhhLmNvbnRlbnQpKSkgPyAocyA9ICEwLCB0W29dID0gbnVsbCkgOiBhLmNvbnRlbnQgPSBcIiBcIjtcbiAgICAgIH0gZWxzZVxuICAgICAgICBpICYmIChhLmNvbnRlbnQgPSBIUChhLmNvbnRlbnQpKTtcbiAgfVxuICBpZiAoY2QgJiYgZSAmJiBJZS5pc1ByZVRhZyhlKSkge1xuICAgIGNvbnN0IG8gPSB0WzBdO1xuICAgIG8gJiYgby50eXBlID09PSAyICYmIChvLmNvbnRlbnQgPSBvLmNvbnRlbnQucmVwbGFjZSgvXlxccj9cXG4vLCBcIlwiKSk7XG4gIH1cbiAgcmV0dXJuIHMgPyB0LmZpbHRlcihCb29sZWFuKSA6IHQ7XG59XG5mdW5jdGlvbiB0Nyh0KSB7XG4gIGZvciAobGV0IGUgPSAwOyBlIDwgdC5sZW5ndGg7IGUrKylcbiAgICBpZiAoIU5uKHQuY2hhckNvZGVBdChlKSkpXG4gICAgICByZXR1cm4gITE7XG4gIHJldHVybiAhMDtcbn1cbmZ1bmN0aW9uIG43KHQpIHtcbiAgZm9yIChsZXQgZSA9IDA7IGUgPCB0Lmxlbmd0aDsgZSsrKSB7XG4gICAgY29uc3QgbiA9IHQuY2hhckNvZGVBdChlKTtcbiAgICBpZiAobiA9PT0gMTAgfHwgbiA9PT0gMTMpXG4gICAgICByZXR1cm4gITA7XG4gIH1cbiAgcmV0dXJuICExO1xufVxuZnVuY3Rpb24gSFAodCkge1xuICBsZXQgZSA9IFwiXCIsIG4gPSAhMTtcbiAgZm9yIChsZXQgciA9IDA7IHIgPCB0Lmxlbmd0aDsgcisrKVxuICAgIE5uKHQuY2hhckNvZGVBdChyKSkgPyBuIHx8IChlICs9IFwiIFwiLCBuID0gITApIDogKGUgKz0gdFtyXSwgbiA9ICExKTtcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBxcCh0KSB7XG4gICh2dFswXSB8fCBBbCkuY2hpbGRyZW4ucHVzaCh0KTtcbn1cbmZ1bmN0aW9uIFJ0KHQsIGUpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGFydDogYXQuZ2V0UG9zKHQpLFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgYWxsb3cgbGF0ZSBhdHRhY2htZW50XG4gICAgZW5kOiBlID09IG51bGwgPyBlIDogYXQuZ2V0UG9zKGUpLFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgYWxsb3cgbGF0ZSBhdHRhY2htZW50XG4gICAgc291cmNlOiBlID09IG51bGwgPyBlIDogcXQodCwgZSlcbiAgfTtcbn1cbmZ1bmN0aW9uICRzKHQsIGUpIHtcbiAgdC5lbmQgPSBhdC5nZXRQb3MoZSksIHQuc291cmNlID0gcXQodC5zdGFydC5vZmZzZXQsIGUpO1xufVxuZnVuY3Rpb24gcjcodCkge1xuICBjb25zdCBlID0ge1xuICAgIHR5cGU6IDYsXG4gICAgbmFtZTogdC5yYXdOYW1lLFxuICAgIG5hbWVMb2M6IFJ0KFxuICAgICAgdC5sb2Muc3RhcnQub2Zmc2V0LFxuICAgICAgdC5sb2Muc3RhcnQub2Zmc2V0ICsgdC5yYXdOYW1lLmxlbmd0aFxuICAgICksXG4gICAgdmFsdWU6IHZvaWQgMCxcbiAgICBsb2M6IHQubG9jXG4gIH07XG4gIGlmICh0LmV4cCkge1xuICAgIGNvbnN0IG4gPSB0LmV4cC5sb2M7XG4gICAgbi5lbmQub2Zmc2V0IDwgdC5sb2MuZW5kLm9mZnNldCAmJiAobi5zdGFydC5vZmZzZXQtLSwgbi5zdGFydC5jb2x1bW4tLSwgbi5lbmQub2Zmc2V0KyssIG4uZW5kLmNvbHVtbisrKSwgZS52YWx1ZSA9IHtcbiAgICAgIHR5cGU6IDIsXG4gICAgICBjb250ZW50OiB0LmV4cC5jb250ZW50LFxuICAgICAgbG9jOiBuXG4gICAgfTtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIHB1KHQsIGUgPSAhMSwgbiwgciA9IDAsIGkgPSAwKSB7XG4gIHJldHVybiBFZSh0LCBlLCBuLCByKTtcbn1cbmZ1bmN0aW9uIG1uKHQsIGUsIG4pIHtcbiAgSWUub25FcnJvcihcbiAgICBHZSh0LCBSdChlLCBlKSwgdm9pZCAwLCBuKVxuICApO1xufVxuZnVuY3Rpb24gaTcoKSB7XG4gIGF0LnJlc2V0KCksIGVuID0gbnVsbCwgTWUgPSBudWxsLCBibiA9IFwiXCIsIEpyID0gLTEsIGJzID0gLTEsIHZ0Lmxlbmd0aCA9IDA7XG59XG5mdW5jdGlvbiBzNyh0LCBlKSB7XG4gIGlmIChpNygpLCBXcyA9IHQsIEllID0gJGUoe30sIHFQKSwgZSkge1xuICAgIGxldCBpO1xuICAgIGZvciAoaSBpbiBlKVxuICAgICAgZVtpXSAhPSBudWxsICYmIChJZVtpXSA9IGVbaV0pO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIUllLmRlY29kZUVudGl0aWVzKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiW0B2dWUvY29tcGlsZXItY29yZV0gZGVjb2RlRW50aXRpZXMgb3B0aW9uIGlzIHJlcXVpcmVkIGluIGJyb3dzZXIgYnVpbGRzLlwiXG4gICAgKTtcbiAgYXQubW9kZSA9IEllLnBhcnNlTW9kZSA9PT0gXCJodG1sXCIgPyAxIDogSWUucGFyc2VNb2RlID09PSBcInNmY1wiID8gMiA6IDAsIGF0LmluWE1MID0gSWUubnMgPT09IDEgfHwgSWUubnMgPT09IDI7XG4gIGNvbnN0IG4gPSBlID09IG51bGwgPyB2b2lkIDAgOiBlLmRlbGltaXRlcnM7XG4gIG4gJiYgKGF0LmRlbGltaXRlck9wZW4gPSBpZChuWzBdKSwgYXQuZGVsaW1pdGVyQ2xvc2UgPSBpZChuWzFdKSk7XG4gIGNvbnN0IHIgPSBBbCA9IFI0KFtdLCB0KTtcbiAgcmV0dXJuIGF0LnBhcnNlKFdzKSwgci5sb2MgPSBSdCgwLCB0Lmxlbmd0aCksIHIuY2hpbGRyZW4gPSB6UChyLmNoaWxkcmVuKSwgQWwgPSBudWxsLCByO1xufVxuZnVuY3Rpb24gbzcodCwgZSkge1xuICBPdShcbiAgICB0LFxuICAgIGUsXG4gICAgLy8gUm9vdCBub2RlIGlzIHVuZm9ydHVuYXRlbHkgbm9uLWhvaXN0YWJsZSBkdWUgdG8gcG90ZW50aWFsIHBhcmVudFxuICAgIC8vIGZhbGx0aHJvdWdoIGF0dHJpYnV0ZXMuXG4gICAgRlAodCwgdC5jaGlsZHJlblswXSlcbiAgKTtcbn1cbmZ1bmN0aW9uIEZQKHQsIGUpIHtcbiAgY29uc3QgeyBjaGlsZHJlbjogbiB9ID0gdDtcbiAgcmV0dXJuIG4ubGVuZ3RoID09PSAxICYmIGUudHlwZSA9PT0gMSAmJiAhYWQoZSk7XG59XG5mdW5jdGlvbiBPdSh0LCBlLCBuID0gITEpIHtcbiAgY29uc3QgeyBjaGlsZHJlbjogciB9ID0gdCwgaSA9IHIubGVuZ3RoO1xuICBsZXQgcyA9IDA7XG4gIGZvciAobGV0IG8gPSAwOyBvIDwgci5sZW5ndGg7IG8rKykge1xuICAgIGNvbnN0IGEgPSByW29dO1xuICAgIGlmIChhLnR5cGUgPT09IDEgJiYgYS50YWdUeXBlID09PSAwKSB7XG4gICAgICBjb25zdCBsID0gbiA/IDAgOiBLbihhLCBlKTtcbiAgICAgIGlmIChsID4gMCkge1xuICAgICAgICBpZiAobCA+PSAyKSB7XG4gICAgICAgICAgYS5jb2RlZ2VuTm9kZS5wYXRjaEZsYWcgPSAtMSArIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcIiAvKiBIT0lTVEVEICovXCIgOiBcIlwiKSwgYS5jb2RlZ2VuTm9kZSA9IGUuaG9pc3QoYS5jb2RlZ2VuTm9kZSksIHMrKztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYyA9IGEuY29kZWdlbk5vZGU7XG4gICAgICAgIGlmIChjLnR5cGUgPT09IDEzKSB7XG4gICAgICAgICAgY29uc3QgdSA9IGVfKGMpO1xuICAgICAgICAgIGlmICgoIXUgfHwgdSA9PT0gNTEyIHx8IHUgPT09IDEpICYmIEtQKGEsIGUpID49IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGQgPSBKUChhKTtcbiAgICAgICAgICAgIGQgJiYgKGMucHJvcHMgPSBlLmhvaXN0KGQpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYy5keW5hbWljUHJvcHMgJiYgKGMuZHluYW1pY1Byb3BzID0gZS5ob2lzdChjLmR5bmFtaWNQcm9wcykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhLnR5cGUgPT09IDEpIHtcbiAgICAgIGNvbnN0IGwgPSBhLnRhZ1R5cGUgPT09IDE7XG4gICAgICBsICYmIGUuc2NvcGVzLnZTbG90KyssIE91KGEsIGUpLCBsICYmIGUuc2NvcGVzLnZTbG90LS07XG4gICAgfSBlbHNlIGlmIChhLnR5cGUgPT09IDExKVxuICAgICAgT3UoYSwgZSwgYS5jaGlsZHJlbi5sZW5ndGggPT09IDEpO1xuICAgIGVsc2UgaWYgKGEudHlwZSA9PT0gOSlcbiAgICAgIGZvciAobGV0IGwgPSAwOyBsIDwgYS5icmFuY2hlcy5sZW5ndGg7IGwrKylcbiAgICAgICAgT3UoXG4gICAgICAgICAgYS5icmFuY2hlc1tsXSxcbiAgICAgICAgICBlLFxuICAgICAgICAgIGEuYnJhbmNoZXNbbF0uY2hpbGRyZW4ubGVuZ3RoID09PSAxXG4gICAgICAgICk7XG4gIH1cbiAgaWYgKHMgJiYgZS50cmFuc2Zvcm1Ib2lzdCAmJiBlLnRyYW5zZm9ybUhvaXN0KHIsIGUsIHQpLCBzICYmIHMgPT09IGkgJiYgdC50eXBlID09PSAxICYmIHQudGFnVHlwZSA9PT0gMCAmJiB0LmNvZGVnZW5Ob2RlICYmIHQuY29kZWdlbk5vZGUudHlwZSA9PT0gMTMgJiYgaWUodC5jb2RlZ2VuTm9kZS5jaGlsZHJlbikpIHtcbiAgICBjb25zdCBvID0gZS5ob2lzdChcbiAgICAgIHNjKHQuY29kZWdlbk5vZGUuY2hpbGRyZW4pXG4gICAgKTtcbiAgICBlLmhtciAmJiAoby5jb250ZW50ID0gYFsuLi4ke28uY29udGVudH1dYCksIHQuY29kZWdlbk5vZGUuY2hpbGRyZW4gPSBvO1xuICB9XG59XG5mdW5jdGlvbiBLbih0LCBlKSB7XG4gIGNvbnN0IHsgY29uc3RhbnRDYWNoZTogbiB9ID0gZTtcbiAgc3dpdGNoICh0LnR5cGUpIHtcbiAgICBjYXNlIDE6XG4gICAgICBpZiAodC50YWdUeXBlICE9PSAwKVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIGNvbnN0IHIgPSBuLmdldCh0KTtcbiAgICAgIGlmIChyICE9PSB2b2lkIDApXG4gICAgICAgIHJldHVybiByO1xuICAgICAgY29uc3QgaSA9IHQuY29kZWdlbk5vZGU7XG4gICAgICBpZiAoaS50eXBlICE9PSAxMyB8fCBpLmlzQmxvY2sgJiYgdC50YWcgIT09IFwic3ZnXCIgJiYgdC50YWcgIT09IFwiZm9yZWlnbk9iamVjdFwiKVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIGlmIChlXyhpKSlcbiAgICAgICAgcmV0dXJuIG4uc2V0KHQsIDApLCAwO1xuICAgICAge1xuICAgICAgICBsZXQgYSA9IDM7XG4gICAgICAgIGNvbnN0IGwgPSBLUCh0LCBlKTtcbiAgICAgICAgaWYgKGwgPT09IDApXG4gICAgICAgICAgcmV0dXJuIG4uc2V0KHQsIDApLCAwO1xuICAgICAgICBsIDwgYSAmJiAoYSA9IGwpO1xuICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHQuY2hpbGRyZW4ubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICBjb25zdCB1ID0gS24odC5jaGlsZHJlbltjXSwgZSk7XG4gICAgICAgICAgaWYgKHUgPT09IDApXG4gICAgICAgICAgICByZXR1cm4gbi5zZXQodCwgMCksIDA7XG4gICAgICAgICAgdSA8IGEgJiYgKGEgPSB1KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYSA+IDEpXG4gICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCB0LnByb3BzLmxlbmd0aDsgYysrKSB7XG4gICAgICAgICAgICBjb25zdCB1ID0gdC5wcm9wc1tjXTtcbiAgICAgICAgICAgIGlmICh1LnR5cGUgPT09IDcgJiYgdS5uYW1lID09PSBcImJpbmRcIiAmJiB1LmV4cCkge1xuICAgICAgICAgICAgICBjb25zdCBkID0gS24odS5leHAsIGUpO1xuICAgICAgICAgICAgICBpZiAoZCA9PT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gbi5zZXQodCwgMCksIDA7XG4gICAgICAgICAgICAgIGQgPCBhICYmIChhID0gZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICBpZiAoaS5pc0Jsb2NrKSB7XG4gICAgICAgICAgZm9yIChsZXQgYyA9IDA7IGMgPCB0LnByb3BzLmxlbmd0aDsgYysrKVxuICAgICAgICAgICAgaWYgKHQucHJvcHNbY10udHlwZSA9PT0gNylcbiAgICAgICAgICAgICAgcmV0dXJuIG4uc2V0KHQsIDApLCAwO1xuICAgICAgICAgIGUucmVtb3ZlSGVscGVyKEZzKSwgZS5yZW1vdmVIZWxwZXIoXG4gICAgICAgICAgICBLbyhlLmluU1NSLCBpLmlzQ29tcG9uZW50KVxuICAgICAgICAgICksIGkuaXNCbG9jayA9ICExLCBlLmhlbHBlcihHbyhlLmluU1NSLCBpLmlzQ29tcG9uZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG4uc2V0KHQsIGEpLCBhO1xuICAgICAgfVxuICAgIGNhc2UgMjpcbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gMztcbiAgICBjYXNlIDk6XG4gICAgY2FzZSAxMTpcbiAgICBjYXNlIDEwOlxuICAgICAgcmV0dXJuIDA7XG4gICAgY2FzZSA1OlxuICAgIGNhc2UgMTI6XG4gICAgICByZXR1cm4gS24odC5jb250ZW50LCBlKTtcbiAgICBjYXNlIDQ6XG4gICAgICByZXR1cm4gdC5jb25zdFR5cGU7XG4gICAgY2FzZSA4OlxuICAgICAgbGV0IG8gPSAzO1xuICAgICAgZm9yIChsZXQgYSA9IDA7IGEgPCB0LmNoaWxkcmVuLmxlbmd0aDsgYSsrKSB7XG4gICAgICAgIGNvbnN0IGwgPSB0LmNoaWxkcmVuW2FdO1xuICAgICAgICBpZiAod2UobCkgfHwgT3IobCkpXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IGMgPSBLbihsLCBlKTtcbiAgICAgICAgaWYgKGMgPT09IDApXG4gICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGMgPCBvICYmIChvID0gYyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHByb2Nlc3MuZW52Lk5PREVfRU5WLCAwO1xuICB9XG59XG5jb25zdCBhNyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgWGcsXG4gIGpnLFxuICBFbCxcbiAgaWNcbl0pO1xuZnVuY3Rpb24gR1AodCwgZSkge1xuICBpZiAodC50eXBlID09PSAxNCAmJiAhd2UodC5jYWxsZWUpICYmIGE3Lmhhcyh0LmNhbGxlZSkpIHtcbiAgICBjb25zdCBuID0gdC5hcmd1bWVudHNbMF07XG4gICAgaWYgKG4udHlwZSA9PT0gNClcbiAgICAgIHJldHVybiBLbihuLCBlKTtcbiAgICBpZiAobi50eXBlID09PSAxNClcbiAgICAgIHJldHVybiBHUChuLCBlKTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIEtQKHQsIGUpIHtcbiAgbGV0IG4gPSAzO1xuICBjb25zdCByID0gSlAodCk7XG4gIGlmIChyICYmIHIudHlwZSA9PT0gMTUpIHtcbiAgICBjb25zdCB7IHByb3BlcnRpZXM6IGkgfSA9IHI7XG4gICAgZm9yIChsZXQgcyA9IDA7IHMgPCBpLmxlbmd0aDsgcysrKSB7XG4gICAgICBjb25zdCB7IGtleTogbywgdmFsdWU6IGEgfSA9IGlbc10sIGwgPSBLbihvLCBlKTtcbiAgICAgIGlmIChsID09PSAwKVxuICAgICAgICByZXR1cm4gbDtcbiAgICAgIGwgPCBuICYmIChuID0gbCk7XG4gICAgICBsZXQgYztcbiAgICAgIGlmIChhLnR5cGUgPT09IDQgPyBjID0gS24oYSwgZSkgOiBhLnR5cGUgPT09IDE0ID8gYyA9IEdQKGEsIGUpIDogYyA9IDAsIGMgPT09IDApXG4gICAgICAgIHJldHVybiBjO1xuICAgICAgYyA8IG4gJiYgKG4gPSBjKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBKUCh0KSB7XG4gIGNvbnN0IGUgPSB0LmNvZGVnZW5Ob2RlO1xuICBpZiAoZS50eXBlID09PSAxMylcbiAgICByZXR1cm4gZS5wcm9wcztcbn1cbmZ1bmN0aW9uIGVfKHQpIHtcbiAgY29uc3QgZSA9IHQucGF0Y2hGbGFnO1xuICByZXR1cm4gZSA/IHBhcnNlSW50KGUsIDEwKSA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGw3KHQsIHtcbiAgZmlsZW5hbWU6IGUgPSBcIlwiLFxuICBwcmVmaXhJZGVudGlmaWVyczogbiA9ICExLFxuICBob2lzdFN0YXRpYzogciA9ICExLFxuICBobXI6IGkgPSAhMSxcbiAgY2FjaGVIYW5kbGVyczogcyA9ICExLFxuICBub2RlVHJhbnNmb3JtczogbyA9IFtdLFxuICBkaXJlY3RpdmVUcmFuc2Zvcm1zOiBhID0ge30sXG4gIHRyYW5zZm9ybUhvaXN0OiBsID0gbnVsbCxcbiAgaXNCdWlsdEluQ29tcG9uZW50OiBjID0gaXQsXG4gIGlzQ3VzdG9tRWxlbWVudDogdSA9IGl0LFxuICBleHByZXNzaW9uUGx1Z2luczogZCA9IFtdLFxuICBzY29wZUlkOiBmID0gbnVsbCxcbiAgc2xvdHRlZDogaCA9ICEwLFxuICBzc3I6IHAgPSAhMSxcbiAgaW5TU1I6IE8gPSAhMSxcbiAgc3NyQ3NzVmFyczogbSA9IFwiXCIsXG4gIGJpbmRpbmdNZXRhZGF0YTogeSA9IFZlLFxuICBpbmxpbmU6IGIgPSAhMSxcbiAgaXNUUzogZyA9ICExLFxuICBvbkVycm9yOiB2ID0gWWcsXG4gIG9uV2FybjogUyA9IGpQLFxuICBjb21wYXRDb25maWc6IHdcbn0pIHtcbiAgY29uc3QgayA9IGUucmVwbGFjZSgvXFw/LiokLywgXCJcIikubWF0Y2goLyhbXi9cXFxcXSspXFwuXFx3KyQvKSwgXyA9IHtcbiAgICAvLyBvcHRpb25zXG4gICAgZmlsZW5hbWU6IGUsXG4gICAgc2VsZk5hbWU6IGsgJiYgV3IobXQoa1sxXSkpLFxuICAgIHByZWZpeElkZW50aWZpZXJzOiBuLFxuICAgIGhvaXN0U3RhdGljOiByLFxuICAgIGhtcjogaSxcbiAgICBjYWNoZUhhbmRsZXJzOiBzLFxuICAgIG5vZGVUcmFuc2Zvcm1zOiBvLFxuICAgIGRpcmVjdGl2ZVRyYW5zZm9ybXM6IGEsXG4gICAgdHJhbnNmb3JtSG9pc3Q6IGwsXG4gICAgaXNCdWlsdEluQ29tcG9uZW50OiBjLFxuICAgIGlzQ3VzdG9tRWxlbWVudDogdSxcbiAgICBleHByZXNzaW9uUGx1Z2luczogZCxcbiAgICBzY29wZUlkOiBmLFxuICAgIHNsb3R0ZWQ6IGgsXG4gICAgc3NyOiBwLFxuICAgIGluU1NSOiBPLFxuICAgIHNzckNzc1ZhcnM6IG0sXG4gICAgYmluZGluZ01ldGFkYXRhOiB5LFxuICAgIGlubGluZTogYixcbiAgICBpc1RTOiBnLFxuICAgIG9uRXJyb3I6IHYsXG4gICAgb25XYXJuOiBTLFxuICAgIGNvbXBhdENvbmZpZzogdyxcbiAgICAvLyBzdGF0ZVxuICAgIHJvb3Q6IHQsXG4gICAgaGVscGVyczogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICBjb21wb25lbnRzOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICAgIGRpcmVjdGl2ZXM6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgaG9pc3RzOiBbXSxcbiAgICBpbXBvcnRzOiBbXSxcbiAgICBjb25zdGFudENhY2hlOiAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSxcbiAgICB0ZW1wczogMCxcbiAgICBjYWNoZWQ6IDAsXG4gICAgaWRlbnRpZmllcnM6IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgIHNjb3Blczoge1xuICAgICAgdkZvcjogMCxcbiAgICAgIHZTbG90OiAwLFxuICAgICAgdlByZTogMCxcbiAgICAgIHZPbmNlOiAwXG4gICAgfSxcbiAgICBwYXJlbnQ6IG51bGwsXG4gICAgY3VycmVudE5vZGU6IHQsXG4gICAgY2hpbGRJbmRleDogMCxcbiAgICBpblZPbmNlOiAhMSxcbiAgICAvLyBtZXRob2RzXG4gICAgaGVscGVyKFQpIHtcbiAgICAgIGNvbnN0IEMgPSBfLmhlbHBlcnMuZ2V0KFQpIHx8IDA7XG4gICAgICByZXR1cm4gXy5oZWxwZXJzLnNldChULCBDICsgMSksIFQ7XG4gICAgfSxcbiAgICByZW1vdmVIZWxwZXIoVCkge1xuICAgICAgY29uc3QgQyA9IF8uaGVscGVycy5nZXQoVCk7XG4gICAgICBpZiAoQykge1xuICAgICAgICBjb25zdCBBID0gQyAtIDE7XG4gICAgICAgIEEgPyBfLmhlbHBlcnMuc2V0KFQsIEEpIDogXy5oZWxwZXJzLmRlbGV0ZShUKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGhlbHBlclN0cmluZyhUKSB7XG4gICAgICByZXR1cm4gYF8ke0hvW18uaGVscGVyKFQpXX1gO1xuICAgIH0sXG4gICAgcmVwbGFjZU5vZGUoVCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBpZiAoIV8uY3VycmVudE5vZGUpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm9kZSBiZWluZyByZXBsYWNlZCBpcyBhbHJlYWR5IHJlbW92ZWQuXCIpO1xuICAgICAgICBpZiAoIV8ucGFyZW50KVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXBsYWNlIHJvb3Qgbm9kZS5cIik7XG4gICAgICB9XG4gICAgICBfLnBhcmVudC5jaGlsZHJlbltfLmNoaWxkSW5kZXhdID0gXy5jdXJyZW50Tm9kZSA9IFQ7XG4gICAgfSxcbiAgICByZW1vdmVOb2RlKFQpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIV8ucGFyZW50KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVtb3ZlIHJvb3Qgbm9kZS5cIik7XG4gICAgICBjb25zdCBDID0gXy5wYXJlbnQuY2hpbGRyZW4sIEEgPSBUID8gQy5pbmRleE9mKFQpIDogXy5jdXJyZW50Tm9kZSA/IF8uY2hpbGRJbmRleCA6IC0xO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBBIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm9kZSBiZWluZyByZW1vdmVkIGlzIG5vdCBhIGNoaWxkIG9mIGN1cnJlbnQgcGFyZW50XCIpO1xuICAgICAgIVQgfHwgVCA9PT0gXy5jdXJyZW50Tm9kZSA/IChfLmN1cnJlbnROb2RlID0gbnVsbCwgXy5vbk5vZGVSZW1vdmVkKCkpIDogXy5jaGlsZEluZGV4ID4gQSAmJiAoXy5jaGlsZEluZGV4LS0sIF8ub25Ob2RlUmVtb3ZlZCgpKSwgXy5wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKEEsIDEpO1xuICAgIH0sXG4gICAgb25Ob2RlUmVtb3ZlZDogaXQsXG4gICAgYWRkSWRlbnRpZmllcnMoVCkge1xuICAgIH0sXG4gICAgcmVtb3ZlSWRlbnRpZmllcnMoVCkge1xuICAgIH0sXG4gICAgaG9pc3QoVCkge1xuICAgICAgd2UoVCkgJiYgKFQgPSBFZShUKSksIF8uaG9pc3RzLnB1c2goVCk7XG4gICAgICBjb25zdCBDID0gRWUoXG4gICAgICAgIGBfaG9pc3RlZF8ke18uaG9pc3RzLmxlbmd0aH1gLFxuICAgICAgICAhMSxcbiAgICAgICAgVC5sb2MsXG4gICAgICAgIDJcbiAgICAgICk7XG4gICAgICByZXR1cm4gQy5ob2lzdGVkID0gVCwgQztcbiAgICB9LFxuICAgIGNhY2hlKFQsIEMgPSAhMSkge1xuICAgICAgcmV0dXJuIE40KF8uY2FjaGVkKyssIFQsIEMpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIF8uZmlsdGVycyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksIF87XG59XG5mdW5jdGlvbiBjNyh0LCBlKSB7XG4gIGNvbnN0IG4gPSBsNyh0LCBlKTtcbiAgZWYodCwgbiksIGUuaG9pc3RTdGF0aWMgJiYgbzcodCwgbiksIGUuc3NyIHx8IHU3KHQsIG4pLCB0LmhlbHBlcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbLi4ubi5oZWxwZXJzLmtleXMoKV0pLCB0LmNvbXBvbmVudHMgPSBbLi4ubi5jb21wb25lbnRzXSwgdC5kaXJlY3RpdmVzID0gWy4uLm4uZGlyZWN0aXZlc10sIHQuaW1wb3J0cyA9IG4uaW1wb3J0cywgdC5ob2lzdHMgPSBuLmhvaXN0cywgdC50ZW1wcyA9IG4udGVtcHMsIHQuY2FjaGVkID0gbi5jYWNoZWQsIHQudHJhbnNmb3JtZWQgPSAhMCwgdC5maWx0ZXJzID0gWy4uLm4uZmlsdGVyc107XG59XG5mdW5jdGlvbiB1Nyh0LCBlKSB7XG4gIGNvbnN0IHsgaGVscGVyOiBuIH0gPSBlLCB7IGNoaWxkcmVuOiByIH0gPSB0O1xuICBpZiAoci5sZW5ndGggPT09IDEpIHtcbiAgICBjb25zdCBpID0gclswXTtcbiAgICBpZiAoRlAodCwgaSkgJiYgaS5jb2RlZ2VuTm9kZSkge1xuICAgICAgY29uc3QgcyA9IGkuY29kZWdlbk5vZGU7XG4gICAgICBzLnR5cGUgPT09IDEzICYmIHFnKHMsIGUpLCB0LmNvZGVnZW5Ob2RlID0gcztcbiAgICB9IGVsc2VcbiAgICAgIHQuY29kZWdlbk5vZGUgPSBpO1xuICB9IGVsc2UgaWYgKHIubGVuZ3RoID4gMSkge1xuICAgIGxldCBpID0gNjQsIHMgPSBEcls2NF07XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIHIuZmlsdGVyKChvKSA9PiBvLnR5cGUgIT09IDMpLmxlbmd0aCA9PT0gMSAmJiAoaSB8PSAyMDQ4LCBzICs9IGAsICR7RHJbMjA0OF19YCksIHQuY29kZWdlbk5vZGUgPSAkbChcbiAgICAgIGUsXG4gICAgICBuKFRsKSxcbiAgICAgIHZvaWQgMCxcbiAgICAgIHQuY2hpbGRyZW4sXG4gICAgICBpICsgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGAgLyogJHtzfSAqL2AgOiBcIlwiKSxcbiAgICAgIHZvaWQgMCxcbiAgICAgIHZvaWQgMCxcbiAgICAgICEwLFxuICAgICAgdm9pZCAwLFxuICAgICAgITFcbiAgICApO1xuICB9XG59XG5mdW5jdGlvbiBkNyh0LCBlKSB7XG4gIGxldCBuID0gMDtcbiAgY29uc3QgciA9ICgpID0+IHtcbiAgICBuLS07XG4gIH07XG4gIGZvciAoOyBuIDwgdC5jaGlsZHJlbi5sZW5ndGg7IG4rKykge1xuICAgIGNvbnN0IGkgPSB0LmNoaWxkcmVuW25dO1xuICAgIHdlKGkpIHx8IChlLnBhcmVudCA9IHQsIGUuY2hpbGRJbmRleCA9IG4sIGUub25Ob2RlUmVtb3ZlZCA9IHIsIGVmKGksIGUpKTtcbiAgfVxufVxuZnVuY3Rpb24gZWYodCwgZSkge1xuICBlLmN1cnJlbnROb2RlID0gdDtcbiAgY29uc3QgeyBub2RlVHJhbnNmb3JtczogbiB9ID0gZSwgciA9IFtdO1xuICBmb3IgKGxldCBzID0gMDsgcyA8IG4ubGVuZ3RoOyBzKyspIHtcbiAgICBjb25zdCBvID0gbltzXSh0LCBlKTtcbiAgICBpZiAobyAmJiAoaWUobykgPyByLnB1c2goLi4ubykgOiByLnB1c2gobykpLCBlLmN1cnJlbnROb2RlKVxuICAgICAgdCA9IGUuY3VycmVudE5vZGU7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuO1xuICB9XG4gIHN3aXRjaCAodC50eXBlKSB7XG4gICAgY2FzZSAzOlxuICAgICAgZS5zc3IgfHwgZS5oZWxwZXIocmMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA1OlxuICAgICAgZS5zc3IgfHwgZS5oZWxwZXIoSmQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA5OlxuICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCB0LmJyYW5jaGVzLmxlbmd0aDsgcysrKVxuICAgICAgICBlZih0LmJyYW5jaGVzW3NdLCBlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTA6XG4gICAgY2FzZSAxMTpcbiAgICBjYXNlIDE6XG4gICAgY2FzZSAwOlxuICAgICAgZDcodCwgZSk7XG4gICAgICBicmVhaztcbiAgfVxuICBlLmN1cnJlbnROb2RlID0gdDtcbiAgbGV0IGkgPSByLmxlbmd0aDtcbiAgZm9yICg7IGktLTsgKVxuICAgIHJbaV0oKTtcbn1cbmZ1bmN0aW9uIHRfKHQsIGUpIHtcbiAgY29uc3QgbiA9IHdlKHQpID8gKHIpID0+IHIgPT09IHQgOiAocikgPT4gdC50ZXN0KHIpO1xuICByZXR1cm4gKHIsIGkpID0+IHtcbiAgICBpZiAoci50eXBlID09PSAxKSB7XG4gICAgICBjb25zdCB7IHByb3BzOiBzIH0gPSByO1xuICAgICAgaWYgKHIudGFnVHlwZSA9PT0gMyAmJiBzLnNvbWUoVTQpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBvID0gW107XG4gICAgICBmb3IgKGxldCBhID0gMDsgYSA8IHMubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgY29uc3QgbCA9IHNbYV07XG4gICAgICAgIGlmIChsLnR5cGUgPT09IDcgJiYgbihsLm5hbWUpKSB7XG4gICAgICAgICAgcy5zcGxpY2UoYSwgMSksIGEtLTtcbiAgICAgICAgICBjb25zdCBjID0gZShyLCBsLCBpKTtcbiAgICAgICAgICBjICYmIG8ucHVzaChjKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG87XG4gICAgfVxuICB9O1xufVxuY29uc3QgdGYgPSBcIi8qI19fUFVSRV9fKi9cIiwgbl8gPSAodCkgPT4gYCR7SG9bdF19OiBfJHtIb1t0XX1gO1xuZnVuY3Rpb24gZjcodCwge1xuICBtb2RlOiBlID0gXCJmdW5jdGlvblwiLFxuICBwcmVmaXhJZGVudGlmaWVyczogbiA9IGUgPT09IFwibW9kdWxlXCIsXG4gIHNvdXJjZU1hcDogciA9ICExLFxuICBmaWxlbmFtZTogaSA9IFwidGVtcGxhdGUudnVlLmh0bWxcIixcbiAgc2NvcGVJZDogcyA9IG51bGwsXG4gIG9wdGltaXplSW1wb3J0czogbyA9ICExLFxuICBydW50aW1lR2xvYmFsTmFtZTogYSA9IFwiVnVlXCIsXG4gIHJ1bnRpbWVNb2R1bGVOYW1lOiBsID0gXCJ2dWVcIixcbiAgc3NyUnVudGltZU1vZHVsZU5hbWU6IGMgPSBcInZ1ZS9zZXJ2ZXItcmVuZGVyZXJcIixcbiAgc3NyOiB1ID0gITEsXG4gIGlzVFM6IGQgPSAhMSxcbiAgaW5TU1I6IGYgPSAhMVxufSkge1xuICBjb25zdCBoID0ge1xuICAgIG1vZGU6IGUsXG4gICAgcHJlZml4SWRlbnRpZmllcnM6IG4sXG4gICAgc291cmNlTWFwOiByLFxuICAgIGZpbGVuYW1lOiBpLFxuICAgIHNjb3BlSWQ6IHMsXG4gICAgb3B0aW1pemVJbXBvcnRzOiBvLFxuICAgIHJ1bnRpbWVHbG9iYWxOYW1lOiBhLFxuICAgIHJ1bnRpbWVNb2R1bGVOYW1lOiBsLFxuICAgIHNzclJ1bnRpbWVNb2R1bGVOYW1lOiBjLFxuICAgIHNzcjogdSxcbiAgICBpc1RTOiBkLFxuICAgIGluU1NSOiBmLFxuICAgIHNvdXJjZTogdC5zb3VyY2UsXG4gICAgY29kZTogXCJcIixcbiAgICBjb2x1bW46IDEsXG4gICAgbGluZTogMSxcbiAgICBvZmZzZXQ6IDAsXG4gICAgaW5kZW50TGV2ZWw6IDAsXG4gICAgcHVyZTogITEsXG4gICAgbWFwOiB2b2lkIDAsXG4gICAgaGVscGVyKE8pIHtcbiAgICAgIHJldHVybiBgXyR7SG9bT119YDtcbiAgICB9LFxuICAgIHB1c2goTywgbSA9IC0yLCB5KSB7XG4gICAgICBoLmNvZGUgKz0gTztcbiAgICB9LFxuICAgIGluZGVudCgpIHtcbiAgICAgIHAoKytoLmluZGVudExldmVsKTtcbiAgICB9LFxuICAgIGRlaW5kZW50KE8gPSAhMSkge1xuICAgICAgTyA/IC0taC5pbmRlbnRMZXZlbCA6IHAoLS1oLmluZGVudExldmVsKTtcbiAgICB9LFxuICAgIG5ld2xpbmUoKSB7XG4gICAgICBwKGguaW5kZW50TGV2ZWwpO1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gcChPKSB7XG4gICAgaC5wdXNoKFxuICAgICAgYFxuYCArIFwiICBcIi5yZXBlYXQoTyksXG4gICAgICAwXG4gICAgICAvKiBTdGFydCAqL1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIGg7XG59XG5mdW5jdGlvbiBoNyh0LCBlID0ge30pIHtcbiAgY29uc3QgbiA9IGY3KHQsIGUpO1xuICBlLm9uQ29udGV4dENyZWF0ZWQgJiYgZS5vbkNvbnRleHRDcmVhdGVkKG4pO1xuICBjb25zdCB7XG4gICAgbW9kZTogcixcbiAgICBwdXNoOiBpLFxuICAgIHByZWZpeElkZW50aWZpZXJzOiBzLFxuICAgIGluZGVudDogbyxcbiAgICBkZWluZGVudDogYSxcbiAgICBuZXdsaW5lOiBsLFxuICAgIHNjb3BlSWQ6IGMsXG4gICAgc3NyOiB1XG4gIH0gPSBuLCBkID0gQXJyYXkuZnJvbSh0LmhlbHBlcnMpLCBmID0gZC5sZW5ndGggPiAwLCBoID0gIXMgJiYgciAhPT0gXCJtb2R1bGVcIjtcbiAgcDcodCwgbik7XG4gIGNvbnN0IE8gPSB1ID8gXCJzc3JSZW5kZXJcIiA6IFwicmVuZGVyXCIsIHkgPSAodSA/IFtcIl9jdHhcIiwgXCJfcHVzaFwiLCBcIl9wYXJlbnRcIiwgXCJfYXR0cnNcIl0gOiBbXCJfY3R4XCIsIFwiX2NhY2hlXCJdKS5qb2luKFwiLCBcIik7XG4gIGlmIChpKGBmdW5jdGlvbiAke099KCR7eX0pIHtgKSwgbygpLCBoICYmIChpKFwid2l0aCAoX2N0eCkge1wiKSwgbygpLCBmICYmIChpKFxuICAgIGBjb25zdCB7ICR7ZC5tYXAobl8pLmpvaW4oXCIsIFwiKX0gfSA9IF9WdWVcbmAsXG4gICAgLTFcbiAgICAvKiBFbmQgKi9cbiAgKSwgbCgpKSksIHQuY29tcG9uZW50cy5sZW5ndGggJiYgKHRoKHQuY29tcG9uZW50cywgXCJjb21wb25lbnRcIiwgbiksICh0LmRpcmVjdGl2ZXMubGVuZ3RoIHx8IHQudGVtcHMgPiAwKSAmJiBsKCkpLCB0LmRpcmVjdGl2ZXMubGVuZ3RoICYmICh0aCh0LmRpcmVjdGl2ZXMsIFwiZGlyZWN0aXZlXCIsIG4pLCB0LnRlbXBzID4gMCAmJiBsKCkpLCB0LmZpbHRlcnMgJiYgdC5maWx0ZXJzLmxlbmd0aCAmJiAobCgpLCB0aCh0LmZpbHRlcnMsIFwiZmlsdGVyXCIsIG4pLCBsKCkpLCB0LnRlbXBzID4gMCkge1xuICAgIGkoXCJsZXQgXCIpO1xuICAgIGZvciAobGV0IGIgPSAwOyBiIDwgdC50ZW1wczsgYisrKVxuICAgICAgaShgJHtiID4gMCA/IFwiLCBcIiA6IFwiXCJ9X3RlbXAke2J9YCk7XG4gIH1cbiAgcmV0dXJuICh0LmNvbXBvbmVudHMubGVuZ3RoIHx8IHQuZGlyZWN0aXZlcy5sZW5ndGggfHwgdC50ZW1wcykgJiYgKGkoXG4gICAgYFxuYCxcbiAgICAwXG4gICAgLyogU3RhcnQgKi9cbiAgKSwgbCgpKSwgdSB8fCBpKFwicmV0dXJuIFwiKSwgdC5jb2RlZ2VuTm9kZSA/IGNuKHQuY29kZWdlbk5vZGUsIG4pIDogaShcIm51bGxcIiksIGggJiYgKGEoKSwgaShcIn1cIikpLCBhKCksIGkoXCJ9XCIpLCB7XG4gICAgYXN0OiB0LFxuICAgIGNvZGU6IG4uY29kZSxcbiAgICBwcmVhbWJsZTogXCJcIixcbiAgICBtYXA6IG4ubWFwID8gbi5tYXAudG9KU09OKCkgOiB2b2lkIDBcbiAgfTtcbn1cbmZ1bmN0aW9uIHA3KHQsIGUpIHtcbiAgY29uc3Qge1xuICAgIHNzcjogbixcbiAgICBwcmVmaXhJZGVudGlmaWVyczogcixcbiAgICBwdXNoOiBpLFxuICAgIG5ld2xpbmU6IHMsXG4gICAgcnVudGltZU1vZHVsZU5hbWU6IG8sXG4gICAgcnVudGltZUdsb2JhbE5hbWU6IGEsXG4gICAgc3NyUnVudGltZU1vZHVsZU5hbWU6IGxcbiAgfSA9IGUsIGMgPSBhLCB1ID0gQXJyYXkuZnJvbSh0LmhlbHBlcnMpO1xuICBpZiAodS5sZW5ndGggPiAwICYmIChpKFxuICAgIGBjb25zdCBfVnVlID0gJHtjfVxuYCxcbiAgICAtMVxuICAgIC8qIEVuZCAqL1xuICApLCB0LmhvaXN0cy5sZW5ndGgpKSB7XG4gICAgY29uc3QgZCA9IFtcbiAgICAgIEFnLFxuICAgICAgUmcsXG4gICAgICByYyxcbiAgICAgIE5nLFxuICAgICAgSVBcbiAgICBdLmZpbHRlcigoZikgPT4gdS5pbmNsdWRlcyhmKSkubWFwKG5fKS5qb2luKFwiLCBcIik7XG4gICAgaShcbiAgICAgIGBjb25zdCB7ICR7ZH0gfSA9IF9WdWVcbmAsXG4gICAgICAtMVxuICAgICAgLyogRW5kICovXG4gICAgKTtcbiAgfVxuICBPNyh0LmhvaXN0cywgZSksIHMoKSwgaShcInJldHVybiBcIik7XG59XG5mdW5jdGlvbiB0aCh0LCBlLCB7IGhlbHBlcjogbiwgcHVzaDogciwgbmV3bGluZTogaSwgaXNUUzogcyB9KSB7XG4gIGNvbnN0IG8gPSBuKFxuICAgIGUgPT09IFwiZmlsdGVyXCIgPyBJZyA6IGUgPT09IFwiY29tcG9uZW50XCIgPyBEZyA6IFZnXG4gICk7XG4gIGZvciAobGV0IGEgPSAwOyBhIDwgdC5sZW5ndGg7IGErKykge1xuICAgIGxldCBsID0gdFthXTtcbiAgICBjb25zdCBjID0gbC5lbmRzV2l0aChcIl9fc2VsZlwiKTtcbiAgICBjICYmIChsID0gbC5zbGljZSgwLCAtNikpLCByKFxuICAgICAgYGNvbnN0ICR7Q2wobCwgZSl9ID0gJHtvfSgke0pTT04uc3RyaW5naWZ5KGwpfSR7YyA/IFwiLCB0cnVlXCIgOiBcIlwifSkke3MgPyBcIiFcIiA6IFwiXCJ9YFxuICAgICksIGEgPCB0Lmxlbmd0aCAtIDEgJiYgaSgpO1xuICB9XG59XG5mdW5jdGlvbiBPNyh0LCBlKSB7XG4gIGlmICghdC5sZW5ndGgpXG4gICAgcmV0dXJuO1xuICBlLnB1cmUgPSAhMDtcbiAgY29uc3QgeyBwdXNoOiBuLCBuZXdsaW5lOiByLCBoZWxwZXI6IGksIHNjb3BlSWQ6IHMsIG1vZGU6IG8gfSA9IGU7XG4gIHIoKTtcbiAgZm9yIChsZXQgYSA9IDA7IGEgPCB0Lmxlbmd0aDsgYSsrKSB7XG4gICAgY29uc3QgbCA9IHRbYV07XG4gICAgbCAmJiAobihcbiAgICAgIGBjb25zdCBfaG9pc3RlZF8ke2EgKyAxfSA9IGBcbiAgICApLCBjbihsLCBlKSwgcigpKTtcbiAgfVxuICBlLnB1cmUgPSAhMTtcbn1cbmZ1bmN0aW9uIGc3KHQpIHtcbiAgcmV0dXJuIHdlKHQpIHx8IHQudHlwZSA9PT0gNCB8fCB0LnR5cGUgPT09IDIgfHwgdC50eXBlID09PSA1IHx8IHQudHlwZSA9PT0gODtcbn1cbmZ1bmN0aW9uIEhnKHQsIGUpIHtcbiAgY29uc3QgbiA9IHQubGVuZ3RoID4gMyB8fCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgdC5zb21lKChyKSA9PiBpZShyKSB8fCAhZzcocikpO1xuICBlLnB1c2goXCJbXCIpLCBuICYmIGUuaW5kZW50KCksIG9jKHQsIGUsIG4pLCBuICYmIGUuZGVpbmRlbnQoKSwgZS5wdXNoKFwiXVwiKTtcbn1cbmZ1bmN0aW9uIG9jKHQsIGUsIG4gPSAhMSwgciA9ICEwKSB7XG4gIGNvbnN0IHsgcHVzaDogaSwgbmV3bGluZTogcyB9ID0gZTtcbiAgZm9yIChsZXQgbyA9IDA7IG8gPCB0Lmxlbmd0aDsgbysrKSB7XG4gICAgY29uc3QgYSA9IHRbb107XG4gICAgd2UoYSkgPyBpKFxuICAgICAgYSxcbiAgICAgIC0zXG4gICAgICAvKiBVbmtub3duICovXG4gICAgKSA6IGllKGEpID8gSGcoYSwgZSkgOiBjbihhLCBlKSwgbyA8IHQubGVuZ3RoIC0gMSAmJiAobiA/IChyICYmIGkoXCIsXCIpLCBzKCkpIDogciAmJiBpKFwiLCBcIikpO1xuICB9XG59XG5mdW5jdGlvbiBjbih0LCBlKSB7XG4gIGlmICh3ZSh0KSkge1xuICAgIGUucHVzaChcbiAgICAgIHQsXG4gICAgICAtM1xuICAgICAgLyogVW5rbm93biAqL1xuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChPcih0KSkge1xuICAgIGUucHVzaChlLmhlbHBlcih0KSk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHN3aXRjaCAodC50eXBlKSB7XG4gICAgY2FzZSAxOlxuICAgIGNhc2UgOTpcbiAgICBjYXNlIDExOlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIEYwKFxuICAgICAgICB0LmNvZGVnZW5Ob2RlICE9IG51bGwsXG4gICAgICAgIFwiQ29kZWdlbiBub2RlIGlzIG1pc3NpbmcgZm9yIGVsZW1lbnQvaWYvZm9yIG5vZGUuIEFwcGx5IGFwcHJvcHJpYXRlIHRyYW5zZm9ybXMgZmlyc3QuXCJcbiAgICAgICksIGNuKHQuY29kZWdlbk5vZGUsIGUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyOlxuICAgICAgbTcodCwgZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDQ6XG4gICAgICByXyh0LCBlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNTpcbiAgICAgIGI3KHQsIGUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxMjpcbiAgICAgIGNuKHQuY29kZWdlbk5vZGUsIGUpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA4OlxuICAgICAgaV8odCwgZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6XG4gICAgICB5Nyh0LCBlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTM6XG4gICAgICBTNyh0LCBlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTQ6XG4gICAgICBrNyh0LCBlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTU6XG4gICAgICB4Nyh0LCBlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTc6XG4gICAgICBQNyh0LCBlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTg6XG4gICAgICBfNyh0LCBlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTk6XG4gICAgICBUNyh0LCBlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjA6XG4gICAgICBFNyh0LCBlKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjE6XG4gICAgICBvYyh0LmJvZHksIGUsICEwLCAhMSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDIyOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyMzpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMjQ6XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI1OlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAyNjpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTA6XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIilcbiAgICAgICAgcmV0dXJuIEYwKCExLCBgdW5oYW5kbGVkIGNvZGVnZW4gbm9kZSB0eXBlOiAke3QudHlwZX1gKSwgdDtcbiAgfVxufVxuZnVuY3Rpb24gbTcodCwgZSkge1xuICBlLnB1c2goSlNPTi5zdHJpbmdpZnkodC5jb250ZW50KSwgLTMsIHQpO1xufVxuZnVuY3Rpb24gcl8odCwgZSkge1xuICBjb25zdCB7IGNvbnRlbnQ6IG4sIGlzU3RhdGljOiByIH0gPSB0O1xuICBlLnB1c2goXG4gICAgciA/IEpTT04uc3RyaW5naWZ5KG4pIDogbixcbiAgICAtMyxcbiAgICB0XG4gICk7XG59XG5mdW5jdGlvbiBiNyh0LCBlKSB7XG4gIGNvbnN0IHsgcHVzaDogbiwgaGVscGVyOiByLCBwdXJlOiBpIH0gPSBlO1xuICBpICYmIG4odGYpLCBuKGAke3IoSmQpfShgKSwgY24odC5jb250ZW50LCBlKSwgbihcIilcIik7XG59XG5mdW5jdGlvbiBpXyh0LCBlKSB7XG4gIGZvciAobGV0IG4gPSAwOyBuIDwgdC5jaGlsZHJlbi5sZW5ndGg7IG4rKykge1xuICAgIGNvbnN0IHIgPSB0LmNoaWxkcmVuW25dO1xuICAgIHdlKHIpID8gZS5wdXNoKFxuICAgICAgcixcbiAgICAgIC0zXG4gICAgICAvKiBVbmtub3duICovXG4gICAgKSA6IGNuKHIsIGUpO1xuICB9XG59XG5mdW5jdGlvbiB2Nyh0LCBlKSB7XG4gIGNvbnN0IHsgcHVzaDogbiB9ID0gZTtcbiAgaWYgKHQudHlwZSA9PT0gOClcbiAgICBuKFwiW1wiKSwgaV8odCwgZSksIG4oXCJdXCIpO1xuICBlbHNlIGlmICh0LmlzU3RhdGljKSB7XG4gICAgY29uc3QgciA9IHpnKHQuY29udGVudCkgPyB0LmNvbnRlbnQgOiBKU09OLnN0cmluZ2lmeSh0LmNvbnRlbnQpO1xuICAgIG4ociwgLTIsIHQpO1xuICB9IGVsc2VcbiAgICBuKGBbJHt0LmNvbnRlbnR9XWAsIC0zLCB0KTtcbn1cbmZ1bmN0aW9uIHk3KHQsIGUpIHtcbiAgY29uc3QgeyBwdXNoOiBuLCBoZWxwZXI6IHIsIHB1cmU6IGkgfSA9IGU7XG4gIGkgJiYgbih0ZiksIG4oXG4gICAgYCR7cihyYyl9KCR7SlNPTi5zdHJpbmdpZnkodC5jb250ZW50KX0pYCxcbiAgICAtMyxcbiAgICB0XG4gICk7XG59XG5mdW5jdGlvbiBTNyh0LCBlKSB7XG4gIGNvbnN0IHsgcHVzaDogbiwgaGVscGVyOiByLCBwdXJlOiBpIH0gPSBlLCB7XG4gICAgdGFnOiBzLFxuICAgIHByb3BzOiBvLFxuICAgIGNoaWxkcmVuOiBhLFxuICAgIHBhdGNoRmxhZzogbCxcbiAgICBkeW5hbWljUHJvcHM6IGMsXG4gICAgZGlyZWN0aXZlczogdSxcbiAgICBpc0Jsb2NrOiBkLFxuICAgIGRpc2FibGVUcmFja2luZzogZixcbiAgICBpc0NvbXBvbmVudDogaFxuICB9ID0gdDtcbiAgdSAmJiBuKHIoV2cpICsgXCIoXCIpLCBkICYmIG4oYCgke3IoRnMpfSgke2YgPyBcInRydWVcIiA6IFwiXCJ9KSwgYCksIGkgJiYgbih0Zik7XG4gIGNvbnN0IHAgPSBkID8gS28oZS5pblNTUiwgaCkgOiBHbyhlLmluU1NSLCBoKTtcbiAgbihyKHApICsgXCIoXCIsIC0yLCB0KSwgb2MoXG4gICAgdzcoW3MsIG8sIGEsIGwsIGNdKSxcbiAgICBlXG4gICksIG4oXCIpXCIpLCBkICYmIG4oXCIpXCIpLCB1ICYmIChuKFwiLCBcIiksIGNuKHUsIGUpLCBuKFwiKVwiKSk7XG59XG5mdW5jdGlvbiB3Nyh0KSB7XG4gIGxldCBlID0gdC5sZW5ndGg7XG4gIGZvciAoOyBlLS0gJiYgdFtlXSA9PSBudWxsOyApXG4gICAgO1xuICByZXR1cm4gdC5zbGljZSgwLCBlICsgMSkubWFwKChuKSA9PiBuIHx8IFwibnVsbFwiKTtcbn1cbmZ1bmN0aW9uIGs3KHQsIGUpIHtcbiAgY29uc3QgeyBwdXNoOiBuLCBoZWxwZXI6IHIsIHB1cmU6IGkgfSA9IGUsIHMgPSB3ZSh0LmNhbGxlZSkgPyB0LmNhbGxlZSA6IHIodC5jYWxsZWUpO1xuICBpICYmIG4odGYpLCBuKHMgKyBcIihcIiwgLTIsIHQpLCBvYyh0LmFyZ3VtZW50cywgZSksIG4oXCIpXCIpO1xufVxuZnVuY3Rpb24geDcodCwgZSkge1xuICBjb25zdCB7IHB1c2g6IG4sIGluZGVudDogciwgZGVpbmRlbnQ6IGksIG5ld2xpbmU6IHMgfSA9IGUsIHsgcHJvcGVydGllczogbyB9ID0gdDtcbiAgaWYgKCFvLmxlbmd0aCkge1xuICAgIG4oXCJ7fVwiLCAtMiwgdCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGEgPSBvLmxlbmd0aCA+IDEgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIG8uc29tZSgobCkgPT4gbC52YWx1ZS50eXBlICE9PSA0KTtcbiAgbihhID8gXCJ7XCIgOiBcInsgXCIpLCBhICYmIHIoKTtcbiAgZm9yIChsZXQgbCA9IDA7IGwgPCBvLmxlbmd0aDsgbCsrKSB7XG4gICAgY29uc3QgeyBrZXk6IGMsIHZhbHVlOiB1IH0gPSBvW2xdO1xuICAgIHY3KGMsIGUpLCBuKFwiOiBcIiksIGNuKHUsIGUpLCBsIDwgby5sZW5ndGggLSAxICYmIChuKFwiLFwiKSwgcygpKTtcbiAgfVxuICBhICYmIGkoKSwgbihhID8gXCJ9XCIgOiBcIiB9XCIpO1xufVxuZnVuY3Rpb24gUDcodCwgZSkge1xuICBIZyh0LmVsZW1lbnRzLCBlKTtcbn1cbmZ1bmN0aW9uIF83KHQsIGUpIHtcbiAgY29uc3QgeyBwdXNoOiBuLCBpbmRlbnQ6IHIsIGRlaW5kZW50OiBpIH0gPSBlLCB7IHBhcmFtczogcywgcmV0dXJuczogbywgYm9keTogYSwgbmV3bGluZTogbCwgaXNTbG90OiBjIH0gPSB0O1xuICBjICYmIG4oYF8ke0hvW0xnXX0oYCksIG4oXCIoXCIsIC0yLCB0KSwgaWUocykgPyBvYyhzLCBlKSA6IHMgJiYgY24ocywgZSksIG4oXCIpID0+IFwiKSwgKGwgfHwgYSkgJiYgKG4oXCJ7XCIpLCByKCkpLCBvID8gKGwgJiYgbihcInJldHVybiBcIiksIGllKG8pID8gSGcobywgZSkgOiBjbihvLCBlKSkgOiBhICYmIGNuKGEsIGUpLCAobCB8fCBhKSAmJiAoaSgpLCBuKFwifVwiKSksIGMgJiYgKHQuaXNOb25TY29wZWRTbG90ICYmIG4oXCIsIHVuZGVmaW5lZCwgdHJ1ZVwiKSwgbihcIilcIikpO1xufVxuZnVuY3Rpb24gVDcodCwgZSkge1xuICBjb25zdCB7IHRlc3Q6IG4sIGNvbnNlcXVlbnQ6IHIsIGFsdGVybmF0ZTogaSwgbmV3bGluZTogcyB9ID0gdCwgeyBwdXNoOiBvLCBpbmRlbnQ6IGEsIGRlaW5kZW50OiBsLCBuZXdsaW5lOiBjIH0gPSBlO1xuICBpZiAobi50eXBlID09PSA0KSB7XG4gICAgY29uc3QgZCA9ICF6ZyhuLmNvbnRlbnQpO1xuICAgIGQgJiYgbyhcIihcIiksIHJfKG4sIGUpLCBkICYmIG8oXCIpXCIpO1xuICB9IGVsc2VcbiAgICBvKFwiKFwiKSwgY24obiwgZSksIG8oXCIpXCIpO1xuICBzICYmIGEoKSwgZS5pbmRlbnRMZXZlbCsrLCBzIHx8IG8oXCIgXCIpLCBvKFwiPyBcIiksIGNuKHIsIGUpLCBlLmluZGVudExldmVsLS0sIHMgJiYgYygpLCBzIHx8IG8oXCIgXCIpLCBvKFwiOiBcIik7XG4gIGNvbnN0IHUgPSBpLnR5cGUgPT09IDE5O1xuICB1IHx8IGUuaW5kZW50TGV2ZWwrKywgY24oaSwgZSksIHUgfHwgZS5pbmRlbnRMZXZlbC0tLCBzICYmIGwoXG4gICAgITBcbiAgICAvKiB3aXRob3V0IG5ld2xpbmUgKi9cbiAgKTtcbn1cbmZ1bmN0aW9uIEU3KHQsIGUpIHtcbiAgY29uc3QgeyBwdXNoOiBuLCBoZWxwZXI6IHIsIGluZGVudDogaSwgZGVpbmRlbnQ6IHMsIG5ld2xpbmU6IG8gfSA9IGU7XG4gIG4oYF9jYWNoZVske3QuaW5kZXh9XSB8fCAoYCksIHQuaXNWTm9kZSAmJiAoaSgpLCBuKGAke3IocmQpfSgtMSksYCksIG8oKSksIG4oYF9jYWNoZVske3QuaW5kZXh9XSA9IGApLCBjbih0LnZhbHVlLCBlKSwgdC5pc1ZOb2RlICYmIChuKFwiLFwiKSwgbygpLCBuKGAke3IocmQpfSgxKSxgKSwgbygpLCBuKGBfY2FjaGVbJHt0LmluZGV4fV1gKSwgcygpKSwgbihcIilcIik7XG59XG5jb25zdCAkNyA9IG5ldyBSZWdFeHAoXG4gIFwiXFxcXGJcIiArIFwiYXJndW1lbnRzLGF3YWl0LGJyZWFrLGNhc2UsY2F0Y2gsY2xhc3MsY29uc3QsY29udGludWUsZGVidWdnZXIsZGVmYXVsdCxkZWxldGUsZG8sZWxzZSxleHBvcnQsZXh0ZW5kcyxmaW5hbGx5LGZvcixmdW5jdGlvbixpZixpbXBvcnQsbGV0LG5ldyxyZXR1cm4sc3VwZXIsc3dpdGNoLHRocm93LHRyeSx2YXIsdm9pZCx3aGlsZSx3aXRoLHlpZWxkXCIuc3BsaXQoXCIsXCIpLmpvaW4oXCJcXFxcYnxcXFxcYlwiKSArIFwiXFxcXGJcIlxuKSwgUTcgPSAvJyg/OlteJ1xcXFxdfFxcXFwuKSonfFwiKD86W15cIlxcXFxdfFxcXFwuKSpcInxgKD86W15gXFxcXF18XFxcXC4pKlxcJFxce3xcXH0oPzpbXmBcXFxcXXxcXFxcLikqYHxgKD86W15gXFxcXF18XFxcXC4pKmAvZztcbmZ1bmN0aW9uIFFzKHQsIGUsIG4gPSAhMSwgciA9ICExKSB7XG4gIGNvbnN0IGkgPSB0LmNvbnRlbnQ7XG4gIGlmIChpLnRyaW0oKSlcbiAgICB0cnkge1xuICAgICAgbmV3IEZ1bmN0aW9uKFxuICAgICAgICByID8gYCAke2l9IGAgOiBgcmV0dXJuICR7biA/IGAoJHtpfSkgPT4ge31gIDogYCgke2l9KWB9YFxuICAgICAgKTtcbiAgICB9IGNhdGNoIChzKSB7XG4gICAgICBsZXQgbyA9IHMubWVzc2FnZTtcbiAgICAgIGNvbnN0IGEgPSBpLnJlcGxhY2UoUTcsIFwiXCIpLm1hdGNoKCQ3KTtcbiAgICAgIGEgJiYgKG8gPSBgYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCBrZXl3b3JkIGFzIHByb3BlcnR5IG5hbWU6IFwiJHthWzBdfVwiYCksIGUub25FcnJvcihcbiAgICAgICAgR2UoXG4gICAgICAgICAgNDUsXG4gICAgICAgICAgdC5sb2MsXG4gICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgIG9cbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG59XG5jb25zdCBDNyA9ICh0LCBlKSA9PiB7XG4gIGlmICh0LnR5cGUgPT09IDUpXG4gICAgdC5jb250ZW50ID0gbmgoXG4gICAgICB0LmNvbnRlbnQsXG4gICAgICBlXG4gICAgKTtcbiAgZWxzZSBpZiAodC50eXBlID09PSAxKVxuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgdC5wcm9wcy5sZW5ndGg7IG4rKykge1xuICAgICAgY29uc3QgciA9IHQucHJvcHNbbl07XG4gICAgICBpZiAoci50eXBlID09PSA3ICYmIHIubmFtZSAhPT0gXCJmb3JcIikge1xuICAgICAgICBjb25zdCBpID0gci5leHAsIHMgPSByLmFyZztcbiAgICAgICAgaSAmJiBpLnR5cGUgPT09IDQgJiYgIShyLm5hbWUgPT09IFwib25cIiAmJiBzKSAmJiAoci5leHAgPSBuaChcbiAgICAgICAgICBpLFxuICAgICAgICAgIGUsXG4gICAgICAgICAgLy8gc2xvdCBhcmdzIG11c3QgYmUgcHJvY2Vzc2VkIGFzIGZ1bmN0aW9uIHBhcmFtc1xuICAgICAgICAgIHIubmFtZSA9PT0gXCJzbG90XCJcbiAgICAgICAgKSksIHMgJiYgcy50eXBlID09PSA0ICYmICFzLmlzU3RhdGljICYmIChyLmFyZyA9IG5oKHMsIGUpKTtcbiAgICAgIH1cbiAgICB9XG59O1xuZnVuY3Rpb24gbmgodCwgZSwgbiA9ICExLCByID0gITEsIGkgPSBPYmplY3QuY3JlYXRlKGUuaWRlbnRpZmllcnMpKSB7XG4gIHJldHVybiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgUXModCwgZSwgbiwgciksIHQ7XG59XG5jb25zdCBBNyA9IHRfKFxuICAvXihpZnxlbHNlfGVsc2UtaWYpJC8sXG4gICh0LCBlLCBuKSA9PiBSNyh0LCBlLCBuLCAociwgaSwgcykgPT4ge1xuICAgIGNvbnN0IG8gPSBuLnBhcmVudC5jaGlsZHJlbjtcbiAgICBsZXQgYSA9IG8uaW5kZXhPZihyKSwgbCA9IDA7XG4gICAgZm9yICg7IGEtLSA+PSAwOyApIHtcbiAgICAgIGNvbnN0IGMgPSBvW2FdO1xuICAgICAgYyAmJiBjLnR5cGUgPT09IDkgJiYgKGwgKz0gYy5icmFuY2hlcy5sZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKHMpXG4gICAgICAgIHIuY29kZWdlbk5vZGUgPSBueShcbiAgICAgICAgICBpLFxuICAgICAgICAgIGwsXG4gICAgICAgICAgblxuICAgICAgICApO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGMgPSBENyhyLmNvZGVnZW5Ob2RlKTtcbiAgICAgICAgYy5hbHRlcm5hdGUgPSBueShcbiAgICAgICAgICBpLFxuICAgICAgICAgIGwgKyByLmJyYW5jaGVzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgblxuICAgICAgICApO1xuICAgICAgfVxuICAgIH07XG4gIH0pXG4pO1xuZnVuY3Rpb24gUjcodCwgZSwgbiwgcikge1xuICBpZiAoZS5uYW1lICE9PSBcImVsc2VcIiAmJiAoIWUuZXhwIHx8ICFlLmV4cC5jb250ZW50LnRyaW0oKSkpIHtcbiAgICBjb25zdCBpID0gZS5leHAgPyBlLmV4cC5sb2MgOiB0LmxvYztcbiAgICBuLm9uRXJyb3IoXG4gICAgICBHZSgyOCwgZS5sb2MpXG4gICAgKSwgZS5leHAgPSBFZShcInRydWVcIiwgITEsIGkpO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZS5leHAgJiYgUXMoZS5leHAsIG4pLCBlLm5hbWUgPT09IFwiaWZcIikge1xuICAgIGNvbnN0IGkgPSB0eSh0LCBlKSwgcyA9IHtcbiAgICAgIHR5cGU6IDksXG4gICAgICBsb2M6IHQubG9jLFxuICAgICAgYnJhbmNoZXM6IFtpXVxuICAgIH07XG4gICAgaWYgKG4ucmVwbGFjZU5vZGUocyksIHIpXG4gICAgICByZXR1cm4gcihzLCBpLCAhMCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgaSA9IG4ucGFyZW50LmNoaWxkcmVuLCBzID0gW107XG4gICAgbGV0IG8gPSBpLmluZGV4T2YodCk7XG4gICAgZm9yICg7IG8tLSA+PSAtMTsgKSB7XG4gICAgICBjb25zdCBhID0gaVtvXTtcbiAgICAgIGlmIChhICYmIGEudHlwZSA9PT0gMykge1xuICAgICAgICBuLnJlbW92ZU5vZGUoYSksIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBzLnVuc2hpZnQoYSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGEgJiYgYS50eXBlID09PSAyICYmICFhLmNvbnRlbnQudHJpbSgpLmxlbmd0aCkge1xuICAgICAgICBuLnJlbW92ZU5vZGUoYSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKGEgJiYgYS50eXBlID09PSA5KSB7XG4gICAgICAgIGUubmFtZSA9PT0gXCJlbHNlLWlmXCIgJiYgYS5icmFuY2hlc1thLmJyYW5jaGVzLmxlbmd0aCAtIDFdLmNvbmRpdGlvbiA9PT0gdm9pZCAwICYmIG4ub25FcnJvcihcbiAgICAgICAgICBHZSgzMCwgdC5sb2MpXG4gICAgICAgICksIG4ucmVtb3ZlTm9kZSgpO1xuICAgICAgICBjb25zdCBsID0gdHkodCwgZSk7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgcy5sZW5ndGggJiYgLy8gIzM2MTkgaWdub3JlIGNvbW1lbnRzIGlmIHRoZSB2LWlmIGlzIGRpcmVjdCBjaGlsZCBvZiA8dHJhbnNpdGlvbj5cbiAgICAgICAgIShuLnBhcmVudCAmJiBuLnBhcmVudC50eXBlID09PSAxICYmIChuLnBhcmVudC50YWcgPT09IFwidHJhbnNpdGlvblwiIHx8IG4ucGFyZW50LnRhZyA9PT0gXCJUcmFuc2l0aW9uXCIpKSAmJiAobC5jaGlsZHJlbiA9IFsuLi5zLCAuLi5sLmNoaWxkcmVuXSksIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgIGNvbnN0IHUgPSBsLnVzZXJLZXk7XG4gICAgICAgICAgdSAmJiBhLmJyYW5jaGVzLmZvckVhY2goKHsgdXNlcktleTogZCB9KSA9PiB7XG4gICAgICAgICAgICBONyhkLCB1KSAmJiBuLm9uRXJyb3IoXG4gICAgICAgICAgICAgIEdlKFxuICAgICAgICAgICAgICAgIDI5LFxuICAgICAgICAgICAgICAgIGwudXNlcktleS5sb2NcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhLmJyYW5jaGVzLnB1c2gobCk7XG4gICAgICAgIGNvbnN0IGMgPSByICYmIHIoYSwgbCwgITEpO1xuICAgICAgICBlZihsLCBuKSwgYyAmJiBjKCksIG4uY3VycmVudE5vZGUgPSBudWxsO1xuICAgICAgfSBlbHNlXG4gICAgICAgIG4ub25FcnJvcihcbiAgICAgICAgICBHZSgzMCwgdC5sb2MpXG4gICAgICAgICk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHR5KHQsIGUpIHtcbiAgY29uc3QgbiA9IHQudGFnVHlwZSA9PT0gMztcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAxMCxcbiAgICBsb2M6IHQubG9jLFxuICAgIGNvbmRpdGlvbjogZS5uYW1lID09PSBcImVsc2VcIiA/IHZvaWQgMCA6IGUuZXhwLFxuICAgIGNoaWxkcmVuOiBuICYmICF6bih0LCBcImZvclwiKSA/IHQuY2hpbGRyZW4gOiBbdF0sXG4gICAgdXNlcktleTogUWwodCwgXCJrZXlcIiksXG4gICAgaXNUZW1wbGF0ZUlmOiBuXG4gIH07XG59XG5mdW5jdGlvbiBueSh0LCBlLCBuKSB7XG4gIHJldHVybiB0LmNvbmRpdGlvbiA/IEJwKFxuICAgIHQuY29uZGl0aW9uLFxuICAgIHJ5KHQsIGUsIG4pLFxuICAgIC8vIG1ha2Ugc3VyZSB0byBwYXNzIGluIGFzQmxvY2s6IHRydWUgc28gdGhhdCB0aGUgY29tbWVudCBub2RlIGNhbGxcbiAgICAvLyBjbG9zZXMgdGhlIGN1cnJlbnQgYmxvY2suXG4gICAgRHQobi5oZWxwZXIocmMpLCBbXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyAnXCJ2LWlmXCInIDogJ1wiXCInLFxuICAgICAgXCJ0cnVlXCJcbiAgICBdKVxuICApIDogcnkodCwgZSwgbik7XG59XG5mdW5jdGlvbiByeSh0LCBlLCBuKSB7XG4gIGNvbnN0IHsgaGVscGVyOiByIH0gPSBuLCBpID0geXQoXG4gICAgXCJrZXlcIixcbiAgICBFZShcbiAgICAgIGAke2V9YCxcbiAgICAgICExLFxuICAgICAgTG4sXG4gICAgICAyXG4gICAgKVxuICApLCB7IGNoaWxkcmVuOiBzIH0gPSB0LCBvID0gc1swXTtcbiAgaWYgKHMubGVuZ3RoICE9PSAxIHx8IG8udHlwZSAhPT0gMSlcbiAgICBpZiAocy5sZW5ndGggPT09IDEgJiYgby50eXBlID09PSAxMSkge1xuICAgICAgY29uc3QgbCA9IG8uY29kZWdlbk5vZGU7XG4gICAgICByZXR1cm4gbGQobCwgaSwgbiksIGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBsID0gNjQsIGMgPSBEcls2NF07XG4gICAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICF0LmlzVGVtcGxhdGVJZiAmJiBzLmZpbHRlcigodSkgPT4gdS50eXBlICE9PSAzKS5sZW5ndGggPT09IDEgJiYgKGwgfD0gMjA0OCwgYyArPSBgLCAke0RyWzIwNDhdfWApLCAkbChcbiAgICAgICAgbixcbiAgICAgICAgcihUbCksXG4gICAgICAgIEduKFtpXSksXG4gICAgICAgIHMsXG4gICAgICAgIGwgKyAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gYCAvKiAke2N9ICovYCA6IFwiXCIpLFxuICAgICAgICB2b2lkIDAsXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgITAsXG4gICAgICAgICExLFxuICAgICAgICAhMSxcbiAgICAgICAgdC5sb2NcbiAgICAgICk7XG4gICAgfVxuICBlbHNlIHtcbiAgICBjb25zdCBsID0gby5jb2RlZ2VuTm9kZSwgYyA9IFk0KGwpO1xuICAgIHJldHVybiBjLnR5cGUgPT09IDEzICYmIHFnKGMsIG4pLCBsZChjLCBpLCBuKSwgbDtcbiAgfVxufVxuZnVuY3Rpb24gTjcodCwgZSkge1xuICBpZiAoIXQgfHwgdC50eXBlICE9PSBlLnR5cGUpXG4gICAgcmV0dXJuICExO1xuICBpZiAodC50eXBlID09PSA2KSB7XG4gICAgaWYgKHQudmFsdWUuY29udGVudCAhPT0gZS52YWx1ZS5jb250ZW50KVxuICAgICAgcmV0dXJuICExO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG4gPSB0LmV4cCwgciA9IGUuZXhwO1xuICAgIGlmIChuLnR5cGUgIT09IHIudHlwZSB8fCBuLnR5cGUgIT09IDQgfHwgbi5pc1N0YXRpYyAhPT0gci5pc1N0YXRpYyB8fCBuLmNvbnRlbnQgIT09IHIuY29udGVudClcbiAgICAgIHJldHVybiAhMTtcbiAgfVxuICByZXR1cm4gITA7XG59XG5mdW5jdGlvbiBENyh0KSB7XG4gIGZvciAoOyA7IClcbiAgICBpZiAodC50eXBlID09PSAxOSlcbiAgICAgIGlmICh0LmFsdGVybmF0ZS50eXBlID09PSAxOSlcbiAgICAgICAgdCA9IHQuYWx0ZXJuYXRlO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gdDtcbiAgICBlbHNlXG4gICAgICB0LnR5cGUgPT09IDIwICYmICh0ID0gdC52YWx1ZSk7XG59XG5jb25zdCBaNyA9IHRfKFxuICBcImZvclwiLFxuICAodCwgZSwgbikgPT4ge1xuICAgIGNvbnN0IHsgaGVscGVyOiByLCByZW1vdmVIZWxwZXI6IGkgfSA9IG47XG4gICAgcmV0dXJuIFY3KHQsIGUsIG4sIChzKSA9PiB7XG4gICAgICBjb25zdCBvID0gRHQocihNZyksIFtcbiAgICAgICAgcy5zb3VyY2VcbiAgICAgIF0pLCBhID0gb2QodCksIGwgPSB6bih0LCBcIm1lbW9cIiksIGMgPSBRbCh0LCBcImtleVwiKSwgdSA9IGMgJiYgKGMudHlwZSA9PT0gNiA/IEVlKGMudmFsdWUuY29udGVudCwgITApIDogYy5leHApLCBkID0gYyA/IHl0KFwia2V5XCIsIHUpIDogbnVsbCwgZiA9IHMuc291cmNlLnR5cGUgPT09IDQgJiYgcy5zb3VyY2UuY29uc3RUeXBlID4gMCwgaCA9IGYgPyA2NCA6IGMgPyAxMjggOiAyNTY7XG4gICAgICByZXR1cm4gcy5jb2RlZ2VuTm9kZSA9ICRsKFxuICAgICAgICBuLFxuICAgICAgICByKFRsKSxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICBvLFxuICAgICAgICBoICsgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGAgLyogJHtEcltoXX0gKi9gIDogXCJcIiksXG4gICAgICAgIHZvaWQgMCxcbiAgICAgICAgdm9pZCAwLFxuICAgICAgICAhMCxcbiAgICAgICAgIWYsXG4gICAgICAgICExLFxuICAgICAgICB0LmxvY1xuICAgICAgKSwgKCkgPT4ge1xuICAgICAgICBsZXQgcDtcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbjogTyB9ID0gcztcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIGEgJiYgdC5jaGlsZHJlbi5zb21lKChiKSA9PiB7XG4gICAgICAgICAgaWYgKGIudHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgY29uc3QgZyA9IFFsKGIsIFwia2V5XCIpO1xuICAgICAgICAgICAgaWYgKGcpXG4gICAgICAgICAgICAgIHJldHVybiBuLm9uRXJyb3IoXG4gICAgICAgICAgICAgICAgR2UoXG4gICAgICAgICAgICAgICAgICAzMyxcbiAgICAgICAgICAgICAgICAgIGcubG9jXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApLCAhMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBtID0gTy5sZW5ndGggIT09IDEgfHwgT1swXS50eXBlICE9PSAxLCB5ID0gYWQodCkgPyB0IDogYSAmJiB0LmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJiBhZCh0LmNoaWxkcmVuWzBdKSA/IHQuY2hpbGRyZW5bMF0gOiBudWxsO1xuICAgICAgICBpZiAoeSA/IChwID0geS5jb2RlZ2VuTm9kZSwgYSAmJiBkICYmIGxkKHAsIGQsIG4pKSA6IG0gPyBwID0gJGwoXG4gICAgICAgICAgbixcbiAgICAgICAgICByKFRsKSxcbiAgICAgICAgICBkID8gR24oW2RdKSA6IHZvaWQgMCxcbiAgICAgICAgICB0LmNoaWxkcmVuLFxuICAgICAgICAgIDY0ICsgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGAgLyogJHtEcls2NF19ICovYCA6IFwiXCIpLFxuICAgICAgICAgIHZvaWQgMCxcbiAgICAgICAgICB2b2lkIDAsXG4gICAgICAgICAgITAsXG4gICAgICAgICAgdm9pZCAwLFxuICAgICAgICAgICExXG4gICAgICAgICkgOiAocCA9IE9bMF0uY29kZWdlbk5vZGUsIGEgJiYgZCAmJiBsZChwLCBkLCBuKSwgcC5pc0Jsb2NrICE9PSAhZiAmJiAocC5pc0Jsb2NrID8gKGkoRnMpLCBpKFxuICAgICAgICAgIEtvKG4uaW5TU1IsIHAuaXNDb21wb25lbnQpXG4gICAgICAgICkpIDogaShcbiAgICAgICAgICBHbyhuLmluU1NSLCBwLmlzQ29tcG9uZW50KVxuICAgICAgICApKSwgcC5pc0Jsb2NrID0gIWYsIHAuaXNCbG9jayA/IChyKEZzKSwgcihLbyhuLmluU1NSLCBwLmlzQ29tcG9uZW50KSkpIDogcihHbyhuLmluU1NSLCBwLmlzQ29tcG9uZW50KSkpLCBsKSB7XG4gICAgICAgICAgY29uc3QgYiA9IEZvKFxuICAgICAgICAgICAgWXAocy5wYXJzZVJlc3VsdCwgW1xuICAgICAgICAgICAgICBFZShcIl9jYWNoZWRcIilcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgKTtcbiAgICAgICAgICBiLmJvZHkgPSBENChbXG4gICAgICAgICAgICBwcihbXCJjb25zdCBfbWVtbyA9IChcIiwgbC5leHAsIFwiKVwiXSksXG4gICAgICAgICAgICBwcihbXG4gICAgICAgICAgICAgIFwiaWYgKF9jYWNoZWRcIixcbiAgICAgICAgICAgICAgLi4udSA/IFtcIiAmJiBfY2FjaGVkLmtleSA9PT0gXCIsIHVdIDogW10sXG4gICAgICAgICAgICAgIGAgJiYgJHtuLmhlbHBlclN0cmluZyhcbiAgICAgICAgICAgICAgICBYUFxuICAgICAgICAgICAgICApfShfY2FjaGVkLCBfbWVtbykpIHJldHVybiBfY2FjaGVkYFxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBwcihbXCJjb25zdCBfaXRlbSA9IFwiLCBwXSksXG4gICAgICAgICAgICBFZShcIl9pdGVtLm1lbW8gPSBfbWVtb1wiKSxcbiAgICAgICAgICAgIEVlKFwicmV0dXJuIF9pdGVtXCIpXG4gICAgICAgICAgXSksIG8uYXJndW1lbnRzLnB1c2goXG4gICAgICAgICAgICBiLFxuICAgICAgICAgICAgRWUoXCJfY2FjaGVcIiksXG4gICAgICAgICAgICBFZShTdHJpbmcobi5jYWNoZWQrKykpXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgby5hcmd1bWVudHMucHVzaChcbiAgICAgICAgICAgIEZvKFxuICAgICAgICAgICAgICBZcChzLnBhcnNlUmVzdWx0KSxcbiAgICAgICAgICAgICAgcCxcbiAgICAgICAgICAgICAgITBcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuKTtcbmZ1bmN0aW9uIFY3KHQsIGUsIG4sIHIpIHtcbiAgaWYgKCFlLmV4cCkge1xuICAgIG4ub25FcnJvcihcbiAgICAgIEdlKDMxLCBlLmxvYylcbiAgICApO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBpID0gZS5mb3JQYXJzZVJlc3VsdDtcbiAgaWYgKCFpKSB7XG4gICAgbi5vbkVycm9yKFxuICAgICAgR2UoMzIsIGUubG9jKVxuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHNfKGksIG4pO1xuICBjb25zdCB7IGFkZElkZW50aWZpZXJzOiBzLCByZW1vdmVJZGVudGlmaWVyczogbywgc2NvcGVzOiBhIH0gPSBuLCB7IHNvdXJjZTogbCwgdmFsdWU6IGMsIGtleTogdSwgaW5kZXg6IGQgfSA9IGksIGYgPSB7XG4gICAgdHlwZTogMTEsXG4gICAgbG9jOiBlLmxvYyxcbiAgICBzb3VyY2U6IGwsXG4gICAgdmFsdWVBbGlhczogYyxcbiAgICBrZXlBbGlhczogdSxcbiAgICBvYmplY3RJbmRleEFsaWFzOiBkLFxuICAgIHBhcnNlUmVzdWx0OiBpLFxuICAgIGNoaWxkcmVuOiBvZCh0KSA/IHQuY2hpbGRyZW4gOiBbdF1cbiAgfTtcbiAgbi5yZXBsYWNlTm9kZShmKSwgYS52Rm9yKys7XG4gIGNvbnN0IGggPSByICYmIHIoZik7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgYS52Rm9yLS0sIGggJiYgaCgpO1xuICB9O1xufVxuZnVuY3Rpb24gc18odCwgZSkge1xuICB0LmZpbmFsaXplZCB8fCAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIChRcyh0LnNvdXJjZSwgZSksIHQua2V5ICYmIFFzKFxuICAgIHQua2V5LFxuICAgIGUsXG4gICAgITBcbiAgKSwgdC5pbmRleCAmJiBRcyhcbiAgICB0LmluZGV4LFxuICAgIGUsXG4gICAgITBcbiAgKSwgdC52YWx1ZSAmJiBRcyhcbiAgICB0LnZhbHVlLFxuICAgIGUsXG4gICAgITBcbiAgKSksIHQuZmluYWxpemVkID0gITApO1xufVxuZnVuY3Rpb24gWXAoeyB2YWx1ZTogdCwga2V5OiBlLCBpbmRleDogbiB9LCByID0gW10pIHtcbiAgcmV0dXJuIEk3KFt0LCBlLCBuLCAuLi5yXSk7XG59XG5mdW5jdGlvbiBJNyh0KSB7XG4gIGxldCBlID0gdC5sZW5ndGg7XG4gIGZvciAoOyBlLS0gJiYgIXRbZV07IClcbiAgICA7XG4gIHJldHVybiB0LnNsaWNlKDAsIGUgKyAxKS5tYXAoKG4sIHIpID0+IG4gfHwgRWUoXCJfXCIucmVwZWF0KHIgKyAxKSwgITEpKTtcbn1cbmNvbnN0IGl5ID0gRWUoXCJ1bmRlZmluZWRcIiwgITEpLCBXNyA9ICh0LCBlKSA9PiB7XG4gIGlmICh0LnR5cGUgPT09IDEgJiYgKHQudGFnVHlwZSA9PT0gMSB8fCB0LnRhZ1R5cGUgPT09IDMpKSB7XG4gICAgY29uc3QgbiA9IHpuKHQsIFwic2xvdFwiKTtcbiAgICBpZiAobilcbiAgICAgIHJldHVybiBuLmV4cCwgZS5zY29wZXMudlNsb3QrKywgKCkgPT4ge1xuICAgICAgICBlLnNjb3Blcy52U2xvdC0tO1xuICAgICAgfTtcbiAgfVxufSwgTTcgPSAodCwgZSwgbiwgcikgPT4gRm8oXG4gIHQsXG4gIG4sXG4gICExLFxuICAhMCxcbiAgbi5sZW5ndGggPyBuWzBdLmxvYyA6IHJcbik7XG5mdW5jdGlvbiBYNyh0LCBlLCBuID0gTTcpIHtcbiAgZS5oZWxwZXIoTGcpO1xuICBjb25zdCB7IGNoaWxkcmVuOiByLCBsb2M6IGkgfSA9IHQsIHMgPSBbXSwgbyA9IFtdO1xuICBsZXQgYSA9IGUuc2NvcGVzLnZTbG90ID4gMCB8fCBlLnNjb3Blcy52Rm9yID4gMDtcbiAgY29uc3QgbCA9IHpuKHQsIFwic2xvdFwiLCAhMCk7XG4gIGlmIChsKSB7XG4gICAgY29uc3QgeyBhcmc6IG0sIGV4cDogeSB9ID0gbDtcbiAgICBtICYmICF4bihtKSAmJiAoYSA9ICEwKSwgcy5wdXNoKFxuICAgICAgeXQoXG4gICAgICAgIG0gfHwgRWUoXCJkZWZhdWx0XCIsICEwKSxcbiAgICAgICAgbih5LCB2b2lkIDAsIHIsIGkpXG4gICAgICApXG4gICAgKTtcbiAgfVxuICBsZXQgYyA9ICExLCB1ID0gITE7XG4gIGNvbnN0IGQgPSBbXSwgZiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGxldCBoID0gMDtcbiAgZm9yIChsZXQgbSA9IDA7IG0gPCByLmxlbmd0aDsgbSsrKSB7XG4gICAgY29uc3QgeSA9IHJbbV07XG4gICAgbGV0IGI7XG4gICAgaWYgKCFvZCh5KSB8fCAhKGIgPSB6bih5LCBcInNsb3RcIiwgITApKSkge1xuICAgICAgeS50eXBlICE9PSAzICYmIGQucHVzaCh5KTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobCkge1xuICAgICAgZS5vbkVycm9yKFxuICAgICAgICBHZSgzNywgYi5sb2MpXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGMgPSAhMDtcbiAgICBjb25zdCB7IGNoaWxkcmVuOiBnLCBsb2M6IHYgfSA9IHksIHtcbiAgICAgIGFyZzogUyA9IEVlKFwiZGVmYXVsdFwiLCAhMCksXG4gICAgICBleHA6IHcsXG4gICAgICBsb2M6IGtcbiAgICB9ID0gYjtcbiAgICBsZXQgXztcbiAgICB4bihTKSA/IF8gPSBTID8gUy5jb250ZW50IDogXCJkZWZhdWx0XCIgOiBhID0gITA7XG4gICAgY29uc3QgVCA9IHpuKHksIFwiZm9yXCIpLCBDID0gbih3LCBULCBnLCB2KTtcbiAgICBsZXQgQSwgUTtcbiAgICBpZiAoQSA9IHpuKHksIFwiaWZcIikpXG4gICAgICBhID0gITAsIG8ucHVzaChcbiAgICAgICAgQnAoXG4gICAgICAgICAgQS5leHAsXG4gICAgICAgICAgcWMoUywgQywgaCsrKSxcbiAgICAgICAgICBpeVxuICAgICAgICApXG4gICAgICApO1xuICAgIGVsc2UgaWYgKFEgPSB6bihcbiAgICAgIHksXG4gICAgICAvXmVsc2UoLWlmKT8kLyxcbiAgICAgICEwXG4gICAgICAvKiBhbGxvd0VtcHR5ICovXG4gICAgKSkge1xuICAgICAgbGV0IFcgPSBtLCBMO1xuICAgICAgZm9yICg7IFctLSAmJiAoTCA9IHJbV10sIEwudHlwZSA9PT0gMyk7IClcbiAgICAgICAgO1xuICAgICAgaWYgKEwgJiYgb2QoTCkgJiYgem4oTCwgXCJpZlwiKSkge1xuICAgICAgICByLnNwbGljZShtLCAxKSwgbS0tO1xuICAgICAgICBsZXQgcmUgPSBvW28ubGVuZ3RoIC0gMV07XG4gICAgICAgIGZvciAoOyByZS5hbHRlcm5hdGUudHlwZSA9PT0gMTk7IClcbiAgICAgICAgICByZSA9IHJlLmFsdGVybmF0ZTtcbiAgICAgICAgcmUuYWx0ZXJuYXRlID0gUS5leHAgPyBCcChcbiAgICAgICAgICBRLmV4cCxcbiAgICAgICAgICBxYyhcbiAgICAgICAgICAgIFMsXG4gICAgICAgICAgICBDLFxuICAgICAgICAgICAgaCsrXG4gICAgICAgICAgKSxcbiAgICAgICAgICBpeVxuICAgICAgICApIDogcWMoUywgQywgaCsrKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBlLm9uRXJyb3IoXG4gICAgICAgICAgR2UoMzAsIFEubG9jKVxuICAgICAgICApO1xuICAgIH0gZWxzZSBpZiAoVCkge1xuICAgICAgYSA9ICEwO1xuICAgICAgY29uc3QgVyA9IFQuZm9yUGFyc2VSZXN1bHQ7XG4gICAgICBXID8gKHNfKFcsIGUpLCBvLnB1c2goXG4gICAgICAgIER0KGUuaGVscGVyKE1nKSwgW1xuICAgICAgICAgIFcuc291cmNlLFxuICAgICAgICAgIEZvKFxuICAgICAgICAgICAgWXAoVyksXG4gICAgICAgICAgICBxYyhTLCBDKSxcbiAgICAgICAgICAgICEwXG4gICAgICAgICAgKVxuICAgICAgICBdKVxuICAgICAgKSkgOiBlLm9uRXJyb3IoXG4gICAgICAgIEdlKFxuICAgICAgICAgIDMyLFxuICAgICAgICAgIFQubG9jXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChfKSB7XG4gICAgICAgIGlmIChmLmhhcyhfKSkge1xuICAgICAgICAgIGUub25FcnJvcihcbiAgICAgICAgICAgIEdlKFxuICAgICAgICAgICAgICAzOCxcbiAgICAgICAgICAgICAga1xuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZi5hZGQoXyksIF8gPT09IFwiZGVmYXVsdFwiICYmICh1ID0gITApO1xuICAgICAgfVxuICAgICAgcy5wdXNoKHl0KFMsIEMpKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFsKSB7XG4gICAgY29uc3QgbSA9ICh5LCBiKSA9PiB7XG4gICAgICBjb25zdCBnID0gbih5LCB2b2lkIDAsIGIsIGkpO1xuICAgICAgcmV0dXJuIGUuY29tcGF0Q29uZmlnICYmIChnLmlzTm9uU2NvcGVkU2xvdCA9ICEwKSwgeXQoXCJkZWZhdWx0XCIsIGcpO1xuICAgIH07XG4gICAgYyA/IGQubGVuZ3RoICYmIC8vICMzNzY2XG4gICAgLy8gd2l0aCB3aGl0ZXNwYWNlOiAncHJlc2VydmUnLCB3aGl0ZXNwYWNlcyBiZXR3ZWVuIHNsb3RzIHdpbGwgZW5kIHVwIGluXG4gICAgLy8gaW1wbGljaXREZWZhdWx0Q2hpbGRyZW4uIElnbm9yZSBpZiBhbGwgaW1wbGljaXQgY2hpbGRyZW4gYXJlIHdoaXRlc3BhY2VzLlxuICAgIGQuc29tZSgoeSkgPT4gb18oeSkpICYmICh1ID8gZS5vbkVycm9yKFxuICAgICAgR2UoXG4gICAgICAgIDM5LFxuICAgICAgICBkWzBdLmxvY1xuICAgICAgKVxuICAgICkgOiBzLnB1c2goXG4gICAgICBtKHZvaWQgMCwgZClcbiAgICApKSA6IHMucHVzaChtKHZvaWQgMCwgcikpO1xuICB9XG4gIGNvbnN0IHAgPSBhID8gMiA6IGd1KHQuY2hpbGRyZW4pID8gMyA6IDE7XG4gIGxldCBPID0gR24oXG4gICAgcy5jb25jYXQoXG4gICAgICB5dChcbiAgICAgICAgXCJfXCIsXG4gICAgICAgIC8vIDIgPSBjb21waWxlZCBidXQgZHluYW1pYyA9IGNhbiBza2lwIG5vcm1hbGl6YXRpb24sIGJ1dCBtdXN0IHJ1biBkaWZmXG4gICAgICAgIC8vIDEgPSBjb21waWxlZCBhbmQgc3RhdGljID0gY2FuIHNraXAgbm9ybWFsaXphdGlvbiBBTkQgZGlmZiBhcyBvcHRpbWl6ZWRcbiAgICAgICAgRWUoXG4gICAgICAgICAgcCArIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBgIC8qICR7Vl9bcF19ICovYCA6IFwiXCIpLFxuICAgICAgICAgICExXG4gICAgICAgIClcbiAgICAgIClcbiAgICApLFxuICAgIGlcbiAgKTtcbiAgcmV0dXJuIG8ubGVuZ3RoICYmIChPID0gRHQoZS5oZWxwZXIoTVApLCBbXG4gICAgTyxcbiAgICBzYyhvKVxuICBdKSksIHtcbiAgICBzbG90czogTyxcbiAgICBoYXNEeW5hbWljU2xvdHM6IGFcbiAgfTtcbn1cbmZ1bmN0aW9uIHFjKHQsIGUsIG4pIHtcbiAgY29uc3QgciA9IFtcbiAgICB5dChcIm5hbWVcIiwgdCksXG4gICAgeXQoXCJmblwiLCBlKVxuICBdO1xuICByZXR1cm4gbiAhPSBudWxsICYmIHIucHVzaChcbiAgICB5dChcImtleVwiLCBFZShTdHJpbmcobiksICEwKSlcbiAgKSwgR24ocik7XG59XG5mdW5jdGlvbiBndSh0KSB7XG4gIGZvciAobGV0IGUgPSAwOyBlIDwgdC5sZW5ndGg7IGUrKykge1xuICAgIGNvbnN0IG4gPSB0W2VdO1xuICAgIHN3aXRjaCAobi50eXBlKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGlmIChuLnRhZ1R5cGUgPT09IDIgfHwgZ3Uobi5jaGlsZHJlbikpXG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgOTpcbiAgICAgICAgaWYgKGd1KG4uYnJhbmNoZXMpKVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDEwOlxuICAgICAgY2FzZSAxMTpcbiAgICAgICAgaWYgKGd1KG4uY2hpbGRyZW4pKVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIG9fKHQpIHtcbiAgcmV0dXJuIHQudHlwZSAhPT0gMiAmJiB0LnR5cGUgIT09IDEyID8gITAgOiB0LnR5cGUgPT09IDIgPyAhIXQuY29udGVudC50cmltKCkgOiBvXyh0LmNvbnRlbnQpO1xufVxuY29uc3QgYV8gPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgajcgPSAodCwgZSkgPT4gZnVuY3Rpb24oKSB7XG4gIGlmICh0ID0gZS5jdXJyZW50Tm9kZSwgISh0LnR5cGUgPT09IDEgJiYgKHQudGFnVHlwZSA9PT0gMCB8fCB0LnRhZ1R5cGUgPT09IDEpKSlcbiAgICByZXR1cm47XG4gIGNvbnN0IHsgdGFnOiByLCBwcm9wczogaSB9ID0gdCwgcyA9IHQudGFnVHlwZSA9PT0gMTtcbiAgbGV0IG8gPSBzID8gQjcodCwgZSkgOiBgXCIke3J9XCJgO1xuICBjb25zdCBhID0gWmUobykgJiYgby5jYWxsZWUgPT09IFpnO1xuICBsZXQgbCwgYywgdSwgZCA9IDAsIGYsIGgsIHAsIE8gPSAoXG4gICAgLy8gZHluYW1pYyBjb21wb25lbnQgbWF5IHJlc29sdmUgdG8gcGxhaW4gZWxlbWVudHNcbiAgICBhIHx8IG8gPT09IEdhIHx8IG8gPT09IENnIHx8ICFzICYmIC8vIDxzdmc+IGFuZCA8Zm9yZWlnbk9iamVjdD4gbXVzdCBiZSBmb3JjZWQgaW50byBibG9ja3Mgc28gdGhhdCBibG9ja1xuICAgIC8vIHVwZGF0ZXMgaW5zaWRlIGdldCBwcm9wZXIgaXNTVkcgZmxhZyBhdCBydW50aW1lLiAoIzYzOSwgIzY0MylcbiAgICAvLyBUaGlzIGlzIHRlY2huaWNhbGx5IHdlYi1zcGVjaWZpYywgYnV0IHNwbGl0dGluZyB0aGUgbG9naWMgb3V0IG9mIGNvcmVcbiAgICAvLyBsZWFkcyB0byB0b28gbXVjaCB1bm5lY2Vzc2FyeSBjb21wbGV4aXR5LlxuICAgIChyID09PSBcInN2Z1wiIHx8IHIgPT09IFwiZm9yZWlnbk9iamVjdFwiKVxuICApO1xuICBpZiAoaS5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgbSA9IGxfKFxuICAgICAgdCxcbiAgICAgIGUsXG4gICAgICB2b2lkIDAsXG4gICAgICBzLFxuICAgICAgYVxuICAgICk7XG4gICAgbCA9IG0ucHJvcHMsIGQgPSBtLnBhdGNoRmxhZywgaCA9IG0uZHluYW1pY1Byb3BOYW1lcztcbiAgICBjb25zdCB5ID0gbS5kaXJlY3RpdmVzO1xuICAgIHAgPSB5ICYmIHkubGVuZ3RoID8gc2MoXG4gICAgICB5Lm1hcCgoYikgPT4gVTcoYiwgZSkpXG4gICAgKSA6IHZvaWQgMCwgbS5zaG91bGRVc2VCbG9jayAmJiAoTyA9ICEwKTtcbiAgfVxuICBpZiAodC5jaGlsZHJlbi5sZW5ndGggPiAwKVxuICAgIGlmIChvID09PSB0ZCAmJiAoTyA9ICEwLCBkIHw9IDEwMjQsIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiB0LmNoaWxkcmVuLmxlbmd0aCA+IDEgJiYgZS5vbkVycm9yKFxuICAgICAgR2UoNDYsIHtcbiAgICAgICAgc3RhcnQ6IHQuY2hpbGRyZW5bMF0ubG9jLnN0YXJ0LFxuICAgICAgICBlbmQ6IHQuY2hpbGRyZW5bdC5jaGlsZHJlbi5sZW5ndGggLSAxXS5sb2MuZW5kLFxuICAgICAgICBzb3VyY2U6IFwiXCJcbiAgICAgIH0pXG4gICAgKSksIHMgJiYgLy8gVGVsZXBvcnQgaXMgbm90IGEgcmVhbCBjb21wb25lbnQgYW5kIGhhcyBkZWRpY2F0ZWQgcnVudGltZSBoYW5kbGluZ1xuICAgIG8gIT09IEdhICYmIC8vIGV4cGxhaW5lZCBhYm92ZS5cbiAgICBvICE9PSB0ZCkge1xuICAgICAgY29uc3QgeyBzbG90czogeSwgaGFzRHluYW1pY1Nsb3RzOiBiIH0gPSBYNyh0LCBlKTtcbiAgICAgIGMgPSB5LCBiICYmIChkIHw9IDEwMjQpO1xuICAgIH0gZWxzZSBpZiAodC5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgbyAhPT0gR2EpIHtcbiAgICAgIGNvbnN0IHkgPSB0LmNoaWxkcmVuWzBdLCBiID0geS50eXBlLCBnID0gYiA9PT0gNSB8fCBiID09PSA4O1xuICAgICAgZyAmJiBLbih5LCBlKSA9PT0gMCAmJiAoZCB8PSAxKSwgZyB8fCBiID09PSAyID8gYyA9IHkgOiBjID0gdC5jaGlsZHJlbjtcbiAgICB9IGVsc2VcbiAgICAgIGMgPSB0LmNoaWxkcmVuO1xuICBpZiAoZCAhPT0gMCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpXG4gICAgICBpZiAoZCA8IDApXG4gICAgICAgIHUgPSBkICsgYCAvKiAke0RyW2RdfSAqL2A7XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbSA9IE9iamVjdC5rZXlzKERyKS5tYXAoTnVtYmVyKS5maWx0ZXIoKHkpID0+IHkgPiAwICYmIGQgJiB5KS5tYXAoKHkpID0+IERyW3ldKS5qb2luKFwiLCBcIik7XG4gICAgICAgIHUgPSBkICsgYCAvKiAke219ICovYDtcbiAgICAgIH1cbiAgICBlbHNlXG4gICAgICB1ID0gU3RyaW5nKGQpO1xuICAgIGggJiYgaC5sZW5ndGggJiYgKGYgPSBxNyhoKSk7XG4gIH1cbiAgdC5jb2RlZ2VuTm9kZSA9ICRsKFxuICAgIGUsXG4gICAgbyxcbiAgICBsLFxuICAgIGMsXG4gICAgdSxcbiAgICBmLFxuICAgIHAsXG4gICAgISFPLFxuICAgICExLFxuICAgIHMsXG4gICAgdC5sb2NcbiAgKTtcbn07XG5mdW5jdGlvbiBCNyh0LCBlLCBuID0gITEpIHtcbiAgbGV0IHsgdGFnOiByIH0gPSB0O1xuICBjb25zdCBpID0genAociksIHMgPSBRbCh0LCBcImlzXCIpO1xuICBpZiAocylcbiAgICBpZiAoaSB8fCBlcyhcbiAgICAgIFwiQ09NUElMRVJfSVNfT05fRUxFTUVOVFwiLFxuICAgICAgZVxuICAgICkpIHtcbiAgICAgIGNvbnN0IGEgPSBzLnR5cGUgPT09IDYgPyBzLnZhbHVlICYmIEVlKHMudmFsdWUuY29udGVudCwgITApIDogcy5leHA7XG4gICAgICBpZiAoYSlcbiAgICAgICAgcmV0dXJuIER0KGUuaGVscGVyKFpnKSwgW1xuICAgICAgICAgIGFcbiAgICAgICAgXSk7XG4gICAgfSBlbHNlXG4gICAgICBzLnR5cGUgPT09IDYgJiYgcy52YWx1ZS5jb250ZW50LnN0YXJ0c1dpdGgoXCJ2dWU6XCIpICYmIChyID0gcy52YWx1ZS5jb250ZW50LnNsaWNlKDQpKTtcbiAgY29uc3QgbyA9IEJQKHIpIHx8IGUuaXNCdWlsdEluQ29tcG9uZW50KHIpO1xuICByZXR1cm4gbyA/IChuIHx8IGUuaGVscGVyKG8pLCBvKSA6IChlLmhlbHBlcihEZyksIGUuY29tcG9uZW50cy5hZGQociksIENsKHIsIFwiY29tcG9uZW50XCIpKTtcbn1cbmZ1bmN0aW9uIGxfKHQsIGUsIG4gPSB0LnByb3BzLCByLCBpLCBzID0gITEpIHtcbiAgY29uc3QgeyB0YWc6IG8sIGxvYzogYSwgY2hpbGRyZW46IGwgfSA9IHQ7XG4gIGxldCBjID0gW107XG4gIGNvbnN0IHUgPSBbXSwgZCA9IFtdLCBmID0gbC5sZW5ndGggPiAwO1xuICBsZXQgaCA9ICExLCBwID0gMCwgTyA9ICExLCBtID0gITEsIHkgPSAhMSwgYiA9ICExLCBnID0gITEsIHYgPSAhMTtcbiAgY29uc3QgUyA9IFtdLCB3ID0gKFQpID0+IHtcbiAgICBjLmxlbmd0aCAmJiAodS5wdXNoKFxuICAgICAgR24oc3koYyksIGEpXG4gICAgKSwgYyA9IFtdKSwgVCAmJiB1LnB1c2goVCk7XG4gIH0sIGsgPSAoeyBrZXk6IFQsIHZhbHVlOiBDIH0pID0+IHtcbiAgICBpZiAoeG4oVCkpIHtcbiAgICAgIGNvbnN0IEEgPSBULmNvbnRlbnQsIFEgPSBvaShBKTtcbiAgICAgIGlmIChRICYmICghciB8fCBpKSAmJiAvLyBvbWl0IHRoZSBmbGFnIGZvciBjbGljayBoYW5kbGVycyBiZWNhdXNlIGh5ZHJhdGlvbiBnaXZlcyBjbGlja1xuICAgICAgLy8gZGVkaWNhdGVkIGZhc3QgcGF0aC5cbiAgICAgIEEudG9Mb3dlckNhc2UoKSAhPT0gXCJvbmNsaWNrXCIgJiYgLy8gb21pdCB2LW1vZGVsIGhhbmRsZXJzXG4gICAgICBBICE9PSBcIm9uVXBkYXRlOm1vZGVsVmFsdWVcIiAmJiAvLyBvbWl0IG9uVm5vZGVYWFggaG9va3NcbiAgICAgICFVaShBKSAmJiAoYiA9ICEwKSwgUSAmJiBVaShBKSAmJiAodiA9ICEwKSwgUSAmJiBDLnR5cGUgPT09IDE0ICYmIChDID0gQy5hcmd1bWVudHNbMF0pLCBDLnR5cGUgPT09IDIwIHx8IChDLnR5cGUgPT09IDQgfHwgQy50eXBlID09PSA4KSAmJiBLbihDLCBlKSA+IDApXG4gICAgICAgIHJldHVybjtcbiAgICAgIEEgPT09IFwicmVmXCIgPyBPID0gITAgOiBBID09PSBcImNsYXNzXCIgPyBtID0gITAgOiBBID09PSBcInN0eWxlXCIgPyB5ID0gITAgOiBBICE9PSBcImtleVwiICYmICFTLmluY2x1ZGVzKEEpICYmIFMucHVzaChBKSwgciAmJiAoQSA9PT0gXCJjbGFzc1wiIHx8IEEgPT09IFwic3R5bGVcIikgJiYgIVMuaW5jbHVkZXMoQSkgJiYgUy5wdXNoKEEpO1xuICAgIH0gZWxzZVxuICAgICAgZyA9ICEwO1xuICB9O1xuICBmb3IgKGxldCBUID0gMDsgVCA8IG4ubGVuZ3RoOyBUKyspIHtcbiAgICBjb25zdCBDID0gbltUXTtcbiAgICBpZiAoQy50eXBlID09PSA2KSB7XG4gICAgICBjb25zdCB7IGxvYzogQSwgbmFtZTogUSwgbmFtZUxvYzogVywgdmFsdWU6IEwgfSA9IEM7XG4gICAgICBsZXQgcmUgPSAhMDtcbiAgICAgIGlmIChRID09PSBcInJlZlwiICYmIChPID0gITAsIGUuc2NvcGVzLnZGb3IgPiAwICYmIGMucHVzaChcbiAgICAgICAgeXQoXG4gICAgICAgICAgRWUoXCJyZWZfZm9yXCIsICEwKSxcbiAgICAgICAgICBFZShcInRydWVcIilcbiAgICAgICAgKVxuICAgICAgKSksIFEgPT09IFwiaXNcIiAmJiAoenAobykgfHwgTCAmJiBMLmNvbnRlbnQuc3RhcnRzV2l0aChcInZ1ZTpcIikgfHwgZXMoXG4gICAgICAgIFwiQ09NUElMRVJfSVNfT05fRUxFTUVOVFwiLFxuICAgICAgICBlXG4gICAgICApKSlcbiAgICAgICAgY29udGludWU7XG4gICAgICBjLnB1c2goXG4gICAgICAgIHl0KFxuICAgICAgICAgIEVlKFEsICEwLCBXKSxcbiAgICAgICAgICBFZShcbiAgICAgICAgICAgIEwgPyBMLmNvbnRlbnQgOiBcIlwiLFxuICAgICAgICAgICAgcmUsXG4gICAgICAgICAgICBMID8gTC5sb2MgOiBBXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7IG5hbWU6IEEsIGFyZzogUSwgZXhwOiBXLCBsb2M6IEwsIG1vZGlmaWVyczogcmUgfSA9IEMsIFkgPSBBID09PSBcImJpbmRcIiwgSyA9IEEgPT09IFwib25cIjtcbiAgICAgIGlmIChBID09PSBcInNsb3RcIikge1xuICAgICAgICByIHx8IGUub25FcnJvcihcbiAgICAgICAgICBHZSg0MCwgTClcbiAgICAgICAgKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoQSA9PT0gXCJvbmNlXCIgfHwgQSA9PT0gXCJtZW1vXCIgfHwgQSA9PT0gXCJpc1wiIHx8IFkgJiYgTGkoUSwgXCJpc1wiKSAmJiAoenAobykgfHwgZXMoXG4gICAgICAgIFwiQ09NUElMRVJfSVNfT05fRUxFTUVOVFwiLFxuICAgICAgICBlXG4gICAgICApKSB8fCBLICYmIHMpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKFxuICAgICAgICAvLyAjOTM4OiBlbGVtZW50cyB3aXRoIGR5bmFtaWMga2V5cyBzaG91bGQgYmUgZm9yY2VkIGludG8gYmxvY2tzXG4gICAgICAgIChZICYmIExpKFEsIFwia2V5XCIpIHx8IC8vIGlubGluZSBiZWZvcmUtdXBkYXRlIGhvb2tzIG5lZWQgdG8gZm9yY2UgYmxvY2sgc28gdGhhdCBpdCBpcyBpbnZva2VkXG4gICAgICAgIC8vIGJlZm9yZSBjaGlsZHJlblxuICAgICAgICBLICYmIGYgJiYgTGkoUSwgXCJ2dWU6YmVmb3JlLXVwZGF0ZVwiKSkgJiYgKGggPSAhMCksIFkgJiYgTGkoUSwgXCJyZWZcIikgJiYgZS5zY29wZXMudkZvciA+IDAgJiYgYy5wdXNoKFxuICAgICAgICAgIHl0KFxuICAgICAgICAgICAgRWUoXCJyZWZfZm9yXCIsICEwKSxcbiAgICAgICAgICAgIEVlKFwidHJ1ZVwiKVxuICAgICAgICAgIClcbiAgICAgICAgKSwgIVEgJiYgKFkgfHwgSylcbiAgICAgICkge1xuICAgICAgICBpZiAoZyA9ICEwLCBXKVxuICAgICAgICAgIGlmIChZKSB7XG4gICAgICAgICAgICBpZiAodygpLCBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgdS5zb21lKChDZSkgPT4gQ2UudHlwZSA9PT0gMTUgPyBDZS5wcm9wZXJ0aWVzLnNvbWUoKHsga2V5OiB1ZSB9KSA9PiB1ZS50eXBlICE9PSA0IHx8ICF1ZS5pc1N0YXRpYyA/ICEwIDogdWUuY29udGVudCAhPT0gXCJjbGFzc1wiICYmIHVlLmNvbnRlbnQgIT09IFwic3R5bGVcIiAmJiAhb2kodWUuY29udGVudCkpIDogITApICYmIEpvKFxuICAgICAgICAgICAgICBcIkNPTVBJTEVSX1ZfQklORF9PQkpFQ1RfT1JERVJcIixcbiAgICAgICAgICAgICAgZSxcbiAgICAgICAgICAgICAgTFxuICAgICAgICAgICAgKSwgZXMoXG4gICAgICAgICAgICAgIFwiQ09NUElMRVJfVl9CSU5EX09CSkVDVF9PUkRFUlwiLFxuICAgICAgICAgICAgICBlXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgICAgIHUudW5zaGlmdChXKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1LnB1c2goVyk7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICB3KHtcbiAgICAgICAgICAgICAgdHlwZTogMTQsXG4gICAgICAgICAgICAgIGxvYzogTCxcbiAgICAgICAgICAgICAgY2FsbGVlOiBlLmhlbHBlcihCZyksXG4gICAgICAgICAgICAgIGFyZ3VtZW50czogciA/IFtXXSA6IFtXLCBcInRydWVcIl1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZS5vbkVycm9yKFxuICAgICAgICAgICAgR2UoXG4gICAgICAgICAgICAgIFkgPyAzNCA6IDM1LFxuICAgICAgICAgICAgICBMXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBZICYmIHJlLmluY2x1ZGVzKFwicHJvcFwiKSAmJiAocCB8PSAzMik7XG4gICAgICBjb25zdCBCID0gZS5kaXJlY3RpdmVUcmFuc2Zvcm1zW0FdO1xuICAgICAgaWYgKEIpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wczogX2UsIG5lZWRSdW50aW1lOiBDZSB9ID0gQihDLCB0LCBlKTtcbiAgICAgICAgIXMgJiYgX2UuZm9yRWFjaChrKSwgSyAmJiBRICYmICF4bihRKSA/IHcoR24oX2UsIGEpKSA6IGMucHVzaCguLi5fZSksIENlICYmIChkLnB1c2goQyksIE9yKENlKSAmJiBhXy5zZXQoQywgQ2UpKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBPeShBKSB8fCAoZC5wdXNoKEMpLCBmICYmIChoID0gITApKTtcbiAgICB9XG4gIH1cbiAgbGV0IF87XG4gIGlmICh1Lmxlbmd0aCA/ICh3KCksIHUubGVuZ3RoID4gMSA/IF8gPSBEdChcbiAgICBlLmhlbHBlcihuZCksXG4gICAgdSxcbiAgICBhXG4gICkgOiBfID0gdVswXSkgOiBjLmxlbmd0aCAmJiAoXyA9IEduKFxuICAgIHN5KGMpLFxuICAgIGFcbiAgKSksIGcgPyBwIHw9IDE2IDogKG0gJiYgIXIgJiYgKHAgfD0gMiksIHkgJiYgIXIgJiYgKHAgfD0gNCksIFMubGVuZ3RoICYmIChwIHw9IDgpLCBiICYmIChwIHw9IDMyKSksICFoICYmIChwID09PSAwIHx8IHAgPT09IDMyKSAmJiAoTyB8fCB2IHx8IGQubGVuZ3RoID4gMCkgJiYgKHAgfD0gNTEyKSwgIWUuaW5TU1IgJiYgXylcbiAgICBzd2l0Y2ggKF8udHlwZSkge1xuICAgICAgY2FzZSAxNTpcbiAgICAgICAgbGV0IFQgPSAtMSwgQyA9IC0xLCBBID0gITE7XG4gICAgICAgIGZvciAobGV0IEwgPSAwOyBMIDwgXy5wcm9wZXJ0aWVzLmxlbmd0aDsgTCsrKSB7XG4gICAgICAgICAgY29uc3QgcmUgPSBfLnByb3BlcnRpZXNbTF0ua2V5O1xuICAgICAgICAgIHhuKHJlKSA/IHJlLmNvbnRlbnQgPT09IFwiY2xhc3NcIiA/IFQgPSBMIDogcmUuY29udGVudCA9PT0gXCJzdHlsZVwiICYmIChDID0gTCkgOiByZS5pc0hhbmRsZXJLZXkgfHwgKEEgPSAhMCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgUSA9IF8ucHJvcGVydGllc1tUXSwgVyA9IF8ucHJvcGVydGllc1tDXTtcbiAgICAgICAgQSA/IF8gPSBEdChcbiAgICAgICAgICBlLmhlbHBlcihFbCksXG4gICAgICAgICAgW19dXG4gICAgICAgICkgOiAoUSAmJiAheG4oUS52YWx1ZSkgJiYgKFEudmFsdWUgPSBEdChcbiAgICAgICAgICBlLmhlbHBlcihYZyksXG4gICAgICAgICAgW1EudmFsdWVdXG4gICAgICAgICkpLCBXICYmIC8vIHRoZSBzdGF0aWMgc3R5bGUgaXMgY29tcGlsZWQgaW50byBhbiBvYmplY3QsXG4gICAgICAgIC8vIHNvIHVzZSBgaGFzU3R5bGVCaW5kaW5nYCB0byBlbnN1cmUgdGhhdCBpdCBpcyBhIGR5bmFtaWMgc3R5bGUgYmluZGluZ1xuICAgICAgICAoeSB8fCBXLnZhbHVlLnR5cGUgPT09IDQgJiYgVy52YWx1ZS5jb250ZW50LnRyaW0oKVswXSA9PT0gXCJbXCIgfHwgLy8gdi1iaW5kOnN0eWxlIGFuZCBzdHlsZSBib3RoIGV4aXN0LFxuICAgICAgICAvLyB2LWJpbmQ6c3R5bGUgd2l0aCBzdGF0aWMgbGl0ZXJhbCBvYmplY3RcbiAgICAgICAgVy52YWx1ZS50eXBlID09PSAxNykgJiYgKFcudmFsdWUgPSBEdChcbiAgICAgICAgICBlLmhlbHBlcihqZyksXG4gICAgICAgICAgW1cudmFsdWVdXG4gICAgICAgICkpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE0OlxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIF8gPSBEdChcbiAgICAgICAgICBlLmhlbHBlcihFbCksXG4gICAgICAgICAgW1xuICAgICAgICAgICAgRHQoZS5oZWxwZXIoaWMpLCBbXG4gICAgICAgICAgICAgIF9cbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgXVxuICAgICAgICApO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIHJldHVybiB7XG4gICAgcHJvcHM6IF8sXG4gICAgZGlyZWN0aXZlczogZCxcbiAgICBwYXRjaEZsYWc6IHAsXG4gICAgZHluYW1pY1Byb3BOYW1lczogUyxcbiAgICBzaG91bGRVc2VCbG9jazogaFxuICB9O1xufVxuZnVuY3Rpb24gc3kodCkge1xuICBjb25zdCBlID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgbiA9IFtdO1xuICBmb3IgKGxldCByID0gMDsgciA8IHQubGVuZ3RoOyByKyspIHtcbiAgICBjb25zdCBpID0gdFtyXTtcbiAgICBpZiAoaS5rZXkudHlwZSA9PT0gOCB8fCAhaS5rZXkuaXNTdGF0aWMpIHtcbiAgICAgIG4ucHVzaChpKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBzID0gaS5rZXkuY29udGVudCwgbyA9IGUuZ2V0KHMpO1xuICAgIG8gPyAocyA9PT0gXCJzdHlsZVwiIHx8IHMgPT09IFwiY2xhc3NcIiB8fCBvaShzKSkgJiYgTDcobywgaSkgOiAoZS5zZXQocywgaSksIG4ucHVzaChpKSk7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBMNyh0LCBlKSB7XG4gIHQudmFsdWUudHlwZSA9PT0gMTcgPyB0LnZhbHVlLmVsZW1lbnRzLnB1c2goZS52YWx1ZSkgOiB0LnZhbHVlID0gc2MoXG4gICAgW3QudmFsdWUsIGUudmFsdWVdLFxuICAgIHQubG9jXG4gICk7XG59XG5mdW5jdGlvbiBVNyh0LCBlKSB7XG4gIGNvbnN0IG4gPSBbXSwgciA9IGFfLmdldCh0KTtcbiAgciA/IG4ucHVzaChlLmhlbHBlclN0cmluZyhyKSkgOiAoZS5oZWxwZXIoVmcpLCBlLmRpcmVjdGl2ZXMuYWRkKHQubmFtZSksIG4ucHVzaChDbCh0Lm5hbWUsIFwiZGlyZWN0aXZlXCIpKSk7XG4gIGNvbnN0IHsgbG9jOiBpIH0gPSB0O1xuICBpZiAodC5leHAgJiYgbi5wdXNoKHQuZXhwKSwgdC5hcmcgJiYgKHQuZXhwIHx8IG4ucHVzaChcInZvaWQgMFwiKSwgbi5wdXNoKHQuYXJnKSksIE9iamVjdC5rZXlzKHQubW9kaWZpZXJzKS5sZW5ndGgpIHtcbiAgICB0LmFyZyB8fCAodC5leHAgfHwgbi5wdXNoKFwidm9pZCAwXCIpLCBuLnB1c2goXCJ2b2lkIDBcIikpO1xuICAgIGNvbnN0IHMgPSBFZShcInRydWVcIiwgITEsIGkpO1xuICAgIG4ucHVzaChcbiAgICAgIEduKFxuICAgICAgICB0Lm1vZGlmaWVycy5tYXAoXG4gICAgICAgICAgKG8pID0+IHl0KG8sIHMpXG4gICAgICAgICksXG4gICAgICAgIGlcbiAgICAgIClcbiAgICApO1xuICB9XG4gIHJldHVybiBzYyhuLCB0LmxvYyk7XG59XG5mdW5jdGlvbiBxNyh0KSB7XG4gIGxldCBlID0gXCJbXCI7XG4gIGZvciAobGV0IG4gPSAwLCByID0gdC5sZW5ndGg7IG4gPCByOyBuKyspXG4gICAgZSArPSBKU09OLnN0cmluZ2lmeSh0W25dKSwgbiA8IHIgLSAxICYmIChlICs9IFwiLCBcIik7XG4gIHJldHVybiBlICsgXCJdXCI7XG59XG5mdW5jdGlvbiB6cCh0KSB7XG4gIHJldHVybiB0ID09PSBcImNvbXBvbmVudFwiIHx8IHQgPT09IFwiQ29tcG9uZW50XCI7XG59XG5jb25zdCBZNyA9ICh0LCBlKSA9PiB7XG4gIGlmIChhZCh0KSkge1xuICAgIGNvbnN0IHsgY2hpbGRyZW46IG4sIGxvYzogciB9ID0gdCwgeyBzbG90TmFtZTogaSwgc2xvdFByb3BzOiBzIH0gPSB6Nyh0LCBlKSwgbyA9IFtcbiAgICAgIGUucHJlZml4SWRlbnRpZmllcnMgPyBcIl9jdHguJHNsb3RzXCIgOiBcIiRzbG90c1wiLFxuICAgICAgaSxcbiAgICAgIFwie31cIixcbiAgICAgIFwidW5kZWZpbmVkXCIsXG4gICAgICBcInRydWVcIlxuICAgIF07XG4gICAgbGV0IGEgPSAyO1xuICAgIHMgJiYgKG9bMl0gPSBzLCBhID0gMyksIG4ubGVuZ3RoICYmIChvWzNdID0gRm8oW10sIG4sICExLCAhMSwgciksIGEgPSA0KSwgZS5zY29wZUlkICYmICFlLnNsb3R0ZWQgJiYgKGEgPSA1KSwgby5zcGxpY2UoYSksIHQuY29kZWdlbk5vZGUgPSBEdChcbiAgICAgIGUuaGVscGVyKFdQKSxcbiAgICAgIG8sXG4gICAgICByXG4gICAgKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHo3KHQsIGUpIHtcbiAgbGV0IG4gPSAnXCJkZWZhdWx0XCInLCByO1xuICBjb25zdCBpID0gW107XG4gIGZvciAobGV0IHMgPSAwOyBzIDwgdC5wcm9wcy5sZW5ndGg7IHMrKykge1xuICAgIGNvbnN0IG8gPSB0LnByb3BzW3NdO1xuICAgIGlmIChvLnR5cGUgPT09IDYpXG4gICAgICBvLnZhbHVlICYmIChvLm5hbWUgPT09IFwibmFtZVwiID8gbiA9IEpTT04uc3RyaW5naWZ5KG8udmFsdWUuY29udGVudCkgOiAoby5uYW1lID0gbXQoby5uYW1lKSwgaS5wdXNoKG8pKSk7XG4gICAgZWxzZSBpZiAoby5uYW1lID09PSBcImJpbmRcIiAmJiBMaShvLmFyZywgXCJuYW1lXCIpKSB7XG4gICAgICBpZiAoby5leHApXG4gICAgICAgIG4gPSBvLmV4cDtcbiAgICAgIGVsc2UgaWYgKG8uYXJnICYmIG8uYXJnLnR5cGUgPT09IDQpIHtcbiAgICAgICAgY29uc3QgYSA9IG10KG8uYXJnLmNvbnRlbnQpO1xuICAgICAgICBuID0gby5leHAgPSBFZShhLCAhMSwgby5hcmcubG9jKTtcbiAgICAgIH1cbiAgICB9IGVsc2VcbiAgICAgIG8ubmFtZSA9PT0gXCJiaW5kXCIgJiYgby5hcmcgJiYgeG4oby5hcmcpICYmIChvLmFyZy5jb250ZW50ID0gbXQoby5hcmcuY29udGVudCkpLCBpLnB1c2gobyk7XG4gIH1cbiAgaWYgKGkubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHsgcHJvcHM6IHMsIGRpcmVjdGl2ZXM6IG8gfSA9IGxfKFxuICAgICAgdCxcbiAgICAgIGUsXG4gICAgICBpLFxuICAgICAgITEsXG4gICAgICAhMVxuICAgICk7XG4gICAgciA9IHMsIG8ubGVuZ3RoICYmIGUub25FcnJvcihcbiAgICAgIEdlKFxuICAgICAgICAzNixcbiAgICAgICAgb1swXS5sb2NcbiAgICAgIClcbiAgICApO1xuICB9XG4gIHJldHVybiB7XG4gICAgc2xvdE5hbWU6IG4sXG4gICAgc2xvdFByb3BzOiByXG4gIH07XG59XG5jb25zdCBINyA9IC9eXFxzKihbXFx3JF9dK3woYXN5bmNcXHMqKT9cXChbXildKj9cXCkpXFxzKig6W149XSspPz0+fF5cXHMqKGFzeW5jXFxzKyk/ZnVuY3Rpb24oPzpcXHMrW1xcdyRdKyk/XFxzKlxcKC8sIGNfID0gKHQsIGUsIG4sIHIpID0+IHtcbiAgY29uc3QgeyBsb2M6IGksIG1vZGlmaWVyczogcywgYXJnOiBvIH0gPSB0O1xuICAhdC5leHAgJiYgIXMubGVuZ3RoICYmIG4ub25FcnJvcihHZSgzNSwgaSkpO1xuICBsZXQgYTtcbiAgaWYgKG8udHlwZSA9PT0gNClcbiAgICBpZiAoby5pc1N0YXRpYykge1xuICAgICAgbGV0IGQgPSBvLmNvbnRlbnQ7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZC5zdGFydHNXaXRoKFwidm5vZGVcIikgJiYgbi5vbkVycm9yKEdlKDUxLCBvLmxvYykpLCBkLnN0YXJ0c1dpdGgoXCJ2dWU6XCIpICYmIChkID0gYHZub2RlLSR7ZC5zbGljZSg0KX1gKTtcbiAgICAgIGNvbnN0IGYgPSBlLnRhZ1R5cGUgIT09IDAgfHwgZC5zdGFydHNXaXRoKFwidm5vZGVcIikgfHwgIS9bQS1aXS8udGVzdChkKSA/IChcbiAgICAgICAgLy8gZm9yIG5vbi1lbGVtZW50IGFuZCB2bm9kZSBsaWZlY3ljbGUgZXZlbnQgbGlzdGVuZXJzLCBhdXRvIGNvbnZlcnRcbiAgICAgICAgLy8gaXQgdG8gY2FtZWxDYXNlLiBTZWUgaXNzdWUgIzIyNDlcbiAgICAgICAgVHIobXQoZCkpXG4gICAgICApIDogKFxuICAgICAgICAvLyBwcmVzZXJ2ZSBjYXNlIGZvciBwbGFpbiBlbGVtZW50IGxpc3RlbmVycyB0aGF0IGhhdmUgdXBwZXJjYXNlXG4gICAgICAgIC8vIGxldHRlcnMsIGFzIHRoZXNlIG1heSBiZSBjdXN0b20gZWxlbWVudHMnIGN1c3RvbSBldmVudHNcbiAgICAgICAgYG9uOiR7ZH1gXG4gICAgICApO1xuICAgICAgYSA9IEVlKGYsICEwLCBvLmxvYyk7XG4gICAgfSBlbHNlXG4gICAgICBhID0gcHIoW1xuICAgICAgICBgJHtuLmhlbHBlclN0cmluZyhqcCl9KGAsXG4gICAgICAgIG8sXG4gICAgICAgIFwiKVwiXG4gICAgICBdKTtcbiAgZWxzZVxuICAgIGEgPSBvLCBhLmNoaWxkcmVuLnVuc2hpZnQoYCR7bi5oZWxwZXJTdHJpbmcoanApfShgKSwgYS5jaGlsZHJlbi5wdXNoKFwiKVwiKTtcbiAgbGV0IGwgPSB0LmV4cDtcbiAgbCAmJiAhbC5jb250ZW50LnRyaW0oKSAmJiAobCA9IHZvaWQgMCk7XG4gIGxldCBjID0gbi5jYWNoZUhhbmRsZXJzICYmICFsICYmICFuLmluVk9uY2U7XG4gIGlmIChsKSB7XG4gICAgY29uc3QgZCA9IExQKGwuY29udGVudCksIGYgPSAhKGQgfHwgSDcudGVzdChsLmNvbnRlbnQpKSwgaCA9IGwuY29udGVudC5pbmNsdWRlcyhcIjtcIik7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIFFzKFxuICAgICAgbCxcbiAgICAgIG4sXG4gICAgICAhMSxcbiAgICAgIGhcbiAgICApLCAoZiB8fCBjICYmIGQpICYmIChsID0gcHIoW1xuICAgICAgYCR7ZiA/IFwiJGV2ZW50XCIgOiBcIiguLi5hcmdzKVwifSA9PiAke2ggPyBcIntcIiA6IFwiKFwifWAsXG4gICAgICBsLFxuICAgICAgaCA/IFwifVwiIDogXCIpXCJcbiAgICBdKSk7XG4gIH1cbiAgbGV0IHUgPSB7XG4gICAgcHJvcHM6IFtcbiAgICAgIHl0KFxuICAgICAgICBhLFxuICAgICAgICBsIHx8IEVlKFwiKCkgPT4ge31cIiwgITEsIGkpXG4gICAgICApXG4gICAgXVxuICB9O1xuICByZXR1cm4gciAmJiAodSA9IHIodSkpLCBjICYmICh1LnByb3BzWzBdLnZhbHVlID0gbi5jYWNoZSh1LnByb3BzWzBdLnZhbHVlKSksIHUucHJvcHMuZm9yRWFjaCgoZCkgPT4gZC5rZXkuaXNIYW5kbGVyS2V5ID0gITApLCB1O1xufSwgRjcgPSAodCwgZSwgbikgPT4ge1xuICBjb25zdCB7IG1vZGlmaWVyczogciwgbG9jOiBpIH0gPSB0LCBzID0gdC5hcmc7XG4gIGxldCB7IGV4cDogbyB9ID0gdDtcbiAgaWYgKG8gJiYgby50eXBlID09PSA0ICYmICFvLmNvbnRlbnQudHJpbSgpICYmIChvID0gdm9pZCAwKSwgIW8pIHtcbiAgICBpZiAocy50eXBlICE9PSA0IHx8ICFzLmlzU3RhdGljKVxuICAgICAgcmV0dXJuIG4ub25FcnJvcihcbiAgICAgICAgR2UoXG4gICAgICAgICAgNTIsXG4gICAgICAgICAgcy5sb2NcbiAgICAgICAgKVxuICAgICAgKSwge1xuICAgICAgICBwcm9wczogW1xuICAgICAgICAgIHl0KHMsIEVlKFwiXCIsICEwLCBpKSlcbiAgICAgICAgXVxuICAgICAgfTtcbiAgICBjb25zdCBhID0gbXQocy5jb250ZW50KTtcbiAgICBvID0gdC5leHAgPSBFZShhLCAhMSwgcy5sb2MpO1xuICB9XG4gIHJldHVybiBzLnR5cGUgIT09IDQgPyAocy5jaGlsZHJlbi51bnNoaWZ0KFwiKFwiKSwgcy5jaGlsZHJlbi5wdXNoKCcpIHx8IFwiXCInKSkgOiBzLmlzU3RhdGljIHx8IChzLmNvbnRlbnQgPSBgJHtzLmNvbnRlbnR9IHx8IFwiXCJgKSwgci5pbmNsdWRlcyhcImNhbWVsXCIpICYmIChzLnR5cGUgPT09IDQgPyBzLmlzU3RhdGljID8gcy5jb250ZW50ID0gbXQocy5jb250ZW50KSA6IHMuY29udGVudCA9IGAke24uaGVscGVyU3RyaW5nKFhwKX0oJHtzLmNvbnRlbnR9KWAgOiAocy5jaGlsZHJlbi51bnNoaWZ0KGAke24uaGVscGVyU3RyaW5nKFhwKX0oYCksIHMuY2hpbGRyZW4ucHVzaChcIilcIikpKSwgbi5pblNTUiB8fCAoci5pbmNsdWRlcyhcInByb3BcIikgJiYgb3kocywgXCIuXCIpLCByLmluY2x1ZGVzKFwiYXR0clwiKSAmJiBveShzLCBcIl5cIikpLCB7XG4gICAgcHJvcHM6IFt5dChzLCBvKV1cbiAgfTtcbn0sIG95ID0gKHQsIGUpID0+IHtcbiAgdC50eXBlID09PSA0ID8gdC5pc1N0YXRpYyA/IHQuY29udGVudCA9IGUgKyB0LmNvbnRlbnQgOiB0LmNvbnRlbnQgPSBgXFxgJHtlfVxcJHske3QuY29udGVudH19XFxgYCA6ICh0LmNoaWxkcmVuLnVuc2hpZnQoYCcke2V9JyArIChgKSwgdC5jaGlsZHJlbi5wdXNoKFwiKVwiKSk7XG59LCBHNyA9ICh0LCBlKSA9PiB7XG4gIGlmICh0LnR5cGUgPT09IDAgfHwgdC50eXBlID09PSAxIHx8IHQudHlwZSA9PT0gMTEgfHwgdC50eXBlID09PSAxMClcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29uc3QgbiA9IHQuY2hpbGRyZW47XG4gICAgICBsZXQgciwgaSA9ICExO1xuICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCBuLmxlbmd0aDsgcysrKSB7XG4gICAgICAgIGNvbnN0IG8gPSBuW3NdO1xuICAgICAgICBpZiAoZWgobykpIHtcbiAgICAgICAgICBpID0gITA7XG4gICAgICAgICAgZm9yIChsZXQgYSA9IHMgKyAxOyBhIDwgbi5sZW5ndGg7IGErKykge1xuICAgICAgICAgICAgY29uc3QgbCA9IG5bYV07XG4gICAgICAgICAgICBpZiAoZWgobCkpXG4gICAgICAgICAgICAgIHIgfHwgKHIgPSBuW3NdID0gcHIoXG4gICAgICAgICAgICAgICAgW29dLFxuICAgICAgICAgICAgICAgIG8ubG9jXG4gICAgICAgICAgICAgICkpLCByLmNoaWxkcmVuLnB1c2goXCIgKyBcIiwgbCksIG4uc3BsaWNlKGEsIDEpLCBhLS07XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgciA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoISghaSB8fCAvLyBpZiB0aGlzIGlzIGEgcGxhaW4gZWxlbWVudCB3aXRoIGEgc2luZ2xlIHRleHQgY2hpbGQsIGxlYXZlIGl0XG4gICAgICAvLyBhcy1pcyBzaW5jZSB0aGUgcnVudGltZSBoYXMgZGVkaWNhdGVkIGZhc3QgcGF0aCBmb3IgdGhpcyBieSBkaXJlY3RseVxuICAgICAgLy8gc2V0dGluZyB0ZXh0Q29udGVudCBvZiB0aGUgZWxlbWVudC5cbiAgICAgIC8vIGZvciBjb21wb25lbnQgcm9vdCBpdCdzIGFsd2F5cyBub3JtYWxpemVkIGFueXdheS5cbiAgICAgIG4ubGVuZ3RoID09PSAxICYmICh0LnR5cGUgPT09IDAgfHwgdC50eXBlID09PSAxICYmIHQudGFnVHlwZSA9PT0gMCAmJiAvLyAjMzc1NlxuICAgICAgLy8gY3VzdG9tIGRpcmVjdGl2ZXMgY2FuIHBvdGVudGlhbGx5IGFkZCBET00gZWxlbWVudHMgYXJiaXRyYXJpbHksXG4gICAgICAvLyB3ZSBuZWVkIHRvIGF2b2lkIHNldHRpbmcgdGV4dENvbnRlbnQgb2YgdGhlIGVsZW1lbnQgYXQgcnVudGltZVxuICAgICAgLy8gdG8gYXZvaWQgYWNjaWRlbnRhbGx5IG92ZXJ3cml0aW5nIHRoZSBET00gZWxlbWVudHMgYWRkZWRcbiAgICAgIC8vIGJ5IHRoZSB1c2VyIHRocm91Z2ggY3VzdG9tIGRpcmVjdGl2ZXMuXG4gICAgICAhdC5wcm9wcy5maW5kKFxuICAgICAgICAocykgPT4gcy50eXBlID09PSA3ICYmICFlLmRpcmVjdGl2ZVRyYW5zZm9ybXNbcy5uYW1lXVxuICAgICAgKSAmJiB0LnRhZyAhPT0gXCJ0ZW1wbGF0ZVwiKSkpXG4gICAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgbi5sZW5ndGg7IHMrKykge1xuICAgICAgICAgIGNvbnN0IG8gPSBuW3NdO1xuICAgICAgICAgIGlmIChlaChvKSB8fCBvLnR5cGUgPT09IDgpIHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBbXTtcbiAgICAgICAgICAgIChvLnR5cGUgIT09IDIgfHwgby5jb250ZW50ICE9PSBcIiBcIikgJiYgYS5wdXNoKG8pLCAhZS5zc3IgJiYgS24obywgZSkgPT09IDAgJiYgYS5wdXNoKFxuICAgICAgICAgICAgICAxICsgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IGAgLyogJHtEclsxXX0gKi9gIDogXCJcIilcbiAgICAgICAgICAgICksIG5bc10gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IDEyLFxuICAgICAgICAgICAgICBjb250ZW50OiBvLFxuICAgICAgICAgICAgICBsb2M6IG8ubG9jLFxuICAgICAgICAgICAgICBjb2RlZ2VuTm9kZTogRHQoXG4gICAgICAgICAgICAgICAgZS5oZWxwZXIoTmcpLFxuICAgICAgICAgICAgICAgIGFcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufSwgYXkgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKSwgSzcgPSAodCwgZSkgPT4ge1xuICBpZiAodC50eXBlID09PSAxICYmIHpuKHQsIFwib25jZVwiLCAhMCkpXG4gICAgcmV0dXJuIGF5Lmhhcyh0KSB8fCBlLmluVk9uY2UgfHwgZS5pblNTUiA/IHZvaWQgMCA6IChheS5hZGQodCksIGUuaW5WT25jZSA9ICEwLCBlLmhlbHBlcihyZCksICgpID0+IHtcbiAgICAgIGUuaW5WT25jZSA9ICExO1xuICAgICAgY29uc3QgbiA9IGUuY3VycmVudE5vZGU7XG4gICAgICBuLmNvZGVnZW5Ob2RlICYmIChuLmNvZGVnZW5Ob2RlID0gZS5jYWNoZShcbiAgICAgICAgbi5jb2RlZ2VuTm9kZSxcbiAgICAgICAgITBcbiAgICAgICAgLyogaXNWTm9kZSAqL1xuICAgICAgKSk7XG4gICAgfSk7XG59LCB1XyA9ICh0LCBlLCBuKSA9PiB7XG4gIGNvbnN0IHsgZXhwOiByLCBhcmc6IGkgfSA9IHQ7XG4gIGlmICghcilcbiAgICByZXR1cm4gbi5vbkVycm9yKFxuICAgICAgR2UoNDEsIHQubG9jKVxuICAgICksIFljKCk7XG4gIGNvbnN0IHMgPSByLmxvYy5zb3VyY2UsIG8gPSByLnR5cGUgPT09IDQgPyByLmNvbnRlbnQgOiBzLCBhID0gbi5iaW5kaW5nTWV0YWRhdGFbc107XG4gIGlmIChhID09PSBcInByb3BzXCIgfHwgYSA9PT0gXCJwcm9wcy1hbGlhc2VkXCIpXG4gICAgcmV0dXJuIG4ub25FcnJvcihHZSg0NCwgci5sb2MpKSwgWWMoKTtcbiAgaWYgKCFvLnRyaW0oKSB8fCAhTFAobykgJiYgISExKVxuICAgIHJldHVybiBuLm9uRXJyb3IoXG4gICAgICBHZSg0Miwgci5sb2MpXG4gICAgKSwgWWMoKTtcbiAgY29uc3QgYyA9IGkgfHwgRWUoXCJtb2RlbFZhbHVlXCIsICEwKSwgdSA9IGkgPyB4bihpKSA/IGBvblVwZGF0ZToke210KGkuY29udGVudCl9YCA6IHByKFsnXCJvblVwZGF0ZTpcIiArICcsIGldKSA6IFwib25VcGRhdGU6bW9kZWxWYWx1ZVwiO1xuICBsZXQgZDtcbiAgY29uc3QgZiA9IG4uaXNUUyA/IFwiKCRldmVudDogYW55KVwiIDogXCIkZXZlbnRcIjtcbiAgZCA9IHByKFtcbiAgICBgJHtmfSA9PiAoKGAsXG4gICAgcixcbiAgICBcIikgPSAkZXZlbnQpXCJcbiAgXSk7XG4gIGNvbnN0IGggPSBbXG4gICAgLy8gbW9kZWxWYWx1ZTogZm9vXG4gICAgeXQoYywgdC5leHApLFxuICAgIC8vIFwib25VcGRhdGU6bW9kZWxWYWx1ZVwiOiAkZXZlbnQgPT4gKGZvbyA9ICRldmVudClcbiAgICB5dCh1LCBkKVxuICBdO1xuICBpZiAodC5tb2RpZmllcnMubGVuZ3RoICYmIGUudGFnVHlwZSA9PT0gMSkge1xuICAgIGNvbnN0IHAgPSB0Lm1vZGlmaWVycy5tYXAoKG0pID0+ICh6ZyhtKSA/IG0gOiBKU09OLnN0cmluZ2lmeShtKSkgKyBcIjogdHJ1ZVwiKS5qb2luKFwiLCBcIiksIE8gPSBpID8geG4oaSkgPyBgJHtpLmNvbnRlbnR9TW9kaWZpZXJzYCA6IHByKFtpLCAnICsgXCJNb2RpZmllcnNcIiddKSA6IFwibW9kZWxNb2RpZmllcnNcIjtcbiAgICBoLnB1c2goXG4gICAgICB5dChcbiAgICAgICAgTyxcbiAgICAgICAgRWUoXG4gICAgICAgICAgYHsgJHtwfSB9YCxcbiAgICAgICAgICAhMSxcbiAgICAgICAgICB0LmxvYyxcbiAgICAgICAgICAyXG4gICAgICAgIClcbiAgICAgIClcbiAgICApO1xuICB9XG4gIHJldHVybiBZYyhoKTtcbn07XG5mdW5jdGlvbiBZYyh0ID0gW10pIHtcbiAgcmV0dXJuIHsgcHJvcHM6IHQgfTtcbn1cbmNvbnN0IEo3ID0gL1tcXHcpLitcXC1fJFxcXV0vLCBlaiA9ICh0LCBlKSA9PiB7XG4gIGVzKFwiQ09NUElMRVJfRklMVEVSU1wiLCBlKSAmJiAodC50eXBlID09PSA1ICYmIHVkKHQuY29udGVudCwgZSksIHQudHlwZSA9PT0gMSAmJiB0LnByb3BzLmZvckVhY2goKG4pID0+IHtcbiAgICBuLnR5cGUgPT09IDcgJiYgbi5uYW1lICE9PSBcImZvclwiICYmIG4uZXhwICYmIHVkKG4uZXhwLCBlKTtcbiAgfSkpO1xufTtcbmZ1bmN0aW9uIHVkKHQsIGUpIHtcbiAgaWYgKHQudHlwZSA9PT0gNClcbiAgICBseSh0LCBlKTtcbiAgZWxzZVxuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgdC5jaGlsZHJlbi5sZW5ndGg7IG4rKykge1xuICAgICAgY29uc3QgciA9IHQuY2hpbGRyZW5bbl07XG4gICAgICB0eXBlb2YgciA9PSBcIm9iamVjdFwiICYmIChyLnR5cGUgPT09IDQgPyBseShyLCBlKSA6IHIudHlwZSA9PT0gOCA/IHVkKHQsIGUpIDogci50eXBlID09PSA1ICYmIHVkKHIuY29udGVudCwgZSkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGx5KHQsIGUpIHtcbiAgY29uc3QgbiA9IHQuY29udGVudDtcbiAgbGV0IHIgPSAhMSwgaSA9ICExLCBzID0gITEsIG8gPSAhMSwgYSA9IDAsIGwgPSAwLCBjID0gMCwgdSA9IDAsIGQsIGYsIGgsIHAsIE8gPSBbXTtcbiAgZm9yIChoID0gMDsgaCA8IG4ubGVuZ3RoOyBoKyspXG4gICAgaWYgKGYgPSBkLCBkID0gbi5jaGFyQ29kZUF0KGgpLCByKVxuICAgICAgZCA9PT0gMzkgJiYgZiAhPT0gOTIgJiYgKHIgPSAhMSk7XG4gICAgZWxzZSBpZiAoaSlcbiAgICAgIGQgPT09IDM0ICYmIGYgIT09IDkyICYmIChpID0gITEpO1xuICAgIGVsc2UgaWYgKHMpXG4gICAgICBkID09PSA5NiAmJiBmICE9PSA5MiAmJiAocyA9ICExKTtcbiAgICBlbHNlIGlmIChvKVxuICAgICAgZCA9PT0gNDcgJiYgZiAhPT0gOTIgJiYgKG8gPSAhMSk7XG4gICAgZWxzZSBpZiAoZCA9PT0gMTI0ICYmIC8vIHBpcGVcbiAgICBuLmNoYXJDb2RlQXQoaCArIDEpICE9PSAxMjQgJiYgbi5jaGFyQ29kZUF0KGggLSAxKSAhPT0gMTI0ICYmICFhICYmICFsICYmICFjKVxuICAgICAgcCA9PT0gdm9pZCAwID8gKHUgPSBoICsgMSwgcCA9IG4uc2xpY2UoMCwgaCkudHJpbSgpKSA6IG0oKTtcbiAgICBlbHNlIHtcbiAgICAgIHN3aXRjaCAoZCkge1xuICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgIGkgPSAhMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICByID0gITA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgOTY6XG4gICAgICAgICAgcyA9ICEwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQwOlxuICAgICAgICAgIGMrKztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0MTpcbiAgICAgICAgICBjLS07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgOTE6XG4gICAgICAgICAgbCsrO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDkzOlxuICAgICAgICAgIGwtLTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMjM6XG4gICAgICAgICAgYSsrO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEyNTpcbiAgICAgICAgICBhLS07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoZCA9PT0gNDcpIHtcbiAgICAgICAgbGV0IHkgPSBoIC0gMSwgYjtcbiAgICAgICAgZm9yICg7IHkgPj0gMCAmJiAoYiA9IG4uY2hhckF0KHkpLCBiID09PSBcIiBcIik7IHktLSlcbiAgICAgICAgICA7XG4gICAgICAgICghYiB8fCAhSjcudGVzdChiKSkgJiYgKG8gPSAhMCk7XG4gICAgICB9XG4gICAgfVxuICBwID09PSB2b2lkIDAgPyBwID0gbi5zbGljZSgwLCBoKS50cmltKCkgOiB1ICE9PSAwICYmIG0oKTtcbiAgZnVuY3Rpb24gbSgpIHtcbiAgICBPLnB1c2gobi5zbGljZSh1LCBoKS50cmltKCkpLCB1ID0gaCArIDE7XG4gIH1cbiAgaWYgKE8ubGVuZ3RoKSB7XG4gICAgZm9yIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgc2QoXG4gICAgICBcIkNPTVBJTEVSX0ZJTFRFUlNcIixcbiAgICAgIGUsXG4gICAgICB0LmxvY1xuICAgICksIGggPSAwOyBoIDwgTy5sZW5ndGg7IGgrKylcbiAgICAgIHAgPSB0aihwLCBPW2hdLCBlKTtcbiAgICB0LmNvbnRlbnQgPSBwO1xuICB9XG59XG5mdW5jdGlvbiB0aih0LCBlLCBuKSB7XG4gIG4uaGVscGVyKElnKTtcbiAgY29uc3QgciA9IGUuaW5kZXhPZihcIihcIik7XG4gIGlmIChyIDwgMClcbiAgICByZXR1cm4gbi5maWx0ZXJzLmFkZChlKSwgYCR7Q2woZSwgXCJmaWx0ZXJcIil9KCR7dH0pYDtcbiAge1xuICAgIGNvbnN0IGkgPSBlLnNsaWNlKDAsIHIpLCBzID0gZS5zbGljZShyICsgMSk7XG4gICAgcmV0dXJuIG4uZmlsdGVycy5hZGQoaSksIGAke0NsKGksIFwiZmlsdGVyXCIpfSgke3R9JHtzICE9PSBcIilcIiA/IFwiLFwiICsgcyA6IHN9YDtcbiAgfVxufVxuY29uc3QgY3kgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKSwgbmogPSAodCwgZSkgPT4ge1xuICBpZiAodC50eXBlID09PSAxKSB7XG4gICAgY29uc3QgbiA9IHpuKHQsIFwibWVtb1wiKTtcbiAgICByZXR1cm4gIW4gfHwgY3kuaGFzKHQpID8gdm9pZCAwIDogKGN5LmFkZCh0KSwgKCkgPT4ge1xuICAgICAgY29uc3QgciA9IHQuY29kZWdlbk5vZGUgfHwgZS5jdXJyZW50Tm9kZS5jb2RlZ2VuTm9kZTtcbiAgICAgIHIgJiYgci50eXBlID09PSAxMyAmJiAodC50YWdUeXBlICE9PSAxICYmIHFnKHIsIGUpLCB0LmNvZGVnZW5Ob2RlID0gRHQoZS5oZWxwZXIoVWcpLCBbXG4gICAgICAgIG4uZXhwLFxuICAgICAgICBGbyh2b2lkIDAsIHIpLFxuICAgICAgICBcIl9jYWNoZVwiLFxuICAgICAgICBTdHJpbmcoZS5jYWNoZWQrKylcbiAgICAgIF0pKTtcbiAgICB9KTtcbiAgfVxufTtcbmZ1bmN0aW9uIHJqKHQpIHtcbiAgcmV0dXJuIFtcbiAgICBbXG4gICAgICBLNyxcbiAgICAgIEE3LFxuICAgICAgbmosXG4gICAgICBaNyxcbiAgICAgIGVqLFxuICAgICAgLi4ucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gW0M3XSA6IFtdLFxuICAgICAgWTcsXG4gICAgICBqNyxcbiAgICAgIFc3LFxuICAgICAgRzdcbiAgICBdLFxuICAgIHtcbiAgICAgIG9uOiBjXyxcbiAgICAgIGJpbmQ6IEY3LFxuICAgICAgbW9kZWw6IHVfXG4gICAgfVxuICBdO1xufVxuZnVuY3Rpb24gaWoodCwgZSA9IHt9KSB7XG4gIGNvbnN0IG4gPSBlLm9uRXJyb3IgfHwgWWcsIHIgPSBlLm1vZGUgPT09IFwibW9kdWxlXCI7XG4gIGUucHJlZml4SWRlbnRpZmllcnMgPT09ICEwID8gbihHZSg0NykpIDogciAmJiBuKEdlKDQ4KSk7XG4gIGNvbnN0IGkgPSAhMTtcbiAgZS5jYWNoZUhhbmRsZXJzICYmIG4oR2UoNDkpKSwgZS5zY29wZUlkICYmICFyICYmIG4oR2UoNTApKTtcbiAgY29uc3QgcyA9ICRlKHt9LCBlLCB7XG4gICAgcHJlZml4SWRlbnRpZmllcnM6IGlcbiAgfSksIG8gPSB3ZSh0KSA/IHM3KHQsIHMpIDogdCwgW2EsIGxdID0gcmooKTtcbiAgcmV0dXJuIGM3KFxuICAgIG8sXG4gICAgJGUoe30sIHMsIHtcbiAgICAgIG5vZGVUcmFuc2Zvcm1zOiBbXG4gICAgICAgIC4uLmEsXG4gICAgICAgIC4uLmUubm9kZVRyYW5zZm9ybXMgfHwgW11cbiAgICAgICAgLy8gdXNlciB0cmFuc2Zvcm1zXG4gICAgICBdLFxuICAgICAgZGlyZWN0aXZlVHJhbnNmb3JtczogJGUoXG4gICAgICAgIHt9LFxuICAgICAgICBsLFxuICAgICAgICBlLmRpcmVjdGl2ZVRyYW5zZm9ybXMgfHwge31cbiAgICAgICAgLy8gdXNlciB0cmFuc2Zvcm1zXG4gICAgICApXG4gICAgfSlcbiAgKSwgaDcobywgcyk7XG59XG5jb25zdCBzaiA9ICgpID0+ICh7IHByb3BzOiBbXSB9KTtcbi8qKlxuKiBAdnVlL2NvbXBpbGVyLWRvbSB2My40LjIxXG4qIChjKSAyMDE4LXByZXNlbnQgWXV4aSAoRXZhbikgWW91IGFuZCBWdWUgY29udHJpYnV0b3JzXG4qIEBsaWNlbnNlIE1JVFxuKiovXG5jb25zdCBkXyA9IFN5bWJvbChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBcInZNb2RlbFJhZGlvXCIgOiBcIlwiKSwgZl8gPSBTeW1ib2wocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJ2TW9kZWxDaGVja2JveFwiIDogXCJcIiksIGhfID0gU3ltYm9sKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwidk1vZGVsVGV4dFwiIDogXCJcIiksIHBfID0gU3ltYm9sKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwidk1vZGVsU2VsZWN0XCIgOiBcIlwiKSwgSHAgPSBTeW1ib2wocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJ2TW9kZWxEeW5hbWljXCIgOiBcIlwiKSwgT18gPSBTeW1ib2wocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJ2T25Nb2RpZmllcnNHdWFyZFwiIDogXCJcIiksIGdfID0gU3ltYm9sKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwidk9uS2V5c0d1YXJkXCIgOiBcIlwiKSwgbV8gPSBTeW1ib2wocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gXCJ2U2hvd1wiIDogXCJcIiksIEZnID0gU3ltYm9sKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiVHJhbnNpdGlvblwiIDogXCJcIiksIGJfID0gU3ltYm9sKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFwiVHJhbnNpdGlvbkdyb3VwXCIgOiBcIlwiKTtcbkE0KHtcbiAgW2RfXTogXCJ2TW9kZWxSYWRpb1wiLFxuICBbZl9dOiBcInZNb2RlbENoZWNrYm94XCIsXG4gIFtoX106IFwidk1vZGVsVGV4dFwiLFxuICBbcF9dOiBcInZNb2RlbFNlbGVjdFwiLFxuICBbSHBdOiBcInZNb2RlbER5bmFtaWNcIixcbiAgW09fXTogXCJ3aXRoTW9kaWZpZXJzXCIsXG4gIFtnX106IFwid2l0aEtleXNcIixcbiAgW21fXTogXCJ2U2hvd1wiLFxuICBbRmddOiBcIlRyYW5zaXRpb25cIixcbiAgW2JfXTogXCJUcmFuc2l0aW9uR3JvdXBcIlxufSk7XG5sZXQgY287XG5mdW5jdGlvbiBvaih0LCBlID0gITEpIHtcbiAgcmV0dXJuIGNvIHx8IChjbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpLCBlID8gKGNvLmlubmVySFRNTCA9IGA8ZGl2IGZvbz1cIiR7dC5yZXBsYWNlKC9cIi9nLCBcIiZxdW90O1wiKX1cIj5gLCBjby5jaGlsZHJlblswXS5nZXRBdHRyaWJ1dGUoXCJmb29cIikpIDogKGNvLmlubmVySFRNTCA9IHQsIGNvLnRleHRDb250ZW50KTtcbn1cbmNvbnN0IGFqID0ge1xuICBwYXJzZU1vZGU6IFwiaHRtbFwiLFxuICBpc1ZvaWRUYWc6IEhfLFxuICBpc05hdGl2ZVRhZzogKHQpID0+IGJ5KHQpIHx8IHZ5KHQpIHx8IHl5KHQpLFxuICBpc1ByZVRhZzogKHQpID0+IHQgPT09IFwicHJlXCIsXG4gIGRlY29kZUVudGl0aWVzOiBvaixcbiAgaXNCdWlsdEluQ29tcG9uZW50OiAodCkgPT4ge1xuICAgIGlmICh0ID09PSBcIlRyYW5zaXRpb25cIiB8fCB0ID09PSBcInRyYW5zaXRpb25cIilcbiAgICAgIHJldHVybiBGZztcbiAgICBpZiAodCA9PT0gXCJUcmFuc2l0aW9uR3JvdXBcIiB8fCB0ID09PSBcInRyYW5zaXRpb24tZ3JvdXBcIilcbiAgICAgIHJldHVybiBiXztcbiAgfSxcbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvcGFyc2luZy5odG1sI3RyZWUtY29uc3RydWN0aW9uLWRpc3BhdGNoZXJcbiAgZ2V0TmFtZXNwYWNlKHQsIGUsIG4pIHtcbiAgICBsZXQgciA9IGUgPyBlLm5zIDogbjtcbiAgICBpZiAoZSAmJiByID09PSAyKVxuICAgICAgaWYgKGUudGFnID09PSBcImFubm90YXRpb24teG1sXCIpIHtcbiAgICAgICAgaWYgKHQgPT09IFwic3ZnXCIpXG4gICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIGUucHJvcHMuc29tZShcbiAgICAgICAgICAoaSkgPT4gaS50eXBlID09PSA2ICYmIGkubmFtZSA9PT0gXCJlbmNvZGluZ1wiICYmIGkudmFsdWUgIT0gbnVsbCAmJiAoaS52YWx1ZS5jb250ZW50ID09PSBcInRleHQvaHRtbFwiIHx8IGkudmFsdWUuY29udGVudCA9PT0gXCJhcHBsaWNhdGlvbi94aHRtbCt4bWxcIilcbiAgICAgICAgKSAmJiAociA9IDApO1xuICAgICAgfSBlbHNlXG4gICAgICAgIC9ebSg/Oltpb25zXXx0ZXh0KSQvLnRlc3QoZS50YWcpICYmIHQgIT09IFwibWdseXBoXCIgJiYgdCAhPT0gXCJtYWxpZ25tYXJrXCIgJiYgKHIgPSAwKTtcbiAgICBlbHNlXG4gICAgICBlICYmIHIgPT09IDEgJiYgKGUudGFnID09PSBcImZvcmVpZ25PYmplY3RcIiB8fCBlLnRhZyA9PT0gXCJkZXNjXCIgfHwgZS50YWcgPT09IFwidGl0bGVcIikgJiYgKHIgPSAwKTtcbiAgICBpZiAociA9PT0gMCkge1xuICAgICAgaWYgKHQgPT09IFwic3ZnXCIpXG4gICAgICAgIHJldHVybiAxO1xuICAgICAgaWYgKHQgPT09IFwibWF0aFwiKVxuICAgICAgICByZXR1cm4gMjtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbn0sIGxqID0gKHQpID0+IHtcbiAgdC50eXBlID09PSAxICYmIHQucHJvcHMuZm9yRWFjaCgoZSwgbikgPT4ge1xuICAgIGUudHlwZSA9PT0gNiAmJiBlLm5hbWUgPT09IFwic3R5bGVcIiAmJiBlLnZhbHVlICYmICh0LnByb3BzW25dID0ge1xuICAgICAgdHlwZTogNyxcbiAgICAgIG5hbWU6IFwiYmluZFwiLFxuICAgICAgYXJnOiBFZShcInN0eWxlXCIsICEwLCBlLmxvYyksXG4gICAgICBleHA6IGNqKGUudmFsdWUuY29udGVudCwgZS5sb2MpLFxuICAgICAgbW9kaWZpZXJzOiBbXSxcbiAgICAgIGxvYzogZS5sb2NcbiAgICB9KTtcbiAgfSk7XG59LCBjaiA9ICh0LCBlKSA9PiB7XG4gIGNvbnN0IG4gPSBneSh0KTtcbiAgcmV0dXJuIEVlKFxuICAgIEpTT04uc3RyaW5naWZ5KG4pLFxuICAgICExLFxuICAgIGUsXG4gICAgM1xuICApO1xufTtcbmZ1bmN0aW9uIGRyKHQsIGUpIHtcbiAgcmV0dXJuIEdlKFxuICAgIHQsXG4gICAgZSxcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyB1aiA6IHZvaWQgMFxuICApO1xufVxuY29uc3QgdWogPSB7XG4gIDUzOiBcInYtaHRtbCBpcyBtaXNzaW5nIGV4cHJlc3Npb24uXCIsXG4gIDU0OiBcInYtaHRtbCB3aWxsIG92ZXJyaWRlIGVsZW1lbnQgY2hpbGRyZW4uXCIsXG4gIDU1OiBcInYtdGV4dCBpcyBtaXNzaW5nIGV4cHJlc3Npb24uXCIsXG4gIDU2OiBcInYtdGV4dCB3aWxsIG92ZXJyaWRlIGVsZW1lbnQgY2hpbGRyZW4uXCIsXG4gIDU3OiBcInYtbW9kZWwgY2FuIG9ubHkgYmUgdXNlZCBvbiA8aW5wdXQ+LCA8dGV4dGFyZWE+IGFuZCA8c2VsZWN0PiBlbGVtZW50cy5cIixcbiAgNTg6IFwidi1tb2RlbCBhcmd1bWVudCBpcyBub3Qgc3VwcG9ydGVkIG9uIHBsYWluIGVsZW1lbnRzLlwiLFxuICA1OTogXCJ2LW1vZGVsIGNhbm5vdCBiZSB1c2VkIG9uIGZpbGUgaW5wdXRzIHNpbmNlIHRoZXkgYXJlIHJlYWQtb25seS4gVXNlIGEgdi1vbjpjaGFuZ2UgbGlzdGVuZXIgaW5zdGVhZC5cIixcbiAgNjA6IFwiVW5uZWNlc3NhcnkgdmFsdWUgYmluZGluZyB1c2VkIGFsb25nc2lkZSB2LW1vZGVsLiBJdCB3aWxsIGludGVyZmVyZSB3aXRoIHYtbW9kZWwncyBiZWhhdmlvci5cIixcbiAgNjE6IFwidi1zaG93IGlzIG1pc3NpbmcgZXhwcmVzc2lvbi5cIixcbiAgNjI6IFwiPFRyYW5zaXRpb24+IGV4cGVjdHMgZXhhY3RseSBvbmUgY2hpbGQgZWxlbWVudCBvciBjb21wb25lbnQuXCIsXG4gIDYzOiBcIlRhZ3Mgd2l0aCBzaWRlIGVmZmVjdCAoPHNjcmlwdD4gYW5kIDxzdHlsZT4pIGFyZSBpZ25vcmVkIGluIGNsaWVudCBjb21wb25lbnQgdGVtcGxhdGVzLlwiXG59LCBkaiA9ICh0LCBlLCBuKSA9PiB7XG4gIGNvbnN0IHsgZXhwOiByLCBsb2M6IGkgfSA9IHQ7XG4gIHJldHVybiByIHx8IG4ub25FcnJvcihcbiAgICBkcig1MywgaSlcbiAgKSwgZS5jaGlsZHJlbi5sZW5ndGggJiYgKG4ub25FcnJvcihcbiAgICBkcig1NCwgaSlcbiAgKSwgZS5jaGlsZHJlbi5sZW5ndGggPSAwKSwge1xuICAgIHByb3BzOiBbXG4gICAgICB5dChcbiAgICAgICAgRWUoXCJpbm5lckhUTUxcIiwgITAsIGkpLFxuICAgICAgICByIHx8IEVlKFwiXCIsICEwKVxuICAgICAgKVxuICAgIF1cbiAgfTtcbn0sIGZqID0gKHQsIGUsIG4pID0+IHtcbiAgY29uc3QgeyBleHA6IHIsIGxvYzogaSB9ID0gdDtcbiAgcmV0dXJuIHIgfHwgbi5vbkVycm9yKFxuICAgIGRyKDU1LCBpKVxuICApLCBlLmNoaWxkcmVuLmxlbmd0aCAmJiAobi5vbkVycm9yKFxuICAgIGRyKDU2LCBpKVxuICApLCBlLmNoaWxkcmVuLmxlbmd0aCA9IDApLCB7XG4gICAgcHJvcHM6IFtcbiAgICAgIHl0KFxuICAgICAgICBFZShcInRleHRDb250ZW50XCIsICEwKSxcbiAgICAgICAgciA/IEtuKHIsIG4pID4gMCA/IHIgOiBEdChcbiAgICAgICAgICBuLmhlbHBlclN0cmluZyhKZCksXG4gICAgICAgICAgW3JdLFxuICAgICAgICAgIGlcbiAgICAgICAgKSA6IEVlKFwiXCIsICEwKVxuICAgICAgKVxuICAgIF1cbiAgfTtcbn0sIGhqID0gKHQsIGUsIG4pID0+IHtcbiAgY29uc3QgciA9IHVfKHQsIGUsIG4pO1xuICBpZiAoIXIucHJvcHMubGVuZ3RoIHx8IGUudGFnVHlwZSA9PT0gMSlcbiAgICByZXR1cm4gcjtcbiAgdC5hcmcgJiYgbi5vbkVycm9yKFxuICAgIGRyKFxuICAgICAgNTgsXG4gICAgICB0LmFyZy5sb2NcbiAgICApXG4gICk7XG4gIGZ1bmN0aW9uIGkoKSB7XG4gICAgY29uc3QgYSA9IHpuKGUsIFwiYmluZFwiKTtcbiAgICBhICYmIExpKGEuYXJnLCBcInZhbHVlXCIpICYmIG4ub25FcnJvcihcbiAgICAgIGRyKFxuICAgICAgICA2MCxcbiAgICAgICAgYS5sb2NcbiAgICAgIClcbiAgICApO1xuICB9XG4gIGNvbnN0IHsgdGFnOiBzIH0gPSBlLCBvID0gbi5pc0N1c3RvbUVsZW1lbnQocyk7XG4gIGlmIChzID09PSBcImlucHV0XCIgfHwgcyA9PT0gXCJ0ZXh0YXJlYVwiIHx8IHMgPT09IFwic2VsZWN0XCIgfHwgbykge1xuICAgIGxldCBhID0gaF8sIGwgPSAhMTtcbiAgICBpZiAocyA9PT0gXCJpbnB1dFwiIHx8IG8pIHtcbiAgICAgIGNvbnN0IGMgPSBRbChlLCBcInR5cGVcIik7XG4gICAgICBpZiAoYykge1xuICAgICAgICBpZiAoYy50eXBlID09PSA3KVxuICAgICAgICAgIGEgPSBIcDtcbiAgICAgICAgZWxzZSBpZiAoYy52YWx1ZSlcbiAgICAgICAgICBzd2l0Y2ggKGMudmFsdWUuY29udGVudCkge1xuICAgICAgICAgICAgY2FzZSBcInJhZGlvXCI6XG4gICAgICAgICAgICAgIGEgPSBkXztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiY2hlY2tib3hcIjpcbiAgICAgICAgICAgICAgYSA9IGZfO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJmaWxlXCI6XG4gICAgICAgICAgICAgIGwgPSAhMCwgbi5vbkVycm9yKFxuICAgICAgICAgICAgICAgIGRyKFxuICAgICAgICAgICAgICAgICAgNTksXG4gICAgICAgICAgICAgICAgICB0LmxvY1xuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgaSgpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9IGVsc2VcbiAgICAgICAgTDQoZSkgPyBhID0gSHAgOiBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgaSgpO1xuICAgIH0gZWxzZVxuICAgICAgcyA9PT0gXCJzZWxlY3RcIiA/IGEgPSBwXyA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiAmJiBpKCk7XG4gICAgbCB8fCAoci5uZWVkUnVudGltZSA9IG4uaGVscGVyKGEpKTtcbiAgfSBlbHNlXG4gICAgbi5vbkVycm9yKFxuICAgICAgZHIoXG4gICAgICAgIDU3LFxuICAgICAgICB0LmxvY1xuICAgICAgKVxuICAgICk7XG4gIHJldHVybiByLnByb3BzID0gci5wcm9wcy5maWx0ZXIoXG4gICAgKGEpID0+ICEoYS5rZXkudHlwZSA9PT0gNCAmJiBhLmtleS5jb250ZW50ID09PSBcIm1vZGVsVmFsdWVcIilcbiAgKSwgcjtcbn0sIHBqID0gLyogQF9fUFVSRV9fICovIEJ0KFwicGFzc2l2ZSxvbmNlLGNhcHR1cmVcIiksIE9qID0gLyogQF9fUFVSRV9fICovIEJ0KFxuICAvLyBldmVudCBwcm9wYWdhdGlvbiBtYW5hZ2VtZW50XG4gIFwic3RvcCxwcmV2ZW50LHNlbGYsY3RybCxzaGlmdCxhbHQsbWV0YSxleGFjdCxtaWRkbGVcIlxuKSwgZ2ogPSAvKiBAX19QVVJFX18gKi8gQnQoXCJsZWZ0LHJpZ2h0XCIpLCB2XyA9IC8qIEBfX1BVUkVfXyAqLyBCdChcbiAgXCJvbmtleXVwLG9ua2V5ZG93bixvbmtleXByZXNzXCIsXG4gICEwXG4pLCBtaiA9ICh0LCBlLCBuLCByKSA9PiB7XG4gIGNvbnN0IGkgPSBbXSwgcyA9IFtdLCBvID0gW107XG4gIGZvciAobGV0IGEgPSAwOyBhIDwgZS5sZW5ndGg7IGErKykge1xuICAgIGNvbnN0IGwgPSBlW2FdO1xuICAgIGwgPT09IFwibmF0aXZlXCIgJiYgSm8oXG4gICAgICBcIkNPTVBJTEVSX1ZfT05fTkFUSVZFXCIsXG4gICAgICBuLFxuICAgICAgclxuICAgICkgfHwgcGoobCkgPyBvLnB1c2gobCkgOiBnaihsKSA/IHhuKHQpID8gdl8odC5jb250ZW50KSA/IGkucHVzaChsKSA6IHMucHVzaChsKSA6IChpLnB1c2gobCksIHMucHVzaChsKSkgOiBPaihsKSA/IHMucHVzaChsKSA6IGkucHVzaChsKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGtleU1vZGlmaWVyczogaSxcbiAgICBub25LZXlNb2RpZmllcnM6IHMsXG4gICAgZXZlbnRPcHRpb25Nb2RpZmllcnM6IG9cbiAgfTtcbn0sIHV5ID0gKHQsIGUpID0+IHhuKHQpICYmIHQuY29udGVudC50b0xvd2VyQ2FzZSgpID09PSBcIm9uY2xpY2tcIiA/IEVlKGUsICEwKSA6IHQudHlwZSAhPT0gNCA/IHByKFtcbiAgXCIoXCIsXG4gIHQsXG4gIGApID09PSBcIm9uQ2xpY2tcIiA/IFwiJHtlfVwiIDogKGAsXG4gIHQsXG4gIFwiKVwiXG5dKSA6IHQsIGJqID0gKHQsIGUsIG4pID0+IGNfKHQsIGUsIG4sIChyKSA9PiB7XG4gIGNvbnN0IHsgbW9kaWZpZXJzOiBpIH0gPSB0O1xuICBpZiAoIWkubGVuZ3RoKVxuICAgIHJldHVybiByO1xuICBsZXQgeyBrZXk6IHMsIHZhbHVlOiBvIH0gPSByLnByb3BzWzBdO1xuICBjb25zdCB7IGtleU1vZGlmaWVyczogYSwgbm9uS2V5TW9kaWZpZXJzOiBsLCBldmVudE9wdGlvbk1vZGlmaWVyczogYyB9ID0gbWoocywgaSwgbiwgdC5sb2MpO1xuICBpZiAobC5pbmNsdWRlcyhcInJpZ2h0XCIpICYmIChzID0gdXkocywgXCJvbkNvbnRleHRtZW51XCIpKSwgbC5pbmNsdWRlcyhcIm1pZGRsZVwiKSAmJiAocyA9IHV5KHMsIFwib25Nb3VzZXVwXCIpKSwgbC5sZW5ndGggJiYgKG8gPSBEdChuLmhlbHBlcihPXyksIFtcbiAgICBvLFxuICAgIEpTT04uc3RyaW5naWZ5KGwpXG4gIF0pKSwgYS5sZW5ndGggJiYgLy8gaWYgZXZlbnQgbmFtZSBpcyBkeW5hbWljLCBhbHdheXMgd3JhcCB3aXRoIGtleXMgZ3VhcmRcbiAgKCF4bihzKSB8fCB2XyhzLmNvbnRlbnQpKSAmJiAobyA9IER0KG4uaGVscGVyKGdfKSwgW1xuICAgIG8sXG4gICAgSlNPTi5zdHJpbmdpZnkoYSlcbiAgXSkpLCBjLmxlbmd0aCkge1xuICAgIGNvbnN0IHUgPSBjLm1hcChXcikuam9pbihcIlwiKTtcbiAgICBzID0geG4ocykgPyBFZShgJHtzLmNvbnRlbnR9JHt1fWAsICEwKSA6IHByKFtcIihcIiwgcywgYCkgKyBcIiR7dX1cImBdKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHByb3BzOiBbeXQocywgbyldXG4gIH07XG59KSwgdmogPSAodCwgZSwgbikgPT4ge1xuICBjb25zdCB7IGV4cDogciwgbG9jOiBpIH0gPSB0O1xuICByZXR1cm4gciB8fCBuLm9uRXJyb3IoXG4gICAgZHIoNjEsIGkpXG4gICksIHtcbiAgICBwcm9wczogW10sXG4gICAgbmVlZFJ1bnRpbWU6IG4uaGVscGVyKG1fKVxuICB9O1xufSwgeWogPSAodCwgZSkgPT4ge1xuICBpZiAodC50eXBlID09PSAxICYmIHQudGFnVHlwZSA9PT0gMSAmJiBlLmlzQnVpbHRJbkNvbXBvbmVudCh0LnRhZykgPT09IEZnKVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAoIXQuY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICByZXR1cm47XG4gICAgICB5Xyh0KSAmJiBlLm9uRXJyb3IoXG4gICAgICAgIGRyKFxuICAgICAgICAgIDYyLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHN0YXJ0OiB0LmNoaWxkcmVuWzBdLmxvYy5zdGFydCxcbiAgICAgICAgICAgIGVuZDogdC5jaGlsZHJlblt0LmNoaWxkcmVuLmxlbmd0aCAtIDFdLmxvYy5lbmQsXG4gICAgICAgICAgICBzb3VyY2U6IFwiXCJcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICBjb25zdCByID0gdC5jaGlsZHJlblswXTtcbiAgICAgIGlmIChyLnR5cGUgPT09IDEpXG4gICAgICAgIGZvciAoY29uc3QgaSBvZiByLnByb3BzKVxuICAgICAgICAgIGkudHlwZSA9PT0gNyAmJiBpLm5hbWUgPT09IFwic2hvd1wiICYmIHQucHJvcHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiA2LFxuICAgICAgICAgICAgbmFtZTogXCJwZXJzaXN0ZWRcIixcbiAgICAgICAgICAgIG5hbWVMb2M6IHQubG9jLFxuICAgICAgICAgICAgdmFsdWU6IHZvaWQgMCxcbiAgICAgICAgICAgIGxvYzogdC5sb2NcbiAgICAgICAgICB9KTtcbiAgICB9O1xufTtcbmZ1bmN0aW9uIHlfKHQpIHtcbiAgY29uc3QgZSA9IHQuY2hpbGRyZW4gPSB0LmNoaWxkcmVuLmZpbHRlcihcbiAgICAocikgPT4gci50eXBlICE9PSAzICYmICEoci50eXBlID09PSAyICYmICFyLmNvbnRlbnQudHJpbSgpKVxuICApLCBuID0gZVswXTtcbiAgcmV0dXJuIGUubGVuZ3RoICE9PSAxIHx8IG4udHlwZSA9PT0gMTEgfHwgbi50eXBlID09PSA5ICYmIG4uYnJhbmNoZXMuc29tZSh5Xyk7XG59XG5jb25zdCBTaiA9ICh0LCBlKSA9PiB7XG4gIHQudHlwZSA9PT0gMSAmJiB0LnRhZ1R5cGUgPT09IDAgJiYgKHQudGFnID09PSBcInNjcmlwdFwiIHx8IHQudGFnID09PSBcInN0eWxlXCIpICYmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgZS5vbkVycm9yKFxuICAgIGRyKFxuICAgICAgNjMsXG4gICAgICB0LmxvY1xuICAgIClcbiAgKSwgZS5yZW1vdmVOb2RlKCkpO1xufSwgd2ogPSBbXG4gIGxqLFxuICAuLi5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBbeWpdIDogW11cbl0sIGtqID0ge1xuICBjbG9hazogc2osXG4gIGh0bWw6IGRqLFxuICB0ZXh0OiBmaixcbiAgbW9kZWw6IGhqLFxuICAvLyBvdmVycmlkZSBjb21waWxlci1jb3JlXG4gIG9uOiBiaixcbiAgLy8gb3ZlcnJpZGUgY29tcGlsZXItY29yZVxuICBzaG93OiB2alxufTtcbmZ1bmN0aW9uIHhqKHQsIGUgPSB7fSkge1xuICByZXR1cm4gaWooXG4gICAgdCxcbiAgICAkZSh7fSwgYWosIGUsIHtcbiAgICAgIG5vZGVUcmFuc2Zvcm1zOiBbXG4gICAgICAgIC8vIGlnbm9yZSA8c2NyaXB0PiBhbmQgPHRhZz5cbiAgICAgICAgLy8gdGhpcyBpcyBub3QgcHV0IGluc2lkZSBET01Ob2RlVHJhbnNmb3JtcyBiZWNhdXNlIHRoYXQgbGlzdCBpcyB1c2VkXG4gICAgICAgIC8vIGJ5IGNvbXBpbGVyLXNzciB0byBnZW5lcmF0ZSB2bm9kZSBmYWxsYmFjayBicmFuY2hlc1xuICAgICAgICBTaixcbiAgICAgICAgLi4ud2osXG4gICAgICAgIC4uLmUubm9kZVRyYW5zZm9ybXMgfHwgW11cbiAgICAgIF0sXG4gICAgICBkaXJlY3RpdmVUcmFuc2Zvcm1zOiAkZShcbiAgICAgICAge30sXG4gICAgICAgIGtqLFxuICAgICAgICBlLmRpcmVjdGl2ZVRyYW5zZm9ybXMgfHwge31cbiAgICAgICksXG4gICAgICB0cmFuc2Zvcm1Ib2lzdDogbnVsbFxuICAgIH0pXG4gICk7XG59XG4vKipcbiogdnVlIHYzLjQuMjFcbiogKGMpIDIwMTgtcHJlc2VudCBZdXhpIChFdmFuKSBZb3UgYW5kIFZ1ZSBjb250cmlidXRvcnNcbiogQGxpY2Vuc2UgTUlUXG4qKi9cbmZ1bmN0aW9uIFBqKCkge1xuICBDTygpO1xufVxucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIFBqKCk7XG5jb25zdCBkeSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gX2oodCkge1xuICBsZXQgZSA9IGR5LmdldCh0ID8/IFZlKTtcbiAgcmV0dXJuIGUgfHwgKGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgZHkuc2V0KHQgPz8gVmUsIGUpKSwgZTtcbn1cbmZ1bmN0aW9uIFRqKHQsIGUpIHtcbiAgaWYgKCF3ZSh0KSlcbiAgICBpZiAodC5ub2RlVHlwZSlcbiAgICAgIHQgPSB0LmlubmVySFRNTDtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmIFh0KFwiaW52YWxpZCB0ZW1wbGF0ZSBvcHRpb246IFwiLCB0KSwgaXQ7XG4gIGNvbnN0IG4gPSB0LCByID0gX2ooZSksIGkgPSByW25dO1xuICBpZiAoaSlcbiAgICByZXR1cm4gaTtcbiAgaWYgKHRbMF0gPT09IFwiI1wiKSB7XG4gICAgY29uc3QgYyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodCk7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmICFjICYmIFh0KGBUZW1wbGF0ZSBlbGVtZW50IG5vdCBmb3VuZCBvciBpcyBlbXB0eTogJHt0fWApLCB0ID0gYyA/IGMuaW5uZXJIVE1MIDogXCJcIjtcbiAgfVxuICBjb25zdCBzID0gJGUoXG4gICAge1xuICAgICAgaG9pc3RTdGF0aWM6ICEwLFxuICAgICAgb25FcnJvcjogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gYSA6IHZvaWQgMCxcbiAgICAgIG9uV2FybjogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gKGMpID0+IGEoYywgITApIDogaXRcbiAgICB9LFxuICAgIGVcbiAgKTtcbiAgIXMuaXNDdXN0b21FbGVtZW50ICYmIHR5cGVvZiBjdXN0b21FbGVtZW50cyA8IFwidVwiICYmIChzLmlzQ3VzdG9tRWxlbWVudCA9IChjKSA9PiAhIWN1c3RvbUVsZW1lbnRzLmdldChjKSk7XG4gIGNvbnN0IHsgY29kZTogbyB9ID0geGoodCwgcyk7XG4gIGZ1bmN0aW9uIGEoYywgdSA9ICExKSB7XG4gICAgY29uc3QgZCA9IHUgPyBjLm1lc3NhZ2UgOiBgVGVtcGxhdGUgY29tcGlsYXRpb24gZXJyb3I6ICR7Yy5tZXNzYWdlfWAsIGYgPSBjLmxvYyAmJiBNXyhcbiAgICAgIHQsXG4gICAgICBjLmxvYy5zdGFydC5vZmZzZXQsXG4gICAgICBjLmxvYy5lbmQub2Zmc2V0XG4gICAgKTtcbiAgICBYdChmID8gYCR7ZH1cbiR7Zn1gIDogZCk7XG4gIH1cbiAgY29uc3QgbCA9IG5ldyBGdW5jdGlvbihcIlZ1ZVwiLCBvKSh5USk7XG4gIHJldHVybiBsLl9yYyA9ICEwLCByW25dID0gbDtcbn1cbk0xKFRqKTtcbmdsb2JhbFRoaXMuX19WVUVfT1BUSU9OU19BUElfXyA9ICEwO1xuZ2xvYmFsVGhpcy5fX1ZVRV9QUk9EX0hZRFJBVElPTl9NSVNNQVRDSF9ERVRBSUxTX18gPSAhMDtcbmdsb2JhbFRoaXMuX19WVUVfUFJPRF9ERVZUT09MU19fID0gITE7XG5jb25zdCBFaiA9ICh0KSA9PiB7XG4gIGNvbnN0IGUgPSAkXyhudWxsKTtcbiAgcmV0dXJuIHJoKCgpID0+IHtcbiAgICBpZiAoIWUuY3VycmVudClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBuID0gaFMoXzQsIHtcbiAgICAgIHByb3h5VXJsOiB0LnByb3h5XG4gICAgfSk7XG4gICAgcmV0dXJuIG4ubW91bnQoZS5jdXJyZW50KSwgKCkgPT4gbi51bm1vdW50KCk7XG4gIH0sIFtlXSksIC8qIEBfX1BVUkVfXyAqLyBIci5qc3goXCJkaXZcIiwgeyByZWY6IGUgfSk7XG59LCB7IHJlc2V0QWN0aXZlUmVzcG9uc2U6ICRqLCBzZXRBY3RpdmVSZXF1ZXN0OiBRaiB9ID0gc3IoKSwgSWogPSAoe1xuICBwcm94eTogdCA9IFwiXCIsXG4gIGNsb3NlOiBlLFxuICBpc09wZW46IG4gPSAhMSxcbiAgcmVxdWVzdDogclxufSkgPT4ge1xuICByaCgoKSA9PiB7XG4gICAgJGooKSwgciAmJiBRaihyKTtcbiAgfSwgW24sIHJdKTtcbiAgY29uc3QgW2ksIHNdID0gUV8oXCJcIik7XG4gIHJldHVybiByaCgoKSA9PiBzKHdpbmRvdy5sb2NhdGlvbi5ob3N0KSwgW10pLCAvKiBAX19QVVJFX18gKi8gSHIuanN4KFxuICAgIFwiZGl2XCIsXG4gICAge1xuICAgICAgY2xhc3NOYW1lOiBcInNjYWxhclwiLFxuICAgICAgc3R5bGU6IHsgZGlzcGxheTogbiA/IFwiYmxvY2tcIiA6IFwibm9uZVwiIH0sXG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIEhyLmpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic2NhbGFyLWNvbnRhaW5lclwiLCBjaGlsZHJlbjogW1xuICAgICAgICAvKiBAX19QVVJFX18gKi8gSHIuanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJzY2FsYXItYXBwXCIsIGNoaWxkcmVuOiBbXG4gICAgICAgICAgLyogQF9fUFVSRV9fICovIEhyLmpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwic2NhbGFyLWFwcC1oZWFkZXJcIiwgY2hpbGRyZW46IFtcbiAgICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBIci5qc3goXCJzcGFuXCIsIHsgY2hpbGRyZW46IFwiQVBJIENsaWVudFwiIH0pLFxuICAgICAgICAgICAgLyogQF9fUFVSRV9fICovIEhyLmpzeChcbiAgICAgICAgICAgICAgXCJhXCIsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBocmVmOiBgaHR0cHM6Ly93d3cuc2NhbGFyLmNvbT91dG1fY2FtcGFpZ249JHtpfWAsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBcIl9ibGFua1wiLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIlBvd2VyZWQgYnkgc2NhbGFyLmNvbVwiXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIClcbiAgICAgICAgICBdIH0pLFxuICAgICAgICAgIC8qIEBfX1BVUkVfXyAqLyBIci5qc3goRWosIHsgcHJveHk6IHQgfSlcbiAgICAgICAgXSB9KSxcbiAgICAgICAgLyogQF9fUFVSRV9fICovIEhyLmpzeChcbiAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG9uQ2xpY2s6IGUsXG4gICAgICAgICAgICBjbGFzc05hbWU6IFwic2NhbGFyLWFwcC1leGl0XCJcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIF0gfSlcbiAgICB9XG4gICk7XG59O1xuZXhwb3J0IHtcbiAgSWogYXMgQSxcbiAgRCBhcyBhLFxuICBXbCBhcyBiLFxuICBuZSBhcyBjLFxuICBFaiBhcyBkLFxuICBaIGFzIG9cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/index-DG086FZT.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@scalar/api-client-react/dist/index.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApiClientReact: function() { return /* reexport safe */ _index_DG086FZT_js__WEBPACK_IMPORTED_MODULE_0__.A; },\n/* harmony export */   ApiClientReactBase: function() { return /* reexport safe */ _index_DG086FZT_js__WEBPACK_IMPORTED_MODULE_0__.d; }\n/* harmony export */ });\n/* harmony import */ var _index_DG086FZT_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-DG086FZT.js */ \"(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/index-DG086FZT.js\");\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2NhbGFyL2FwaS1jbGllbnQtcmVhY3QvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBcUQ7QUFJbkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzY2FsYXIvYXBpLWNsaWVudC1yZWFjdC9kaXN0L2luZGV4LmpzP2JjNTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQSBhcyB0LCBkIGFzIGkgfSBmcm9tIFwiLi9pbmRleC1ERzA4NkZaVC5qc1wiO1xuZXhwb3J0IHtcbiAgdCBhcyBBcGlDbGllbnRSZWFjdCxcbiAgaSBhcyBBcGlDbGllbnRSZWFjdEJhc2Vcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@scalar/api-client-react/dist/index.js\n"));

/***/ })

}]);