'use client';

import { AIMessageRole } from '@gitbook/api';
import * as React from 'react';
import { streamAsk } from './server-actions';

export type AskMessage = {
    role: AIMessageRole;
    content: React.ReactNode;
};

export type AskSession = {
    /**
     * The title of the ask session.
     * It can be auto-generated by the AI or an initial value.
     */
    title: string;

    /**
     * ID of the latest AI response.
     */
    responseId: string | null;

    /**
     * Messages in the session.
     */
    messages: AskMessage[];

    /**
     * If true, the session is in progress.
     */
    loading: boolean;
};

export type AskState = {
    opened: boolean;
    session: AskSession;
};

export type AskController = {
    /** Open the dialog */
    open: () => void;

    /** Close the dialog */
    close: () => void;

    /** Post a message to the session */
    postMessage: (input: {
        /** If defined, the title of the session will be updated. */
        title?: string;
        /** The message to post to the session. */
        message: string;
    }) => void;
};

const AskStateContext = React.createContext<AskState | null>(null);
const AskControllerContext = React.createContext<AskController | null>(null);

export function AskStateProvider(props: React.PropsWithChildren) {
    const { children } = props;

    const [state, setState] = React.useState<AskState>({
        opened: false,
        session: {
            title: '',
            responseId: null,
            messages: [],
            loading: false,
        },
    });

    const stateRef = React.useRef<AskState>(state);
    stateRef.current = state;

    const controller = React.useMemo(() => {
        return {
            open: () => {
                setState((previous) => {
                    return {
                        ...previous,
                        opened: true,
                    };
                });
            },
            close: () => {
                setState((previous) => {
                    return {
                        ...previous,
                        opened: false,
                    };
                });
            },
            postMessage: async (input: { title?: string; message: string }) => {
                try {
                    const stream = await streamAsk({
                        query: input.message,
                        previousResponseId: stateRef.current.session.responseId ?? undefined,
                    });

                    setState((previous) => {
                        return {
                            ...previous,
                            session: {
                                ...previous.session,
                                messages: [
                                    ...previous.session.messages,
                                    {
                                        role: AIMessageRole.User,
                                        content: input.message,
                                    },
                                    {
                                        role: AIMessageRole.Assistant,
                                        content: null,
                                    },
                                ],
                            },
                        };
                    });

                    for await (const data of stream) {
                        if (!data) continue;

                        if (data.responseId) {
                            setState((previous) => {
                                return {
                                    ...previous,
                                    session: {
                                        ...previous.session,
                                        responseId: data.responseId,
                                    },
                                };
                            });
                        }

                        if (data.output) {
                            setState((previous) => {
                                return {
                                    ...previous,
                                    session: {
                                        ...previous.session,
                                        messages: [
                                            ...previous.session.messages.slice(0, -1),
                                            {
                                                role: AIMessageRole.Assistant,
                                                content: data.output,
                                            },
                                        ],
                                    },
                                };
                            });
                        }
                    }
                } catch (error) {
                    console.error('Error in summary stream:', error);
                }
            },
        };
    }, []);

    return (
        <AskStateContext.Provider value={state}>
            <AskControllerContext.Provider value={controller}>
                {children}
            </AskControllerContext.Provider>
        </AskStateContext.Provider>
    );
}

/**
 * Get the current state of the ask session.
 */
export function useAskState(): AskState {
    const context = React.useContext(AskStateContext);
    if (!context) {
        throw new Error('useAskState must be used within a AskStateProvider');
    }
    return context;
}

/**
 * Get the controller to interact with the ask session.
 */
export function useAskController(): AskController {
    const context = React.useContext(AskControllerContext);
    if (!context) {
        throw new Error('useAskController must be used within a AskStateProvider');
    }
    return context;
}
